.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 8BD55E7149812997911299B8CA4DF247
.rdata:00000000 ; Input CRC32 : 0F58A775
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\TabBar.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000000 _rdata          segment para public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; const WCHAR _SG123346
.rdata:00000000 $SG123346:                              ; DATA XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+CFo
.rdata:00000000                 unicode 0, <Tab>,0
.rdata:00000008 ; const WCHAR _SG123347
.rdata:00000008 $SG123347:                              ; DATA XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+D4o
.rdata:00000008                 unicode 0, <SysTabControl32>,0
.rdata:00000028 ; char _SG123351[]
.rdata:00000028 $SG123351       db 'TabBar::init : CreateWindowEx() function return null',0
.rdata:00000028                                         ; DATA XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+F0o
.rdata:0000005D                 align 10h
.rdata:00000060 ; const WCHAR _SG123455
.rdata:00000060 $SG123455:                              ; DATA XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+F7o
.rdata:00000060                 unicode 0, <Tab>,0
.rdata:00000068 ; const WCHAR _SG123456
.rdata:00000068 $SG123456:                              ; DATA XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+FCo
.rdata:00000068                 unicode 0, <SysTabControl32>,0
.rdata:00000088 ; char _SG123460[]
.rdata:00000088 $SG123460       db 'TabBarPlus::init : CreateWindowEx() function return null',0
.rdata:00000088                                         ; DATA XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+118o
.rdata:000000C1                 align 4
.rdata:000000C4 ; const WCHAR _SG123461
.rdata:000000C4 $SG123461:                              ; DATA XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+157o
.rdata:000000C4                 unicode 0, <tooltips_class32>,0
.rdata:000000E6                 align 4
.rdata:000000E8 ; char _SG123465[]
.rdata:000000E8 $SG123465       db 'TabBarPlus::init : tooltip CreateWindowEx() function return null',0
.rdata:000000E8                                         ; DATA XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+173o
.rdata:00000129                 align 4
.rdata:0000012C ; const WCHAR _SG123670
.rdata:0000012C $SG123670       dw 0                    ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+5Ao
.rdata:0000012E                 align 10h
.rdata:00000130 ; char _SG123479[]
.rdata:00000130 $SG123479       db 'TabBarPlus::init : Tab Control error - Tab Control # is over its '
.rdata:00000130                                         ; DATA XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+247o
.rdata:00000130                 db 'limit',0
.rdata:00000177                 align 4
.rdata:00000178 ; const WCHAR _SG123671
.rdata:00000178 $SG123671:                              ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+5Fo
.rdata:00000178                 unicode 0, <nTab >
.rdata:00000178                 dw 3Ch
.rdata:00000178                 unicode 0, < 0>,0
.rdata:0000018A                 align 4
.rdata:0000018C ; const WCHAR _SG123677
.rdata:0000018C $SG123677       dw 0                    ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+F8o
.rdata:0000018E                 align 10h
.rdata:00000190 ; const WCHAR _SG123678
.rdata:00000190 $SG123678:                              ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+FDo
.rdata:00000190                 unicode 0, <! TCM_GETITEM>,0
.rdata:000001AC ; const WCHAR _SG123725
.rdata:000001AC $SG123725       dd offset $SG123347+18h ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+5B3o
.rdata:000001AC                                         ; "l32"
.rdata:000001B0 ; const WCHAR _SG123778
.rdata:000001B0 $SG123778:                              ; DATA XREF: TabBarPlus::draggingCursor(tagPOINT)+70o
.rdata:000001B0                 unicode 0, <Scintilla>,0
.rdata:000001C4 ; const WCHAR _SG123779
.rdata:000001C4 $SG123779:                              ; DATA XREF: TabBarPlus::draggingCursor(tagPOINT)+86o
.rdata:000001C4                 unicode 0, <SysTabControl32>,0
.rdata:000001C4 _rdata          ends
.rdata:000001C4
.bss:000001E4 ; ===========================================================================
.bss:000001E4
.bss:000001E4 ; Segment type: Uninitialized
.bss:000001E4 ; Segment permissions: Read/Write
.bss:000001E4 _bss            segment dword public 'BSS' use32
.bss:000001E4                 assume cs:_bss
.bss:000001E4                 ;org 1E4h
.bss:000001E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000001E4                 public ?_doDragNDrop@TabBarPlus@@1_NA
.bss:000001E4 ; protected: static bool TabBarPlus::_doDragNDrop
.bss:000001E4 ?_doDragNDrop@TabBarPlus@@1_NA db ?     ; DATA XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long):loc_1134r
.bss:000001E5                 public ?_drawTabCloseButton@TabBarPlus@@1_NA
.bss:000001E5 ; protected: static bool TabBarPlus::_drawTabCloseButton
.bss:000001E5 ?_drawTabCloseButton@TabBarPlus@@1_NA db ?
.bss:000001E5                                         ; DATA XREF: TabBarPlus::doOwnerDrawTab(void)+E5r
.bss:000001E5                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long):$LN33r ...
.bss:000001E6                 public ?_isDbClk2Close@TabBarPlus@@1_NA
.bss:000001E6 ; protected: static bool TabBarPlus::_isDbClk2Close
.bss:000001E6 ?_isDbClk2Close@TabBarPlus@@1_NA db ?   ; DATA XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long):$LN2_0r
.bss:000001E7                 public ?_isCtrlVertical@TabBarPlus@@1_NA
.bss:000001E7 ; protected: static bool TabBarPlus::_isCtrlVertical
.bss:000001E7 ?_isCtrlVertical@TabBarPlus@@1_NA db ?  ; DATA XREF: TabBarPlus::isVertical(void)+3r
.bss:000001E8                 public ?_isCtrlMultiLine@TabBarPlus@@1_NA
.bss:000001E8 ; protected: static bool TabBarPlus::_isCtrlMultiLine
.bss:000001E8 ?_isCtrlMultiLine@TabBarPlus@@1_NA db ? ; DATA XREF: TabBarPlus::isMultiLine(void)+3r
.bss:000001E9                 align 4
.bss:000001EC                 public ?_nbCtrl@TabBarPlus@@1HA
.bss:000001EC ; protected: static int TabBarPlus::_nbCtrl
.bss:000001EC ?_nbCtrl@TabBarPlus@@1HA dd ?           ; DATA XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+1BEr
.bss:000001EC                                         ; TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+1CEr ...
.bss:000001F0                 public ?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A
.bss:000001F0 ; HWND TabBarPlus::_hwndArray
.bss:000001F0 ?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A dd ?
.bss:000001F0                                         ; DATA XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+1C4r
.bss:000001F0                                         ; TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+1DAw ...
.bss:000001F4                 db    ? ;
.bss:000001F5                 db    ? ;
.bss:000001F6                 db    ? ;
.bss:000001F7                 db    ? ;
.bss:000001F8                 db    ? ;
.bss:000001F9                 db    ? ;
.bss:000001FA                 db    ? ;
.bss:000001FB                 db    ? ;
.bss:000001FC                 db    ? ;
.bss:000001FD                 db    ? ;
.bss:000001FE                 db    ? ;
.bss:000001FF                 db    ? ;
.bss:00000200                 db    ? ;
.bss:00000201                 db    ? ;
.bss:00000202                 db    ? ;
.bss:00000203                 db    ? ;
.bss:00000204                 db    ? ;
.bss:00000205                 db    ? ;
.bss:00000206                 db    ? ;
.bss:00000207                 db    ? ;
.bss:00000208                 db    ? ;
.bss:00000209                 db    ? ;
.bss:0000020A                 db    ? ;
.bss:0000020B                 db    ? ;
.bss:0000020C                 db    ? ;
.bss:0000020D                 db    ? ;
.bss:0000020E                 db    ? ;
.bss:0000020F                 db    ? ;
.bss:00000210                 db    ? ;
.bss:00000211                 db    ? ;
.bss:00000212                 db    ? ;
.bss:00000213                 db    ? ;
.bss:00000214                 db    ? ;
.bss:00000215                 db    ? ;
.bss:00000216                 db    ? ;
.bss:00000217                 db    ? ;
.bss:00000218 _allocator_arg  db    ? ;
.bss:00000219 _piecewise_construct db    ? ;
.bss:0000021A                 db    ? ;
.bss:0000021B                 db    ? ;
.bss:0000021C                 public ?_activeTextColour@TabBarPlus@@1KA
.bss:0000021C ; COLORREF TabBarPlus::_activeTextColour
.bss:0000021C ?_activeTextColour@TabBarPlus@@1KA dd ? ; DATA XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex)+1Dw
.bss:0000021C                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+9F5r ...
.bss:0000021C _bss            ends
.bss:0000021C
.data:00000220 ; ===========================================================================
.data:00000220
.data:00000220 ; Segment type: Pure data
.data:00000220 ; Segment permissions: Read/Write
.data:00000220 _data           segment dword public 'DATA' use32
.data:00000220                 assume cs:_data
.data:00000220                 ;org 220h
.data:00000220                 public ?_drawInactiveTab@TabBarPlus@@1_NA
.data:00000220 ; protected: static bool TabBarPlus::_drawInactiveTab
.data:00000220 ?_drawInactiveTab@TabBarPlus@@1_NA db 1 ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *):loc_1C64r
.data:00000221                 public ?_drawTopBar@TabBarPlus@@1_NA
.data:00000221 ; protected: static bool TabBarPlus::_drawTopBar
.data:00000221 ?_drawTopBar@TabBarPlus@@1_NA db 1      ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+184r
.data:00000222                 align 4
.data:00000224                 public ?_activeTopBarFocusedColour@TabBarPlus@@1KA
.data:00000224 ; COLORREF TabBarPlus::_activeTopBarFocusedColour
.data:00000224 ?_activeTopBarFocusedColour@TabBarPlus@@1KA dd 3CAAFAh
.data:00000224                                         ; DATA XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex)+28w
.data:00000224                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+26Er
.data:00000228                 public ?_activeTopBarUnfocusedColour@TabBarPlus@@1KA
.data:00000228 ; COLORREF TabBarPlus::_activeTopBarUnfocusedColour
.data:00000228 ?_activeTopBarUnfocusedColour@TabBarPlus@@1KA dd 96D2FAh
.data:00000228                                         ; DATA XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex)+32w
.data:00000228                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *):loc_1C27r
.data:0000022C                 public ?_inactiveTextColour@TabBarPlus@@1KA
.data:0000022C ; COLORREF TabBarPlus::_inactiveTextColour
.data:0000022C ?_inactiveTextColour@TabBarPlus@@1KA dd 808080h
.data:0000022C                                         ; DATA XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex)+3Dw
.data:0000022C                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *):loc_24C8r
.data:00000230                 public ?_inactiveBgColour@TabBarPlus@@1KA
.data:00000230 ; COLORREF TabBarPlus::_inactiveBgColour
.data:00000230 ?_inactiveBgColour@TabBarPlus@@1KA dd 0C0C0C0h
.data:00000230                                         ; DATA XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex)+48w
.data:00000230                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+2FBr
.data:00000230 _data           ends
.data:00000230
.text$mn:00000234 ; ===========================================================================
.text$mn:00000234
.text$mn:00000234 ; Segment type: Pure code
.text$mn:00000234 ; Segment permissions: Read/Execute
.text$mn:00000234 _text$mn        segment para public 'CODE' use32
.text$mn:00000234                 assume cs:_text$mn
.text$mn:00000234                 ;org 234h
.text$mn:00000234                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000234
.text$mn:00000234 ; =============== S U B R O U T I N E =======================================
.text$mn:00000234
.text$mn:00000234 ; Attributes: bp-based frame
.text$mn:00000234
.text$mn:00000234 ; void __thiscall TabBar::destroy(TabBar *__hidden this)
.text$mn:00000234                 public ?destroy@TabBar@@UAEXXZ
.text$mn:00000234 ?destroy@TabBar@@UAEXXZ proc near       ; CODE XREF: TabBarPlus::destroy(void)+Ap
.text$mn:00000234
.text$mn:00000234 var_4           = dword ptr -4
.text$mn:00000234
.text$mn:00000234                 push    ebp
.text$mn:00000235                 mov     ebp, esp
.text$mn:00000237                 push    ecx
.text$mn:00000238                 mov     [ebp+var_4], ecx
.text$mn:0000023B                 mov     eax, [ebp+var_4]
.text$mn:0000023E                 cmp     dword ptr [eax+18h], 0
.text$mn:00000242                 jz      short loc_251
.text$mn:00000244                 mov     ecx, [ebp+var_4]
.text$mn:00000247                 mov     edx, [ecx+18h]
.text$mn:0000024A                 push    edx             ; ho
.text$mn:0000024B                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00000251
.text$mn:00000251 loc_251:                                ; CODE XREF: TabBar::destroy(void)+Ej
.text$mn:00000251                 mov     eax, [ebp+var_4]
.text$mn:00000254                 cmp     dword ptr [eax+1Ch], 0
.text$mn:00000258                 jz      short loc_267
.text$mn:0000025A                 mov     ecx, [ebp+var_4]
.text$mn:0000025D                 mov     edx, [ecx+1Ch]
.text$mn:00000260                 push    edx             ; ho
.text$mn:00000261                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00000267
.text$mn:00000267 loc_267:                                ; CODE XREF: TabBar::destroy(void)+24j
.text$mn:00000267                 mov     eax, [ebp+var_4]
.text$mn:0000026A                 cmp     dword ptr [eax+20h], 0
.text$mn:0000026E                 jz      short loc_27D
.text$mn:00000270                 mov     ecx, [ebp+var_4]
.text$mn:00000273                 mov     edx, [ecx+20h]
.text$mn:00000276                 push    edx             ; ho
.text$mn:00000277                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:0000027D
.text$mn:0000027D loc_27D:                                ; CODE XREF: TabBar::destroy(void)+3Aj
.text$mn:0000027D                 mov     eax, [ebp+var_4]
.text$mn:00000280                 cmp     dword ptr [eax+24h], 0
.text$mn:00000284                 jz      short loc_293
.text$mn:00000286                 mov     ecx, [ebp+var_4]
.text$mn:00000289                 mov     edx, [ecx+24h]
.text$mn:0000028C                 push    edx             ; ho
.text$mn:0000028D                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00000293
.text$mn:00000293 loc_293:                                ; CODE XREF: TabBar::destroy(void)+50j
.text$mn:00000293                 mov     eax, [ebp+var_4]
.text$mn:00000296                 mov     ecx, [eax+0Ch]
.text$mn:00000299                 push    ecx             ; hWnd
.text$mn:0000029A                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:000002A0                 mov     edx, [ebp+var_4]
.text$mn:000002A3                 mov     dword ptr [edx+0Ch], 0
.text$mn:000002AA                 mov     esp, ebp
.text$mn:000002AC                 pop     ebp
.text$mn:000002AD                 retn
.text$mn:000002AD ?destroy@TabBar@@UAEXXZ endp
.text$mn:000002AD
.text$mn:000002AD ; ---------------------------------------------------------------------------
.text$mn:000002AE                 db 6 dup(0CCh)
.text$mn:000002B4
.text$mn:000002B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000002B4
.text$mn:000002B4 ; Attributes: bp-based frame
.text$mn:000002B4
.text$mn:000002B4 ; void __thiscall TabBar::init(TabBar *this, HINSTANCE, HWND, bool, bool, bool)
.text$mn:000002B4                 public ?init@TabBar@@UAEXPAUHINSTANCE__@@PAUHWND__@@_N22@Z
.text$mn:000002B4 ?init@TabBar@@UAEXPAUHINSTANCE__@@PAUHWND__@@_N22@Z proc near
.text$mn:000002B4
.text$mn:000002B4 var_30          = byte ptr -30h
.text$mn:000002B4 picce           = INITCOMMONCONTROLSEX ptr -24h
.text$mn:000002B4 dwStyle         = dword ptr -1Ch
.text$mn:000002B4 var_18          = dword ptr -18h
.text$mn:000002B4 var_14          = dword ptr -14h
.text$mn:000002B4 var_10          = dword ptr -10h
.text$mn:000002B4 var_C           = dword ptr -0Ch
.text$mn:000002B4 var_8           = dword ptr -8
.text$mn:000002B4 var_4           = dword ptr -4
.text$mn:000002B4 arg_0           = dword ptr  8
.text$mn:000002B4 arg_4           = dword ptr  0Ch
.text$mn:000002B4 arg_8           = byte ptr  10h
.text$mn:000002B4 arg_C           = byte ptr  14h
.text$mn:000002B4 arg_10          = byte ptr  18h
.text$mn:000002B4
.text$mn:000002B4                 push    ebp
.text$mn:000002B5                 mov     ebp, esp
.text$mn:000002B7                 sub     esp, 30h
.text$mn:000002BA                 mov     [ebp+var_4], ecx
.text$mn:000002BD                 mov     eax, [ebp+arg_4]
.text$mn:000002C0                 push    eax             ; HWND
.text$mn:000002C1                 mov     ecx, [ebp+arg_0]
.text$mn:000002C4                 push    ecx             ; HINSTANCE
.text$mn:000002C5                 mov     ecx, [ebp+var_4] ; this
.text$mn:000002C8                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:000002CD                 movzx   edx, [ebp+arg_8]
.text$mn:000002D1                 test    edx, edx
.text$mn:000002D3                 jz      short loc_2DE
.text$mn:000002D5                 mov     [ebp+var_8], 280h
.text$mn:000002DC                 jmp     short loc_2E5
.text$mn:000002DE ; ---------------------------------------------------------------------------
.text$mn:000002DE
.text$mn:000002DE loc_2DE:                                ; CODE XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+1Fj
.text$mn:000002DE                 mov     [ebp+var_8], 0
.text$mn:000002E5
.text$mn:000002E5 loc_2E5:                                ; CODE XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+28j
.text$mn:000002E5                 mov     eax, [ebp+var_8]
.text$mn:000002E8                 mov     [ebp+var_14], eax
.text$mn:000002EB                 mov     ecx, [ebp+var_4]
.text$mn:000002EE                 mov     dl, [ebp+arg_C]
.text$mn:000002F1                 mov     [ecx+2Ch], dl
.text$mn:000002F4                 mov     eax, [ebp+var_4]
.text$mn:000002F7                 mov     cl, [ebp+arg_8]
.text$mn:000002FA                 mov     [eax+2Dh], cl
.text$mn:000002FD                 mov     edx, [ebp+var_4]
.text$mn:00000300                 mov     al, [ebp+arg_10]
.text$mn:00000303                 mov     [edx+2Eh], al
.text$mn:00000306                 mov     [ebp+picce.dwSize], 8
.text$mn:0000030D                 mov     [ebp+picce.dwICC], 8
.text$mn:00000314                 lea     ecx, [ebp+picce]
.text$mn:00000317                 push    ecx             ; picce
.text$mn:00000318                 call    dword ptr ds:__imp__InitCommonControlsEx@4 ; InitCommonControlsEx(x)
.text$mn:0000031E                 movzx   edx, [ebp+arg_10]
.text$mn:00000322                 test    edx, edx
.text$mn:00000324                 jz      short loc_349
.text$mn:00000326                 mov     eax, [ebp+var_4]
.text$mn:00000329                 movzx   ecx, byte ptr [eax+2Ch]
.text$mn:0000032D                 test    ecx, ecx
.text$mn:0000032F                 jz      short loc_33A
.text$mn:00000331                 mov     [ebp+var_C], 200h
.text$mn:00000338                 jmp     short loc_341
.text$mn:0000033A ; ---------------------------------------------------------------------------
.text$mn:0000033A
.text$mn:0000033A loc_33A:                                ; CODE XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+7Bj
.text$mn:0000033A                 mov     [ebp+var_C], 0
.text$mn:00000341
.text$mn:00000341 loc_341:                                ; CODE XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+84j
.text$mn:00000341                 mov     edx, [ebp+var_C]
.text$mn:00000344                 mov     [ebp+var_10], edx
.text$mn:00000347                 jmp     short loc_350
.text$mn:00000349 ; ---------------------------------------------------------------------------
.text$mn:00000349
.text$mn:00000349 loc_349:                                ; CODE XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+70j
.text$mn:00000349                 mov     [ebp+var_10], 0
.text$mn:00000350
.text$mn:00000350 loc_350:                                ; CODE XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+93j
.text$mn:00000350                 mov     eax, [ebp+var_10]
.text$mn:00000353                 mov     [ebp+var_18], eax
.text$mn:00000356                 mov     ecx, [ebp+var_14]
.text$mn:00000359                 or      ecx, 56018000h
.text$mn:0000035F                 or      ecx, [ebp+var_18]
.text$mn:00000362                 mov     [ebp+dwStyle], ecx
.text$mn:00000365                 push    0               ; lpParam
.text$mn:00000367                 mov     edx, [ebp+var_4]
.text$mn:0000036A                 mov     eax, [edx+4]
.text$mn:0000036D                 push    eax             ; hInstance
.text$mn:0000036E                 push    0               ; hMenu
.text$mn:00000370                 mov     ecx, [ebp+var_4]
.text$mn:00000373                 mov     edx, [ecx+8]
.text$mn:00000376                 push    edx             ; hWndParent
.text$mn:00000377                 push    0               ; nHeight
.text$mn:00000379                 push    0               ; nWidth
.text$mn:0000037B                 push    0               ; Y
.text$mn:0000037D                 push    0               ; X
.text$mn:0000037F                 mov     eax, [ebp+dwStyle]
.text$mn:00000382                 push    eax             ; dwStyle
.text$mn:00000383                 push    offset $SG123346 ; "Tab"
.text$mn:00000388                 push    offset $SG123347 ; "SysTabControl32"
.text$mn:0000038D                 push    0               ; dwExStyle
.text$mn:0000038F                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:00000395                 mov     ecx, [ebp+var_4]
.text$mn:00000398                 mov     [ecx+0Ch], eax
.text$mn:0000039B                 mov     edx, [ebp+var_4]
.text$mn:0000039E                 cmp     dword ptr [edx+0Ch], 0
.text$mn:000003A2                 jnz     short loc_3BF
.text$mn:000003A4                 push    offset $SG123351 ; "TabBar::init : CreateWindowEx() functio"...
.text$mn:000003A9                 lea     ecx, [ebp+var_30] ; this
.text$mn:000003AC                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:000003B1                 push    offset __TI2?AVruntime_error@std@@
.text$mn:000003B6                 lea     eax, [ebp+var_30]
.text$mn:000003B9                 push    eax
.text$mn:000003BA                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000003BF ; ---------------------------------------------------------------------------
.text$mn:000003BF
.text$mn:000003BF loc_3BF:                                ; CODE XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+EEj
.text$mn:000003BF                 mov     esp, ebp
.text$mn:000003C1                 pop     ebp
.text$mn:000003C2                 retn    14h
.text$mn:000003C2 ?init@TabBar@@UAEXPAUHINSTANCE__@@PAUHWND__@@_N22@Z endp
.text$mn:000003C2
.text$mn:000003C2 ; ---------------------------------------------------------------------------
.text$mn:000003C5                 db 0Fh dup(0CCh)
.text$mn:000003D4
.text$mn:000003D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000003D4
.text$mn:000003D4 ; Attributes: bp-based frame
.text$mn:000003D4
.text$mn:000003D4 ; void __thiscall TabBar::reSizeTo(TabBar *this, struct tagRECT *)
.text$mn:000003D4                 public ?reSizeTo@TabBar@@UAEXAAUtagRECT@@@Z
.text$mn:000003D4 ?reSizeTo@TabBar@@UAEXAAUtagRECT@@@Z proc near
.text$mn:000003D4
.text$mn:000003D4 var_34          = dword ptr -34h
.text$mn:000003D4 var_30          = dword ptr -30h
.text$mn:000003D4 var_2C          = dword ptr -2Ch
.text$mn:000003D4 var_25          = byte ptr -25h
.text$mn:000003D4 var_24          = tagRECT ptr -24h
.text$mn:000003D4 lParam          = dword ptr -14h
.text$mn:000003D4 var_10          = dword ptr -10h
.text$mn:000003D4 var_C           = dword ptr -0Ch
.text$mn:000003D4 var_8           = dword ptr -8
.text$mn:000003D4 var_4           = dword ptr -4
.text$mn:000003D4 arg_0           = dword ptr  8
.text$mn:000003D4
.text$mn:000003D4                 push    ebp
.text$mn:000003D5                 mov     ebp, esp
.text$mn:000003D7                 sub     esp, 34h
.text$mn:000003DA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000003DF                 xor     eax, ebp
.text$mn:000003E1                 mov     [ebp+var_4], eax
.text$mn:000003E4                 mov     [ebp+var_30], ecx
.text$mn:000003E7                 mov     eax, [ebp+arg_0]
.text$mn:000003EA                 cmp     dword ptr [eax+8], 0Ah
.text$mn:000003EE                 jle     short loc_3F6
.text$mn:000003F0                 mov     [ebp+var_25], 1
.text$mn:000003F4                 jmp     short loc_3FA
.text$mn:000003F6 ; ---------------------------------------------------------------------------
.text$mn:000003F6
.text$mn:000003F6 loc_3F6:                                ; CODE XREF: TabBar::reSizeTo(tagRECT &)+1Aj
.text$mn:000003F6                 mov     [ebp+var_25], 0
.text$mn:000003FA
.text$mn:000003FA loc_3FA:                                ; CODE XREF: TabBar::reSizeTo(tagRECT &)+20j
.text$mn:000003FA                 movzx   ecx, [ebp+var_25]
.text$mn:000003FE                 push    ecx
.text$mn:000003FF                 mov     edx, [ebp+var_30]
.text$mn:00000402                 mov     eax, [edx]
.text$mn:00000404                 mov     ecx, [ebp+var_30]
.text$mn:00000407                 mov     edx, [eax+0Ch]
.text$mn:0000040A                 call    edx
.text$mn:0000040C                 mov     eax, [ebp+arg_0]
.text$mn:0000040F                 mov     ecx, [eax]
.text$mn:00000411                 mov     [ebp+var_24.left], ecx
.text$mn:00000414                 mov     edx, [eax+4]
.text$mn:00000417                 mov     [ebp+var_24.top], edx
.text$mn:0000041A                 mov     ecx, [eax+8]
.text$mn:0000041D                 mov     [ebp+var_24.right], ecx
.text$mn:00000420                 mov     edx, [eax+0Ch]
.text$mn:00000423                 mov     [ebp+var_24.bottom], edx
.text$mn:00000426                 lea     eax, [ebp+var_24]
.text$mn:00000429                 push    eax             ; struct tagRECT *
.text$mn:0000042A                 mov     ecx, [ebp+var_30] ; this
.text$mn:0000042D                 call    ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.text$mn:00000432                 push    0               ; lParam
.text$mn:00000434                 push    0               ; wParam
.text$mn:00000436                 push    132Ch           ; Msg
.text$mn:0000043B                 mov     ecx, [ebp+var_30]
.text$mn:0000043E                 mov     edx, [ecx+0Ch]
.text$mn:00000441                 push    edx             ; hWnd
.text$mn:00000442                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000448                 mov     [ebp+var_34], eax
.text$mn:0000044B                 lea     eax, [ebp+lParam]
.text$mn:0000044E                 push    eax             ; lParam
.text$mn:0000044F                 push    0               ; wParam
.text$mn:00000451                 push    130Ah           ; Msg
.text$mn:00000456                 mov     ecx, [ebp+var_30]
.text$mn:00000459                 mov     edx, [ecx+0Ch]
.text$mn:0000045C                 push    edx             ; hWnd
.text$mn:0000045D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000463                 mov     eax, [ebp+var_30]
.text$mn:00000466                 movzx   ecx, byte ptr [eax+2Ch]
.text$mn:0000046A                 test    ecx, ecx
.text$mn:0000046C                 jz      short loc_488
.text$mn:0000046E                 mov     edx, [ebp+arg_0]
.text$mn:00000471                 push    edx             ; lParam
.text$mn:00000472                 push    0               ; wParam
.text$mn:00000474                 push    1328h           ; Msg
.text$mn:00000479                 mov     eax, [ebp+var_30]
.text$mn:0000047C                 mov     ecx, [eax+0Ch]
.text$mn:0000047F                 push    ecx             ; hWnd
.text$mn:00000480                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000486                 jmp     short loc_505
.text$mn:00000488 ; ---------------------------------------------------------------------------
.text$mn:00000488
.text$mn:00000488 loc_488:                                ; CODE XREF: TabBar::reSizeTo(tagRECT &)+98j
.text$mn:00000488                 mov     edx, [ebp+var_30]
.text$mn:0000048B                 movzx   eax, byte ptr [edx+2Dh]
.text$mn:0000048F                 test    eax, eax
.text$mn:00000491                 jz      short loc_4CC
.text$mn:00000493                 mov     ecx, [ebp+var_C]
.text$mn:00000496                 sub     ecx, [ebp+lParam]
.text$mn:00000499                 imul    ecx, [ebp+var_34]
.text$mn:0000049D                 mov     [ebp+var_2C], ecx
.text$mn:000004A0                 push    2Dh ; '-'       ; nIndex
.text$mn:000004A2                 call    dword ptr ds:__imp__GetSystemMetrics@4 ; GetSystemMetrics(x)
.text$mn:000004A8                 add     eax, [ebp+var_2C]
.text$mn:000004AB                 mov     [ebp+var_2C], eax
.text$mn:000004AE                 mov     edx, [ebp+arg_0]
.text$mn:000004B1                 mov     eax, [edx]
.text$mn:000004B3                 add     eax, [ebp+var_2C]
.text$mn:000004B6                 mov     ecx, [ebp+arg_0]
.text$mn:000004B9                 mov     [ecx], eax
.text$mn:000004BB                 mov     edx, [ebp+arg_0]
.text$mn:000004BE                 mov     eax, [edx+8]
.text$mn:000004C1                 sub     eax, [ebp+var_2C]
.text$mn:000004C4                 mov     ecx, [ebp+arg_0]
.text$mn:000004C7                 mov     [ecx+8], eax
.text$mn:000004CA                 jmp     short loc_505
.text$mn:000004CC ; ---------------------------------------------------------------------------
.text$mn:000004CC
.text$mn:000004CC loc_4CC:                                ; CODE XREF: TabBar::reSizeTo(tagRECT &)+BDj
.text$mn:000004CC                 mov     edx, [ebp+var_8]
.text$mn:000004CF                 sub     edx, [ebp+var_10]
.text$mn:000004D2                 imul    edx, [ebp+var_34]
.text$mn:000004D6                 mov     [ebp+var_2C], edx
.text$mn:000004D9                 push    2Eh ; '.'       ; nIndex
.text$mn:000004DB                 call    dword ptr ds:__imp__GetSystemMetrics@4 ; GetSystemMetrics(x)
.text$mn:000004E1                 add     eax, [ebp+var_2C]
.text$mn:000004E4                 mov     [ebp+var_2C], eax
.text$mn:000004E7                 mov     eax, [ebp+arg_0]
.text$mn:000004EA                 mov     ecx, [eax+4]
.text$mn:000004ED                 add     ecx, [ebp+var_2C]
.text$mn:000004F0                 mov     edx, [ebp+arg_0]
.text$mn:000004F3                 mov     [edx+4], ecx
.text$mn:000004F6                 mov     eax, [ebp+arg_0]
.text$mn:000004F9                 mov     ecx, [eax+0Ch]
.text$mn:000004FC                 sub     ecx, [ebp+var_2C]
.text$mn:000004FF                 mov     edx, [ebp+arg_0]
.text$mn:00000502                 mov     [edx+0Ch], ecx
.text$mn:00000505
.text$mn:00000505 loc_505:                                ; CODE XREF: TabBar::reSizeTo(tagRECT &)+B2j
.text$mn:00000505                                         ; TabBar::reSizeTo(tagRECT &)+F6j
.text$mn:00000505                 mov     ecx, [ebp+var_4]
.text$mn:00000508                 xor     ecx, ebp
.text$mn:0000050A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000050F                 mov     esp, ebp
.text$mn:00000511                 pop     ebp
.text$mn:00000512                 retn    4
.text$mn:00000512 ?reSizeTo@TabBar@@UAEXAAUtagRECT@@@Z endp
.text$mn:00000512
.text$mn:00000512 ; ---------------------------------------------------------------------------
.text$mn:00000515                 db 0Fh dup(0CCh)
.text$mn:00000524
.text$mn:00000524 ; =============== S U B R O U T I N E =======================================
.text$mn:00000524
.text$mn:00000524 ; Attributes: bp-based frame
.text$mn:00000524
.text$mn:00000524 ; int __thiscall TabBar::insertAtEnd(TabBar *this, const wchar_t *)
.text$mn:00000524                 public ?insertAtEnd@TabBar@@QAEHPB_W@Z
.text$mn:00000524 ?insertAtEnd@TabBar@@QAEHPB_W@Z proc near
.text$mn:00000524
.text$mn:00000524 lParam          = dword ptr -28h
.text$mn:00000524 var_1C          = dword ptr -1Ch
.text$mn:00000524 var_14          = dword ptr -14h
.text$mn:00000524 wParam          = dword ptr -0Ch
.text$mn:00000524 var_8           = dword ptr -8
.text$mn:00000524 var_4           = dword ptr -4
.text$mn:00000524 arg_0           = dword ptr  8
.text$mn:00000524
.text$mn:00000524                 push    ebp
.text$mn:00000525                 mov     ebp, esp
.text$mn:00000527                 sub     esp, 28h
.text$mn:0000052A                 mov     [ebp+var_4], ecx
.text$mn:0000052D                 mov     [ebp+lParam], 3
.text$mn:00000534                 mov     [ebp+var_8], 0FFFFFFFFh
.text$mn:0000053B                 mov     eax, [ebp+var_4]
.text$mn:0000053E                 movzx   ecx, byte ptr [eax+14h]
.text$mn:00000542                 test    ecx, ecx
.text$mn:00000544                 jz      short loc_54D
.text$mn:00000546                 mov     [ebp+var_8], 0
.text$mn:0000054D
.text$mn:0000054D loc_54D:                                ; CODE XREF: TabBar::insertAtEnd(wchar_t const *)+20j
.text$mn:0000054D                 mov     edx, [ebp+var_8]
.text$mn:00000550                 mov     [ebp+var_14], edx
.text$mn:00000553                 mov     eax, [ebp+arg_0]
.text$mn:00000556                 mov     [ebp+var_1C], eax
.text$mn:00000559                 mov     ecx, [ebp+var_4]
.text$mn:0000055C                 mov     edx, [ecx+10h]
.text$mn:0000055F                 mov     [ebp+wParam], edx
.text$mn:00000562                 mov     eax, [ebp+var_4]
.text$mn:00000565                 mov     ecx, [eax+10h]
.text$mn:00000568                 add     ecx, 1
.text$mn:0000056B                 mov     edx, [ebp+var_4]
.text$mn:0000056E                 mov     [edx+10h], ecx
.text$mn:00000571                 lea     eax, [ebp+lParam]
.text$mn:00000574                 push    eax             ; lParam
.text$mn:00000575                 mov     ecx, [ebp+wParam]
.text$mn:00000578                 push    ecx             ; wParam
.text$mn:00000579                 push    133Eh           ; DATA XREF: TabBarPlus::draggingCursor(tagPOINT):loc_26C4o
.text$mn:00000579                                         ; TabBarPlus::draggingCursor(tagPOINT)+108o
.text$mn:00000579                                         ; Msg
.text$mn:0000057E
.text$mn:0000057E ; const WCHAR CursorName
.text$mn:0000057E CursorName:                             ; DATA XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+6A3o
.text$mn:0000057E                                         ; TabBarPlus::draggingCursor(tagPOINT)+B2o ...
.text$mn:0000057E                 mov     edx, [ebp+var_4]
.text$mn:00000581                 mov     eax, [edx+0Ch]
.text$mn:00000584                 push    eax             ; hWnd
.text$mn:00000585                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000058B                 mov     esp, ebp
.text$mn:0000058D                 pop     ebp
.text$mn:0000058E                 retn    4
.text$mn:0000058E ?insertAtEnd@TabBar@@QAEHPB_W@Z endp
.text$mn:0000058E
.text$mn:0000058E ; ---------------------------------------------------------------------------
.text$mn:00000591                 align 4
.text$mn:00000594
.text$mn:00000594 ; =============== S U B R O U T I N E =======================================
.text$mn:00000594
.text$mn:00000594 ; Attributes: bp-based frame
.text$mn:00000594
.text$mn:00000594 ; void __thiscall TabBar::activateAt(TabBar *this, int)
.text$mn:00000594                 public ?activateAt@TabBar@@QBEXH@Z
.text$mn:00000594 ?activateAt@TabBar@@QBEXH@Z proc near
.text$mn:00000594
.text$mn:00000594 var_14          = dword ptr -14h
.text$mn:00000594 var_10          = dword ptr -10h
.text$mn:00000594 var_C           = dword ptr -0Ch
.text$mn:00000594 var_8           = dword ptr -8
.text$mn:00000594 var_4           = dword ptr -4
.text$mn:00000594 wParam          = dword ptr  8
.text$mn:00000594
.text$mn:00000594                 push    ebp
.text$mn:00000595                 mov     ebp, esp
.text$mn:00000597                 sub     esp, 14h
.text$mn:0000059A                 mov     [ebp+var_4], ecx
.text$mn:0000059D                 mov     ecx, [ebp+var_4] ; this
.text$mn:000005A0                 call    ?getCurrentTabIndex@TabBar@@QBEHXZ ; TabBar::getCurrentTabIndex(void)
.text$mn:000005A5                 cmp     eax, [ebp+wParam]
.text$mn:000005A8                 jz      short loc_5C2
.text$mn:000005AA                 push    0               ; lParam
.text$mn:000005AC                 mov     eax, [ebp+wParam]
.text$mn:000005AF                 push    eax             ; wParam
.text$mn:000005B0                 push    130Ch           ; Msg
.text$mn:000005B5                 mov     ecx, [ebp+var_4]
.text$mn:000005B8                 mov     edx, [ecx+0Ch]
.text$mn:000005BB                 push    edx             ; hWnd
.text$mn:000005BC                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000005C2
.text$mn:000005C2 loc_5C2:                                ; CODE XREF: TabBar::activateAt(int)+14j
.text$mn:000005C2                 mov     eax, [ebp+var_4]
.text$mn:000005C5                 mov     ecx, [eax+0Ch]
.text$mn:000005C8                 mov     [ebp+var_14], ecx
.text$mn:000005CB                 mov     [ebp+var_C], 0FFFFFDD9h
.text$mn:000005D2                 mov     edx, [ebp+var_4]
.text$mn:000005D5                 mov     [ebp+var_10], edx
.text$mn:000005D8                 mov     eax, [ebp+wParam]
.text$mn:000005DB                 mov     [ebp+var_8], eax
.text$mn:000005DE                 mov     esp, ebp
.text$mn:000005E0                 pop     ebp
.text$mn:000005E1                 retn    4
.text$mn:000005E1 ?activateAt@TabBar@@QBEXH@Z endp
.text$mn:000005E1
.text$mn:000005E4
.text$mn:000005E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000005E4
.text$mn:000005E4 ; Attributes: bp-based frame
.text$mn:000005E4
.text$mn:000005E4 ; void __thiscall TabBar::getCurrentTitle(TabBar *this, wchar_t *, int)
.text$mn:000005E4                 public ?getCurrentTitle@TabBar@@QAEXPA_WH@Z
.text$mn:000005E4 ?getCurrentTitle@TabBar@@QAEXPA_WH@Z proc near
.text$mn:000005E4
.text$mn:000005E4 lParam          = dword ptr -20h
.text$mn:000005E4 var_14          = dword ptr -14h
.text$mn:000005E4 var_10          = dword ptr -10h
.text$mn:000005E4 var_4           = dword ptr -4
.text$mn:000005E4 arg_0           = dword ptr  8
.text$mn:000005E4 arg_4           = dword ptr  0Ch
.text$mn:000005E4
.text$mn:000005E4                 push    ebp
.text$mn:000005E5                 mov     ebp, esp
.text$mn:000005E7                 sub     esp, 20h
.text$mn:000005EA                 mov     [ebp+var_4], ecx
.text$mn:000005ED                 mov     [ebp+lParam], 1
.text$mn:000005F4                 mov     eax, [ebp+arg_0]
.text$mn:000005F7                 mov     [ebp+var_14], eax
.text$mn:000005FA                 mov     ecx, [ebp+arg_4]
.text$mn:000005FD                 sub     ecx, 1
.text$mn:00000600                 mov     [ebp+var_10], ecx
.text$mn:00000603                 lea     edx, [ebp+lParam]
.text$mn:00000606                 push    edx             ; lParam
.text$mn:00000607                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000060A                 call    ?getCurrentTabIndex@TabBar@@QBEHXZ ; TabBar::getCurrentTabIndex(void)
.text$mn:0000060F                 push    eax             ; wParam
.text$mn:00000610                 push    133Ch           ; Msg
.text$mn:00000615                 mov     eax, [ebp+var_4]
.text$mn:00000618                 mov     ecx, [eax+0Ch]
.text$mn:0000061B                 push    ecx             ; hWnd
.text$mn:0000061C                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000622                 mov     esp, ebp
.text$mn:00000624                 pop     ebp
.text$mn:00000625                 retn    8
.text$mn:00000625 ?getCurrentTitle@TabBar@@QAEXPA_WH@Z endp
.text$mn:00000625
.text$mn:00000625 ; ---------------------------------------------------------------------------
.text$mn:00000628                 db 0Ch dup(0CCh)
.text$mn:00000634
.text$mn:00000634 ; =============== S U B R O U T I N E =======================================
.text$mn:00000634
.text$mn:00000634 ; Attributes: bp-based frame
.text$mn:00000634
.text$mn:00000634 ; void __thiscall TabBar::deletItemAt(TabBar *this, unsigned int)
.text$mn:00000634                 public ?deletItemAt@TabBar@@QAEXI@Z
.text$mn:00000634 ?deletItemAt@TabBar@@QAEXI@Z proc near
.text$mn:00000634
.text$mn:00000634 var_1C          = dword ptr -1Ch
.text$mn:00000634 var_18          = dword ptr -18h
.text$mn:00000634 lParam          = dword ptr -14h
.text$mn:00000634 var_4           = dword ptr -4
.text$mn:00000634 wParam          = dword ptr  8
.text$mn:00000634
.text$mn:00000634                 push    ebp
.text$mn:00000635                 mov     ebp, esp
.text$mn:00000637                 sub     esp, 1Ch
.text$mn:0000063A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000063F                 xor     eax, ebp
.text$mn:00000641                 mov     [ebp+var_4], eax
.text$mn:00000644                 mov     [ebp+var_18], ecx
.text$mn:00000647                 mov     eax, [ebp+var_18]
.text$mn:0000064A                 mov     ecx, [eax+10h]
.text$mn:0000064D                 sub     ecx, 1
.text$mn:00000650                 cmp     [ebp+wParam], ecx
.text$mn:00000653                 jnz     loc_6E1
.text$mn:00000659                 mov     edx, [ebp+var_18]
.text$mn:0000065C                 cmp     dword ptr [edx+10h], 1
.text$mn:00000660                 jbe     short loc_6E1
.text$mn:00000662                 lea     eax, [ebp+lParam]
.text$mn:00000665                 push    eax             ; lParam
.text$mn:00000666                 mov     ecx, [ebp+wParam]
.text$mn:00000669                 push    ecx             ; wParam
.text$mn:0000066A                 push    130Ah           ; Msg
.text$mn:0000066F                 mov     edx, [ebp+var_18]
.text$mn:00000672                 mov     eax, [edx+0Ch]
.text$mn:00000675                 push    eax             ; hWnd
.text$mn:00000676                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000067C                 cmp     [ebp+lParam], 5
.text$mn:00000680                 jge     short loc_6E1
.text$mn:00000682                 mov     ecx, [ebp+wParam]
.text$mn:00000685                 sub     ecx, 1
.text$mn:00000688                 and     ecx, 0FFFFh
.text$mn:0000068E                 movzx   edx, cx
.text$mn:00000691                 shl     edx, 10h
.text$mn:00000694                 or      edx, 4
.text$mn:00000697                 mov     [ebp+var_1C], edx
.text$mn:0000069A                 push    0               ; lParam
.text$mn:0000069C                 mov     eax, [ebp+var_1C]
.text$mn:0000069F                 push    eax             ; wParam
.text$mn:000006A0                 push    114h            ; Msg
.text$mn:000006A5                 mov     ecx, [ebp+var_18]
.text$mn:000006A8                 mov     edx, [ecx+0Ch]
.text$mn:000006AB                 push    edx             ; hWnd
.text$mn:000006AC                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000006B2                 mov     eax, [ebp+wParam]
.text$mn:000006B5                 sub     eax, 1
.text$mn:000006B8                 and     eax, 0FFFFh
.text$mn:000006BD                 movzx   ecx, ax
.text$mn:000006C0                 shl     ecx, 10h
.text$mn:000006C3                 or      ecx, 8
.text$mn:000006C6                 mov     [ebp+var_1C], ecx
.text$mn:000006C9                 push    0               ; lParam
.text$mn:000006CB                 mov     edx, [ebp+var_1C]
.text$mn:000006CE                 push    edx             ; wParam
.text$mn:000006CF                 push    114h            ; Msg
.text$mn:000006D4                 mov     eax, [ebp+var_18]
.text$mn:000006D7                 mov     ecx, [eax+0Ch]
.text$mn:000006DA                 push    ecx             ; hWnd
.text$mn:000006DB                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000006E1
.text$mn:000006E1 loc_6E1:                                ; CODE XREF: TabBar::deletItemAt(uint)+1Fj
.text$mn:000006E1                                         ; TabBar::deletItemAt(uint)+2Cj ...
.text$mn:000006E1                 push    0               ; lParam
.text$mn:000006E3                 mov     edx, [ebp+wParam]
.text$mn:000006E6                 push    edx             ; wParam
.text$mn:000006E7                 push    1308h           ; Msg
.text$mn:000006EC                 mov     eax, [ebp+var_18]
.text$mn:000006EF                 mov     ecx, [eax+0Ch]
.text$mn:000006F2                 push    ecx             ; hWnd
.text$mn:000006F3                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000006F9                 mov     edx, [ebp+var_18]
.text$mn:000006FC                 mov     eax, [edx+10h]
.text$mn:000006FF                 sub     eax, 1
.text$mn:00000702                 mov     ecx, [ebp+var_18]
.text$mn:00000705                 mov     [ecx+10h], eax
.text$mn:00000708                 mov     ecx, [ebp+var_4]
.text$mn:0000070B                 xor     ecx, ebp
.text$mn:0000070D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000712                 mov     esp, ebp
.text$mn:00000714                 pop     ebp
.text$mn:00000715                 retn    4
.text$mn:00000715 ?deletItemAt@TabBar@@QAEXI@Z endp
.text$mn:00000715
.text$mn:00000715 ; ---------------------------------------------------------------------------
.text$mn:00000718                 db 0Ch dup(0CCh)
.text$mn:00000724
.text$mn:00000724 ; =============== S U B R O U T I N E =======================================
.text$mn:00000724
.text$mn:00000724 ; Attributes: bp-based frame
.text$mn:00000724
.text$mn:00000724 ; void __thiscall TabBar::setFont(TabBar *this, LPCWSTR pszFaceName, unsigned int)
.text$mn:00000724                 public ?setFont@TabBar@@QAEXPA_WI@Z
.text$mn:00000724 ?setFont@TabBar@@QAEXPA_WI@Z proc near
.text$mn:00000724
.text$mn:00000724 cEscapement     = dword ptr -0Ch
.text$mn:00000724 cOrientation    = dword ptr -8
.text$mn:00000724 var_4           = dword ptr -4
.text$mn:00000724 pszFaceName     = dword ptr  8
.text$mn:00000724 cHeight         = dword ptr  0Ch
.text$mn:00000724
.text$mn:00000724                 push    ebp
.text$mn:00000725                 mov     ebp, esp
.text$mn:00000727                 sub     esp, 0Ch
.text$mn:0000072A                 mov     [ebp+var_4], ecx
.text$mn:0000072D                 mov     eax, [ebp+var_4]
.text$mn:00000730                 cmp     dword ptr [eax+18h], 0
.text$mn:00000734                 jz      short loc_743
.text$mn:00000736                 mov     ecx, [ebp+var_4]
.text$mn:00000739                 mov     edx, [ecx+18h]
.text$mn:0000073C                 push    edx             ; ho
.text$mn:0000073D                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00000743
.text$mn:00000743 loc_743:                                ; CODE XREF: TabBar::setFont(wchar_t *,uint)+10j
.text$mn:00000743                 mov     eax, [ebp+var_4]
.text$mn:00000746                 movzx   ecx, byte ptr [eax+2Dh]
.text$mn:0000074A                 test    ecx, ecx
.text$mn:0000074C                 jz      short loc_757
.text$mn:0000074E                 mov     [ebp+cOrientation], 384h
.text$mn:00000755                 jmp     short loc_75E
.text$mn:00000757 ; ---------------------------------------------------------------------------
.text$mn:00000757
.text$mn:00000757 loc_757:                                ; CODE XREF: TabBar::setFont(wchar_t *,uint)+28j
.text$mn:00000757                 mov     [ebp+cOrientation], 0
.text$mn:0000075E
.text$mn:0000075E loc_75E:                                ; CODE XREF: TabBar::setFont(wchar_t *,uint)+31j
.text$mn:0000075E                 mov     edx, [ebp+var_4]
.text$mn:00000761                 movzx   eax, byte ptr [edx+2Dh]
.text$mn:00000765                 test    eax, eax
.text$mn:00000767                 jz      short loc_772
.text$mn:00000769                 mov     [ebp+cEscapement], 384h
.text$mn:00000770                 jmp     short loc_779
.text$mn:00000772 ; ---------------------------------------------------------------------------
.text$mn:00000772
.text$mn:00000772 loc_772:                                ; CODE XREF: TabBar::setFont(wchar_t *,uint)+43j
.text$mn:00000772                 mov     [ebp+cEscapement], 0
.text$mn:00000779
.text$mn:00000779 loc_779:                                ; CODE XREF: TabBar::setFont(wchar_t *,uint)+4Cj
.text$mn:00000779                 mov     ecx, [ebp+pszFaceName]
.text$mn:0000077C                 push    ecx             ; pszFaceName
.text$mn:0000077D                 push    0               ; iPitchAndFamily
.text$mn:0000077F                 push    0               ; iQuality
.text$mn:00000781                 push    0               ; iClipPrecision
.text$mn:00000783                 push    0               ; iOutPrecision
.text$mn:00000785                 push    0               ; iCharSet
.text$mn:00000787                 push    0               ; bStrikeOut
.text$mn:00000789                 push    0               ; bUnderline
.text$mn:0000078B                 push    0               ; bItalic
.text$mn:0000078D                 push    190h            ; cWeight
.text$mn:00000792                 mov     edx, [ebp+cOrientation]
.text$mn:00000795                 push    edx             ; cOrientation
.text$mn:00000796                 mov     eax, [ebp+cEscapement]
.text$mn:00000799                 push    eax             ; cEscapement
.text$mn:0000079A                 push    0               ; cWidth
.text$mn:0000079C                 mov     ecx, [ebp+cHeight]
.text$mn:0000079F                 push    ecx             ; cHeight
.text$mn:000007A0                 call    dword ptr ds:__imp__CreateFontW@56 ; CreateFontW(x,x,x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:000007A6                 mov     edx, [ebp+var_4]
.text$mn:000007A9                 mov     [edx+18h], eax
.text$mn:000007AC                 mov     eax, [ebp+var_4]
.text$mn:000007AF                 cmp     dword ptr [eax+18h], 0
.text$mn:000007B3                 jz      short loc_7CD
.text$mn:000007B5                 push    0               ; lParam
.text$mn:000007B7                 mov     ecx, [ebp+var_4]
.text$mn:000007BA                 mov     edx, [ecx+18h]
.text$mn:000007BD                 push    edx             ; wParam
.text$mn:000007BE                 push    30h ; '0'       ; Msg
.text$mn:000007C0                 mov     eax, [ebp+var_4]
.text$mn:000007C3                 mov     ecx, [eax+0Ch]
.text$mn:000007C6                 push    ecx             ; hWnd
.text$mn:000007C7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000007CD
.text$mn:000007CD loc_7CD:                                ; CODE XREF: TabBar::setFont(wchar_t *,uint)+8Fj
.text$mn:000007CD                 mov     esp, ebp
.text$mn:000007CF                 pop     ebp
.text$mn:000007D0                 retn    8
.text$mn:000007D0 ?setFont@TabBar@@QAEXPA_WI@Z endp
.text$mn:000007D0
.text$mn:000007D0 ; ---------------------------------------------------------------------------
.text$mn:000007D3                 align 4
.text$mn:000007D4
.text$mn:000007D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000007D4
.text$mn:000007D4 ; Attributes: bp-based frame
.text$mn:000007D4
.text$mn:000007D4 ; public: __thiscall CloseButtonZone::CloseButtonZone(void)
.text$mn:000007D4                 public ??0CloseButtonZone@@QAE@XZ
.text$mn:000007D4 ??0CloseButtonZone@@QAE@XZ proc near
.text$mn:000007D4
.text$mn:000007D4 var_4           = dword ptr -4
.text$mn:000007D4
.text$mn:000007D4                 push    ebp
.text$mn:000007D5                 mov     ebp, esp
.text$mn:000007D7                 push    ecx
.text$mn:000007D8                 mov     [ebp+var_4], ecx
.text$mn:000007DB                 push    0Bh             ; int
.text$mn:000007DD                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000007E2                 add     eax, 0Ch
.text$mn:000007E5                 mov     ecx, eax        ; this
.text$mn:000007E7                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:000007EC                 mov     ecx, [ebp+var_4]
.text$mn:000007EF                 mov     [ecx], eax
.text$mn:000007F1                 push    0Bh             ; int
.text$mn:000007F3                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000007F8                 add     eax, 0Ch
.text$mn:000007FB                 mov     ecx, eax        ; this
.text$mn:000007FD                 call    ?scaleY@DPIManager@@QAEHH@Z ; DPIManager::scaleY(int)
.text$mn:00000802                 mov     edx, [ebp+var_4]
.text$mn:00000805                 mov     [edx+4], eax
.text$mn:00000808                 push    5               ; int
.text$mn:0000080A                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:0000080F                 add     eax, 0Ch
.text$mn:00000812                 mov     ecx, eax        ; this
.text$mn:00000814                 call    ?scaleY@DPIManager@@QAEHH@Z ; DPIManager::scaleY(int)
.text$mn:00000819                 mov     ecx, [ebp+var_4]
.text$mn:0000081C                 mov     [ecx+8], eax
.text$mn:0000081F                 push    3               ; int
.text$mn:00000821                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000826                 add     eax, 0Ch
.text$mn:00000829                 mov     ecx, eax        ; this
.text$mn:0000082B                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:00000830                 mov     edx, [ebp+var_4]
.text$mn:00000833                 mov     [edx+0Ch], eax
.text$mn:00000836                 mov     eax, [ebp+var_4]
.text$mn:00000839                 mov     esp, ebp
.text$mn:0000083B                 pop     ebp
.text$mn:0000083C                 retn
.text$mn:0000083C ??0CloseButtonZone@@QAE@XZ endp
.text$mn:0000083C
.text$mn:0000083C ; ---------------------------------------------------------------------------
.text$mn:0000083D                 db 7 dup(0CCh)
.text$mn:00000844
.text$mn:00000844 ; =============== S U B R O U T I N E =======================================
.text$mn:00000844
.text$mn:00000844 ; Attributes: bp-based frame
.text$mn:00000844
.text$mn:00000844 ; bool __thiscall CloseButtonZone::isHit(CloseButtonZone *this, int, int, const struct tagRECT *)
.text$mn:00000844                 public ?isHit@CloseButtonZone@@QBE_NHHABUtagRECT@@@Z
.text$mn:00000844 ?isHit@CloseButtonZone@@QBE_NHHABUtagRECT@@@Z proc near
.text$mn:00000844                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+185p
.text$mn:00000844                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long)+40Bp ...
.text$mn:00000844
.text$mn:00000844 var_4           = dword ptr -4
.text$mn:00000844 arg_0           = dword ptr  8
.text$mn:00000844 arg_4           = dword ptr  0Ch
.text$mn:00000844 arg_8           = dword ptr  10h
.text$mn:00000844
.text$mn:00000844                 push    ebp
.text$mn:00000845                 mov     ebp, esp
.text$mn:00000847                 push    ecx
.text$mn:00000848                 mov     [ebp+var_4], ecx
.text$mn:0000084B                 mov     eax, [ebp+var_4]
.text$mn:0000084E                 mov     ecx, [ebp+arg_0]
.text$mn:00000851                 add     ecx, [eax]
.text$mn:00000853                 mov     edx, [ebp+var_4]
.text$mn:00000856                 add     ecx, [edx+0Ch]
.text$mn:00000859                 mov     eax, [ebp+arg_8]
.text$mn:0000085C                 cmp     ecx, [eax+8]
.text$mn:0000085F                 jl      short loc_872
.text$mn:00000861                 mov     ecx, [ebp+arg_8]
.text$mn:00000864                 mov     edx, [ebp+var_4]
.text$mn:00000867                 mov     eax, [ecx+8]
.text$mn:0000086A                 sub     eax, [edx+0Ch]
.text$mn:0000086D                 cmp     [ebp+arg_0], eax
.text$mn:00000870                 jle     short loc_876
.text$mn:00000872
.text$mn:00000872 loc_872:                                ; CODE XREF: CloseButtonZone::isHit(int,int,tagRECT const &)+1Bj
.text$mn:00000872                 xor     al, al
.text$mn:00000874                 jmp     short loc_8A4
.text$mn:00000876 ; ---------------------------------------------------------------------------
.text$mn:00000876
.text$mn:00000876 loc_876:                                ; CODE XREF: CloseButtonZone::isHit(int,int,tagRECT const &)+2Cj
.text$mn:00000876                 mov     ecx, [ebp+var_4]
.text$mn:00000879                 mov     edx, [ebp+arg_4]
.text$mn:0000087C                 sub     edx, [ecx+4]
.text$mn:0000087F                 mov     eax, [ebp+var_4]
.text$mn:00000882                 sub     edx, [eax+8]
.text$mn:00000885                 mov     ecx, [ebp+arg_8]
.text$mn:00000888                 cmp     edx, [ecx+4]
.text$mn:0000088B                 jg      short loc_89E
.text$mn:0000088D                 mov     edx, [ebp+arg_8]
.text$mn:00000890                 mov     eax, [edx+4]
.text$mn:00000893                 mov     ecx, [ebp+var_4]
.text$mn:00000896                 add     eax, [ecx+8]
.text$mn:00000899                 cmp     [ebp+arg_4], eax
.text$mn:0000089C                 jge     short loc_8A2
.text$mn:0000089E
.text$mn:0000089E loc_89E:                                ; CODE XREF: CloseButtonZone::isHit(int,int,tagRECT const &)+47j
.text$mn:0000089E                 xor     al, al
.text$mn:000008A0                 jmp     short loc_8A4
.text$mn:000008A2 ; ---------------------------------------------------------------------------
.text$mn:000008A2
.text$mn:000008A2 loc_8A2:                                ; CODE XREF: CloseButtonZone::isHit(int,int,tagRECT const &)+58j
.text$mn:000008A2                 mov     al, 1
.text$mn:000008A4
.text$mn:000008A4 loc_8A4:                                ; CODE XREF: CloseButtonZone::isHit(int,int,tagRECT const &)+30j
.text$mn:000008A4                                         ; CloseButtonZone::isHit(int,int,tagRECT const &)+5Cj
.text$mn:000008A4                 mov     esp, ebp
.text$mn:000008A6                 pop     ebp
.text$mn:000008A7                 retn    0Ch
.text$mn:000008A7 ?isHit@CloseButtonZone@@QBE_NHHABUtagRECT@@@Z endp
.text$mn:000008A7
.text$mn:000008A7 ; ---------------------------------------------------------------------------
.text$mn:000008AA                 db 0Ah dup(0CCh)
.text$mn:000008B4
.text$mn:000008B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000008B4
.text$mn:000008B4 ; Attributes: bp-based frame
.text$mn:000008B4
.text$mn:000008B4 ; struct tagRECT *__thiscall CloseButtonZone::getButtonRectFrom(CloseButtonZone *this, struct tagRECT *retstr, const struct tagRECT *)
.text$mn:000008B4                 public ?getButtonRectFrom@CloseButtonZone@@QBE?AUtagRECT@@ABU2@@Z
.text$mn:000008B4 ?getButtonRectFrom@CloseButtonZone@@QBE?AUtagRECT@@ABU2@@Z proc near
.text$mn:000008B4                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+35Bp
.text$mn:000008B4
.text$mn:000008B4 var_18          = dword ptr -18h
.text$mn:000008B4 var_14          = dword ptr -14h
.text$mn:000008B4 var_10          = dword ptr -10h
.text$mn:000008B4 var_C           = dword ptr -0Ch
.text$mn:000008B4 var_8           = dword ptr -8
.text$mn:000008B4 var_4           = dword ptr -4
.text$mn:000008B4 retstr          = dword ptr  8
.text$mn:000008B4 arg_4           = dword ptr  0Ch
.text$mn:000008B4
.text$mn:000008B4                 push    ebp
.text$mn:000008B5                 mov     ebp, esp
.text$mn:000008B7                 sub     esp, 18h
.text$mn:000008BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000008BF                 xor     eax, ebp
.text$mn:000008C1                 mov     [ebp+var_4], eax
.text$mn:000008C4                 mov     [ebp+var_18], ecx
.text$mn:000008C7                 mov     eax, [ebp+arg_4]
.text$mn:000008CA                 mov     ecx, [ebp+var_18]
.text$mn:000008CD                 mov     edx, [eax+8]
.text$mn:000008D0                 sub     edx, [ecx+0Ch]
.text$mn:000008D3                 mov     [ebp+var_C], edx
.text$mn:000008D6                 mov     eax, [ebp+var_18]
.text$mn:000008D9                 mov     ecx, [ebp+var_C]
.text$mn:000008DC                 sub     ecx, [eax]
.text$mn:000008DE                 mov     [ebp+var_14], ecx
.text$mn:000008E1                 mov     edx, [ebp+arg_4]
.text$mn:000008E4                 mov     eax, [edx+4]
.text$mn:000008E7                 mov     ecx, [ebp+var_18]
.text$mn:000008EA                 add     eax, [ecx+8]
.text$mn:000008ED                 mov     [ebp+var_10], eax
.text$mn:000008F0                 mov     edx, [ebp+var_18]
.text$mn:000008F3                 mov     eax, [ebp+var_10]
.text$mn:000008F6                 add     eax, [edx+4]
.text$mn:000008F9                 mov     [ebp+var_8], eax
.text$mn:000008FC                 mov     ecx, [ebp+retstr]
.text$mn:000008FF                 mov     edx, [ebp+var_14]
.text$mn:00000902                 mov     [ecx], edx
.text$mn:00000904                 mov     eax, [ebp+var_10]
.text$mn:00000907                 mov     [ecx+4], eax
.text$mn:0000090A                 mov     edx, [ebp+var_C]
.text$mn:0000090D                 mov     [ecx+8], edx
.text$mn:00000910                 mov     eax, [ebp+var_8]
.text$mn:00000913                 mov     [ecx+0Ch], eax
.text$mn:00000916                 mov     eax, [ebp+retstr]
.text$mn:00000919                 mov     ecx, [ebp+var_4]
.text$mn:0000091C                 xor     ecx, ebp
.text$mn:0000091E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000923                 mov     esp, ebp
.text$mn:00000925                 pop     ebp
.text$mn:00000926                 retn    8
.text$mn:00000926 ?getButtonRectFrom@CloseButtonZone@@QBE?AUtagRECT@@ABU2@@Z endp
.text$mn:00000926
.text$mn:00000926 ; ---------------------------------------------------------------------------
.text$mn:00000929                 db 0Bh dup(0CCh)
.text$mn:00000934
.text$mn:00000934 ; =============== S U B R O U T I N E =======================================
.text$mn:00000934
.text$mn:00000934 ; Attributes: bp-based frame
.text$mn:00000934
.text$mn:00000934 ; void __thiscall TabBarPlus::init(TabBarPlus *this, HINSTANCE, HWND, bool, bool, bool)
.text$mn:00000934                 public ?init@TabBarPlus@@UAEXPAUHINSTANCE__@@PAUHWND__@@_N22@Z
.text$mn:00000934 ?init@TabBarPlus@@UAEXPAUHINSTANCE__@@PAUHWND__@@_N22@Z proc near
.text$mn:00000934
.text$mn:00000934 var_B0          = byte ptr -0B0h
.text$mn:00000934 var_A4          = byte ptr -0A4h
.text$mn:00000934 var_98          = byte ptr -98h
.text$mn:00000934 picce           = INITCOMMONCONTROLSEX ptr -8Ch
.text$mn:00000934 var_84          = dword ptr -84h
.text$mn:00000934 var_80          = dword ptr -80h
.text$mn:00000934 var_7C          = dword ptr -7Ch
.text$mn:00000934 var_78          = dword ptr -78h
.text$mn:00000934 var_74          = dword ptr -74h
.text$mn:00000934 dwStyle         = dword ptr -70h
.text$mn:00000934 var_6C          = dword ptr -6Ch
.text$mn:00000934 var_65          = byte ptr -65h
.text$mn:00000934 dwNewLong       = dword ptr -64h
.text$mn:00000934 pv              = byte ptr -60h
.text$mn:00000934 var_58          = dword ptr -58h
.text$mn:00000934 var_54          = dword ptr -54h
.text$mn:00000934 var_50          = dword ptr -50h
.text$mn:00000934 var_4           = dword ptr -4
.text$mn:00000934 arg_0           = dword ptr  8
.text$mn:00000934 arg_4           = dword ptr  0Ch
.text$mn:00000934 arg_8           = byte ptr  10h
.text$mn:00000934 arg_C           = byte ptr  14h
.text$mn:00000934 arg_10          = byte ptr  18h
.text$mn:00000934
.text$mn:00000934                 push    ebp
.text$mn:00000935                 mov     ebp, esp
.text$mn:00000937                 sub     esp, 0B0h
.text$mn:0000093D                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000942                 xor     eax, ebp
.text$mn:00000944                 mov     [ebp+var_4], eax
.text$mn:00000947                 mov     [ebp+dwNewLong], ecx
.text$mn:0000094A                 mov     eax, [ebp+arg_4]
.text$mn:0000094D                 push    eax             ; HWND
.text$mn:0000094E                 mov     ecx, [ebp+arg_0]
.text$mn:00000951                 push    ecx             ; HINSTANCE
.text$mn:00000952                 mov     ecx, [ebp+dwNewLong] ; this
.text$mn:00000955                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:0000095A                 movzx   edx, [ebp+arg_8]
.text$mn:0000095E                 test    edx, edx
.text$mn:00000960                 jz      short loc_96B
.text$mn:00000962                 mov     [ebp+var_78], 280h
.text$mn:00000969                 jmp     short loc_972
.text$mn:0000096B ; ---------------------------------------------------------------------------
.text$mn:0000096B
.text$mn:0000096B loc_96B:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+2Cj
.text$mn:0000096B                 mov     [ebp+var_78], 0
.text$mn:00000972
.text$mn:00000972 loc_972:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+35j
.text$mn:00000972                 mov     eax, [ebp+var_78]
.text$mn:00000975                 mov     [ebp+var_80], eax
.text$mn:00000978                 mov     ecx, [ebp+dwNewLong]
.text$mn:0000097B                 mov     dl, [ebp+arg_C]
.text$mn:0000097E                 mov     [ecx+2Ch], dl
.text$mn:00000981                 mov     eax, [ebp+dwNewLong]
.text$mn:00000984                 mov     cl, [ebp+arg_8]
.text$mn:00000987                 mov     [eax+2Dh], cl
.text$mn:0000098A                 mov     edx, [ebp+dwNewLong]
.text$mn:0000098D                 mov     al, [ebp+arg_10]
.text$mn:00000990                 mov     [edx+2Eh], al
.text$mn:00000993                 mov     [ebp+picce.dwSize], 8
.text$mn:0000099D                 mov     [ebp+picce.dwICC], 8
.text$mn:000009A7                 lea     ecx, [ebp+picce]
.text$mn:000009AD                 push    ecx             ; picce
.text$mn:000009AE                 call    dword ptr ds:__imp__InitCommonControlsEx@4 ; InitCommonControlsEx(x)
.text$mn:000009B4                 movzx   edx, [ebp+arg_10]
.text$mn:000009B8                 test    edx, edx
.text$mn:000009BA                 jz      short loc_9DF
.text$mn:000009BC                 mov     eax, [ebp+dwNewLong]
.text$mn:000009BF                 movzx   ecx, byte ptr [eax+2Ch]
.text$mn:000009C3                 test    ecx, ecx
.text$mn:000009C5                 jz      short loc_9D0
.text$mn:000009C7                 mov     [ebp+var_7C], 200h
.text$mn:000009CE                 jmp     short loc_9D7
.text$mn:000009D0 ; ---------------------------------------------------------------------------
.text$mn:000009D0
.text$mn:000009D0 loc_9D0:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+91j
.text$mn:000009D0                 mov     [ebp+var_7C], 0
.text$mn:000009D7
.text$mn:000009D7 loc_9D7:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+9Aj
.text$mn:000009D7                 mov     edx, [ebp+var_7C]
.text$mn:000009DA                 mov     [ebp+var_74], edx
.text$mn:000009DD                 jmp     short loc_9E6
.text$mn:000009DF ; ---------------------------------------------------------------------------
.text$mn:000009DF
.text$mn:000009DF loc_9DF:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+86j
.text$mn:000009DF                 mov     [ebp+var_74], 0
.text$mn:000009E6
.text$mn:000009E6 loc_9E6:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+A9j
.text$mn:000009E6                 mov     eax, [ebp+var_74]
.text$mn:000009E9                 mov     [ebp+var_84], eax
.text$mn:000009EF                 mov     ecx, [ebp+var_80]
.text$mn:000009F2                 or      ecx, 56008000h
.text$mn:000009F8                 or      ecx, [ebp+var_84]
.text$mn:000009FE                 mov     [ebp+dwStyle], ecx
.text$mn:00000A01                 mov     edx, [ebp+dwStyle]
.text$mn:00000A04                 or      edx, 2000h
.text$mn:00000A0A                 mov     [ebp+dwStyle], edx
.text$mn:00000A0D                 push    0               ; lpParam
.text$mn:00000A0F                 mov     eax, [ebp+dwNewLong]
.text$mn:00000A12                 mov     ecx, [eax+4]
.text$mn:00000A15                 push    ecx             ; hInstance
.text$mn:00000A16                 push    0               ; hMenu
.text$mn:00000A18                 mov     edx, [ebp+dwNewLong]
.text$mn:00000A1B                 mov     eax, [edx+8]
.text$mn:00000A1E                 push    eax             ; hWndParent
.text$mn:00000A1F                 push    0               ; nHeight
.text$mn:00000A21                 push    0               ; nWidth
.text$mn:00000A23                 push    0               ; Y
.text$mn:00000A25                 push    0               ; X
.text$mn:00000A27                 mov     ecx, [ebp+dwStyle]
.text$mn:00000A2A                 push    ecx             ; dwStyle
.text$mn:00000A2B                 push    offset $SG123455 ; "Tab"
.text$mn:00000A30                 push    offset $SG123456 ; "SysTabControl32"
.text$mn:00000A35                 push    0               ; dwExStyle
.text$mn:00000A37                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:00000A3D                 mov     edx, [ebp+dwNewLong]
.text$mn:00000A40                 mov     [edx+0Ch], eax
.text$mn:00000A43                 mov     eax, [ebp+dwNewLong]
.text$mn:00000A46                 cmp     dword ptr [eax+0Ch], 0
.text$mn:00000A4A                 jnz     short loc_A6D
.text$mn:00000A4C                 push    offset $SG123460 ; "TabBarPlus::init : CreateWindowEx() fun"...
.text$mn:00000A51                 lea     ecx, [ebp+var_B0] ; this
.text$mn:00000A57                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:00000A5C                 push    offset __TI2?AVruntime_error@std@@
.text$mn:00000A61                 lea     ecx, [ebp+var_B0]
.text$mn:00000A67                 push    ecx
.text$mn:00000A68                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000A6D ; ---------------------------------------------------------------------------
.text$mn:00000A6D
.text$mn:00000A6D loc_A6D:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+116j
.text$mn:00000A6D                 push    0               ; lpParam
.text$mn:00000A6F                 mov     edx, [ebp+dwNewLong]
.text$mn:00000A72                 mov     eax, [edx+4]
.text$mn:00000A75                 push    eax             ; hInstance
.text$mn:00000A76                 push    0               ; hMenu
.text$mn:00000A78                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000A7B                 mov     edx, [ecx+8]
.text$mn:00000A7E                 push    edx             ; hWndParent
.text$mn:00000A7F                 push    0               ; nHeight
.text$mn:00000A81                 push    0               ; nWidth
.text$mn:00000A83                 push    0               ; Y
.text$mn:00000A85                 push    0               ; X
.text$mn:00000A87                 push    3               ; dwStyle
.text$mn:00000A89                 push    0               ; lpWindowName
.text$mn:00000A8B                 push    offset $SG123461 ; "tooltips_class32"
.text$mn:00000A90                 push    0               ; dwExStyle
.text$mn:00000A92                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:00000A98                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000A9B                 mov     [ecx+78h], eax
.text$mn:00000A9E                 mov     edx, [ebp+dwNewLong]
.text$mn:00000AA1                 cmp     dword ptr [edx+78h], 0
.text$mn:00000AA5                 jnz     short loc_AC8
.text$mn:00000AA7                 push    offset $SG123465 ; "TabBarPlus::init : tooltip CreateWindow"...
.text$mn:00000AAC                 lea     ecx, [ebp+var_A4] ; this
.text$mn:00000AB2                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:00000AB7                 push    offset __TI2?AVruntime_error@std@@
.text$mn:00000ABC                 lea     eax, [ebp+var_A4]
.text$mn:00000AC2                 push    eax
.text$mn:00000AC3                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000AC8 ; ---------------------------------------------------------------------------
.text$mn:00000AC8
.text$mn:00000AC8 loc_AC8:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+171j
.text$mn:00000AC8                 push    0               ; lParam
.text$mn:00000ACA                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000ACD                 mov     edx, [ecx+78h]
.text$mn:00000AD0                 push    edx             ; wParam
.text$mn:00000AD1                 push    132Eh           ; Msg
.text$mn:00000AD6                 mov     eax, [ebp+dwNewLong]
.text$mn:00000AD9                 mov     ecx, [eax+0Ch]
.text$mn:00000ADC                 push    ecx             ; hWnd
.text$mn:00000ADD                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000AE3                 mov     edx, [ebp+dwNewLong]
.text$mn:00000AE6                 movzx   eax, byte ptr [edx+2Ch]
.text$mn:00000AEA                 test    eax, eax
.text$mn:00000AEC                 jnz     loc_BF1
.text$mn:00000AF2                 mov     ecx, ds:?_nbCtrl@TabBarPlus@@1HA ; int TabBarPlus::_nbCtrl
.text$mn:00000AF8                 cmp     ds:?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A[ecx*4], 0 ; HWND__ * * TabBarPlus::_hwndArray
.text$mn:00000B00                 jnz     short loc_B25
.text$mn:00000B02                 mov     edx, ds:?_nbCtrl@TabBarPlus@@1HA ; int TabBarPlus::_nbCtrl
.text$mn:00000B08                 mov     eax, [ebp+dwNewLong]
.text$mn:00000B0B                 mov     ecx, [eax+0Ch]
.text$mn:00000B0E                 mov     ds:?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A[edx*4], ecx ; HWND__ * * TabBarPlus::_hwndArray
.text$mn:00000B15                 mov     edx, [ebp+dwNewLong]
.text$mn:00000B18                 mov     eax, ds:?_nbCtrl@TabBarPlus@@1HA ; int TabBarPlus::_nbCtrl
.text$mn:00000B1D                 mov     [edx+28h], eax
.text$mn:00000B20                 jmp     loc_BB5
.text$mn:00000B25 ; ---------------------------------------------------------------------------
.text$mn:00000B25
.text$mn:00000B25 loc_B25:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+1CCj
.text$mn:00000B25                 mov     [ebp+var_6C], 0
.text$mn:00000B2C                 mov     [ebp+var_65], 0
.text$mn:00000B30                 jmp     short loc_B3B
.text$mn:00000B32 ; ---------------------------------------------------------------------------
.text$mn:00000B32
.text$mn:00000B32 loc_B32:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool):loc_B5Aj
.text$mn:00000B32                 mov     ecx, [ebp+var_6C]
.text$mn:00000B35                 add     ecx, 1
.text$mn:00000B38                 mov     [ebp+var_6C], ecx
.text$mn:00000B3B
.text$mn:00000B3B loc_B3B:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+1FCj
.text$mn:00000B3B                 cmp     [ebp+var_6C], 0Ah
.text$mn:00000B3F                 jge     short loc_B5C
.text$mn:00000B41                 movzx   edx, [ebp+var_65]
.text$mn:00000B45                 test    edx, edx
.text$mn:00000B47                 jnz     short loc_B5C
.text$mn:00000B49                 mov     eax, [ebp+var_6C]
.text$mn:00000B4C                 cmp     ds:?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A[eax*4], 0 ; HWND__ * * TabBarPlus::_hwndArray
.text$mn:00000B54                 jnz     short loc_B5A
.text$mn:00000B56                 mov     [ebp+var_65], 1
.text$mn:00000B5A
.text$mn:00000B5A loc_B5A:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+220j
.text$mn:00000B5A                 jmp     short loc_B32
.text$mn:00000B5C ; ---------------------------------------------------------------------------
.text$mn:00000B5C
.text$mn:00000B5C loc_B5C:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+20Bj
.text$mn:00000B5C                                         ; TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+213j
.text$mn:00000B5C                 movzx   ecx, [ebp+var_65]
.text$mn:00000B60                 test    ecx, ecx
.text$mn:00000B62                 jnz     short loc_B9C
.text$mn:00000B64                 mov     edx, [ebp+dwNewLong]
.text$mn:00000B67                 mov     dword ptr [edx+28h], 0FFFFFFFFh
.text$mn:00000B6E                 mov     eax, [ebp+dwNewLong]
.text$mn:00000B71                 mov     edx, [eax]
.text$mn:00000B73                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000B76                 mov     eax, [edx+8]
.text$mn:00000B79                 call    eax
.text$mn:00000B7B                 push    offset $SG123479 ; "TabBarPlus::init : Tab Control error - "...
.text$mn:00000B80                 lea     ecx, [ebp+var_98] ; this
.text$mn:00000B86                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:00000B8B                 push    offset __TI2?AVruntime_error@std@@
.text$mn:00000B90                 lea     ecx, [ebp+var_98]
.text$mn:00000B96                 push    ecx
.text$mn:00000B97                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000B9C ; ---------------------------------------------------------------------------
.text$mn:00000B9C
.text$mn:00000B9C loc_B9C:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+22Ej
.text$mn:00000B9C                 mov     edx, [ebp+var_6C]
.text$mn:00000B9F                 mov     eax, [ebp+dwNewLong]
.text$mn:00000BA2                 mov     ecx, [eax+0Ch]
.text$mn:00000BA5                 mov     ds:?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A[edx*4], ecx ; HWND__ * * TabBarPlus::_hwndArray
.text$mn:00000BAC                 mov     edx, [ebp+dwNewLong]
.text$mn:00000BAF                 mov     eax, [ebp+var_6C]
.text$mn:00000BB2                 mov     [edx+28h], eax
.text$mn:00000BB5
.text$mn:00000BB5 loc_BB5:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+1ECj
.text$mn:00000BB5                 mov     ecx, ds:?_nbCtrl@TabBarPlus@@1HA ; int TabBarPlus::_nbCtrl
.text$mn:00000BBB                 add     ecx, 1
.text$mn:00000BBE                 mov     ds:?_nbCtrl@TabBarPlus@@1HA, ecx ; int TabBarPlus::_nbCtrl
.text$mn:00000BC4                 mov     edx, [ebp+dwNewLong]
.text$mn:00000BC7                 push    edx             ; dwNewLong
.text$mn:00000BC8                 push    0FFFFFFEBh      ; nIndex
.text$mn:00000BCA                 mov     eax, [ebp+dwNewLong]
.text$mn:00000BCD                 mov     ecx, [eax+0Ch]
.text$mn:00000BD0                 push    ecx             ; hWnd
.text$mn:00000BD1                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000BD7                 push    offset ?TabBarPlus_Proc@TabBarPlus@@KGJPAUHWND__@@IIJ@Z ; dwNewLong
.text$mn:00000BDC                 push    0FFFFFFFCh      ; nIndex
.text$mn:00000BDE                 mov     edx, [ebp+dwNewLong]
.text$mn:00000BE1                 mov     eax, [edx+0Ch]
.text$mn:00000BE4                 push    eax             ; hWnd
.text$mn:00000BE5                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000BEB                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000BEE                 mov     [ecx+44h], eax
.text$mn:00000BF1
.text$mn:00000BF1 loc_BF1:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+1B8j
.text$mn:00000BF1                 push    0               ; lParam
.text$mn:00000BF3                 push    0               ; wParam
.text$mn:00000BF5                 push    31h ; '1'       ; Msg
.text$mn:00000BF7                 mov     edx, [ebp+dwNewLong]
.text$mn:00000BFA                 mov     eax, [edx+0Ch]
.text$mn:00000BFD                 push    eax             ; hWnd
.text$mn:00000BFE                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000C04                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000C07                 mov     [ecx+18h], eax
.text$mn:00000C0A                 mov     edx, [ebp+dwNewLong]
.text$mn:00000C0D                 cmp     dword ptr [edx+18h], 0
.text$mn:00000C11                 jnz     short loc_C21
.text$mn:00000C13                 push    11h             ; i
.text$mn:00000C15                 call    dword ptr ds:__imp__GetStockObject@4 ; GetStockObject(x)
.text$mn:00000C1B                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000C1E                 mov     [ecx+18h], eax
.text$mn:00000C21
.text$mn:00000C21 loc_C21:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+2DDj
.text$mn:00000C21                 mov     edx, [ebp+dwNewLong]
.text$mn:00000C24                 cmp     dword ptr [edx+1Ch], 0
.text$mn:00000C28                 jnz     short loc_C38
.text$mn:00000C2A                 push    0Dh             ; i
.text$mn:00000C2C                 call    dword ptr ds:__imp__GetStockObject@4 ; GetStockObject(x)
.text$mn:00000C32                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000C35                 mov     [ecx+1Ch], eax
.text$mn:00000C38
.text$mn:00000C38 loc_C38:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+2F4j
.text$mn:00000C38                 lea     edx, [ebp+pv]
.text$mn:00000C3B                 push    edx             ; pv
.text$mn:00000C3C                 push    5Ch ; '\'       ; c
.text$mn:00000C3E                 mov     eax, [ebp+dwNewLong]
.text$mn:00000C41                 mov     ecx, [eax+18h]
.text$mn:00000C44                 push    ecx             ; h
.text$mn:00000C45                 call    dword ptr ds:__imp__GetObjectW@12 ; GetObjectW(x,x,x)
.text$mn:00000C4B                 test    eax, eax
.text$mn:00000C4D                 jz      short loc_C84
.text$mn:00000C4F                 mov     [ebp+var_58], 384h
.text$mn:00000C56                 mov     [ebp+var_54], 384h
.text$mn:00000C5D                 lea     edx, [ebp+pv]
.text$mn:00000C60                 push    edx             ; lplf
.text$mn:00000C61                 call    dword ptr ds:__imp__CreateFontIndirectW@4 ; CreateFontIndirectW(x)
.text$mn:00000C67                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000C6A                 mov     [ecx+20h], eax
.text$mn:00000C6D                 mov     [ebp+var_50], 384h
.text$mn:00000C74                 lea     edx, [ebp+pv]
.text$mn:00000C77                 push    edx             ; lplf
.text$mn:00000C78                 call    dword ptr ds:__imp__CreateFontIndirectW@4 ; CreateFontIndirectW(x)
.text$mn:00000C7E                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000C81                 mov     [ecx+24h], eax
.text$mn:00000C84
.text$mn:00000C84 loc_C84:                                ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+319j
.text$mn:00000C84                 mov     ecx, [ebp+var_4]
.text$mn:00000C87                 xor     ecx, ebp
.text$mn:00000C89                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000C8E                 mov     esp, ebp
.text$mn:00000C90                 pop     ebp
.text$mn:00000C91                 retn    14h
.text$mn:00000C91 ?init@TabBarPlus@@UAEXPAUHINSTANCE__@@PAUHWND__@@_N22@Z endp
.text$mn:00000C91
.text$mn:00000C94
.text$mn:00000C94 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C94
.text$mn:00000C94 ; Attributes: bp-based frame
.text$mn:00000C94
.text$mn:00000C94 ; void __thiscall TabBarPlus::destroy(TabBarPlus *__hidden this)
.text$mn:00000C94                 public ?destroy@TabBarPlus@@UAEXXZ
.text$mn:00000C94 ?destroy@TabBarPlus@@UAEXXZ proc near
.text$mn:00000C94
.text$mn:00000C94 var_4           = dword ptr -4
.text$mn:00000C94
.text$mn:00000C94                 push    ebp
.text$mn:00000C95                 mov     ebp, esp
.text$mn:00000C97                 push    ecx
.text$mn:00000C98                 mov     [ebp+var_4], ecx
.text$mn:00000C9B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000C9E                 call    ?destroy@TabBar@@UAEXXZ ; TabBar::destroy(void)
.text$mn:00000CA3                 mov     eax, [ebp+var_4]
.text$mn:00000CA6                 mov     ecx, [eax+78h]
.text$mn:00000CA9                 push    ecx             ; hWnd
.text$mn:00000CAA                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:00000CB0                 mov     edx, [ebp+var_4]
.text$mn:00000CB3                 mov     dword ptr [edx+78h], 0
.text$mn:00000CBA                 mov     esp, ebp
.text$mn:00000CBC                 pop     ebp
.text$mn:00000CBD                 retn
.text$mn:00000CBD ?destroy@TabBarPlus@@UAEXXZ endp
.text$mn:00000CBD
.text$mn:00000CBD ; ---------------------------------------------------------------------------
.text$mn:00000CBE                 db 6 dup(0CCh)
.text$mn:00000CC4
.text$mn:00000CC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CC4
.text$mn:00000CC4 ; Attributes: bp-based frame
.text$mn:00000CC4
.text$mn:00000CC4 ; void __cdecl TabBarPlus::doOwnerDrawTab()
.text$mn:00000CC4                 public ?doOwnerDrawTab@TabBarPlus@@SAXXZ
.text$mn:00000CC4 ?doOwnerDrawTab@TabBarPlus@@SAXXZ proc near
.text$mn:00000CC4                                         ; CODE XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex):loc_F05p
.text$mn:00000CC4
.text$mn:00000CC4 var_14          = dword ptr -14h
.text$mn:00000CC4 var_10          = dword ptr -10h
.text$mn:00000CC4 var_C           = dword ptr -0Ch
.text$mn:00000CC4 dwNewLong       = dword ptr -8
.text$mn:00000CC4 var_4           = dword ptr -4
.text$mn:00000CC4
.text$mn:00000CC4                 push    ebp
.text$mn:00000CC5                 mov     ebp, esp
.text$mn:00000CC7                 sub     esp, 14h
.text$mn:00000CCA                 push    6               ; lParam
.text$mn:00000CCC                 push    0               ; wParam
.text$mn:00000CCE                 push    132Bh           ; Msg
.text$mn:00000CD3                 mov     eax, 4
.text$mn:00000CD8                 imul    ecx, eax, 0
.text$mn:00000CDB                 mov     edx, ds:?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A[ecx] ; HWND__ * * TabBarPlus::_hwndArray
.text$mn:00000CE1                 push    edx             ; hWnd
.text$mn:00000CE2                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000CE8                 mov     [ebp+var_4], 0
.text$mn:00000CEF                 jmp     short loc_CFA
.text$mn:00000CF1 ; ---------------------------------------------------------------------------
.text$mn:00000CF1
.text$mn:00000CF1 loc_CF1:                                ; CODE XREF: TabBarPlus::doOwnerDrawTab(void):loc_DE7j
.text$mn:00000CF1                 mov     eax, [ebp+var_4]
.text$mn:00000CF4                 add     eax, 1
.text$mn:00000CF7                 mov     [ebp+var_4], eax
.text$mn:00000CFA
.text$mn:00000CFA loc_CFA:                                ; CODE XREF: TabBarPlus::doOwnerDrawTab(void)+2Bj
.text$mn:00000CFA                 mov     ecx, [ebp+var_4]
.text$mn:00000CFD                 cmp     ecx, ds:?_nbCtrl@TabBarPlus@@1HA ; int TabBarPlus::_nbCtrl
.text$mn:00000D03                 jge     loc_DEC
.text$mn:00000D09                 mov     edx, [ebp+var_4]
.text$mn:00000D0C                 cmp     ds:?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A[edx*4], 0 ; HWND__ * * TabBarPlus::_hwndArray
.text$mn:00000D14                 jz      loc_DE7
.text$mn:00000D1A                 push    0FFFFFFF0h      ; nIndex
.text$mn:00000D1C                 mov     eax, [ebp+var_4]
.text$mn:00000D1F                 mov     ecx, ds:?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A[eax*4] ; HWND__ * * TabBarPlus::_hwndArray
.text$mn:00000D26                 push    ecx             ; hWnd
.text$mn:00000D27                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:00000D2D                 mov     [ebp+dwNewLong], eax
.text$mn:00000D30                 call    ?isOwnerDrawTab@TabBarPlus@@SA_NXZ ; TabBarPlus::isOwnerDrawTab(void)
.text$mn:00000D35                 movzx   edx, al
.text$mn:00000D38                 test    edx, edx
.text$mn:00000D3A                 jz      short loc_D49
.text$mn:00000D3C                 mov     eax, [ebp+dwNewLong]
.text$mn:00000D3F                 or      eax, 2000h
.text$mn:00000D44                 mov     [ebp+dwNewLong], eax
.text$mn:00000D47                 jmp     short loc_D55
.text$mn:00000D49 ; ---------------------------------------------------------------------------
.text$mn:00000D49
.text$mn:00000D49 loc_D49:                                ; CODE XREF: TabBarPlus::doOwnerDrawTab(void)+76j
.text$mn:00000D49                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000D4C                 and     ecx, 0FFFFDFFFh
.text$mn:00000D52                 mov     [ebp+dwNewLong], ecx
.text$mn:00000D55
.text$mn:00000D55 loc_D55:                                ; CODE XREF: TabBarPlus::doOwnerDrawTab(void)+83j
.text$mn:00000D55                 mov     edx, [ebp+dwNewLong]
.text$mn:00000D58                 push    edx             ; dwNewLong
.text$mn:00000D59                 push    0FFFFFFF0h      ; nIndex
.text$mn:00000D5B                 mov     eax, [ebp+var_4]
.text$mn:00000D5E                 mov     ecx, ds:?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A[eax*4] ; HWND__ * * TabBarPlus::_hwndArray
.text$mn:00000D65                 push    ecx             ; hWnd
.text$mn:00000D66                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000D6C                 push    1               ; bErase
.text$mn:00000D6E                 push    0               ; lpRect
.text$mn:00000D70                 mov     edx, [ebp+var_4]
.text$mn:00000D73                 mov     eax, ds:?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A[edx*4] ; HWND__ * * TabBarPlus::_hwndArray
.text$mn:00000D7A                 push    eax             ; hWnd
.text$mn:00000D7B                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:00000D81                 push    6               ; int
.text$mn:00000D83                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000D88                 add     eax, 0Ch
.text$mn:00000D8B                 mov     ecx, eax        ; this
.text$mn:00000D8D                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:00000D92                 mov     [ebp+var_14], eax
.text$mn:00000D95                 push    9               ; int
.text$mn:00000D97                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000D9C                 add     eax, 0Ch
.text$mn:00000D9F                 mov     ecx, eax        ; this
.text$mn:00000DA1                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:00000DA6                 mov     [ebp+var_10], eax
.text$mn:00000DA9                 movzx   ecx, ds:?_drawTabCloseButton@TabBarPlus@@1_NA ; bool TabBarPlus::_drawTabCloseButton
.text$mn:00000DB0                 test    ecx, ecx
.text$mn:00000DB2                 jz      short loc_DBC
.text$mn:00000DB4                 mov     edx, [ebp+var_10]
.text$mn:00000DB7                 mov     [ebp+var_C], edx
.text$mn:00000DBA                 jmp     short loc_DC2
.text$mn:00000DBC ; ---------------------------------------------------------------------------
.text$mn:00000DBC
.text$mn:00000DBC loc_DBC:                                ; CODE XREF: TabBarPlus::doOwnerDrawTab(void)+EEj
.text$mn:00000DBC                 mov     eax, [ebp+var_14]
.text$mn:00000DBF                 mov     [ebp+var_C], eax
.text$mn:00000DC2
.text$mn:00000DC2 loc_DC2:                                ; CODE XREF: TabBarPlus::doOwnerDrawTab(void)+F6j
.text$mn:00000DC2                 mov     ecx, [ebp+var_C]
.text$mn:00000DC5                 and     ecx, 0FFFFh
.text$mn:00000DCB                 movzx   edx, cx
.text$mn:00000DCE                 push    edx             ; lParam
.text$mn:00000DCF                 push    0               ; wParam
.text$mn:00000DD1                 push    132Bh           ; Msg
.text$mn:00000DD6                 mov     eax, [ebp+var_4]
.text$mn:00000DD9                 mov     ecx, ds:?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A[eax*4] ; HWND__ * * TabBarPlus::_hwndArray
.text$mn:00000DE0                 push    ecx             ; hWnd
.text$mn:00000DE1                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000DE7
.text$mn:00000DE7 loc_DE7:                                ; CODE XREF: TabBarPlus::doOwnerDrawTab(void)+50j
.text$mn:00000DE7                 jmp     loc_CF1
.text$mn:00000DEC ; ---------------------------------------------------------------------------
.text$mn:00000DEC
.text$mn:00000DEC loc_DEC:                                ; CODE XREF: TabBarPlus::doOwnerDrawTab(void)+3Fj
.text$mn:00000DEC                 mov     esp, ebp
.text$mn:00000DEE                 pop     ebp
.text$mn:00000DEF                 retn
.text$mn:00000DEF ?doOwnerDrawTab@TabBarPlus@@SAXXZ endp
.text$mn:00000DEF
.text$mn:00000DEF ; ---------------------------------------------------------------------------
.text$mn:00000DF0                 db 4 dup(0CCh)
.text$mn:00000DF4
.text$mn:00000DF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DF4
.text$mn:00000DF4 ; Attributes: bp-based frame
.text$mn:00000DF4
.text$mn:00000DF4 ; void __cdecl TabBarPlus::doVertical()
.text$mn:00000DF4                 public ?doVertical@TabBarPlus@@SAXXZ
.text$mn:00000DF4 ?doVertical@TabBarPlus@@SAXXZ proc near
.text$mn:00000DF4
.text$mn:00000DF4 var_4           = dword ptr -4
.text$mn:00000DF4
.text$mn:00000DF4                 push    ebp
.text$mn:00000DF5                 mov     ebp, esp
.text$mn:00000DF7                 push    ecx
.text$mn:00000DF8                 mov     [ebp+var_4], 0
.text$mn:00000DFF                 jmp     short loc_E0A
.text$mn:00000E01 ; ---------------------------------------------------------------------------
.text$mn:00000E01
.text$mn:00000E01 loc_E01:                                ; CODE XREF: TabBarPlus::doVertical(void):loc_E46j
.text$mn:00000E01                 mov     eax, [ebp+var_4]
.text$mn:00000E04                 add     eax, 1
.text$mn:00000E07                 mov     [ebp+var_4], eax
.text$mn:00000E0A
.text$mn:00000E0A loc_E0A:                                ; CODE XREF: TabBarPlus::doVertical(void)+Bj
.text$mn:00000E0A                 mov     ecx, [ebp+var_4]
.text$mn:00000E0D                 cmp     ecx, ds:?_nbCtrl@TabBarPlus@@1HA ; int TabBarPlus::_nbCtrl
.text$mn:00000E13                 jge     short loc_E48
.text$mn:00000E15                 mov     edx, [ebp+var_4]
.text$mn:00000E18                 cmp     ds:?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A[edx*4], 0 ; HWND__ * * TabBarPlus::_hwndArray
.text$mn:00000E20                 jz      short loc_E46
.text$mn:00000E22                 push    80h ; 'Ç'       ; lParam
.text$mn:00000E27                 call    ?isVertical@TabBarPlus@@SA_NXZ ; TabBarPlus::isVertical(void)
.text$mn:00000E2C                 movzx   eax, al
.text$mn:00000E2F                 push    eax             ; wParam
.text$mn:00000E30                 push    8024h           ; Msg
.text$mn:00000E35                 mov     ecx, [ebp+var_4]
.text$mn:00000E38                 mov     edx, ds:?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A[ecx*4] ; HWND__ * * TabBarPlus::_hwndArray
.text$mn:00000E3F                 push    edx             ; hWnd
.text$mn:00000E40                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000E46
.text$mn:00000E46 loc_E46:                                ; CODE XREF: TabBarPlus::doVertical(void)+2Cj
.text$mn:00000E46                 jmp     short loc_E01
.text$mn:00000E48 ; ---------------------------------------------------------------------------
.text$mn:00000E48
.text$mn:00000E48 loc_E48:                                ; CODE XREF: TabBarPlus::doVertical(void)+1Fj
.text$mn:00000E48                 mov     esp, ebp
.text$mn:00000E4A                 pop     ebp
.text$mn:00000E4B                 retn
.text$mn:00000E4B ?doVertical@TabBarPlus@@SAXXZ endp
.text$mn:00000E4B
.text$mn:00000E4B ; ---------------------------------------------------------------------------
.text$mn:00000E4C                 db 8 dup(0CCh)
.text$mn:00000E54
.text$mn:00000E54 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E54
.text$mn:00000E54 ; Attributes: bp-based frame
.text$mn:00000E54
.text$mn:00000E54 ; void __cdecl TabBarPlus::doMultiLine()
.text$mn:00000E54                 public ?doMultiLine@TabBarPlus@@SAXXZ
.text$mn:00000E54 ?doMultiLine@TabBarPlus@@SAXXZ proc near
.text$mn:00000E54
.text$mn:00000E54 var_4           = dword ptr -4
.text$mn:00000E54
.text$mn:00000E54                 push    ebp
.text$mn:00000E55                 mov     ebp, esp
.text$mn:00000E57                 push    ecx
.text$mn:00000E58                 mov     [ebp+var_4], 0
.text$mn:00000E5F                 jmp     short loc_E6A
.text$mn:00000E61 ; ---------------------------------------------------------------------------
.text$mn:00000E61
.text$mn:00000E61 loc_E61:                                ; CODE XREF: TabBarPlus::doMultiLine(void):loc_EA6j
.text$mn:00000E61                 mov     eax, [ebp+var_4]
.text$mn:00000E64                 add     eax, 1
.text$mn:00000E67                 mov     [ebp+var_4], eax
.text$mn:00000E6A
.text$mn:00000E6A loc_E6A:                                ; CODE XREF: TabBarPlus::doMultiLine(void)+Bj
.text$mn:00000E6A                 mov     ecx, [ebp+var_4]
.text$mn:00000E6D                 cmp     ecx, ds:?_nbCtrl@TabBarPlus@@1HA ; int TabBarPlus::_nbCtrl
.text$mn:00000E73                 jge     short loc_EA8
.text$mn:00000E75                 mov     edx, [ebp+var_4]
.text$mn:00000E78                 cmp     ds:?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A[edx*4], 0 ; HWND__ * * TabBarPlus::_hwndArray
.text$mn:00000E80                 jz      short loc_EA6
.text$mn:00000E82                 push    200h            ; lParam
.text$mn:00000E87                 call    ?isMultiLine@TabBarPlus@@SA_NXZ ; TabBarPlus::isMultiLine(void)
.text$mn:00000E8C                 movzx   eax, al
.text$mn:00000E8F                 push    eax             ; wParam
.text$mn:00000E90                 push    8024h           ; Msg
.text$mn:00000E95                 mov     ecx, [ebp+var_4]
.text$mn:00000E98                 mov     edx, ds:?_hwndArray@TabBarPlus@@1PAPAUHWND__@@A[ecx*4] ; HWND__ * * TabBarPlus::_hwndArray
.text$mn:00000E9F                 push    edx             ; hWnd
.text$mn:00000EA0                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000EA6
.text$mn:00000EA6 loc_EA6:                                ; CODE XREF: TabBarPlus::doMultiLine(void)+2Cj
.text$mn:00000EA6                 jmp     short loc_E61
.text$mn:00000EA8 ; ---------------------------------------------------------------------------
.text$mn:00000EA8
.text$mn:00000EA8 loc_EA8:                                ; CODE XREF: TabBarPlus::doMultiLine(void)+1Fj
.text$mn:00000EA8                 mov     esp, ebp
.text$mn:00000EAA                 pop     ebp
.text$mn:00000EAB                 retn
.text$mn:00000EAB ?doMultiLine@TabBarPlus@@SAXXZ endp
.text$mn:00000EAB
.text$mn:00000EAB ; ---------------------------------------------------------------------------
.text$mn:00000EAC                 db 8 dup(0CCh)
.text$mn:00000EB4
.text$mn:00000EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EB4
.text$mn:00000EB4 ; Attributes: bp-based frame
.text$mn:00000EB4
.text$mn:00000EB4 ; public: static void __cdecl TabBarPlus::setColour(unsigned long, enum  TabBarPlus::tabColourIndex)
.text$mn:00000EB4                 public ?setColour@TabBarPlus@@SAXKW4tabColourIndex@1@@Z
.text$mn:00000EB4 ?setColour@TabBarPlus@@SAXKW4tabColourIndex@1@@Z proc near
.text$mn:00000EB4
.text$mn:00000EB4 var_4           = dword ptr -4
.text$mn:00000EB4 arg_0           = dword ptr  8
.text$mn:00000EB4 arg_4           = dword ptr  0Ch
.text$mn:00000EB4
.text$mn:00000EB4                 push    ebp
.text$mn:00000EB5                 mov     ebp, esp
.text$mn:00000EB7                 push    ecx
.text$mn:00000EB8                 mov     eax, [ebp+arg_4]
.text$mn:00000EBB                 mov     [ebp+var_4], eax
.text$mn:00000EBE                 cmp     [ebp+var_4], 4  ; switch 5 cases
.text$mn:00000EC2                 ja      short loc_F03   ; jumptable 00000EC7 default case
.text$mn:00000EC4                 mov     ecx, [ebp+var_4]
.text$mn:00000EC7                 jmp     ds:$LN11[ecx*4] ; switch jump
.text$mn:00000ECE ; ---------------------------------------------------------------------------
.text$mn:00000ECE
.text$mn:00000ECE $LN6:                                   ; CODE XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex)+13j
.text$mn:00000ECE                                         ; DATA XREF: .text$mn:$LN11o
.text$mn:00000ECE                 mov     edx, [ebp+arg_0] ; jumptable 00000EC7 case 0
.text$mn:00000ED1                 mov     ds:?_activeTextColour@TabBarPlus@@1KA, edx ; ulong TabBarPlus::_activeTextColour
.text$mn:00000ED7                 jmp     short loc_F05
.text$mn:00000ED9 ; ---------------------------------------------------------------------------
.text$mn:00000ED9
.text$mn:00000ED9 $LN5:                                   ; CODE XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex)+13j
.text$mn:00000ED9                                         ; DATA XREF: .text$mn:$LN11o
.text$mn:00000ED9                 mov     eax, [ebp+arg_0] ; jumptable 00000EC7 case 1
.text$mn:00000EDC                 mov     ds:?_activeTopBarFocusedColour@TabBarPlus@@1KA, eax ; ulong TabBarPlus::_activeTopBarFocusedColour
.text$mn:00000EE1                 jmp     short loc_F05
.text$mn:00000EE3 ; ---------------------------------------------------------------------------
.text$mn:00000EE3
.text$mn:00000EE3 $LN4:                                   ; CODE XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex)+13j
.text$mn:00000EE3                                         ; DATA XREF: .text$mn:$LN11o
.text$mn:00000EE3                 mov     ecx, [ebp+arg_0] ; jumptable 00000EC7 case 2
.text$mn:00000EE6                 mov     ds:?_activeTopBarUnfocusedColour@TabBarPlus@@1KA, ecx ; ulong TabBarPlus::_activeTopBarUnfocusedColour
.text$mn:00000EEC                 jmp     short loc_F05
.text$mn:00000EEE ; ---------------------------------------------------------------------------
.text$mn:00000EEE
.text$mn:00000EEE $LN3:                                   ; CODE XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex)+13j
.text$mn:00000EEE                                         ; DATA XREF: .text$mn:$LN11o
.text$mn:00000EEE                 mov     edx, [ebp+arg_0] ; jumptable 00000EC7 case 3
.text$mn:00000EF1                 mov     ds:?_inactiveTextColour@TabBarPlus@@1KA, edx ; ulong TabBarPlus::_inactiveTextColour
.text$mn:00000EF7                 jmp     short loc_F05
.text$mn:00000EF9 ; ---------------------------------------------------------------------------
.text$mn:00000EF9
.text$mn:00000EF9 $LN2:                                   ; CODE XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex)+13j
.text$mn:00000EF9                                         ; DATA XREF: .text$mn:$LN11o
.text$mn:00000EF9                 mov     eax, [ebp+arg_0] ; jumptable 00000EC7 case 4
.text$mn:00000EFC                 mov     ds:?_inactiveBgColour@TabBarPlus@@1KA, eax ; ulong TabBarPlus::_inactiveBgColour
.text$mn:00000F01                 jmp     short loc_F05
.text$mn:00000F03 ; ---------------------------------------------------------------------------
.text$mn:00000F03
.text$mn:00000F03 loc_F03:                                ; CODE XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex)+Ej
.text$mn:00000F03                 jmp     short loc_F0A   ; jumptable 00000EC7 default case
.text$mn:00000F05 ; ---------------------------------------------------------------------------
.text$mn:00000F05
.text$mn:00000F05 loc_F05:                                ; CODE XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex)+23j
.text$mn:00000F05                                         ; TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex)+2Dj ...
.text$mn:00000F05                 call    ?doOwnerDrawTab@TabBarPlus@@SAXXZ ; TabBarPlus::doOwnerDrawTab(void)
.text$mn:00000F0A
.text$mn:00000F0A loc_F0A:                                ; CODE XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex):loc_F03j
.text$mn:00000F0A                 mov     esp, ebp
.text$mn:00000F0C                 pop     ebp
.text$mn:00000F0D                 retn
.text$mn:00000F0D ?setColour@TabBarPlus@@SAXKW4tabColourIndex@1@@Z endp
.text$mn:00000F0D
.text$mn:00000F0D ; ---------------------------------------------------------------------------
.text$mn:00000F0E                 align 10h
.text$mn:00000F10 $LN11           dd offset $LN6          ; DATA XREF: TabBarPlus::setColour(ulong,TabBarPlus::tabColourIndex)+13r
.text$mn:00000F10                 dd offset $LN5          ; jump table for switch statement
.text$mn:00000F10                 dd offset $LN4
.text$mn:00000F10                 dd offset $LN3
.text$mn:00000F10                 dd offset $LN2
.text$mn:00000F24
.text$mn:00000F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F24
.text$mn:00000F24 ; Attributes: bp-based frame
.text$mn:00000F24
.text$mn:00000F24 ; __int32 __thiscall TabBarPlus::runProc(TabBarPlus *this, HWND hWnd, UINT Msg, WPARAM wParam, __int32)
.text$mn:00000F24                 public ?runProc@TabBarPlus@@IAEJPAUHWND__@@IIJ@Z
.text$mn:00000F24 ?runProc@TabBarPlus@@IAEJPAUHWND__@@IIJ@Z proc near
.text$mn:00000F24                                         ; CODE XREF: TabBarPlus::TabBarPlus_Proc(HWND__ *,uint,uint,long)+21p
.text$mn:00000F24
.text$mn:00000F24 var_DC          = dword ptr -0DCh
.text$mn:00000F24 var_D8          = dword ptr -0D8h
.text$mn:00000F24 var_D4          = dword ptr -0D4h
.text$mn:00000F24 var_D0          = dword ptr -0D0h
.text$mn:00000F24 var_CC          = dword ptr -0CCh
.text$mn:00000F24 var_C8          = dword ptr -0C8h
.text$mn:00000F24 var_C4          = dword ptr -0C4h
.text$mn:00000F24 var_C0          = dword ptr -0C0h
.text$mn:00000F24 var_BC          = dword ptr -0BCh
.text$mn:00000F24 var_B8          = dword ptr -0B8h
.text$mn:00000F24 var_B4          = dword ptr -0B4h
.text$mn:00000F24 var_B0          = dword ptr -0B0h
.text$mn:00000F24 var_AC          = dword ptr -0ACh
.text$mn:00000F24 var_A8          = dword ptr -0A8h
.text$mn:00000F24 var_A4          = dword ptr -0A4h
.text$mn:00000F24 var_A0          = dword ptr -0A0h
.text$mn:00000F24 var_9C          = dword ptr -9Ch
.text$mn:00000F24 var_98          = dword ptr -98h
.text$mn:00000F24 var_94          = dword ptr -94h
.text$mn:00000F24 var_90          = dword ptr -90h
.text$mn:00000F24 var_8C          = dword ptr -8Ch
.text$mn:00000F24 var_88          = dword ptr -88h
.text$mn:00000F24 var_84          = dword ptr -84h
.text$mn:00000F24 var_80          = dword ptr -80h
.text$mn:00000F24 var_7C          = tagPOINT ptr -7Ch
.text$mn:00000F24 var_74          = dword ptr -74h
.text$mn:00000F24 EventTrack      = tagTRACKMOUSEEVENT ptr -70h
.text$mn:00000F24 var_60          = dword ptr -60h
.text$mn:00000F24 Point           = tagPOINT ptr -5Ch
.text$mn:00000F24 var_54          = dword ptr -54h
.text$mn:00000F24 var_50          = dword ptr -50h
.text$mn:00000F24 var_4C          = dword ptr -4Ch
.text$mn:00000F24 var_48          = dword ptr -48h
.text$mn:00000F24 var_44          = dword ptr -44h
.text$mn:00000F24 var_40          = dword ptr -40h
.text$mn:00000F24 var_3C          = dword ptr -3Ch
.text$mn:00000F24 var_38          = dword ptr -38h
.text$mn:00000F24 var_34          = dword ptr -34h
.text$mn:00000F24 var_30          = dword ptr -30h
.text$mn:00000F24 var_2C          = dword ptr -2Ch
.text$mn:00000F24 var_28          = dword ptr -28h
.text$mn:00000F24 dwNewLong       = dword ptr -24h
.text$mn:00000F24 var_1D          = byte ptr -1Dh
.text$mn:00000F24 var_1C          = dword ptr -1Ch
.text$mn:00000F24 var_18          = dword ptr -18h
.text$mn:00000F24 Rect            = RECT ptr -14h
.text$mn:00000F24 var_4           = dword ptr -4
.text$mn:00000F24 hWnd            = dword ptr  8
.text$mn:00000F24 Msg             = dword ptr  0Ch
.text$mn:00000F24 wParam          = dword ptr  10h
.text$mn:00000F24 lParam          = dword ptr  14h
.text$mn:00000F24
.text$mn:00000F24                 push    ebp
.text$mn:00000F25                 mov     ebp, esp
.text$mn:00000F27                 sub     esp, 0DCh
.text$mn:00000F2D                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F32                 xor     eax, ebp
.text$mn:00000F34                 mov     [ebp+var_4], eax
.text$mn:00000F37                 mov     [ebp+var_18], ecx
.text$mn:00000F3A                 mov     eax, [ebp+Msg]
.text$mn:00000F3D                 mov     [ebp+var_1C], eax
.text$mn:00000F40                 cmp     [ebp+var_1C], 200h
.text$mn:00000F47                 ja      short loc_F72
.text$mn:00000F49                 cmp     [ebp+var_1C], 200h
.text$mn:00000F50                 jz      loc_1218
.text$mn:00000F56                 cmp     [ebp+var_1C], 2Bh ; '+'
.text$mn:00000F5A                 jz      loc_15A8
.text$mn:00000F60                 cmp     [ebp+var_1C], 100h
.text$mn:00000F67                 jz      loc_15BE
.text$mn:00000F6D                 jmp     loc_16FF        ; jumptable 00000FA1 default case
.text$mn:00000F72 ; ---------------------------------------------------------------------------
.text$mn:00000F72
.text$mn:00000F72 loc_F72:                                ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+23j
.text$mn:00000F72                 cmp     [ebp+var_1C], 208h
.text$mn:00000F79                 ja      short loc_FA8
.text$mn:00000F7B                 cmp     [ebp+var_1C], 208h
.text$mn:00000F82                 jz      loc_15EA
.text$mn:00000F88                 mov     ecx, [ebp+var_1C]
.text$mn:00000F8B                 sub     ecx, 201h
.text$mn:00000F91                 mov     [ebp+var_1C], ecx
.text$mn:00000F94                 cmp     [ebp+var_1C], 3 ; switch 4 cases
.text$mn:00000F98                 ja      loc_16FF        ; jumptable 00000FA1 default case
.text$mn:00000F9E                 mov     edx, [ebp+var_1C]
.text$mn:00000FA1                 jmp     ds:$LN49[edx*4] ; switch jump
.text$mn:00000FA8 ; ---------------------------------------------------------------------------
.text$mn:00000FA8
.text$mn:00000FA8 loc_FA8:                                ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+55j
.text$mn:00000FA8                 cmp     [ebp+var_1C], 215h
.text$mn:00000FAF                 jz      loc_1587
.text$mn:00000FB5                 cmp     [ebp+var_1C], 2A3h
.text$mn:00000FBC                 jz      loc_13F2
.text$mn:00000FC2                 cmp     [ebp+var_1C], 8024h
.text$mn:00000FC9                 jz      short loc_FD0
.text$mn:00000FCB                 jmp     loc_16FF        ; jumptable 00000FA1 default case
.text$mn:00000FD0 ; ---------------------------------------------------------------------------
.text$mn:00000FD0
.text$mn:00000FD0 loc_FD0:                                ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+A5j
.text$mn:00000FD0                 push    0FFFFFFF0h      ; nIndex
.text$mn:00000FD2                 mov     eax, [ebp+hWnd]
.text$mn:00000FD5                 push    eax             ; hWnd
.text$mn:00000FD6                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:00000FDC                 mov     [ebp+dwNewLong], eax
.text$mn:00000FDF                 cmp     [ebp+wParam], 0
.text$mn:00000FE3                 jbe     short loc_FF0
.text$mn:00000FE5                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000FE8                 or      ecx, [ebp+lParam]
.text$mn:00000FEB                 mov     [ebp+dwNewLong], ecx
.text$mn:00000FEE                 jmp     short loc_FFB
.text$mn:00000FF0 ; ---------------------------------------------------------------------------
.text$mn:00000FF0
.text$mn:00000FF0 loc_FF0:                                ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+BFj
.text$mn:00000FF0                 mov     edx, [ebp+lParam]
.text$mn:00000FF3                 not     edx
.text$mn:00000FF5                 and     edx, [ebp+dwNewLong]
.text$mn:00000FF8                 mov     [ebp+dwNewLong], edx
.text$mn:00000FFB
.text$mn:00000FFB loc_FFB:                                ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+CAj
.text$mn:00000FFB                 mov     eax, [ebp+dwNewLong]
.text$mn:00000FFE                 and     eax, 80h
.text$mn:00001003                 jz      short loc_100E
.text$mn:00001005                 mov     [ebp+var_48], 1
.text$mn:0000100C                 jmp     short loc_1015
.text$mn:0000100E ; ---------------------------------------------------------------------------
.text$mn:0000100E
.text$mn:0000100E loc_100E:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+DFj
.text$mn:0000100E                 mov     [ebp+var_48], 0
.text$mn:00001015
.text$mn:00001015 loc_1015:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+E8j
.text$mn:00001015                 mov     ecx, [ebp+var_18]
.text$mn:00001018                 mov     dl, byte ptr [ebp+var_48]
.text$mn:0000101B                 mov     [ecx+2Dh], dl
.text$mn:0000101E                 mov     eax, [ebp+dwNewLong]
.text$mn:00001021                 and     eax, 200h
.text$mn:00001026                 jz      short loc_1031
.text$mn:00001028                 mov     [ebp+var_54], 1
.text$mn:0000102F                 jmp     short loc_1038
.text$mn:00001031 ; ---------------------------------------------------------------------------
.text$mn:00001031
.text$mn:00001031 loc_1031:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+102j
.text$mn:00001031                 mov     [ebp+var_54], 0
.text$mn:00001038
.text$mn:00001038 loc_1038:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+10Bj
.text$mn:00001038                 mov     ecx, [ebp+var_18]
.text$mn:0000103B                 mov     dl, byte ptr [ebp+var_54]
.text$mn:0000103E                 mov     [ecx+2Eh], dl
.text$mn:00001041                 mov     eax, [ebp+dwNewLong]
.text$mn:00001044                 push    eax             ; dwNewLong
.text$mn:00001045                 push    0FFFFFFF0h      ; nIndex
.text$mn:00001047                 mov     ecx, [ebp+hWnd]
.text$mn:0000104A                 push    ecx             ; hWnd
.text$mn:0000104B                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00001051                 push    1               ; bErase
.text$mn:00001053                 push    0               ; lpRect
.text$mn:00001055                 mov     edx, [ebp+hWnd]
.text$mn:00001058                 push    edx             ; hWnd
.text$mn:00001059                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:0000105F                 mov     eax, 1
.text$mn:00001064                 jmp     loc_171C
.text$mn:00001069 ; ---------------------------------------------------------------------------
.text$mn:00001069
.text$mn:00001069 $LN33:                                  ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+7Dj
.text$mn:00001069                                         ; DATA XREF: .text$mn:$LN49o
.text$mn:00001069                 movzx   eax, ds:?_drawTabCloseButton@TabBarPlus@@1_NA ; jumptable 00000FA1 case 0
.text$mn:00001070                 test    eax, eax
.text$mn:00001072                 jz      short loc_10EE
.text$mn:00001074                 mov     ecx, [ebp+lParam]
.text$mn:00001077                 and     ecx, 0FFFFh
.text$mn:0000107D                 movzx   edx, cx
.text$mn:00001080                 mov     [ebp+var_3C], edx
.text$mn:00001083                 mov     eax, [ebp+lParam]
.text$mn:00001086                 shr     eax, 10h
.text$mn:00001089                 and     eax, 0FFFFh
.text$mn:0000108E                 movzx   ecx, ax
.text$mn:00001091                 mov     [ebp+var_50], ecx
.text$mn:00001094                 mov     edx, [ebp+var_18]
.text$mn:00001097                 add     edx, 48h ; 'H'
.text$mn:0000109A                 push    edx             ; struct tagRECT *
.text$mn:0000109B                 mov     eax, [ebp+var_50]
.text$mn:0000109E                 push    eax             ; int
.text$mn:0000109F                 mov     ecx, [ebp+var_3C]
.text$mn:000010A2                 push    ecx             ; int
.text$mn:000010A3                 mov     ecx, [ebp+var_18]
.text$mn:000010A6                 add     ecx, 5Ch ; '\'  ; this
.text$mn:000010A9                 call    ?isHit@CloseButtonZone@@QBE_NHHABUtagRECT@@@Z ; CloseButtonZone::isHit(int,int,tagRECT const &)
.text$mn:000010AE                 movzx   edx, al
.text$mn:000010B1                 test    edx, edx
.text$mn:000010B3                 jz      short loc_10EE
.text$mn:000010B5                 mov     eax, [ebp+var_50]
.text$mn:000010B8                 push    eax             ; int
.text$mn:000010B9                 mov     ecx, [ebp+var_3C]
.text$mn:000010BC                 push    ecx             ; int
.text$mn:000010BD                 mov     ecx, [ebp+var_18] ; this
.text$mn:000010C0                 call    ?getTabIndexAt@TabBarPlus@@IAEHHH@Z ; TabBarPlus::getTabIndexAt(int,int)
.text$mn:000010C5                 mov     edx, [ebp+var_18]
.text$mn:000010C8                 mov     [edx+70h], eax
.text$mn:000010CB                 push    0               ; lParam
.text$mn:000010CD                 push    0AC08h          ; wParam
.text$mn:000010D2                 push    111h            ; Msg
.text$mn:000010D7                 mov     eax, [ebp+var_18]
.text$mn:000010DA                 mov     ecx, [eax+8]
.text$mn:000010DD                 push    ecx             ; hWnd
.text$mn:000010DE                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000010E4                 mov     eax, 1
.text$mn:000010E9                 jmp     loc_171C
.text$mn:000010EE ; ---------------------------------------------------------------------------
.text$mn:000010EE
.text$mn:000010EE loc_10EE:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+14Ej
.text$mn:000010EE                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long)+18Fj
.text$mn:000010EE                 mov     edx, [ebp+lParam]
.text$mn:000010F1                 push    edx             ; lParam
.text$mn:000010F2                 mov     eax, [ebp+wParam]
.text$mn:000010F5                 push    eax             ; wParam
.text$mn:000010F6                 mov     ecx, [ebp+Msg]
.text$mn:000010F9                 push    ecx             ; Msg
.text$mn:000010FA                 mov     edx, [ebp+hWnd]
.text$mn:000010FD                 push    edx             ; hWnd
.text$mn:000010FE                 mov     eax, [ebp+var_18]
.text$mn:00001101                 mov     ecx, [eax+44h]
.text$mn:00001104                 push    ecx             ; lpPrevWndFunc
.text$mn:00001105                 call    dword ptr ds:__imp__CallWindowProcW@20 ; CallWindowProcW(x,x,x,x,x)
.text$mn:0000110B                 push    0               ; lParam
.text$mn:0000110D                 push    0               ; wParam
.text$mn:0000110F                 push    130Bh           ; Msg
.text$mn:00001114                 mov     edx, [ebp+var_18]
.text$mn:00001117                 mov     eax, [edx+0Ch]
.text$mn:0000111A                 push    eax             ; hWnd
.text$mn:0000111B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001121                 mov     [ebp+var_2C], eax
.text$mn:00001124                 cmp     [ebp+wParam], 2
.text$mn:00001128                 jnz     short loc_1134
.text$mn:0000112A                 mov     eax, 1
.text$mn:0000112F                 jmp     loc_171C
.text$mn:00001134 ; ---------------------------------------------------------------------------
.text$mn:00001134
.text$mn:00001134 loc_1134:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+204j
.text$mn:00001134                 movzx   ecx, ds:?_doDragNDrop@TabBarPlus@@1_NA ; bool TabBarPlus::_doDragNDrop
.text$mn:0000113B                 test    ecx, ecx
.text$mn:0000113D                 jz      short loc_11A6
.text$mn:0000113F                 mov     edx, [ebp+var_18]
.text$mn:00001142                 mov     eax, [ebp+var_2C]
.text$mn:00001145                 mov     [edx+38h], eax
.text$mn:00001148                 mov     ecx, [ebp+var_18]
.text$mn:0000114B                 mov     edx, [ebp+var_2C]
.text$mn:0000114E                 mov     [ecx+34h], edx
.text$mn:00001151                 mov     eax, [ebp+lParam]
.text$mn:00001154                 and     eax, 0FFFFh
.text$mn:00001159                 movzx   ecx, ax
.text$mn:0000115C                 mov     [ebp+Point.x], ecx
.text$mn:0000115F                 mov     edx, [ebp+lParam]
.text$mn:00001162                 shr     edx, 10h
.text$mn:00001165                 and     edx, 0FFFFh
.text$mn:0000116B                 movzx   eax, dx
.text$mn:0000116E                 mov     [ebp+Point.y], eax
.text$mn:00001171                 lea     ecx, [ebp+Point]
.text$mn:00001174                 push    ecx             ; lpPoint
.text$mn:00001175                 mov     edx, [ebp+hWnd]
.text$mn:00001178                 push    edx             ; hWnd
.text$mn:00001179                 call    dword ptr ds:__imp__ClientToScreen@8 ; ClientToScreen(x,x)
.text$mn:0000117F                 mov     eax, [ebp+Point.y]
.text$mn:00001182                 push    eax
.text$mn:00001183                 mov     ecx, [ebp+Point.x]
.text$mn:00001186                 push    ecx             ; pt
.text$mn:00001187                 mov     edx, [ebp+hWnd]
.text$mn:0000118A                 push    edx             ; hwnd
.text$mn:0000118B                 call    dword ptr ds:__imp__DragDetect@12 ; DragDetect(x,x,x)
.text$mn:00001191                 test    eax, eax
.text$mn:00001193                 jz      short loc_11A6
.text$mn:00001195                 mov     eax, [ebp+var_18]
.text$mn:00001198                 mov     byte ptr [eax+30h], 1
.text$mn:0000119C                 mov     ecx, [ebp+hWnd]
.text$mn:0000119F                 push    ecx             ; hWnd
.text$mn:000011A0                 call    dword ptr ds:__imp__SetCapture@4 ; SetCapture(x)
.text$mn:000011A6
.text$mn:000011A6 loc_11A6:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+219j
.text$mn:000011A6                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long)+26Fj
.text$mn:000011A6                 mov     edx, [ebp+var_18]
.text$mn:000011A9                 mov     eax, [edx+0Ch]
.text$mn:000011AC                 mov     [ebp+var_9C], eax
.text$mn:000011B2                 mov     [ebp+var_94], 0FFFFFFFEh
.text$mn:000011BC                 mov     ecx, [ebp+var_18]
.text$mn:000011BF                 mov     [ebp+var_98], ecx
.text$mn:000011C5                 mov     edx, [ebp+var_2C]
.text$mn:000011C8                 mov     [ebp+var_90], edx
.text$mn:000011CE                 lea     eax, [ebp+var_9C]
.text$mn:000011D4                 push    eax             ; lParam
.text$mn:000011D5                 push    0               ; wParam
.text$mn:000011D7                 push    4Eh ; 'N'       ; Msg
.text$mn:000011D9                 mov     ecx, [ebp+var_18]
.text$mn:000011DC                 mov     edx, [ecx+8]
.text$mn:000011DF                 push    edx             ; hWnd
.text$mn:000011E0                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000011E6                 mov     eax, 1
.text$mn:000011EB                 jmp     loc_171C
.text$mn:000011F0 ; ---------------------------------------------------------------------------
.text$mn:000011F0
.text$mn:000011F0 $LN27:                                  ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+7Dj
.text$mn:000011F0                                         ; DATA XREF: .text$mn:$LN49o
.text$mn:000011F0                 mov     eax, [ebp+lParam] ; jumptable 00000FA1 case 3
.text$mn:000011F3                 push    eax             ; lParam
.text$mn:000011F4                 mov     ecx, [ebp+wParam]
.text$mn:000011F7                 push    ecx             ; wParam
.text$mn:000011F8                 push    201h            ; Msg
.text$mn:000011FD                 mov     edx, [ebp+hWnd]
.text$mn:00001200                 push    edx             ; hWnd
.text$mn:00001201                 mov     eax, [ebp+var_18]
.text$mn:00001204                 mov     ecx, [eax+44h]
.text$mn:00001207                 push    ecx             ; lpPrevWndFunc
.text$mn:00001208                 call    dword ptr ds:__imp__CallWindowProcW@20 ; CallWindowProcW(x,x,x,x,x)
.text$mn:0000120E                 mov     eax, 1
.text$mn:00001213                 jmp     loc_171C
.text$mn:00001218 ; ---------------------------------------------------------------------------
.text$mn:00001218
.text$mn:00001218 loc_1218:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+2Cj
.text$mn:00001218                 mov     edx, [ebp+var_18]
.text$mn:0000121B                 movzx   eax, byte ptr [edx+30h]
.text$mn:0000121F                 test    eax, eax
.text$mn:00001221                 jz      short loc_127D
.text$mn:00001223                 mov     ecx, [ebp+lParam]
.text$mn:00001226                 and     ecx, 0FFFFh
.text$mn:0000122C                 movzx   edx, cx
.text$mn:0000122F                 mov     [ebp+var_7C.x], edx
.text$mn:00001232                 mov     eax, [ebp+lParam]
.text$mn:00001235                 shr     eax, 10h
.text$mn:00001238                 and     eax, 0FFFFh
.text$mn:0000123D                 movzx   ecx, ax
.text$mn:00001240                 mov     [ebp+var_7C.y], ecx
.text$mn:00001243                 mov     edx, [ebp+var_7C.y]
.text$mn:00001246                 push    edx
.text$mn:00001247                 mov     eax, [ebp+var_7C.x]
.text$mn:0000124A                 push    eax             ; struct tagPOINT
.text$mn:0000124B                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000124E                 call    ?exchangeItemData@TabBarPlus@@IAEXUtagPOINT@@@Z ; TabBarPlus::exchangeItemData(tagPOINT)
.text$mn:00001253                 mov     ecx, [ebp+var_18]
.text$mn:00001256                 add     ecx, 3Ch ; '<'
.text$mn:00001259                 push    ecx             ; lpPoint
.text$mn:0000125A                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:00001260                 mov     edx, [ebp+var_18]
.text$mn:00001263                 mov     eax, [edx+40h]
.text$mn:00001266                 push    eax
.text$mn:00001267                 mov     ecx, [edx+3Ch]
.text$mn:0000126A                 push    ecx             ; struct tagPOINT
.text$mn:0000126B                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000126E                 call    ?draggingCursor@TabBarPlus@@IAEXUtagPOINT@@@Z ; TabBarPlus::draggingCursor(tagPOINT)
.text$mn:00001273                 mov     eax, 1
.text$mn:00001278                 jmp     loc_171C
.text$mn:0000127D ; ---------------------------------------------------------------------------
.text$mn:0000127D
.text$mn:0000127D loc_127D:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+2FDj
.text$mn:0000127D                 movzx   edx, ds:?_drawTabCloseButton@TabBarPlus@@1_NA ; bool TabBarPlus::_drawTabCloseButton
.text$mn:00001284                 test    edx, edx
.text$mn:00001286                 jz      loc_13ED
.text$mn:0000128C                 mov     eax, [ebp+lParam]
.text$mn:0000128F                 and     eax, 0FFFFh
.text$mn:00001294                 movzx   ecx, ax
.text$mn:00001297                 mov     [ebp+var_44], ecx
.text$mn:0000129A                 mov     edx, [ebp+lParam]
.text$mn:0000129D                 shr     edx, 10h
.text$mn:000012A0                 and     edx, 0FFFFh
.text$mn:000012A6                 movzx   eax, dx
.text$mn:000012A9                 mov     [ebp+var_4C], eax
.text$mn:000012AC                 mov     ecx, [ebp+var_18]
.text$mn:000012AF                 mov     edx, [ecx+58h]
.text$mn:000012B2                 mov     [ebp+var_34], edx
.text$mn:000012B5                 mov     eax, [ebp+var_18]
.text$mn:000012B8                 add     eax, 48h ; 'H'
.text$mn:000012BB                 mov     ecx, [eax]
.text$mn:000012BD                 mov     [ebp+Rect.left], ecx
.text$mn:000012C0                 mov     edx, [eax+4]
.text$mn:000012C3                 mov     [ebp+Rect.top], edx
.text$mn:000012C6                 mov     ecx, [eax+8]
.text$mn:000012C9                 mov     [ebp+Rect.right], ecx
.text$mn:000012CC                 mov     edx, [eax+0Ch]
.text$mn:000012CF                 mov     [ebp+Rect.bottom], edx
.text$mn:000012D2                 mov     eax, [ebp+var_18]
.text$mn:000012D5                 mov     cl, [eax+6Ch]
.text$mn:000012D8                 mov     [ebp+var_1D], cl
.text$mn:000012DB                 mov     edx, [ebp+var_4C]
.text$mn:000012DE                 push    edx             ; int
.text$mn:000012DF                 mov     eax, [ebp+var_44]
.text$mn:000012E2                 push    eax             ; int
.text$mn:000012E3                 mov     ecx, [ebp+var_18] ; this
.text$mn:000012E6                 call    ?getTabIndexAt@TabBarPlus@@IAEHHH@Z ; TabBarPlus::getTabIndexAt(int,int)
.text$mn:000012EB                 mov     ecx, [ebp+var_18]
.text$mn:000012EE                 mov     [ecx+58h], eax
.text$mn:000012F1                 mov     edx, [ebp+var_18]
.text$mn:000012F4                 cmp     dword ptr [edx+58h], 0FFFFFFFFh
.text$mn:000012F8                 jz      short loc_133C
.text$mn:000012FA                 mov     eax, [ebp+var_18]
.text$mn:000012FD                 add     eax, 48h ; 'H'
.text$mn:00001300                 push    eax             ; lParam
.text$mn:00001301                 mov     ecx, [ebp+var_18]
.text$mn:00001304                 mov     edx, [ecx+58h]
.text$mn:00001307                 push    edx             ; wParam
.text$mn:00001308                 push    130Ah           ; Msg
.text$mn:0000130D                 mov     eax, [ebp+var_18]
.text$mn:00001310                 mov     ecx, [eax+0Ch]
.text$mn:00001313                 push    ecx             ; hWnd
.text$mn:00001314                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000131A                 mov     edx, [ebp+var_18]
.text$mn:0000131D                 add     edx, 48h ; 'H'
.text$mn:00001320                 push    edx             ; struct tagRECT *
.text$mn:00001321                 mov     eax, [ebp+var_4C]
.text$mn:00001324                 push    eax             ; int
.text$mn:00001325                 mov     ecx, [ebp+var_44]
.text$mn:00001328                 push    ecx             ; int
.text$mn:00001329                 mov     ecx, [ebp+var_18]
.text$mn:0000132C                 add     ecx, 5Ch ; '\'  ; this
.text$mn:0000132F                 call    ?isHit@CloseButtonZone@@QBE_NHHABUtagRECT@@@Z ; CloseButtonZone::isHit(int,int,tagRECT const &)
.text$mn:00001334                 mov     edx, [ebp+var_18]
.text$mn:00001337                 mov     [edx+6Ch], al
.text$mn:0000133A                 jmp     short loc_1350
.text$mn:0000133C ; ---------------------------------------------------------------------------
.text$mn:0000133C
.text$mn:0000133C loc_133C:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+3D4j
.text$mn:0000133C                 mov     eax, [ebp+var_18]
.text$mn:0000133F                 add     eax, 48h ; 'H'
.text$mn:00001342                 push    eax             ; lprc
.text$mn:00001343                 call    dword ptr ds:__imp__SetRectEmpty@4 ; SetRectEmpty(x)
.text$mn:00001349                 mov     ecx, [ebp+var_18]
.text$mn:0000134C                 mov     byte ptr [ecx+6Ch], 0
.text$mn:00001350
.text$mn:00001350 loc_1350:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+416j
.text$mn:00001350                 mov     edx, [ebp+var_18]
.text$mn:00001353                 mov     eax, [edx+58h]
.text$mn:00001356                 cmp     eax, [ebp+var_34]
.text$mn:00001359                 jnz     short loc_136A
.text$mn:0000135B                 mov     ecx, [ebp+var_18]
.text$mn:0000135E                 movzx   edx, byte ptr [ecx+6Ch]
.text$mn:00001362                 movzx   eax, [ebp+var_1D]
.text$mn:00001366                 cmp     edx, eax
.text$mn:00001368                 jz      short loc_13B6
.text$mn:0000136A
.text$mn:0000136A loc_136A:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+435j
.text$mn:0000136A                 movzx   ecx, [ebp+var_1D]
.text$mn:0000136E                 test    ecx, ecx
.text$mn:00001370                 jz      short loc_1398
.text$mn:00001372                 mov     edx, [ebp+var_18]
.text$mn:00001375                 mov     eax, [edx+58h]
.text$mn:00001378                 cmp     eax, [ebp+var_34]
.text$mn:0000137B                 jnz     short loc_1388
.text$mn:0000137D                 mov     ecx, [ebp+var_18]
.text$mn:00001380                 movzx   edx, byte ptr [ecx+6Ch]
.text$mn:00001384                 test    edx, edx
.text$mn:00001386                 jnz     short loc_1398
.text$mn:00001388
.text$mn:00001388 loc_1388:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+457j
.text$mn:00001388                 push    0               ; bErase
.text$mn:0000138A                 lea     eax, [ebp+Rect]
.text$mn:0000138D                 push    eax             ; lpRect
.text$mn:0000138E                 mov     ecx, [ebp+hWnd]
.text$mn:00001391                 push    ecx             ; hWnd
.text$mn:00001392                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:00001398
.text$mn:00001398 loc_1398:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+44Cj
.text$mn:00001398                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long)+462j
.text$mn:00001398                 mov     edx, [ebp+var_18]
.text$mn:0000139B                 movzx   eax, byte ptr [edx+6Ch]
.text$mn:0000139F                 test    eax, eax
.text$mn:000013A1                 jz      short loc_13B6
.text$mn:000013A3                 push    0               ; bErase
.text$mn:000013A5                 mov     ecx, [ebp+var_18]
.text$mn:000013A8                 add     ecx, 48h ; 'H'
.text$mn:000013AB                 push    ecx             ; lpRect
.text$mn:000013AC                 mov     edx, [ebp+hWnd]
.text$mn:000013AF                 push    edx             ; hWnd
.text$mn:000013B0                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:000013B6
.text$mn:000013B6 loc_13B6:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+444j
.text$mn:000013B6                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long)+47Dj
.text$mn:000013B6                 mov     eax, [ebp+var_18]
.text$mn:000013B9                 movzx   ecx, byte ptr [eax+6Ch]
.text$mn:000013BD                 test    ecx, ecx
.text$mn:000013BF                 jz      short loc_13ED
.text$mn:000013C1                 xor     edx, edx
.text$mn:000013C3                 mov     [ebp+EventTrack.cbSize], edx
.text$mn:000013C6                 mov     [ebp+EventTrack.dwFlags], edx
.text$mn:000013C9                 mov     [ebp+EventTrack.hwndTrack], edx
.text$mn:000013CC                 mov     [ebp+EventTrack.dwHoverTime], edx
.text$mn:000013CF                 mov     [ebp+EventTrack.cbSize], 10h
.text$mn:000013D6                 mov     [ebp+EventTrack.dwFlags], 2
.text$mn:000013DD                 mov     eax, [ebp+hWnd]
.text$mn:000013E0                 mov     [ebp+EventTrack.hwndTrack], eax
.text$mn:000013E3                 lea     ecx, [ebp+EventTrack]
.text$mn:000013E6                 push    ecx             ; lpEventTrack
.text$mn:000013E7                 call    dword ptr ds:__imp__TrackMouseEvent@4 ; TrackMouseEvent(x)
.text$mn:000013ED
.text$mn:000013ED loc_13ED:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+362j
.text$mn:000013ED                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long)+49Bj
.text$mn:000013ED                 jmp     loc_16FF        ; jumptable 00000FA1 default case
.text$mn:000013F2 ; ---------------------------------------------------------------------------
.text$mn:000013F2
.text$mn:000013F2 loc_13F2:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+98j
.text$mn:000013F2                 mov     edx, [ebp+var_18]
.text$mn:000013F5                 movzx   eax, byte ptr [edx+6Ch]
.text$mn:000013F9                 test    eax, eax
.text$mn:000013FB                 jz      short loc_1410
.text$mn:000013FD                 push    0               ; bErase
.text$mn:000013FF                 mov     ecx, [ebp+var_18]
.text$mn:00001402                 add     ecx, 48h ; 'H'
.text$mn:00001405                 push    ecx             ; lpRect
.text$mn:00001406                 mov     edx, [ebp+hWnd]
.text$mn:00001409                 push    edx             ; hWnd
.text$mn:0000140A                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:00001410
.text$mn:00001410 loc_1410:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+4D7j
.text$mn:00001410                 mov     eax, [ebp+var_18]
.text$mn:00001413                 mov     dword ptr [eax+58h], 0FFFFFFFFh
.text$mn:0000141A                 mov     ecx, [ebp+var_18]
.text$mn:0000141D                 add     ecx, 48h ; 'H'
.text$mn:00001420                 push    ecx             ; lprc
.text$mn:00001421                 call    dword ptr ds:__imp__SetRectEmpty@4 ; SetRectEmpty(x)
.text$mn:00001427                 mov     edx, [ebp+var_18]
.text$mn:0000142A                 mov     byte ptr [edx+6Ch], 0
.text$mn:0000142E                 jmp     loc_16FF        ; jumptable 00000FA1 default case
.text$mn:00001433 ; ---------------------------------------------------------------------------
.text$mn:00001433
.text$mn:00001433 $LN13:                                  ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+7Dj
.text$mn:00001433                                         ; DATA XREF: .text$mn:$LN49o
.text$mn:00001433                 mov     eax, [ebp+lParam] ; jumptable 00000FA1 case 1
.text$mn:00001436                 and     eax, 0FFFFh
.text$mn:0000143B                 movzx   ecx, ax
.text$mn:0000143E                 mov     [ebp+var_30], ecx
.text$mn:00001441                 mov     edx, [ebp+lParam]
.text$mn:00001444                 shr     edx, 10h
.text$mn:00001447                 and     edx, 0FFFFh
.text$mn:0000144D                 movzx   eax, dx
.text$mn:00001450                 mov     [ebp+var_40], eax
.text$mn:00001453                 mov     ecx, [ebp+var_40]
.text$mn:00001456                 push    ecx             ; int
.text$mn:00001457                 mov     edx, [ebp+var_30]
.text$mn:0000145A                 push    edx             ; int
.text$mn:0000145B                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000145E                 call    ?getTabIndexAt@TabBarPlus@@IAEHHH@Z ; TabBarPlus::getTabIndexAt(int,int)
.text$mn:00001463                 mov     [ebp+var_28], eax
.text$mn:00001466                 mov     eax, [ebp+var_18]
.text$mn:00001469                 movzx   ecx, byte ptr [eax+30h]
.text$mn:0000146D                 test    ecx, ecx
.text$mn:0000146F                 jz      short loc_14E9
.text$mn:00001471                 call    dword ptr ds:__imp__GetCapture@0 ; GetCapture()
.text$mn:00001477                 mov     edx, [ebp+var_18]
.text$mn:0000147A                 cmp     eax, [edx+0Ch]
.text$mn:0000147D                 jnz     short loc_1485
.text$mn:0000147F                 call    dword ptr ds:__imp__ReleaseCapture@0 ; ReleaseCapture()
.text$mn:00001485
.text$mn:00001485 loc_1485:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+559j
.text$mn:00001485                 mov     eax, [ebp+var_18]
.text$mn:00001488                 mov     ecx, [eax+0Ch]
.text$mn:0000148B                 mov     [ebp+var_CC], ecx
.text$mn:00001491                 mov     edx, [ebp+var_18]
.text$mn:00001494                 movzx   eax, byte ptr [edx+31h]
.text$mn:00001498                 test    eax, eax
.text$mn:0000149A                 jz      short loc_14A5
.text$mn:0000149C                 mov     [ebp+var_38], 0FFFFFDD0h
.text$mn:000014A3                 jmp     short loc_14AC
.text$mn:000014A5 ; ---------------------------------------------------------------------------
.text$mn:000014A5
.text$mn:000014A5 loc_14A5:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+576j
.text$mn:000014A5                 mov     [ebp+var_38], 0FFFFFDCFh
.text$mn:000014AC
.text$mn:000014AC loc_14AC:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+57Fj
.text$mn:000014AC                 mov     ecx, [ebp+var_38]
.text$mn:000014AF                 mov     [ebp+var_C4], ecx
.text$mn:000014B5                 mov     edx, [ebp+var_18]
.text$mn:000014B8                 mov     [ebp+var_C8], edx
.text$mn:000014BE                 mov     eax, [ebp+var_28]
.text$mn:000014C1                 mov     [ebp+var_C0], eax
.text$mn:000014C7                 lea     ecx, [ebp+var_CC]
.text$mn:000014CD                 push    ecx             ; lParam
.text$mn:000014CE                 push    0               ; wParam
.text$mn:000014D0                 push    4Eh ; 'N'       ; Msg
.text$mn:000014D2                 mov     edx, [ebp+var_18]
.text$mn:000014D5                 mov     eax, [edx+8]
.text$mn:000014D8                 push    eax             ; hWnd
.text$mn:000014D9                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000014DF                 mov     eax, 1
.text$mn:000014E4                 jmp     loc_171C
.text$mn:000014E9 ; ---------------------------------------------------------------------------
.text$mn:000014E9
.text$mn:000014E9 loc_14E9:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+54Bj
.text$mn:000014E9                 movzx   ecx, ds:?_drawTabCloseButton@TabBarPlus@@1_NA ; bool TabBarPlus::_drawTabCloseButton
.text$mn:000014F0                 test    ecx, ecx
.text$mn:000014F2                 jz      loc_1582
.text$mn:000014F8                 mov     edx, [ebp+var_18]
.text$mn:000014FB                 mov     eax, [edx+70h]
.text$mn:000014FE                 cmp     eax, [ebp+var_28]
.text$mn:00001501                 jnz     short loc_1578
.text$mn:00001503                 mov     ecx, [ebp+var_18]
.text$mn:00001506                 add     ecx, 48h ; 'H'
.text$mn:00001509                 push    ecx             ; struct tagRECT *
.text$mn:0000150A                 mov     edx, [ebp+var_40]
.text$mn:0000150D                 push    edx             ; int
.text$mn:0000150E                 mov     eax, [ebp+var_30]
.text$mn:00001511                 push    eax             ; int
.text$mn:00001512                 mov     ecx, [ebp+var_18]
.text$mn:00001515                 add     ecx, 5Ch ; '\'  ; this
.text$mn:00001518                 call    ?isHit@CloseButtonZone@@QBE_NHHABUtagRECT@@@Z ; CloseButtonZone::isHit(int,int,tagRECT const &)
.text$mn:0000151D                 movzx   ecx, al
.text$mn:00001520                 test    ecx, ecx
.text$mn:00001522                 jz      short loc_1578
.text$mn:00001524                 mov     edx, [ebp+var_18]
.text$mn:00001527                 mov     eax, [edx+0Ch]
.text$mn:0000152A                 mov     [ebp+var_AC], eax
.text$mn:00001530                 mov     [ebp+var_A4], 0FFFFFDCEh
.text$mn:0000153A                 mov     ecx, [ebp+var_18]
.text$mn:0000153D                 mov     [ebp+var_A8], ecx
.text$mn:00001543                 mov     edx, [ebp+var_28]
.text$mn:00001546                 mov     [ebp+var_A0], edx
.text$mn:0000154C                 lea     eax, [ebp+var_AC]
.text$mn:00001552                 push    eax             ; lParam
.text$mn:00001553                 push    0               ; wParam
.text$mn:00001555                 push    4Eh ; 'N'       ; Msg
.text$mn:00001557                 mov     ecx, [ebp+var_18]
.text$mn:0000155A                 mov     edx, [ecx+8]
.text$mn:0000155D                 push    edx             ; hWnd
.text$mn:0000155E                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001564                 mov     eax, [ebp+var_18]
.text$mn:00001567                 mov     dword ptr [eax+70h], 0FFFFFFFFh
.text$mn:0000156E                 mov     eax, 1
.text$mn:00001573                 jmp     loc_171C
.text$mn:00001578 ; ---------------------------------------------------------------------------
.text$mn:00001578
.text$mn:00001578 loc_1578:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+5DDj
.text$mn:00001578                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long)+5FEj
.text$mn:00001578                 mov     ecx, [ebp+var_18]
.text$mn:0000157B                 mov     dword ptr [ecx+70h], 0FFFFFFFFh
.text$mn:00001582
.text$mn:00001582 loc_1582:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+5CEj
.text$mn:00001582                 jmp     loc_16FF        ; jumptable 00000FA1 default case
.text$mn:00001587 ; ---------------------------------------------------------------------------
.text$mn:00001587
.text$mn:00001587 loc_1587:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+8Bj
.text$mn:00001587                 mov     edx, [ebp+var_18]
.text$mn:0000158A                 movzx   eax, byte ptr [edx+30h]
.text$mn:0000158E                 test    eax, eax
.text$mn:00001590                 jz      short loc_15A3
.text$mn:00001592                 mov     ecx, [ebp+var_18]
.text$mn:00001595                 mov     byte ptr [ecx+30h], 0
.text$mn:00001599                 mov     eax, 1
.text$mn:0000159E                 jmp     loc_171C
.text$mn:000015A3 ; ---------------------------------------------------------------------------
.text$mn:000015A3
.text$mn:000015A3 loc_15A3:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+66Cj
.text$mn:000015A3                 jmp     loc_16FF        ; jumptable 00000FA1 default case
.text$mn:000015A8 ; ---------------------------------------------------------------------------
.text$mn:000015A8
.text$mn:000015A8 loc_15A8:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+36j
.text$mn:000015A8                 mov     edx, [ebp+lParam]
.text$mn:000015AB                 push    edx             ; struct tagDRAWITEMSTRUCT *
.text$mn:000015AC                 mov     ecx, [ebp+var_18] ; this
.text$mn:000015AF                 call    ?drawItem@TabBarPlus@@IAEXPAUtagDRAWITEMSTRUCT@@@Z ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)
.text$mn:000015B4                 mov     eax, 1
.text$mn:000015B9                 jmp     loc_171C
.text$mn:000015BE ; ---------------------------------------------------------------------------
.text$mn:000015BE
.text$mn:000015BE loc_15BE:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+43j
.text$mn:000015BE                 cmp     [ebp+wParam], 0A2h ; 'ó'
.text$mn:000015C5                 jnz     short loc_15E0
.text$mn:000015C7                 push    offset CursorName ; lpCursorName
.text$mn:000015CC                 mov     eax, [ebp+var_18]
.text$mn:000015CF                 mov     ecx, [eax+4]
.text$mn:000015D2                 push    ecx             ; hInstance
.text$mn:000015D3                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:000015D9                 push    eax             ; hCursor
.text$mn:000015DA                 call    dword ptr ds:__imp__SetCursor@4 ; SetCursor(x)
.text$mn:000015E0
.text$mn:000015E0 loc_15E0:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+6A1j
.text$mn:000015E0                 mov     eax, 1
.text$mn:000015E5                 jmp     loc_171C
.text$mn:000015EA ; ---------------------------------------------------------------------------
.text$mn:000015EA
.text$mn:000015EA loc_15EA:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+5Ej
.text$mn:000015EA                 mov     edx, [ebp+lParam]
.text$mn:000015ED                 and     edx, 0FFFFh
.text$mn:000015F3                 movzx   eax, dx
.text$mn:000015F6                 mov     [ebp+var_74], eax
.text$mn:000015F9                 mov     ecx, [ebp+lParam]
.text$mn:000015FC                 shr     ecx, 10h
.text$mn:000015FF                 and     ecx, 0FFFFh
.text$mn:00001605                 movzx   edx, cx
.text$mn:00001608                 mov     [ebp+var_84], edx
.text$mn:0000160E                 mov     eax, [ebp+var_84]
.text$mn:00001614                 push    eax             ; int
.text$mn:00001615                 mov     ecx, [ebp+var_74]
.text$mn:00001618                 push    ecx             ; int
.text$mn:00001619                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000161C                 call    ?getTabIndexAt@TabBarPlus@@IAEHHH@Z ; TabBarPlus::getTabIndexAt(int,int)
.text$mn:00001621                 mov     [ebp+var_88], eax
.text$mn:00001627                 mov     edx, [ebp+var_18]
.text$mn:0000162A                 mov     eax, [edx+0Ch]
.text$mn:0000162D                 mov     [ebp+var_BC], eax
.text$mn:00001633                 mov     [ebp+var_B4], 0FFFFFDCEh
.text$mn:0000163D                 mov     ecx, [ebp+var_18]
.text$mn:00001640                 mov     [ebp+var_B8], ecx
.text$mn:00001646                 mov     edx, [ebp+var_88]
.text$mn:0000164C                 mov     [ebp+var_B0], edx
.text$mn:00001652                 lea     eax, [ebp+var_BC]
.text$mn:00001658                 push    eax             ; lParam
.text$mn:00001659                 push    0               ; wParam
.text$mn:0000165B                 push    4Eh ; 'N'       ; Msg
.text$mn:0000165D                 mov     ecx, [ebp+var_18]
.text$mn:00001660                 mov     edx, [ecx+8]
.text$mn:00001663                 push    edx             ; hWnd
.text$mn:00001664                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000166A                 mov     eax, 1
.text$mn:0000166F                 jmp     loc_171C
.text$mn:00001674 ; ---------------------------------------------------------------------------
.text$mn:00001674
.text$mn:00001674 $LN2_0:                                 ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+7Dj
.text$mn:00001674                                         ; DATA XREF: .text$mn:$LN49o
.text$mn:00001674                 movzx   eax, ds:?_isDbClk2Close@TabBarPlus@@1_NA ; jumptable 00000FA1 case 2
.text$mn:0000167B                 test    eax, eax
.text$mn:0000167D                 jz      short loc_16F8
.text$mn:0000167F                 mov     ecx, [ebp+lParam]
.text$mn:00001682                 and     ecx, 0FFFFh
.text$mn:00001688                 movzx   edx, cx
.text$mn:0000168B                 mov     [ebp+var_8C], edx
.text$mn:00001691                 mov     eax, [ebp+lParam]
.text$mn:00001694                 shr     eax, 10h
.text$mn:00001697                 and     eax, 0FFFFh
.text$mn:0000169C                 movzx   ecx, ax
.text$mn:0000169F                 mov     [ebp+var_60], ecx
.text$mn:000016A2                 mov     edx, [ebp+var_60]
.text$mn:000016A5                 push    edx             ; int
.text$mn:000016A6                 mov     eax, [ebp+var_8C]
.text$mn:000016AC                 push    eax             ; int
.text$mn:000016AD                 mov     ecx, [ebp+var_18] ; this
.text$mn:000016B0                 call    ?getTabIndexAt@TabBarPlus@@IAEHHH@Z ; TabBarPlus::getTabIndexAt(int,int)
.text$mn:000016B5                 mov     [ebp+var_80], eax
.text$mn:000016B8                 mov     ecx, [ebp+var_18]
.text$mn:000016BB                 mov     edx, [ecx+0Ch]
.text$mn:000016BE                 mov     [ebp+var_DC], edx
.text$mn:000016C4                 mov     [ebp+var_D4], 0FFFFFDCEh
.text$mn:000016CE                 mov     eax, [ebp+var_18]
.text$mn:000016D1                 mov     [ebp+var_D8], eax
.text$mn:000016D7                 mov     ecx, [ebp+var_80]
.text$mn:000016DA                 mov     [ebp+var_D0], ecx
.text$mn:000016E0                 lea     edx, [ebp+var_DC]
.text$mn:000016E6                 push    edx             ; lParam
.text$mn:000016E7                 push    0               ; wParam
.text$mn:000016E9                 push    4Eh ; 'N'       ; Msg
.text$mn:000016EB                 mov     eax, [ebp+var_18]
.text$mn:000016EE                 mov     ecx, [eax+8]
.text$mn:000016F1                 push    ecx             ; hWnd
.text$mn:000016F2                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000016F8
.text$mn:000016F8 loc_16F8:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+759j
.text$mn:000016F8                 mov     eax, 1
.text$mn:000016FD                 jmp     short loc_171C
.text$mn:000016FF ; ---------------------------------------------------------------------------
.text$mn:000016FF
.text$mn:000016FF loc_16FF:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+49j
.text$mn:000016FF                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long)+74j ...
.text$mn:000016FF                 mov     edx, [ebp+lParam] ; jumptable 00000FA1 default case
.text$mn:00001702                 push    edx             ; lParam
.text$mn:00001703                 mov     eax, [ebp+wParam]
.text$mn:00001706                 push    eax             ; wParam
.text$mn:00001707                 mov     ecx, [ebp+Msg]
.text$mn:0000170A                 push    ecx             ; Msg
.text$mn:0000170B                 mov     edx, [ebp+hWnd]
.text$mn:0000170E                 push    edx             ; hWnd
.text$mn:0000170F                 mov     eax, [ebp+var_18]
.text$mn:00001712                 mov     ecx, [eax+44h]
.text$mn:00001715                 push    ecx             ; lpPrevWndFunc
.text$mn:00001716                 call    dword ptr ds:__imp__CallWindowProcW@20 ; CallWindowProcW(x,x,x,x,x)
.text$mn:0000171C
.text$mn:0000171C loc_171C:                               ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+140j
.text$mn:0000171C                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long)+1C5j ...
.text$mn:0000171C                 mov     ecx, [ebp+var_4]
.text$mn:0000171F                 xor     ecx, ebp
.text$mn:00001721                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001726                 mov     esp, ebp
.text$mn:00001728                 pop     ebp
.text$mn:00001729                 retn    10h
.text$mn:00001729 ?runProc@TabBarPlus@@IAEJPAUHWND__@@IIJ@Z endp
.text$mn:00001729
.text$mn:00001729 ; ---------------------------------------------------------------------------
.text$mn:0000172C $LN49           dd offset $LN33         ; DATA XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+7Dr
.text$mn:0000172C                 dd offset $LN13         ; jump table for switch statement
.text$mn:0000172C                 dd offset $LN2_0
.text$mn:0000172C                 dd offset $LN27
.text$mn:0000173C                 db 8 dup(0CCh)
.text$mn:00001744
.text$mn:00001744 ; =============== S U B R O U T I N E =======================================
.text$mn:00001744
.text$mn:00001744 ; Attributes: bp-based frame
.text$mn:00001744
.text$mn:00001744 ; void __thiscall TabBarPlus::exchangeItemData(TabBarPlus *this, struct tagPOINT)
.text$mn:00001744                 public ?exchangeItemData@TabBarPlus@@IAEXUtagPOINT@@@Z
.text$mn:00001744 ?exchangeItemData@TabBarPlus@@IAEXUtagPOINT@@@Z proc near
.text$mn:00001744                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+32Ap
.text$mn:00001744
.text$mn:00001744 lParam          = dword ptr -450h
.text$mn:00001744 var_444         = dword ptr -444h
.text$mn:00001744 var_440         = dword ptr -440h
.text$mn:00001744 var_434         = dword ptr -434h
.text$mn:00001744 var_430         = dword ptr -430h
.text$mn:00001744 var_424         = dword ptr -424h
.text$mn:00001744 var_420         = dword ptr -420h
.text$mn:00001744 var_414         = dword ptr -414h
.text$mn:00001744 var_410         = dword ptr -410h
.text$mn:00001744 wParam          = dword ptr -40Ch
.text$mn:00001744 var_408         = dword ptr -408h
.text$mn:00001744 var_404         = byte ptr -404h
.text$mn:00001744 var_204         = byte ptr -204h
.text$mn:00001744 var_4           = dword ptr -4
.text$mn:00001744 arg_0           = tagPOINT ptr  8
.text$mn:00001744
.text$mn:00001744                 push    ebp
.text$mn:00001745                 mov     ebp, esp
.text$mn:00001747                 sub     esp, 450h
.text$mn:0000174D                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001752                 xor     eax, ebp
.text$mn:00001754                 mov     [ebp+var_4], eax
.text$mn:00001757                 mov     [ebp+var_408], ecx
.text$mn:0000175D                 lea     eax, [ebp+arg_0]
.text$mn:00001760                 push    eax             ; struct tagPOINT *
.text$mn:00001761                 mov     ecx, [ebp+var_408] ; this
.text$mn:00001767                 call    ?getTabIndexAt@TabBarPlus@@IAEHABUtagPOINT@@@Z ; TabBarPlus::getTabIndexAt(tagPOINT const &)
.text$mn:0000176C                 mov     [ebp+wParam], eax
.text$mn:00001772                 cmp     [ebp+wParam], 0FFFFFFFFh
.text$mn:00001779                 jz      loc_1988
.text$mn:0000177F                 mov     ecx, [ebp+var_408]
.text$mn:00001785                 mov     byte ptr [ecx+31h], 1
.text$mn:00001789                 mov     edx, [ebp+var_408]
.text$mn:0000178F                 mov     eax, [ebp+wParam]
.text$mn:00001795                 cmp     eax, [edx+38h]
.text$mn:00001798                 jz      loc_1986
.text$mn:0000179E                 push    0               ; lParam
.text$mn:000017A0                 mov     ecx, [ebp+wParam]
.text$mn:000017A6                 push    ecx             ; wParam
.text$mn:000017A7                 push    130Ch           ; Msg
.text$mn:000017AC                 mov     edx, [ebp+var_408]
.text$mn:000017B2                 mov     eax, [edx+0Ch]
.text$mn:000017B5                 push    eax             ; hWnd
.text$mn:000017B6                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000017BC                 mov     [ebp+var_430], 0Bh
.text$mn:000017C6                 mov     ecx, [ebp+var_430]
.text$mn:000017CC                 mov     [ebp+lParam], ecx
.text$mn:000017D2                 mov     [ebp+var_434], 100h
.text$mn:000017DC                 lea     edx, [ebp+var_204]
.text$mn:000017E2                 mov     [ebp+var_444], edx
.text$mn:000017E8                 mov     [ebp+var_440], 100h
.text$mn:000017F2                 lea     eax, [ebp+var_404]
.text$mn:000017F8                 mov     [ebp+var_424], eax
.text$mn:000017FE                 mov     [ebp+var_420], 100h
.text$mn:00001808                 lea     ecx, [ebp+lParam]
.text$mn:0000180E                 push    ecx             ; lParam
.text$mn:0000180F                 mov     edx, [ebp+var_408]
.text$mn:00001815                 mov     eax, [edx+38h]
.text$mn:00001818                 push    eax             ; wParam
.text$mn:00001819                 push    133Ch           ; Msg
.text$mn:0000181E                 mov     ecx, [ebp+var_408]
.text$mn:00001824                 mov     edx, [ecx+0Ch]
.text$mn:00001827                 push    edx             ; hWnd
.text$mn:00001828                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000182E                 mov     eax, [ebp+var_408]
.text$mn:00001834                 mov     ecx, [eax+38h]
.text$mn:00001837                 cmp     ecx, [ebp+wParam]
.text$mn:0000183D                 jle     short loc_18BA
.text$mn:0000183F                 mov     edx, [ebp+var_408]
.text$mn:00001845                 mov     eax, [edx+38h]
.text$mn:00001848                 mov     [ebp+var_414], eax
.text$mn:0000184E                 jmp     short loc_185F
.text$mn:00001850 ; ---------------------------------------------------------------------------
.text$mn:00001850
.text$mn:00001850 loc_1850:                               ; CODE XREF: TabBarPlus::exchangeItemData(tagPOINT)+172j
.text$mn:00001850                 mov     ecx, [ebp+var_414]
.text$mn:00001856                 sub     ecx, 1
.text$mn:00001859                 mov     [ebp+var_414], ecx
.text$mn:0000185F
.text$mn:0000185F loc_185F:                               ; CODE XREF: TabBarPlus::exchangeItemData(tagPOINT)+10Aj
.text$mn:0000185F                 mov     edx, [ebp+var_414]
.text$mn:00001865                 cmp     edx, [ebp+wParam]
.text$mn:0000186B                 jle     short loc_18B8
.text$mn:0000186D                 lea     eax, [ebp+var_430]
.text$mn:00001873                 push    eax             ; lParam
.text$mn:00001874                 mov     ecx, [ebp+var_414]
.text$mn:0000187A                 sub     ecx, 1
.text$mn:0000187D                 push    ecx             ; wParam
.text$mn:0000187E                 push    133Ch           ; Msg
.text$mn:00001883                 mov     edx, [ebp+var_408]
.text$mn:00001889                 mov     eax, [edx+0Ch]
.text$mn:0000188C                 push    eax             ; hWnd
.text$mn:0000188D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001893                 lea     ecx, [ebp+var_430]
.text$mn:00001899                 push    ecx             ; lParam
.text$mn:0000189A                 mov     edx, [ebp+var_414]
.text$mn:000018A0                 push    edx             ; wParam
.text$mn:000018A1                 push    133Dh           ; Msg
.text$mn:000018A6                 mov     eax, [ebp+var_408]
.text$mn:000018AC                 mov     ecx, [eax+0Ch]
.text$mn:000018AF                 push    ecx             ; hWnd
.text$mn:000018B0                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000018B6                 jmp     short loc_1850
.text$mn:000018B8 ; ---------------------------------------------------------------------------
.text$mn:000018B8
.text$mn:000018B8 loc_18B8:                               ; CODE XREF: TabBarPlus::exchangeItemData(tagPOINT)+127j
.text$mn:000018B8                 jmp     short loc_1933
.text$mn:000018BA ; ---------------------------------------------------------------------------
.text$mn:000018BA
.text$mn:000018BA loc_18BA:                               ; CODE XREF: TabBarPlus::exchangeItemData(tagPOINT)+F9j
.text$mn:000018BA                 mov     edx, [ebp+var_408]
.text$mn:000018C0                 mov     eax, [edx+38h]
.text$mn:000018C3                 mov     [ebp+var_410], eax
.text$mn:000018C9                 jmp     short loc_18DA
.text$mn:000018CB ; ---------------------------------------------------------------------------
.text$mn:000018CB
.text$mn:000018CB loc_18CB:                               ; CODE XREF: TabBarPlus::exchangeItemData(tagPOINT)+1EDj
.text$mn:000018CB                 mov     ecx, [ebp+var_410]
.text$mn:000018D1                 add     ecx, 1
.text$mn:000018D4                 mov     [ebp+var_410], ecx
.text$mn:000018DA
.text$mn:000018DA loc_18DA:                               ; CODE XREF: TabBarPlus::exchangeItemData(tagPOINT)+185j
.text$mn:000018DA                 mov     edx, [ebp+var_410]
.text$mn:000018E0                 cmp     edx, [ebp+wParam]
.text$mn:000018E6                 jge     short loc_1933
.text$mn:000018E8                 lea     eax, [ebp+var_430]
.text$mn:000018EE                 push    eax             ; lParam
.text$mn:000018EF                 mov     ecx, [ebp+var_410]
.text$mn:000018F5                 add     ecx, 1
.text$mn:000018F8                 push    ecx             ; wParam
.text$mn:000018F9                 push    133Ch           ; Msg
.text$mn:000018FE                 mov     edx, [ebp+var_408]
.text$mn:00001904                 mov     eax, [edx+0Ch]
.text$mn:00001907                 push    eax             ; hWnd
.text$mn:00001908                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000190E                 lea     ecx, [ebp+var_430]
.text$mn:00001914                 push    ecx             ; lParam
.text$mn:00001915                 mov     edx, [ebp+var_410]
.text$mn:0000191B                 push    edx             ; wParam
.text$mn:0000191C                 push    133Dh           ; Msg
.text$mn:00001921                 mov     eax, [ebp+var_408]
.text$mn:00001927                 mov     ecx, [eax+0Ch]
.text$mn:0000192A                 push    ecx             ; hWnd
.text$mn:0000192B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001931                 jmp     short loc_18CB
.text$mn:00001933 ; ---------------------------------------------------------------------------
.text$mn:00001933
.text$mn:00001933 loc_1933:                               ; CODE XREF: TabBarPlus::exchangeItemData(tagPOINT):loc_18B8j
.text$mn:00001933                                         ; TabBarPlus::exchangeItemData(tagPOINT)+1A2j
.text$mn:00001933                 lea     edx, [ebp+lParam]
.text$mn:00001939                 push    edx             ; lParam
.text$mn:0000193A                 mov     eax, [ebp+wParam]
.text$mn:00001940                 push    eax             ; wParam
.text$mn:00001941                 push    133Dh           ; Msg
.text$mn:00001946                 mov     ecx, [ebp+var_408]
.text$mn:0000194C                 mov     edx, [ecx+0Ch]
.text$mn:0000194F                 push    edx             ; hWnd
.text$mn:00001950                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001956                 mov     eax, [ebp+var_408]
.text$mn:0000195C                 mov     ecx, [ebp+wParam]
.text$mn:00001962                 mov     [eax+38h], ecx
.text$mn:00001965                 mov     edx, [ebp+var_408]
.text$mn:0000196B                 mov     eax, [edx+38h]
.text$mn:0000196E                 push    eax             ; lParam
.text$mn:0000196F                 push    0               ; wParam
.text$mn:00001971                 push    420h            ; Msg
.text$mn:00001976                 mov     ecx, [ebp+var_408]
.text$mn:0000197C                 mov     edx, [ecx+8]
.text$mn:0000197F                 push    edx             ; hWnd
.text$mn:00001980                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001986
.text$mn:00001986 loc_1986:                               ; CODE XREF: TabBarPlus::exchangeItemData(tagPOINT)+54j
.text$mn:00001986                 jmp     short loc_1992
.text$mn:00001988 ; ---------------------------------------------------------------------------
.text$mn:00001988
.text$mn:00001988 loc_1988:                               ; CODE XREF: TabBarPlus::exchangeItemData(tagPOINT)+35j
.text$mn:00001988                 mov     eax, [ebp+var_408]
.text$mn:0000198E                 mov     byte ptr [eax+31h], 0
.text$mn:00001992
.text$mn:00001992 loc_1992:                               ; CODE XREF: TabBarPlus::exchangeItemData(tagPOINT):loc_1986j
.text$mn:00001992                 mov     ecx, [ebp+var_4]
.text$mn:00001995                 xor     ecx, ebp
.text$mn:00001997                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000199C                 mov     esp, ebp
.text$mn:0000199E                 pop     ebp
.text$mn:0000199F                 retn    8
.text$mn:0000199F ?exchangeItemData@TabBarPlus@@IAEXUtagPOINT@@@Z endp
.text$mn:0000199F
.text$mn:0000199F ; ---------------------------------------------------------------------------
.text$mn:000019A2                 align 4
.text$mn:000019A4
.text$mn:000019A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000019A4
.text$mn:000019A4 ; Attributes: bp-based frame
.text$mn:000019A4
.text$mn:000019A4 ; void __thiscall TabBarPlus::drawItem(TabBarPlus *this, struct tagDRAWITEMSTRUCT *)
.text$mn:000019A4                 public ?drawItem@TabBarPlus@@IAEXPAUtagDRAWITEMSTRUCT@@@Z
.text$mn:000019A4 ?drawItem@TabBarPlus@@IAEXPAUtagDRAWITEMSTRUCT@@@Z proc near
.text$mn:000019A4                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+68Bp
.text$mn:000019A4
.text$mn:000019A4 pv              = byte ptr -530h
.text$mn:000019A4 wSrc            = dword ptr -52Ch
.text$mn:000019A4 hSrc            = dword ptr -528h
.text$mn:000019A4 sz              = tagSIZE ptr -518h
.text$mn:000019A4 lParam          = dword ptr -510h
.text$mn:000019A4 var_504         = dword ptr -504h
.text$mn:000019A4 var_500         = dword ptr -500h
.text$mn:000019A4 i               = dword ptr -4FCh
.text$mn:000019A4 wDest           = dword ptr -4F4h
.text$mn:000019A4 nSavedDC        = dword ptr -4F0h
.text$mn:000019A4 var_4EC         = dword ptr -4ECh
.text$mn:000019A4 var_4E8         = dword ptr -4E8h
.text$mn:000019A4 var_4E4         = dword ptr -4E4h
.text$mn:000019A4 var_4E0         = dword ptr -4E0h
.text$mn:000019A4 var_4DC         = dword ptr -4DCh
.text$mn:000019A4 y               = dword ptr -4D8h
.text$mn:000019A4 var_4D4         = dword ptr -4D4h
.text$mn:000019A4 var_4D0         = dword ptr -4D0h
.text$mn:000019A4 var_4CC         = dword ptr -4CCh
.text$mn:000019A4 var_4C8         = dword ptr -4C8h
.text$mn:000019A4 var_4C4         = dword ptr -4C4h
.text$mn:000019A4 fStyle          = dword ptr -4C0h
.text$mn:000019A4 x               = dword ptr -4BCh
.text$mn:000019A4 hDest           = dword ptr -4B8h
.text$mn:000019A4 var_4B4         = dword ptr -4B4h
.text$mn:000019A4 hdcSrc          = dword ptr -4B0h
.text$mn:000019A4 h               = dword ptr -4ACh
.text$mn:000019A4 var_4A8         = dword ptr -4A8h
.text$mn:000019A4 var_4A4         = dword ptr -4A4h
.text$mn:000019A4 himl            = dword ptr -4A0h
.text$mn:000019A4 wParam          = dword ptr -49Ch
.text$mn:000019A4 var_495         = byte ptr -495h
.text$mn:000019A4 var_494         = dword ptr -494h
.text$mn:000019A4 var_490         = dword ptr -490h
.text$mn:000019A4 var_48C         = dword ptr -48Ch
.text$mn:000019A4 hbr             = dword ptr -488h
.text$mn:000019A4 format          = dword ptr -484h
.text$mn:000019A4 hdc             = dword ptr -480h
.text$mn:000019A4 var_47C         = dword ptr -47Ch
.text$mn:000019A4 var_475         = byte ptr -475h
.text$mn:000019A4 pImageInfo      = IMAGEINFO ptr -474h
.text$mn:000019A4 var_454         = RECT ptr -454h
.text$mn:000019A4 var_444         = RECT ptr -444h
.text$mn:000019A4 xDest           = dword ptr -434h
.text$mn:000019A4 yDest           = dword ptr -430h
.text$mn:000019A4 rc              = RECT ptr -424h
.text$mn:000019A4 var_414         = byte ptr -414h
.text$mn:000019A4 String          = word ptr -20Ch
.text$mn:000019A4 var_4           = dword ptr -4
.text$mn:000019A4 arg_0           = dword ptr  8
.text$mn:000019A4
.text$mn:000019A4                 push    ebp
.text$mn:000019A5                 mov     ebp, esp
.text$mn:000019A7                 sub     esp, 530h
.text$mn:000019AD                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000019B2                 xor     eax, ebp
.text$mn:000019B4                 mov     [ebp+var_4], eax
.text$mn:000019B7                 push    esi
.text$mn:000019B8                 mov     [ebp+var_47C], ecx
.text$mn:000019BE                 mov     eax, [ebp+arg_0]
.text$mn:000019C1                 add     eax, 1Ch
.text$mn:000019C4                 mov     ecx, [eax]
.text$mn:000019C6                 mov     [ebp+rc.left], ecx
.text$mn:000019CC                 mov     edx, [eax+4]
.text$mn:000019CF                 mov     [ebp+rc.top], edx
.text$mn:000019D5                 mov     ecx, [eax+8]
.text$mn:000019D8                 mov     [ebp+rc.right], ecx
.text$mn:000019DE                 mov     edx, [eax+0Ch]
.text$mn:000019E1                 mov     [ebp+rc.bottom], edx
.text$mn:000019E7                 mov     eax, [ebp+arg_0]
.text$mn:000019EA                 mov     ecx, [eax+8]
.text$mn:000019ED                 mov     [ebp+wParam], ecx
.text$mn:000019F3                 cmp     [ebp+wParam], 0
.text$mn:000019FA                 jge     short loc_1A10
.text$mn:000019FC                 push    0               ; uType
.text$mn:000019FE                 push    offset $SG123670 ; lpCaption
.text$mn:00001A03                 push    offset $SG123671 ; "nTab < 0"
.text$mn:00001A08                 push    0               ; hWnd
.text$mn:00001A0A                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:00001A10
.text$mn:00001A10 loc_1A10:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+56j
.text$mn:00001A10                 push    0               ; lParam
.text$mn:00001A12                 push    0               ; wParam
.text$mn:00001A14                 push    130Bh           ; Msg
.text$mn:00001A19                 mov     edx, [ebp+var_47C]
.text$mn:00001A1F                 mov     eax, [edx+0Ch]
.text$mn:00001A22                 push    eax             ; hWnd
.text$mn:00001A23                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001A29                 cmp     [ebp+wParam], eax
.text$mn:00001A2F                 jnz     short loc_1A3D
.text$mn:00001A31                 mov     [ebp+var_4E4], 1
.text$mn:00001A3B                 jmp     short loc_1A47
.text$mn:00001A3D ; ---------------------------------------------------------------------------
.text$mn:00001A3D
.text$mn:00001A3D loc_1A3D:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+8Bj
.text$mn:00001A3D                 mov     [ebp+var_4E4], 0
.text$mn:00001A47
.text$mn:00001A47 loc_1A47:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+97j
.text$mn:00001A47                 mov     cl, byte ptr [ebp+var_4E4]
.text$mn:00001A4D                 mov     [ebp+var_475], cl
.text$mn:00001A53                 mov     [ebp+lParam], 3
.text$mn:00001A5D                 lea     edx, [ebp+var_414]
.text$mn:00001A63                 mov     [ebp+var_504], edx
.text$mn:00001A69                 mov     [ebp+var_500], 103h
.text$mn:00001A73                 lea     eax, [ebp+lParam]
.text$mn:00001A79                 push    eax             ; lParam
.text$mn:00001A7A                 mov     ecx, [ebp+wParam]
.text$mn:00001A80                 push    ecx             ; wParam
.text$mn:00001A81                 push    133Ch           ; Msg
.text$mn:00001A86                 mov     edx, [ebp+var_47C]
.text$mn:00001A8C                 mov     eax, [edx+0Ch]
.text$mn:00001A8F                 push    eax             ; hWnd
.text$mn:00001A90                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001A96                 test    eax, eax
.text$mn:00001A98                 jnz     short loc_1AAE
.text$mn:00001A9A                 push    0               ; uType
.text$mn:00001A9C                 push    offset $SG123677 ; lpCaption
.text$mn:00001AA1                 push    offset $SG123678 ; "! TCM_GETITEM"
.text$mn:00001AA6                 push    0               ; hWnd
.text$mn:00001AA8                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:00001AAE
.text$mn:00001AAE loc_1AAE:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+F4j
.text$mn:00001AAE                 mov     ecx, [ebp+arg_0]
.text$mn:00001AB1                 mov     edx, [ecx+18h]
.text$mn:00001AB4                 mov     [ebp+hdc], edx
.text$mn:00001ABA                 mov     eax, [ebp+hdc]
.text$mn:00001AC0                 push    eax             ; hdc
.text$mn:00001AC1                 call    dword ptr ds:__imp__SaveDC@4 ; SaveDC(x)
.text$mn:00001AC7                 mov     [ebp+nSavedDC], eax
.text$mn:00001ACD                 push    1               ; mode
.text$mn:00001ACF                 mov     ecx, [ebp+hdc]
.text$mn:00001AD5                 push    ecx             ; hdc
.text$mn:00001AD6                 call    dword ptr ds:__imp__SetBkMode@8 ; SetBkMode(x,x)
.text$mn:00001ADC                 push    0Fh             ; nIndex
.text$mn:00001ADE                 call    dword ptr ds:__imp__GetSysColor@4 ; GetSysColor(x)
.text$mn:00001AE4                 push    eax             ; color
.text$mn:00001AE5                 call    dword ptr ds:__imp__CreateSolidBrush@4 ; CreateSolidBrush(x)
.text$mn:00001AEB                 mov     [ebp+hbr], eax
.text$mn:00001AF1                 mov     edx, [ebp+hbr]
.text$mn:00001AF7                 push    edx             ; hbr
.text$mn:00001AF8                 lea     eax, [ebp+rc]
.text$mn:00001AFE                 push    eax             ; lprc
.text$mn:00001AFF                 mov     ecx, [ebp+hdc]
.text$mn:00001B05                 push    ecx             ; hDC
.text$mn:00001B06                 call    dword ptr ds:__imp__FillRect@12 ; FillRect(x,x,x)
.text$mn:00001B0C                 mov     edx, [ebp+hbr]
.text$mn:00001B12                 push    edx             ; ho
.text$mn:00001B13                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00001B19                 movzx   eax, [ebp+var_475]
.text$mn:00001B20                 test    eax, eax
.text$mn:00001B22                 jz      loc_1C64
.text$mn:00001B28                 movzx   ecx, ds:?_drawTopBar@TabBarPlus@@1_NA ; bool TabBarPlus::_drawTopBar
.text$mn:00001B2F                 test    ecx, ecx
.text$mn:00001B31                 jz      loc_1C62
.text$mn:00001B37                 mov     edx, [ebp+rc.left]
.text$mn:00001B3D                 mov     [ebp+var_444.left], edx
.text$mn:00001B43                 mov     eax, [ebp+rc.top]
.text$mn:00001B49                 mov     [ebp+var_444.top], eax
.text$mn:00001B4F                 mov     ecx, [ebp+rc.right]
.text$mn:00001B55                 mov     [ebp+var_444.right], ecx
.text$mn:00001B5B                 mov     edx, [ebp+rc.bottom]
.text$mn:00001B61                 mov     [ebp+var_444.bottom], edx
.text$mn:00001B67                 push    6               ; int
.text$mn:00001B69                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00001B6E                 add     eax, 0Ch
.text$mn:00001B71                 mov     ecx, eax        ; this
.text$mn:00001B73                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:00001B78                 mov     [ebp+var_4CC], eax
.text$mn:00001B7E                 push    2               ; int
.text$mn:00001B80                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00001B85                 add     eax, 0Ch
.text$mn:00001B88                 mov     ecx, eax        ; this
.text$mn:00001B8A                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:00001B8F                 mov     [ebp+var_4D4], eax
.text$mn:00001B95                 mov     eax, [ebp+var_47C]
.text$mn:00001B9B                 movzx   ecx, byte ptr [eax+2Dh]
.text$mn:00001B9F                 test    ecx, ecx
.text$mn:00001BA1                 jz      short loc_1BC9
.text$mn:00001BA3                 mov     edx, [ebp+var_444.left]
.text$mn:00001BA9                 add     edx, [ebp+var_4CC]
.text$mn:00001BAF                 mov     [ebp+var_444.right], edx
.text$mn:00001BB5                 mov     eax, [ebp+rc.left]
.text$mn:00001BBB                 add     eax, [ebp+var_4D4]
.text$mn:00001BC1                 mov     [ebp+rc.left], eax
.text$mn:00001BC7                 jmp     short loc_1BED
.text$mn:00001BC9 ; ---------------------------------------------------------------------------
.text$mn:00001BC9
.text$mn:00001BC9 loc_1BC9:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+1FDj
.text$mn:00001BC9                 mov     ecx, [ebp+var_444.top]
.text$mn:00001BCF                 add     ecx, [ebp+var_4CC]
.text$mn:00001BD5                 mov     [ebp+var_444.bottom], ecx
.text$mn:00001BDB                 mov     edx, [ebp+rc.top]
.text$mn:00001BE1                 add     edx, [ebp+var_4D4]
.text$mn:00001BE7                 mov     [ebp+rc.top], edx
.text$mn:00001BED
.text$mn:00001BED loc_1BED:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+223j
.text$mn:00001BED                 mov     eax, [ebp+var_47C]
.text$mn:00001BF3                 mov     ecx, [eax+0Ch]
.text$mn:00001BF6                 push    ecx             ; lParam
.text$mn:00001BF7                 push    0               ; wParam
.text$mn:00001BF9                 push    40Dh            ; Msg
.text$mn:00001BFE                 mov     edx, [ebp+var_47C]
.text$mn:00001C04                 mov     eax, [edx+8]
.text$mn:00001C07                 push    eax             ; hWnd
.text$mn:00001C08                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001C0E                 test    eax, eax
.text$mn:00001C10                 jz      short loc_1C27
.text$mn:00001C12                 mov     ecx, ds:?_activeTopBarFocusedColour@TabBarPlus@@1KA ; ulong TabBarPlus::_activeTopBarFocusedColour
.text$mn:00001C18                 push    ecx             ; color
.text$mn:00001C19                 call    dword ptr ds:__imp__CreateSolidBrush@4 ; CreateSolidBrush(x)
.text$mn:00001C1F                 mov     [ebp+hbr], eax
.text$mn:00001C25                 jmp     short loc_1C3A
.text$mn:00001C27 ; ---------------------------------------------------------------------------
.text$mn:00001C27
.text$mn:00001C27 loc_1C27:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+26Cj
.text$mn:00001C27                 mov     edx, ds:?_activeTopBarUnfocusedColour@TabBarPlus@@1KA ; ulong TabBarPlus::_activeTopBarUnfocusedColour
.text$mn:00001C2D                 push    edx             ; color
.text$mn:00001C2E                 call    dword ptr ds:__imp__CreateSolidBrush@4 ; CreateSolidBrush(x)
.text$mn:00001C34                 mov     [ebp+hbr], eax
.text$mn:00001C3A
.text$mn:00001C3A loc_1C3A:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+281j
.text$mn:00001C3A                 mov     eax, [ebp+hbr]
.text$mn:00001C40                 push    eax             ; hbr
.text$mn:00001C41                 lea     ecx, [ebp+var_444]
.text$mn:00001C47                 push    ecx             ; lprc
.text$mn:00001C48                 mov     edx, [ebp+hdc]
.text$mn:00001C4E                 push    edx             ; hDC
.text$mn:00001C4F                 call    dword ptr ds:__imp__FillRect@12 ; FillRect(x,x,x)
.text$mn:00001C55                 mov     eax, [ebp+hbr]
.text$mn:00001C5B                 push    eax             ; ho
.text$mn:00001C5C                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00001C62
.text$mn:00001C62 loc_1C62:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+18Dj
.text$mn:00001C62                 jmp     short loc_1CD9
.text$mn:00001C64 ; ---------------------------------------------------------------------------
.text$mn:00001C64
.text$mn:00001C64 loc_1C64:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+17Ej
.text$mn:00001C64                 movzx   ecx, ds:?_drawInactiveTab@TabBarPlus@@1_NA ; bool TabBarPlus::_drawInactiveTab
.text$mn:00001C6B                 test    ecx, ecx
.text$mn:00001C6D                 jz      short loc_1CD9
.text$mn:00001C6F                 mov     edx, [ebp+rc.left]
.text$mn:00001C75                 mov     [ebp+var_454.left], edx
.text$mn:00001C7B                 mov     eax, [ebp+rc.top]
.text$mn:00001C81                 mov     [ebp+var_454.top], eax
.text$mn:00001C87                 mov     ecx, [ebp+rc.right]
.text$mn:00001C8D                 mov     [ebp+var_454.right], ecx
.text$mn:00001C93                 mov     edx, [ebp+rc.bottom]
.text$mn:00001C99                 mov     [ebp+var_454.bottom], edx
.text$mn:00001C9F                 mov     eax, ds:?_inactiveBgColour@TabBarPlus@@1KA ; ulong TabBarPlus::_inactiveBgColour
.text$mn:00001CA4                 push    eax             ; color
.text$mn:00001CA5                 call    dword ptr ds:__imp__CreateSolidBrush@4 ; CreateSolidBrush(x)
.text$mn:00001CAB                 mov     [ebp+hbr], eax
.text$mn:00001CB1                 mov     ecx, [ebp+hbr]
.text$mn:00001CB7                 push    ecx             ; hbr
.text$mn:00001CB8                 lea     edx, [ebp+var_454]
.text$mn:00001CBE                 push    edx             ; lprc
.text$mn:00001CBF                 mov     eax, [ebp+hdc]
.text$mn:00001CC5                 push    eax             ; hDC
.text$mn:00001CC6                 call    dword ptr ds:__imp__FillRect@12 ; FillRect(x,x,x)
.text$mn:00001CCC                 mov     ecx, [ebp+hbr]
.text$mn:00001CD2                 push    ecx             ; ho
.text$mn:00001CD3                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00001CD9
.text$mn:00001CD9 loc_1CD9:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *):loc_1C62j
.text$mn:00001CD9                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+2C9j
.text$mn:00001CD9                 movzx   edx, ds:?_drawTabCloseButton@TabBarPlus@@1_NA ; bool TabBarPlus::_drawTabCloseButton
.text$mn:00001CE0                 test    edx, edx
.text$mn:00001CE2                 jz      loc_1F2F
.text$mn:00001CE8                 lea     eax, [ebp+rc]
.text$mn:00001CEE                 push    eax             ; struct tagRECT *
.text$mn:00001CEF                 lea     ecx, [ebp+xDest]
.text$mn:00001CF5                 push    ecx             ; retstr
.text$mn:00001CF6                 mov     ecx, [ebp+var_47C]
.text$mn:00001CFC                 add     ecx, 5Ch ; '\'  ; this
.text$mn:00001CFF                 call    ?getButtonRectFrom@CloseButtonZone@@QBE?AUtagRECT@@ABU2@@Z ; CloseButtonZone::getButtonRectFrom(tagRECT const &)
.text$mn:00001D04                 movzx   edx, [ebp+var_475]
.text$mn:00001D0B                 test    edx, edx
.text$mn:00001D0D                 jz      short loc_1D2E
.text$mn:00001D0F                 mov     eax, [ebp+var_47C]
.text$mn:00001D15                 movzx   ecx, byte ptr [eax+2Dh]
.text$mn:00001D19                 test    ecx, ecx
.text$mn:00001D1B                 jnz     short loc_1D2C
.text$mn:00001D1D                 mov     edx, [ebp+xDest]
.text$mn:00001D23                 sub     edx, 2
.text$mn:00001D26                 mov     [ebp+xDest], edx
.text$mn:00001D2C
.text$mn:00001D2C loc_1D2C:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+377j
.text$mn:00001D2C                 jmp     short loc_1D6A
.text$mn:00001D2E ; ---------------------------------------------------------------------------
.text$mn:00001D2E
.text$mn:00001D2E loc_1D2E:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+369j
.text$mn:00001D2E                 mov     eax, [ebp+var_47C]
.text$mn:00001D34                 movzx   ecx, byte ptr [eax+2Dh]
.text$mn:00001D38                 test    ecx, ecx
.text$mn:00001D3A                 jz      short loc_1D4D
.text$mn:00001D3C                 mov     edx, [ebp+xDest]
.text$mn:00001D42                 add     edx, 2
.text$mn:00001D45                 mov     [ebp+xDest], edx
.text$mn:00001D4B                 jmp     short loc_1D6A
.text$mn:00001D4D ; ---------------------------------------------------------------------------
.text$mn:00001D4D
.text$mn:00001D4D loc_1D4D:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+396j
.text$mn:00001D4D                 push    2               ; int
.text$mn:00001D4F                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00001D54                 add     eax, 0Ch
.text$mn:00001D57                 mov     ecx, eax        ; this
.text$mn:00001D59                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:00001D5E                 add     eax, [ebp+xDest]
.text$mn:00001D64                 mov     [ebp+xDest], eax
.text$mn:00001D6A
.text$mn:00001D6A loc_1D6A:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *):loc_1D2Cj
.text$mn:00001D6A                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+3A7j
.text$mn:00001D6A                 mov     eax, [ebp+var_47C]
.text$mn:00001D70                 movzx   ecx, byte ptr [eax+6Ch]
.text$mn:00001D74                 test    ecx, ecx
.text$mn:00001D76                 jz      short loc_1DA1
.text$mn:00001D78                 mov     edx, [ebp+var_47C]
.text$mn:00001D7E                 mov     eax, [edx+58h]
.text$mn:00001D81                 cmp     eax, [ebp+wParam]
.text$mn:00001D87                 jnz     short loc_1DA1
.text$mn:00001D89                 mov     ecx, [ebp+var_47C]
.text$mn:00001D8F                 cmp     dword ptr [ecx+70h], 0FFFFFFFFh
.text$mn:00001D93                 jnz     short loc_1DA1
.text$mn:00001D95                 mov     [ebp+var_4B4], 5FCh
.text$mn:00001D9F                 jmp     short loc_1E0D
.text$mn:00001DA1 ; ---------------------------------------------------------------------------
.text$mn:00001DA1
.text$mn:00001DA1 loc_1DA1:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+3D2j
.text$mn:00001DA1                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+3E3j ...
.text$mn:00001DA1                 mov     edx, [ebp+var_47C]
.text$mn:00001DA7                 movzx   eax, byte ptr [edx+6Ch]
.text$mn:00001DAB                 test    eax, eax
.text$mn:00001DAD                 jz      short loc_1DE0
.text$mn:00001DAF                 mov     ecx, [ebp+var_47C]
.text$mn:00001DB5                 mov     edx, [ecx+58h]
.text$mn:00001DB8                 cmp     edx, [ebp+wParam]
.text$mn:00001DBE                 jnz     short loc_1DE0
.text$mn:00001DC0                 mov     eax, [ebp+var_47C]
.text$mn:00001DC6                 mov     ecx, [ebp+var_47C]
.text$mn:00001DCC                 mov     edx, [eax+70h]
.text$mn:00001DCF                 cmp     edx, [ecx+58h]
.text$mn:00001DD2                 jnz     short loc_1DE0
.text$mn:00001DD4                 mov     [ebp+var_4B4], 5FDh
.text$mn:00001DDE                 jmp     short loc_1E0D
.text$mn:00001DE0 ; ---------------------------------------------------------------------------
.text$mn:00001DE0
.text$mn:00001DE0 loc_1DE0:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+409j
.text$mn:00001DE0                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+41Aj ...
.text$mn:00001DE0                 movzx   eax, [ebp+var_475]
.text$mn:00001DE7                 test    eax, eax
.text$mn:00001DE9                 jz      short loc_1DF7
.text$mn:00001DEB                 mov     [ebp+var_4DC], 5FAh
.text$mn:00001DF5                 jmp     short loc_1E01
.text$mn:00001DF7 ; ---------------------------------------------------------------------------
.text$mn:00001DF7
.text$mn:00001DF7 loc_1DF7:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+445j
.text$mn:00001DF7                 mov     [ebp+var_4DC], 5FBh
.text$mn:00001E01
.text$mn:00001E01 loc_1E01:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+451j
.text$mn:00001E01                 mov     ecx, [ebp+var_4DC]
.text$mn:00001E07                 mov     [ebp+var_4B4], ecx
.text$mn:00001E0D
.text$mn:00001E0D loc_1E0D:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+3FBj
.text$mn:00001E0D                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+43Aj
.text$mn:00001E0D                 mov     edx, [ebp+hdc]
.text$mn:00001E13                 push    edx             ; hdc
.text$mn:00001E14                 call    dword ptr ds:__imp__CreateCompatibleDC@4 ; CreateCompatibleDC(x)
.text$mn:00001E1A                 mov     [ebp+hdcSrc], eax
.text$mn:00001E20                 movzx   eax, word ptr [ebp+var_4B4]
.text$mn:00001E27                 push    eax             ; lpBitmapName
.text$mn:00001E28                 mov     ecx, [ebp+var_47C]
.text$mn:00001E2E                 mov     edx, [ecx+4]
.text$mn:00001E31                 push    edx             ; hInstance
.text$mn:00001E32                 call    dword ptr ds:__imp__LoadBitmapW@8 ; LoadBitmapW(x,x)
.text$mn:00001E38                 mov     [ebp+h], eax
.text$mn:00001E3E                 lea     eax, [ebp+pv]
.text$mn:00001E44                 push    eax             ; pv
.text$mn:00001E45                 push    18h             ; c
.text$mn:00001E47                 mov     ecx, [ebp+h]
.text$mn:00001E4D                 push    ecx             ; h
.text$mn:00001E4E                 call    dword ptr ds:__imp__GetObjectW@12 ; GetObjectW(x,x,x)
.text$mn:00001E54                 mov     edx, [ebp+wSrc]
.text$mn:00001E5A                 push    edx             ; int
.text$mn:00001E5B                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00001E60                 add     eax, 0Ch
.text$mn:00001E63                 mov     ecx, eax        ; this
.text$mn:00001E65                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:00001E6A                 mov     [ebp+wDest], eax
.text$mn:00001E70                 mov     eax, [ebp+hSrc]
.text$mn:00001E76                 push    eax             ; int
.text$mn:00001E77                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00001E7C                 add     eax, 0Ch
.text$mn:00001E7F                 mov     ecx, eax        ; this
.text$mn:00001E81                 call    ?scaleY@DPIManager@@QAEHH@Z ; DPIManager::scaleY(int)
.text$mn:00001E86                 mov     [ebp+hDest], eax
.text$mn:00001E8C                 mov     ecx, [ebp+var_47C]
.text$mn:00001E92                 movzx   edx, byte ptr [ecx+2Dh]
.text$mn:00001E96                 test    edx, edx
.text$mn:00001E98                 jz      short loc_1EAE
.text$mn:00001E9A                 mov     eax, [ebp+yDest]
.text$mn:00001EA0                 add     eax, [ebp+hDest]
.text$mn:00001EA6                 mov     [ebp+rc.top], eax
.text$mn:00001EAC                 jmp     short loc_1EBA
.text$mn:00001EAE ; ---------------------------------------------------------------------------
.text$mn:00001EAE
.text$mn:00001EAE loc_1EAE:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+4F4j
.text$mn:00001EAE                 mov     ecx, [ebp+xDest]
.text$mn:00001EB4                 mov     [ebp+rc.right], ecx
.text$mn:00001EBA
.text$mn:00001EBA loc_1EBA:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+508j
.text$mn:00001EBA                 mov     edx, [ebp+h]
.text$mn:00001EC0                 push    edx             ; h
.text$mn:00001EC1                 mov     eax, [ebp+hdcSrc]
.text$mn:00001EC7                 push    eax             ; hdc
.text$mn:00001EC8                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:00001ECE                 push    0CC0020h        ; rop
.text$mn:00001ED3                 mov     ecx, [ebp+hSrc]
.text$mn:00001ED9                 push    ecx             ; hSrc
.text$mn:00001EDA                 mov     edx, [ebp+wSrc]
.text$mn:00001EE0                 push    edx             ; wSrc
.text$mn:00001EE1                 push    0               ; ySrc
.text$mn:00001EE3                 push    0               ; xSrc
.text$mn:00001EE5                 mov     eax, [ebp+hdcSrc]
.text$mn:00001EEB                 push    eax             ; hdcSrc
.text$mn:00001EEC                 mov     ecx, [ebp+hDest]
.text$mn:00001EF2                 push    ecx             ; hDest
.text$mn:00001EF3                 mov     edx, [ebp+wDest]
.text$mn:00001EF9                 push    edx             ; wDest
.text$mn:00001EFA                 mov     eax, [ebp+yDest]
.text$mn:00001F00                 push    eax             ; yDest
.text$mn:00001F01                 mov     ecx, [ebp+xDest]
.text$mn:00001F07                 push    ecx             ; xDest
.text$mn:00001F08                 mov     edx, [ebp+hdc]
.text$mn:00001F0E                 push    edx             ; hdcDest
.text$mn:00001F0F                 call    dword ptr ds:__imp__StretchBlt@44 ; StretchBlt(x,x,x,x,x,x,x,x,x,x,x)
.text$mn:00001F15                 mov     eax, [ebp+hdcSrc]
.text$mn:00001F1B                 push    eax             ; hdc
.text$mn:00001F1C                 call    dword ptr ds:__imp__DeleteDC@4 ; DeleteDC(x)
.text$mn:00001F22                 mov     ecx, [ebp+h]
.text$mn:00001F28                 push    ecx             ; ho
.text$mn:00001F29                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00001F2F
.text$mn:00001F2F loc_1F2F:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+33Ej
.text$mn:00001F2F                 push    0               ; lParam
.text$mn:00001F31                 push    0               ; wParam
.text$mn:00001F33                 push    1302h           ; Msg
.text$mn:00001F38                 mov     edx, [ebp+var_47C]
.text$mn:00001F3E                 mov     eax, [edx+0Ch]
.text$mn:00001F41                 push    eax             ; hWnd
.text$mn:00001F42                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001F48                 mov     [ebp+himl], eax
.text$mn:00001F4E                 lea     ecx, [ebp+sz]
.text$mn:00001F54                 push    ecx             ; lpsz
.text$mn:00001F55                 push    1               ; c
.text$mn:00001F57                 push    offset $SG123725 ; lpString
.text$mn:00001F5C                 mov     edx, [ebp+hdc]
.text$mn:00001F62                 push    edx             ; hdc
.text$mn:00001F63                 call    dword ptr ds:__imp__GetTextExtentPointW@16 ; GetTextExtentPointW(x,x,x,x)
.text$mn:00001F69                 mov     eax, [ebp+sz._cx]
.text$mn:00001F6F                 mov     [ebp+var_4A4], eax
.text$mn:00001F75                 cmp     [ebp+himl], 0
.text$mn:00001F7C                 jz      loc_21C8
.text$mn:00001F82                 cmp     [ebp+i], 0
.text$mn:00001F89                 jl      loc_21C8
.text$mn:00001F8F                 mov     [ebp+y], 0
.text$mn:00001F99                 mov     [ebp+x], 0
.text$mn:00001FA3                 mov     [ebp+var_4A8], 0
.text$mn:00001FAD                 lea     ecx, [ebp+pImageInfo]
.text$mn:00001FB3                 push    ecx             ; pImageInfo
.text$mn:00001FB4                 mov     edx, [ebp+i]
.text$mn:00001FBA                 push    edx             ; i
.text$mn:00001FBB                 mov     eax, [ebp+himl]
.text$mn:00001FC1                 push    eax             ; himl
.text$mn:00001FC2                 call    dword ptr ds:__imp__ImageList_GetImageInfo@12 ; ImageList_GetImageInfo(x,x,x)
.text$mn:00001FC8                 lea     ecx, [ebp+pImageInfo.rcImage]
.text$mn:00001FCE                 mov     [ebp+var_490], ecx
.text$mn:00001FD4                 mov     edx, [ebp+var_47C]
.text$mn:00001FDA                 movzx   eax, byte ptr [edx+2Dh]
.text$mn:00001FDE                 test    eax, eax
.text$mn:00001FE0                 jz      short loc_202E
.text$mn:00001FE2                 mov     eax, [ebp+rc.right]
.text$mn:00001FE8                 sub     eax, [ebp+rc.left]
.text$mn:00001FEE                 cdq
.text$mn:00001FEF                 sub     eax, edx
.text$mn:00001FF1                 mov     esi, eax
.text$mn:00001FF3                 sar     esi, 1
.text$mn:00001FF5                 add     esi, [ebp+rc.left]
.text$mn:00001FFB                 push    2               ; int
.text$mn:00001FFD                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00002002                 add     eax, 0Ch
.text$mn:00002005                 mov     ecx, eax        ; this
.text$mn:00002007                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:0000200C                 add     esi, eax
.text$mn:0000200E                 mov     ecx, [ebp+var_490]
.text$mn:00002014                 mov     edx, [ebp+var_490]
.text$mn:0000201A                 mov     eax, [ecx+8]
.text$mn:0000201D                 sub     eax, [edx]
.text$mn:0000201F                 cdq
.text$mn:00002020                 sub     eax, edx
.text$mn:00002022                 sar     eax, 1
.text$mn:00002024                 sub     esi, eax
.text$mn:00002026                 mov     [ebp+x], esi
.text$mn:0000202C                 jmp     short loc_209C
.text$mn:0000202E ; ---------------------------------------------------------------------------
.text$mn:0000202E
.text$mn:0000202E loc_202E:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+63Cj
.text$mn:0000202E                 movzx   eax, [ebp+var_475]
.text$mn:00002035                 test    eax, eax
.text$mn:00002037                 jz      short loc_2045
.text$mn:00002039                 mov     [ebp+var_4EC], 0
.text$mn:00002043                 jmp     short loc_205C
.text$mn:00002045 ; ---------------------------------------------------------------------------
.text$mn:00002045
.text$mn:00002045 loc_2045:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+693j
.text$mn:00002045                 push    2               ; int
.text$mn:00002047                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:0000204C                 add     eax, 0Ch
.text$mn:0000204F                 mov     ecx, eax        ; this
.text$mn:00002051                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:00002056                 mov     [ebp+var_4EC], eax
.text$mn:0000205C
.text$mn:0000205C loc_205C:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+69Fj
.text$mn:0000205C                 mov     eax, [ebp+rc.bottom]
.text$mn:00002062                 sub     eax, [ebp+rc.top]
.text$mn:00002068                 cdq
.text$mn:00002069                 sub     eax, edx
.text$mn:0000206B                 mov     ecx, eax
.text$mn:0000206D                 sar     ecx, 1
.text$mn:0000206F                 add     ecx, [ebp+rc.top]
.text$mn:00002075                 add     ecx, [ebp+var_4EC]
.text$mn:0000207B                 mov     edx, [ebp+var_490]
.text$mn:00002081                 mov     eax, [ebp+var_490]
.text$mn:00002087                 mov     edx, [edx+0Ch]
.text$mn:0000208A                 sub     edx, [eax+4]
.text$mn:0000208D                 mov     eax, edx
.text$mn:0000208F                 cdq
.text$mn:00002090                 sub     eax, edx
.text$mn:00002092                 sar     eax, 1
.text$mn:00002094                 sub     ecx, eax
.text$mn:00002096                 mov     [ebp+y], ecx
.text$mn:0000209C
.text$mn:0000209C loc_209C:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+688j
.text$mn:0000209C                 mov     eax, [ebp+var_4A4]
.text$mn:000020A2                 mov     [ebp+var_4A8], eax
.text$mn:000020A8                 mov     ecx, [ebp+var_47C]
.text$mn:000020AE                 movzx   edx, byte ptr [ecx+2Dh]
.text$mn:000020B2                 test    edx, edx
.text$mn:000020B4                 jz      loc_2148
.text$mn:000020BA                 mov     eax, [ebp+var_490]
.text$mn:000020C0                 mov     ecx, [ebp+var_490]
.text$mn:000020C6                 mov     edx, [eax+0Ch]
.text$mn:000020C9                 sub     edx, [ecx+4]
.text$mn:000020CC                 mov     eax, [ebp+rc.bottom]
.text$mn:000020D2                 sub     eax, edx
.text$mn:000020D4                 mov     [ebp+rc.bottom], eax
.text$mn:000020DA                 movzx   ecx, [ebp+var_475]
.text$mn:000020E1                 test    ecx, ecx
.text$mn:000020E3                 jz      short loc_20F1
.text$mn:000020E5                 mov     [ebp+fStyle], 1
.text$mn:000020EF                 jmp     short loc_20FB
.text$mn:000020F1 ; ---------------------------------------------------------------------------
.text$mn:000020F1
.text$mn:000020F1 loc_20F1:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+73Fj
.text$mn:000020F1                 mov     [ebp+fStyle], 4
.text$mn:000020FB
.text$mn:000020FB loc_20FB:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+74Bj
.text$mn:000020FB                 mov     edx, [ebp+fStyle]
.text$mn:00002101                 push    edx             ; fStyle
.text$mn:00002102                 mov     eax, [ebp+rc.bottom]
.text$mn:00002108                 sub     eax, [ebp+var_4A8]
.text$mn:0000210E                 push    eax             ; y
.text$mn:0000210F                 mov     ecx, [ebp+x]
.text$mn:00002115                 push    ecx             ; x
.text$mn:00002116                 mov     edx, [ebp+hdc]
.text$mn:0000211C                 push    edx             ; hdcDst
.text$mn:0000211D                 mov     eax, [ebp+i]
.text$mn:00002123                 push    eax             ; i
.text$mn:00002124                 mov     ecx, [ebp+himl]
.text$mn:0000212A                 push    ecx             ; himl
.text$mn:0000212B                 call    dword ptr ds:__imp__ImageList_Draw@24 ; ImageList_Draw(x,x,x,x,x,x)
.text$mn:00002131                 mov     edx, [ebp+rc.bottom]
.text$mn:00002137                 add     edx, [ebp+var_4A8]
.text$mn:0000213D                 mov     [ebp+rc.bottom], edx
.text$mn:00002143                 jmp     loc_21C8
.text$mn:00002148 ; ---------------------------------------------------------------------------
.text$mn:00002148
.text$mn:00002148 loc_2148:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+710j
.text$mn:00002148                 mov     eax, [ebp+rc.left]
.text$mn:0000214E                 add     eax, [ebp+var_4A8]
.text$mn:00002154                 mov     [ebp+rc.left], eax
.text$mn:0000215A                 movzx   ecx, [ebp+var_475]
.text$mn:00002161                 test    ecx, ecx
.text$mn:00002163                 jz      short loc_2171
.text$mn:00002165                 mov     [ebp+var_4C4], 1
.text$mn:0000216F                 jmp     short loc_217B
.text$mn:00002171 ; ---------------------------------------------------------------------------
.text$mn:00002171
.text$mn:00002171 loc_2171:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+7BFj
.text$mn:00002171                 mov     [ebp+var_4C4], 4
.text$mn:0000217B
.text$mn:0000217B loc_217B:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+7CBj
.text$mn:0000217B                 mov     edx, [ebp+var_4C4]
.text$mn:00002181                 push    edx             ; fStyle
.text$mn:00002182                 mov     eax, [ebp+y]
.text$mn:00002188                 push    eax             ; y
.text$mn:00002189                 mov     ecx, [ebp+rc.left]
.text$mn:0000218F                 push    ecx             ; x
.text$mn:00002190                 mov     edx, [ebp+hdc]
.text$mn:00002196                 push    edx             ; hdcDst
.text$mn:00002197                 mov     eax, [ebp+i]
.text$mn:0000219D                 push    eax             ; i
.text$mn:0000219E                 mov     ecx, [ebp+himl]
.text$mn:000021A4                 push    ecx             ; himl
.text$mn:000021A5                 call    dword ptr ds:__imp__ImageList_Draw@24 ; ImageList_Draw(x,x,x,x,x,x)
.text$mn:000021AB                 mov     edx, [ebp+var_490]
.text$mn:000021B1                 mov     eax, [ebp+var_490]
.text$mn:000021B7                 mov     ecx, [edx+8]
.text$mn:000021BA                 sub     ecx, [eax]
.text$mn:000021BC                 add     ecx, [ebp+rc.left]
.text$mn:000021C2                 mov     [ebp+rc.left], ecx
.text$mn:000021C8
.text$mn:000021C8 loc_21C8:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+5D8j
.text$mn:000021C8                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+5E5j ...
.text$mn:000021C8                 push    0               ; lParam
.text$mn:000021CA                 push    0               ; wParam
.text$mn:000021CC                 push    40Ch            ; Msg
.text$mn:000021D1                 mov     edx, [ebp+var_47C]
.text$mn:000021D7                 mov     eax, [edx+8]
.text$mn:000021DA                 push    eax             ; hWnd
.text$mn:000021DB                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000021E1                 cmp     eax, 1
.text$mn:000021E4                 jnz     short loc_21F2
.text$mn:000021E6                 mov     [ebp+var_4C8], 1
.text$mn:000021F0                 jmp     short loc_21FC
.text$mn:000021F2 ; ---------------------------------------------------------------------------
.text$mn:000021F2
.text$mn:000021F2 loc_21F2:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+840j
.text$mn:000021F2                 mov     [ebp+var_4C8], 0
.text$mn:000021FC
.text$mn:000021FC loc_21FC:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+84Cj
.text$mn:000021FC                 mov     cl, byte ptr [ebp+var_4C8]
.text$mn:00002202                 mov     [ebp+var_495], cl
.text$mn:00002208                 movzx   edx, [ebp+var_495]
.text$mn:0000220F                 test    edx, edx
.text$mn:00002211                 jz      short loc_2253
.text$mn:00002213                 mov     eax, [ebp+var_47C]
.text$mn:00002219                 movzx   ecx, byte ptr [eax+2Dh]
.text$mn:0000221D                 test    ecx, ecx
.text$mn:0000221F                 jz      short loc_223A
.text$mn:00002221                 mov     edx, [ebp+var_47C]
.text$mn:00002227                 mov     eax, [edx+20h]
.text$mn:0000222A                 push    eax             ; h
.text$mn:0000222B                 mov     ecx, [ebp+hdc]
.text$mn:00002231                 push    ecx             ; hdc
.text$mn:00002232                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:00002238                 jmp     short loc_2251
.text$mn:0000223A ; ---------------------------------------------------------------------------
.text$mn:0000223A
.text$mn:0000223A loc_223A:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+87Bj
.text$mn:0000223A                 mov     edx, [ebp+var_47C]
.text$mn:00002240                 mov     eax, [edx+18h]
.text$mn:00002243                 push    eax             ; h
.text$mn:00002244                 mov     ecx, [ebp+hdc]
.text$mn:0000224A                 push    ecx             ; hdc
.text$mn:0000224B                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:00002251
.text$mn:00002251 loc_2251:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+894j
.text$mn:00002251                 jmp     short loc_2291
.text$mn:00002253 ; ---------------------------------------------------------------------------
.text$mn:00002253
.text$mn:00002253 loc_2253:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+86Dj
.text$mn:00002253                 mov     edx, [ebp+var_47C]
.text$mn:00002259                 movzx   eax, byte ptr [edx+2Dh]
.text$mn:0000225D                 test    eax, eax
.text$mn:0000225F                 jz      short loc_227A
.text$mn:00002261                 mov     ecx, [ebp+var_47C]
.text$mn:00002267                 mov     edx, [ecx+24h]
.text$mn:0000226A                 push    edx             ; h
.text$mn:0000226B                 mov     eax, [ebp+hdc]
.text$mn:00002271                 push    eax             ; hdc
.text$mn:00002272                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:00002278                 jmp     short loc_2291
.text$mn:0000227A ; ---------------------------------------------------------------------------
.text$mn:0000227A
.text$mn:0000227A loc_227A:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+8BBj
.text$mn:0000227A                 mov     ecx, [ebp+var_47C]
.text$mn:00002280                 mov     edx, [ecx+1Ch]
.text$mn:00002283                 push    edx             ; h
.text$mn:00002284                 mov     eax, [ebp+hdc]
.text$mn:0000228A                 push    eax             ; hdc
.text$mn:0000228B                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:00002291
.text$mn:00002291 loc_2291:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *):loc_2251j
.text$mn:00002291                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+8D4j
.text$mn:00002291                 mov     [ebp+format], 820h
.text$mn:0000229B                 lea     ecx, [ebp+var_414]
.text$mn:000022A1                 mov     [ebp+var_48C], ecx
.text$mn:000022A7                 lea     edx, [ebp+String]
.text$mn:000022AD                 mov     [ebp+var_494], edx
.text$mn:000022B3
.text$mn:000022B3 loc_22B3:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *):loc_2344j
.text$mn:000022B3                 mov     eax, [ebp+var_48C]
.text$mn:000022B9                 movzx   ecx, word ptr [eax]
.text$mn:000022BC                 test    ecx, ecx
.text$mn:000022BE                 jz      loc_2349
.text$mn:000022C4                 mov     edx, [ebp+var_48C]
.text$mn:000022CA                 movzx   eax, word ptr [edx]
.text$mn:000022CD                 cmp     eax, 26h ; '&'
.text$mn:000022D0                 jnz     short loc_2314
.text$mn:000022D2
.text$mn:000022D2 loc_22D2:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+96Cj
.text$mn:000022D2                 mov     ecx, [ebp+var_48C]
.text$mn:000022D8                 add     ecx, 2
.text$mn:000022DB                 mov     [ebp+var_48C], ecx
.text$mn:000022E1                 mov     edx, [ebp+var_48C]
.text$mn:000022E7                 movzx   eax, word ptr [edx]
.text$mn:000022EA                 cmp     eax, 26h ; '&'
.text$mn:000022ED                 jnz     short loc_2312
.text$mn:000022EF                 mov     ecx, [ebp+var_494]
.text$mn:000022F5                 mov     edx, [ebp+var_48C]
.text$mn:000022FB                 mov     ax, [edx]
.text$mn:000022FE                 mov     [ecx], ax
.text$mn:00002301                 mov     ecx, [ebp+var_494]
.text$mn:00002307                 add     ecx, 2
.text$mn:0000230A                 mov     [ebp+var_494], ecx
.text$mn:00002310                 jmp     short loc_22D2
.text$mn:00002312 ; ---------------------------------------------------------------------------
.text$mn:00002312
.text$mn:00002312 loc_2312:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+949j
.text$mn:00002312                 jmp     short loc_2344
.text$mn:00002314 ; ---------------------------------------------------------------------------
.text$mn:00002314
.text$mn:00002314 loc_2314:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+92Cj
.text$mn:00002314                 mov     edx, [ebp+var_494]
.text$mn:0000231A                 mov     eax, [ebp+var_48C]
.text$mn:00002320                 mov     cx, [eax]
.text$mn:00002323                 mov     [edx], cx
.text$mn:00002326                 mov     edx, [ebp+var_494]
.text$mn:0000232C                 add     edx, 2
.text$mn:0000232F                 mov     [ebp+var_494], edx
.text$mn:00002335                 mov     eax, [ebp+var_48C]
.text$mn:0000233B                 add     eax, 2
.text$mn:0000233E                 mov     [ebp+var_48C], eax
.text$mn:00002344
.text$mn:00002344 loc_2344:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *):loc_2312j
.text$mn:00002344                 jmp     loc_22B3
.text$mn:00002349 ; ---------------------------------------------------------------------------
.text$mn:00002349
.text$mn:00002349 loc_2349:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+91Aj
.text$mn:00002349                 xor     ecx, ecx
.text$mn:0000234B                 mov     edx, [ebp+var_494]
.text$mn:00002351                 mov     [edx], cx
.text$mn:00002354                 movzx   eax, ds:?_drawTabCloseButton@TabBarPlus@@1_NA ; bool TabBarPlus::_drawTabCloseButton
.text$mn:0000235B                 test    eax, eax
.text$mn:0000235D                 jz      short loc_236D
.text$mn:0000235F                 mov     ecx, [ebp+format]
.text$mn:00002365                 mov     [ebp+format], ecx
.text$mn:0000236B                 jmp     short loc_238A
.text$mn:0000236D ; ---------------------------------------------------------------------------
.text$mn:0000236D
.text$mn:0000236D loc_236D:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+9B9j
.text$mn:0000236D                 mov     edx, [ebp+var_47C]
.text$mn:00002373                 movzx   eax, byte ptr [edx+2Dh]
.text$mn:00002377                 test    eax, eax
.text$mn:00002379                 jnz     short loc_238A
.text$mn:0000237B                 mov     ecx, [ebp+format]
.text$mn:00002381                 or      ecx, 1
.text$mn:00002384                 mov     [ebp+format], ecx
.text$mn:0000238A
.text$mn:0000238A loc_238A:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+9C7j
.text$mn:0000238A                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+9D5j
.text$mn:0000238A                 movzx   edx, [ebp+var_475]
.text$mn:00002391                 test    edx, edx
.text$mn:00002393                 jz      loc_24C8
.text$mn:00002399                 mov     eax, ds:?_activeTextColour@TabBarPlus@@1KA ; ulong TabBarPlus::_activeTextColour
.text$mn:0000239E                 push    eax             ; color
.text$mn:0000239F                 mov     ecx, [ebp+hdc]
.text$mn:000023A5                 push    ecx             ; hdc
.text$mn:000023A6                 call    dword ptr ds:__imp__SetTextColor@8 ; SetTextColor(x,x)
.text$mn:000023AC                 mov     edx, [ebp+var_47C]
.text$mn:000023B2                 movzx   eax, byte ptr [edx+2Dh]
.text$mn:000023B6                 test    eax, eax
.text$mn:000023B8                 jz      loc_244C
.text$mn:000023BE                 push    2               ; int
.text$mn:000023C0                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000023C5                 add     eax, 0Ch
.text$mn:000023C8                 mov     ecx, eax        ; this
.text$mn:000023CA                 call    ?scaleY@DPIManager@@QAEHH@Z ; DPIManager::scaleY(int)
.text$mn:000023CF                 mov     ecx, [ebp+rc.bottom]
.text$mn:000023D5                 sub     ecx, eax
.text$mn:000023D7                 mov     [ebp+rc.bottom], ecx
.text$mn:000023DD                 push    2Dh ; '-'       ; nIndex
.text$mn:000023DF                 call    dword ptr ds:__imp__GetSystemMetrics@4 ; GetSystemMetrics(x)
.text$mn:000023E5                 mov     esi, eax
.text$mn:000023E7                 push    4               ; int
.text$mn:000023E9                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000023EE                 add     eax, 0Ch
.text$mn:000023F1                 mov     ecx, eax        ; this
.text$mn:000023F3                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:000023F8                 add     eax, [ebp+rc.left]
.text$mn:000023FE                 add     eax, esi
.text$mn:00002400                 mov     [ebp+rc.left], eax
.text$mn:00002406                 movzx   edx, ds:?_drawTabCloseButton@TabBarPlus@@1_NA ; bool TabBarPlus::_drawTabCloseButton
.text$mn:0000240D                 test    edx, edx
.text$mn:0000240F                 jz      short loc_241F
.text$mn:00002411                 mov     eax, [ebp+var_4A4]
.text$mn:00002417                 mov     [ebp+var_4E8], eax
.text$mn:0000241D                 jmp     short loc_2429
.text$mn:0000241F ; ---------------------------------------------------------------------------
.text$mn:0000241F
.text$mn:0000241F loc_241F:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+A6Bj
.text$mn:0000241F                 mov     [ebp+var_4E8], 0
.text$mn:00002429
.text$mn:00002429 loc_2429:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+A79j
.text$mn:00002429                 mov     ecx, [ebp+rc.top]
.text$mn:0000242F                 add     ecx, [ebp+var_4E8]
.text$mn:00002435                 mov     [ebp+rc.top], ecx
.text$mn:0000243B                 mov     edx, [ebp+format]
.text$mn:00002441                 or      edx, 8
.text$mn:00002444                 mov     [ebp+format], edx
.text$mn:0000244A                 jmp     short loc_24C3
.text$mn:0000244C ; ---------------------------------------------------------------------------
.text$mn:0000244C
.text$mn:0000244C loc_244C:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+A14j
.text$mn:0000244C                 push    2Eh ; '.'       ; nIndex
.text$mn:0000244E                 call    dword ptr ds:__imp__GetSystemMetrics@4 ; GetSystemMetrics(x)
.text$mn:00002454                 mov     ecx, [ebp+rc.top]
.text$mn:0000245A                 sub     ecx, eax
.text$mn:0000245C                 mov     [ebp+rc.top], ecx
.text$mn:00002462                 push    3               ; int
.text$mn:00002464                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00002469                 add     eax, 0Ch
.text$mn:0000246C                 mov     ecx, eax        ; this
.text$mn:0000246E                 call    ?scaleY@DPIManager@@QAEHH@Z ; DPIManager::scaleY(int)
.text$mn:00002473                 add     eax, [ebp+rc.top]
.text$mn:00002479                 mov     [ebp+rc.top], eax
.text$mn:0000247F                 movzx   edx, ds:?_drawTabCloseButton@TabBarPlus@@1_NA ; bool TabBarPlus::_drawTabCloseButton
.text$mn:00002486                 test    edx, edx
.text$mn:00002488                 jz      short loc_2498
.text$mn:0000248A                 mov     eax, [ebp+var_4A4]
.text$mn:00002490                 mov     [ebp+var_4D0], eax
.text$mn:00002496                 jmp     short loc_24A2
.text$mn:00002498 ; ---------------------------------------------------------------------------
.text$mn:00002498
.text$mn:00002498 loc_2498:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+AE4j
.text$mn:00002498                 mov     [ebp+var_4D0], 0
.text$mn:000024A2
.text$mn:000024A2 loc_24A2:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+AF2j
.text$mn:000024A2                 mov     ecx, [ebp+rc.left]
.text$mn:000024A8                 add     ecx, [ebp+var_4D0]
.text$mn:000024AE                 mov     [ebp+rc.left], ecx
.text$mn:000024B4                 mov     edx, [ebp+format]
.text$mn:000024BA                 or      edx, 4
.text$mn:000024BD                 mov     [ebp+format], edx
.text$mn:000024C3
.text$mn:000024C3 loc_24C3:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+AA6j
.text$mn:000024C3                 jmp     loc_2592
.text$mn:000024C8 ; ---------------------------------------------------------------------------
.text$mn:000024C8
.text$mn:000024C8 loc_24C8:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+9EFj
.text$mn:000024C8                 mov     eax, ds:?_inactiveTextColour@TabBarPlus@@1KA ; ulong TabBarPlus::_inactiveTextColour
.text$mn:000024CD                 push    eax             ; color
.text$mn:000024CE                 mov     ecx, [ebp+hdc]
.text$mn:000024D4                 push    ecx             ; hdc
.text$mn:000024D5                 call    dword ptr ds:__imp__SetTextColor@8 ; SetTextColor(x,x)
.text$mn:000024DB                 mov     edx, [ebp+var_47C]
.text$mn:000024E1                 movzx   eax, byte ptr [edx+2Dh]
.text$mn:000024E5                 test    eax, eax
.text$mn:000024E7                 jz      short loc_254E
.text$mn:000024E9                 push    2               ; int
.text$mn:000024EB                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000024F0                 add     eax, 0Ch
.text$mn:000024F3                 mov     ecx, eax        ; this
.text$mn:000024F5                 call    ?scaleY@DPIManager@@QAEHH@Z ; DPIManager::scaleY(int)
.text$mn:000024FA                 add     eax, [ebp+rc.top]
.text$mn:00002500                 mov     [ebp+rc.top], eax
.text$mn:00002506                 push    4               ; int
.text$mn:00002508                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:0000250D                 add     eax, 0Ch
.text$mn:00002510                 mov     ecx, eax        ; this
.text$mn:00002512                 call    ?scaleY@DPIManager@@QAEHH@Z ; DPIManager::scaleY(int)
.text$mn:00002517                 add     eax, [ebp+rc.bottom]
.text$mn:0000251D                 mov     [ebp+rc.bottom], eax
.text$mn:00002523                 push    2Dh ; '-'       ; nIndex
.text$mn:00002525                 call    dword ptr ds:__imp__GetSystemMetrics@4 ; GetSystemMetrics(x)
.text$mn:0000252B                 mov     esi, eax
.text$mn:0000252D                 push    2               ; int
.text$mn:0000252F                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00002534                 add     eax, 0Ch
.text$mn:00002537                 mov     ecx, eax        ; this
.text$mn:00002539                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:0000253E                 add     eax, [ebp+rc.left]
.text$mn:00002544                 add     eax, esi
.text$mn:00002546                 mov     [ebp+rc.left], eax
.text$mn:0000254C                 jmp     short loc_2583
.text$mn:0000254E ; ---------------------------------------------------------------------------
.text$mn:0000254E
.text$mn:0000254E loc_254E:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+B43j
.text$mn:0000254E                 movzx   ecx, ds:?_drawTabCloseButton@TabBarPlus@@1_NA ; bool TabBarPlus::_drawTabCloseButton
.text$mn:00002555                 test    ecx, ecx
.text$mn:00002557                 jz      short loc_2567
.text$mn:00002559                 mov     edx, [ebp+var_4A4]
.text$mn:0000255F                 mov     [ebp+var_4E0], edx
.text$mn:00002565                 jmp     short loc_2571
.text$mn:00002567 ; ---------------------------------------------------------------------------
.text$mn:00002567
.text$mn:00002567 loc_2567:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+BB3j
.text$mn:00002567                 mov     [ebp+var_4E0], 0
.text$mn:00002571
.text$mn:00002571 loc_2571:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+BC1j
.text$mn:00002571                 mov     eax, [ebp+rc.left]
.text$mn:00002577                 add     eax, [ebp+var_4E0]
.text$mn:0000257D                 mov     [ebp+rc.left], eax
.text$mn:00002583
.text$mn:00002583 loc_2583:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+BA8j
.text$mn:00002583                 mov     ecx, [ebp+format]
.text$mn:00002589                 or      ecx, 8
.text$mn:0000258C                 mov     [ebp+format], ecx
.text$mn:00002592
.text$mn:00002592 loc_2592:                               ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *):loc_24C3j
.text$mn:00002592                 mov     edx, [ebp+format]
.text$mn:00002598                 push    edx             ; format
.text$mn:00002599                 lea     eax, [ebp+rc]
.text$mn:0000259F                 push    eax             ; lprc
.text$mn:000025A0                 lea     ecx, [ebp+String]
.text$mn:000025A6                 push    ecx             ; lpString
.text$mn:000025A7                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:000025AD                 push    eax             ; cchText
.text$mn:000025AE                 lea     edx, [ebp+String]
.text$mn:000025B4                 push    edx             ; lpchText
.text$mn:000025B5                 mov     eax, [ebp+hdc]
.text$mn:000025BB                 push    eax             ; hdc
.text$mn:000025BC                 call    dword ptr ds:__imp__DrawTextW@20 ; DrawTextW(x,x,x,x,x)
.text$mn:000025C2                 mov     ecx, [ebp+nSavedDC]
.text$mn:000025C8                 push    ecx             ; nSavedDC
.text$mn:000025C9                 mov     edx, [ebp+hdc]
.text$mn:000025CF                 push    edx             ; hdc
.text$mn:000025D0                 call    dword ptr ds:__imp__RestoreDC@8 ; RestoreDC(x,x)
.text$mn:000025D6                 pop     esi
.text$mn:000025D7                 mov     ecx, [ebp+var_4]
.text$mn:000025DA                 xor     ecx, ebp
.text$mn:000025DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000025E1                 mov     esp, ebp
.text$mn:000025E3                 pop     ebp
.text$mn:000025E4                 retn    4
.text$mn:000025E4 ?drawItem@TabBarPlus@@IAEXPAUtagDRAWITEMSTRUCT@@@Z endp
.text$mn:000025E4
.text$mn:000025E4 ; ---------------------------------------------------------------------------
.text$mn:000025E7                 db 0Dh dup(0CCh)
.text$mn:000025F4
.text$mn:000025F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000025F4
.text$mn:000025F4 ; Attributes: bp-based frame
.text$mn:000025F4
.text$mn:000025F4 ; void __thiscall TabBarPlus::draggingCursor(TabBarPlus *this, struct tagPOINT)
.text$mn:000025F4                 public ?draggingCursor@TabBarPlus@@IAEXUtagPOINT@@@Z
.text$mn:000025F4 ?draggingCursor@TabBarPlus@@IAEXUtagPOINT@@@Z proc near
.text$mn:000025F4                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+34Ap
.text$mn:000025F4
.text$mn:000025F4 hWnd            = dword ptr -20Ch
.text$mn:000025F4 var_208         = dword ptr -208h
.text$mn:000025F4 ClassName       = word ptr -204h
.text$mn:000025F4 var_4           = dword ptr -4
.text$mn:000025F4 Point           = POINT ptr  8
.text$mn:000025F4
.text$mn:000025F4                 push    ebp
.text$mn:000025F5                 mov     ebp, esp
.text$mn:000025F7                 sub     esp, 20Ch
.text$mn:000025FD                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002602                 xor     eax, ebp
.text$mn:00002604                 mov     [ebp+var_4], eax
.text$mn:00002607                 mov     [ebp+var_208], ecx
.text$mn:0000260D                 mov     eax, [ebp+Point.y]
.text$mn:00002610                 push    eax
.text$mn:00002611                 mov     ecx, [ebp+Point.x]
.text$mn:00002614                 push    ecx             ; Point
.text$mn:00002615                 call    dword ptr ds:__imp__WindowFromPoint@8 ; WindowFromPoint(x,x)
.text$mn:0000261B                 mov     [ebp+hWnd], eax
.text$mn:00002621                 mov     edx, [ebp+var_208]
.text$mn:00002627                 mov     eax, [edx+0Ch]
.text$mn:0000262A                 cmp     eax, [ebp+hWnd]
.text$mn:00002630                 jnz     short loc_264B
.text$mn:00002632                 push    7F00h           ; lpCursorName
.text$mn:00002637                 push    0               ; hInstance
.text$mn:00002639                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:0000263F                 push    eax             ; hCursor
.text$mn:00002640                 call    dword ptr ds:__imp__SetCursor@4 ; SetCursor(x)
.text$mn:00002646                 jmp     loc_2736
.text$mn:0000264B ; ---------------------------------------------------------------------------
.text$mn:0000264B
.text$mn:0000264B loc_264B:                               ; CODE XREF: TabBarPlus::draggingCursor(tagPOINT)+3Cj
.text$mn:0000264B                 push    100h            ; nMaxCount
.text$mn:00002650                 lea     ecx, [ebp+ClassName]
.text$mn:00002656                 push    ecx             ; lpClassName
.text$mn:00002657                 mov     edx, [ebp+hWnd]
.text$mn:0000265D                 push    edx             ; hWnd
.text$mn:0000265E                 call    dword ptr ds:__imp__GetClassNameW@12 ; GetClassNameW(x,x,x)
.text$mn:00002664                 push    offset $SG123778 ; "Scintilla"
.text$mn:00002669                 lea     eax, [ebp+ClassName]
.text$mn:0000266F                 push    eax             ; lpString1
.text$mn:00002670                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:00002676                 test    eax, eax
.text$mn:00002678                 jz      short loc_2690
.text$mn:0000267A                 push    offset $SG123779 ; "SysTabControl32"
.text$mn:0000267F                 lea     ecx, [ebp+ClassName]
.text$mn:00002685                 push    ecx             ; lpString1
.text$mn:00002686                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:0000268C                 test    eax, eax
.text$mn:0000268E                 jnz     short loc_26E2
.text$mn:00002690
.text$mn:00002690 loc_2690:                               ; CODE XREF: TabBarPlus::draggingCursor(tagPOINT)+84j
.text$mn:00002690                 push    0A2h ; 'ó'      ; nVirtKey
.text$mn:00002695                 call    dword ptr ds:__imp__GetKeyState@4 ; GetKeyState(x)
.text$mn:0000269B                 movsx   edx, ax
.text$mn:0000269E                 and     edx, 80000000h
.text$mn:000026A4                 jz      short loc_26C4
.text$mn:000026A6                 push    offset CursorName ; lpCursorName
.text$mn:000026AB                 mov     eax, [ebp+var_208]
.text$mn:000026B1                 mov     ecx, [eax+4]
.text$mn:000026B4                 push    ecx             ; hInstance
.text$mn:000026B5                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:000026BB                 push    eax             ; hCursor
.text$mn:000026BC                 call    dword ptr ds:__imp__SetCursor@4 ; SetCursor(x)
.text$mn:000026C2                 jmp     short loc_26E0
.text$mn:000026C4 ; ---------------------------------------------------------------------------
.text$mn:000026C4
.text$mn:000026C4 loc_26C4:                               ; CODE XREF: TabBarPlus::draggingCursor(tagPOINT)+B0j
.text$mn:000026C4                 push    (offset loc_579+3) ; lpCursorName
.text$mn:000026C9                 mov     edx, [ebp+var_208]
.text$mn:000026CF                 mov     eax, [edx+4]
.text$mn:000026D2                 push    eax             ; hInstance
.text$mn:000026D3                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:000026D9                 push    eax             ; hCursor
.text$mn:000026DA                 call    dword ptr ds:__imp__SetCursor@4 ; SetCursor(x)
.text$mn:000026E0
.text$mn:000026E0 loc_26E0:                               ; CODE XREF: TabBarPlus::draggingCursor(tagPOINT)+CEj
.text$mn:000026E0                 jmp     short loc_2736
.text$mn:000026E2 ; ---------------------------------------------------------------------------
.text$mn:000026E2
.text$mn:000026E2 loc_26E2:                               ; CODE XREF: TabBarPlus::draggingCursor(tagPOINT)+9Aj
.text$mn:000026E2                 mov     ecx, [ebp+Point.y]
.text$mn:000026E5                 push    ecx
.text$mn:000026E6                 mov     edx, [ebp+Point.x]
.text$mn:000026E9                 push    edx             ; struct tagPOINT
.text$mn:000026EA                 mov     ecx, [ebp+var_208] ; this
.text$mn:000026F0                 call    ?isPointInParentZone@TabBarPlus@@IBE_NUtagPOINT@@@Z ; TabBarPlus::isPointInParentZone(tagPOINT)
.text$mn:000026F5                 movzx   eax, al
.text$mn:000026F8                 test    eax, eax
.text$mn:000026FA                 jz      short loc_271A
.text$mn:000026FC                 push    (offset loc_579+4) ; lpCursorName
.text$mn:00002701                 mov     ecx, [ebp+var_208]
.text$mn:00002707                 mov     edx, [ecx+4]
.text$mn:0000270A                 push    edx             ; hInstance
.text$mn:0000270B                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:00002711                 push    eax             ; hCursor
.text$mn:00002712                 call    dword ptr ds:__imp__SetCursor@4 ; SetCursor(x)
.text$mn:00002718                 jmp     short loc_2736
.text$mn:0000271A ; ---------------------------------------------------------------------------
.text$mn:0000271A
.text$mn:0000271A loc_271A:                               ; CODE XREF: TabBarPlus::draggingCursor(tagPOINT)+106j
.text$mn:0000271A                 push    (offset CursorName+1) ; lpCursorName
.text$mn:0000271F                 mov     eax, [ebp+var_208]
.text$mn:00002725                 mov     ecx, [eax+4]
.text$mn:00002728                 push    ecx             ; hInstance
.text$mn:00002729                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:0000272F                 push    eax             ; hCursor
.text$mn:00002730                 call    dword ptr ds:__imp__SetCursor@4 ; SetCursor(x)
.text$mn:00002736
.text$mn:00002736 loc_2736:                               ; CODE XREF: TabBarPlus::draggingCursor(tagPOINT)+52j
.text$mn:00002736                                         ; TabBarPlus::draggingCursor(tagPOINT):loc_26E0j ...
.text$mn:00002736                 mov     ecx, [ebp+var_4]
.text$mn:00002739                 xor     ecx, ebp
.text$mn:0000273B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002740                 mov     esp, ebp
.text$mn:00002742                 pop     ebp
.text$mn:00002743                 retn    8
.text$mn:00002743 ?draggingCursor@TabBarPlus@@IAEXUtagPOINT@@@Z endp
.text$mn:00002743
.text$mn:00002743 ; ---------------------------------------------------------------------------
.text$mn:00002746                 align 4
.text$mn:00002746 _text$mn        ends
.text$mn:00002746
.text$mn:00002748 ; ===========================================================================
.text$mn:00002748
.text$mn:00002748 ; Segment type: Pure code
.text$mn:00002748 ; Segment permissions: Read/Execute
.text$mn:00002748 _text$mn        segment para public 'CODE' use32
.text$mn:00002748                 assume cs:_text$mn
.text$mn:00002748                 ;org 2748h
.text$mn:00002748 ; COMDAT (pick any)
.text$mn:00002748                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002748
.text$mn:00002748 ; =============== S U B R O U T I N E =======================================
.text$mn:00002748
.text$mn:00002748 ; Attributes: bp-based frame
.text$mn:00002748
.text$mn:00002748 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00002748                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00002748 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00002748                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00002748
.text$mn:00002748 var_4           = dword ptr -4
.text$mn:00002748 arg_0           = dword ptr  8
.text$mn:00002748
.text$mn:00002748                 push    ebp
.text$mn:00002749                 mov     ebp, esp
.text$mn:0000274B                 push    ecx
.text$mn:0000274C                 mov     [ebp+var_4], 0
.text$mn:00002753                 cmp     [ebp+arg_0], 0
.text$mn:00002757                 jnz     short loc_275B
.text$mn:00002759                 jmp     short loc_277B
.text$mn:0000275B ; ---------------------------------------------------------------------------
.text$mn:0000275B
.text$mn:0000275B loc_275B:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:0000275B                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:0000275F                 ja      short loc_2776
.text$mn:00002761                 mov     eax, [ebp+arg_0]
.text$mn:00002764                 push    eax             ; unsigned int
.text$mn:00002765                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000276A                 add     esp, 4
.text$mn:0000276D                 mov     [ebp+var_4], eax
.text$mn:00002770                 cmp     [ebp+var_4], 0
.text$mn:00002774                 jnz     short loc_277B
.text$mn:00002776
.text$mn:00002776 loc_2776:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00002776                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000277B
.text$mn:0000277B loc_277B:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:0000277B                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:0000277B                 mov     eax, [ebp+var_4]
.text$mn:0000277E                 mov     esp, ebp
.text$mn:00002780                 pop     ebp
.text$mn:00002781                 retn
.text$mn:00002781 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00002781
.text$mn:00002781 ; ---------------------------------------------------------------------------
.text$mn:00002782                 align 4
.text$mn:00002782 _text$mn        ends
.text$mn:00002782
.text$mn:00002784 ; ===========================================================================
.text$mn:00002784
.text$mn:00002784 ; Segment type: Pure code
.text$mn:00002784 ; Segment permissions: Read/Execute
.text$mn:00002784 _text$mn        segment para public 'CODE' use32
.text$mn:00002784                 assume cs:_text$mn
.text$mn:00002784                 ;org 2784h
.text$mn:00002784 ; COMDAT (pick any)
.text$mn:00002784                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002784
.text$mn:00002784 ; =============== S U B R O U T I N E =======================================
.text$mn:00002784
.text$mn:00002784 ; Attributes: bp-based frame
.text$mn:00002784
.text$mn:00002784 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00002784                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00002784 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00002784                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00002784
.text$mn:00002784 var_4           = dword ptr -4
.text$mn:00002784 arg_0           = dword ptr  8
.text$mn:00002784
.text$mn:00002784                 push    ebp
.text$mn:00002785                 mov     ebp, esp
.text$mn:00002787                 push    ecx
.text$mn:00002788                 mov     [ebp+var_4], 0
.text$mn:0000278F                 cmp     [ebp+arg_0], 0
.text$mn:00002793                 jnz     short loc_2797
.text$mn:00002795                 jmp     short loc_27BD
.text$mn:00002797 ; ---------------------------------------------------------------------------
.text$mn:00002797
.text$mn:00002797 loc_2797:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00002797                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:0000279E                 ja      short loc_27B8
.text$mn:000027A0                 mov     eax, [ebp+arg_0]
.text$mn:000027A3                 shl     eax, 3
.text$mn:000027A6                 push    eax             ; unsigned int
.text$mn:000027A7                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000027AC                 add     esp, 4
.text$mn:000027AF                 mov     [ebp+var_4], eax
.text$mn:000027B2                 cmp     [ebp+var_4], 0
.text$mn:000027B6                 jnz     short loc_27BD
.text$mn:000027B8
.text$mn:000027B8 loc_27B8:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000027B8                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000027BD
.text$mn:000027BD loc_27BD:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000027BD                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000027BD                 mov     eax, [ebp+var_4]
.text$mn:000027C0                 mov     esp, ebp
.text$mn:000027C2                 pop     ebp
.text$mn:000027C3                 retn
.text$mn:000027C3 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000027C3
.text$mn:000027C3 _text$mn        ends
.text$mn:000027C3
.text$mn:000027C4 ; ===========================================================================
.text$mn:000027C4
.text$mn:000027C4 ; Segment type: Pure code
.text$mn:000027C4 ; Segment permissions: Read/Execute
.text$mn:000027C4 _text$mn        segment para public 'CODE' use32
.text$mn:000027C4                 assume cs:_text$mn
.text$mn:000027C4                 ;org 27C4h
.text$mn:000027C4 ; COMDAT (pick any)
.text$mn:000027C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027C4
.text$mn:000027C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027C4
.text$mn:000027C4 ; Attributes: bp-based frame
.text$mn:000027C4
.text$mn:000027C4 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000027C4                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000027C4 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000027C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000027C4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000027C4
.text$mn:000027C4 arg_0           = dword ptr  8
.text$mn:000027C4 arg_4           = dword ptr  0Ch
.text$mn:000027C4 arg_8           = dword ptr  10h
.text$mn:000027C4
.text$mn:000027C4                 push    ebp
.text$mn:000027C5                 mov     ebp, esp
.text$mn:000027C7                 cmp     [ebp+arg_0], 0
.text$mn:000027CB                 jnz     short loc_27E2
.text$mn:000027CD                 mov     eax, [ebp+arg_8]
.text$mn:000027D0                 push    eax             ; unsigned int
.text$mn:000027D1                 mov     ecx, [ebp+arg_4]
.text$mn:000027D4                 push    ecx             ; wchar_t *
.text$mn:000027D5                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000027DA                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000027DF                 add     esp, 0Ch
.text$mn:000027E2
.text$mn:000027E2 loc_27E2:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000027E2                 pop     ebp
.text$mn:000027E3                 retn
.text$mn:000027E3 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000027E3
.text$mn:000027E3 _text$mn        ends
.text$mn:000027E3
.text$mn:000027E4 ; ===========================================================================
.text$mn:000027E4
.text$mn:000027E4 ; Segment type: Pure code
.text$mn:000027E4 ; Segment permissions: Read/Execute
.text$mn:000027E4 _text$mn        segment para public 'CODE' use32
.text$mn:000027E4                 assume cs:_text$mn
.text$mn:000027E4                 ;org 27E4h
.text$mn:000027E4 ; COMDAT (pick any)
.text$mn:000027E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027E4
.text$mn:000027E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027E4
.text$mn:000027E4 ; Attributes: bp-based frame
.text$mn:000027E4
.text$mn:000027E4 ; char * __cdecl std::addressof<char>(char &)
.text$mn:000027E4                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000027E4 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000027E4                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000027E4                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000027E4
.text$mn:000027E4 arg_0           = dword ptr  8
.text$mn:000027E4
.text$mn:000027E4                 push    ebp
.text$mn:000027E5                 mov     ebp, esp
.text$mn:000027E7                 mov     eax, [ebp+arg_0]
.text$mn:000027EA                 pop     ebp
.text$mn:000027EB                 retn
.text$mn:000027EB ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000027EB
.text$mn:000027EB _text$mn        ends
.text$mn:000027EB
.text$mn:000027EC ; ===========================================================================
.text$mn:000027EC
.text$mn:000027EC ; Segment type: Pure code
.text$mn:000027EC ; Segment permissions: Read/Execute
.text$mn:000027EC _text$mn        segment para public 'CODE' use32
.text$mn:000027EC                 assume cs:_text$mn
.text$mn:000027EC                 ;org 27ECh
.text$mn:000027EC ; COMDAT (pick any)
.text$mn:000027EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027EC
.text$mn:000027EC ; =============== S U B R O U T I N E =======================================
.text$mn:000027EC
.text$mn:000027EC ; Attributes: bp-based frame
.text$mn:000027EC
.text$mn:000027EC ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000027EC                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000027EC ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000027EC                                         ; CODE XREF: $LN19+4Bp
.text$mn:000027EC
.text$mn:000027EC var_4           = dword ptr -4
.text$mn:000027EC arg_0           = dword ptr  8
.text$mn:000027EC arg_4           = dword ptr  0Ch
.text$mn:000027EC
.text$mn:000027EC                 push    ebp
.text$mn:000027ED                 mov     ebp, esp
.text$mn:000027EF                 push    ecx
.text$mn:000027F0                 mov     [ebp+var_4], ecx
.text$mn:000027F3                 mov     eax, [ebp+arg_4]
.text$mn:000027F6                 push    eax
.text$mn:000027F7                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000027FC                 add     esp, 4
.text$mn:000027FF                 push    eax             ; int
.text$mn:00002800                 mov     ecx, [ebp+arg_0]
.text$mn:00002803                 push    ecx             ; void *
.text$mn:00002804                 mov     edx, [ebp+var_4]
.text$mn:00002807                 push    edx             ; int
.text$mn:00002808                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:0000280D                 add     esp, 0Ch
.text$mn:00002810                 mov     esp, ebp
.text$mn:00002812                 pop     ebp
.text$mn:00002813                 retn    8
.text$mn:00002813 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00002813
.text$mn:00002813 ; ---------------------------------------------------------------------------
.text$mn:00002816                 align 4
.text$mn:00002816 _text$mn        ends
.text$mn:00002816
.text$mn:00002818 ; ===========================================================================
.text$mn:00002818
.text$mn:00002818 ; Segment type: Pure code
.text$mn:00002818 ; Segment permissions: Read/Execute
.text$mn:00002818 _text$mn        segment para public 'CODE' use32
.text$mn:00002818                 assume cs:_text$mn
.text$mn:00002818                 ;org 2818h
.text$mn:00002818 ; COMDAT (pick any)
.text$mn:00002818                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002818
.text$mn:00002818 ; =============== S U B R O U T I N E =======================================
.text$mn:00002818
.text$mn:00002818 ; Attributes: bp-based frame
.text$mn:00002818
.text$mn:00002818 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00002818                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00002818 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00002818                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00002818
.text$mn:00002818 var_1C          = dword ptr -1Ch
.text$mn:00002818 var_18          = dword ptr -18h
.text$mn:00002818 var_14          = dword ptr -14h
.text$mn:00002818 var_10          = dword ptr -10h
.text$mn:00002818 var_C           = dword ptr -0Ch
.text$mn:00002818 var_4           = dword ptr -4
.text$mn:00002818 arg_0           = dword ptr  8
.text$mn:00002818 arg_4           = dword ptr  0Ch
.text$mn:00002818
.text$mn:00002818                 push    ebp
.text$mn:00002819                 mov     ebp, esp
.text$mn:0000281B                 push    0FFFFFFFFh
.text$mn:0000281D                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00002822                 mov     eax, large fs:0
.text$mn:00002828                 push    eax
.text$mn:00002829                 sub     esp, 10h
.text$mn:0000282C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002831                 xor     eax, ebp
.text$mn:00002833                 push    eax
.text$mn:00002834                 lea     eax, [ebp+var_C]
.text$mn:00002837                 mov     large fs:0, eax
.text$mn:0000283D                 mov     [ebp+var_18], ecx
.text$mn:00002840                 mov     eax, [ebp+arg_0]
.text$mn:00002843                 push    eax             ; void *
.text$mn:00002844                 push    4               ; unsigned int
.text$mn:00002846                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000284B                 add     esp, 8
.text$mn:0000284E                 mov     [ebp+var_10], eax
.text$mn:00002851                 mov     [ebp+var_4], 0
.text$mn:00002858                 cmp     [ebp+var_10], 0
.text$mn:0000285C                 jz      short loc_2879
.text$mn:0000285E                 mov     ecx, [ebp+arg_4]
.text$mn:00002861                 push    ecx
.text$mn:00002862                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00002867                 add     esp, 4
.text$mn:0000286A                 mov     edx, [ebp+var_10]
.text$mn:0000286D                 mov     eax, [eax]
.text$mn:0000286F                 mov     [edx], eax
.text$mn:00002871                 mov     ecx, [ebp+var_10]
.text$mn:00002874                 mov     [ebp+var_14], ecx
.text$mn:00002877                 jmp     short loc_2880
.text$mn:00002879 ; ---------------------------------------------------------------------------
.text$mn:00002879
.text$mn:00002879 loc_2879:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00002879                 mov     [ebp+var_14], 0
.text$mn:00002880
.text$mn:00002880 loc_2880:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00002880                 mov     edx, [ebp+var_14]
.text$mn:00002883                 mov     [ebp+var_1C], edx
.text$mn:00002886                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000288D                 mov     ecx, [ebp+var_C]
.text$mn:00002890                 mov     large fs:0, ecx
.text$mn:00002897                 pop     ecx
.text$mn:00002898                 mov     esp, ebp
.text$mn:0000289A                 pop     ebp
.text$mn:0000289B                 retn    8
.text$mn:0000289B ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000289B
.text$mn:0000289B ; ---------------------------------------------------------------------------
.text$mn:0000289E                 align 10h
.text$mn:0000289E _text$mn        ends
.text$mn:0000289E
.text$x:000028A0 ; ===========================================================================
.text$x:000028A0
.text$x:000028A0 ; Segment type: Pure code
.text$x:000028A0 ; Segment permissions: Read/Execute
.text$x:000028A0 _text$x         segment para public 'CODE' use32
.text$x:000028A0                 assume cs:_text$x
.text$x:000028A0                 ;org 28A0h
.text$x:000028A0 ; COMDAT (pick associative to section at 2818)
.text$x:000028A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000028A0
.text$x:000028A0 ; =============== S U B R O U T I N E =======================================
.text$x:000028A0
.text$x:000028A0
.text$x:000028A0 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000028A0                                         ; DATA XREF: .xdata$x:0000480Co
.text$x:000028A0                 mov     eax, [ebp+8]
.text$x:000028A3                 push    eax
.text$x:000028A4                 mov     eax, [ebp-10h]
.text$x:000028A7                 push    eax             ; void *
.text$x:000028A8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000028AD                 add     esp, 8
.text$x:000028B0                 retn
.text$x:000028B0 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000028B0
.text$x:000028B1
.text$x:000028B1 ; =============== S U B R O U T I N E =======================================
.text$x:000028B1
.text$x:000028B1
.text$x:000028B1 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000028B1                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000028B1
.text$x:000028B1 arg_4           = dword ptr  8
.text$x:000028B1
.text$x:000028B1                 mov     edx, [esp+arg_4]
.text$x:000028B5                 lea     eax, [edx+0Ch]
.text$x:000028B8                 mov     ecx, [edx-14h]
.text$x:000028BB                 xor     ecx, eax
.text$x:000028BD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000028C2                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000028C7                 jmp     ___CxxFrameHandler3
.text$x:000028C7 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000028C7
.text$x:000028C7 _text$x         ends
.text$x:000028C7
.text$mn:000028CC ; ===========================================================================
.text$mn:000028CC
.text$mn:000028CC ; Segment type: Pure code
.text$mn:000028CC ; Segment permissions: Read/Execute
.text$mn:000028CC _text$mn        segment para public 'CODE' use32
.text$mn:000028CC                 assume cs:_text$mn
.text$mn:000028CC                 ;org 28CCh
.text$mn:000028CC ; COMDAT (pick any)
.text$mn:000028CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028CC
.text$mn:000028CC ; =============== S U B R O U T I N E =======================================
.text$mn:000028CC
.text$mn:000028CC ; Attributes: bp-based frame
.text$mn:000028CC
.text$mn:000028CC ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000028CC                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000028CC ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000028CC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000028CC
.text$mn:000028CC arg_0           = dword ptr  8
.text$mn:000028CC arg_4           = dword ptr  0Ch
.text$mn:000028CC arg_8           = dword ptr  10h
.text$mn:000028CC
.text$mn:000028CC                 push    ebp
.text$mn:000028CD                 mov     ebp, esp
.text$mn:000028CF                 mov     eax, [ebp+arg_8]
.text$mn:000028D2                 push    eax
.text$mn:000028D3                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000028D8                 add     esp, 4
.text$mn:000028DB                 push    eax             ; int
.text$mn:000028DC                 mov     ecx, [ebp+arg_4]
.text$mn:000028DF                 push    ecx             ; void *
.text$mn:000028E0                 mov     ecx, [ebp+arg_0]
.text$mn:000028E3                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:000028E8                 pop     ebp
.text$mn:000028E9                 retn
.text$mn:000028E9 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:000028E9
.text$mn:000028E9 ; ---------------------------------------------------------------------------
.text$mn:000028EA                 align 4
.text$mn:000028EA _text$mn        ends
.text$mn:000028EA
.text$mn:000028EC ; ===========================================================================
.text$mn:000028EC
.text$mn:000028EC ; Segment type: Pure code
.text$mn:000028EC ; Segment permissions: Read/Execute
.text$mn:000028EC _text$mn        segment para public 'CODE' use32
.text$mn:000028EC                 assume cs:_text$mn
.text$mn:000028EC                 ;org 28ECh
.text$mn:000028EC ; COMDAT (pick any)
.text$mn:000028EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028EC
.text$mn:000028EC ; =============== S U B R O U T I N E =======================================
.text$mn:000028EC
.text$mn:000028EC ; Attributes: bp-based frame
.text$mn:000028EC
.text$mn:000028EC ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000028EC                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000028EC ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000028EC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:000028EC
.text$mn:000028EC var_1C          = dword ptr -1Ch
.text$mn:000028EC var_18          = dword ptr -18h
.text$mn:000028EC var_14          = dword ptr -14h
.text$mn:000028EC var_10          = dword ptr -10h
.text$mn:000028EC var_C           = dword ptr -0Ch
.text$mn:000028EC var_4           = dword ptr -4
.text$mn:000028EC arg_0           = dword ptr  8
.text$mn:000028EC arg_4           = dword ptr  0Ch
.text$mn:000028EC
.text$mn:000028EC                 push    ebp
.text$mn:000028ED                 mov     ebp, esp
.text$mn:000028EF                 push    0FFFFFFFFh
.text$mn:000028F1                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000028F6                 mov     eax, large fs:0
.text$mn:000028FC                 push    eax
.text$mn:000028FD                 sub     esp, 10h
.text$mn:00002900                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002905                 xor     eax, ebp
.text$mn:00002907                 push    eax
.text$mn:00002908                 lea     eax, [ebp+var_C]
.text$mn:0000290B                 mov     large fs:0, eax
.text$mn:00002911                 mov     [ebp+var_18], ecx
.text$mn:00002914                 mov     eax, [ebp+arg_0]
.text$mn:00002917                 push    eax             ; void *
.text$mn:00002918                 push    8               ; unsigned int
.text$mn:0000291A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000291F                 add     esp, 8
.text$mn:00002922                 mov     [ebp+var_10], eax
.text$mn:00002925                 mov     [ebp+var_4], 0
.text$mn:0000292C                 cmp     [ebp+var_10], 0
.text$mn:00002930                 jz      short loc_2953
.text$mn:00002932                 mov     ecx, [ebp+arg_4]
.text$mn:00002935                 push    ecx
.text$mn:00002936                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000293B                 add     esp, 4
.text$mn:0000293E                 mov     edx, [eax]
.text$mn:00002940                 mov     eax, [eax+4]
.text$mn:00002943                 mov     ecx, [ebp+var_10]
.text$mn:00002946                 mov     [ecx], edx
.text$mn:00002948                 mov     [ecx+4], eax
.text$mn:0000294B                 mov     edx, [ebp+var_10]
.text$mn:0000294E                 mov     [ebp+var_14], edx
.text$mn:00002951                 jmp     short loc_295A
.text$mn:00002953 ; ---------------------------------------------------------------------------
.text$mn:00002953
.text$mn:00002953 loc_2953:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00002953                 mov     [ebp+var_14], 0
.text$mn:0000295A
.text$mn:0000295A loc_295A:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:0000295A                 mov     eax, [ebp+var_14]
.text$mn:0000295D                 mov     [ebp+var_1C], eax
.text$mn:00002960                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002967                 mov     ecx, [ebp+var_C]
.text$mn:0000296A                 mov     large fs:0, ecx
.text$mn:00002971                 pop     ecx
.text$mn:00002972                 mov     esp, ebp
.text$mn:00002974                 pop     ebp
.text$mn:00002975                 retn    8
.text$mn:00002975 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00002975
.text$mn:00002975 _text$mn        ends
.text$mn:00002975
.text$x:00002978 ; ===========================================================================
.text$x:00002978
.text$x:00002978 ; Segment type: Pure code
.text$x:00002978 ; Segment permissions: Read/Execute
.text$x:00002978 _text$x         segment para public 'CODE' use32
.text$x:00002978                 assume cs:_text$x
.text$x:00002978                 ;org 2978h
.text$x:00002978 ; COMDAT (pick associative to section at 28EC)
.text$x:00002978                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002978
.text$x:00002978 ; =============== S U B R O U T I N E =======================================
.text$x:00002978
.text$x:00002978
.text$x:00002978 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00002978                                         ; DATA XREF: .xdata$x:000047E0o
.text$x:00002978                 mov     eax, [ebp+8]
.text$x:0000297B                 push    eax
.text$x:0000297C                 mov     eax, [ebp-10h]
.text$x:0000297F                 push    eax             ; void *
.text$x:00002980                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002985                 add     esp, 8
.text$x:00002988                 retn
.text$x:00002988 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00002988
.text$x:00002989
.text$x:00002989 ; =============== S U B R O U T I N E =======================================
.text$x:00002989
.text$x:00002989
.text$x:00002989 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00002989                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00002989
.text$x:00002989 arg_4           = dword ptr  8
.text$x:00002989
.text$x:00002989                 mov     edx, [esp+arg_4]
.text$x:0000298D                 lea     eax, [edx+0Ch]
.text$x:00002990                 mov     ecx, [edx-14h]
.text$x:00002993                 xor     ecx, eax
.text$x:00002995                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000299A                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:0000299F                 jmp     ___CxxFrameHandler3
.text$x:0000299F __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:0000299F
.text$x:0000299F _text$x         ends
.text$x:0000299F
.text$mn:000029A4 ; ===========================================================================
.text$mn:000029A4
.text$mn:000029A4 ; Segment type: Pure code
.text$mn:000029A4 ; Segment permissions: Read/Execute
.text$mn:000029A4 _text$mn        segment para public 'CODE' use32
.text$mn:000029A4                 assume cs:_text$mn
.text$mn:000029A4                 ;org 29A4h
.text$mn:000029A4 ; COMDAT (pick any)
.text$mn:000029A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029A4
.text$mn:000029A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029A4
.text$mn:000029A4 ; Attributes: bp-based frame
.text$mn:000029A4
.text$mn:000029A4 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000029A4                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:000029A4 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:000029A4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:000029A4
.text$mn:000029A4 var_4           = dword ptr -4
.text$mn:000029A4 arg_0           = dword ptr  8
.text$mn:000029A4
.text$mn:000029A4                 push    ebp
.text$mn:000029A5                 mov     ebp, esp
.text$mn:000029A7                 push    ecx
.text$mn:000029A8                 mov     [ebp+var_4], ecx
.text$mn:000029AB                 mov     eax, [ebp+arg_0]
.text$mn:000029AE                 push    eax
.text$mn:000029AF                 mov     ecx, [ebp+var_4]
.text$mn:000029B2                 push    ecx
.text$mn:000029B3                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:000029B8                 add     esp, 8
.text$mn:000029BB                 mov     esp, ebp
.text$mn:000029BD                 pop     ebp
.text$mn:000029BE                 retn    4
.text$mn:000029BE ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:000029BE
.text$mn:000029BE ; ---------------------------------------------------------------------------
.text$mn:000029C1                 align 4
.text$mn:000029C1 _text$mn        ends
.text$mn:000029C1
.text$mn:000029C4 ; ===========================================================================
.text$mn:000029C4
.text$mn:000029C4 ; Segment type: Pure code
.text$mn:000029C4 ; Segment permissions: Read/Execute
.text$mn:000029C4 _text$mn        segment para public 'CODE' use32
.text$mn:000029C4                 assume cs:_text$mn
.text$mn:000029C4                 ;org 29C4h
.text$mn:000029C4 ; COMDAT (pick any)
.text$mn:000029C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029C4
.text$mn:000029C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029C4
.text$mn:000029C4 ; Attributes: bp-based frame
.text$mn:000029C4
.text$mn:000029C4 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:000029C4                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:000029C4 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:000029C4                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:000029C4
.text$mn:000029C4 var_4           = dword ptr -4
.text$mn:000029C4
.text$mn:000029C4                 push    ebp
.text$mn:000029C5                 mov     ebp, esp
.text$mn:000029C7                 push    ecx
.text$mn:000029C8                 mov     [ebp+var_4], ecx
.text$mn:000029CB                 mov     esp, ebp
.text$mn:000029CD                 pop     ebp
.text$mn:000029CE                 retn    4
.text$mn:000029CE ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:000029CE
.text$mn:000029CE ; ---------------------------------------------------------------------------
.text$mn:000029D1                 align 4
.text$mn:000029D1 _text$mn        ends
.text$mn:000029D1
.text$mn:000029D4 ; ===========================================================================
.text$mn:000029D4
.text$mn:000029D4 ; Segment type: Pure code
.text$mn:000029D4 ; Segment permissions: Read/Execute
.text$mn:000029D4 _text$mn        segment para public 'CODE' use32
.text$mn:000029D4                 assume cs:_text$mn
.text$mn:000029D4                 ;org 29D4h
.text$mn:000029D4 ; COMDAT (pick any)
.text$mn:000029D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029D4
.text$mn:000029D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029D4
.text$mn:000029D4 ; Attributes: bp-based frame
.text$mn:000029D4
.text$mn:000029D4 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:000029D4                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:000029D4 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:000029D4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:000029D4
.text$mn:000029D4 arg_0           = dword ptr  8
.text$mn:000029D4 arg_4           = dword ptr  0Ch
.text$mn:000029D4
.text$mn:000029D4                 push    ebp
.text$mn:000029D5                 mov     ebp, esp
.text$mn:000029D7                 mov     eax, [ebp+arg_4]
.text$mn:000029DA                 push    eax
.text$mn:000029DB                 mov     ecx, [ebp+arg_0]
.text$mn:000029DE                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:000029E3                 pop     ebp
.text$mn:000029E4                 retn
.text$mn:000029E4 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:000029E4
.text$mn:000029E4 ; ---------------------------------------------------------------------------
.text$mn:000029E5                 align 4
.text$mn:000029E5 _text$mn        ends
.text$mn:000029E5
.text$mn:000029E8 ; ===========================================================================
.text$mn:000029E8
.text$mn:000029E8 ; Segment type: Pure code
.text$mn:000029E8 ; Segment permissions: Read/Execute
.text$mn:000029E8 _text$mn        segment para public 'CODE' use32
.text$mn:000029E8                 assume cs:_text$mn
.text$mn:000029E8                 ;org 29E8h
.text$mn:000029E8 ; COMDAT (pick any)
.text$mn:000029E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029E8
.text$mn:000029E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000029E8
.text$mn:000029E8 ; Attributes: bp-based frame
.text$mn:000029E8
.text$mn:000029E8 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:000029E8                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:000029E8 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:000029E8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:000029E8
.text$mn:000029E8 var_4           = dword ptr -4
.text$mn:000029E8
.text$mn:000029E8                 push    ebp
.text$mn:000029E9                 mov     ebp, esp
.text$mn:000029EB                 push    ecx
.text$mn:000029EC                 mov     [ebp+var_4], ecx
.text$mn:000029EF                 mov     esp, ebp
.text$mn:000029F1                 pop     ebp
.text$mn:000029F2                 retn    4
.text$mn:000029F2 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:000029F2
.text$mn:000029F2 ; ---------------------------------------------------------------------------
.text$mn:000029F5                 align 4
.text$mn:000029F5 _text$mn        ends
.text$mn:000029F5
.text$mn:000029F8 ; ===========================================================================
.text$mn:000029F8
.text$mn:000029F8 ; Segment type: Pure code
.text$mn:000029F8 ; Segment permissions: Read/Execute
.text$mn:000029F8 _text$mn        segment para public 'CODE' use32
.text$mn:000029F8                 assume cs:_text$mn
.text$mn:000029F8                 ;org 29F8h
.text$mn:000029F8 ; COMDAT (pick any)
.text$mn:000029F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029F8
.text$mn:000029F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000029F8
.text$mn:000029F8 ; Attributes: bp-based frame
.text$mn:000029F8
.text$mn:000029F8 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:000029F8                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:000029F8 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:000029F8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:000029F8                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:000029F8
.text$mn:000029F8 arg_0           = dword ptr  8
.text$mn:000029F8
.text$mn:000029F8                 push    ebp
.text$mn:000029F9                 mov     ebp, esp
.text$mn:000029FB                 mov     eax, [ebp+arg_0]
.text$mn:000029FE                 pop     ebp
.text$mn:000029FF                 retn
.text$mn:000029FF ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:000029FF
.text$mn:000029FF _text$mn        ends
.text$mn:000029FF
.text$mn:00002A00 ; ===========================================================================
.text$mn:00002A00
.text$mn:00002A00 ; Segment type: Pure code
.text$mn:00002A00 ; Segment permissions: Read/Execute
.text$mn:00002A00 _text$mn        segment para public 'CODE' use32
.text$mn:00002A00                 assume cs:_text$mn
.text$mn:00002A00                 ;org 2A00h
.text$mn:00002A00 ; COMDAT (pick any)
.text$mn:00002A00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A00
.text$mn:00002A00 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A00
.text$mn:00002A00 ; Attributes: bp-based frame
.text$mn:00002A00
.text$mn:00002A00 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00002A00                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00002A00 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00002A00                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00002A00
.text$mn:00002A00 arg_0           = dword ptr  8
.text$mn:00002A00
.text$mn:00002A00                 push    ebp
.text$mn:00002A01                 mov     ebp, esp
.text$mn:00002A03                 mov     eax, [ebp+arg_0]
.text$mn:00002A06                 pop     ebp
.text$mn:00002A07                 retn
.text$mn:00002A07 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00002A07
.text$mn:00002A07 _text$mn        ends
.text$mn:00002A07
.text$mn:00002A08 ; ===========================================================================
.text$mn:00002A08
.text$mn:00002A08 ; Segment type: Pure code
.text$mn:00002A08 ; Segment permissions: Read/Execute
.text$mn:00002A08 _text$mn        segment para public 'CODE' use32
.text$mn:00002A08                 assume cs:_text$mn
.text$mn:00002A08                 ;org 2A08h
.text$mn:00002A08 ; COMDAT (pick any)
.text$mn:00002A08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A08
.text$mn:00002A08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A08
.text$mn:00002A08 ; Attributes: bp-based frame
.text$mn:00002A08
.text$mn:00002A08 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00002A08                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002A08 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00002A08                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00002A08
.text$mn:00002A08 var_10          = dword ptr -10h
.text$mn:00002A08 var_C           = dword ptr -0Ch
.text$mn:00002A08 var_4           = dword ptr -4
.text$mn:00002A08
.text$mn:00002A08                 push    ebp
.text$mn:00002A09                 mov     ebp, esp
.text$mn:00002A0B                 push    0FFFFFFFFh
.text$mn:00002A0D                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002A12                 mov     eax, large fs:0
.text$mn:00002A18                 push    eax
.text$mn:00002A19                 push    ecx
.text$mn:00002A1A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002A1F                 xor     eax, ebp
.text$mn:00002A21                 push    eax
.text$mn:00002A22                 lea     eax, [ebp+var_C]
.text$mn:00002A25                 mov     large fs:0, eax
.text$mn:00002A2B                 mov     [ebp+var_10], ecx
.text$mn:00002A2E                 mov     ecx, [ebp+var_10]
.text$mn:00002A31                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00002A36                 mov     [ebp+var_4], 0
.text$mn:00002A3D                 mov     ecx, [ebp+var_10]
.text$mn:00002A40                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00002A45                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002A4C                 mov     eax, [ebp+var_10]
.text$mn:00002A4F                 mov     ecx, [ebp+var_C]
.text$mn:00002A52                 mov     large fs:0, ecx
.text$mn:00002A59                 pop     ecx
.text$mn:00002A5A                 mov     esp, ebp
.text$mn:00002A5C                 pop     ebp
.text$mn:00002A5D                 retn    4
.text$mn:00002A5D ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00002A5D
.text$mn:00002A5D _text$mn        ends
.text$mn:00002A5D
.text$x:00002A60 ; ===========================================================================
.text$x:00002A60
.text$x:00002A60 ; Segment type: Pure code
.text$x:00002A60 ; Segment permissions: Read/Execute
.text$x:00002A60 _text$x         segment para public 'CODE' use32
.text$x:00002A60                 assume cs:_text$x
.text$x:00002A60                 ;org 2A60h
.text$x:00002A60 ; COMDAT (pick associative to section at 2A08)
.text$x:00002A60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002A60
.text$x:00002A60 ; =============== S U B R O U T I N E =======================================
.text$x:00002A60
.text$x:00002A60
.text$x:00002A60 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00002A60                                         ; DATA XREF: .xdata$x:00004494o
.text$x:00002A60                 mov     ecx, [ebp-10h]
.text$x:00002A63                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00002A63 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00002A63
.text$x:00002A68
.text$x:00002A68 ; =============== S U B R O U T I N E =======================================
.text$x:00002A68
.text$x:00002A68
.text$x:00002A68 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00002A68                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00002A68
.text$x:00002A68 arg_4           = dword ptr  8
.text$x:00002A68
.text$x:00002A68                 mov     edx, [esp+arg_4]
.text$x:00002A6C                 lea     eax, [edx+0Ch]
.text$x:00002A6F                 mov     ecx, [edx-8]
.text$x:00002A72                 xor     ecx, eax
.text$x:00002A74                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A79                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00002A7E                 jmp     ___CxxFrameHandler3
.text$x:00002A7E __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00002A7E
.text$x:00002A7E ; ---------------------------------------------------------------------------
.text$x:00002A83                 align 4
.text$x:00002A83 _text$x         ends
.text$x:00002A83
.text$mn:00002A84 ; ===========================================================================
.text$mn:00002A84
.text$mn:00002A84 ; Segment type: Pure code
.text$mn:00002A84 ; Segment permissions: Read/Execute
.text$mn:00002A84 _text$mn        segment para public 'CODE' use32
.text$mn:00002A84                 assume cs:_text$mn
.text$mn:00002A84                 ;org 2A84h
.text$mn:00002A84 ; COMDAT (pick any)
.text$mn:00002A84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A84
.text$mn:00002A84 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A84
.text$mn:00002A84 ; Attributes: bp-based frame
.text$mn:00002A84
.text$mn:00002A84 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00002A84                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002A84 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00002A84                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00002A84
.text$mn:00002A84 var_10          = dword ptr -10h
.text$mn:00002A84 var_C           = dword ptr -0Ch
.text$mn:00002A84 var_4           = dword ptr -4
.text$mn:00002A84
.text$mn:00002A84                 push    ebp
.text$mn:00002A85                 mov     ebp, esp
.text$mn:00002A87                 push    0FFFFFFFFh
.text$mn:00002A89                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002A8E                 mov     eax, large fs:0
.text$mn:00002A94                 push    eax
.text$mn:00002A95                 push    ecx
.text$mn:00002A96                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002A9B                 xor     eax, ebp
.text$mn:00002A9D                 push    eax
.text$mn:00002A9E                 lea     eax, [ebp+var_C]
.text$mn:00002AA1                 mov     large fs:0, eax
.text$mn:00002AA7                 mov     [ebp+var_10], ecx
.text$mn:00002AAA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002AAD                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00002AB2                 mov     [ebp+var_4], 0
.text$mn:00002AB9                 mov     eax, [ebp+var_10]
.text$mn:00002ABC                 mov     dword ptr [eax+14h], 0
.text$mn:00002AC3                 mov     ecx, [ebp+var_10]
.text$mn:00002AC6                 mov     dword ptr [ecx+18h], 0
.text$mn:00002ACD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002AD4                 mov     eax, [ebp+var_10]
.text$mn:00002AD7                 mov     ecx, [ebp+var_C]
.text$mn:00002ADA                 mov     large fs:0, ecx
.text$mn:00002AE1                 pop     ecx
.text$mn:00002AE2                 mov     esp, ebp
.text$mn:00002AE4                 pop     ebp
.text$mn:00002AE5                 retn
.text$mn:00002AE5 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00002AE5
.text$mn:00002AE5 ; ---------------------------------------------------------------------------
.text$mn:00002AE6                 align 4
.text$mn:00002AE6 _text$mn        ends
.text$mn:00002AE6
.text$x:00002AE8 ; ===========================================================================
.text$x:00002AE8
.text$x:00002AE8 ; Segment type: Pure code
.text$x:00002AE8 ; Segment permissions: Read/Execute
.text$x:00002AE8 _text$x         segment para public 'CODE' use32
.text$x:00002AE8                 assume cs:_text$x
.text$x:00002AE8                 ;org 2AE8h
.text$x:00002AE8 ; COMDAT (pick associative to section at 2A84)
.text$x:00002AE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002AE8
.text$x:00002AE8 ; =============== S U B R O U T I N E =======================================
.text$x:00002AE8
.text$x:00002AE8
.text$x:00002AE8 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00002AE8                                         ; DATA XREF: .xdata$x:0000443Co
.text$x:00002AE8                 mov     ecx, [ebp-10h]  ; this
.text$x:00002AEB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002AEB __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00002AEB
.text$x:00002AF0
.text$x:00002AF0 ; =============== S U B R O U T I N E =======================================
.text$x:00002AF0
.text$x:00002AF0
.text$x:00002AF0 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00002AF0                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00002AF0
.text$x:00002AF0 arg_4           = dword ptr  8
.text$x:00002AF0
.text$x:00002AF0                 mov     edx, [esp+arg_4]
.text$x:00002AF4                 lea     eax, [edx+0Ch]
.text$x:00002AF7                 mov     ecx, [edx-8]
.text$x:00002AFA                 xor     ecx, eax
.text$x:00002AFC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B01                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00002B06                 jmp     ___CxxFrameHandler3
.text$x:00002B06 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00002B06
.text$x:00002B06 ; ---------------------------------------------------------------------------
.text$x:00002B0B                 align 4
.text$x:00002B0B _text$x         ends
.text$x:00002B0B
.text$mn:00002B0C ; ===========================================================================
.text$mn:00002B0C
.text$mn:00002B0C ; Segment type: Pure code
.text$mn:00002B0C ; Segment permissions: Read/Execute
.text$mn:00002B0C _text$mn        segment para public 'CODE' use32
.text$mn:00002B0C                 assume cs:_text$mn
.text$mn:00002B0C                 ;org 2B0Ch
.text$mn:00002B0C ; COMDAT (pick any)
.text$mn:00002B0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B0C
.text$mn:00002B0C ; =============== S U B R O U T I N E =======================================
.text$mn:00002B0C
.text$mn:00002B0C ; Attributes: bp-based frame
.text$mn:00002B0C
.text$mn:00002B0C ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00002B0C                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00002B0C ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00002B0C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00002B0C
.text$mn:00002B0C var_4           = dword ptr -4
.text$mn:00002B0C
.text$mn:00002B0C                 push    ebp
.text$mn:00002B0D                 mov     ebp, esp
.text$mn:00002B0F                 push    ecx
.text$mn:00002B10                 mov     [ebp+var_4], ecx
.text$mn:00002B13                 mov     ecx, [ebp+var_4]
.text$mn:00002B16                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00002B1B                 mov     eax, [ebp+var_4]
.text$mn:00002B1E                 mov     esp, ebp
.text$mn:00002B20                 pop     ebp
.text$mn:00002B21                 retn
.text$mn:00002B21 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00002B21
.text$mn:00002B21 ; ---------------------------------------------------------------------------
.text$mn:00002B22                 align 4
.text$mn:00002B22 _text$mn        ends
.text$mn:00002B22
.text$mn:00002B24 ; ===========================================================================
.text$mn:00002B24
.text$mn:00002B24 ; Segment type: Pure code
.text$mn:00002B24 ; Segment permissions: Read/Execute
.text$mn:00002B24 _text$mn        segment para public 'CODE' use32
.text$mn:00002B24                 assume cs:_text$mn
.text$mn:00002B24                 ;org 2B24h
.text$mn:00002B24 ; COMDAT (pick any)
.text$mn:00002B24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B24
.text$mn:00002B24 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B24
.text$mn:00002B24 ; Attributes: bp-based frame
.text$mn:00002B24
.text$mn:00002B24 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00002B24                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00002B24 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00002B24                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00002B24
.text$mn:00002B24 var_4           = dword ptr -4
.text$mn:00002B24
.text$mn:00002B24                 push    ebp
.text$mn:00002B25                 mov     ebp, esp
.text$mn:00002B27                 push    ecx
.text$mn:00002B28                 mov     [ebp+var_4], ecx
.text$mn:00002B2B                 mov     eax, [ebp+var_4]
.text$mn:00002B2E                 mov     esp, ebp
.text$mn:00002B30                 pop     ebp
.text$mn:00002B31                 retn
.text$mn:00002B31 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00002B31
.text$mn:00002B31 ; ---------------------------------------------------------------------------
.text$mn:00002B32                 align 4
.text$mn:00002B32 _text$mn        ends
.text$mn:00002B32
.text$mn:00002B34 ; ===========================================================================
.text$mn:00002B34
.text$mn:00002B34 ; Segment type: Pure code
.text$mn:00002B34 ; Segment permissions: Read/Execute
.text$mn:00002B34 _text$mn        segment para public 'CODE' use32
.text$mn:00002B34                 assume cs:_text$mn
.text$mn:00002B34                 ;org 2B34h
.text$mn:00002B34 ; COMDAT (pick any)
.text$mn:00002B34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B34
.text$mn:00002B34 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B34
.text$mn:00002B34 ; Attributes: bp-based frame
.text$mn:00002B34
.text$mn:00002B34 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00002B34                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00002B34 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00002B34                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00002B34                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:00002B34
.text$mn:00002B34 var_4           = dword ptr -4
.text$mn:00002B34
.text$mn:00002B34                 push    ebp
.text$mn:00002B35                 mov     ebp, esp
.text$mn:00002B37                 push    ecx
.text$mn:00002B38                 mov     [ebp+var_4], ecx
.text$mn:00002B3B                 mov     eax, [ebp+var_4]
.text$mn:00002B3E                 mov     esp, ebp
.text$mn:00002B40                 pop     ebp
.text$mn:00002B41                 retn
.text$mn:00002B41 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00002B41
.text$mn:00002B41 ; ---------------------------------------------------------------------------
.text$mn:00002B42                 align 4
.text$mn:00002B42 _text$mn        ends
.text$mn:00002B42
.text$mn:00002B44 ; ===========================================================================
.text$mn:00002B44
.text$mn:00002B44 ; Segment type: Pure code
.text$mn:00002B44 ; Segment permissions: Read/Execute
.text$mn:00002B44 _text$mn        segment para public 'CODE' use32
.text$mn:00002B44                 assume cs:_text$mn
.text$mn:00002B44                 ;org 2B44h
.text$mn:00002B44 ; COMDAT (pick any)
.text$mn:00002B44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B44
.text$mn:00002B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B44
.text$mn:00002B44 ; Attributes: bp-based frame
.text$mn:00002B44
.text$mn:00002B44 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00002B44                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00002B44 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00002B44                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00002B44                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00002B44
.text$mn:00002B44 var_14          = dword ptr -14h
.text$mn:00002B44 var_D           = byte ptr -0Dh
.text$mn:00002B44 var_C           = dword ptr -0Ch
.text$mn:00002B44 var_4           = dword ptr -4
.text$mn:00002B44 Str             = dword ptr  8
.text$mn:00002B44
.text$mn:00002B44                 push    ebp
.text$mn:00002B45                 mov     ebp, esp
.text$mn:00002B47                 push    0FFFFFFFFh
.text$mn:00002B49                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00002B4E                 mov     eax, large fs:0
.text$mn:00002B54                 push    eax
.text$mn:00002B55                 sub     esp, 8
.text$mn:00002B58                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B5D                 xor     eax, ebp
.text$mn:00002B5F                 push    eax
.text$mn:00002B60                 lea     eax, [ebp+var_C]
.text$mn:00002B63                 mov     large fs:0, eax
.text$mn:00002B69                 mov     [ebp+var_14], ecx
.text$mn:00002B6C                 lea     ecx, [ebp+var_D]
.text$mn:00002B6F                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00002B74                 push    eax
.text$mn:00002B75                 mov     ecx, [ebp+var_14]
.text$mn:00002B78                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00002B7D                 mov     [ebp+var_4], 0
.text$mn:00002B84                 push    0               ; Size
.text$mn:00002B86                 push    0               ; char
.text$mn:00002B88                 mov     ecx, [ebp+var_14]
.text$mn:00002B8B                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002B90                 mov     eax, [ebp+Str]
.text$mn:00002B93                 push    eax             ; Str
.text$mn:00002B94                 mov     ecx, [ebp+var_14]
.text$mn:00002B97                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00002B9C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002BA3                 mov     eax, [ebp+var_14]
.text$mn:00002BA6                 mov     ecx, [ebp+var_C]
.text$mn:00002BA9                 mov     large fs:0, ecx
.text$mn:00002BB0                 pop     ecx
.text$mn:00002BB1                 mov     esp, ebp
.text$mn:00002BB3                 pop     ebp
.text$mn:00002BB4                 retn    4
.text$mn:00002BB4 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00002BB4
.text$mn:00002BB4 ; ---------------------------------------------------------------------------
.text$mn:00002BB7                 align 4
.text$mn:00002BB7 _text$mn        ends
.text$mn:00002BB7
.text$x:00002BB8 ; ===========================================================================
.text$x:00002BB8
.text$x:00002BB8 ; Segment type: Pure code
.text$x:00002BB8 ; Segment permissions: Read/Execute
.text$x:00002BB8 _text$x         segment para public 'CODE' use32
.text$x:00002BB8                 assume cs:_text$x
.text$x:00002BB8                 ;org 2BB8h
.text$x:00002BB8 ; COMDAT (pick associative to section at 2B44)
.text$x:00002BB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002BB8
.text$x:00002BB8 ; =============== S U B R O U T I N E =======================================
.text$x:00002BB8
.text$x:00002BB8
.text$x:00002BB8 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00002BB8                                         ; DATA XREF: .xdata$x:000044ECo
.text$x:00002BB8                 mov     ecx, [ebp-14h]
.text$x:00002BBB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00002BBB __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00002BBB
.text$x:00002BC0
.text$x:00002BC0 ; =============== S U B R O U T I N E =======================================
.text$x:00002BC0
.text$x:00002BC0
.text$x:00002BC0 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00002BC0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00002BC0
.text$x:00002BC0 arg_4           = dword ptr  8
.text$x:00002BC0
.text$x:00002BC0                 mov     edx, [esp+arg_4]
.text$x:00002BC4                 lea     eax, [edx+0Ch]
.text$x:00002BC7                 mov     ecx, [edx-0Ch]
.text$x:00002BCA                 xor     ecx, eax
.text$x:00002BCC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BD1                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00002BD6                 jmp     ___CxxFrameHandler3
.text$x:00002BD6 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00002BD6
.text$x:00002BD6 ; ---------------------------------------------------------------------------
.text$x:00002BDB                 align 4
.text$x:00002BDB _text$x         ends
.text$x:00002BDB
.text$mn:00002BDC ; ===========================================================================
.text$mn:00002BDC
.text$mn:00002BDC ; Segment type: Pure code
.text$mn:00002BDC ; Segment permissions: Read/Execute
.text$mn:00002BDC _text$mn        segment para public 'CODE' use32
.text$mn:00002BDC                 assume cs:_text$mn
.text$mn:00002BDC                 ;org 2BDCh
.text$mn:00002BDC ; COMDAT (pick any)
.text$mn:00002BDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BDC
.text$mn:00002BDC ; =============== S U B R O U T I N E =======================================
.text$mn:00002BDC
.text$mn:00002BDC ; Attributes: bp-based frame
.text$mn:00002BDC
.text$mn:00002BDC ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00002BDC                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00002BDC ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00002BDC                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00002BDC
.text$mn:00002BDC var_4           = dword ptr -4
.text$mn:00002BDC
.text$mn:00002BDC                 push    ebp
.text$mn:00002BDD                 mov     ebp, esp
.text$mn:00002BDF                 push    ecx
.text$mn:00002BE0                 mov     [ebp+var_4], ecx
.text$mn:00002BE3                 mov     eax, [ebp+var_4]
.text$mn:00002BE6                 mov     dword ptr [eax], 0
.text$mn:00002BEC                 mov     eax, [ebp+var_4]
.text$mn:00002BEF                 mov     esp, ebp
.text$mn:00002BF1                 pop     ebp
.text$mn:00002BF2                 retn
.text$mn:00002BF2 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00002BF2
.text$mn:00002BF2 ; ---------------------------------------------------------------------------
.text$mn:00002BF3                 align 4
.text$mn:00002BF3 _text$mn        ends
.text$mn:00002BF3
.text$mn:00002BF4 ; ===========================================================================
.text$mn:00002BF4
.text$mn:00002BF4 ; Segment type: Pure code
.text$mn:00002BF4 ; Segment permissions: Read/Execute
.text$mn:00002BF4 _text$mn        segment para public 'CODE' use32
.text$mn:00002BF4                 assume cs:_text$mn
.text$mn:00002BF4                 ;org 2BF4h
.text$mn:00002BF4 ; COMDAT (pick any)
.text$mn:00002BF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BF4
.text$mn:00002BF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BF4
.text$mn:00002BF4 ; Attributes: bp-based frame
.text$mn:00002BF4
.text$mn:00002BF4 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00002BF4                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00002BF4 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00002BF4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00002BF4
.text$mn:00002BF4 var_4           = dword ptr -4
.text$mn:00002BF4
.text$mn:00002BF4                 push    ebp
.text$mn:00002BF5                 mov     ebp, esp
.text$mn:00002BF7                 push    ecx
.text$mn:00002BF8                 mov     [ebp+var_4], ecx
.text$mn:00002BFB                 mov     eax, [ebp+var_4]
.text$mn:00002BFE                 mov     dword ptr [eax], 0
.text$mn:00002C04                 mov     ecx, [ebp+var_4]
.text$mn:00002C07                 mov     dword ptr [ecx+4], 0
.text$mn:00002C0E                 mov     eax, [ebp+var_4]
.text$mn:00002C11                 mov     esp, ebp
.text$mn:00002C13                 pop     ebp
.text$mn:00002C14                 retn
.text$mn:00002C14 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00002C14
.text$mn:00002C14 ; ---------------------------------------------------------------------------
.text$mn:00002C15                 align 4
.text$mn:00002C15 _text$mn        ends
.text$mn:00002C15
.text$mn:00002C18 ; ===========================================================================
.text$mn:00002C18
.text$mn:00002C18 ; Segment type: Pure code
.text$mn:00002C18 ; Segment permissions: Read/Execute
.text$mn:00002C18 _text$mn        segment para public 'CODE' use32
.text$mn:00002C18                 assume cs:_text$mn
.text$mn:00002C18                 ;org 2C18h
.text$mn:00002C18 ; COMDAT (pick any)
.text$mn:00002C18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C18
.text$mn:00002C18 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C18
.text$mn:00002C18 ; Attributes: bp-based frame
.text$mn:00002C18
.text$mn:00002C18 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00002C18                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00002C18 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00002C18                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00002C18                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00002C18
.text$mn:00002C18 var_10          = dword ptr -10h
.text$mn:00002C18 var_C           = dword ptr -0Ch
.text$mn:00002C18 var_4           = dword ptr -4
.text$mn:00002C18
.text$mn:00002C18                 push    ebp
.text$mn:00002C19                 mov     ebp, esp
.text$mn:00002C1B                 push    0FFFFFFFFh
.text$mn:00002C1D                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00002C22                 mov     eax, large fs:0
.text$mn:00002C28                 push    eax
.text$mn:00002C29                 push    ecx
.text$mn:00002C2A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002C2F                 xor     eax, ebp
.text$mn:00002C31                 push    eax
.text$mn:00002C32                 lea     eax, [ebp+var_C]
.text$mn:00002C35                 mov     large fs:0, eax
.text$mn:00002C3B                 mov     [ebp+var_10], ecx
.text$mn:00002C3E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002C41                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00002C46                 mov     [ebp+var_4], 0
.text$mn:00002C4D                 mov     eax, [ebp+var_10]
.text$mn:00002C50                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00002C56                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002C5D                 mov     eax, [ebp+var_10]
.text$mn:00002C60                 mov     ecx, [ebp+var_C]
.text$mn:00002C63                 mov     large fs:0, ecx
.text$mn:00002C6A                 pop     ecx
.text$mn:00002C6B                 mov     esp, ebp
.text$mn:00002C6D                 pop     ebp
.text$mn:00002C6E                 retn
.text$mn:00002C6E ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00002C6E
.text$mn:00002C6E ; ---------------------------------------------------------------------------
.text$mn:00002C6F                 align 10h
.text$mn:00002C6F _text$mn        ends
.text$mn:00002C6F
.text$x:00002C70 ; ===========================================================================
.text$x:00002C70
.text$x:00002C70 ; Segment type: Pure code
.text$x:00002C70 ; Segment permissions: Read/Execute
.text$x:00002C70 _text$x         segment para public 'CODE' use32
.text$x:00002C70                 assume cs:_text$x
.text$x:00002C70                 ;org 2C70h
.text$x:00002C70 ; COMDAT (pick associative to section at 2C18)
.text$x:00002C70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002C70
.text$x:00002C70 ; =============== S U B R O U T I N E =======================================
.text$x:00002C70
.text$x:00002C70
.text$x:00002C70 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00002C70                                         ; DATA XREF: .xdata$x:00004654o
.text$x:00002C70                 mov     ecx, [ebp-10h]  ; this
.text$x:00002C73                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00002C73 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00002C73
.text$x:00002C78
.text$x:00002C78 ; =============== S U B R O U T I N E =======================================
.text$x:00002C78
.text$x:00002C78
.text$x:00002C78 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00002C78                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00002C78
.text$x:00002C78 arg_4           = dword ptr  8
.text$x:00002C78
.text$x:00002C78                 mov     edx, [esp+arg_4]
.text$x:00002C7C                 lea     eax, [edx+0Ch]
.text$x:00002C7F                 mov     ecx, [edx-8]
.text$x:00002C82                 xor     ecx, eax
.text$x:00002C84                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C89                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00002C8E                 jmp     ___CxxFrameHandler3
.text$x:00002C8E __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00002C8E
.text$x:00002C8E ; ---------------------------------------------------------------------------
.text$x:00002C93                 align 4
.text$x:00002C93 _text$x         ends
.text$x:00002C93
.text$mn:00002C94 ; ===========================================================================
.text$mn:00002C94
.text$mn:00002C94 ; Segment type: Pure code
.text$mn:00002C94 ; Segment permissions: Read/Execute
.text$mn:00002C94 _text$mn        segment para public 'CODE' use32
.text$mn:00002C94                 assume cs:_text$mn
.text$mn:00002C94                 ;org 2C94h
.text$mn:00002C94 ; COMDAT (pick any)
.text$mn:00002C94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C94
.text$mn:00002C94 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C94
.text$mn:00002C94 ; Attributes: bp-based frame
.text$mn:00002C94
.text$mn:00002C94 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00002C94                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00002C94 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00002C94                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00002C94
.text$mn:00002C94 var_10          = dword ptr -10h
.text$mn:00002C94 var_C           = dword ptr -0Ch
.text$mn:00002C94 var_4           = dword ptr -4
.text$mn:00002C94
.text$mn:00002C94                 push    ebp
.text$mn:00002C95                 mov     ebp, esp
.text$mn:00002C97                 push    0FFFFFFFFh
.text$mn:00002C99                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00002C9E                 mov     eax, large fs:0
.text$mn:00002CA4                 push    eax
.text$mn:00002CA5                 push    ecx
.text$mn:00002CA6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002CAB                 xor     eax, ebp
.text$mn:00002CAD                 push    eax
.text$mn:00002CAE                 lea     eax, [ebp+var_C]
.text$mn:00002CB1                 mov     large fs:0, eax
.text$mn:00002CB7                 mov     [ebp+var_10], ecx
.text$mn:00002CBA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002CBD                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00002CC2                 mov     [ebp+var_4], 0
.text$mn:00002CC9                 mov     eax, [ebp+var_10]
.text$mn:00002CCC                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00002CD2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002CD9                 mov     eax, [ebp+var_10]
.text$mn:00002CDC                 mov     ecx, [ebp+var_C]
.text$mn:00002CDF                 mov     large fs:0, ecx
.text$mn:00002CE6                 pop     ecx
.text$mn:00002CE7                 mov     esp, ebp
.text$mn:00002CE9                 pop     ebp
.text$mn:00002CEA                 retn
.text$mn:00002CEA ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00002CEA
.text$mn:00002CEA ; ---------------------------------------------------------------------------
.text$mn:00002CEB                 align 4
.text$mn:00002CEB _text$mn        ends
.text$mn:00002CEB
.text$x:00002CEC ; ===========================================================================
.text$x:00002CEC
.text$x:00002CEC ; Segment type: Pure code
.text$x:00002CEC ; Segment permissions: Read/Execute
.text$x:00002CEC _text$x         segment para public 'CODE' use32
.text$x:00002CEC                 assume cs:_text$x
.text$x:00002CEC                 ;org 2CECh
.text$x:00002CEC ; COMDAT (pick associative to section at 2C94)
.text$x:00002CEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002CEC
.text$x:00002CEC ; =============== S U B R O U T I N E =======================================
.text$x:00002CEC
.text$x:00002CEC
.text$x:00002CEC __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00002CEC                                         ; DATA XREF: .xdata$x:000046D8o
.text$x:00002CEC                 mov     ecx, [ebp-10h]  ; this
.text$x:00002CEF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00002CEF __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00002CEF
.text$x:00002CF4
.text$x:00002CF4 ; =============== S U B R O U T I N E =======================================
.text$x:00002CF4
.text$x:00002CF4
.text$x:00002CF4 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00002CF4                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00002CF4
.text$x:00002CF4 arg_4           = dword ptr  8
.text$x:00002CF4
.text$x:00002CF4                 mov     edx, [esp+arg_4]
.text$x:00002CF8                 lea     eax, [edx+0Ch]
.text$x:00002CFB                 mov     ecx, [edx-8]
.text$x:00002CFE                 xor     ecx, eax
.text$x:00002D00                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D05                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00002D0A                 jmp     ___CxxFrameHandler3
.text$x:00002D0A __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00002D0A
.text$x:00002D0A ; ---------------------------------------------------------------------------
.text$x:00002D0F                 align 10h
.text$x:00002D0F _text$x         ends
.text$x:00002D0F
.text$mn:00002D10 ; ===========================================================================
.text$mn:00002D10
.text$mn:00002D10 ; Segment type: Pure code
.text$mn:00002D10 ; Segment permissions: Read/Execute
.text$mn:00002D10 _text$mn        segment para public 'CODE' use32
.text$mn:00002D10                 assume cs:_text$mn
.text$mn:00002D10                 ;org 2D10h
.text$mn:00002D10 ; COMDAT (pick any)
.text$mn:00002D10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D10
.text$mn:00002D10 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D10
.text$mn:00002D10 ; Attributes: bp-based frame
.text$mn:00002D10
.text$mn:00002D10 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00002D10                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00002D10 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00002D10                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00002D10
.text$mn:00002D10 var_10          = dword ptr -10h
.text$mn:00002D10 var_C           = dword ptr -0Ch
.text$mn:00002D10 var_4           = dword ptr -4
.text$mn:00002D10
.text$mn:00002D10                 push    ebp
.text$mn:00002D11                 mov     ebp, esp
.text$mn:00002D13                 push    0FFFFFFFFh
.text$mn:00002D15                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00002D1A                 mov     eax, large fs:0
.text$mn:00002D20                 push    eax
.text$mn:00002D21                 push    ecx
.text$mn:00002D22                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002D27                 xor     eax, ebp
.text$mn:00002D29                 push    eax
.text$mn:00002D2A                 lea     eax, [ebp+var_C]
.text$mn:00002D2D                 mov     large fs:0, eax
.text$mn:00002D33                 mov     [ebp+var_10], ecx
.text$mn:00002D36                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002D39                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00002D3E                 mov     [ebp+var_4], 0
.text$mn:00002D45                 mov     eax, [ebp+var_10]
.text$mn:00002D48                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00002D4E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002D55                 mov     eax, [ebp+var_10]
.text$mn:00002D58                 mov     ecx, [ebp+var_C]
.text$mn:00002D5B                 mov     large fs:0, ecx
.text$mn:00002D62                 pop     ecx
.text$mn:00002D63                 mov     esp, ebp
.text$mn:00002D65                 pop     ebp
.text$mn:00002D66                 retn
.text$mn:00002D66 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00002D66
.text$mn:00002D66 ; ---------------------------------------------------------------------------
.text$mn:00002D67                 align 4
.text$mn:00002D67 _text$mn        ends
.text$mn:00002D67
.text$x:00002D68 ; ===========================================================================
.text$x:00002D68
.text$x:00002D68 ; Segment type: Pure code
.text$x:00002D68 ; Segment permissions: Read/Execute
.text$x:00002D68 _text$x         segment para public 'CODE' use32
.text$x:00002D68                 assume cs:_text$x
.text$x:00002D68                 ;org 2D68h
.text$x:00002D68 ; COMDAT (pick associative to section at 2D10)
.text$x:00002D68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002D68
.text$x:00002D68 ; =============== S U B R O U T I N E =======================================
.text$x:00002D68
.text$x:00002D68
.text$x:00002D68 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00002D68                                         ; DATA XREF: .xdata$x:0000475Co
.text$x:00002D68                 mov     ecx, [ebp-10h]  ; this
.text$x:00002D6B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00002D6B __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00002D6B
.text$x:00002D70
.text$x:00002D70 ; =============== S U B R O U T I N E =======================================
.text$x:00002D70
.text$x:00002D70
.text$x:00002D70 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00002D70                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00002D70
.text$x:00002D70 arg_4           = dword ptr  8
.text$x:00002D70
.text$x:00002D70                 mov     edx, [esp+arg_4]
.text$x:00002D74                 lea     eax, [edx+0Ch]
.text$x:00002D77                 mov     ecx, [edx-8]
.text$x:00002D7A                 xor     ecx, eax
.text$x:00002D7C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D81                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00002D86                 jmp     ___CxxFrameHandler3
.text$x:00002D86 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00002D86
.text$x:00002D86 ; ---------------------------------------------------------------------------
.text$x:00002D8B                 align 4
.text$x:00002D8B _text$x         ends
.text$x:00002D8B
.text$mn:00002D8C ; ===========================================================================
.text$mn:00002D8C
.text$mn:00002D8C ; Segment type: Pure code
.text$mn:00002D8C ; Segment permissions: Read/Execute
.text$mn:00002D8C _text$mn        segment para public 'CODE' use32
.text$mn:00002D8C                 assume cs:_text$mn
.text$mn:00002D8C                 ;org 2D8Ch
.text$mn:00002D8C ; COMDAT (pick any)
.text$mn:00002D8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D8C
.text$mn:00002D8C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D8C
.text$mn:00002D8C ; Attributes: bp-based frame
.text$mn:00002D8C
.text$mn:00002D8C ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00002D8C                 public ??0error_category@std@@QAE@XZ
.text$mn:00002D8C ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00002D8C
.text$mn:00002D8C var_4           = dword ptr -4
.text$mn:00002D8C
.text$mn:00002D8C                 push    ebp
.text$mn:00002D8D                 mov     ebp, esp
.text$mn:00002D8F                 push    ecx
.text$mn:00002D90                 mov     [ebp+var_4], ecx
.text$mn:00002D93                 mov     eax, [ebp+var_4]
.text$mn:00002D96                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00002D9C                 mov     eax, [ebp+var_4]
.text$mn:00002D9F                 mov     esp, ebp
.text$mn:00002DA1                 pop     ebp
.text$mn:00002DA2                 retn
.text$mn:00002DA2 ??0error_category@std@@QAE@XZ endp
.text$mn:00002DA2
.text$mn:00002DA2 ; ---------------------------------------------------------------------------
.text$mn:00002DA3                 align 4
.text$mn:00002DA3 _text$mn        ends
.text$mn:00002DA3
.text$mn:00002DA4 ; ===========================================================================
.text$mn:00002DA4
.text$mn:00002DA4 ; Segment type: Pure code
.text$mn:00002DA4 ; Segment permissions: Read/Execute
.text$mn:00002DA4 _text$mn        segment para public 'CODE' use32
.text$mn:00002DA4                 assume cs:_text$mn
.text$mn:00002DA4                 ;org 2DA4h
.text$mn:00002DA4 ; COMDAT (pick any)
.text$mn:00002DA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DA4
.text$mn:00002DA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DA4
.text$mn:00002DA4 ; Attributes: bp-based frame
.text$mn:00002DA4
.text$mn:00002DA4 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00002DA4                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00002DA4 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00002DA4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00002DA4                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00002DA4
.text$mn:00002DA4 var_4           = dword ptr -4
.text$mn:00002DA4 arg_0           = dword ptr  8
.text$mn:00002DA4 arg_4           = dword ptr  0Ch
.text$mn:00002DA4
.text$mn:00002DA4                 push    ebp
.text$mn:00002DA5                 mov     ebp, esp
.text$mn:00002DA7                 push    ecx
.text$mn:00002DA8                 mov     [ebp+var_4], ecx
.text$mn:00002DAB                 mov     eax, [ebp+var_4]
.text$mn:00002DAE                 mov     ecx, [ebp+arg_0]
.text$mn:00002DB1                 mov     [eax], ecx
.text$mn:00002DB3                 mov     edx, [ebp+var_4]
.text$mn:00002DB6                 mov     eax, [ebp+arg_4]
.text$mn:00002DB9                 mov     [edx+4], eax
.text$mn:00002DBC                 mov     eax, [ebp+var_4]
.text$mn:00002DBF                 mov     esp, ebp
.text$mn:00002DC1                 pop     ebp
.text$mn:00002DC2                 retn    8
.text$mn:00002DC2 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00002DC2
.text$mn:00002DC2 ; ---------------------------------------------------------------------------
.text$mn:00002DC5                 align 4
.text$mn:00002DC5 _text$mn        ends
.text$mn:00002DC5
.text$mn:00002DC8 ; ===========================================================================
.text$mn:00002DC8
.text$mn:00002DC8 ; Segment type: Pure code
.text$mn:00002DC8 ; Segment permissions: Read/Execute
.text$mn:00002DC8 _text$mn        segment para public 'CODE' use32
.text$mn:00002DC8                 assume cs:_text$mn
.text$mn:00002DC8                 ;org 2DC8h
.text$mn:00002DC8 ; COMDAT (pick any)
.text$mn:00002DC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DC8
.text$mn:00002DC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DC8
.text$mn:00002DC8 ; Attributes: bp-based frame
.text$mn:00002DC8
.text$mn:00002DC8 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00002DC8                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00002DC8 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00002DC8                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00002DC8
.text$mn:00002DC8 var_4           = dword ptr -4
.text$mn:00002DC8 arg_0           = dword ptr  8
.text$mn:00002DC8
.text$mn:00002DC8                 push    ebp
.text$mn:00002DC9                 mov     ebp, esp
.text$mn:00002DCB                 push    ecx
.text$mn:00002DCC                 mov     [ebp+var_4], ecx
.text$mn:00002DCF                 mov     eax, [ebp+var_4]
.text$mn:00002DD2                 mov     ecx, [ebp+arg_0]
.text$mn:00002DD5                 mov     [eax], ecx
.text$mn:00002DD7                 mov     eax, [ebp+var_4]
.text$mn:00002DDA                 mov     esp, ebp
.text$mn:00002DDC                 pop     ebp
.text$mn:00002DDD                 retn    4
.text$mn:00002DDD ??0id@locale@std@@QAE@I@Z endp
.text$mn:00002DDD
.text$mn:00002DDD _text$mn        ends
.text$mn:00002DDD
.text$mn:00002DE0 ; ===========================================================================
.text$mn:00002DE0
.text$mn:00002DE0 ; Segment type: Pure code
.text$mn:00002DE0 ; Segment permissions: Read/Execute
.text$mn:00002DE0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DE0                 assume cs:_text$mn
.text$mn:00002DE0                 ;org 2DE0h
.text$mn:00002DE0 ; COMDAT (pick any)
.text$mn:00002DE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DE0
.text$mn:00002DE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DE0
.text$mn:00002DE0 ; Attributes: bp-based frame
.text$mn:00002DE0
.text$mn:00002DE0 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:00002DE0                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00002DE0 ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:00002DE0                                         ; DATA XREF: .xdata$x:00004894o
.text$mn:00002DE0
.text$mn:00002DE0 var_10          = dword ptr -10h
.text$mn:00002DE0 var_C           = dword ptr -0Ch
.text$mn:00002DE0 var_4           = dword ptr -4
.text$mn:00002DE0 arg_0           = dword ptr  8
.text$mn:00002DE0
.text$mn:00002DE0                 push    ebp
.text$mn:00002DE1                 mov     ebp, esp
.text$mn:00002DE3                 push    0FFFFFFFFh
.text$mn:00002DE5                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00002DEA                 mov     eax, large fs:0
.text$mn:00002DF0                 push    eax
.text$mn:00002DF1                 push    ecx
.text$mn:00002DF2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002DF7                 xor     eax, ebp
.text$mn:00002DF9                 push    eax
.text$mn:00002DFA                 lea     eax, [ebp+var_C]
.text$mn:00002DFD                 mov     large fs:0, eax
.text$mn:00002E03                 mov     [ebp+var_10], ecx
.text$mn:00002E06                 mov     eax, [ebp+arg_0]
.text$mn:00002E09                 push    eax             ; struct std::exception *
.text$mn:00002E0A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002E0D                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:00002E12                 mov     [ebp+var_4], 0
.text$mn:00002E19                 mov     ecx, [ebp+var_10]
.text$mn:00002E1C                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00002E22                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E29                 mov     eax, [ebp+var_10]
.text$mn:00002E2C                 mov     ecx, [ebp+var_C]
.text$mn:00002E2F                 mov     large fs:0, ecx
.text$mn:00002E36                 pop     ecx
.text$mn:00002E37                 mov     esp, ebp
.text$mn:00002E39                 pop     ebp
.text$mn:00002E3A                 retn    4
.text$mn:00002E3A ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:00002E3A
.text$mn:00002E3A ; ---------------------------------------------------------------------------
.text$mn:00002E3D                 align 10h
.text$mn:00002E3D _text$mn        ends
.text$mn:00002E3D
.text$x:00002E40 ; ===========================================================================
.text$x:00002E40
.text$x:00002E40 ; Segment type: Pure code
.text$x:00002E40 ; Segment permissions: Read/Execute
.text$x:00002E40 _text$x         segment para public 'CODE' use32
.text$x:00002E40                 assume cs:_text$x
.text$x:00002E40                 ;org 2E40h
.text$x:00002E40 ; COMDAT (pick associative to section at 2DE0)
.text$x:00002E40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002E40
.text$x:00002E40 ; =============== S U B R O U T I N E =======================================
.text$x:00002E40
.text$x:00002E40
.text$x:00002E40 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:00002E40                                         ; DATA XREF: .xdata$x:00004628o
.text$x:00002E40                 mov     ecx, [ebp-10h]  ; this
.text$x:00002E43                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00002E43 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:00002E43
.text$x:00002E48
.text$x:00002E48 ; =============== S U B R O U T I N E =======================================
.text$x:00002E48
.text$x:00002E48
.text$x:00002E48 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:00002E48                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:00002E48
.text$x:00002E48 arg_4           = dword ptr  8
.text$x:00002E48
.text$x:00002E48                 mov     edx, [esp+arg_4]
.text$x:00002E4C                 lea     eax, [edx+0Ch]
.text$x:00002E4F                 mov     ecx, [edx-8]
.text$x:00002E52                 xor     ecx, eax
.text$x:00002E54                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002E59                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:00002E5E                 jmp     ___CxxFrameHandler3
.text$x:00002E5E __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:00002E5E
.text$x:00002E5E ; ---------------------------------------------------------------------------
.text$x:00002E63                 align 4
.text$x:00002E63 _text$x         ends
.text$x:00002E63
.text$mn:00002E64 ; ===========================================================================
.text$mn:00002E64
.text$mn:00002E64 ; Segment type: Pure code
.text$mn:00002E64 ; Segment permissions: Read/Execute
.text$mn:00002E64 _text$mn        segment para public 'CODE' use32
.text$mn:00002E64                 assume cs:_text$mn
.text$mn:00002E64                 ;org 2E64h
.text$mn:00002E64 ; COMDAT (pick any)
.text$mn:00002E64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E64
.text$mn:00002E64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E64
.text$mn:00002E64 ; Attributes: bp-based frame
.text$mn:00002E64
.text$mn:00002E64 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:00002E64                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:00002E64 ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:00002E64                                         ; CODE XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+F8p
.text$mn:00002E64                                         ; TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+123p ...
.text$mn:00002E64
.text$mn:00002E64 var_10          = dword ptr -10h
.text$mn:00002E64 var_C           = dword ptr -0Ch
.text$mn:00002E64 var_4           = dword ptr -4
.text$mn:00002E64 arg_0           = dword ptr  8
.text$mn:00002E64
.text$mn:00002E64                 push    ebp
.text$mn:00002E65                 mov     ebp, esp
.text$mn:00002E67                 push    0FFFFFFFFh
.text$mn:00002E69                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:00002E6E                 mov     eax, large fs:0
.text$mn:00002E74                 push    eax
.text$mn:00002E75                 push    ecx
.text$mn:00002E76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002E7B                 xor     eax, ebp
.text$mn:00002E7D                 push    eax
.text$mn:00002E7E                 lea     eax, [ebp+var_C]
.text$mn:00002E81                 mov     large fs:0, eax
.text$mn:00002E87                 mov     [ebp+var_10], ecx
.text$mn:00002E8A                 lea     eax, [ebp+arg_0]
.text$mn:00002E8D                 push    eax             ; char **
.text$mn:00002E8E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002E91                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:00002E96                 mov     [ebp+var_4], 0
.text$mn:00002E9D                 mov     ecx, [ebp+var_10]
.text$mn:00002EA0                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00002EA6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002EAD                 mov     eax, [ebp+var_10]
.text$mn:00002EB0                 mov     ecx, [ebp+var_C]
.text$mn:00002EB3                 mov     large fs:0, ecx
.text$mn:00002EBA                 pop     ecx
.text$mn:00002EBB                 mov     esp, ebp
.text$mn:00002EBD                 pop     ebp
.text$mn:00002EBE                 retn    4
.text$mn:00002EBE ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:00002EBE
.text$mn:00002EBE ; ---------------------------------------------------------------------------
.text$mn:00002EC1                 align 4
.text$mn:00002EC1 _text$mn        ends
.text$mn:00002EC1
.text$x:00002EC4 ; ===========================================================================
.text$x:00002EC4
.text$x:00002EC4 ; Segment type: Pure code
.text$x:00002EC4 ; Segment permissions: Read/Execute
.text$x:00002EC4 _text$x         segment para public 'CODE' use32
.text$x:00002EC4                 assume cs:_text$x
.text$x:00002EC4                 ;org 2EC4h
.text$x:00002EC4 ; COMDAT (pick associative to section at 2E64)
.text$x:00002EC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002EC4
.text$x:00002EC4 ; =============== S U B R O U T I N E =======================================
.text$x:00002EC4
.text$x:00002EC4
.text$x:00002EC4 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:00002EC4                                         ; DATA XREF: .xdata$x:000045D0o
.text$x:00002EC4                 mov     ecx, [ebp-10h]  ; this
.text$x:00002EC7                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00002EC7 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:00002EC7
.text$x:00002ECC
.text$x:00002ECC ; =============== S U B R O U T I N E =======================================
.text$x:00002ECC
.text$x:00002ECC
.text$x:00002ECC __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:00002ECC                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:00002ECC
.text$x:00002ECC arg_4           = dword ptr  8
.text$x:00002ECC
.text$x:00002ECC                 mov     edx, [esp+arg_4]
.text$x:00002ED0                 lea     eax, [edx+0Ch]
.text$x:00002ED3                 mov     ecx, [edx-8]
.text$x:00002ED6                 xor     ecx, eax
.text$x:00002ED8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002EDD                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:00002EE2                 jmp     ___CxxFrameHandler3
.text$x:00002EE2 __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:00002EE2
.text$x:00002EE2 ; ---------------------------------------------------------------------------
.text$x:00002EE7                 align 4
.text$x:00002EE7 _text$x         ends
.text$x:00002EE7
.text$mn:00002EE8 ; ===========================================================================
.text$mn:00002EE8
.text$mn:00002EE8 ; Segment type: Pure code
.text$mn:00002EE8 ; Segment permissions: Read/Execute
.text$mn:00002EE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002EE8                 assume cs:_text$mn
.text$mn:00002EE8                 ;org 2EE8h
.text$mn:00002EE8 ; COMDAT (pick any)
.text$mn:00002EE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002EE8
.text$mn:00002EE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EE8
.text$mn:00002EE8 ; Attributes: bp-based frame
.text$mn:00002EE8
.text$mn:00002EE8 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00002EE8                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00002EE8 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00002EE8                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00002EE8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00002EE8
.text$mn:00002EE8 var_10          = dword ptr -10h
.text$mn:00002EE8 var_C           = dword ptr -0Ch
.text$mn:00002EE8 var_4           = dword ptr -4
.text$mn:00002EE8
.text$mn:00002EE8                 push    ebp
.text$mn:00002EE9                 mov     ebp, esp
.text$mn:00002EEB                 push    0FFFFFFFFh
.text$mn:00002EED                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00002EF2                 mov     eax, large fs:0
.text$mn:00002EF8                 push    eax
.text$mn:00002EF9                 push    ecx
.text$mn:00002EFA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002EFF                 xor     eax, ebp
.text$mn:00002F01                 push    eax
.text$mn:00002F02                 lea     eax, [ebp+var_C]
.text$mn:00002F05                 mov     large fs:0, eax
.text$mn:00002F0B                 mov     [ebp+var_10], ecx
.text$mn:00002F0E                 mov     [ebp+var_4], 0
.text$mn:00002F15                 mov     ecx, [ebp+var_10]
.text$mn:00002F18                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00002F1D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002F24                 mov     ecx, [ebp+var_10]
.text$mn:00002F27                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00002F2C                 mov     ecx, [ebp+var_C]
.text$mn:00002F2F                 mov     large fs:0, ecx
.text$mn:00002F36                 pop     ecx
.text$mn:00002F37                 mov     esp, ebp
.text$mn:00002F39                 pop     ebp
.text$mn:00002F3A                 retn
.text$mn:00002F3A ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00002F3A
.text$mn:00002F3A ; ---------------------------------------------------------------------------
.text$mn:00002F3B                 align 4
.text$mn:00002F3B _text$mn        ends
.text$mn:00002F3B
.text$x:00002F3C ; ===========================================================================
.text$x:00002F3C
.text$x:00002F3C ; Segment type: Pure code
.text$x:00002F3C ; Segment permissions: Read/Execute
.text$x:00002F3C _text$x         segment para public 'CODE' use32
.text$x:00002F3C                 assume cs:_text$x
.text$x:00002F3C                 ;org 2F3Ch
.text$x:00002F3C ; COMDAT (pick associative to section at 2EE8)
.text$x:00002F3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002F3C
.text$x:00002F3C ; =============== S U B R O U T I N E =======================================
.text$x:00002F3C
.text$x:00002F3C
.text$x:00002F3C __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002F3C                                         ; DATA XREF: .xdata$x:000044C0o
.text$x:00002F3C                 mov     ecx, [ebp-10h]
.text$x:00002F3F                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00002F3F __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002F3F
.text$x:00002F44
.text$x:00002F44 ; =============== S U B R O U T I N E =======================================
.text$x:00002F44
.text$x:00002F44
.text$x:00002F44 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00002F44                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00002F44
.text$x:00002F44 arg_4           = dword ptr  8
.text$x:00002F44
.text$x:00002F44                 mov     edx, [esp+arg_4]
.text$x:00002F48                 lea     eax, [edx+0Ch]
.text$x:00002F4B                 mov     ecx, [edx-8]
.text$x:00002F4E                 xor     ecx, eax
.text$x:00002F50                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F55                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00002F5A                 jmp     ___CxxFrameHandler3
.text$x:00002F5A __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00002F5A
.text$x:00002F5A ; ---------------------------------------------------------------------------
.text$x:00002F5F                 align 10h
.text$x:00002F5F _text$x         ends
.text$x:00002F5F
.text$mn:00002F60 ; ===========================================================================
.text$mn:00002F60
.text$mn:00002F60 ; Segment type: Pure code
.text$mn:00002F60 ; Segment permissions: Read/Execute
.text$mn:00002F60 _text$mn        segment para public 'CODE' use32
.text$mn:00002F60                 assume cs:_text$mn
.text$mn:00002F60                 ;org 2F60h
.text$mn:00002F60 ; COMDAT (pick any)
.text$mn:00002F60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F60
.text$mn:00002F60 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F60
.text$mn:00002F60 ; Attributes: bp-based frame
.text$mn:00002F60
.text$mn:00002F60 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00002F60                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002F60 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00002F60                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00002F60                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00002F60
.text$mn:00002F60 var_10          = dword ptr -10h
.text$mn:00002F60 var_C           = dword ptr -0Ch
.text$mn:00002F60 var_4           = dword ptr -4
.text$mn:00002F60
.text$mn:00002F60                 push    ebp
.text$mn:00002F61                 mov     ebp, esp
.text$mn:00002F63                 push    0FFFFFFFFh
.text$mn:00002F65                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002F6A                 mov     eax, large fs:0
.text$mn:00002F70                 push    eax
.text$mn:00002F71                 push    ecx
.text$mn:00002F72                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002F77                 xor     eax, ebp
.text$mn:00002F79                 push    eax
.text$mn:00002F7A                 lea     eax, [ebp+var_C]
.text$mn:00002F7D                 mov     large fs:0, eax
.text$mn:00002F83                 mov     [ebp+var_10], ecx
.text$mn:00002F86                 mov     [ebp+var_4], 0
.text$mn:00002F8D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002F94                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002F97                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00002F9C                 mov     ecx, [ebp+var_C]
.text$mn:00002F9F                 mov     large fs:0, ecx
.text$mn:00002FA6                 pop     ecx
.text$mn:00002FA7                 mov     esp, ebp
.text$mn:00002FA9                 pop     ebp
.text$mn:00002FAA                 retn
.text$mn:00002FAA ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00002FAA
.text$mn:00002FAA ; ---------------------------------------------------------------------------
.text$mn:00002FAB                 align 4
.text$mn:00002FAB _text$mn        ends
.text$mn:00002FAB
.text$x:00002FAC ; ===========================================================================
.text$x:00002FAC
.text$x:00002FAC ; Segment type: Pure code
.text$x:00002FAC ; Segment permissions: Read/Execute
.text$x:00002FAC _text$x         segment para public 'CODE' use32
.text$x:00002FAC                 assume cs:_text$x
.text$x:00002FAC                 ;org 2FACh
.text$x:00002FAC ; COMDAT (pick associative to section at 2F60)
.text$x:00002FAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002FAC
.text$x:00002FAC ; =============== S U B R O U T I N E =======================================
.text$x:00002FAC
.text$x:00002FAC
.text$x:00002FAC __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00002FAC                                         ; DATA XREF: .xdata$x:00004468o
.text$x:00002FAC                 mov     ecx, [ebp-10h]  ; this
.text$x:00002FAF                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002FAF __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00002FAF
.text$x:00002FB4
.text$x:00002FB4 ; =============== S U B R O U T I N E =======================================
.text$x:00002FB4
.text$x:00002FB4
.text$x:00002FB4 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00002FB4                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00002FB4
.text$x:00002FB4 arg_4           = dword ptr  8
.text$x:00002FB4
.text$x:00002FB4                 mov     edx, [esp+arg_4]
.text$x:00002FB8                 lea     eax, [edx+0Ch]
.text$x:00002FBB                 mov     ecx, [edx-8]
.text$x:00002FBE                 xor     ecx, eax
.text$x:00002FC0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002FC5                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00002FCA                 jmp     ___CxxFrameHandler3
.text$x:00002FCA __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00002FCA
.text$x:00002FCA ; ---------------------------------------------------------------------------
.text$x:00002FCF                 align 10h
.text$x:00002FCF _text$x         ends
.text$x:00002FCF
.text$mn:00002FD0 ; ===========================================================================
.text$mn:00002FD0
.text$mn:00002FD0 ; Segment type: Pure code
.text$mn:00002FD0 ; Segment permissions: Read/Execute
.text$mn:00002FD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002FD0                 assume cs:_text$mn
.text$mn:00002FD0                 ;org 2FD0h
.text$mn:00002FD0 ; COMDAT (pick any)
.text$mn:00002FD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FD0
.text$mn:00002FD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FD0
.text$mn:00002FD0 ; Attributes: bp-based frame
.text$mn:00002FD0
.text$mn:00002FD0 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00002FD0                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00002FD0 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00002FD0                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00002FD0                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00002FD0
.text$mn:00002FD0 var_10          = dword ptr -10h
.text$mn:00002FD0 var_C           = dword ptr -0Ch
.text$mn:00002FD0 var_4           = dword ptr -4
.text$mn:00002FD0
.text$mn:00002FD0                 push    ebp
.text$mn:00002FD1                 mov     ebp, esp
.text$mn:00002FD3                 push    0FFFFFFFFh
.text$mn:00002FD5                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00002FDA                 mov     eax, large fs:0
.text$mn:00002FE0                 push    eax
.text$mn:00002FE1                 push    ecx
.text$mn:00002FE2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002FE7                 xor     eax, ebp
.text$mn:00002FE9                 push    eax
.text$mn:00002FEA                 lea     eax, [ebp+var_C]
.text$mn:00002FED                 mov     large fs:0, eax
.text$mn:00002FF3                 mov     [ebp+var_10], ecx
.text$mn:00002FF6                 mov     [ebp+var_4], 0
.text$mn:00002FFD                 push    0               ; Size
.text$mn:00002FFF                 push    1               ; char
.text$mn:00003001                 mov     ecx, [ebp+var_10]
.text$mn:00003004                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003009                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003010                 mov     ecx, [ebp+var_10]
.text$mn:00003013                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00003018                 mov     ecx, [ebp+var_C]
.text$mn:0000301B                 mov     large fs:0, ecx
.text$mn:00003022                 pop     ecx
.text$mn:00003023                 mov     esp, ebp
.text$mn:00003025                 pop     ebp
.text$mn:00003026                 retn
.text$mn:00003026 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00003026
.text$mn:00003026 ; ---------------------------------------------------------------------------
.text$mn:00003027                 align 4
.text$mn:00003027 _text$mn        ends
.text$mn:00003027
.text$x:00003028 ; ===========================================================================
.text$x:00003028
.text$x:00003028 ; Segment type: Pure code
.text$x:00003028 ; Segment permissions: Read/Execute
.text$x:00003028 _text$x         segment para public 'CODE' use32
.text$x:00003028                 assume cs:_text$x
.text$x:00003028                 ;org 3028h
.text$x:00003028 ; COMDAT (pick associative to section at 2FD0)
.text$x:00003028                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003028
.text$x:00003028 ; =============== S U B R O U T I N E =======================================
.text$x:00003028
.text$x:00003028
.text$x:00003028 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00003028                                         ; DATA XREF: .xdata$x:00004518o
.text$x:00003028                 mov     ecx, [ebp-10h]
.text$x:0000302B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000302B __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000302B
.text$x:00003030
.text$x:00003030 ; =============== S U B R O U T I N E =======================================
.text$x:00003030
.text$x:00003030
.text$x:00003030 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00003030                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00003030
.text$x:00003030 arg_4           = dword ptr  8
.text$x:00003030
.text$x:00003030                 mov     edx, [esp+arg_4]
.text$x:00003034                 lea     eax, [edx+0Ch]
.text$x:00003037                 mov     ecx, [edx-8]
.text$x:0000303A                 xor     ecx, eax
.text$x:0000303C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003041                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00003046                 jmp     ___CxxFrameHandler3
.text$x:00003046 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00003046
.text$x:00003046 ; ---------------------------------------------------------------------------
.text$x:0000304B                 align 4
.text$x:0000304B _text$x         ends
.text$x:0000304B
.text$mn:0000304C ; ===========================================================================
.text$mn:0000304C
.text$mn:0000304C ; Segment type: Pure code
.text$mn:0000304C ; Segment permissions: Read/Execute
.text$mn:0000304C _text$mn        segment para public 'CODE' use32
.text$mn:0000304C                 assume cs:_text$mn
.text$mn:0000304C                 ;org 304Ch
.text$mn:0000304C ; COMDAT (pick any)
.text$mn:0000304C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000304C
.text$mn:0000304C ; =============== S U B R O U T I N E =======================================
.text$mn:0000304C
.text$mn:0000304C ; Attributes: bp-based frame
.text$mn:0000304C
.text$mn:0000304C ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:0000304C                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:0000304C ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:0000304C                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:0000304C                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:0000304C
.text$mn:0000304C var_4           = dword ptr -4
.text$mn:0000304C
.text$mn:0000304C                 push    ebp
.text$mn:0000304D                 mov     ebp, esp
.text$mn:0000304F                 push    ecx
.text$mn:00003050                 mov     [ebp+var_4], ecx
.text$mn:00003053                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003056                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000305B                 mov     esp, ebp
.text$mn:0000305D                 pop     ebp
.text$mn:0000305E                 retn
.text$mn:0000305E ??1_Container_base12@std@@QAE@XZ endp
.text$mn:0000305E
.text$mn:0000305E ; ---------------------------------------------------------------------------
.text$mn:0000305F                 align 10h
.text$mn:0000305F _text$mn        ends
.text$mn:0000305F
.text$mn:00003060 ; ===========================================================================
.text$mn:00003060
.text$mn:00003060 ; Segment type: Pure code
.text$mn:00003060 ; Segment permissions: Read/Execute
.text$mn:00003060 _text$mn        segment para public 'CODE' use32
.text$mn:00003060                 assume cs:_text$mn
.text$mn:00003060                 ;org 3060h
.text$mn:00003060 ; COMDAT (pick any)
.text$mn:00003060                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003060
.text$mn:00003060 ; =============== S U B R O U T I N E =======================================
.text$mn:00003060
.text$mn:00003060 ; Attributes: bp-based frame
.text$mn:00003060
.text$mn:00003060 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00003060                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00003060 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00003060                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00003060                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00003060
.text$mn:00003060 var_10          = dword ptr -10h
.text$mn:00003060 var_C           = dword ptr -0Ch
.text$mn:00003060 var_4           = dword ptr -4
.text$mn:00003060
.text$mn:00003060                 push    ebp
.text$mn:00003061                 mov     ebp, esp
.text$mn:00003063                 push    0FFFFFFFFh
.text$mn:00003065                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000306A                 mov     eax, large fs:0
.text$mn:00003070                 push    eax
.text$mn:00003071                 push    ecx
.text$mn:00003072                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003077                 xor     eax, ebp
.text$mn:00003079                 push    eax
.text$mn:0000307A                 lea     eax, [ebp+var_C]
.text$mn:0000307D                 mov     large fs:0, eax
.text$mn:00003083                 mov     [ebp+var_10], ecx
.text$mn:00003086                 mov     [ebp+var_4], 0
.text$mn:0000308D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003094                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003097                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000309C                 mov     ecx, [ebp+var_C]
.text$mn:0000309F                 mov     large fs:0, ecx
.text$mn:000030A6                 pop     ecx
.text$mn:000030A7                 mov     esp, ebp
.text$mn:000030A9                 pop     ebp
.text$mn:000030AA                 retn
.text$mn:000030AA ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:000030AA
.text$mn:000030AA ; ---------------------------------------------------------------------------
.text$mn:000030AB                 align 4
.text$mn:000030AB _text$mn        ends
.text$mn:000030AB
.text$x:000030AC ; ===========================================================================
.text$x:000030AC
.text$x:000030AC ; Segment type: Pure code
.text$x:000030AC ; Segment permissions: Read/Execute
.text$x:000030AC _text$x         segment para public 'CODE' use32
.text$x:000030AC                 assume cs:_text$x
.text$x:000030AC                 ;org 30ACh
.text$x:000030AC ; COMDAT (pick associative to section at 3060)
.text$x:000030AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000030AC
.text$x:000030AC ; =============== S U B R O U T I N E =======================================
.text$x:000030AC
.text$x:000030AC
.text$x:000030AC __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:000030AC                                         ; DATA XREF: .xdata$x:000046ACo
.text$x:000030AC                 mov     ecx, [ebp-10h]  ; this
.text$x:000030AF                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000030AF __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:000030AF
.text$x:000030B4
.text$x:000030B4 ; =============== S U B R O U T I N E =======================================
.text$x:000030B4
.text$x:000030B4
.text$x:000030B4 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:000030B4                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:000030B4
.text$x:000030B4 arg_4           = dword ptr  8
.text$x:000030B4
.text$x:000030B4                 mov     edx, [esp+arg_4]
.text$x:000030B8                 lea     eax, [edx+0Ch]
.text$x:000030BB                 mov     ecx, [edx-8]
.text$x:000030BE                 xor     ecx, eax
.text$x:000030C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000030C5                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:000030CA                 jmp     ___CxxFrameHandler3
.text$x:000030CA __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:000030CA
.text$x:000030CA ; ---------------------------------------------------------------------------
.text$x:000030CF                 align 10h
.text$x:000030CF _text$x         ends
.text$x:000030CF
.text$mn:000030D0 ; ===========================================================================
.text$mn:000030D0
.text$mn:000030D0 ; Segment type: Pure code
.text$mn:000030D0 ; Segment permissions: Read/Execute
.text$mn:000030D0 _text$mn        segment para public 'CODE' use32
.text$mn:000030D0                 assume cs:_text$mn
.text$mn:000030D0                 ;org 30D0h
.text$mn:000030D0 ; COMDAT (pick any)
.text$mn:000030D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030D0
.text$mn:000030D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000030D0
.text$mn:000030D0 ; Attributes: bp-based frame
.text$mn:000030D0
.text$mn:000030D0 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000030D0                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000030D0 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:000030D0                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000030D0                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000030D0
.text$mn:000030D0 var_10          = dword ptr -10h
.text$mn:000030D0 var_C           = dword ptr -0Ch
.text$mn:000030D0 var_4           = dword ptr -4
.text$mn:000030D0
.text$mn:000030D0                 push    ebp
.text$mn:000030D1                 mov     ebp, esp
.text$mn:000030D3                 push    0FFFFFFFFh
.text$mn:000030D5                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000030DA                 mov     eax, large fs:0
.text$mn:000030E0                 push    eax
.text$mn:000030E1                 push    ecx
.text$mn:000030E2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000030E7                 xor     eax, ebp
.text$mn:000030E9                 push    eax
.text$mn:000030EA                 lea     eax, [ebp+var_C]
.text$mn:000030ED                 mov     large fs:0, eax
.text$mn:000030F3                 mov     [ebp+var_10], ecx
.text$mn:000030F6                 mov     [ebp+var_4], 0
.text$mn:000030FD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003104                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003107                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000310C                 mov     ecx, [ebp+var_C]
.text$mn:0000310F                 mov     large fs:0, ecx
.text$mn:00003116                 pop     ecx
.text$mn:00003117                 mov     esp, ebp
.text$mn:00003119                 pop     ebp
.text$mn:0000311A                 retn
.text$mn:0000311A ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:0000311A
.text$mn:0000311A ; ---------------------------------------------------------------------------
.text$mn:0000311B                 align 4
.text$mn:0000311B _text$mn        ends
.text$mn:0000311B
.text$x:0000311C ; ===========================================================================
.text$x:0000311C
.text$x:0000311C ; Segment type: Pure code
.text$x:0000311C ; Segment permissions: Read/Execute
.text$x:0000311C _text$x         segment para public 'CODE' use32
.text$x:0000311C                 assume cs:_text$x
.text$x:0000311C                 ;org 311Ch
.text$x:0000311C ; COMDAT (pick associative to section at 30D0)
.text$x:0000311C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000311C
.text$x:0000311C ; =============== S U B R O U T I N E =======================================
.text$x:0000311C
.text$x:0000311C
.text$x:0000311C __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:0000311C                                         ; DATA XREF: .xdata$x:00004730o
.text$x:0000311C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000311F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000311F __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:0000311F
.text$x:00003124
.text$x:00003124 ; =============== S U B R O U T I N E =======================================
.text$x:00003124
.text$x:00003124
.text$x:00003124 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00003124                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00003124
.text$x:00003124 arg_4           = dword ptr  8
.text$x:00003124
.text$x:00003124                 mov     edx, [esp+arg_4]
.text$x:00003128                 lea     eax, [edx+0Ch]
.text$x:0000312B                 mov     ecx, [edx-8]
.text$x:0000312E                 xor     ecx, eax
.text$x:00003130                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003135                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:0000313A                 jmp     ___CxxFrameHandler3
.text$x:0000313A __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:0000313A
.text$x:0000313A ; ---------------------------------------------------------------------------
.text$x:0000313F                 align 10h
.text$x:0000313F _text$x         ends
.text$x:0000313F
.text$mn:00003140 ; ===========================================================================
.text$mn:00003140
.text$mn:00003140 ; Segment type: Pure code
.text$mn:00003140 ; Segment permissions: Read/Execute
.text$mn:00003140 _text$mn        segment para public 'CODE' use32
.text$mn:00003140                 assume cs:_text$mn
.text$mn:00003140                 ;org 3140h
.text$mn:00003140 ; COMDAT (pick any)
.text$mn:00003140                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003140
.text$mn:00003140 ; =============== S U B R O U T I N E =======================================
.text$mn:00003140
.text$mn:00003140 ; Attributes: bp-based frame
.text$mn:00003140
.text$mn:00003140 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00003140                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00003140 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00003140                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00003140                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00003140
.text$mn:00003140 var_10          = dword ptr -10h
.text$mn:00003140 var_C           = dword ptr -0Ch
.text$mn:00003140 var_4           = dword ptr -4
.text$mn:00003140
.text$mn:00003140                 push    ebp
.text$mn:00003141                 mov     ebp, esp
.text$mn:00003143                 push    0FFFFFFFFh
.text$mn:00003145                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:0000314A                 mov     eax, large fs:0
.text$mn:00003150                 push    eax
.text$mn:00003151                 push    ecx
.text$mn:00003152                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003157                 xor     eax, ebp
.text$mn:00003159                 push    eax
.text$mn:0000315A                 lea     eax, [ebp+var_C]
.text$mn:0000315D                 mov     large fs:0, eax
.text$mn:00003163                 mov     [ebp+var_10], ecx
.text$mn:00003166                 mov     [ebp+var_4], 0
.text$mn:0000316D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003174                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003177                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000317C                 mov     ecx, [ebp+var_C]
.text$mn:0000317F                 mov     large fs:0, ecx
.text$mn:00003186                 pop     ecx
.text$mn:00003187                 mov     esp, ebp
.text$mn:00003189                 pop     ebp
.text$mn:0000318A                 retn
.text$mn:0000318A ??1_System_error_category@std@@UAE@XZ endp
.text$mn:0000318A
.text$mn:0000318A ; ---------------------------------------------------------------------------
.text$mn:0000318B                 align 4
.text$mn:0000318B _text$mn        ends
.text$mn:0000318B
.text$x:0000318C ; ===========================================================================
.text$x:0000318C
.text$x:0000318C ; Segment type: Pure code
.text$x:0000318C ; Segment permissions: Read/Execute
.text$x:0000318C _text$x         segment para public 'CODE' use32
.text$x:0000318C                 assume cs:_text$x
.text$x:0000318C                 ;org 318Ch
.text$x:0000318C ; COMDAT (pick associative to section at 3140)
.text$x:0000318C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000318C
.text$x:0000318C ; =============== S U B R O U T I N E =======================================
.text$x:0000318C
.text$x:0000318C
.text$x:0000318C __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:0000318C                                         ; DATA XREF: .xdata$x:000047B4o
.text$x:0000318C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000318F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000318F __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000318F
.text$x:00003194
.text$x:00003194 ; =============== S U B R O U T I N E =======================================
.text$x:00003194
.text$x:00003194
.text$x:00003194 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00003194                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00003194
.text$x:00003194 arg_4           = dword ptr  8
.text$x:00003194
.text$x:00003194                 mov     edx, [esp+arg_4]
.text$x:00003198                 lea     eax, [edx+0Ch]
.text$x:0000319B                 mov     ecx, [edx-8]
.text$x:0000319E                 xor     ecx, eax
.text$x:000031A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000031A5                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:000031AA                 jmp     ___CxxFrameHandler3
.text$x:000031AA __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:000031AA
.text$x:000031AA ; ---------------------------------------------------------------------------
.text$x:000031AF                 align 10h
.text$x:000031AF _text$x         ends
.text$x:000031AF
.text$mn:000031B0 ; ===========================================================================
.text$mn:000031B0
.text$mn:000031B0 ; Segment type: Pure code
.text$mn:000031B0 ; Segment permissions: Read/Execute
.text$mn:000031B0 _text$mn        segment para public 'CODE' use32
.text$mn:000031B0                 assume cs:_text$mn
.text$mn:000031B0                 ;org 31B0h
.text$mn:000031B0 ; COMDAT (pick any)
.text$mn:000031B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031B0
.text$mn:000031B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000031B0
.text$mn:000031B0 ; Attributes: bp-based frame
.text$mn:000031B0
.text$mn:000031B0 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:000031B0                 public ??1error_category@std@@UAE@XZ
.text$mn:000031B0 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:000031B0                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:000031B0
.text$mn:000031B0 var_4           = dword ptr -4
.text$mn:000031B0
.text$mn:000031B0                 push    ebp
.text$mn:000031B1                 mov     ebp, esp
.text$mn:000031B3                 push    ecx
.text$mn:000031B4                 mov     [ebp+var_4], ecx
.text$mn:000031B7                 mov     eax, [ebp+var_4]
.text$mn:000031BA                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000031C0                 mov     esp, ebp
.text$mn:000031C2                 pop     ebp
.text$mn:000031C3                 retn
.text$mn:000031C3 ??1error_category@std@@UAE@XZ endp
.text$mn:000031C3
.text$mn:000031C3 _text$mn        ends
.text$mn:000031C3
.text$mn:000031C4 ; ===========================================================================
.text$mn:000031C4
.text$mn:000031C4 ; Segment type: Pure code
.text$mn:000031C4 ; Segment permissions: Read/Execute
.text$mn:000031C4 _text$mn        segment para public 'CODE' use32
.text$mn:000031C4                 assume cs:_text$mn
.text$mn:000031C4                 ;org 31C4h
.text$mn:000031C4 ; COMDAT (pick any)
.text$mn:000031C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031C4
.text$mn:000031C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000031C4
.text$mn:000031C4 ; Attributes: bp-based frame
.text$mn:000031C4
.text$mn:000031C4 ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:000031C4                 public ??1runtime_error@std@@UAE@XZ
.text$mn:000031C4 ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+Ap
.text$mn:000031C4                                         ; DATA XREF: .xdata$x:00004844o
.text$mn:000031C4
.text$mn:000031C4 var_10          = dword ptr -10h
.text$mn:000031C4 var_C           = dword ptr -0Ch
.text$mn:000031C4 var_4           = dword ptr -4
.text$mn:000031C4
.text$mn:000031C4                 push    ebp
.text$mn:000031C5                 mov     ebp, esp
.text$mn:000031C7                 push    0FFFFFFFFh
.text$mn:000031C9                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:000031CE                 mov     eax, large fs:0
.text$mn:000031D4                 push    eax
.text$mn:000031D5                 push    ecx
.text$mn:000031D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000031DB                 xor     eax, ebp
.text$mn:000031DD                 push    eax
.text$mn:000031DE                 lea     eax, [ebp+var_C]
.text$mn:000031E1                 mov     large fs:0, eax
.text$mn:000031E7                 mov     [ebp+var_10], ecx
.text$mn:000031EA                 mov     [ebp+var_4], 0
.text$mn:000031F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000031F8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000031FB                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:00003200                 mov     ecx, [ebp+var_C]
.text$mn:00003203                 mov     large fs:0, ecx
.text$mn:0000320A                 pop     ecx
.text$mn:0000320B                 mov     esp, ebp
.text$mn:0000320D                 pop     ebp
.text$mn:0000320E                 retn
.text$mn:0000320E ??1runtime_error@std@@UAE@XZ endp
.text$mn:0000320E
.text$mn:0000320E ; ---------------------------------------------------------------------------
.text$mn:0000320F                 align 10h
.text$mn:0000320F _text$mn        ends
.text$mn:0000320F
.text$x:00003210 ; ===========================================================================
.text$x:00003210
.text$x:00003210 ; Segment type: Pure code
.text$x:00003210 ; Segment permissions: Read/Execute
.text$x:00003210 _text$x         segment para public 'CODE' use32
.text$x:00003210                 assume cs:_text$x
.text$x:00003210                 ;org 3210h
.text$x:00003210 ; COMDAT (pick associative to section at 31C4)
.text$x:00003210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003210
.text$x:00003210 ; =============== S U B R O U T I N E =======================================
.text$x:00003210
.text$x:00003210
.text$x:00003210 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:00003210                                         ; DATA XREF: .xdata$x:000045FCo
.text$x:00003210                 mov     ecx, [ebp-10h]  ; this
.text$x:00003213                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00003213 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:00003213
.text$x:00003218
.text$x:00003218 ; =============== S U B R O U T I N E =======================================
.text$x:00003218
.text$x:00003218
.text$x:00003218 __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:00003218                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:00003218
.text$x:00003218 arg_4           = dword ptr  8
.text$x:00003218
.text$x:00003218                 mov     edx, [esp+arg_4]
.text$x:0000321C                 lea     eax, [edx+0Ch]
.text$x:0000321F                 mov     ecx, [edx-8]
.text$x:00003222                 xor     ecx, eax
.text$x:00003224                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003229                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:0000322E                 jmp     ___CxxFrameHandler3
.text$x:0000322E __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:0000322E
.text$x:0000322E ; ---------------------------------------------------------------------------
.text$x:00003233                 align 4
.text$x:00003233 _text$x         ends
.text$x:00003233
.text$mn:00003234 ; ===========================================================================
.text$mn:00003234
.text$mn:00003234 ; Segment type: Pure code
.text$mn:00003234 ; Segment permissions: Read/Execute
.text$mn:00003234 _text$mn        segment para public 'CODE' use32
.text$mn:00003234                 assume cs:_text$mn
.text$mn:00003234                 ;org 3234h
.text$mn:00003234 ; COMDAT (pick any)
.text$mn:00003234                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003234
.text$mn:00003234 ; =============== S U B R O U T I N E =======================================
.text$mn:00003234
.text$mn:00003234 ; Attributes: bp-based frame
.text$mn:00003234
.text$mn:00003234 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00003234                 public ??2@YAPAXIPAX@Z
.text$mn:00003234 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00003234                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00003234
.text$mn:00003234 arg_4           = dword ptr  0Ch
.text$mn:00003234
.text$mn:00003234                 push    ebp
.text$mn:00003235                 mov     ebp, esp
.text$mn:00003237                 mov     eax, [ebp+arg_4]
.text$mn:0000323A                 pop     ebp
.text$mn:0000323B                 retn
.text$mn:0000323B ??2@YAPAXIPAX@Z endp
.text$mn:0000323B
.text$mn:0000323B _text$mn        ends
.text$mn:0000323B
.text$mn:0000323C ; ===========================================================================
.text$mn:0000323C
.text$mn:0000323C ; Segment type: Pure code
.text$mn:0000323C ; Segment permissions: Read/Execute
.text$mn:0000323C _text$mn        segment para public 'CODE' use32
.text$mn:0000323C                 assume cs:_text$mn
.text$mn:0000323C                 ;org 323Ch
.text$mn:0000323C ; COMDAT (pick any)
.text$mn:0000323C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000323C
.text$mn:0000323C ; =============== S U B R O U T I N E =======================================
.text$mn:0000323C
.text$mn:0000323C ; Attributes: bp-based frame
.text$mn:0000323C
.text$mn:0000323C ; void __cdecl operator delete(void *)
.text$mn:0000323C                 public ??3@YAXPAX0@Z
.text$mn:0000323C ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:0000323C                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:0000323C                 push    ebp
.text$mn:0000323D                 mov     ebp, esp
.text$mn:0000323F                 pop     ebp
.text$mn:00003240                 retn
.text$mn:00003240 ??3@YAXPAX0@Z   endp
.text$mn:00003240
.text$mn:00003240 ; ---------------------------------------------------------------------------
.text$mn:00003241                 align 4
.text$mn:00003241 _text$mn        ends
.text$mn:00003241
.text$mn:00003244 ; ===========================================================================
.text$mn:00003244
.text$mn:00003244 ; Segment type: Pure code
.text$mn:00003244 ; Segment permissions: Read/Execute
.text$mn:00003244 _text$mn        segment para public 'CODE' use32
.text$mn:00003244                 assume cs:_text$mn
.text$mn:00003244                 ;org 3244h
.text$mn:00003244 ; COMDAT (pick any)
.text$mn:00003244                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003244
.text$mn:00003244 ; =============== S U B R O U T I N E =======================================
.text$mn:00003244
.text$mn:00003244 ; Attributes: bp-based frame
.text$mn:00003244
.text$mn:00003244 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00003244                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00003244 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00003244                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00003244                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00003244
.text$mn:00003244 var_8           = dword ptr -8
.text$mn:00003244 var_4           = dword ptr -4
.text$mn:00003244 arg_0           = dword ptr  8
.text$mn:00003244
.text$mn:00003244                 push    ebp
.text$mn:00003245                 mov     ebp, esp
.text$mn:00003247                 sub     esp, 8
.text$mn:0000324A                 mov     [ebp+var_8], ecx
.text$mn:0000324D                 mov     eax, [ebp+var_8]
.text$mn:00003250                 cmp     eax, [ebp+arg_0]
.text$mn:00003253                 jnz     short loc_325E
.text$mn:00003255                 mov     [ebp+var_4], 1
.text$mn:0000325C                 jmp     short loc_3265
.text$mn:0000325E ; ---------------------------------------------------------------------------
.text$mn:0000325E
.text$mn:0000325E loc_325E:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:0000325E                 mov     [ebp+var_4], 0
.text$mn:00003265
.text$mn:00003265 loc_3265:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00003265                 mov     al, byte ptr [ebp+var_4]
.text$mn:00003268                 mov     esp, ebp
.text$mn:0000326A                 pop     ebp
.text$mn:0000326B                 retn    4
.text$mn:0000326B ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:0000326B
.text$mn:0000326B ; ---------------------------------------------------------------------------
.text$mn:0000326E                 align 10h
.text$mn:0000326E _text$mn        ends
.text$mn:0000326E
.text$mn:00003270 ; ===========================================================================
.text$mn:00003270
.text$mn:00003270 ; Segment type: Pure code
.text$mn:00003270 ; Segment permissions: Read/Execute
.text$mn:00003270 _text$mn        segment para public 'CODE' use32
.text$mn:00003270                 assume cs:_text$mn
.text$mn:00003270                 ;org 3270h
.text$mn:00003270 ; COMDAT (pick any)
.text$mn:00003270                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003270
.text$mn:00003270 ; =============== S U B R O U T I N E =======================================
.text$mn:00003270
.text$mn:00003270 ; Attributes: bp-based frame
.text$mn:00003270
.text$mn:00003270 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00003270                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00003270 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00003270                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00003270
.text$mn:00003270 var_8           = dword ptr -8
.text$mn:00003270 var_4           = dword ptr -4
.text$mn:00003270 arg_0           = dword ptr  8
.text$mn:00003270
.text$mn:00003270                 push    ebp
.text$mn:00003271                 mov     ebp, esp
.text$mn:00003273                 sub     esp, 8
.text$mn:00003276                 push    esi
.text$mn:00003277                 mov     [ebp+var_4], ecx
.text$mn:0000327A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000327D                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00003282                 push    eax
.text$mn:00003283                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003286                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000328B                 mov     ecx, eax
.text$mn:0000328D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00003292                 movzx   eax, al
.text$mn:00003295                 test    eax, eax
.text$mn:00003297                 jz      short loc_32B8
.text$mn:00003299                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000329C                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000032A1                 mov     esi, eax
.text$mn:000032A3                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000032A6                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000032AB                 cmp     esi, eax
.text$mn:000032AD                 jnz     short loc_32B8
.text$mn:000032AF                 mov     [ebp+var_8], 1
.text$mn:000032B6                 jmp     short loc_32BF
.text$mn:000032B8 ; ---------------------------------------------------------------------------
.text$mn:000032B8
.text$mn:000032B8 loc_32B8:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:000032B8                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:000032B8                 mov     [ebp+var_8], 0
.text$mn:000032BF
.text$mn:000032BF loc_32BF:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:000032BF                 mov     al, byte ptr [ebp+var_8]
.text$mn:000032C2                 pop     esi
.text$mn:000032C3                 mov     esp, ebp
.text$mn:000032C5                 pop     ebp
.text$mn:000032C6                 retn    4
.text$mn:000032C6 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:000032C6
.text$mn:000032C6 ; ---------------------------------------------------------------------------
.text$mn:000032C9                 align 4
.text$mn:000032C9 _text$mn        ends
.text$mn:000032C9
.text$mn:000032CC ; ===========================================================================
.text$mn:000032CC
.text$mn:000032CC ; Segment type: Pure code
.text$mn:000032CC ; Segment permissions: Read/Execute
.text$mn:000032CC _text$mn        segment para public 'CODE' use32
.text$mn:000032CC                 assume cs:_text$mn
.text$mn:000032CC                 ;org 32CCh
.text$mn:000032CC ; COMDAT (pick any)
.text$mn:000032CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032CC
.text$mn:000032CC ; =============== S U B R O U T I N E =======================================
.text$mn:000032CC
.text$mn:000032CC ; Attributes: bp-based frame
.text$mn:000032CC
.text$mn:000032CC ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000032CC                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:000032CC ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:000032CC
.text$mn:000032CC var_4           = dword ptr -4
.text$mn:000032CC arg_0           = dword ptr  8
.text$mn:000032CC
.text$mn:000032CC                 push    ebp
.text$mn:000032CD                 mov     ebp, esp
.text$mn:000032CF                 push    ecx
.text$mn:000032D0                 mov     [ebp+var_4], ecx
.text$mn:000032D3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000032D6                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000032DB                 mov     eax, [ebp+arg_0]
.text$mn:000032DE                 and     eax, 1
.text$mn:000032E1                 jz      short loc_32EF
.text$mn:000032E3                 mov     ecx, [ebp+var_4]
.text$mn:000032E6                 push    ecx             ; void *
.text$mn:000032E7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000032EC                 add     esp, 4
.text$mn:000032EF
.text$mn:000032EF loc_32EF:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000032EF                 mov     eax, [ebp+var_4]
.text$mn:000032F2                 mov     esp, ebp
.text$mn:000032F4                 pop     ebp
.text$mn:000032F5                 retn    4
.text$mn:000032F5 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:000032F5
.text$mn:000032F5 _text$mn        ends
.text$mn:000032F5
.text$mn:000032F8 ; ===========================================================================
.text$mn:000032F8
.text$mn:000032F8 ; Segment type: Pure code
.text$mn:000032F8 ; Segment permissions: Read/Execute
.text$mn:000032F8 _text$mn        segment para public 'CODE' use32
.text$mn:000032F8                 assume cs:_text$mn
.text$mn:000032F8                 ;org 32F8h
.text$mn:000032F8 ; COMDAT (pick any)
.text$mn:000032F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032F8
.text$mn:000032F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000032F8
.text$mn:000032F8 ; Attributes: bp-based frame
.text$mn:000032F8
.text$mn:000032F8 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000032F8                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:000032F8 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:000032F8
.text$mn:000032F8 var_4           = dword ptr -4
.text$mn:000032F8 arg_0           = dword ptr  8
.text$mn:000032F8
.text$mn:000032F8                 push    ebp
.text$mn:000032F9                 mov     ebp, esp
.text$mn:000032FB                 push    ecx
.text$mn:000032FC                 mov     [ebp+var_4], ecx
.text$mn:000032FF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003302                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00003307                 mov     eax, [ebp+arg_0]
.text$mn:0000330A                 and     eax, 1
.text$mn:0000330D                 jz      short loc_331B
.text$mn:0000330F                 mov     ecx, [ebp+var_4]
.text$mn:00003312                 push    ecx             ; void *
.text$mn:00003313                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003318                 add     esp, 4
.text$mn:0000331B
.text$mn:0000331B loc_331B:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000331B                 mov     eax, [ebp+var_4]
.text$mn:0000331E                 mov     esp, ebp
.text$mn:00003320                 pop     ebp
.text$mn:00003321                 retn    4
.text$mn:00003321 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00003321
.text$mn:00003321 _text$mn        ends
.text$mn:00003321
.text$mn:00003324 ; ===========================================================================
.text$mn:00003324
.text$mn:00003324 ; Segment type: Pure code
.text$mn:00003324 ; Segment permissions: Read/Execute
.text$mn:00003324 _text$mn        segment para public 'CODE' use32
.text$mn:00003324                 assume cs:_text$mn
.text$mn:00003324                 ;org 3324h
.text$mn:00003324 ; COMDAT (pick any)
.text$mn:00003324                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003324
.text$mn:00003324 ; =============== S U B R O U T I N E =======================================
.text$mn:00003324
.text$mn:00003324 ; Attributes: bp-based frame
.text$mn:00003324
.text$mn:00003324 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00003324                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00003324 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00003324
.text$mn:00003324 var_4           = dword ptr -4
.text$mn:00003324 arg_0           = dword ptr  8
.text$mn:00003324
.text$mn:00003324                 push    ebp
.text$mn:00003325                 mov     ebp, esp
.text$mn:00003327                 push    ecx
.text$mn:00003328                 mov     [ebp+var_4], ecx
.text$mn:0000332B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000332E                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00003333                 mov     eax, [ebp+arg_0]
.text$mn:00003336                 and     eax, 1
.text$mn:00003339                 jz      short loc_3347
.text$mn:0000333B                 mov     ecx, [ebp+var_4]
.text$mn:0000333E                 push    ecx             ; void *
.text$mn:0000333F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003344                 add     esp, 4
.text$mn:00003347
.text$mn:00003347 loc_3347:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00003347                 mov     eax, [ebp+var_4]
.text$mn:0000334A                 mov     esp, ebp
.text$mn:0000334C                 pop     ebp
.text$mn:0000334D                 retn    4
.text$mn:0000334D ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:0000334D
.text$mn:0000334D _text$mn        ends
.text$mn:0000334D
.text$mn:00003350 ; ===========================================================================
.text$mn:00003350
.text$mn:00003350 ; Segment type: Pure code
.text$mn:00003350 ; Segment permissions: Read/Execute
.text$mn:00003350 _text$mn        segment para public 'CODE' use32
.text$mn:00003350                 assume cs:_text$mn
.text$mn:00003350                 ;org 3350h
.text$mn:00003350 ; COMDAT (pick any)
.text$mn:00003350                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003350
.text$mn:00003350 ; =============== S U B R O U T I N E =======================================
.text$mn:00003350
.text$mn:00003350 ; Attributes: bp-based frame
.text$mn:00003350
.text$mn:00003350 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00003350                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00003350 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00003350
.text$mn:00003350 var_4           = dword ptr -4
.text$mn:00003350 arg_0           = dword ptr  8
.text$mn:00003350
.text$mn:00003350                 push    ebp
.text$mn:00003351                 mov     ebp, esp
.text$mn:00003353                 push    ecx
.text$mn:00003354                 mov     [ebp+var_4], ecx
.text$mn:00003357                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000335A                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000335F                 mov     eax, [ebp+arg_0]
.text$mn:00003362                 and     eax, 1
.text$mn:00003365                 jz      short loc_3373
.text$mn:00003367                 mov     ecx, [ebp+var_4]
.text$mn:0000336A                 push    ecx             ; void *
.text$mn:0000336B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003370                 add     esp, 4
.text$mn:00003373
.text$mn:00003373 loc_3373:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00003373                 mov     eax, [ebp+var_4]
.text$mn:00003376                 mov     esp, ebp
.text$mn:00003378                 pop     ebp
.text$mn:00003379                 retn    4
.text$mn:00003379 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00003379
.text$mn:00003379 _text$mn        ends
.text$mn:00003379
.text$mn:0000337C ; ===========================================================================
.text$mn:0000337C
.text$mn:0000337C ; Segment type: Pure code
.text$mn:0000337C ; Segment permissions: Read/Execute
.text$mn:0000337C _text$mn        segment para public 'CODE' use32
.text$mn:0000337C                 assume cs:_text$mn
.text$mn:0000337C                 ;org 337Ch
.text$mn:0000337C ; COMDAT (pick any)
.text$mn:0000337C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000337C
.text$mn:0000337C ; =============== S U B R O U T I N E =======================================
.text$mn:0000337C
.text$mn:0000337C ; Attributes: bp-based frame
.text$mn:0000337C
.text$mn:0000337C ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:0000337C                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:0000337C ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:0000337C
.text$mn:0000337C var_4           = dword ptr -4
.text$mn:0000337C arg_0           = dword ptr  8
.text$mn:0000337C
.text$mn:0000337C                 push    ebp
.text$mn:0000337D                 mov     ebp, esp
.text$mn:0000337F                 push    ecx
.text$mn:00003380                 mov     [ebp+var_4], ecx
.text$mn:00003383                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003386                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:0000338B                 mov     eax, [ebp+arg_0]
.text$mn:0000338E                 and     eax, 1
.text$mn:00003391                 jz      short loc_339F
.text$mn:00003393                 mov     ecx, [ebp+var_4]
.text$mn:00003396                 push    ecx             ; void *
.text$mn:00003397                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000339C                 add     esp, 4
.text$mn:0000339F
.text$mn:0000339F loc_339F:                               ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:0000339F                 mov     eax, [ebp+var_4]
.text$mn:000033A2                 mov     esp, ebp
.text$mn:000033A4                 pop     ebp
.text$mn:000033A5                 retn    4
.text$mn:000033A5 ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:000033A5
.text$mn:000033A5 _text$mn        ends
.text$mn:000033A5
.text$di:000033A8 ; ===========================================================================
.text$di:000033A8
.text$di:000033A8 ; Segment type: Pure code
.text$di:000033A8 ; Segment permissions: Read/Execute
.text$di:000033A8 _text$di        segment para public 'CODE' use32
.text$di:000033A8                 assume cs:_text$di
.text$di:000033A8                 ;org 33A8h
.text$di:000033A8 ; COMDAT (pick any)
.text$di:000033A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000033A8
.text$di:000033A8 ; =============== S U B R O U T I N E =======================================
.text$di:000033A8
.text$di:000033A8 ; Attributes: bp-based frame
.text$di:000033A8
.text$di:000033A8 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:000033A8 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:000033A8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:000033A8                 push    ebp
.text$di:000033A9                 mov     ebp, esp
.text$di:000033AB                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:000033B0                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:000033B5                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000033BA                 call    _atexit
.text$di:000033BF                 add     esp, 4
.text$di:000033C2                 pop     ebp
.text$di:000033C3                 retn
.text$di:000033C3 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:000033C3
.text$di:000033C3 _text$di        ends
.text$di:000033C3
.text$di:000033C4 ; ===========================================================================
.text$di:000033C4
.text$di:000033C4 ; Segment type: Pure code
.text$di:000033C4 ; Segment permissions: Read/Execute
.text$di:000033C4 _text$di        segment para public 'CODE' use32
.text$di:000033C4                 assume cs:_text$di
.text$di:000033C4                 ;org 33C4h
.text$di:000033C4 ; COMDAT (pick any)
.text$di:000033C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000033C4
.text$di:000033C4 ; =============== S U B R O U T I N E =======================================
.text$di:000033C4
.text$di:000033C4 ; Attributes: bp-based frame
.text$di:000033C4
.text$di:000033C4 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:000033C4 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:000033C4                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:000033C4                 push    ebp
.text$di:000033C5                 mov     ebp, esp
.text$di:000033C7                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:000033CC                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:000033D1                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000033D6                 call    _atexit
.text$di:000033DB                 add     esp, 4
.text$di:000033DE                 pop     ebp
.text$di:000033DF                 retn
.text$di:000033DF ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:000033DF
.text$di:000033DF _text$di        ends
.text$di:000033DF
.text$di:000033E0 ; ===========================================================================
.text$di:000033E0
.text$di:000033E0 ; Segment type: Pure code
.text$di:000033E0 ; Segment permissions: Read/Execute
.text$di:000033E0 _text$di        segment para public 'CODE' use32
.text$di:000033E0                 assume cs:_text$di
.text$di:000033E0                 ;org 33E0h
.text$di:000033E0 ; COMDAT (pick any)
.text$di:000033E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000033E0
.text$di:000033E0 ; =============== S U B R O U T I N E =======================================
.text$di:000033E0
.text$di:000033E0 ; Attributes: bp-based frame
.text$di:000033E0
.text$di:000033E0 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:000033E0 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:000033E0                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:000033E0                 push    ebp
.text$di:000033E1                 mov     ebp, esp
.text$di:000033E3                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:000033E8                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:000033ED                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000033F2                 call    _atexit
.text$di:000033F7                 add     esp, 4
.text$di:000033FA                 pop     ebp
.text$di:000033FB                 retn
.text$di:000033FB ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:000033FB
.text$di:000033FB _text$di        ends
.text$di:000033FB
.text$di:000033FC ; ===========================================================================
.text$di:000033FC
.text$di:000033FC ; Segment type: Pure code
.text$di:000033FC ; Segment permissions: Read/Execute
.text$di:000033FC _text$di        segment para public 'CODE' use32
.text$di:000033FC                 assume cs:_text$di
.text$di:000033FC                 ;org 33FCh
.text$di:000033FC ; COMDAT (pick any)
.text$di:000033FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000033FC
.text$di:000033FC ; =============== S U B R O U T I N E =======================================
.text$di:000033FC
.text$di:000033FC ; Attributes: bp-based frame
.text$di:000033FC
.text$di:000033FC ; void __cdecl `dynamic initializer for 'protected: static unsigned long TabBarPlus::_activeTextColour''(void)
.text$di:000033FC ??__E?_activeTextColour@TabBarPlus@@1KA@@YAXXZ proc near
.text$di:000033FC                                         ; DATA XREF: .CRT$XCU:void (*TabBarPlus::_activeTextColour$initializer$)(void)o
.text$di:000033FC                 push    ebp
.text$di:000033FD                 mov     ebp, esp
.text$di:000033FF                 push    12h             ; nIndex
.text$di:00003401                 call    dword ptr ds:__imp__GetSysColor@4 ; GetSysColor(x)
.text$di:00003407                 mov     ds:?_activeTextColour@TabBarPlus@@1KA, eax ; ulong TabBarPlus::_activeTextColour
.text$di:0000340C                 pop     ebp
.text$di:0000340D                 retn
.text$di:0000340D ??__E?_activeTextColour@TabBarPlus@@1KA@@YAXXZ endp
.text$di:0000340D
.text$di:0000340D ; ---------------------------------------------------------------------------
.text$di:0000340E                 align 10h
.text$di:0000340E _text$di        ends
.text$di:0000340E
.text$di:00003410 ; ===========================================================================
.text$di:00003410
.text$di:00003410 ; Segment type: Pure code
.text$di:00003410 ; Segment permissions: Read/Execute
.text$di:00003410 _text$di        segment para public 'CODE' use32
.text$di:00003410                 assume cs:_text$di
.text$di:00003410                 ;org 3410h
.text$di:00003410 ; COMDAT (pick any)
.text$di:00003410                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003410
.text$di:00003410 ; =============== S U B R O U T I N E =======================================
.text$di:00003410
.text$di:00003410 ; Attributes: bp-based frame
.text$di:00003410
.text$di:00003410 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00003410 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00003410                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00003410                 push    ebp
.text$di:00003411                 mov     ebp, esp
.text$di:00003413                 push    0               ; unsigned int
.text$di:00003415                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000341A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000341F                 pop     ebp
.text$di:00003420                 retn
.text$di:00003420 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00003420
.text$di:00003420 ; ---------------------------------------------------------------------------
.text$di:00003421                 align 4
.text$di:00003421 _text$di        ends
.text$di:00003421
.text$di:00003424 ; ===========================================================================
.text$di:00003424
.text$di:00003424 ; Segment type: Pure code
.text$di:00003424 ; Segment permissions: Read/Execute
.text$di:00003424 _text$di        segment para public 'CODE' use32
.text$di:00003424                 assume cs:_text$di
.text$di:00003424                 ;org 3424h
.text$di:00003424 ; COMDAT (pick any)
.text$di:00003424                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003424
.text$di:00003424 ; =============== S U B R O U T I N E =======================================
.text$di:00003424
.text$di:00003424 ; Attributes: bp-based frame
.text$di:00003424
.text$di:00003424 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00003424 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00003424                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00003424                 push    ebp
.text$di:00003425                 mov     ebp, esp
.text$di:00003427                 push    0               ; unsigned int
.text$di:00003429                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000342E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00003433                 pop     ebp
.text$di:00003434                 retn
.text$di:00003434 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00003434
.text$di:00003434 ; ---------------------------------------------------------------------------
.text$di:00003435                 align 4
.text$di:00003435 _text$di        ends
.text$di:00003435
.text$di:00003438 ; ===========================================================================
.text$di:00003438
.text$di:00003438 ; Segment type: Pure code
.text$di:00003438 ; Segment permissions: Read/Execute
.text$di:00003438 _text$di        segment para public 'CODE' use32
.text$di:00003438                 assume cs:_text$di
.text$di:00003438                 ;org 3438h
.text$di:00003438 ; COMDAT (pick any)
.text$di:00003438                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003438
.text$di:00003438 ; =============== S U B R O U T I N E =======================================
.text$di:00003438
.text$di:00003438 ; Attributes: bp-based frame
.text$di:00003438
.text$di:00003438 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00003438 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00003438                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00003438                 push    ebp
.text$di:00003439                 mov     ebp, esp
.text$di:0000343B                 push    0               ; unsigned int
.text$di:0000343D                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00003442                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00003447                 pop     ebp
.text$di:00003448                 retn
.text$di:00003448 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00003448
.text$di:00003448 ; ---------------------------------------------------------------------------
.text$di:00003449                 align 4
.text$di:00003449 _text$di        ends
.text$di:00003449
.text$di:0000344C ; ===========================================================================
.text$di:0000344C
.text$di:0000344C ; Segment type: Pure code
.text$di:0000344C ; Segment permissions: Read/Execute
.text$di:0000344C _text$di        segment para public 'CODE' use32
.text$di:0000344C                 assume cs:_text$di
.text$di:0000344C                 ;org 344Ch
.text$di:0000344C ; COMDAT (pick any)
.text$di:0000344C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000344C
.text$di:0000344C ; =============== S U B R O U T I N E =======================================
.text$di:0000344C
.text$di:0000344C ; Attributes: bp-based frame
.text$di:0000344C
.text$di:0000344C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:0000344C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000344C                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:0000344C                 push    ebp
.text$di:0000344D                 mov     ebp, esp
.text$di:0000344F                 push    0               ; unsigned int
.text$di:00003451                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00003456                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000345B                 pop     ebp
.text$di:0000345C                 retn
.text$di:0000345C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000345C
.text$di:0000345C ; ---------------------------------------------------------------------------
.text$di:0000345D                 align 10h
.text$di:0000345D _text$di        ends
.text$di:0000345D
.text$di:00003460 ; ===========================================================================
.text$di:00003460
.text$di:00003460 ; Segment type: Pure code
.text$di:00003460 ; Segment permissions: Read/Execute
.text$di:00003460 _text$di        segment para public 'CODE' use32
.text$di:00003460                 assume cs:_text$di
.text$di:00003460                 ;org 3460h
.text$di:00003460 ; COMDAT (pick any)
.text$di:00003460                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003460
.text$di:00003460 ; =============== S U B R O U T I N E =======================================
.text$di:00003460
.text$di:00003460 ; Attributes: bp-based frame
.text$di:00003460
.text$di:00003460 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00003460 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00003460
.text$di:00003460 var_1           = byte ptr -1
.text$di:00003460
.text$di:00003460                 push    ebp
.text$di:00003461                 mov     ebp, esp
.text$di:00003463                 push    ecx
.text$di:00003464                 xor     eax, eax
.text$di:00003466                 mov     [ebp+var_1], al
.text$di:00003469                 mov     esp, ebp
.text$di:0000346B                 pop     ebp
.text$di:0000346C                 retn
.text$di:0000346C ??__Eallocator_arg@std@@YAXXZ endp
.text$di:0000346C
.text$di:0000346C ; ---------------------------------------------------------------------------
.text$di:0000346D                 align 10h
.text$di:0000346D _text$di        ends
.text$di:0000346D
.text$di:00003470 ; ===========================================================================
.text$di:00003470
.text$di:00003470 ; Segment type: Pure code
.text$di:00003470 ; Segment permissions: Read/Execute
.text$di:00003470 _text$di        segment para public 'CODE' use32
.text$di:00003470                 assume cs:_text$di
.text$di:00003470                 ;org 3470h
.text$di:00003470 ; COMDAT (pick any)
.text$di:00003470                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003470
.text$di:00003470 ; =============== S U B R O U T I N E =======================================
.text$di:00003470
.text$di:00003470 ; Attributes: bp-based frame
.text$di:00003470
.text$di:00003470 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00003470 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00003470                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00003470
.text$di:00003470 var_1           = byte ptr -1
.text$di:00003470
.text$di:00003470                 push    ebp
.text$di:00003471                 mov     ebp, esp
.text$di:00003473                 push    ecx
.text$di:00003474                 xor     eax, eax
.text$di:00003476                 mov     [ebp+var_1], al
.text$di:00003479                 mov     esp, ebp
.text$di:0000347B                 pop     ebp
.text$di:0000347C                 retn
.text$di:0000347C ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:0000347C
.text$di:0000347C ; ---------------------------------------------------------------------------
.text$di:0000347D                 align 10h
.text$di:0000347D _text$di        ends
.text$di:0000347D
.text$yd:00003480 ; ===========================================================================
.text$yd:00003480
.text$yd:00003480 ; Segment type: Pure code
.text$yd:00003480 ; Segment permissions: Read/Execute
.text$yd:00003480 _text$yd        segment para public 'CODE' use32
.text$yd:00003480                 assume cs:_text$yd
.text$yd:00003480                 ;org 3480h
.text$yd:00003480 ; COMDAT (pick any)
.text$yd:00003480                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00003480
.text$yd:00003480 ; =============== S U B R O U T I N E =======================================
.text$yd:00003480
.text$yd:00003480 ; Attributes: bp-based frame
.text$yd:00003480
.text$yd:00003480 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00003480 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00003480                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00003480                 push    ebp
.text$yd:00003481                 mov     ebp, esp
.text$yd:00003483                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00003488                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:0000348D                 pop     ebp
.text$yd:0000348E                 retn
.text$yd:0000348E ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:0000348E
.text$yd:0000348E ; ---------------------------------------------------------------------------
.text$yd:0000348F                 align 10h
.text$yd:0000348F _text$yd        ends
.text$yd:0000348F
.text$yd:00003490 ; ===========================================================================
.text$yd:00003490
.text$yd:00003490 ; Segment type: Pure code
.text$yd:00003490 ; Segment permissions: Read/Execute
.text$yd:00003490 _text$yd        segment para public 'CODE' use32
.text$yd:00003490                 assume cs:_text$yd
.text$yd:00003490                 ;org 3490h
.text$yd:00003490 ; COMDAT (pick any)
.text$yd:00003490                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00003490
.text$yd:00003490 ; =============== S U B R O U T I N E =======================================
.text$yd:00003490
.text$yd:00003490 ; Attributes: bp-based frame
.text$yd:00003490
.text$yd:00003490 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00003490 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00003490                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00003490                 push    ebp
.text$yd:00003491                 mov     ebp, esp
.text$yd:00003493                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00003498                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:0000349D                 pop     ebp
.text$yd:0000349E                 retn
.text$yd:0000349E ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:0000349E
.text$yd:0000349E ; ---------------------------------------------------------------------------
.text$yd:0000349F                 align 10h
.text$yd:0000349F _text$yd        ends
.text$yd:0000349F
.text$yd:000034A0 ; ===========================================================================
.text$yd:000034A0
.text$yd:000034A0 ; Segment type: Pure code
.text$yd:000034A0 ; Segment permissions: Read/Execute
.text$yd:000034A0 _text$yd        segment para public 'CODE' use32
.text$yd:000034A0                 assume cs:_text$yd
.text$yd:000034A0                 ;org 34A0h
.text$yd:000034A0 ; COMDAT (pick any)
.text$yd:000034A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000034A0
.text$yd:000034A0 ; =============== S U B R O U T I N E =======================================
.text$yd:000034A0
.text$yd:000034A0 ; Attributes: bp-based frame
.text$yd:000034A0
.text$yd:000034A0 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:000034A0 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:000034A0                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:000034A0                 push    ebp
.text$yd:000034A1                 mov     ebp, esp
.text$yd:000034A3                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:000034A8                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:000034AD                 pop     ebp
.text$yd:000034AE                 retn
.text$yd:000034AE ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:000034AE
.text$yd:000034AE ; ---------------------------------------------------------------------------
.text$yd:000034AF                 align 10h
.text$yd:000034AF _text$yd        ends
.text$yd:000034AF
.text$mn:000034B0 ; ===========================================================================
.text$mn:000034B0
.text$mn:000034B0 ; Segment type: Pure code
.text$mn:000034B0 ; Segment permissions: Read/Execute
.text$mn:000034B0 _text$mn        segment para public 'CODE' use32
.text$mn:000034B0                 assume cs:_text$mn
.text$mn:000034B0                 ;org 34B0h
.text$mn:000034B0 ; COMDAT (pick any)
.text$mn:000034B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034B0
.text$mn:000034B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000034B0
.text$mn:000034B0 ; Attributes: bp-based frame
.text$mn:000034B0
.text$mn:000034B0 ; __int32 __stdcall TabBarPlus::TabBarPlus_Proc(HWND hWnd, UINT Msg, WPARAM wParam, __int32)
.text$mn:000034B0                 public ?TabBarPlus_Proc@TabBarPlus@@KGJPAUHWND__@@IIJ@Z
.text$mn:000034B0 ?TabBarPlus_Proc@TabBarPlus@@KGJPAUHWND__@@IIJ@Z proc near
.text$mn:000034B0                                         ; DATA XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+2A3o
.text$mn:000034B0
.text$mn:000034B0 hWnd            = dword ptr  8
.text$mn:000034B0 Msg             = dword ptr  0Ch
.text$mn:000034B0 wParam          = dword ptr  10h
.text$mn:000034B0 arg_C           = dword ptr  14h
.text$mn:000034B0
.text$mn:000034B0                 push    ebp
.text$mn:000034B1                 mov     ebp, esp
.text$mn:000034B3                 mov     eax, [ebp+arg_C]
.text$mn:000034B6                 push    eax             ; __int32
.text$mn:000034B7                 mov     ecx, [ebp+wParam]
.text$mn:000034BA                 push    ecx             ; wParam
.text$mn:000034BB                 mov     edx, [ebp+Msg]
.text$mn:000034BE                 push    edx             ; Msg
.text$mn:000034BF                 mov     eax, [ebp+hWnd]
.text$mn:000034C2                 push    eax             ; hWnd
.text$mn:000034C3                 push    0FFFFFFEBh      ; nIndex
.text$mn:000034C5                 mov     ecx, [ebp+hWnd]
.text$mn:000034C8                 push    ecx             ; hWnd
.text$mn:000034C9                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:000034CF                 mov     ecx, eax        ; this
.text$mn:000034D1                 call    ?runProc@TabBarPlus@@IAEJPAUHWND__@@IIJ@Z ; TabBarPlus::runProc(HWND__ *,uint,uint,long)
.text$mn:000034D6                 pop     ebp
.text$mn:000034D7                 retn    10h
.text$mn:000034D7 ?TabBarPlus_Proc@TabBarPlus@@KGJPAUHWND__@@IIJ@Z endp
.text$mn:000034D7
.text$mn:000034D7 ; ---------------------------------------------------------------------------
.text$mn:000034DA                 align 4
.text$mn:000034DA _text$mn        ends
.text$mn:000034DA
.text$mn:000034DC ; ===========================================================================
.text$mn:000034DC
.text$mn:000034DC ; Segment type: Pure code
.text$mn:000034DC ; Segment permissions: Read/Execute
.text$mn:000034DC _text$mn        segment para public 'CODE' use32
.text$mn:000034DC                 assume cs:_text$mn
.text$mn:000034DC                 ;org 34DCh
.text$mn:000034DC ; COMDAT (pick any)
.text$mn:000034DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034DC
.text$mn:000034DC ; =============== S U B R O U T I N E =======================================
.text$mn:000034DC
.text$mn:000034DC ; Attributes: bp-based frame
.text$mn:000034DC
.text$mn:000034DC ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000034DC                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000034DC ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000034DC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:000034DC
.text$mn:000034DC var_10          = byte ptr -10h
.text$mn:000034DC var_8           = dword ptr -8
.text$mn:000034DC var_1           = byte ptr -1
.text$mn:000034DC
.text$mn:000034DC                 push    ebp
.text$mn:000034DD                 mov     ebp, esp
.text$mn:000034DF                 sub     esp, 10h
.text$mn:000034E2                 mov     [ebp+var_8], ecx
.text$mn:000034E5                 lea     ecx, [ebp+var_1]
.text$mn:000034E8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000034ED                 push    1
.text$mn:000034EF                 lea     ecx, [ebp+var_1]
.text$mn:000034F2                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000034F7                 mov     ecx, [ebp+var_8]
.text$mn:000034FA                 mov     [ecx], eax
.text$mn:000034FC                 lea     ecx, [ebp+var_10] ; this
.text$mn:000034FF                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00003504                 push    eax             ; int
.text$mn:00003505                 mov     edx, [ebp+var_8]
.text$mn:00003508                 mov     eax, [edx]
.text$mn:0000350A                 push    eax             ; void *
.text$mn:0000350B                 lea     ecx, [ebp+var_1]
.text$mn:0000350E                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00003513                 mov     ecx, [ebp+var_8]
.text$mn:00003516                 mov     edx, [ecx]
.text$mn:00003518                 mov     eax, [ebp+var_8]
.text$mn:0000351B                 mov     [edx], eax
.text$mn:0000351D                 mov     esp, ebp
.text$mn:0000351F                 pop     ebp
.text$mn:00003520                 retn
.text$mn:00003520 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00003520
.text$mn:00003520 ; ---------------------------------------------------------------------------
.text$mn:00003521                 align 4
.text$mn:00003521 _text$mn        ends
.text$mn:00003521
.text$mn:00003524 ; ===========================================================================
.text$mn:00003524
.text$mn:00003524 ; Segment type: Pure code
.text$mn:00003524 ; Segment permissions: Read/Execute
.text$mn:00003524 _text$mn        segment para public 'CODE' use32
.text$mn:00003524                 assume cs:_text$mn
.text$mn:00003524                 ;org 3524h
.text$mn:00003524 ; COMDAT (pick any)
.text$mn:00003524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003524
.text$mn:00003524 ; =============== S U B R O U T I N E =======================================
.text$mn:00003524
.text$mn:00003524 ; Attributes: bp-based frame
.text$mn:00003524
.text$mn:00003524 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00003524                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00003524 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00003524                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00003524
.text$mn:00003524 var_20          = dword ptr -20h
.text$mn:00003524 var_1C          = dword ptr -1Ch
.text$mn:00003524 var_18          = dword ptr -18h
.text$mn:00003524 var_11          = byte ptr -11h
.text$mn:00003524 var_10          = dword ptr -10h
.text$mn:00003524 var_C           = byte ptr -0Ch
.text$mn:00003524 var_4           = dword ptr -4
.text$mn:00003524 arg_0           = dword ptr  8
.text$mn:00003524
.text$mn:00003524 ; FUNCTION CHUNK AT .text$mn:00003646 SIZE 00000009 BYTES
.text$mn:00003524
.text$mn:00003524                 push    ebp
.text$mn:00003525                 mov     ebp, esp
.text$mn:00003527                 push    0FFFFFFFFh
.text$mn:00003529                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000352E                 mov     eax, large fs:0
.text$mn:00003534                 push    eax
.text$mn:00003535                 push    ecx
.text$mn:00003536                 sub     esp, 10h
.text$mn:00003539                 push    ebx
.text$mn:0000353A                 push    esi
.text$mn:0000353B                 push    edi
.text$mn:0000353C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003541                 xor     eax, ebp
.text$mn:00003543                 push    eax
.text$mn:00003544                 lea     eax, [ebp+var_C]
.text$mn:00003547                 mov     large fs:0, eax
.text$mn:0000354D                 mov     [ebp+var_10], esp
.text$mn:00003550                 mov     [ebp+var_18], ecx
.text$mn:00003553                 mov     eax, [ebp+arg_0]
.text$mn:00003556                 or      eax, 0Fh
.text$mn:00003559                 mov     [ebp+var_1C], eax
.text$mn:0000355C                 mov     ecx, [ebp+var_18]
.text$mn:0000355F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00003564                 cmp     eax, [ebp+var_1C]
.text$mn:00003567                 jnb     short loc_3571
.text$mn:00003569                 mov     ecx, [ebp+arg_0]
.text$mn:0000356C                 mov     [ebp+var_1C], ecx
.text$mn:0000356F                 jmp     short loc_35C3
.text$mn:00003571 ; ---------------------------------------------------------------------------
.text$mn:00003571
.text$mn:00003571 loc_3571:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00003571                 mov     edx, [ebp+var_18]
.text$mn:00003574                 mov     ecx, [edx+18h]
.text$mn:00003577                 shr     ecx, 1
.text$mn:00003579                 mov     eax, [ebp+var_1C]
.text$mn:0000357C                 xor     edx, edx
.text$mn:0000357E                 mov     esi, 3
.text$mn:00003583                 div     esi
.text$mn:00003585                 cmp     ecx, eax
.text$mn:00003587                 ja      short loc_358B
.text$mn:00003589                 jmp     short loc_35C3
.text$mn:0000358B ; ---------------------------------------------------------------------------
.text$mn:0000358B
.text$mn:0000358B loc_358B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:0000358B                 mov     ecx, [ebp+var_18]
.text$mn:0000358E                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00003593                 mov     edx, [ebp+var_18]
.text$mn:00003596                 mov     ecx, [edx+18h]
.text$mn:00003599                 shr     ecx, 1
.text$mn:0000359B                 sub     eax, ecx
.text$mn:0000359D                 mov     edx, [ebp+var_18]
.text$mn:000035A0                 cmp     [edx+18h], eax
.text$mn:000035A3                 ja      short loc_35B8
.text$mn:000035A5                 mov     eax, [ebp+var_18]
.text$mn:000035A8                 mov     ecx, [eax+18h]
.text$mn:000035AB                 shr     ecx, 1
.text$mn:000035AD                 mov     edx, [ebp+var_18]
.text$mn:000035B0                 add     ecx, [edx+18h]
.text$mn:000035B3                 mov     [ebp+var_1C], ecx
.text$mn:000035B6                 jmp     short loc_35C3
.text$mn:000035B8 ; ---------------------------------------------------------------------------
.text$mn:000035B8
.text$mn:000035B8 loc_35B8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000035B8                 mov     ecx, [ebp+var_18]
.text$mn:000035BB                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000035C0                 mov     [ebp+var_1C], eax
.text$mn:000035C3
.text$mn:000035C3 loc_35C3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:000035C3                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:000035C3                 mov     [ebp+var_4], 0
.text$mn:000035CA                 mov     eax, [ebp+var_1C]
.text$mn:000035CD                 add     eax, 1
.text$mn:000035D0                 push    eax
.text$mn:000035D1                 lea     ecx, [ebp+var_11]
.text$mn:000035D4                 push    ecx
.text$mn:000035D5                 mov     ecx, [ebp+var_18]
.text$mn:000035D8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000035DD                 mov     ecx, eax
.text$mn:000035DF                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000035E4                 mov     [ebp+var_20], eax
.text$mn:000035E7                 jmp     short loc_3646
.text$mn:000035E7 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:000035E7
.text$mn:000035E9
.text$mn:000035E9 ; =============== S U B R O U T I N E =======================================
.text$mn:000035E9
.text$mn:000035E9
.text$mn:000035E9 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:000035E9                                         ; DATA XREF: .xdata$x:0000454Co
.text$mn:000035E9
.text$mn:000035E9 ; FUNCTION CHUNK AT .text$mn:00003630 SIZE 00000009 BYTES
.text$mn:000035E9 ; FUNCTION CHUNK AT .text$mn:00003640 SIZE 00000006 BYTES
.text$mn:000035E9
.text$mn:000035E9                 mov     [ebp-10h], esp
.text$mn:000035EC                 mov     edx, [ebp+8]
.text$mn:000035EF                 mov     [ebp-1Ch], edx
.text$mn:000035F2                 mov     byte ptr [ebp-4], 2
.text$mn:000035F6                 mov     eax, [ebp-1Ch]
.text$mn:000035F9                 add     eax, 1
.text$mn:000035FC                 push    eax
.text$mn:000035FD                 lea     ecx, [ebp-12h]
.text$mn:00003600                 push    ecx
.text$mn:00003601                 mov     ecx, [ebp-18h]
.text$mn:00003604                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003609                 mov     ecx, eax
.text$mn:0000360B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00003610                 mov     [ebp-20h], eax
.text$mn:00003613                 jmp     short loc_3630
.text$mn:00003613 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00003613
.text$mn:00003615
.text$mn:00003615 ; =============== S U B R O U T I N E =======================================
.text$mn:00003615
.text$mn:00003615 ; Attributes: noreturn
.text$mn:00003615
.text$mn:00003615 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00003615                                         ; DATA XREF: .xdata$x:0000455Co
.text$mn:00003615                 push    0               ; Size
.text$mn:00003617                 push    1               ; char
.text$mn:00003619                 mov     ecx, [ebp-18h]
.text$mn:0000361C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003621                 push    0
.text$mn:00003623                 push    0
.text$mn:00003625                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00003625 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00003625
.text$mn:0000362A ; ---------------------------------------------------------------------------
.text$mn:0000362A                 mov     eax, offset $LN17
.text$mn:0000362F                 retn
.text$mn:00003630 ; ---------------------------------------------------------------------------
.text$mn:00003630 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003630
.text$mn:00003630 loc_3630:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00003630                 mov     dword ptr [ebp-4], 1
.text$mn:00003637                 jmp     short loc_3640
.text$mn:00003637 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003639
.text$mn:00003639 ; =============== S U B R O U T I N E =======================================
.text$mn:00003639
.text$mn:00003639
.text$mn:00003639 $LN17           proc near               ; DATA XREF: .text$mn:0000362Ao
.text$mn:00003639                 mov     dword ptr [ebp-4], 1
.text$mn:00003639 $LN17           endp ; sp-analysis failed
.text$mn:00003639
.text$mn:00003640 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003640
.text$mn:00003640 loc_3640:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00003640                 mov     eax, offset $LN19
.text$mn:00003645                 retn
.text$mn:00003645 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003646 ; ---------------------------------------------------------------------------
.text$mn:00003646 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00003646
.text$mn:00003646 loc_3646:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00003646                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000364D                 jmp     short loc_3656
.text$mn:0000364D ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000364F
.text$mn:0000364F ; =============== S U B R O U T I N E =======================================
.text$mn:0000364F
.text$mn:0000364F
.text$mn:0000364F $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_3640o
.text$mn:0000364F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00003656
.text$mn:00003656 loc_3656:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00003656                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000365A                 jbe     short loc_3675
.text$mn:0000365C                 mov     edx, [ebp+0Ch]
.text$mn:0000365F                 push    edx             ; Size
.text$mn:00003660                 mov     ecx, [ebp-18h]
.text$mn:00003663                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003668                 push    eax             ; Src
.text$mn:00003669                 mov     eax, [ebp-20h]
.text$mn:0000366C                 push    eax             ; Dst
.text$mn:0000366D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00003672                 add     esp, 0Ch
.text$mn:00003675
.text$mn:00003675 loc_3675:                               ; CODE XREF: $LN19+Bj
.text$mn:00003675                 push    0               ; Size
.text$mn:00003677                 push    1               ; char
.text$mn:00003679                 mov     ecx, [ebp-18h]
.text$mn:0000367C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003681                 lea     ecx, [ebp-20h]
.text$mn:00003684                 push    ecx             ; int
.text$mn:00003685                 mov     edx, [ebp-18h]
.text$mn:00003688                 add     edx, 4
.text$mn:0000368B                 push    edx             ; void *
.text$mn:0000368C                 lea     eax, [ebp-13h]
.text$mn:0000368F                 push    eax
.text$mn:00003690                 mov     ecx, [ebp-18h]
.text$mn:00003693                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003698                 mov     ecx, eax
.text$mn:0000369A                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000369F                 mov     ecx, [ebp-18h]
.text$mn:000036A2                 mov     edx, [ebp-1Ch]
.text$mn:000036A5                 mov     [ecx+18h], edx
.text$mn:000036A8                 mov     eax, [ebp+0Ch]
.text$mn:000036AB                 push    eax
.text$mn:000036AC                 mov     ecx, [ebp-18h]
.text$mn:000036AF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000036B4                 mov     ecx, [ebp-0Ch]
.text$mn:000036B7                 mov     large fs:0, ecx
.text$mn:000036BE                 pop     ecx
.text$mn:000036BF                 pop     edi
.text$mn:000036C0                 pop     esi
.text$mn:000036C1                 pop     ebx
.text$mn:000036C2                 mov     esp, ebp
.text$mn:000036C4                 pop     ebp
.text$mn:000036C5                 retn    8
.text$mn:000036C5 $LN19           endp ; sp-analysis failed
.text$mn:000036C5
.text$mn:000036C5 _text$mn        ends
.text$mn:000036C5
.text$x:000036C8 ; ===========================================================================
.text$x:000036C8
.text$x:000036C8 ; Segment type: Pure code
.text$x:000036C8 ; Segment permissions: Read/Execute
.text$x:000036C8 _text$x         segment para public 'CODE' use32
.text$x:000036C8                 assume cs:_text$x
.text$x:000036C8                 ;org 36C8h
.text$x:000036C8 ; COMDAT (pick associative to section at 3524)
.text$x:000036C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000036C8
.text$x:000036C8 ; =============== S U B R O U T I N E =======================================
.text$x:000036C8
.text$x:000036C8
.text$x:000036C8 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:000036C8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:000036C8
.text$x:000036C8 arg_4           = dword ptr  8
.text$x:000036C8
.text$x:000036C8                 mov     edx, [esp+arg_4]
.text$x:000036CC                 lea     eax, [edx+0Ch]
.text$x:000036CF                 mov     ecx, [edx-24h]
.text$x:000036D2                 xor     ecx, eax
.text$x:000036D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000036D9                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:000036DE                 jmp     ___CxxFrameHandler3
.text$x:000036DE __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:000036DE
.text$x:000036DE ; ---------------------------------------------------------------------------
.text$x:000036E3                 align 4
.text$x:000036E3 _text$x         ends
.text$x:000036E3
.text$mn:000036E4 ; ===========================================================================
.text$mn:000036E4
.text$mn:000036E4 ; Segment type: Pure code
.text$mn:000036E4 ; Segment permissions: Read/Execute
.text$mn:000036E4 _text$mn        segment para public 'CODE' use32
.text$mn:000036E4                 assume cs:_text$mn
.text$mn:000036E4                 ;org 36E4h
.text$mn:000036E4 ; COMDAT (pick any)
.text$mn:000036E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036E4
.text$mn:000036E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000036E4
.text$mn:000036E4 ; Attributes: bp-based frame
.text$mn:000036E4
.text$mn:000036E4 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:000036E4                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:000036E4 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:000036E4                                         ; CODE XREF: $LN19+60p
.text$mn:000036E4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:000036E4
.text$mn:000036E4 var_8           = dword ptr -8
.text$mn:000036E4 var_1           = byte ptr -1
.text$mn:000036E4 arg_0           = dword ptr  8
.text$mn:000036E4
.text$mn:000036E4                 push    ebp
.text$mn:000036E5                 mov     ebp, esp
.text$mn:000036E7                 sub     esp, 8
.text$mn:000036EA                 mov     [ebp+var_8], ecx
.text$mn:000036ED                 mov     [ebp+var_1], 0
.text$mn:000036F1                 mov     eax, [ebp+var_8]
.text$mn:000036F4                 mov     ecx, [ebp+arg_0]
.text$mn:000036F7                 mov     [eax+14h], ecx
.text$mn:000036FA                 lea     edx, [ebp+var_1]
.text$mn:000036FD                 push    edx
.text$mn:000036FE                 mov     ecx, [ebp+var_8]
.text$mn:00003701                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003706                 add     eax, [ebp+arg_0]
.text$mn:00003709                 push    eax
.text$mn:0000370A                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:0000370F                 add     esp, 8
.text$mn:00003712                 mov     esp, ebp
.text$mn:00003714                 pop     ebp
.text$mn:00003715                 retn    4
.text$mn:00003715 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00003715
.text$mn:00003715 _text$mn        ends
.text$mn:00003715
.text$mn:00003718 ; ===========================================================================
.text$mn:00003718
.text$mn:00003718 ; Segment type: Pure code
.text$mn:00003718 ; Segment permissions: Read/Execute
.text$mn:00003718 _text$mn        segment para public 'CODE' use32
.text$mn:00003718                 assume cs:_text$mn
.text$mn:00003718                 ;org 3718h
.text$mn:00003718 ; COMDAT (pick any)
.text$mn:00003718                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003718
.text$mn:00003718 ; =============== S U B R O U T I N E =======================================
.text$mn:00003718
.text$mn:00003718 ; Attributes: bp-based frame
.text$mn:00003718
.text$mn:00003718 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00003718                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00003718 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00003718                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00003718
.text$mn:00003718 var_8           = dword ptr -8
.text$mn:00003718 var_1           = byte ptr -1
.text$mn:00003718
.text$mn:00003718                 push    ebp
.text$mn:00003719                 mov     ebp, esp
.text$mn:0000371B                 sub     esp, 8
.text$mn:0000371E                 mov     [ebp+var_8], ecx
.text$mn:00003721                 lea     ecx, [ebp+var_1]
.text$mn:00003724                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00003729                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000372C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00003731                 mov     eax, [ebp+var_8]
.text$mn:00003734                 mov     ecx, [eax]
.text$mn:00003736                 push    ecx
.text$mn:00003737                 lea     ecx, [ebp+var_1]
.text$mn:0000373A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000373F                 push    1               ; int
.text$mn:00003741                 mov     edx, [ebp+var_8]
.text$mn:00003744                 mov     eax, [edx]
.text$mn:00003746                 push    eax             ; void *
.text$mn:00003747                 lea     ecx, [ebp+var_1]
.text$mn:0000374A                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000374F                 mov     ecx, [ebp+var_8]
.text$mn:00003752                 mov     dword ptr [ecx], 0
.text$mn:00003758                 mov     esp, ebp
.text$mn:0000375A                 pop     ebp
.text$mn:0000375B                 retn
.text$mn:0000375B ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000375B
.text$mn:0000375B _text$mn        ends
.text$mn:0000375B
.text$mn:0000375C ; ===========================================================================
.text$mn:0000375C
.text$mn:0000375C ; Segment type: Pure code
.text$mn:0000375C ; Segment permissions: Read/Execute
.text$mn:0000375C _text$mn        segment para public 'CODE' use32
.text$mn:0000375C                 assume cs:_text$mn
.text$mn:0000375C                 ;org 375Ch
.text$mn:0000375C ; COMDAT (pick any)
.text$mn:0000375C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000375C
.text$mn:0000375C ; =============== S U B R O U T I N E =======================================
.text$mn:0000375C
.text$mn:0000375C ; Attributes: bp-based frame
.text$mn:0000375C
.text$mn:0000375C ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:0000375C                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:0000375C ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:0000375C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:0000375C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:0000375C
.text$mn:0000375C var_4           = dword ptr -4
.text$mn:0000375C arg_0           = dword ptr  8
.text$mn:0000375C
.text$mn:0000375C                 push    ebp
.text$mn:0000375D                 mov     ebp, esp
.text$mn:0000375F                 push    ecx
.text$mn:00003760                 mov     [ebp+var_4], ecx
.text$mn:00003763                 mov     ecx, [ebp+arg_0]
.text$mn:00003766                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:0000376B                 mov     eax, [ebp+arg_0]
.text$mn:0000376E                 mov     esp, ebp
.text$mn:00003770                 pop     ebp
.text$mn:00003771                 retn    4
.text$mn:00003771 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00003771
.text$mn:00003771 _text$mn        ends
.text$mn:00003771
.text$mn:00003774 ; ===========================================================================
.text$mn:00003774
.text$mn:00003774 ; Segment type: Pure code
.text$mn:00003774 ; Segment permissions: Read/Execute
.text$mn:00003774 _text$mn        segment para public 'CODE' use32
.text$mn:00003774                 assume cs:_text$mn
.text$mn:00003774                 ;org 3774h
.text$mn:00003774 ; COMDAT (pick any)
.text$mn:00003774                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003774
.text$mn:00003774 ; =============== S U B R O U T I N E =======================================
.text$mn:00003774
.text$mn:00003774 ; Attributes: bp-based frame
.text$mn:00003774
.text$mn:00003774 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00003774                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00003774 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00003774                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00003774                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00003774
.text$mn:00003774 var_C           = dword ptr -0Ch
.text$mn:00003774 Size            = dword ptr -8
.text$mn:00003774 var_4           = dword ptr -4
.text$mn:00003774 arg_0           = dword ptr  8
.text$mn:00003774 arg_4           = byte ptr  0Ch
.text$mn:00003774
.text$mn:00003774                 push    ebp
.text$mn:00003775                 mov     ebp, esp
.text$mn:00003777                 sub     esp, 0Ch
.text$mn:0000377A                 mov     [ebp+var_4], ecx
.text$mn:0000377D                 mov     ecx, [ebp+var_4]
.text$mn:00003780                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00003785                 cmp     eax, [ebp+arg_0]
.text$mn:00003788                 jnb     short loc_3792
.text$mn:0000378A                 mov     ecx, [ebp+var_4]
.text$mn:0000378D                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00003792
.text$mn:00003792 loc_3792:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00003792                 mov     eax, [ebp+var_4]
.text$mn:00003795                 mov     ecx, [eax+18h]
.text$mn:00003798                 cmp     ecx, [ebp+arg_0]
.text$mn:0000379B                 jnb     short loc_37B2
.text$mn:0000379D                 mov     edx, [ebp+var_4]
.text$mn:000037A0                 mov     eax, [edx+14h]
.text$mn:000037A3                 push    eax
.text$mn:000037A4                 mov     ecx, [ebp+arg_0]
.text$mn:000037A7                 push    ecx
.text$mn:000037A8                 mov     ecx, [ebp+var_4]
.text$mn:000037AB                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:000037B0                 jmp     short loc_37FC
.text$mn:000037B2 ; ---------------------------------------------------------------------------
.text$mn:000037B2
.text$mn:000037B2 loc_37B2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:000037B2                 movzx   edx, [ebp+arg_4]
.text$mn:000037B6                 test    edx, edx
.text$mn:000037B8                 jz      short loc_37EC
.text$mn:000037BA                 cmp     [ebp+arg_0], 10h
.text$mn:000037BE                 jnb     short loc_37EC
.text$mn:000037C0                 mov     eax, [ebp+var_4]
.text$mn:000037C3                 mov     ecx, [ebp+arg_0]
.text$mn:000037C6                 cmp     ecx, [eax+14h]
.text$mn:000037C9                 jnb     short loc_37D3
.text$mn:000037CB                 mov     edx, [ebp+arg_0]
.text$mn:000037CE                 mov     [ebp+Size], edx
.text$mn:000037D1                 jmp     short loc_37DC
.text$mn:000037D3 ; ---------------------------------------------------------------------------
.text$mn:000037D3
.text$mn:000037D3 loc_37D3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:000037D3                 mov     eax, [ebp+var_4]
.text$mn:000037D6                 mov     ecx, [eax+14h]
.text$mn:000037D9                 mov     [ebp+Size], ecx
.text$mn:000037DC
.text$mn:000037DC loc_37DC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:000037DC                 mov     edx, [ebp+Size]
.text$mn:000037DF                 push    edx             ; Size
.text$mn:000037E0                 push    1               ; char
.text$mn:000037E2                 mov     ecx, [ebp+var_4]
.text$mn:000037E5                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000037EA                 jmp     short loc_37FC
.text$mn:000037EC ; ---------------------------------------------------------------------------
.text$mn:000037EC
.text$mn:000037EC loc_37EC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:000037EC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:000037EC                 cmp     [ebp+arg_0], 0
.text$mn:000037F0                 jnz     short loc_37FC
.text$mn:000037F2                 push    0
.text$mn:000037F4                 mov     ecx, [ebp+var_4]
.text$mn:000037F7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000037FC
.text$mn:000037FC loc_37FC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:000037FC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:000037FC                 cmp     [ebp+arg_0], 0
.text$mn:00003800                 jbe     short loc_380B
.text$mn:00003802                 mov     [ebp+var_C], 1
.text$mn:00003809                 jmp     short loc_3812
.text$mn:0000380B ; ---------------------------------------------------------------------------
.text$mn:0000380B
.text$mn:0000380B loc_380B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000380B                 mov     [ebp+var_C], 0
.text$mn:00003812
.text$mn:00003812 loc_3812:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00003812                 mov     al, byte ptr [ebp+var_C]
.text$mn:00003815                 mov     esp, ebp
.text$mn:00003817                 pop     ebp
.text$mn:00003818                 retn    8
.text$mn:00003818 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00003818
.text$mn:00003818 ; ---------------------------------------------------------------------------
.text$mn:0000381B                 align 4
.text$mn:0000381B _text$mn        ends
.text$mn:0000381B
.text$mn:0000381C ; ===========================================================================
.text$mn:0000381C
.text$mn:0000381C ; Segment type: Pure code
.text$mn:0000381C ; Segment permissions: Read/Execute
.text$mn:0000381C _text$mn        segment para public 'CODE' use32
.text$mn:0000381C                 assume cs:_text$mn
.text$mn:0000381C                 ;org 381Ch
.text$mn:0000381C ; COMDAT (pick any)
.text$mn:0000381C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000381C
.text$mn:0000381C ; =============== S U B R O U T I N E =======================================
.text$mn:0000381C
.text$mn:0000381C ; Attributes: bp-based frame
.text$mn:0000381C
.text$mn:0000381C ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:0000381C                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:0000381C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:0000381C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:0000381C
.text$mn:0000381C var_4           = dword ptr -4
.text$mn:0000381C arg_0           = dword ptr  8
.text$mn:0000381C
.text$mn:0000381C                 push    ebp
.text$mn:0000381D                 mov     ebp, esp
.text$mn:0000381F                 push    ecx
.text$mn:00003820                 mov     [ebp+var_4], ecx
.text$mn:00003823                 cmp     [ebp+arg_0], 0
.text$mn:00003827                 jz      short loc_3849
.text$mn:00003829                 mov     ecx, [ebp+var_4]
.text$mn:0000382C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003831                 cmp     [ebp+arg_0], eax
.text$mn:00003834                 jb      short loc_3849
.text$mn:00003836                 mov     ecx, [ebp+var_4]
.text$mn:00003839                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000383E                 mov     ecx, [ebp+var_4]
.text$mn:00003841                 add     eax, [ecx+14h]
.text$mn:00003844                 cmp     eax, [ebp+arg_0]
.text$mn:00003847                 ja      short loc_384F
.text$mn:00003849
.text$mn:00003849 loc_3849:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00003849                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00003849                 xor     al, al
.text$mn:0000384B                 jmp     short loc_3851
.text$mn:0000384D ; ---------------------------------------------------------------------------
.text$mn:0000384D                 jmp     short loc_3851
.text$mn:0000384F ; ---------------------------------------------------------------------------
.text$mn:0000384F
.text$mn:0000384F loc_384F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000384F                 mov     al, 1
.text$mn:00003851
.text$mn:00003851 loc_3851:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00003851                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00003851                 mov     esp, ebp
.text$mn:00003853                 pop     ebp
.text$mn:00003854                 retn    4
.text$mn:00003854 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00003854
.text$mn:00003854 ; ---------------------------------------------------------------------------
.text$mn:00003857                 align 4
.text$mn:00003857 _text$mn        ends
.text$mn:00003857
.text$mn:00003858 ; ===========================================================================
.text$mn:00003858
.text$mn:00003858 ; Segment type: Pure code
.text$mn:00003858 ; Segment permissions: Read/Execute
.text$mn:00003858 _text$mn        segment para public 'CODE' use32
.text$mn:00003858                 assume cs:_text$mn
.text$mn:00003858                 ;org 3858h
.text$mn:00003858 ; COMDAT (pick any)
.text$mn:00003858                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003858
.text$mn:00003858 ; =============== S U B R O U T I N E =======================================
.text$mn:00003858
.text$mn:00003858 ; Attributes: bp-based frame
.text$mn:00003858
.text$mn:00003858 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003858                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00003858 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00003858                                         ; CODE XREF: $LN19+14p
.text$mn:00003858                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00003858
.text$mn:00003858 var_8           = dword ptr -8
.text$mn:00003858 var_4           = dword ptr -4
.text$mn:00003858
.text$mn:00003858                 push    ebp
.text$mn:00003859                 mov     ebp, esp
.text$mn:0000385B                 sub     esp, 8
.text$mn:0000385E                 mov     [ebp+var_4], ecx
.text$mn:00003861                 mov     eax, [ebp+var_4]
.text$mn:00003864                 cmp     dword ptr [eax+18h], 10h
.text$mn:00003868                 jb      short loc_387E
.text$mn:0000386A                 mov     ecx, [ebp+var_4]
.text$mn:0000386D                 mov     edx, [ecx+4]
.text$mn:00003870                 push    edx
.text$mn:00003871                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00003876                 add     esp, 4
.text$mn:00003879                 mov     [ebp+var_8], eax
.text$mn:0000387C                 jmp     short loc_3887
.text$mn:0000387E ; ---------------------------------------------------------------------------
.text$mn:0000387E
.text$mn:0000387E loc_387E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000387E                 mov     eax, [ebp+var_4]
.text$mn:00003881                 add     eax, 4
.text$mn:00003884                 mov     [ebp+var_8], eax
.text$mn:00003887
.text$mn:00003887 loc_3887:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00003887                 mov     eax, [ebp+var_8]
.text$mn:0000388A                 mov     esp, ebp
.text$mn:0000388C                 pop     ebp
.text$mn:0000388D                 retn
.text$mn:0000388D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:0000388D
.text$mn:0000388D ; ---------------------------------------------------------------------------
.text$mn:0000388E                 align 10h
.text$mn:0000388E _text$mn        ends
.text$mn:0000388E
.text$mn:00003890 ; ===========================================================================
.text$mn:00003890
.text$mn:00003890 ; Segment type: Pure code
.text$mn:00003890 ; Segment permissions: Read/Execute
.text$mn:00003890 _text$mn        segment para public 'CODE' use32
.text$mn:00003890                 assume cs:_text$mn
.text$mn:00003890                 ;org 3890h
.text$mn:00003890 ; COMDAT (pick any)
.text$mn:00003890                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003890
.text$mn:00003890 ; =============== S U B R O U T I N E =======================================
.text$mn:00003890
.text$mn:00003890 ; Attributes: bp-based frame
.text$mn:00003890
.text$mn:00003890 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00003890                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00003890 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00003890                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00003890
.text$mn:00003890 var_8           = dword ptr -8
.text$mn:00003890 var_4           = dword ptr -4
.text$mn:00003890
.text$mn:00003890                 push    ebp
.text$mn:00003891                 mov     ebp, esp
.text$mn:00003893                 sub     esp, 8
.text$mn:00003896                 mov     [ebp+var_4], ecx
.text$mn:00003899                 mov     eax, [ebp+var_4]
.text$mn:0000389C                 cmp     dword ptr [eax+18h], 10h
.text$mn:000038A0                 jb      short loc_38B6
.text$mn:000038A2                 mov     ecx, [ebp+var_4]
.text$mn:000038A5                 mov     edx, [ecx+4]
.text$mn:000038A8                 push    edx
.text$mn:000038A9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000038AE                 add     esp, 4
.text$mn:000038B1                 mov     [ebp+var_8], eax
.text$mn:000038B4                 jmp     short loc_38BF
.text$mn:000038B6 ; ---------------------------------------------------------------------------
.text$mn:000038B6
.text$mn:000038B6 loc_38B6:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000038B6                 mov     eax, [ebp+var_4]
.text$mn:000038B9                 add     eax, 4
.text$mn:000038BC                 mov     [ebp+var_8], eax
.text$mn:000038BF
.text$mn:000038BF loc_38BF:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000038BF                 mov     eax, [ebp+var_8]
.text$mn:000038C2                 mov     esp, ebp
.text$mn:000038C4                 pop     ebp
.text$mn:000038C5                 retn
.text$mn:000038C5 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:000038C5
.text$mn:000038C5 ; ---------------------------------------------------------------------------
.text$mn:000038C6                 align 4
.text$mn:000038C6 _text$mn        ends
.text$mn:000038C6
.text$mn:000038C8 ; ===========================================================================
.text$mn:000038C8
.text$mn:000038C8 ; Segment type: Pure code
.text$mn:000038C8 ; Segment permissions: Read/Execute
.text$mn:000038C8 _text$mn        segment para public 'CODE' use32
.text$mn:000038C8                 assume cs:_text$mn
.text$mn:000038C8                 ;org 38C8h
.text$mn:000038C8 ; COMDAT (pick any)
.text$mn:000038C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038C8
.text$mn:000038C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000038C8
.text$mn:000038C8 ; Attributes: bp-based frame
.text$mn:000038C8
.text$mn:000038C8 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:000038C8                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000038C8 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:000038C8                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:000038C8                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:000038C8
.text$mn:000038C8 var_18          = byte ptr -18h
.text$mn:000038C8 var_14          = dword ptr -14h
.text$mn:000038C8 var_10          = dword ptr -10h
.text$mn:000038C8 var_C           = dword ptr -0Ch
.text$mn:000038C8 var_4           = dword ptr -4
.text$mn:000038C8
.text$mn:000038C8                 push    ebp
.text$mn:000038C9                 mov     ebp, esp
.text$mn:000038CB                 push    0FFFFFFFFh
.text$mn:000038CD                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000038D2                 mov     eax, large fs:0
.text$mn:000038D8                 push    eax
.text$mn:000038D9                 sub     esp, 0Ch
.text$mn:000038DC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000038E1                 xor     eax, ebp
.text$mn:000038E3                 push    eax
.text$mn:000038E4                 lea     eax, [ebp+var_C]
.text$mn:000038E7                 mov     large fs:0, eax
.text$mn:000038ED                 mov     [ebp+var_14], ecx
.text$mn:000038F0                 mov     eax, [ebp+var_14]
.text$mn:000038F3                 cmp     dword ptr [eax], 0
.text$mn:000038F6                 jz      short loc_3953
.text$mn:000038F8                 push    3               ; int
.text$mn:000038FA                 lea     ecx, [ebp+var_18] ; this
.text$mn:000038FD                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00003902                 mov     [ebp+var_4], 0
.text$mn:00003909                 mov     ecx, [ebp+var_14]
.text$mn:0000390C                 mov     edx, [ecx]
.text$mn:0000390E                 add     edx, 4
.text$mn:00003911                 mov     [ebp+var_10], edx
.text$mn:00003914                 jmp     short loc_3923
.text$mn:00003916 ; ---------------------------------------------------------------------------
.text$mn:00003916
.text$mn:00003916 loc_3916:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00003916                 mov     eax, [ebp+var_10]
.text$mn:00003919                 mov     ecx, [eax]
.text$mn:0000391B                 mov     edx, [ebp+var_10]
.text$mn:0000391E                 mov     eax, [ecx+4]
.text$mn:00003921                 mov     [edx], eax
.text$mn:00003923
.text$mn:00003923 loc_3923:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00003923                 mov     ecx, [ebp+var_10]
.text$mn:00003926                 cmp     dword ptr [ecx], 0
.text$mn:00003929                 jz      short loc_3938
.text$mn:0000392B                 mov     edx, [ebp+var_10]
.text$mn:0000392E                 mov     eax, [edx]
.text$mn:00003930                 mov     dword ptr [eax], 0
.text$mn:00003936                 jmp     short loc_3916
.text$mn:00003938 ; ---------------------------------------------------------------------------
.text$mn:00003938
.text$mn:00003938 loc_3938:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00003938                 mov     ecx, [ebp+var_14]
.text$mn:0000393B                 mov     edx, [ecx]
.text$mn:0000393D                 mov     dword ptr [edx+4], 0
.text$mn:00003944                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000394B                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000394E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00003953
.text$mn:00003953 loc_3953:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00003953                 mov     ecx, [ebp+var_C]
.text$mn:00003956                 mov     large fs:0, ecx
.text$mn:0000395D                 pop     ecx
.text$mn:0000395E                 mov     esp, ebp
.text$mn:00003960                 pop     ebp
.text$mn:00003961                 retn
.text$mn:00003961 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00003961
.text$mn:00003961 ; ---------------------------------------------------------------------------
.text$mn:00003962                 align 4
.text$mn:00003962 _text$mn        ends
.text$mn:00003962
.text$x:00003964 ; ===========================================================================
.text$x:00003964
.text$x:00003964 ; Segment type: Pure code
.text$x:00003964 ; Segment permissions: Read/Execute
.text$x:00003964 _text$x         segment para public 'CODE' use32
.text$x:00003964                 assume cs:_text$x
.text$x:00003964                 ;org 3964h
.text$x:00003964 ; COMDAT (pick associative to section at 38C8)
.text$x:00003964                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003964
.text$x:00003964 ; =============== S U B R O U T I N E =======================================
.text$x:00003964
.text$x:00003964
.text$x:00003964 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00003964                                         ; DATA XREF: .xdata$x:00004410o
.text$x:00003964                 lea     ecx, [ebp-18h]  ; this
.text$x:00003967                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00003967 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00003967
.text$x:0000396C
.text$x:0000396C ; =============== S U B R O U T I N E =======================================
.text$x:0000396C
.text$x:0000396C
.text$x:0000396C __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:0000396C                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:0000396C
.text$x:0000396C arg_4           = dword ptr  8
.text$x:0000396C
.text$x:0000396C                 mov     edx, [esp+arg_4]
.text$x:00003970                 lea     eax, [edx+0Ch]
.text$x:00003973                 mov     ecx, [edx-10h]
.text$x:00003976                 xor     ecx, eax
.text$x:00003978                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000397D                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00003982                 jmp     ___CxxFrameHandler3
.text$x:00003982 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00003982
.text$x:00003982 ; ---------------------------------------------------------------------------
.text$x:00003987                 align 4
.text$x:00003987 _text$x         ends
.text$x:00003987
.text$mn:00003988 ; ===========================================================================
.text$mn:00003988
.text$mn:00003988 ; Segment type: Pure code
.text$mn:00003988 ; Segment permissions: Read/Execute
.text$mn:00003988 _text$mn        segment para public 'CODE' use32
.text$mn:00003988                 assume cs:_text$mn
.text$mn:00003988                 ;org 3988h
.text$mn:00003988 ; COMDAT (pick any)
.text$mn:00003988                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003988
.text$mn:00003988 ; =============== S U B R O U T I N E =======================================
.text$mn:00003988
.text$mn:00003988 ; Attributes: bp-based frame
.text$mn:00003988
.text$mn:00003988 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00003988                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00003988 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00003988                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00003988                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00003988
.text$mn:00003988 var_C           = dword ptr -0Ch
.text$mn:00003988 var_8           = dword ptr -8
.text$mn:00003988 var_2           = byte ptr -2
.text$mn:00003988 var_1           = byte ptr -1
.text$mn:00003988 arg_0           = byte ptr  8
.text$mn:00003988 Size            = dword ptr  0Ch
.text$mn:00003988
.text$mn:00003988                 push    ebp
.text$mn:00003989                 mov     ebp, esp
.text$mn:0000398B                 sub     esp, 0Ch
.text$mn:0000398E                 mov     [ebp+var_8], ecx
.text$mn:00003991                 movzx   eax, [ebp+arg_0]
.text$mn:00003995                 test    eax, eax
.text$mn:00003997                 jnz     short loc_399B
.text$mn:00003999                 jmp     short loc_3A0E
.text$mn:0000399B ; ---------------------------------------------------------------------------
.text$mn:0000399B
.text$mn:0000399B loc_399B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000399B                 mov     ecx, [ebp+var_8]
.text$mn:0000399E                 cmp     dword ptr [ecx+18h], 10h
.text$mn:000039A2                 jb      short loc_3A0E
.text$mn:000039A4                 mov     edx, [ebp+var_8]
.text$mn:000039A7                 mov     eax, [edx+4]
.text$mn:000039AA                 mov     [ebp+var_C], eax
.text$mn:000039AD                 mov     ecx, [ebp+var_8]
.text$mn:000039B0                 add     ecx, 4
.text$mn:000039B3                 push    ecx
.text$mn:000039B4                 lea     edx, [ebp+var_1]
.text$mn:000039B7                 push    edx
.text$mn:000039B8                 mov     ecx, [ebp+var_8]
.text$mn:000039BB                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000039C0                 mov     ecx, eax
.text$mn:000039C2                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000039C7                 cmp     [ebp+Size], 0
.text$mn:000039CB                 jbe     short loc_39ED
.text$mn:000039CD                 mov     eax, [ebp+Size]
.text$mn:000039D0                 push    eax             ; Size
.text$mn:000039D1                 mov     ecx, [ebp+var_C]
.text$mn:000039D4                 push    ecx
.text$mn:000039D5                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000039DA                 add     esp, 4
.text$mn:000039DD                 push    eax             ; Src
.text$mn:000039DE                 mov     edx, [ebp+var_8]
.text$mn:000039E1                 add     edx, 4
.text$mn:000039E4                 push    edx             ; Dst
.text$mn:000039E5                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000039EA                 add     esp, 0Ch
.text$mn:000039ED
.text$mn:000039ED loc_39ED:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:000039ED                 mov     eax, [ebp+var_8]
.text$mn:000039F0                 mov     ecx, [eax+18h]
.text$mn:000039F3                 add     ecx, 1
.text$mn:000039F6                 push    ecx             ; int
.text$mn:000039F7                 mov     edx, [ebp+var_C]
.text$mn:000039FA                 push    edx             ; void *
.text$mn:000039FB                 lea     eax, [ebp+var_2]
.text$mn:000039FE                 push    eax
.text$mn:000039FF                 mov     ecx, [ebp+var_8]
.text$mn:00003A02                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003A07                 mov     ecx, eax
.text$mn:00003A09                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00003A0E
.text$mn:00003A0E loc_3A0E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00003A0E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00003A0E                 mov     ecx, [ebp+var_8]
.text$mn:00003A11                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00003A18                 mov     edx, [ebp+Size]
.text$mn:00003A1B                 push    edx
.text$mn:00003A1C                 mov     ecx, [ebp+var_8]
.text$mn:00003A1F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003A24                 mov     esp, ebp
.text$mn:00003A26                 pop     ebp
.text$mn:00003A27                 retn    8
.text$mn:00003A27 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00003A27
.text$mn:00003A27 ; ---------------------------------------------------------------------------
.text$mn:00003A2A                 align 4
.text$mn:00003A2A _text$mn        ends
.text$mn:00003A2A
.text$mn:00003A2C ; ===========================================================================
.text$mn:00003A2C
.text$mn:00003A2C ; Segment type: Pure code
.text$mn:00003A2C ; Segment permissions: Read/Execute
.text$mn:00003A2C _text$mn        segment para public 'CODE' use32
.text$mn:00003A2C                 assume cs:_text$mn
.text$mn:00003A2C                 ;org 3A2Ch
.text$mn:00003A2C ; COMDAT (pick any)
.text$mn:00003A2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A2C
.text$mn:00003A2C ; =============== S U B R O U T I N E =======================================
.text$mn:00003A2C
.text$mn:00003A2C ; Attributes: bp-based frame
.text$mn:00003A2C
.text$mn:00003A2C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00003A2C                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00003A2C ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00003A2C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00003A2C
.text$mn:00003A2C var_4           = dword ptr -4
.text$mn:00003A2C
.text$mn:00003A2C                 push    ebp
.text$mn:00003A2D                 mov     ebp, esp
.text$mn:00003A2F                 push    ecx
.text$mn:00003A30                 mov     [ebp+var_4], ecx
.text$mn:00003A33                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00003A38                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00003A3D                 mov     esp, ebp
.text$mn:00003A3F                 pop     ebp
.text$mn:00003A40                 retn
.text$mn:00003A40 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00003A40
.text$mn:00003A40 ; ---------------------------------------------------------------------------
.text$mn:00003A41                 align 4
.text$mn:00003A41 _text$mn        ends
.text$mn:00003A41
.text$mn:00003A44 ; ===========================================================================
.text$mn:00003A44
.text$mn:00003A44 ; Segment type: Pure code
.text$mn:00003A44 ; Segment permissions: Read/Execute
.text$mn:00003A44 _text$mn        segment para public 'CODE' use32
.text$mn:00003A44                 assume cs:_text$mn
.text$mn:00003A44                 ;org 3A44h
.text$mn:00003A44 ; COMDAT (pick any)
.text$mn:00003A44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A44
.text$mn:00003A44 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A44
.text$mn:00003A44 ; Attributes: bp-based frame
.text$mn:00003A44
.text$mn:00003A44 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00003A44                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00003A44 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00003A44                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00003A44                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00003A44
.text$mn:00003A44 var_4           = dword ptr -4
.text$mn:00003A44
.text$mn:00003A44                 push    ebp
.text$mn:00003A45                 mov     ebp, esp
.text$mn:00003A47                 push    ecx
.text$mn:00003A48                 mov     [ebp+var_4], ecx
.text$mn:00003A4B                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00003A50                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00003A55                 mov     esp, ebp
.text$mn:00003A57                 pop     ebp
.text$mn:00003A58                 retn
.text$mn:00003A58 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00003A58
.text$mn:00003A58 ; ---------------------------------------------------------------------------
.text$mn:00003A59                 align 4
.text$mn:00003A59 _text$mn        ends
.text$mn:00003A59
.text$mn:00003A5C ; ===========================================================================
.text$mn:00003A5C
.text$mn:00003A5C ; Segment type: Pure code
.text$mn:00003A5C ; Segment permissions: Read/Execute
.text$mn:00003A5C _text$mn        segment para public 'CODE' use32
.text$mn:00003A5C                 assume cs:_text$mn
.text$mn:00003A5C                 ;org 3A5Ch
.text$mn:00003A5C ; COMDAT (pick any)
.text$mn:00003A5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A5C
.text$mn:00003A5C ; =============== S U B R O U T I N E =======================================
.text$mn:00003A5C
.text$mn:00003A5C ; Attributes: bp-based frame
.text$mn:00003A5C
.text$mn:00003A5C ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00003A5C                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00003A5C ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00003A5C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00003A5C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00003A5C
.text$mn:00003A5C var_4           = dword ptr -4
.text$mn:00003A5C arg_0           = dword ptr  8
.text$mn:00003A5C
.text$mn:00003A5C                 push    ebp
.text$mn:00003A5D                 mov     ebp, esp
.text$mn:00003A5F                 push    ecx
.text$mn:00003A60                 mov     [ebp+var_4], ecx
.text$mn:00003A63                 mov     eax, [ebp+arg_0]
.text$mn:00003A66                 push    eax
.text$mn:00003A67                 mov     ecx, [ebp+var_4]
.text$mn:00003A6A                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00003A6F                 mov     esp, ebp
.text$mn:00003A71                 pop     ebp
.text$mn:00003A72                 retn    4
.text$mn:00003A72 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00003A72
.text$mn:00003A72 ; ---------------------------------------------------------------------------
.text$mn:00003A75                 align 4
.text$mn:00003A75 _text$mn        ends
.text$mn:00003A75
.text$mn:00003A78 ; ===========================================================================
.text$mn:00003A78
.text$mn:00003A78 ; Segment type: Pure code
.text$mn:00003A78 ; Segment permissions: Read/Execute
.text$mn:00003A78 _text$mn        segment para public 'CODE' use32
.text$mn:00003A78                 assume cs:_text$mn
.text$mn:00003A78                 ;org 3A78h
.text$mn:00003A78 ; COMDAT (pick any)
.text$mn:00003A78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A78
.text$mn:00003A78 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A78
.text$mn:00003A78 ; Attributes: bp-based frame
.text$mn:00003A78
.text$mn:00003A78 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00003A78                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00003A78 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00003A78                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00003A78
.text$mn:00003A78 var_4           = dword ptr -4
.text$mn:00003A78 arg_0           = dword ptr  8
.text$mn:00003A78
.text$mn:00003A78                 push    ebp
.text$mn:00003A79                 mov     ebp, esp
.text$mn:00003A7B                 push    ecx
.text$mn:00003A7C                 mov     [ebp+var_4], ecx
.text$mn:00003A7F                 push    0
.text$mn:00003A81                 mov     eax, [ebp+arg_0]
.text$mn:00003A84                 push    eax
.text$mn:00003A85                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00003A8A                 add     esp, 8
.text$mn:00003A8D                 mov     esp, ebp
.text$mn:00003A8F                 pop     ebp
.text$mn:00003A90                 retn    4
.text$mn:00003A90 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00003A90
.text$mn:00003A90 ; ---------------------------------------------------------------------------
.text$mn:00003A93                 align 4
.text$mn:00003A93 _text$mn        ends
.text$mn:00003A93
.text$mn:00003A94 ; ===========================================================================
.text$mn:00003A94
.text$mn:00003A94 ; Segment type: Pure code
.text$mn:00003A94 ; Segment permissions: Read/Execute
.text$mn:00003A94 _text$mn        segment para public 'CODE' use32
.text$mn:00003A94                 assume cs:_text$mn
.text$mn:00003A94                 ;org 3A94h
.text$mn:00003A94 ; COMDAT (pick any)
.text$mn:00003A94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A94
.text$mn:00003A94 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A94
.text$mn:00003A94 ; Attributes: bp-based frame
.text$mn:00003A94
.text$mn:00003A94 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00003A94                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00003A94 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00003A94                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00003A94
.text$mn:00003A94 var_4           = dword ptr -4
.text$mn:00003A94 arg_0           = dword ptr  8
.text$mn:00003A94
.text$mn:00003A94                 push    ebp
.text$mn:00003A95                 mov     ebp, esp
.text$mn:00003A97                 push    ecx
.text$mn:00003A98                 mov     [ebp+var_4], ecx
.text$mn:00003A9B                 push    0
.text$mn:00003A9D                 mov     eax, [ebp+arg_0]
.text$mn:00003AA0                 push    eax
.text$mn:00003AA1                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00003AA6                 add     esp, 8
.text$mn:00003AA9                 mov     esp, ebp
.text$mn:00003AAB                 pop     ebp
.text$mn:00003AAC                 retn    4
.text$mn:00003AAC ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00003AAC
.text$mn:00003AAC ; ---------------------------------------------------------------------------
.text$mn:00003AAF                 align 10h
.text$mn:00003AAF _text$mn        ends
.text$mn:00003AAF
.text$mn:00003AB0 ; ===========================================================================
.text$mn:00003AB0
.text$mn:00003AB0 ; Segment type: Pure code
.text$mn:00003AB0 ; Segment permissions: Read/Execute
.text$mn:00003AB0 _text$mn        segment para public 'CODE' use32
.text$mn:00003AB0                 assume cs:_text$mn
.text$mn:00003AB0                 ;org 3AB0h
.text$mn:00003AB0 ; COMDAT (pick any)
.text$mn:00003AB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003AB0
.text$mn:00003AB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AB0
.text$mn:00003AB0 ; Attributes: bp-based frame
.text$mn:00003AB0
.text$mn:00003AB0 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00003AB0                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00003AB0 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00003AB0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00003AB0
.text$mn:00003AB0 Size            = dword ptr -8
.text$mn:00003AB0 var_4           = dword ptr -4
.text$mn:00003AB0 arg_0           = dword ptr  8
.text$mn:00003AB0 arg_4           = dword ptr  0Ch
.text$mn:00003AB0 arg_8           = dword ptr  10h
.text$mn:00003AB0
.text$mn:00003AB0                 push    ebp
.text$mn:00003AB1                 mov     ebp, esp
.text$mn:00003AB3                 sub     esp, 8
.text$mn:00003AB6                 mov     [ebp+var_4], ecx
.text$mn:00003AB9                 mov     ecx, [ebp+arg_0]
.text$mn:00003ABC                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00003AC1                 cmp     eax, [ebp+arg_4]
.text$mn:00003AC4                 jnb     short loc_3ACE
.text$mn:00003AC6                 mov     ecx, [ebp+var_4]
.text$mn:00003AC9                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00003ACE
.text$mn:00003ACE loc_3ACE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00003ACE                 mov     ecx, [ebp+arg_0]
.text$mn:00003AD1                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00003AD6                 sub     eax, [ebp+arg_4]
.text$mn:00003AD9                 mov     [ebp+Size], eax
.text$mn:00003ADC                 mov     eax, [ebp+arg_8]
.text$mn:00003ADF                 cmp     eax, [ebp+Size]
.text$mn:00003AE2                 jnb     short loc_3AEA
.text$mn:00003AE4                 mov     ecx, [ebp+arg_8]
.text$mn:00003AE7                 mov     [ebp+Size], ecx
.text$mn:00003AEA
.text$mn:00003AEA loc_3AEA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00003AEA                 mov     edx, [ebp+var_4]
.text$mn:00003AED                 cmp     edx, [ebp+arg_0]
.text$mn:00003AF0                 jnz     short loc_3B11
.text$mn:00003AF2                 mov     eax, [ebp+arg_4]
.text$mn:00003AF5                 add     eax, [ebp+Size]
.text$mn:00003AF8                 push    eax
.text$mn:00003AF9                 mov     ecx, [ebp+var_4]
.text$mn:00003AFC                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00003B01                 mov     ecx, [ebp+arg_4]
.text$mn:00003B04                 push    ecx
.text$mn:00003B05                 push    0
.text$mn:00003B07                 mov     ecx, [ebp+var_4]
.text$mn:00003B0A                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00003B0F                 jmp     short loc_3B53
.text$mn:00003B11 ; ---------------------------------------------------------------------------
.text$mn:00003B11
.text$mn:00003B11 loc_3B11:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00003B11                 push    0
.text$mn:00003B13                 mov     edx, [ebp+Size]
.text$mn:00003B16                 push    edx
.text$mn:00003B17                 mov     ecx, [ebp+var_4]
.text$mn:00003B1A                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00003B1F                 movzx   eax, al
.text$mn:00003B22                 test    eax, eax
.text$mn:00003B24                 jz      short loc_3B53
.text$mn:00003B26                 mov     ecx, [ebp+Size]
.text$mn:00003B29                 push    ecx             ; Size
.text$mn:00003B2A                 mov     ecx, [ebp+arg_0]
.text$mn:00003B2D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003B32                 add     eax, [ebp+arg_4]
.text$mn:00003B35                 push    eax             ; Src
.text$mn:00003B36                 mov     ecx, [ebp+var_4]
.text$mn:00003B39                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003B3E                 push    eax             ; Dst
.text$mn:00003B3F                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00003B44                 add     esp, 0Ch
.text$mn:00003B47                 mov     edx, [ebp+Size]
.text$mn:00003B4A                 push    edx
.text$mn:00003B4B                 mov     ecx, [ebp+var_4]
.text$mn:00003B4E                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003B53
.text$mn:00003B53 loc_3B53:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00003B53                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00003B53                 mov     eax, [ebp+var_4]
.text$mn:00003B56                 mov     esp, ebp
.text$mn:00003B58                 pop     ebp
.text$mn:00003B59                 retn    0Ch
.text$mn:00003B59 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00003B59
.text$mn:00003B59 _text$mn        ends
.text$mn:00003B59
.text$mn:00003B5C ; ===========================================================================
.text$mn:00003B5C
.text$mn:00003B5C ; Segment type: Pure code
.text$mn:00003B5C ; Segment permissions: Read/Execute
.text$mn:00003B5C _text$mn        segment para public 'CODE' use32
.text$mn:00003B5C                 assume cs:_text$mn
.text$mn:00003B5C                 ;org 3B5Ch
.text$mn:00003B5C ; COMDAT (pick any)
.text$mn:00003B5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B5C
.text$mn:00003B5C ; =============== S U B R O U T I N E =======================================
.text$mn:00003B5C
.text$mn:00003B5C ; Attributes: bp-based frame
.text$mn:00003B5C
.text$mn:00003B5C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00003B5C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00003B5C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00003B5C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00003B5C
.text$mn:00003B5C var_4           = dword ptr -4
.text$mn:00003B5C Str             = dword ptr  8
.text$mn:00003B5C
.text$mn:00003B5C                 push    ebp
.text$mn:00003B5D                 mov     ebp, esp
.text$mn:00003B5F                 push    ecx
.text$mn:00003B60                 mov     [ebp+var_4], ecx
.text$mn:00003B63                 push    490h            ; unsigned int
.text$mn:00003B68                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003B6D                 mov     eax, [ebp+Str]
.text$mn:00003B70                 push    eax             ; int
.text$mn:00003B71                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00003B76                 add     esp, 0Ch
.text$mn:00003B79                 mov     ecx, [ebp+Str]
.text$mn:00003B7C                 push    ecx             ; Str
.text$mn:00003B7D                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00003B82                 add     esp, 4
.text$mn:00003B85                 push    eax             ; Size
.text$mn:00003B86                 mov     edx, [ebp+Str]
.text$mn:00003B89                 push    edx             ; Src
.text$mn:00003B8A                 mov     ecx, [ebp+var_4]
.text$mn:00003B8D                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00003B92                 mov     esp, ebp
.text$mn:00003B94                 pop     ebp
.text$mn:00003B95                 retn    4
.text$mn:00003B95 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00003B95
.text$mn:00003B95 _text$mn        ends
.text$mn:00003B95
.text$mn:00003B98 ; ===========================================================================
.text$mn:00003B98
.text$mn:00003B98 ; Segment type: Pure code
.text$mn:00003B98 ; Segment permissions: Read/Execute
.text$mn:00003B98 _text$mn        segment para public 'CODE' use32
.text$mn:00003B98                 assume cs:_text$mn
.text$mn:00003B98                 ;org 3B98h
.text$mn:00003B98 ; COMDAT (pick any)
.text$mn:00003B98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B98
.text$mn:00003B98 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B98
.text$mn:00003B98 ; Attributes: bp-based frame
.text$mn:00003B98
.text$mn:00003B98 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00003B98                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00003B98 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00003B98                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00003B98
.text$mn:00003B98 var_4           = dword ptr -4
.text$mn:00003B98 Src             = dword ptr  8
.text$mn:00003B98 Size            = dword ptr  0Ch
.text$mn:00003B98
.text$mn:00003B98                 push    ebp
.text$mn:00003B99                 mov     ebp, esp
.text$mn:00003B9B                 push    ecx
.text$mn:00003B9C                 mov     [ebp+var_4], ecx
.text$mn:00003B9F                 cmp     [ebp+Size], 0
.text$mn:00003BA3                 jz      short loc_3BBB
.text$mn:00003BA5                 push    47Fh            ; unsigned int
.text$mn:00003BAA                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003BAF                 mov     eax, [ebp+Src]
.text$mn:00003BB2                 push    eax             ; int
.text$mn:00003BB3                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00003BB8                 add     esp, 0Ch
.text$mn:00003BBB
.text$mn:00003BBB loc_3BBB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00003BBB                 mov     ecx, [ebp+Src]
.text$mn:00003BBE                 push    ecx
.text$mn:00003BBF                 mov     ecx, [ebp+var_4]
.text$mn:00003BC2                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00003BC7                 movzx   edx, al
.text$mn:00003BCA                 test    edx, edx
.text$mn:00003BCC                 jz      short loc_3BEE
.text$mn:00003BCE                 mov     eax, [ebp+Size]
.text$mn:00003BD1                 push    eax
.text$mn:00003BD2                 mov     ecx, [ebp+var_4]
.text$mn:00003BD5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003BDA                 mov     ecx, [ebp+Src]
.text$mn:00003BDD                 sub     ecx, eax
.text$mn:00003BDF                 push    ecx
.text$mn:00003BE0                 mov     edx, [ebp+var_4]
.text$mn:00003BE3                 push    edx
.text$mn:00003BE4                 mov     ecx, [ebp+var_4]
.text$mn:00003BE7                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00003BEC                 jmp     short loc_3C2B
.text$mn:00003BEE ; ---------------------------------------------------------------------------
.text$mn:00003BEE
.text$mn:00003BEE loc_3BEE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00003BEE                 push    0
.text$mn:00003BF0                 mov     eax, [ebp+Size]
.text$mn:00003BF3                 push    eax
.text$mn:00003BF4                 mov     ecx, [ebp+var_4]
.text$mn:00003BF7                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00003BFC                 movzx   ecx, al
.text$mn:00003BFF                 test    ecx, ecx
.text$mn:00003C01                 jz      short loc_3C28
.text$mn:00003C03                 mov     edx, [ebp+Size]
.text$mn:00003C06                 push    edx             ; Size
.text$mn:00003C07                 mov     eax, [ebp+Src]
.text$mn:00003C0A                 push    eax             ; Src
.text$mn:00003C0B                 mov     ecx, [ebp+var_4]
.text$mn:00003C0E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003C13                 push    eax             ; Dst
.text$mn:00003C14                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00003C19                 add     esp, 0Ch
.text$mn:00003C1C                 mov     ecx, [ebp+Size]
.text$mn:00003C1F                 push    ecx
.text$mn:00003C20                 mov     ecx, [ebp+var_4]
.text$mn:00003C23                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003C28
.text$mn:00003C28 loc_3C28:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00003C28                 mov     eax, [ebp+var_4]
.text$mn:00003C2B
.text$mn:00003C2B loc_3C2B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00003C2B                 mov     esp, ebp
.text$mn:00003C2D                 pop     ebp
.text$mn:00003C2E                 retn    8
.text$mn:00003C2E ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00003C2E
.text$mn:00003C2E ; ---------------------------------------------------------------------------
.text$mn:00003C31                 align 4
.text$mn:00003C31 _text$mn        ends
.text$mn:00003C31
.text$mn:00003C34 ; ===========================================================================
.text$mn:00003C34
.text$mn:00003C34 ; Segment type: Pure code
.text$mn:00003C34 ; Segment permissions: Read/Execute
.text$mn:00003C34 _text$mn        segment para public 'CODE' use32
.text$mn:00003C34                 assume cs:_text$mn
.text$mn:00003C34                 ;org 3C34h
.text$mn:00003C34 ; COMDAT (pick any)
.text$mn:00003C34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C34
.text$mn:00003C34 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C34
.text$mn:00003C34 ; Attributes: bp-based frame
.text$mn:00003C34
.text$mn:00003C34 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00003C34                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00003C34 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00003C34                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00003C34
.text$mn:00003C34 arg_0           = dword ptr  8
.text$mn:00003C34 arg_4           = dword ptr  0Ch
.text$mn:00003C34
.text$mn:00003C34                 push    ebp
.text$mn:00003C35                 mov     ebp, esp
.text$mn:00003C37                 mov     eax, [ebp+arg_0]
.text$mn:00003C3A                 mov     ecx, [ebp+arg_4]
.text$mn:00003C3D                 mov     dl, [ecx]
.text$mn:00003C3F                 mov     [eax], dl
.text$mn:00003C41                 pop     ebp
.text$mn:00003C42                 retn
.text$mn:00003C42 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00003C42
.text$mn:00003C42 ; ---------------------------------------------------------------------------
.text$mn:00003C43                 align 4
.text$mn:00003C43 _text$mn        ends
.text$mn:00003C43
.text$mn:00003C44 ; ===========================================================================
.text$mn:00003C44
.text$mn:00003C44 ; Segment type: Pure code
.text$mn:00003C44 ; Segment permissions: Read/Execute
.text$mn:00003C44 _text$mn        segment para public 'CODE' use32
.text$mn:00003C44                 assume cs:_text$mn
.text$mn:00003C44                 ;org 3C44h
.text$mn:00003C44 ; COMDAT (pick any)
.text$mn:00003C44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C44
.text$mn:00003C44 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C44
.text$mn:00003C44 ; Attributes: bp-based frame
.text$mn:00003C44
.text$mn:00003C44 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00003C44                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00003C44 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00003C44                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00003C44
.text$mn:00003C44 var_4           = dword ptr -4
.text$mn:00003C44
.text$mn:00003C44                 push    ebp
.text$mn:00003C45                 mov     ebp, esp
.text$mn:00003C47                 push    ecx
.text$mn:00003C48                 mov     [ebp+var_4], ecx
.text$mn:00003C4B                 mov     eax, [ebp+var_4]
.text$mn:00003C4E                 mov     eax, [eax+4]
.text$mn:00003C51                 mov     esp, ebp
.text$mn:00003C53                 pop     ebp
.text$mn:00003C54                 retn
.text$mn:00003C54 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00003C54
.text$mn:00003C54 ; ---------------------------------------------------------------------------
.text$mn:00003C55                 align 4
.text$mn:00003C55 _text$mn        ends
.text$mn:00003C55
.text$mn:00003C58 ; ===========================================================================
.text$mn:00003C58
.text$mn:00003C58 ; Segment type: Pure code
.text$mn:00003C58 ; Segment permissions: Read/Execute
.text$mn:00003C58 _text$mn        segment para public 'CODE' use32
.text$mn:00003C58                 assume cs:_text$mn
.text$mn:00003C58                 ;org 3C58h
.text$mn:00003C58 ; COMDAT (pick any)
.text$mn:00003C58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C58
.text$mn:00003C58 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C58
.text$mn:00003C58 ; Attributes: bp-based frame
.text$mn:00003C58
.text$mn:00003C58 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00003C58                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00003C58 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00003C58                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00003C58                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00003C58
.text$mn:00003C58 var_4           = dword ptr -4
.text$mn:00003C58
.text$mn:00003C58                 push    ebp
.text$mn:00003C59                 mov     ebp, esp
.text$mn:00003C5B                 push    ecx
.text$mn:00003C5C                 mov     [ebp+var_4], ecx
.text$mn:00003C5F                 mov     eax, [ebp+var_4]
.text$mn:00003C62                 mov     eax, [eax+4]
.text$mn:00003C65                 mov     esp, ebp
.text$mn:00003C67                 pop     ebp
.text$mn:00003C68                 retn
.text$mn:00003C68 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00003C68
.text$mn:00003C68 ; ---------------------------------------------------------------------------
.text$mn:00003C69                 align 4
.text$mn:00003C69 _text$mn        ends
.text$mn:00003C69
.text$mn:00003C6C ; ===========================================================================
.text$mn:00003C6C
.text$mn:00003C6C ; Segment type: Pure code
.text$mn:00003C6C ; Segment permissions: Read/Execute
.text$mn:00003C6C _text$mn        segment para public 'CODE' use32
.text$mn:00003C6C                 assume cs:_text$mn
.text$mn:00003C6C                 ;org 3C6Ch
.text$mn:00003C6C ; COMDAT (pick any)
.text$mn:00003C6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C6C
.text$mn:00003C6C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C6C
.text$mn:00003C6C ; Attributes: bp-based frame
.text$mn:00003C6C
.text$mn:00003C6C ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00003C6C                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00003C6C ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00003C6C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00003C6C
.text$mn:00003C6C var_4           = dword ptr -4
.text$mn:00003C6C Dst             = dword ptr  8
.text$mn:00003C6C Src             = dword ptr  0Ch
.text$mn:00003C6C Size            = dword ptr  10h
.text$mn:00003C6C
.text$mn:00003C6C                 push    ebp
.text$mn:00003C6D                 mov     ebp, esp
.text$mn:00003C6F                 push    ecx
.text$mn:00003C70                 cmp     [ebp+Size], 0
.text$mn:00003C74                 jnz     short loc_3C7E
.text$mn:00003C76                 mov     eax, [ebp+Dst]
.text$mn:00003C79                 mov     [ebp+var_4], eax
.text$mn:00003C7C                 jmp     short loc_3C95
.text$mn:00003C7E ; ---------------------------------------------------------------------------
.text$mn:00003C7E
.text$mn:00003C7E loc_3C7E:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00003C7E                 mov     ecx, [ebp+Size]
.text$mn:00003C81                 push    ecx             ; Size
.text$mn:00003C82                 mov     edx, [ebp+Src]
.text$mn:00003C85                 push    edx             ; Src
.text$mn:00003C86                 mov     eax, [ebp+Dst]
.text$mn:00003C89                 push    eax             ; Dst
.text$mn:00003C8A                 call    _memcpy
.text$mn:00003C8F                 add     esp, 0Ch
.text$mn:00003C92                 mov     [ebp+var_4], eax
.text$mn:00003C95
.text$mn:00003C95 loc_3C95:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00003C95                 mov     eax, [ebp+var_4]
.text$mn:00003C98                 mov     esp, ebp
.text$mn:00003C9A                 pop     ebp
.text$mn:00003C9B                 retn
.text$mn:00003C9B ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00003C9B
.text$mn:00003C9B _text$mn        ends
.text$mn:00003C9B
.text$mn:00003C9C ; ===========================================================================
.text$mn:00003C9C
.text$mn:00003C9C ; Segment type: Pure code
.text$mn:00003C9C ; Segment permissions: Read/Execute
.text$mn:00003C9C _text$mn        segment para public 'CODE' use32
.text$mn:00003C9C                 assume cs:_text$mn
.text$mn:00003C9C                 ;org 3C9Ch
.text$mn:00003C9C ; COMDAT (pick any)
.text$mn:00003C9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C9C
.text$mn:00003C9C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C9C
.text$mn:00003C9C ; Attributes: bp-based frame
.text$mn:00003C9C
.text$mn:00003C9C ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00003C9C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00003C9C ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00003C9C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00003C9C
.text$mn:00003C9C var_4           = dword ptr -4
.text$mn:00003C9C arg_0           = dword ptr  8
.text$mn:00003C9C arg_4           = dword ptr  0Ch
.text$mn:00003C9C
.text$mn:00003C9C                 push    ebp
.text$mn:00003C9D                 mov     ebp, esp
.text$mn:00003C9F                 push    ecx
.text$mn:00003CA0                 mov     [ebp+var_4], ecx
.text$mn:00003CA3                 mov     eax, [ebp+arg_4]
.text$mn:00003CA6                 push    eax             ; int
.text$mn:00003CA7                 mov     ecx, [ebp+arg_0]
.text$mn:00003CAA                 push    ecx             ; void *
.text$mn:00003CAB                 mov     ecx, [ebp+var_4]
.text$mn:00003CAE                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00003CB3                 mov     esp, ebp
.text$mn:00003CB5                 pop     ebp
.text$mn:00003CB6                 retn    8
.text$mn:00003CB6 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00003CB6
.text$mn:00003CB6 ; ---------------------------------------------------------------------------
.text$mn:00003CB9                 align 4
.text$mn:00003CB9 _text$mn        ends
.text$mn:00003CB9
.text$mn:00003CBC ; ===========================================================================
.text$mn:00003CBC
.text$mn:00003CBC ; Segment type: Pure code
.text$mn:00003CBC ; Segment permissions: Read/Execute
.text$mn:00003CBC _text$mn        segment para public 'CODE' use32
.text$mn:00003CBC                 assume cs:_text$mn
.text$mn:00003CBC                 ;org 3CBCh
.text$mn:00003CBC ; COMDAT (pick any)
.text$mn:00003CBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CBC
.text$mn:00003CBC ; =============== S U B R O U T I N E =======================================
.text$mn:00003CBC
.text$mn:00003CBC ; Attributes: bp-based frame
.text$mn:00003CBC
.text$mn:00003CBC ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00003CBC                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00003CBC ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00003CBC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00003CBC
.text$mn:00003CBC var_4           = dword ptr -4
.text$mn:00003CBC arg_0           = dword ptr  8
.text$mn:00003CBC
.text$mn:00003CBC                 push    ebp
.text$mn:00003CBD                 mov     ebp, esp
.text$mn:00003CBF                 push    ecx
.text$mn:00003CC0                 mov     [ebp+var_4], ecx
.text$mn:00003CC3                 mov     eax, [ebp+arg_0]
.text$mn:00003CC6                 push    eax             ; void *
.text$mn:00003CC7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003CCC                 add     esp, 4
.text$mn:00003CCF                 mov     esp, ebp
.text$mn:00003CD1                 pop     ebp
.text$mn:00003CD2                 retn    8
.text$mn:00003CD2 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00003CD2
.text$mn:00003CD2 ; ---------------------------------------------------------------------------
.text$mn:00003CD5                 align 4
.text$mn:00003CD5 _text$mn        ends
.text$mn:00003CD5
.text$mn:00003CD8 ; ===========================================================================
.text$mn:00003CD8
.text$mn:00003CD8 ; Segment type: Pure code
.text$mn:00003CD8 ; Segment permissions: Read/Execute
.text$mn:00003CD8 _text$mn        segment para public 'CODE' use32
.text$mn:00003CD8                 assume cs:_text$mn
.text$mn:00003CD8                 ;org 3CD8h
.text$mn:00003CD8 ; COMDAT (pick any)
.text$mn:00003CD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CD8
.text$mn:00003CD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CD8
.text$mn:00003CD8 ; Attributes: bp-based frame
.text$mn:00003CD8
.text$mn:00003CD8 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00003CD8                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00003CD8 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00003CD8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00003CD8
.text$mn:00003CD8 var_4           = dword ptr -4
.text$mn:00003CD8 arg_0           = dword ptr  8
.text$mn:00003CD8
.text$mn:00003CD8                 push    ebp
.text$mn:00003CD9                 mov     ebp, esp
.text$mn:00003CDB                 push    ecx
.text$mn:00003CDC                 mov     [ebp+var_4], ecx
.text$mn:00003CDF                 mov     eax, [ebp+arg_0]
.text$mn:00003CE2                 push    eax             ; void *
.text$mn:00003CE3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003CE8                 add     esp, 4
.text$mn:00003CEB                 mov     esp, ebp
.text$mn:00003CED                 pop     ebp
.text$mn:00003CEE                 retn    8
.text$mn:00003CEE ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00003CEE
.text$mn:00003CEE ; ---------------------------------------------------------------------------
.text$mn:00003CF1                 align 4
.text$mn:00003CF1 _text$mn        ends
.text$mn:00003CF1
.text$mn:00003CF4 ; ===========================================================================
.text$mn:00003CF4
.text$mn:00003CF4 ; Segment type: Pure code
.text$mn:00003CF4 ; Segment permissions: Read/Execute
.text$mn:00003CF4 _text$mn        segment para public 'CODE' use32
.text$mn:00003CF4                 assume cs:_text$mn
.text$mn:00003CF4                 ;org 3CF4h
.text$mn:00003CF4 ; COMDAT (pick any)
.text$mn:00003CF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CF4
.text$mn:00003CF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CF4
.text$mn:00003CF4 ; Attributes: bp-based frame
.text$mn:00003CF4
.text$mn:00003CF4 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00003CF4                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00003CF4 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00003CF4                                         ; DATA XREF: .rdata:00004970o
.text$mn:00003CF4
.text$mn:00003CF4 var_4           = dword ptr -4
.text$mn:00003CF4 arg_0           = dword ptr  8
.text$mn:00003CF4 arg_4           = dword ptr  0Ch
.text$mn:00003CF4
.text$mn:00003CF4                 push    ebp
.text$mn:00003CF5                 mov     ebp, esp
.text$mn:00003CF7                 push    ecx
.text$mn:00003CF8                 mov     [ebp+var_4], ecx
.text$mn:00003CFB                 mov     eax, [ebp+arg_4]
.text$mn:00003CFE                 push    eax             ; int
.text$mn:00003CFF                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00003D04                 add     esp, 4
.text$mn:00003D07                 test    eax, eax
.text$mn:00003D09                 jz      short loc_3D24
.text$mn:00003D0B                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00003D10                 push    eax             ; struct std::error_category *
.text$mn:00003D11                 mov     ecx, [ebp+arg_4]
.text$mn:00003D14                 push    ecx             ; int
.text$mn:00003D15                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003D18                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00003D1D                 mov     eax, [ebp+arg_0]
.text$mn:00003D20                 jmp     short loc_3D39
.text$mn:00003D22 ; ---------------------------------------------------------------------------
.text$mn:00003D22                 jmp     short loc_3D39
.text$mn:00003D24 ; ---------------------------------------------------------------------------
.text$mn:00003D24
.text$mn:00003D24 loc_3D24:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00003D24                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00003D29                 push    eax             ; struct std::error_category *
.text$mn:00003D2A                 mov     edx, [ebp+arg_4]
.text$mn:00003D2D                 push    edx             ; int
.text$mn:00003D2E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003D31                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00003D36                 mov     eax, [ebp+arg_0]
.text$mn:00003D39
.text$mn:00003D39 loc_3D39:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00003D39                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00003D39                 mov     esp, ebp
.text$mn:00003D3B                 pop     ebp
.text$mn:00003D3C                 retn    8
.text$mn:00003D3C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00003D3C
.text$mn:00003D3C ; ---------------------------------------------------------------------------
.text$mn:00003D3F                 align 10h
.text$mn:00003D3F _text$mn        ends
.text$mn:00003D3F
.text$mn:00003D40 ; ===========================================================================
.text$mn:00003D40
.text$mn:00003D40 ; Segment type: Pure code
.text$mn:00003D40 ; Segment permissions: Read/Execute
.text$mn:00003D40 _text$mn        segment para public 'CODE' use32
.text$mn:00003D40                 assume cs:_text$mn
.text$mn:00003D40                 ;org 3D40h
.text$mn:00003D40 ; COMDAT (pick any)
.text$mn:00003D40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D40
.text$mn:00003D40 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D40
.text$mn:00003D40 ; Attributes: bp-based frame
.text$mn:00003D40
.text$mn:00003D40 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00003D40                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00003D40 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00003D40                                         ; DATA XREF: .rdata:000048E0o
.text$mn:00003D40                                         ; .rdata:000048FCo ...
.text$mn:00003D40
.text$mn:00003D40 var_4           = dword ptr -4
.text$mn:00003D40 arg_0           = dword ptr  8
.text$mn:00003D40 arg_4           = dword ptr  0Ch
.text$mn:00003D40
.text$mn:00003D40                 push    ebp
.text$mn:00003D41                 mov     ebp, esp
.text$mn:00003D43                 push    ecx
.text$mn:00003D44                 mov     [ebp+var_4], ecx
.text$mn:00003D47                 mov     eax, [ebp+var_4]
.text$mn:00003D4A                 push    eax             ; struct std::error_category *
.text$mn:00003D4B                 mov     ecx, [ebp+arg_4]
.text$mn:00003D4E                 push    ecx             ; int
.text$mn:00003D4F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003D52                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00003D57                 mov     eax, [ebp+arg_0]
.text$mn:00003D5A                 mov     esp, ebp
.text$mn:00003D5C                 pop     ebp
.text$mn:00003D5D                 retn    8
.text$mn:00003D5D ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00003D5D
.text$mn:00003D5D _text$mn        ends
.text$mn:00003D5D
.text$mn:00003D60 ; ===========================================================================
.text$mn:00003D60
.text$mn:00003D60 ; Segment type: Pure code
.text$mn:00003D60 ; Segment permissions: Read/Execute
.text$mn:00003D60 _text$mn        segment para public 'CODE' use32
.text$mn:00003D60                 assume cs:_text$mn
.text$mn:00003D60                 ;org 3D60h
.text$mn:00003D60 ; COMDAT (pick any)
.text$mn:00003D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D60
.text$mn:00003D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D60
.text$mn:00003D60 ; Attributes: bp-based frame
.text$mn:00003D60
.text$mn:00003D60 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00003D60                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00003D60 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00003D60                                         ; DATA XREF: .rdata:000048E4o
.text$mn:00003D60                                         ; .rdata:00004900o ...
.text$mn:00003D60
.text$mn:00003D60 var_8           = dword ptr -8
.text$mn:00003D60 var_4           = dword ptr -4
.text$mn:00003D60 arg_0           = dword ptr  8
.text$mn:00003D60 arg_4           = dword ptr  0Ch
.text$mn:00003D60
.text$mn:00003D60                 push    ebp
.text$mn:00003D61                 mov     ebp, esp
.text$mn:00003D63                 sub     esp, 8
.text$mn:00003D66                 mov     [ebp+var_8], ecx
.text$mn:00003D69                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003D6C                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00003D71                 push    eax
.text$mn:00003D72                 mov     ecx, [ebp+var_8]
.text$mn:00003D75                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00003D7A                 movzx   eax, al
.text$mn:00003D7D                 test    eax, eax
.text$mn:00003D7F                 jz      short loc_3D97
.text$mn:00003D81                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003D84                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00003D89                 cmp     eax, [ebp+arg_4]
.text$mn:00003D8C                 jnz     short loc_3D97
.text$mn:00003D8E                 mov     [ebp+var_4], 1
.text$mn:00003D95                 jmp     short loc_3D9E
.text$mn:00003D97 ; ---------------------------------------------------------------------------
.text$mn:00003D97
.text$mn:00003D97 loc_3D97:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00003D97                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00003D97                 mov     [ebp+var_4], 0
.text$mn:00003D9E
.text$mn:00003D9E loc_3D9E:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00003D9E                 mov     al, byte ptr [ebp+var_4]
.text$mn:00003DA1                 mov     esp, ebp
.text$mn:00003DA3                 pop     ebp
.text$mn:00003DA4                 retn    8
.text$mn:00003DA4 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00003DA4
.text$mn:00003DA4 ; ---------------------------------------------------------------------------
.text$mn:00003DA7                 align 4
.text$mn:00003DA7 _text$mn        ends
.text$mn:00003DA7
.text$mn:00003DA8 ; ===========================================================================
.text$mn:00003DA8
.text$mn:00003DA8 ; Segment type: Pure code
.text$mn:00003DA8 ; Segment permissions: Read/Execute
.text$mn:00003DA8 _text$mn        segment para public 'CODE' use32
.text$mn:00003DA8                 assume cs:_text$mn
.text$mn:00003DA8                 ;org 3DA8h
.text$mn:00003DA8 ; COMDAT (pick any)
.text$mn:00003DA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DA8
.text$mn:00003DA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DA8
.text$mn:00003DA8 ; Attributes: bp-based frame
.text$mn:00003DA8
.text$mn:00003DA8 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00003DA8                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00003DA8 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00003DA8                                         ; DATA XREF: .rdata:000048E8o
.text$mn:00003DA8                                         ; .rdata:00004904o ...
.text$mn:00003DA8
.text$mn:00003DA8 var_C           = byte ptr -0Ch
.text$mn:00003DA8 var_4           = dword ptr -4
.text$mn:00003DA8 arg_0           = dword ptr  8
.text$mn:00003DA8 arg_4           = dword ptr  0Ch
.text$mn:00003DA8
.text$mn:00003DA8                 push    ebp
.text$mn:00003DA9                 mov     ebp, esp
.text$mn:00003DAB                 sub     esp, 0Ch
.text$mn:00003DAE                 mov     [ebp+var_4], ecx
.text$mn:00003DB1                 mov     eax, [ebp+arg_4]
.text$mn:00003DB4                 push    eax             ; std::error_condition *
.text$mn:00003DB5                 mov     ecx, [ebp+arg_0]
.text$mn:00003DB8                 push    ecx
.text$mn:00003DB9                 lea     edx, [ebp+var_C]
.text$mn:00003DBC                 push    edx
.text$mn:00003DBD                 mov     eax, [ebp+var_4]
.text$mn:00003DC0                 mov     edx, [eax]
.text$mn:00003DC2                 mov     ecx, [ebp+var_4]
.text$mn:00003DC5                 mov     eax, [edx+0Ch]
.text$mn:00003DC8                 call    eax
.text$mn:00003DCA                 mov     ecx, eax
.text$mn:00003DCC                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00003DD1                 mov     esp, ebp
.text$mn:00003DD3                 pop     ebp
.text$mn:00003DD4                 retn    8
.text$mn:00003DD4 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00003DD4
.text$mn:00003DD4 ; ---------------------------------------------------------------------------
.text$mn:00003DD7                 align 4
.text$mn:00003DD7 _text$mn        ends
.text$mn:00003DD7
.text$mn:00003DD8 ; ===========================================================================
.text$mn:00003DD8
.text$mn:00003DD8 ; Segment type: Pure code
.text$mn:00003DD8 ; Segment permissions: Read/Execute
.text$mn:00003DD8 _text$mn        segment para public 'CODE' use32
.text$mn:00003DD8                 assume cs:_text$mn
.text$mn:00003DD8                 ;org 3DD8h
.text$mn:00003DD8 ; COMDAT (pick any)
.text$mn:00003DD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DD8
.text$mn:00003DD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DD8
.text$mn:00003DD8 ; Attributes: bp-based frame
.text$mn:00003DD8
.text$mn:00003DD8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00003DD8                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00003DD8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00003DD8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00003DD8
.text$mn:00003DD8 var_4           = dword ptr -4
.text$mn:00003DD8 arg_0           = dword ptr  8
.text$mn:00003DD8
.text$mn:00003DD8                 push    ebp
.text$mn:00003DD9                 mov     ebp, esp
.text$mn:00003DDB                 push    ecx
.text$mn:00003DDC                 mov     [ebp+var_4], ecx
.text$mn:00003DDF                 mov     eax, [ebp+var_4]
.text$mn:00003DE2                 mov     ecx, [eax+14h]
.text$mn:00003DE5                 cmp     ecx, [ebp+arg_0]
.text$mn:00003DE8                 jnb     short loc_3DF2
.text$mn:00003DEA                 mov     ecx, [ebp+var_4]
.text$mn:00003DED                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00003DF2
.text$mn:00003DF2 loc_3DF2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00003DF2                 mov     edx, [ebp+arg_0]
.text$mn:00003DF5                 push    edx
.text$mn:00003DF6                 mov     ecx, [ebp+var_4]
.text$mn:00003DF9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003DFE                 mov     eax, [ebp+var_4]
.text$mn:00003E01                 mov     esp, ebp
.text$mn:00003E03                 pop     ebp
.text$mn:00003E04                 retn    4
.text$mn:00003E04 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00003E04
.text$mn:00003E04 ; ---------------------------------------------------------------------------
.text$mn:00003E07                 align 4
.text$mn:00003E07 _text$mn        ends
.text$mn:00003E07
.text$mn:00003E08 ; ===========================================================================
.text$mn:00003E08
.text$mn:00003E08 ; Segment type: Pure code
.text$mn:00003E08 ; Segment permissions: Read/Execute
.text$mn:00003E08 _text$mn        segment para public 'CODE' use32
.text$mn:00003E08                 assume cs:_text$mn
.text$mn:00003E08                 ;org 3E08h
.text$mn:00003E08 ; COMDAT (pick any)
.text$mn:00003E08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E08
.text$mn:00003E08 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E08
.text$mn:00003E08 ; Attributes: bp-based frame
.text$mn:00003E08
.text$mn:00003E08 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00003E08                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00003E08 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00003E08                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00003E08
.text$mn:00003E08 var_C           = dword ptr -0Ch
.text$mn:00003E08 Dst             = dword ptr -8
.text$mn:00003E08 var_4           = dword ptr -4
.text$mn:00003E08 arg_0           = dword ptr  8
.text$mn:00003E08 arg_4           = dword ptr  0Ch
.text$mn:00003E08
.text$mn:00003E08                 push    ebp
.text$mn:00003E09                 mov     ebp, esp
.text$mn:00003E0B                 sub     esp, 0Ch
.text$mn:00003E0E                 mov     [ebp+var_4], ecx
.text$mn:00003E11                 mov     eax, [ebp+var_4]
.text$mn:00003E14                 mov     ecx, [eax+14h]
.text$mn:00003E17                 cmp     ecx, [ebp+arg_0]
.text$mn:00003E1A                 jnb     short loc_3E24
.text$mn:00003E1C                 mov     ecx, [ebp+var_4]
.text$mn:00003E1F                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00003E24
.text$mn:00003E24 loc_3E24:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00003E24                 mov     edx, [ebp+var_4]
.text$mn:00003E27                 mov     eax, [edx+14h]
.text$mn:00003E2A                 sub     eax, [ebp+arg_0]
.text$mn:00003E2D                 cmp     eax, [ebp+arg_4]
.text$mn:00003E30                 ja      short loc_3E40
.text$mn:00003E32                 mov     ecx, [ebp+arg_0]
.text$mn:00003E35                 push    ecx
.text$mn:00003E36                 mov     ecx, [ebp+var_4]
.text$mn:00003E39                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003E3E                 jmp     short loc_3E86
.text$mn:00003E40 ; ---------------------------------------------------------------------------
.text$mn:00003E40
.text$mn:00003E40 loc_3E40:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00003E40                 cmp     [ebp+arg_4], 0
.text$mn:00003E44                 jbe     short loc_3E86
.text$mn:00003E46                 mov     ecx, [ebp+var_4]
.text$mn:00003E49                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003E4E                 add     eax, [ebp+arg_0]
.text$mn:00003E51                 mov     [ebp+Dst], eax
.text$mn:00003E54                 mov     edx, [ebp+var_4]
.text$mn:00003E57                 mov     eax, [edx+14h]
.text$mn:00003E5A                 sub     eax, [ebp+arg_4]
.text$mn:00003E5D                 mov     [ebp+var_C], eax
.text$mn:00003E60                 mov     ecx, [ebp+var_C]
.text$mn:00003E63                 sub     ecx, [ebp+arg_0]
.text$mn:00003E66                 push    ecx             ; Size
.text$mn:00003E67                 mov     edx, [ebp+Dst]
.text$mn:00003E6A                 add     edx, [ebp+arg_4]
.text$mn:00003E6D                 push    edx             ; Src
.text$mn:00003E6E                 mov     eax, [ebp+Dst]
.text$mn:00003E71                 push    eax             ; Dst
.text$mn:00003E72                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00003E77                 add     esp, 0Ch
.text$mn:00003E7A                 mov     ecx, [ebp+var_C]
.text$mn:00003E7D                 push    ecx
.text$mn:00003E7E                 mov     ecx, [ebp+var_4]
.text$mn:00003E81                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003E86
.text$mn:00003E86 loc_3E86:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00003E86                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00003E86                 mov     eax, [ebp+var_4]
.text$mn:00003E89                 mov     esp, ebp
.text$mn:00003E8B                 pop     ebp
.text$mn:00003E8C                 retn    8
.text$mn:00003E8C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00003E8C
.text$mn:00003E8C ; ---------------------------------------------------------------------------
.text$mn:00003E8F                 align 10h
.text$mn:00003E8F _text$mn        ends
.text$mn:00003E8F
.text$mn:00003E90 ; ===========================================================================
.text$mn:00003E90
.text$mn:00003E90 ; Segment type: Pure code
.text$mn:00003E90 ; Segment permissions: Read/Execute
.text$mn:00003E90 _text$mn        segment para public 'CODE' use32
.text$mn:00003E90                 assume cs:_text$mn
.text$mn:00003E90                 ;org 3E90h
.text$mn:00003E90 ; COMDAT (pick any)
.text$mn:00003E90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E90
.text$mn:00003E90 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E90
.text$mn:00003E90 ; Attributes: bp-based frame
.text$mn:00003E90
.text$mn:00003E90 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00003E90                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00003E90 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00003E90                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00003E90                 push    ebp
.text$mn:00003E91                 mov     ebp, esp
.text$mn:00003E93                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00003E98                 pop     ebp
.text$mn:00003E99                 retn
.text$mn:00003E99 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00003E99
.text$mn:00003E99 ; ---------------------------------------------------------------------------
.text$mn:00003E9A                 align 4
.text$mn:00003E9A _text$mn        ends
.text$mn:00003E9A
.text$mn:00003E9C ; ===========================================================================
.text$mn:00003E9C
.text$mn:00003E9C ; Segment type: Pure code
.text$mn:00003E9C ; Segment permissions: Read/Execute
.text$mn:00003E9C _text$mn        segment para public 'CODE' use32
.text$mn:00003E9C                 assume cs:_text$mn
.text$mn:00003E9C                 ;org 3E9Ch
.text$mn:00003E9C ; COMDAT (pick any)
.text$mn:00003E9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E9C
.text$mn:00003E9C ; =============== S U B R O U T I N E =======================================
.text$mn:00003E9C
.text$mn:00003E9C ; Attributes: bp-based frame
.text$mn:00003E9C
.text$mn:00003E9C ; int __thiscall TabBar::getCurrentTabIndex(TabBar *__hidden this)
.text$mn:00003E9C                 public ?getCurrentTabIndex@TabBar@@QBEHXZ
.text$mn:00003E9C ?getCurrentTabIndex@TabBar@@QBEHXZ proc near
.text$mn:00003E9C                                         ; CODE XREF: TabBar::activateAt(int)+Cp
.text$mn:00003E9C                                         ; TabBar::getCurrentTitle(wchar_t *,int)+26p
.text$mn:00003E9C
.text$mn:00003E9C var_4           = dword ptr -4
.text$mn:00003E9C
.text$mn:00003E9C                 push    ebp
.text$mn:00003E9D                 mov     ebp, esp
.text$mn:00003E9F                 push    ecx
.text$mn:00003EA0                 mov     [ebp+var_4], ecx
.text$mn:00003EA3                 push    0               ; lParam
.text$mn:00003EA5                 push    0               ; wParam
.text$mn:00003EA7                 push    130Bh           ; Msg
.text$mn:00003EAC                 mov     eax, [ebp+var_4]
.text$mn:00003EAF                 mov     ecx, [eax+0Ch]
.text$mn:00003EB2                 push    ecx             ; hWnd
.text$mn:00003EB3                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00003EB9                 mov     esp, ebp
.text$mn:00003EBB                 pop     ebp
.text$mn:00003EBC                 retn
.text$mn:00003EBC ?getCurrentTabIndex@TabBar@@QBEHXZ endp
.text$mn:00003EBC
.text$mn:00003EBC ; ---------------------------------------------------------------------------
.text$mn:00003EBD                 align 10h
.text$mn:00003EBD _text$mn        ends
.text$mn:00003EBD
.text$mn:00003EC0 ; ===========================================================================
.text$mn:00003EC0
.text$mn:00003EC0 ; Segment type: Pure code
.text$mn:00003EC0 ; Segment permissions: Read/Execute
.text$mn:00003EC0 _text$mn        segment para public 'CODE' use32
.text$mn:00003EC0                 assume cs:_text$mn
.text$mn:00003EC0                 ;org 3EC0h
.text$mn:00003EC0 ; COMDAT (pick any)
.text$mn:00003EC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003EC0
.text$mn:00003EC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003EC0
.text$mn:00003EC0 ; Attributes: bp-based frame
.text$mn:00003EC0
.text$mn:00003EC0 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:00003EC0                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:00003EC0 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:00003EC0                                         ; CODE XREF: CloseButtonZone::CloseButtonZone(void)+9p
.text$mn:00003EC0                                         ; CloseButtonZone::CloseButtonZone(void)+1Fp ...
.text$mn:00003EC0                 push    ebp
.text$mn:00003EC1                 mov     ebp, esp
.text$mn:00003EC3                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:00003EC8                 pop     ebp
.text$mn:00003EC9                 retn
.text$mn:00003EC9 ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:00003EC9
.text$mn:00003EC9 ; ---------------------------------------------------------------------------
.text$mn:00003ECA                 align 4
.text$mn:00003ECA _text$mn        ends
.text$mn:00003ECA
.text$mn:00003ECC ; ===========================================================================
.text$mn:00003ECC
.text$mn:00003ECC ; Segment type: Pure code
.text$mn:00003ECC ; Segment permissions: Read/Execute
.text$mn:00003ECC _text$mn        segment para public 'CODE' use32
.text$mn:00003ECC                 assume cs:_text$mn
.text$mn:00003ECC                 ;org 3ECCh
.text$mn:00003ECC ; COMDAT (pick any)
.text$mn:00003ECC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003ECC
.text$mn:00003ECC ; =============== S U B R O U T I N E =======================================
.text$mn:00003ECC
.text$mn:00003ECC ; Attributes: bp-based frame
.text$mn:00003ECC
.text$mn:00003ECC ; int __thiscall TabBarPlus::getTabIndexAt(TabBarPlus *this, const struct tagPOINT *)
.text$mn:00003ECC                 public ?getTabIndexAt@TabBarPlus@@IAEHABUtagPOINT@@@Z
.text$mn:00003ECC ?getTabIndexAt@TabBarPlus@@IAEHABUtagPOINT@@@Z proc near
.text$mn:00003ECC                                         ; CODE XREF: TabBarPlus::exchangeItemData(tagPOINT)+23p
.text$mn:00003ECC
.text$mn:00003ECC var_4           = dword ptr -4
.text$mn:00003ECC arg_0           = dword ptr  8
.text$mn:00003ECC
.text$mn:00003ECC                 push    ebp
.text$mn:00003ECD                 mov     ebp, esp
.text$mn:00003ECF                 push    ecx
.text$mn:00003ED0                 mov     [ebp+var_4], ecx
.text$mn:00003ED3                 mov     eax, [ebp+arg_0]
.text$mn:00003ED6                 mov     ecx, [eax+4]
.text$mn:00003ED9                 push    ecx             ; int
.text$mn:00003EDA                 mov     edx, [ebp+arg_0]
.text$mn:00003EDD                 mov     eax, [edx]
.text$mn:00003EDF                 push    eax             ; int
.text$mn:00003EE0                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003EE3                 call    ?getTabIndexAt@TabBarPlus@@IAEHHH@Z ; TabBarPlus::getTabIndexAt(int,int)
.text$mn:00003EE8                 mov     esp, ebp
.text$mn:00003EEA                 pop     ebp
.text$mn:00003EEB                 retn    4
.text$mn:00003EEB ?getTabIndexAt@TabBarPlus@@IAEHABUtagPOINT@@@Z endp
.text$mn:00003EEB
.text$mn:00003EEB ; ---------------------------------------------------------------------------
.text$mn:00003EEE                 align 10h
.text$mn:00003EEE _text$mn        ends
.text$mn:00003EEE
.text$mn:00003EF0 ; ===========================================================================
.text$mn:00003EF0
.text$mn:00003EF0 ; Segment type: Pure code
.text$mn:00003EF0 ; Segment permissions: Read/Execute
.text$mn:00003EF0 _text$mn        segment para public 'CODE' use32
.text$mn:00003EF0                 assume cs:_text$mn
.text$mn:00003EF0                 ;org 3EF0h
.text$mn:00003EF0 ; COMDAT (pick any)
.text$mn:00003EF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003EF0
.text$mn:00003EF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003EF0
.text$mn:00003EF0 ; Attributes: bp-based frame
.text$mn:00003EF0
.text$mn:00003EF0 ; int __thiscall TabBarPlus::getTabIndexAt(TabBarPlus *this, int, int)
.text$mn:00003EF0                 public ?getTabIndexAt@TabBarPlus@@IAEHHH@Z
.text$mn:00003EF0 ?getTabIndexAt@TabBarPlus@@IAEHHH@Z proc near
.text$mn:00003EF0                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+19Cp
.text$mn:00003EF0                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long)+3C2p ...
.text$mn:00003EF0
.text$mn:00003EF0 var_14          = dword ptr -14h
.text$mn:00003EF0 lParam          = dword ptr -10h
.text$mn:00003EF0 var_C           = dword ptr -0Ch
.text$mn:00003EF0 var_4           = dword ptr -4
.text$mn:00003EF0 arg_0           = dword ptr  8
.text$mn:00003EF0 arg_4           = dword ptr  0Ch
.text$mn:00003EF0
.text$mn:00003EF0                 push    ebp
.text$mn:00003EF1                 mov     ebp, esp
.text$mn:00003EF3                 sub     esp, 14h
.text$mn:00003EF6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003EFB                 xor     eax, ebp
.text$mn:00003EFD                 mov     [ebp+var_4], eax
.text$mn:00003F00                 mov     [ebp+var_14], ecx
.text$mn:00003F03                 mov     eax, [ebp+arg_0]
.text$mn:00003F06                 mov     [ebp+lParam], eax
.text$mn:00003F09                 mov     ecx, [ebp+arg_4]
.text$mn:00003F0C                 mov     [ebp+var_C], ecx
.text$mn:00003F0F                 lea     edx, [ebp+lParam]
.text$mn:00003F12                 push    edx             ; lParam
.text$mn:00003F13                 push    0               ; wParam
.text$mn:00003F15                 push    130Dh           ; Msg
.text$mn:00003F1A                 mov     eax, [ebp+var_14]
.text$mn:00003F1D                 mov     ecx, [eax+0Ch]
.text$mn:00003F20                 push    ecx             ; hWnd
.text$mn:00003F21                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00003F27                 mov     ecx, [ebp+var_4]
.text$mn:00003F2A                 xor     ecx, ebp
.text$mn:00003F2C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00003F31                 mov     esp, ebp
.text$mn:00003F33                 pop     ebp
.text$mn:00003F34                 retn    8
.text$mn:00003F34 ?getTabIndexAt@TabBarPlus@@IAEHHH@Z endp
.text$mn:00003F34
.text$mn:00003F34 ; ---------------------------------------------------------------------------
.text$mn:00003F37                 align 4
.text$mn:00003F37 _text$mn        ends
.text$mn:00003F37
.text$mn:00003F38 ; ===========================================================================
.text$mn:00003F38
.text$mn:00003F38 ; Segment type: Pure code
.text$mn:00003F38 ; Segment permissions: Read/Execute
.text$mn:00003F38 _text$mn        segment para public 'CODE' use32
.text$mn:00003F38                 assume cs:_text$mn
.text$mn:00003F38                 ;org 3F38h
.text$mn:00003F38 ; COMDAT (pick any)
.text$mn:00003F38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F38
.text$mn:00003F38 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F38
.text$mn:00003F38 ; Attributes: bp-based frame
.text$mn:00003F38
.text$mn:00003F38 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:00003F38                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00003F38 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00003F38                                         ; CODE XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+14p
.text$mn:00003F38                                         ; TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+21p
.text$mn:00003F38
.text$mn:00003F38 var_4           = dword ptr -4
.text$mn:00003F38 arg_0           = dword ptr  8
.text$mn:00003F38 arg_4           = dword ptr  0Ch
.text$mn:00003F38
.text$mn:00003F38                 push    ebp
.text$mn:00003F39                 mov     ebp, esp
.text$mn:00003F3B                 push    ecx
.text$mn:00003F3C                 mov     [ebp+var_4], ecx
.text$mn:00003F3F                 mov     eax, [ebp+var_4]
.text$mn:00003F42                 mov     ecx, [ebp+arg_0]
.text$mn:00003F45                 mov     [eax+4], ecx
.text$mn:00003F48                 mov     edx, [ebp+var_4]
.text$mn:00003F4B                 mov     eax, [ebp+arg_4]
.text$mn:00003F4E                 mov     [edx+8], eax
.text$mn:00003F51                 mov     esp, ebp
.text$mn:00003F53                 pop     ebp
.text$mn:00003F54                 retn    8
.text$mn:00003F54 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:00003F54
.text$mn:00003F54 ; ---------------------------------------------------------------------------
.text$mn:00003F57                 align 4
.text$mn:00003F57 _text$mn        ends
.text$mn:00003F57
.text$mn:00003F58 ; ===========================================================================
.text$mn:00003F58
.text$mn:00003F58 ; Segment type: Pure code
.text$mn:00003F58 ; Segment permissions: Read/Execute
.text$mn:00003F58 _text$mn        segment para public 'CODE' use32
.text$mn:00003F58                 assume cs:_text$mn
.text$mn:00003F58                 ;org 3F58h
.text$mn:00003F58 ; COMDAT (pick any)
.text$mn:00003F58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F58
.text$mn:00003F58 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F58
.text$mn:00003F58 ; Attributes: bp-based frame
.text$mn:00003F58
.text$mn:00003F58 ; bool __cdecl TabBarPlus::isMultiLine()
.text$mn:00003F58                 public ?isMultiLine@TabBarPlus@@SA_NXZ
.text$mn:00003F58 ?isMultiLine@TabBarPlus@@SA_NXZ proc near
.text$mn:00003F58                                         ; CODE XREF: TabBarPlus::doMultiLine(void)+33p
.text$mn:00003F58                 push    ebp
.text$mn:00003F59                 mov     ebp, esp
.text$mn:00003F5B                 mov     al, ds:?_isCtrlMultiLine@TabBarPlus@@1_NA ; bool TabBarPlus::_isCtrlMultiLine
.text$mn:00003F60                 pop     ebp
.text$mn:00003F61                 retn
.text$mn:00003F61 ?isMultiLine@TabBarPlus@@SA_NXZ endp
.text$mn:00003F61
.text$mn:00003F61 ; ---------------------------------------------------------------------------
.text$mn:00003F62                 align 4
.text$mn:00003F62 _text$mn        ends
.text$mn:00003F62
.text$mn:00003F64 ; ===========================================================================
.text$mn:00003F64
.text$mn:00003F64 ; Segment type: Pure code
.text$mn:00003F64 ; Segment permissions: Read/Execute
.text$mn:00003F64 _text$mn        segment para public 'CODE' use32
.text$mn:00003F64                 assume cs:_text$mn
.text$mn:00003F64                 ;org 3F64h
.text$mn:00003F64 ; COMDAT (pick any)
.text$mn:00003F64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F64
.text$mn:00003F64 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F64
.text$mn:00003F64 ; Attributes: bp-based frame
.text$mn:00003F64
.text$mn:00003F64 ; bool __cdecl TabBarPlus::isOwnerDrawTab()
.text$mn:00003F64                 public ?isOwnerDrawTab@TabBarPlus@@SA_NXZ
.text$mn:00003F64 ?isOwnerDrawTab@TabBarPlus@@SA_NXZ proc near
.text$mn:00003F64                                         ; CODE XREF: TabBarPlus::doOwnerDrawTab(void)+6Cp
.text$mn:00003F64                 push    ebp
.text$mn:00003F65                 mov     ebp, esp
.text$mn:00003F67                 mov     al, 1
.text$mn:00003F69                 pop     ebp
.text$mn:00003F6A                 retn
.text$mn:00003F6A ?isOwnerDrawTab@TabBarPlus@@SA_NXZ endp
.text$mn:00003F6A
.text$mn:00003F6A ; ---------------------------------------------------------------------------
.text$mn:00003F6B                 align 4
.text$mn:00003F6B _text$mn        ends
.text$mn:00003F6B
.text$mn:00003F6C ; ===========================================================================
.text$mn:00003F6C
.text$mn:00003F6C ; Segment type: Pure code
.text$mn:00003F6C ; Segment permissions: Read/Execute
.text$mn:00003F6C _text$mn        segment para public 'CODE' use32
.text$mn:00003F6C                 assume cs:_text$mn
.text$mn:00003F6C                 ;org 3F6Ch
.text$mn:00003F6C ; COMDAT (pick any)
.text$mn:00003F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F6C
.text$mn:00003F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00003F6C
.text$mn:00003F6C ; Attributes: bp-based frame
.text$mn:00003F6C
.text$mn:00003F6C ; bool __thiscall TabBarPlus::isPointInParentZone(TabBarPlus *this, struct tagPOINT)
.text$mn:00003F6C                 public ?isPointInParentZone@TabBarPlus@@IBE_NUtagPOINT@@@Z
.text$mn:00003F6C ?isPointInParentZone@TabBarPlus@@IBE_NUtagPOINT@@@Z proc near
.text$mn:00003F6C                                         ; CODE XREF: TabBarPlus::draggingCursor(tagPOINT)+FCp
.text$mn:00003F6C
.text$mn:00003F6C var_1C          = dword ptr -1Ch
.text$mn:00003F6C var_18          = dword ptr -18h
.text$mn:00003F6C Rect            = tagRECT ptr -14h
.text$mn:00003F6C var_4           = dword ptr -4
.text$mn:00003F6C arg_0           = tagPOINT ptr  8
.text$mn:00003F6C
.text$mn:00003F6C                 push    ebp
.text$mn:00003F6D                 mov     ebp, esp
.text$mn:00003F6F                 sub     esp, 1Ch
.text$mn:00003F72                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003F77                 xor     eax, ebp
.text$mn:00003F79                 mov     [ebp+var_4], eax
.text$mn:00003F7C                 mov     [ebp+var_1C], ecx
.text$mn:00003F7F                 lea     eax, [ebp+Rect]
.text$mn:00003F82                 push    eax             ; lpRect
.text$mn:00003F83                 mov     ecx, [ebp+var_1C]
.text$mn:00003F86                 mov     edx, [ecx+8]
.text$mn:00003F89                 push    edx             ; hWnd
.text$mn:00003F8A                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:00003F90                 mov     eax, [ebp+arg_0.x]
.text$mn:00003F93                 cmp     eax, [ebp+Rect.left]
.text$mn:00003F96                 jl      short loc_3FB9
.text$mn:00003F98                 mov     ecx, [ebp+arg_0.x]
.text$mn:00003F9B                 cmp     ecx, [ebp+Rect.right]
.text$mn:00003F9E                 jg      short loc_3FB9
.text$mn:00003FA0                 mov     edx, [ebp+arg_0.y]
.text$mn:00003FA3                 cmp     edx, [ebp+Rect.top]
.text$mn:00003FA6                 jl      short loc_3FB9
.text$mn:00003FA8                 mov     eax, [ebp+arg_0.y]
.text$mn:00003FAB                 cmp     eax, [ebp+Rect.bottom]
.text$mn:00003FAE                 jg      short loc_3FB9
.text$mn:00003FB0                 mov     [ebp+var_18], 1
.text$mn:00003FB7                 jmp     short loc_3FC0
.text$mn:00003FB9 ; ---------------------------------------------------------------------------
.text$mn:00003FB9
.text$mn:00003FB9 loc_3FB9:                               ; CODE XREF: TabBarPlus::isPointInParentZone(tagPOINT)+2Aj
.text$mn:00003FB9                                         ; TabBarPlus::isPointInParentZone(tagPOINT)+32j ...
.text$mn:00003FB9                 mov     [ebp+var_18], 0
.text$mn:00003FC0
.text$mn:00003FC0 loc_3FC0:                               ; CODE XREF: TabBarPlus::isPointInParentZone(tagPOINT)+4Bj
.text$mn:00003FC0                 mov     al, byte ptr [ebp+var_18]
.text$mn:00003FC3                 mov     ecx, [ebp+var_4]
.text$mn:00003FC6                 xor     ecx, ebp
.text$mn:00003FC8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00003FCD                 mov     esp, ebp
.text$mn:00003FCF                 pop     ebp
.text$mn:00003FD0                 retn    8
.text$mn:00003FD0 ?isPointInParentZone@TabBarPlus@@IBE_NUtagPOINT@@@Z endp
.text$mn:00003FD0
.text$mn:00003FD0 ; ---------------------------------------------------------------------------
.text$mn:00003FD3                 align 4
.text$mn:00003FD3 _text$mn        ends
.text$mn:00003FD3
.text$mn:00003FD4 ; ===========================================================================
.text$mn:00003FD4
.text$mn:00003FD4 ; Segment type: Pure code
.text$mn:00003FD4 ; Segment permissions: Read/Execute
.text$mn:00003FD4 _text$mn        segment para public 'CODE' use32
.text$mn:00003FD4                 assume cs:_text$mn
.text$mn:00003FD4                 ;org 3FD4h
.text$mn:00003FD4 ; COMDAT (pick any)
.text$mn:00003FD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FD4
.text$mn:00003FD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FD4
.text$mn:00003FD4 ; Attributes: bp-based frame
.text$mn:00003FD4
.text$mn:00003FD4 ; bool __cdecl TabBarPlus::isVertical()
.text$mn:00003FD4                 public ?isVertical@TabBarPlus@@SA_NXZ
.text$mn:00003FD4 ?isVertical@TabBarPlus@@SA_NXZ proc near
.text$mn:00003FD4                                         ; CODE XREF: TabBarPlus::doVertical(void)+33p
.text$mn:00003FD4                 push    ebp
.text$mn:00003FD5                 mov     ebp, esp
.text$mn:00003FD7                 mov     al, ds:?_isCtrlVertical@TabBarPlus@@1_NA ; bool TabBarPlus::_isCtrlVertical
.text$mn:00003FDC                 pop     ebp
.text$mn:00003FDD                 retn
.text$mn:00003FDD ?isVertical@TabBarPlus@@SA_NXZ endp
.text$mn:00003FDD
.text$mn:00003FDD ; ---------------------------------------------------------------------------
.text$mn:00003FDE                 align 10h
.text$mn:00003FDE _text$mn        ends
.text$mn:00003FDE
.text$mn:00003FE0 ; ===========================================================================
.text$mn:00003FE0
.text$mn:00003FE0 ; Segment type: Pure code
.text$mn:00003FE0 ; Segment permissions: Read/Execute
.text$mn:00003FE0 _text$mn        segment para public 'CODE' use32
.text$mn:00003FE0                 assume cs:_text$mn
.text$mn:00003FE0                 ;org 3FE0h
.text$mn:00003FE0 ; COMDAT (pick any)
.text$mn:00003FE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FE0
.text$mn:00003FE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FE0
.text$mn:00003FE0 ; Attributes: bp-based frame
.text$mn:00003FE0
.text$mn:00003FE0 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00003FE0                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00003FE0 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00003FE0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00003FE0
.text$mn:00003FE0 var_4           = dword ptr -4
.text$mn:00003FE0 Str             = dword ptr  8
.text$mn:00003FE0
.text$mn:00003FE0                 push    ebp
.text$mn:00003FE1                 mov     ebp, esp
.text$mn:00003FE3                 push    ecx
.text$mn:00003FE4                 mov     eax, [ebp+Str]
.text$mn:00003FE7                 movsx   ecx, byte ptr [eax]
.text$mn:00003FEA                 test    ecx, ecx
.text$mn:00003FEC                 jnz     short loc_3FF7
.text$mn:00003FEE                 mov     [ebp+var_4], 0
.text$mn:00003FF5                 jmp     short loc_4006
.text$mn:00003FF7 ; ---------------------------------------------------------------------------
.text$mn:00003FF7
.text$mn:00003FF7 loc_3FF7:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00003FF7                 mov     edx, [ebp+Str]
.text$mn:00003FFA                 push    edx             ; Str
.text$mn:00003FFB                 call    _strlen
.text$mn:00004000                 add     esp, 4
.text$mn:00004003                 mov     [ebp+var_4], eax
.text$mn:00004006
.text$mn:00004006 loc_4006:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00004006                 mov     eax, [ebp+var_4]
.text$mn:00004009                 mov     esp, ebp
.text$mn:0000400B                 pop     ebp
.text$mn:0000400C                 retn
.text$mn:0000400C ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:0000400C
.text$mn:0000400C ; ---------------------------------------------------------------------------
.text$mn:0000400D                 align 10h
.text$mn:0000400D _text$mn        ends
.text$mn:0000400D
.text$mn:00004010 ; ===========================================================================
.text$mn:00004010
.text$mn:00004010 ; Segment type: Pure code
.text$mn:00004010 ; Segment permissions: Read/Execute
.text$mn:00004010 _text$mn        segment para public 'CODE' use32
.text$mn:00004010                 assume cs:_text$mn
.text$mn:00004010                 ;org 4010h
.text$mn:00004010 ; COMDAT (pick any)
.text$mn:00004010                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004010
.text$mn:00004010 ; =============== S U B R O U T I N E =======================================
.text$mn:00004010
.text$mn:00004010 ; Attributes: bp-based frame
.text$mn:00004010
.text$mn:00004010 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00004010                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00004010 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00004010                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00004010
.text$mn:00004010 var_4           = dword ptr -4
.text$mn:00004010
.text$mn:00004010                 push    ebp
.text$mn:00004011                 mov     ebp, esp
.text$mn:00004013                 push    ecx
.text$mn:00004014                 mov     [ebp+var_4], ecx
.text$mn:00004017                 mov     eax, [ebp+var_4]
.text$mn:0000401A                 push    eax
.text$mn:0000401B                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00004020                 add     esp, 4
.text$mn:00004023                 mov     esp, ebp
.text$mn:00004025                 pop     ebp
.text$mn:00004026                 retn
.text$mn:00004026 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00004026
.text$mn:00004026 ; ---------------------------------------------------------------------------
.text$mn:00004027                 align 4
.text$mn:00004027 _text$mn        ends
.text$mn:00004027
.text$mn:00004028 ; ===========================================================================
.text$mn:00004028
.text$mn:00004028 ; Segment type: Pure code
.text$mn:00004028 ; Segment permissions: Read/Execute
.text$mn:00004028 _text$mn        segment para public 'CODE' use32
.text$mn:00004028                 assume cs:_text$mn
.text$mn:00004028                 ;org 4028h
.text$mn:00004028 ; COMDAT (pick any)
.text$mn:00004028                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004028
.text$mn:00004028 ; =============== S U B R O U T I N E =======================================
.text$mn:00004028
.text$mn:00004028 ; Attributes: bp-based frame
.text$mn:00004028
.text$mn:00004028 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00004028                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00004028 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00004028                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00004028
.text$mn:00004028 var_4           = dword ptr -4
.text$mn:00004028
.text$mn:00004028                 push    ebp
.text$mn:00004029                 mov     ebp, esp
.text$mn:0000402B                 push    ecx
.text$mn:0000402C                 mov     [ebp+var_4], ecx
.text$mn:0000402F                 or      eax, 0FFFFFFFFh
.text$mn:00004032                 mov     esp, ebp
.text$mn:00004034                 pop     ebp
.text$mn:00004035                 retn
.text$mn:00004035 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00004035
.text$mn:00004035 ; ---------------------------------------------------------------------------
.text$mn:00004036                 align 4
.text$mn:00004036 _text$mn        ends
.text$mn:00004036
.text$mn:00004038 ; ===========================================================================
.text$mn:00004038
.text$mn:00004038 ; Segment type: Pure code
.text$mn:00004038 ; Segment permissions: Read/Execute
.text$mn:00004038 _text$mn        segment para public 'CODE' use32
.text$mn:00004038                 assume cs:_text$mn
.text$mn:00004038                 ;org 4038h
.text$mn:00004038 ; COMDAT (pick any)
.text$mn:00004038                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004038
.text$mn:00004038 ; =============== S U B R O U T I N E =======================================
.text$mn:00004038
.text$mn:00004038 ; Attributes: bp-based frame
.text$mn:00004038
.text$mn:00004038 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00004038                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00004038 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00004038                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00004038
.text$mn:00004038 arg_0           = dword ptr  8
.text$mn:00004038
.text$mn:00004038                 push    ebp
.text$mn:00004039                 mov     ebp, esp
.text$mn:0000403B                 mov     ecx, [ebp+arg_0]
.text$mn:0000403E                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00004043                 pop     ebp
.text$mn:00004044                 retn
.text$mn:00004044 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00004044
.text$mn:00004044 ; ---------------------------------------------------------------------------
.text$mn:00004045                 align 4
.text$mn:00004045 _text$mn        ends
.text$mn:00004045
.text$mn:00004048 ; ===========================================================================
.text$mn:00004048
.text$mn:00004048 ; Segment type: Pure code
.text$mn:00004048 ; Segment permissions: Read/Execute
.text$mn:00004048 _text$mn        segment para public 'CODE' use32
.text$mn:00004048                 assume cs:_text$mn
.text$mn:00004048                 ;org 4048h
.text$mn:00004048 ; COMDAT (pick any)
.text$mn:00004048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004048
.text$mn:00004048 ; =============== S U B R O U T I N E =======================================
.text$mn:00004048
.text$mn:00004048 ; Attributes: bp-based frame
.text$mn:00004048
.text$mn:00004048 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00004048                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00004048 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00004048                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00004048                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00004048
.text$mn:00004048 var_10          = dword ptr -10h
.text$mn:00004048 var_C           = dword ptr -0Ch
.text$mn:00004048 var_8           = dword ptr -8
.text$mn:00004048 var_1           = byte ptr -1
.text$mn:00004048
.text$mn:00004048                 push    ebp
.text$mn:00004049                 mov     ebp, esp
.text$mn:0000404B                 sub     esp, 10h
.text$mn:0000404E                 mov     [ebp+var_10], ecx
.text$mn:00004051                 lea     eax, [ebp+var_1]
.text$mn:00004054                 push    eax
.text$mn:00004055                 mov     ecx, [ebp+var_10]
.text$mn:00004058                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000405D                 mov     ecx, eax
.text$mn:0000405F                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00004064                 mov     [ebp+var_8], eax
.text$mn:00004067                 cmp     [ebp+var_8], 1
.text$mn:0000406B                 ja      short loc_4076
.text$mn:0000406D                 mov     [ebp+var_C], 1
.text$mn:00004074                 jmp     short loc_407F
.text$mn:00004076 ; ---------------------------------------------------------------------------
.text$mn:00004076
.text$mn:00004076 loc_4076:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00004076                 mov     ecx, [ebp+var_8]
.text$mn:00004079                 sub     ecx, 1
.text$mn:0000407C                 mov     [ebp+var_C], ecx
.text$mn:0000407F
.text$mn:0000407F loc_407F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:0000407F                 mov     eax, [ebp+var_C]
.text$mn:00004082                 mov     esp, ebp
.text$mn:00004084                 pop     ebp
.text$mn:00004085                 retn
.text$mn:00004085 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00004085
.text$mn:00004085 ; ---------------------------------------------------------------------------
.text$mn:00004086                 align 4
.text$mn:00004086 _text$mn        ends
.text$mn:00004086
.text$mn:00004088 ; ===========================================================================
.text$mn:00004088
.text$mn:00004088 ; Segment type: Pure code
.text$mn:00004088 ; Segment permissions: Read/Execute
.text$mn:00004088 _text$mn        segment para public 'CODE' use32
.text$mn:00004088                 assume cs:_text$mn
.text$mn:00004088                 ;org 4088h
.text$mn:00004088 ; COMDAT (pick any)
.text$mn:00004088                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004088
.text$mn:00004088 ; =============== S U B R O U T I N E =======================================
.text$mn:00004088
.text$mn:00004088 ; Attributes: bp-based frame
.text$mn:00004088
.text$mn:00004088 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00004088                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00004088 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00004088                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00004088                                         ; DATA XREF: .rdata:000048F8o
.text$mn:00004088
.text$mn:00004088 var_1C          = dword ptr -1Ch
.text$mn:00004088 var_18          = dword ptr -18h
.text$mn:00004088 Str             = dword ptr -14h
.text$mn:00004088 var_10          = dword ptr -10h
.text$mn:00004088 var_C           = dword ptr -0Ch
.text$mn:00004088 var_4           = dword ptr -4
.text$mn:00004088 arg_0           = dword ptr  8
.text$mn:00004088 arg_4           = dword ptr  0Ch
.text$mn:00004088
.text$mn:00004088                 push    ebp
.text$mn:00004089                 mov     ebp, esp
.text$mn:0000408B                 push    0FFFFFFFFh
.text$mn:0000408D                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00004092                 mov     eax, large fs:0
.text$mn:00004098                 push    eax
.text$mn:00004099                 sub     esp, 10h
.text$mn:0000409C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000040A1                 xor     eax, ebp
.text$mn:000040A3                 push    eax
.text$mn:000040A4                 lea     eax, [ebp+var_C]
.text$mn:000040A7                 mov     large fs:0, eax
.text$mn:000040AD                 mov     [ebp+var_1C], ecx
.text$mn:000040B0                 mov     [ebp+var_18], 0
.text$mn:000040B7                 mov     eax, [ebp+arg_4]
.text$mn:000040BA                 push    eax             ; int
.text$mn:000040BB                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000040C0                 add     esp, 4
.text$mn:000040C3                 mov     [ebp+var_10], eax
.text$mn:000040C6                 cmp     [ebp+var_10], 0
.text$mn:000040CA                 jz      short loc_40D4
.text$mn:000040CC                 mov     ecx, [ebp+var_10]
.text$mn:000040CF                 mov     [ebp+Str], ecx
.text$mn:000040D2                 jmp     short loc_40DB
.text$mn:000040D4 ; ---------------------------------------------------------------------------
.text$mn:000040D4
.text$mn:000040D4 loc_40D4:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:000040D4                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000040DB
.text$mn:000040DB loc_40DB:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:000040DB                 mov     edx, [ebp+Str]
.text$mn:000040DE                 push    edx             ; Str
.text$mn:000040DF                 mov     ecx, [ebp+arg_0]
.text$mn:000040E2                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000040E7                 mov     [ebp+var_4], 0
.text$mn:000040EE                 mov     eax, [ebp+var_18]
.text$mn:000040F1                 or      eax, 1
.text$mn:000040F4                 mov     [ebp+var_18], eax
.text$mn:000040F7                 mov     eax, [ebp+arg_0]
.text$mn:000040FA                 mov     ecx, [ebp+var_C]
.text$mn:000040FD                 mov     large fs:0, ecx
.text$mn:00004104                 pop     ecx
.text$mn:00004105                 mov     esp, ebp
.text$mn:00004107                 pop     ebp
.text$mn:00004108                 retn    8
.text$mn:00004108 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00004108
.text$mn:00004108 ; ---------------------------------------------------------------------------
.text$mn:0000410B                 align 4
.text$mn:0000410B _text$mn        ends
.text$mn:0000410B
.text$x:0000410C ; ===========================================================================
.text$x:0000410C
.text$x:0000410C ; Segment type: Pure code
.text$x:0000410C ; Segment permissions: Read/Execute
.text$x:0000410C _text$x         segment para public 'CODE' use32
.text$x:0000410C                 assume cs:_text$x
.text$x:0000410C                 ;org 410Ch
.text$x:0000410C ; COMDAT (pick associative to section at 4088)
.text$x:0000410C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000410C
.text$x:0000410C ; =============== S U B R O U T I N E =======================================
.text$x:0000410C
.text$x:0000410C
.text$x:0000410C __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000410C                                         ; DATA XREF: .xdata$x:00004680o
.text$x:0000410C                 mov     eax, [ebp-18h]
.text$x:0000410F                 and     eax, 1
.text$x:00004112                 jz      $LN6_0
.text$x:00004118                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000411C                 mov     ecx, [ebp+8]
.text$x:0000411F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00004124 ; ---------------------------------------------------------------------------
.text$x:00004124
.text$x:00004124 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00004124                 retn
.text$x:00004124 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00004124
.text$x:00004125
.text$x:00004125 ; =============== S U B R O U T I N E =======================================
.text$x:00004125
.text$x:00004125
.text$x:00004125 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00004125                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00004125
.text$x:00004125 arg_4           = dword ptr  8
.text$x:00004125
.text$x:00004125                 mov     edx, [esp+arg_4]
.text$x:00004129                 lea     eax, [edx+0Ch]
.text$x:0000412C                 mov     ecx, [edx-14h]
.text$x:0000412F                 xor     ecx, eax
.text$x:00004131                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004136                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000413B                 jmp     ___CxxFrameHandler3
.text$x:0000413B __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000413B
.text$x:0000413B _text$x         ends
.text$x:0000413B
.text$mn:00004140 ; ===========================================================================
.text$mn:00004140
.text$mn:00004140 ; Segment type: Pure code
.text$mn:00004140 ; Segment permissions: Read/Execute
.text$mn:00004140 _text$mn        segment para public 'CODE' use32
.text$mn:00004140                 assume cs:_text$mn
.text$mn:00004140                 ;org 4140h
.text$mn:00004140 ; COMDAT (pick any)
.text$mn:00004140                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004140
.text$mn:00004140 ; =============== S U B R O U T I N E =======================================
.text$mn:00004140
.text$mn:00004140 ; Attributes: bp-based frame
.text$mn:00004140
.text$mn:00004140 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00004140                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00004140 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00004140                                         ; DATA XREF: .rdata:0000492Co
.text$mn:00004140
.text$mn:00004140 var_14          = dword ptr -14h
.text$mn:00004140 var_10          = dword ptr -10h
.text$mn:00004140 var_C           = dword ptr -0Ch
.text$mn:00004140 var_4           = dword ptr -4
.text$mn:00004140 arg_0           = dword ptr  8
.text$mn:00004140 arg_4           = dword ptr  0Ch
.text$mn:00004140
.text$mn:00004140                 push    ebp
.text$mn:00004141                 mov     ebp, esp
.text$mn:00004143                 push    0FFFFFFFFh
.text$mn:00004145                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000414A                 mov     eax, large fs:0
.text$mn:00004150                 push    eax
.text$mn:00004151                 sub     esp, 8
.text$mn:00004154                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004159                 xor     eax, ebp
.text$mn:0000415B                 push    eax
.text$mn:0000415C                 lea     eax, [ebp+var_C]
.text$mn:0000415F                 mov     large fs:0, eax
.text$mn:00004165                 mov     [ebp+var_14], ecx
.text$mn:00004168                 mov     [ebp+var_10], 0
.text$mn:0000416F                 cmp     [ebp+arg_4], 1
.text$mn:00004173                 jnz     short loc_4199
.text$mn:00004175                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:0000417A                 mov     ecx, [ebp+arg_0]
.text$mn:0000417D                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00004182                 mov     [ebp+var_4], 0
.text$mn:00004189                 mov     eax, [ebp+var_10]
.text$mn:0000418C                 or      eax, 1
.text$mn:0000418F                 mov     [ebp+var_10], eax
.text$mn:00004192                 mov     eax, [ebp+arg_0]
.text$mn:00004195                 jmp     short loc_41BC
.text$mn:00004197 ; ---------------------------------------------------------------------------
.text$mn:00004197                 jmp     short loc_41BC
.text$mn:00004199 ; ---------------------------------------------------------------------------
.text$mn:00004199
.text$mn:00004199 loc_4199:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00004199                 mov     ecx, [ebp+arg_4]
.text$mn:0000419C                 push    ecx
.text$mn:0000419D                 mov     edx, [ebp+arg_0]
.text$mn:000041A0                 push    edx
.text$mn:000041A1                 mov     ecx, [ebp+var_14]
.text$mn:000041A4                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:000041A9                 mov     [ebp+var_4], 0
.text$mn:000041B0                 mov     eax, [ebp+var_10]
.text$mn:000041B3                 or      eax, 1
.text$mn:000041B6                 mov     [ebp+var_10], eax
.text$mn:000041B9                 mov     eax, [ebp+arg_0]
.text$mn:000041BC
.text$mn:000041BC loc_41BC:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:000041BC                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:000041BC                 mov     ecx, [ebp+var_C]
.text$mn:000041BF                 mov     large fs:0, ecx
.text$mn:000041C6                 pop     ecx
.text$mn:000041C7                 mov     esp, ebp
.text$mn:000041C9                 pop     ebp
.text$mn:000041CA                 retn    8
.text$mn:000041CA ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000041CA
.text$mn:000041CA ; ---------------------------------------------------------------------------
.text$mn:000041CD                 align 10h
.text$mn:000041CD _text$mn        ends
.text$mn:000041CD
.text$x:000041D0 ; ===========================================================================
.text$x:000041D0
.text$x:000041D0 ; Segment type: Pure code
.text$x:000041D0 ; Segment permissions: Read/Execute
.text$x:000041D0 _text$x         segment para public 'CODE' use32
.text$x:000041D0                 assume cs:_text$x
.text$x:000041D0                 ;org 41D0h
.text$x:000041D0 ; COMDAT (pick associative to section at 4140)
.text$x:000041D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000041D0
.text$x:000041D0 ; =============== S U B R O U T I N E =======================================
.text$x:000041D0
.text$x:000041D0
.text$x:000041D0 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000041D0                                         ; DATA XREF: .xdata$x:00004704o
.text$x:000041D0                 mov     eax, [ebp-10h]
.text$x:000041D3                 and     eax, 1
.text$x:000041D6                 jz      $LN6_1
.text$x:000041DC                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000041E0                 mov     ecx, [ebp+8]
.text$x:000041E3                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000041E8 ; ---------------------------------------------------------------------------
.text$x:000041E8
.text$x:000041E8 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000041E8                 retn
.text$x:000041E8 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000041E8
.text$x:000041E9
.text$x:000041E9 ; =============== S U B R O U T I N E =======================================
.text$x:000041E9
.text$x:000041E9
.text$x:000041E9 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000041E9                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:000041E9
.text$x:000041E9 arg_4           = dword ptr  8
.text$x:000041E9
.text$x:000041E9                 mov     edx, [esp+arg_4]
.text$x:000041ED                 lea     eax, [edx+0Ch]
.text$x:000041F0                 mov     ecx, [edx-0Ch]
.text$x:000041F3                 xor     ecx, eax
.text$x:000041F5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000041FA                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000041FF                 jmp     ___CxxFrameHandler3
.text$x:000041FF __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000041FF
.text$x:000041FF _text$x         ends
.text$x:000041FF
.text$mn:00004204 ; ===========================================================================
.text$mn:00004204
.text$mn:00004204 ; Segment type: Pure code
.text$mn:00004204 ; Segment permissions: Read/Execute
.text$mn:00004204 _text$mn        segment para public 'CODE' use32
.text$mn:00004204                 assume cs:_text$mn
.text$mn:00004204                 ;org 4204h
.text$mn:00004204 ; COMDAT (pick any)
.text$mn:00004204                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004204
.text$mn:00004204 ; =============== S U B R O U T I N E =======================================
.text$mn:00004204
.text$mn:00004204 ; Attributes: bp-based frame
.text$mn:00004204
.text$mn:00004204 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00004204                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00004204 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00004204                                         ; DATA XREF: .rdata:0000496Co
.text$mn:00004204
.text$mn:00004204 var_1C          = dword ptr -1Ch
.text$mn:00004204 var_18          = dword ptr -18h
.text$mn:00004204 Str             = dword ptr -14h
.text$mn:00004204 var_10          = dword ptr -10h
.text$mn:00004204 var_C           = dword ptr -0Ch
.text$mn:00004204 var_4           = dword ptr -4
.text$mn:00004204 arg_0           = dword ptr  8
.text$mn:00004204 arg_4           = dword ptr  0Ch
.text$mn:00004204
.text$mn:00004204                 push    ebp
.text$mn:00004205                 mov     ebp, esp
.text$mn:00004207                 push    0FFFFFFFFh
.text$mn:00004209                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000420E                 mov     eax, large fs:0
.text$mn:00004214                 push    eax
.text$mn:00004215                 sub     esp, 10h
.text$mn:00004218                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000421D                 xor     eax, ebp
.text$mn:0000421F                 push    eax
.text$mn:00004220                 lea     eax, [ebp+var_C]
.text$mn:00004223                 mov     large fs:0, eax
.text$mn:00004229                 mov     [ebp+var_1C], ecx
.text$mn:0000422C                 mov     [ebp+var_18], 0
.text$mn:00004233                 mov     eax, [ebp+arg_4]
.text$mn:00004236                 push    eax             ; int
.text$mn:00004237                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:0000423C                 add     esp, 4
.text$mn:0000423F                 mov     [ebp+var_10], eax
.text$mn:00004242                 cmp     [ebp+var_10], 0
.text$mn:00004246                 jz      short loc_4250
.text$mn:00004248                 mov     ecx, [ebp+var_10]
.text$mn:0000424B                 mov     [ebp+Str], ecx
.text$mn:0000424E                 jmp     short loc_4257
.text$mn:00004250 ; ---------------------------------------------------------------------------
.text$mn:00004250
.text$mn:00004250 loc_4250:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00004250                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00004257
.text$mn:00004257 loc_4257:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00004257                 mov     edx, [ebp+Str]
.text$mn:0000425A                 push    edx             ; Str
.text$mn:0000425B                 mov     ecx, [ebp+arg_0]
.text$mn:0000425E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00004263                 mov     [ebp+var_4], 0
.text$mn:0000426A                 mov     eax, [ebp+var_18]
.text$mn:0000426D                 or      eax, 1
.text$mn:00004270                 mov     [ebp+var_18], eax
.text$mn:00004273                 mov     eax, [ebp+arg_0]
.text$mn:00004276                 mov     ecx, [ebp+var_C]
.text$mn:00004279                 mov     large fs:0, ecx
.text$mn:00004280                 pop     ecx
.text$mn:00004281                 mov     esp, ebp
.text$mn:00004283                 pop     ebp
.text$mn:00004284                 retn    8
.text$mn:00004284 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00004284
.text$mn:00004284 ; ---------------------------------------------------------------------------
.text$mn:00004287                 align 4
.text$mn:00004287 _text$mn        ends
.text$mn:00004287
.text$x:00004288 ; ===========================================================================
.text$x:00004288
.text$x:00004288 ; Segment type: Pure code
.text$x:00004288 ; Segment permissions: Read/Execute
.text$x:00004288 _text$x         segment para public 'CODE' use32
.text$x:00004288                 assume cs:_text$x
.text$x:00004288                 ;org 4288h
.text$x:00004288 ; COMDAT (pick associative to section at 4204)
.text$x:00004288                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004288
.text$x:00004288 ; =============== S U B R O U T I N E =======================================
.text$x:00004288
.text$x:00004288
.text$x:00004288 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00004288                                         ; DATA XREF: .xdata$x:00004788o
.text$x:00004288                 mov     eax, [ebp-18h]
.text$x:0000428B                 and     eax, 1
.text$x:0000428E                 jz      $LN6_2
.text$x:00004294                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00004298                 mov     ecx, [ebp+8]
.text$x:0000429B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000042A0 ; ---------------------------------------------------------------------------
.text$x:000042A0
.text$x:000042A0 $LN6_2:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000042A0                 retn
.text$x:000042A0 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000042A0
.text$x:000042A1
.text$x:000042A1 ; =============== S U B R O U T I N E =======================================
.text$x:000042A1
.text$x:000042A1
.text$x:000042A1 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000042A1                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:000042A1
.text$x:000042A1 arg_4           = dword ptr  8
.text$x:000042A1
.text$x:000042A1                 mov     edx, [esp+arg_4]
.text$x:000042A5                 lea     eax, [edx+0Ch]
.text$x:000042A8                 mov     ecx, [edx-14h]
.text$x:000042AB                 xor     ecx, eax
.text$x:000042AD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000042B2                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000042B7                 jmp     ___CxxFrameHandler3
.text$x:000042B7 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000042B7
.text$x:000042B7 _text$x         ends
.text$x:000042B7
.text$mn:000042BC ; ===========================================================================
.text$mn:000042BC
.text$mn:000042BC ; Segment type: Pure code
.text$mn:000042BC ; Segment permissions: Read/Execute
.text$mn:000042BC _text$mn        segment para public 'CODE' use32
.text$mn:000042BC                 assume cs:_text$mn
.text$mn:000042BC                 ;org 42BCh
.text$mn:000042BC ; COMDAT (pick any)
.text$mn:000042BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000042BC
.text$mn:000042BC ; =============== S U B R O U T I N E =======================================
.text$mn:000042BC
.text$mn:000042BC ; Attributes: bp-based frame
.text$mn:000042BC
.text$mn:000042BC ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000042BC                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000042BC ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000042BC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000042BC
.text$mn:000042BC var_4           = dword ptr -4
.text$mn:000042BC Dst             = dword ptr  8
.text$mn:000042BC Src             = dword ptr  0Ch
.text$mn:000042BC Size            = dword ptr  10h
.text$mn:000042BC
.text$mn:000042BC                 push    ebp
.text$mn:000042BD                 mov     ebp, esp
.text$mn:000042BF                 push    ecx
.text$mn:000042C0                 cmp     [ebp+Size], 0
.text$mn:000042C4                 jnz     short loc_42CE
.text$mn:000042C6                 mov     eax, [ebp+Dst]
.text$mn:000042C9                 mov     [ebp+var_4], eax
.text$mn:000042CC                 jmp     short loc_42E5
.text$mn:000042CE ; ---------------------------------------------------------------------------
.text$mn:000042CE
.text$mn:000042CE loc_42CE:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:000042CE                 mov     ecx, [ebp+Size]
.text$mn:000042D1                 push    ecx             ; Size
.text$mn:000042D2                 mov     edx, [ebp+Src]
.text$mn:000042D5                 push    edx             ; Src
.text$mn:000042D6                 mov     eax, [ebp+Dst]
.text$mn:000042D9                 push    eax             ; Dst
.text$mn:000042DA                 call    _memmove
.text$mn:000042DF                 add     esp, 0Ch
.text$mn:000042E2                 mov     [ebp+var_4], eax
.text$mn:000042E5
.text$mn:000042E5 loc_42E5:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:000042E5                 mov     eax, [ebp+var_4]
.text$mn:000042E8                 mov     esp, ebp
.text$mn:000042EA                 pop     ebp
.text$mn:000042EB                 retn
.text$mn:000042EB ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000042EB
.text$mn:000042EB _text$mn        ends
.text$mn:000042EB
.text$mn:000042EC ; ===========================================================================
.text$mn:000042EC
.text$mn:000042EC ; Segment type: Pure code
.text$mn:000042EC ; Segment permissions: Read/Execute
.text$mn:000042EC _text$mn        segment para public 'CODE' use32
.text$mn:000042EC                 assume cs:_text$mn
.text$mn:000042EC                 ;org 42ECh
.text$mn:000042EC ; COMDAT (pick any)
.text$mn:000042EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000042EC
.text$mn:000042EC ; =============== S U B R O U T I N E =======================================
.text$mn:000042EC
.text$mn:000042EC ; Attributes: bp-based frame
.text$mn:000042EC
.text$mn:000042EC ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:000042EC                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:000042EC ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:000042EC                                         ; DATA XREF: .rdata:000048F4o
.text$mn:000042EC
.text$mn:000042EC var_4           = dword ptr -4
.text$mn:000042EC
.text$mn:000042EC                 push    ebp
.text$mn:000042ED                 mov     ebp, esp
.text$mn:000042EF                 push    ecx
.text$mn:000042F0                 mov     [ebp+var_4], ecx
.text$mn:000042F3                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:000042F8                 mov     esp, ebp
.text$mn:000042FA                 pop     ebp
.text$mn:000042FB                 retn
.text$mn:000042FB ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:000042FB
.text$mn:000042FB _text$mn        ends
.text$mn:000042FB
.text$mn:000042FC ; ===========================================================================
.text$mn:000042FC
.text$mn:000042FC ; Segment type: Pure code
.text$mn:000042FC ; Segment permissions: Read/Execute
.text$mn:000042FC _text$mn        segment para public 'CODE' use32
.text$mn:000042FC                 assume cs:_text$mn
.text$mn:000042FC                 ;org 42FCh
.text$mn:000042FC ; COMDAT (pick any)
.text$mn:000042FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000042FC
.text$mn:000042FC ; =============== S U B R O U T I N E =======================================
.text$mn:000042FC
.text$mn:000042FC ; Attributes: bp-based frame
.text$mn:000042FC
.text$mn:000042FC ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:000042FC                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:000042FC ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:000042FC                                         ; DATA XREF: .rdata:00004928o
.text$mn:000042FC
.text$mn:000042FC var_4           = dword ptr -4
.text$mn:000042FC
.text$mn:000042FC                 push    ebp
.text$mn:000042FD                 mov     ebp, esp
.text$mn:000042FF                 push    ecx
.text$mn:00004300                 mov     [ebp+var_4], ecx
.text$mn:00004303                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00004308                 mov     esp, ebp
.text$mn:0000430A                 pop     ebp
.text$mn:0000430B                 retn
.text$mn:0000430B ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000430B
.text$mn:0000430B _text$mn        ends
.text$mn:0000430B
.text$mn:0000430C ; ===========================================================================
.text$mn:0000430C
.text$mn:0000430C ; Segment type: Pure code
.text$mn:0000430C ; Segment permissions: Read/Execute
.text$mn:0000430C _text$mn        segment para public 'CODE' use32
.text$mn:0000430C                 assume cs:_text$mn
.text$mn:0000430C                 ;org 430Ch
.text$mn:0000430C ; COMDAT (pick any)
.text$mn:0000430C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000430C
.text$mn:0000430C ; =============== S U B R O U T I N E =======================================
.text$mn:0000430C
.text$mn:0000430C ; Attributes: bp-based frame
.text$mn:0000430C
.text$mn:0000430C ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:0000430C                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:0000430C ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:0000430C                                         ; DATA XREF: .rdata:00004968o
.text$mn:0000430C
.text$mn:0000430C var_4           = dword ptr -4
.text$mn:0000430C
.text$mn:0000430C                 push    ebp
.text$mn:0000430D                 mov     ebp, esp
.text$mn:0000430F                 push    ecx
.text$mn:00004310                 mov     [ebp+var_4], ecx
.text$mn:00004313                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00004318                 mov     esp, ebp
.text$mn:0000431A                 pop     ebp
.text$mn:0000431B                 retn
.text$mn:0000431B ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000431B
.text$mn:0000431B _text$mn        ends
.text$mn:0000431B
.text$mn:0000431C ; ===========================================================================
.text$mn:0000431C
.text$mn:0000431C ; Segment type: Pure code
.text$mn:0000431C ; Segment permissions: Read/Execute
.text$mn:0000431C _text$mn        segment para public 'CODE' use32
.text$mn:0000431C                 assume cs:_text$mn
.text$mn:0000431C                 ;org 431Ch
.text$mn:0000431C ; COMDAT (pick any)
.text$mn:0000431C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000431C
.text$mn:0000431C ; =============== S U B R O U T I N E =======================================
.text$mn:0000431C
.text$mn:0000431C ; Attributes: bp-based frame
.text$mn:0000431C
.text$mn:0000431C ; void __thiscall Window::reSizeTo(Window *this, struct tagRECT *)
.text$mn:0000431C                 public ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z
.text$mn:0000431C ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:0000431C                                         ; CODE XREF: TabBar::reSizeTo(tagRECT &)+59p
.text$mn:0000431C
.text$mn:0000431C var_4           = dword ptr -4
.text$mn:0000431C arg_0           = dword ptr  8
.text$mn:0000431C
.text$mn:0000431C                 push    ebp
.text$mn:0000431D                 mov     ebp, esp
.text$mn:0000431F                 push    ecx
.text$mn:00004320                 mov     [ebp+var_4], ecx
.text$mn:00004323                 push    1               ; bRepaint
.text$mn:00004325                 mov     eax, [ebp+arg_0]
.text$mn:00004328                 mov     ecx, [eax+0Ch]
.text$mn:0000432B                 push    ecx             ; nHeight
.text$mn:0000432C                 mov     edx, [ebp+arg_0]
.text$mn:0000432F                 mov     eax, [edx+8]
.text$mn:00004332                 push    eax             ; nWidth
.text$mn:00004333                 mov     ecx, [ebp+arg_0]
.text$mn:00004336                 mov     edx, [ecx+4]
.text$mn:00004339                 push    edx             ; Y
.text$mn:0000433A                 mov     eax, [ebp+arg_0]
.text$mn:0000433D                 mov     ecx, [eax]
.text$mn:0000433F                 push    ecx             ; X
.text$mn:00004340                 mov     edx, [ebp+var_4]
.text$mn:00004343                 mov     eax, [edx+0Ch]
.text$mn:00004346                 push    eax             ; hWnd
.text$mn:00004347                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:0000434D                 push    0
.text$mn:0000434F                 mov     ecx, [ebp+var_4]
.text$mn:00004352                 mov     edx, [ecx]
.text$mn:00004354                 mov     ecx, [ebp+var_4]
.text$mn:00004357                 mov     eax, [edx+18h]
.text$mn:0000435A                 call    eax
.text$mn:0000435C                 mov     esp, ebp
.text$mn:0000435E                 pop     ebp
.text$mn:0000435F                 retn    4
.text$mn:0000435F ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:0000435F
.text$mn:0000435F ; ---------------------------------------------------------------------------
.text$mn:00004362                 align 4
.text$mn:00004362 _text$mn        ends
.text$mn:00004362
.text$mn:00004364 ; ===========================================================================
.text$mn:00004364
.text$mn:00004364 ; Segment type: Pure code
.text$mn:00004364 ; Segment permissions: Read/Execute
.text$mn:00004364 _text$mn        segment para public 'CODE' use32
.text$mn:00004364                 assume cs:_text$mn
.text$mn:00004364                 ;org 4364h
.text$mn:00004364 ; COMDAT (pick any)
.text$mn:00004364                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004364
.text$mn:00004364 ; =============== S U B R O U T I N E =======================================
.text$mn:00004364
.text$mn:00004364 ; Attributes: bp-based frame
.text$mn:00004364
.text$mn:00004364 ; int __thiscall DPIManager::scaleX(DPIManager *this, int)
.text$mn:00004364                 public ?scaleX@DPIManager@@QAEHH@Z
.text$mn:00004364 ?scaleX@DPIManager@@QAEHH@Z proc near   ; CODE XREF: CloseButtonZone::CloseButtonZone(void)+13p
.text$mn:00004364                                         ; CloseButtonZone::CloseButtonZone(void)+57p ...
.text$mn:00004364
.text$mn:00004364 var_4           = dword ptr -4
.text$mn:00004364 nNumber         = dword ptr  8
.text$mn:00004364
.text$mn:00004364                 push    ebp
.text$mn:00004365                 mov     ebp, esp
.text$mn:00004367                 push    ecx
.text$mn:00004368                 mov     [ebp+var_4], ecx
.text$mn:0000436B                 push    60h ; '`'       ; nDenominator
.text$mn:0000436D                 mov     eax, [ebp+var_4]
.text$mn:00004370                 mov     ecx, [eax]
.text$mn:00004372                 push    ecx             ; nNumerator
.text$mn:00004373                 mov     edx, [ebp+nNumber]
.text$mn:00004376                 push    edx             ; nNumber
.text$mn:00004377                 call    dword ptr ds:__imp__MulDiv@12 ; MulDiv(x,x,x)
.text$mn:0000437D                 mov     esp, ebp
.text$mn:0000437F                 pop     ebp
.text$mn:00004380                 retn    4
.text$mn:00004380 ?scaleX@DPIManager@@QAEHH@Z endp
.text$mn:00004380
.text$mn:00004380 ; ---------------------------------------------------------------------------
.text$mn:00004383                 align 4
.text$mn:00004383 _text$mn        ends
.text$mn:00004383
.text$mn:00004384 ; ===========================================================================
.text$mn:00004384
.text$mn:00004384 ; Segment type: Pure code
.text$mn:00004384 ; Segment permissions: Read/Execute
.text$mn:00004384 _text$mn        segment para public 'CODE' use32
.text$mn:00004384                 assume cs:_text$mn
.text$mn:00004384                 ;org 4384h
.text$mn:00004384 ; COMDAT (pick any)
.text$mn:00004384                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004384
.text$mn:00004384 ; =============== S U B R O U T I N E =======================================
.text$mn:00004384
.text$mn:00004384 ; Attributes: bp-based frame
.text$mn:00004384
.text$mn:00004384 ; int __thiscall DPIManager::scaleY(DPIManager *this, int)
.text$mn:00004384                 public ?scaleY@DPIManager@@QAEHH@Z
.text$mn:00004384 ?scaleY@DPIManager@@QAEHH@Z proc near   ; CODE XREF: CloseButtonZone::CloseButtonZone(void)+29p
.text$mn:00004384                                         ; CloseButtonZone::CloseButtonZone(void)+40p ...
.text$mn:00004384
.text$mn:00004384 var_4           = dword ptr -4
.text$mn:00004384 nNumber         = dword ptr  8
.text$mn:00004384
.text$mn:00004384                 push    ebp
.text$mn:00004385                 mov     ebp, esp
.text$mn:00004387                 push    ecx
.text$mn:00004388                 mov     [ebp+var_4], ecx
.text$mn:0000438B                 push    60h ; '`'       ; nDenominator
.text$mn:0000438D                 mov     eax, [ebp+var_4]
.text$mn:00004390                 mov     ecx, [eax+4]
.text$mn:00004393                 push    ecx             ; nNumerator
.text$mn:00004394                 mov     edx, [ebp+nNumber]
.text$mn:00004397                 push    edx             ; nNumber
.text$mn:00004398                 call    dword ptr ds:__imp__MulDiv@12 ; MulDiv(x,x,x)
.text$mn:0000439E                 mov     esp, ebp
.text$mn:000043A0                 pop     ebp
.text$mn:000043A1                 retn    4
.text$mn:000043A1 ?scaleY@DPIManager@@QAEHH@Z endp
.text$mn:000043A1
.text$mn:000043A1 _text$mn        ends
.text$mn:000043A1
.text$mn:000043A4 ; ===========================================================================
.text$mn:000043A4
.text$mn:000043A4 ; Segment type: Pure code
.text$mn:000043A4 ; Segment permissions: Read/Execute
.text$mn:000043A4 _text$mn        segment para public 'CODE' use32
.text$mn:000043A4                 assume cs:_text$mn
.text$mn:000043A4                 ;org 43A4h
.text$mn:000043A4 ; COMDAT (pick any)
.text$mn:000043A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043A4
.text$mn:000043A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000043A4
.text$mn:000043A4 ; Attributes: bp-based frame
.text$mn:000043A4
.text$mn:000043A4 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:000043A4                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000043A4 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000043A4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:000043A4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:000043A4
.text$mn:000043A4 var_4           = dword ptr -4
.text$mn:000043A4
.text$mn:000043A4                 push    ebp
.text$mn:000043A5                 mov     ebp, esp
.text$mn:000043A7                 push    ecx
.text$mn:000043A8                 mov     [ebp+var_4], ecx
.text$mn:000043AB                 mov     eax, [ebp+var_4]
.text$mn:000043AE                 mov     eax, [eax+14h]
.text$mn:000043B1                 mov     esp, ebp
.text$mn:000043B3                 pop     ebp
.text$mn:000043B4                 retn
.text$mn:000043B4 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:000043B4
.text$mn:000043B4 ; ---------------------------------------------------------------------------
.text$mn:000043B5                 align 4
.text$mn:000043B5 _text$mn        ends
.text$mn:000043B5
.text$mn:000043B8 ; ===========================================================================
.text$mn:000043B8
.text$mn:000043B8 ; Segment type: Pure code
.text$mn:000043B8 ; Segment permissions: Read/Execute
.text$mn:000043B8 _text$mn        segment para public 'CODE' use32
.text$mn:000043B8                 assume cs:_text$mn
.text$mn:000043B8                 ;org 43B8h
.text$mn:000043B8 ; COMDAT (pick any)
.text$mn:000043B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043B8
.text$mn:000043B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000043B8
.text$mn:000043B8 ; Attributes: bp-based frame
.text$mn:000043B8
.text$mn:000043B8 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:000043B8                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:000043B8 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000043B8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_3D24p
.text$mn:000043B8                 push    ebp
.text$mn:000043B9                 mov     ebp, esp
.text$mn:000043BB                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:000043C0                 pop     ebp
.text$mn:000043C1                 retn
.text$mn:000043C1 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000043C1
.text$mn:000043C1 ; ---------------------------------------------------------------------------
.text$mn:000043C2                 align 4
.text$mn:000043C2 _text$mn        ends
.text$mn:000043C2
.text$mn:000043C4 ; ===========================================================================
.text$mn:000043C4
.text$mn:000043C4 ; Segment type: Pure code
.text$mn:000043C4 ; Segment permissions: Read/Execute
.text$mn:000043C4 _text$mn        segment para public 'CODE' use32
.text$mn:000043C4                 assume cs:_text$mn
.text$mn:000043C4                 ;org 43C4h
.text$mn:000043C4 ; COMDAT (pick any)
.text$mn:000043C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043C4
.text$mn:000043C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000043C4
.text$mn:000043C4 ; Attributes: bp-based frame
.text$mn:000043C4
.text$mn:000043C4 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:000043C4                 public ?value@error_code@std@@QBEHXZ
.text$mn:000043C4 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:000043C4
.text$mn:000043C4 var_4           = dword ptr -4
.text$mn:000043C4
.text$mn:000043C4                 push    ebp
.text$mn:000043C5                 mov     ebp, esp
.text$mn:000043C7                 push    ecx
.text$mn:000043C8                 mov     [ebp+var_4], ecx
.text$mn:000043CB                 mov     eax, [ebp+var_4]
.text$mn:000043CE                 mov     eax, [eax]
.text$mn:000043D0                 mov     esp, ebp
.text$mn:000043D2                 pop     ebp
.text$mn:000043D3                 retn
.text$mn:000043D3 ?value@error_code@std@@QBEHXZ endp
.text$mn:000043D3
.text$mn:000043D3 _text$mn        ends
.text$mn:000043D3
.text$mn:000043D4 ; ===========================================================================
.text$mn:000043D4
.text$mn:000043D4 ; Segment type: Pure code
.text$mn:000043D4 ; Segment permissions: Read/Execute
.text$mn:000043D4 _text$mn        segment para public 'CODE' use32
.text$mn:000043D4                 assume cs:_text$mn
.text$mn:000043D4                 ;org 43D4h
.text$mn:000043D4 ; COMDAT (pick any)
.text$mn:000043D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043D4
.text$mn:000043D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000043D4
.text$mn:000043D4 ; Attributes: bp-based frame
.text$mn:000043D4
.text$mn:000043D4 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:000043D4                 public ?value@error_condition@std@@QBEHXZ
.text$mn:000043D4 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:000043D4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:000043D4                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:000043D4
.text$mn:000043D4 var_4           = dword ptr -4
.text$mn:000043D4
.text$mn:000043D4                 push    ebp
.text$mn:000043D5                 mov     ebp, esp
.text$mn:000043D7                 push    ecx
.text$mn:000043D8                 mov     [ebp+var_4], ecx
.text$mn:000043DB                 mov     eax, [ebp+var_4]
.text$mn:000043DE                 mov     eax, [eax]
.text$mn:000043E0                 mov     esp, ebp
.text$mn:000043E2                 pop     ebp
.text$mn:000043E3                 retn
.text$mn:000043E3 ?value@error_condition@std@@QBEHXZ endp
.text$mn:000043E3
.text$mn:000043E3 _text$mn        ends
.text$mn:000043E3
.text$mn:000043E4 ; ===========================================================================
.text$mn:000043E4
.text$mn:000043E4 ; Segment type: Pure code
.text$mn:000043E4 ; Segment permissions: Read/Execute
.text$mn:000043E4 _text$mn        segment para public 'CODE' use32
.text$mn:000043E4                 assume cs:_text$mn
.text$mn:000043E4                 ;org 43E4h
.text$mn:000043E4 ; COMDAT (pick any)
.text$mn:000043E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043E4
.text$mn:000043E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000043E4
.text$mn:000043E4 ; Attributes: bp-based frame
.text$mn:000043E4
.text$mn:000043E4                 public _hypot
.text$mn:000043E4 _hypot          proc near
.text$mn:000043E4
.text$mn:000043E4 var_10          = qword ptr -10h
.text$mn:000043E4 var_8           = qword ptr -8
.text$mn:000043E4 arg_0           = qword ptr  8
.text$mn:000043E4 arg_8           = qword ptr  10h
.text$mn:000043E4
.text$mn:000043E4                 push    ebp
.text$mn:000043E5                 mov     ebp, esp
.text$mn:000043E7                 sub     esp, 8
.text$mn:000043EA                 movsd   xmm0, [ebp+arg_8]
.text$mn:000043EF                 movsd   [esp+8+var_8], xmm0
.text$mn:000043F4                 sub     esp, 8
.text$mn:000043F7                 movsd   xmm0, [ebp+arg_0]
.text$mn:000043FC                 movsd   [esp+10h+var_10], xmm0
.text$mn:00004401                 call    __hypot
.text$mn:00004406                 add     esp, 10h
.text$mn:00004409                 pop     ebp
.text$mn:0000440A                 retn
.text$mn:0000440A _hypot          endp
.text$mn:0000440A
.text$mn:0000440A ; ---------------------------------------------------------------------------
.text$mn:0000440B                 align 4
.text$mn:0000440B _text$mn        ends
.text$mn:0000440B
.xdata$x:0000440C ; ===========================================================================
.xdata$x:0000440C
.xdata$x:0000440C ; Segment type: Pure data
.xdata$x:0000440C ; Segment permissions: Read
.xdata$x:0000440C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000440C                 assume cs:_xdata$x
.xdata$x:0000440C                 ;org 440Ch
.xdata$x:0000440C ; COMDAT (pick associative to section at 38C8)
.xdata$x:0000440C __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:0000440C                                         ; DATA XREF: .xdata$x:0000441Co
.xdata$x:0000440D                 db 0FFh
.xdata$x:0000440E                 db 0FFh
.xdata$x:0000440F                 db 0FFh
.xdata$x:00004410                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00004414 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00004414                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00004415                 db    5
.xdata$x:00004416                 db  93h ; ô
.xdata$x:00004417                 db  19h
.xdata$x:00004418                 db    1
.xdata$x:00004419                 db    0
.xdata$x:0000441A                 db    0
.xdata$x:0000441B                 db    0
.xdata$x:0000441C                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00004420                 db    0
.xdata$x:00004421                 db    0
.xdata$x:00004422                 db    0
.xdata$x:00004423                 db    0
.xdata$x:00004424                 db    0
.xdata$x:00004425                 db    0
.xdata$x:00004426                 db    0
.xdata$x:00004427                 db    0
.xdata$x:00004428                 db    0
.xdata$x:00004429                 db    0
.xdata$x:0000442A                 db    0
.xdata$x:0000442B                 db    0
.xdata$x:0000442C                 db    0
.xdata$x:0000442D                 db    0
.xdata$x:0000442E                 db    0
.xdata$x:0000442F                 db    0
.xdata$x:00004430                 db    0
.xdata$x:00004431                 db    0
.xdata$x:00004432                 db    0
.xdata$x:00004433                 db    0
.xdata$x:00004434                 db    0
.xdata$x:00004435                 db    0
.xdata$x:00004436                 db    0
.xdata$x:00004437                 db    0
.xdata$x:00004437 _xdata$x        ends
.xdata$x:00004437
.xdata$x:00004438 ; ===========================================================================
.xdata$x:00004438
.xdata$x:00004438 ; Segment type: Pure data
.xdata$x:00004438 ; Segment permissions: Read
.xdata$x:00004438 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004438                 assume cs:_xdata$x
.xdata$x:00004438                 ;org 4438h
.xdata$x:00004438 ; COMDAT (pick associative to section at 2A84)
.xdata$x:00004438 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00004438                                         ; DATA XREF: .xdata$x:00004448o
.xdata$x:00004439                 db 0FFh
.xdata$x:0000443A                 db 0FFh
.xdata$x:0000443B                 db 0FFh
.xdata$x:0000443C                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00004440 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00004440                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00004441                 db    5
.xdata$x:00004442                 db  93h ; ô
.xdata$x:00004443                 db  19h
.xdata$x:00004444                 db    1
.xdata$x:00004445                 db    0
.xdata$x:00004446                 db    0
.xdata$x:00004447                 db    0
.xdata$x:00004448                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000444C                 db    0
.xdata$x:0000444D                 db    0
.xdata$x:0000444E                 db    0
.xdata$x:0000444F                 db    0
.xdata$x:00004450                 db    0
.xdata$x:00004451                 db    0
.xdata$x:00004452                 db    0
.xdata$x:00004453                 db    0
.xdata$x:00004454                 db    0
.xdata$x:00004455                 db    0
.xdata$x:00004456                 db    0
.xdata$x:00004457                 db    0
.xdata$x:00004458                 db    0
.xdata$x:00004459                 db    0
.xdata$x:0000445A                 db    0
.xdata$x:0000445B                 db    0
.xdata$x:0000445C                 db    0
.xdata$x:0000445D                 db    0
.xdata$x:0000445E                 db    0
.xdata$x:0000445F                 db    0
.xdata$x:00004460                 db    0
.xdata$x:00004461                 db    0
.xdata$x:00004462                 db    0
.xdata$x:00004463                 db    0
.xdata$x:00004463 _xdata$x        ends
.xdata$x:00004463
.xdata$x:00004464 ; ===========================================================================
.xdata$x:00004464
.xdata$x:00004464 ; Segment type: Pure data
.xdata$x:00004464 ; Segment permissions: Read
.xdata$x:00004464 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004464                 assume cs:_xdata$x
.xdata$x:00004464                 ;org 4464h
.xdata$x:00004464 ; COMDAT (pick associative to section at 2F60)
.xdata$x:00004464 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00004464                                         ; DATA XREF: .xdata$x:00004474o
.xdata$x:00004465                 db 0FFh
.xdata$x:00004466                 db 0FFh
.xdata$x:00004467                 db 0FFh
.xdata$x:00004468                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000446C __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000446C                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000446D                 db    5
.xdata$x:0000446E                 db  93h ; ô
.xdata$x:0000446F                 db  19h
.xdata$x:00004470                 db    1
.xdata$x:00004471                 db    0
.xdata$x:00004472                 db    0
.xdata$x:00004473                 db    0
.xdata$x:00004474                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00004478                 db    0
.xdata$x:00004479                 db    0
.xdata$x:0000447A                 db    0
.xdata$x:0000447B                 db    0
.xdata$x:0000447C                 db    0
.xdata$x:0000447D                 db    0
.xdata$x:0000447E                 db    0
.xdata$x:0000447F                 db    0
.xdata$x:00004480                 db    0
.xdata$x:00004481                 db    0
.xdata$x:00004482                 db    0
.xdata$x:00004483                 db    0
.xdata$x:00004484                 db    0
.xdata$x:00004485                 db    0
.xdata$x:00004486                 db    0
.xdata$x:00004487                 db    0
.xdata$x:00004488                 db    0
.xdata$x:00004489                 db    0
.xdata$x:0000448A                 db    0
.xdata$x:0000448B                 db    0
.xdata$x:0000448C                 db    0
.xdata$x:0000448D                 db    0
.xdata$x:0000448E                 db    0
.xdata$x:0000448F                 db    0
.xdata$x:0000448F _xdata$x        ends
.xdata$x:0000448F
.xdata$x:00004490 ; ===========================================================================
.xdata$x:00004490
.xdata$x:00004490 ; Segment type: Pure data
.xdata$x:00004490 ; Segment permissions: Read
.xdata$x:00004490 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004490                 assume cs:_xdata$x
.xdata$x:00004490                 ;org 4490h
.xdata$x:00004490 ; COMDAT (pick associative to section at 2A08)
.xdata$x:00004490 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00004490                                         ; DATA XREF: .xdata$x:000044A0o
.xdata$x:00004491                 db 0FFh
.xdata$x:00004492                 db 0FFh
.xdata$x:00004493                 db 0FFh
.xdata$x:00004494                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00004498 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00004498                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00004499                 db    5
.xdata$x:0000449A                 db  93h ; ô
.xdata$x:0000449B                 db  19h
.xdata$x:0000449C                 db    1
.xdata$x:0000449D                 db    0
.xdata$x:0000449E                 db    0
.xdata$x:0000449F                 db    0
.xdata$x:000044A0                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:000044A4                 db    0
.xdata$x:000044A5                 db    0
.xdata$x:000044A6                 db    0
.xdata$x:000044A7                 db    0
.xdata$x:000044A8                 db    0
.xdata$x:000044A9                 db    0
.xdata$x:000044AA                 db    0
.xdata$x:000044AB                 db    0
.xdata$x:000044AC                 db    0
.xdata$x:000044AD                 db    0
.xdata$x:000044AE                 db    0
.xdata$x:000044AF                 db    0
.xdata$x:000044B0                 db    0
.xdata$x:000044B1                 db    0
.xdata$x:000044B2                 db    0
.xdata$x:000044B3                 db    0
.xdata$x:000044B4                 db    0
.xdata$x:000044B5                 db    0
.xdata$x:000044B6                 db    0
.xdata$x:000044B7                 db    0
.xdata$x:000044B8                 db    0
.xdata$x:000044B9                 db    0
.xdata$x:000044BA                 db    0
.xdata$x:000044BB                 db    0
.xdata$x:000044BB _xdata$x        ends
.xdata$x:000044BB
.xdata$x:000044BC ; ===========================================================================
.xdata$x:000044BC
.xdata$x:000044BC ; Segment type: Pure data
.xdata$x:000044BC ; Segment permissions: Read
.xdata$x:000044BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000044BC                 assume cs:_xdata$x
.xdata$x:000044BC                 ;org 44BCh
.xdata$x:000044BC ; COMDAT (pick associative to section at 2EE8)
.xdata$x:000044BC __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000044BC                                         ; DATA XREF: .xdata$x:000044CCo
.xdata$x:000044BD                 db 0FFh
.xdata$x:000044BE                 db 0FFh
.xdata$x:000044BF                 db 0FFh
.xdata$x:000044C0                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000044C4 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000044C4                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000044C5                 db    5
.xdata$x:000044C6                 db  93h ; ô
.xdata$x:000044C7                 db  19h
.xdata$x:000044C8                 db    1
.xdata$x:000044C9                 db    0
.xdata$x:000044CA                 db    0
.xdata$x:000044CB                 db    0
.xdata$x:000044CC                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:000044D0                 db    0
.xdata$x:000044D1                 db    0
.xdata$x:000044D2                 db    0
.xdata$x:000044D3                 db    0
.xdata$x:000044D4                 db    0
.xdata$x:000044D5                 db    0
.xdata$x:000044D6                 db    0
.xdata$x:000044D7                 db    0
.xdata$x:000044D8                 db    0
.xdata$x:000044D9                 db    0
.xdata$x:000044DA                 db    0
.xdata$x:000044DB                 db    0
.xdata$x:000044DC                 db    0
.xdata$x:000044DD                 db    0
.xdata$x:000044DE                 db    0
.xdata$x:000044DF                 db    0
.xdata$x:000044E0                 db    0
.xdata$x:000044E1                 db    0
.xdata$x:000044E2                 db    0
.xdata$x:000044E3                 db    0
.xdata$x:000044E4                 db    0
.xdata$x:000044E5                 db    0
.xdata$x:000044E6                 db    0
.xdata$x:000044E7                 db    0
.xdata$x:000044E7 _xdata$x        ends
.xdata$x:000044E7
.xdata$x:000044E8 ; ===========================================================================
.xdata$x:000044E8
.xdata$x:000044E8 ; Segment type: Pure data
.xdata$x:000044E8 ; Segment permissions: Read
.xdata$x:000044E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000044E8                 assume cs:_xdata$x
.xdata$x:000044E8                 ;org 44E8h
.xdata$x:000044E8 ; COMDAT (pick associative to section at 2B44)
.xdata$x:000044E8 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:000044E8                                         ; DATA XREF: .xdata$x:000044F8o
.xdata$x:000044E9                 db 0FFh
.xdata$x:000044EA                 db 0FFh
.xdata$x:000044EB                 db 0FFh
.xdata$x:000044EC                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:000044F0 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:000044F0                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:000044F1                 db    5
.xdata$x:000044F2                 db  93h ; ô
.xdata$x:000044F3                 db  19h
.xdata$x:000044F4                 db    1
.xdata$x:000044F5                 db    0
.xdata$x:000044F6                 db    0
.xdata$x:000044F7                 db    0
.xdata$x:000044F8                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:000044FC                 db    0
.xdata$x:000044FD                 db    0
.xdata$x:000044FE                 db    0
.xdata$x:000044FF                 db    0
.xdata$x:00004500                 db    0
.xdata$x:00004501                 db    0
.xdata$x:00004502                 db    0
.xdata$x:00004503                 db    0
.xdata$x:00004504                 db    0
.xdata$x:00004505                 db    0
.xdata$x:00004506                 db    0
.xdata$x:00004507                 db    0
.xdata$x:00004508                 db    0
.xdata$x:00004509                 db    0
.xdata$x:0000450A                 db    0
.xdata$x:0000450B                 db    0
.xdata$x:0000450C                 db    0
.xdata$x:0000450D                 db    0
.xdata$x:0000450E                 db    0
.xdata$x:0000450F                 db    0
.xdata$x:00004510                 db    0
.xdata$x:00004511                 db    0
.xdata$x:00004512                 db    0
.xdata$x:00004513                 db    0
.xdata$x:00004513 _xdata$x        ends
.xdata$x:00004513
.xdata$x:00004514 ; ===========================================================================
.xdata$x:00004514
.xdata$x:00004514 ; Segment type: Pure data
.xdata$x:00004514 ; Segment permissions: Read
.xdata$x:00004514 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004514                 assume cs:_xdata$x
.xdata$x:00004514                 ;org 4514h
.xdata$x:00004514 ; COMDAT (pick associative to section at 2FD0)
.xdata$x:00004514 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00004514                                         ; DATA XREF: .xdata$x:00004524o
.xdata$x:00004515                 db 0FFh
.xdata$x:00004516                 db 0FFh
.xdata$x:00004517                 db 0FFh
.xdata$x:00004518                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:0000451C __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000451C                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:0000451D                 db    5
.xdata$x:0000451E                 db  93h ; ô
.xdata$x:0000451F                 db  19h
.xdata$x:00004520                 db    1
.xdata$x:00004521                 db    0
.xdata$x:00004522                 db    0
.xdata$x:00004523                 db    0
.xdata$x:00004524                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00004528                 align 20h
.xdata$x:00004528 _xdata$x        ends
.xdata$x:00004528
.xdata$x:00004540 ; ===========================================================================
.xdata$x:00004540
.xdata$x:00004540 ; Segment type: Pure data
.xdata$x:00004540 ; Segment permissions: Read
.xdata$x:00004540 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004540                 assume cs:_xdata$x
.xdata$x:00004540                 ;org 4540h
.xdata$x:00004540 ; COMDAT (pick associative to section at 3524)
.xdata$x:00004540 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00004540                                         ; DATA XREF: .xdata$x:000045C8o
.xdata$x:00004541                 db    0
.xdata$x:00004542                 db    0
.xdata$x:00004543                 db    0
.xdata$x:00004544                 db    0
.xdata$x:00004545                 db    0
.xdata$x:00004546                 db    0
.xdata$x:00004547                 db    0
.xdata$x:00004548                 db    0
.xdata$x:00004549                 db    0
.xdata$x:0000454A                 db    0
.xdata$x:0000454B                 db    0
.xdata$x:0000454C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00004550 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00004550                                         ; DATA XREF: .xdata$x:000045B4o
.xdata$x:00004551                 db    0
.xdata$x:00004552                 db    0
.xdata$x:00004553                 db    0
.xdata$x:00004554                 db    0
.xdata$x:00004555                 db    0
.xdata$x:00004556                 db    0
.xdata$x:00004557                 db    0
.xdata$x:00004558                 db    0
.xdata$x:00004559                 db    0
.xdata$x:0000455A                 db    0
.xdata$x:0000455B                 db    0
.xdata$x:0000455C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00004560 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00004560                                         ; DATA XREF: .xdata$x:00004588o
.xdata$x:00004561                 db 0FFh
.xdata$x:00004562                 db 0FFh
.xdata$x:00004563                 db 0FFh
.xdata$x:00004564                 db    0
.xdata$x:00004565                 db    0
.xdata$x:00004566                 db    0
.xdata$x:00004567                 db    0
.xdata$x:00004568                 db 0FFh
.xdata$x:00004569                 db 0FFh
.xdata$x:0000456A                 db 0FFh
.xdata$x:0000456B                 db 0FFh
.xdata$x:0000456C                 db    0
.xdata$x:0000456D                 db    0
.xdata$x:0000456E                 db    0
.xdata$x:0000456F                 db    0
.xdata$x:00004570                 db    1
.xdata$x:00004571                 db    0
.xdata$x:00004572                 db    0
.xdata$x:00004573                 db    0
.xdata$x:00004574                 db    0
.xdata$x:00004575                 db    0
.xdata$x:00004576                 db    0
.xdata$x:00004577                 db    0
.xdata$x:00004578                 db    1
.xdata$x:00004579                 db    0
.xdata$x:0000457A                 db    0
.xdata$x:0000457B                 db    0
.xdata$x:0000457C                 db    0
.xdata$x:0000457D                 db    0
.xdata$x:0000457E                 db    0
.xdata$x:0000457F                 db    0
.xdata$x:00004580 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00004580                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00004581                 db    5
.xdata$x:00004582                 db  93h ; ô
.xdata$x:00004583                 db  19h
.xdata$x:00004584                 db    4
.xdata$x:00004585                 db    0
.xdata$x:00004586                 db    0
.xdata$x:00004587                 db    0
.xdata$x:00004588                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000458C                 db    2
.xdata$x:0000458D                 db    0
.xdata$x:0000458E                 db    0
.xdata$x:0000458F                 db    0
.xdata$x:00004590                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00004594                 db    0
.xdata$x:00004595                 db    0
.xdata$x:00004596                 db    0
.xdata$x:00004597                 db    0
.xdata$x:00004598                 db    0
.xdata$x:00004599                 db    0
.xdata$x:0000459A                 db    0
.xdata$x:0000459B                 db    0
.xdata$x:0000459C                 db    0
.xdata$x:0000459D                 db    0
.xdata$x:0000459E                 db    0
.xdata$x:0000459F                 db    0
.xdata$x:000045A0                 db    0
.xdata$x:000045A1                 db    0
.xdata$x:000045A2                 db    0
.xdata$x:000045A3                 db    0
.xdata$x:000045A4 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:000045A4                                         ; DATA XREF: .xdata$x:00004590o
.xdata$x:000045A5                 db    0
.xdata$x:000045A6                 db    0
.xdata$x:000045A7                 db    0
.xdata$x:000045A8                 db    2
.xdata$x:000045A9                 db    0
.xdata$x:000045AA                 db    0
.xdata$x:000045AB                 db    0
.xdata$x:000045AC                 db    3
.xdata$x:000045AD                 db    0
.xdata$x:000045AE                 db    0
.xdata$x:000045AF                 db    0
.xdata$x:000045B0                 db    1
.xdata$x:000045B1                 db    0
.xdata$x:000045B2                 db    0
.xdata$x:000045B3                 db    0
.xdata$x:000045B4                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:000045B8                 align 10h
.xdata$x:000045C0                 db    3
.xdata$x:000045C1                 db    0
.xdata$x:000045C2                 db    0
.xdata$x:000045C3                 db    0
.xdata$x:000045C4                 db    1
.xdata$x:000045C5                 db    0
.xdata$x:000045C6                 db    0
.xdata$x:000045C7                 db    0
.xdata$x:000045C8                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:000045C8 _xdata$x        ends
.xdata$x:000045C8
.xdata$x:000045CC ; ===========================================================================
.xdata$x:000045CC
.xdata$x:000045CC ; Segment type: Pure data
.xdata$x:000045CC ; Segment permissions: Read
.xdata$x:000045CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000045CC                 assume cs:_xdata$x
.xdata$x:000045CC                 ;org 45CCh
.xdata$x:000045CC ; COMDAT (pick associative to section at 2E64)
.xdata$x:000045CC __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:000045CC                                         ; DATA XREF: .xdata$x:000045DCo
.xdata$x:000045CD                 db 0FFh
.xdata$x:000045CE                 db 0FFh
.xdata$x:000045CF                 db 0FFh
.xdata$x:000045D0                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:000045D4 __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:000045D4                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:000045D5                 db    5
.xdata$x:000045D6                 db  93h ; ô
.xdata$x:000045D7                 db  19h
.xdata$x:000045D8                 db    1
.xdata$x:000045D9                 db    0
.xdata$x:000045DA                 db    0
.xdata$x:000045DB                 db    0
.xdata$x:000045DC                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:000045E0                 db    0
.xdata$x:000045E1                 db    0
.xdata$x:000045E2                 db    0
.xdata$x:000045E3                 db    0
.xdata$x:000045E4                 db    0
.xdata$x:000045E5                 db    0
.xdata$x:000045E6                 db    0
.xdata$x:000045E7                 db    0
.xdata$x:000045E8                 db    0
.xdata$x:000045E9                 db    0
.xdata$x:000045EA                 db    0
.xdata$x:000045EB                 db    0
.xdata$x:000045EC                 db    0
.xdata$x:000045ED                 db    0
.xdata$x:000045EE                 db    0
.xdata$x:000045EF                 db    0
.xdata$x:000045F0                 db    0
.xdata$x:000045F1                 db    0
.xdata$x:000045F2                 db    0
.xdata$x:000045F3                 db    0
.xdata$x:000045F4                 db    0
.xdata$x:000045F5                 db    0
.xdata$x:000045F6                 db    0
.xdata$x:000045F7                 db    0
.xdata$x:000045F7 _xdata$x        ends
.xdata$x:000045F7
.xdata$x:000045F8 ; ===========================================================================
.xdata$x:000045F8
.xdata$x:000045F8 ; Segment type: Pure data
.xdata$x:000045F8 ; Segment permissions: Read
.xdata$x:000045F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000045F8                 assume cs:_xdata$x
.xdata$x:000045F8                 ;org 45F8h
.xdata$x:000045F8 ; COMDAT (pick associative to section at 31C4)
.xdata$x:000045F8 __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:000045F8                                         ; DATA XREF: .xdata$x:00004608o
.xdata$x:000045F9                 db 0FFh
.xdata$x:000045FA                 db 0FFh
.xdata$x:000045FB                 db 0FFh
.xdata$x:000045FC                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:00004600 __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:00004600                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:00004601                 db    5
.xdata$x:00004602                 db  93h ; ô
.xdata$x:00004603                 db  19h
.xdata$x:00004604                 db    1
.xdata$x:00004605                 db    0
.xdata$x:00004606                 db    0
.xdata$x:00004607                 db    0
.xdata$x:00004608                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:0000460C                 db    0
.xdata$x:0000460D                 db    0
.xdata$x:0000460E                 db    0
.xdata$x:0000460F                 db    0
.xdata$x:00004610                 db    0
.xdata$x:00004611                 db    0
.xdata$x:00004612                 db    0
.xdata$x:00004613                 db    0
.xdata$x:00004614                 db    0
.xdata$x:00004615                 db    0
.xdata$x:00004616                 db    0
.xdata$x:00004617                 db    0
.xdata$x:00004618                 db    0
.xdata$x:00004619                 db    0
.xdata$x:0000461A                 db    0
.xdata$x:0000461B                 db    0
.xdata$x:0000461C                 db    0
.xdata$x:0000461D                 db    0
.xdata$x:0000461E                 db    0
.xdata$x:0000461F                 db    0
.xdata$x:00004620                 db    0
.xdata$x:00004621                 db    0
.xdata$x:00004622                 db    0
.xdata$x:00004623                 db    0
.xdata$x:00004623 _xdata$x        ends
.xdata$x:00004623
.xdata$x:00004624 ; ===========================================================================
.xdata$x:00004624
.xdata$x:00004624 ; Segment type: Pure data
.xdata$x:00004624 ; Segment permissions: Read
.xdata$x:00004624 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004624                 assume cs:_xdata$x
.xdata$x:00004624                 ;org 4624h
.xdata$x:00004624 ; COMDAT (pick associative to section at 2DE0)
.xdata$x:00004624 __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00004624                                         ; DATA XREF: .xdata$x:00004634o
.xdata$x:00004625                 db 0FFh
.xdata$x:00004626                 db 0FFh
.xdata$x:00004627                 db 0FFh
.xdata$x:00004628                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:0000462C __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000462C                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:0000462D                 db    5
.xdata$x:0000462E                 db  93h ; ô
.xdata$x:0000462F                 db  19h
.xdata$x:00004630                 db    1
.xdata$x:00004631                 db    0
.xdata$x:00004632                 db    0
.xdata$x:00004633                 db    0
.xdata$x:00004634                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:00004638                 db    0
.xdata$x:00004639                 db    0
.xdata$x:0000463A                 db    0
.xdata$x:0000463B                 db    0
.xdata$x:0000463C                 db    0
.xdata$x:0000463D                 db    0
.xdata$x:0000463E                 db    0
.xdata$x:0000463F                 db    0
.xdata$x:00004640                 db    0
.xdata$x:00004641                 db    0
.xdata$x:00004642                 db    0
.xdata$x:00004643                 db    0
.xdata$x:00004644                 db    0
.xdata$x:00004645                 db    0
.xdata$x:00004646                 db    0
.xdata$x:00004647                 db    0
.xdata$x:00004648                 db    0
.xdata$x:00004649                 db    0
.xdata$x:0000464A                 db    0
.xdata$x:0000464B                 db    0
.xdata$x:0000464C                 db    0
.xdata$x:0000464D                 db    0
.xdata$x:0000464E                 db    0
.xdata$x:0000464F                 db    0
.xdata$x:0000464F _xdata$x        ends
.xdata$x:0000464F
.xdata$x:00004650 ; ===========================================================================
.xdata$x:00004650
.xdata$x:00004650 ; Segment type: Pure data
.xdata$x:00004650 ; Segment permissions: Read
.xdata$x:00004650 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004650                 assume cs:_xdata$x
.xdata$x:00004650                 ;org 4650h
.xdata$x:00004650 ; COMDAT (pick associative to section at 2C18)
.xdata$x:00004650 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00004650                                         ; DATA XREF: .xdata$x:00004660o
.xdata$x:00004651                 db 0FFh
.xdata$x:00004652                 db 0FFh
.xdata$x:00004653                 db 0FFh
.xdata$x:00004654                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00004658 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00004658                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00004659                 db    5
.xdata$x:0000465A                 db  93h ; ô
.xdata$x:0000465B                 db  19h
.xdata$x:0000465C                 db    1
.xdata$x:0000465D                 db    0
.xdata$x:0000465E                 db    0
.xdata$x:0000465F                 db    0
.xdata$x:00004660                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00004664                 db    0
.xdata$x:00004665                 db    0
.xdata$x:00004666                 db    0
.xdata$x:00004667                 db    0
.xdata$x:00004668                 db    0
.xdata$x:00004669                 db    0
.xdata$x:0000466A                 db    0
.xdata$x:0000466B                 db    0
.xdata$x:0000466C                 db    0
.xdata$x:0000466D                 db    0
.xdata$x:0000466E                 db    0
.xdata$x:0000466F                 db    0
.xdata$x:00004670                 db    0
.xdata$x:00004671                 db    0
.xdata$x:00004672                 db    0
.xdata$x:00004673                 db    0
.xdata$x:00004674                 db    0
.xdata$x:00004675                 db    0
.xdata$x:00004676                 db    0
.xdata$x:00004677                 db    0
.xdata$x:00004678                 db    0
.xdata$x:00004679                 db    0
.xdata$x:0000467A                 db    0
.xdata$x:0000467B                 db    0
.xdata$x:0000467B _xdata$x        ends
.xdata$x:0000467B
.xdata$x:0000467C ; ===========================================================================
.xdata$x:0000467C
.xdata$x:0000467C ; Segment type: Pure data
.xdata$x:0000467C ; Segment permissions: Read
.xdata$x:0000467C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000467C                 assume cs:_xdata$x
.xdata$x:0000467C                 ;org 467Ch
.xdata$x:0000467C ; COMDAT (pick associative to section at 4088)
.xdata$x:0000467C __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000467C                                         ; DATA XREF: .xdata$x:0000468Co
.xdata$x:0000467D                 db 0FFh
.xdata$x:0000467E                 db 0FFh
.xdata$x:0000467F                 db 0FFh
.xdata$x:00004680                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00004684 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00004684                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00004685                 db    5
.xdata$x:00004686                 db  93h ; ô
.xdata$x:00004687                 db  19h
.xdata$x:00004688                 db    1
.xdata$x:00004689                 db    0
.xdata$x:0000468A                 db    0
.xdata$x:0000468B                 db    0
.xdata$x:0000468C                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00004690                 db    0
.xdata$x:00004691                 db    0
.xdata$x:00004692                 db    0
.xdata$x:00004693                 db    0
.xdata$x:00004694                 db    0
.xdata$x:00004695                 db    0
.xdata$x:00004696                 db    0
.xdata$x:00004697                 db    0
.xdata$x:00004698                 db    0
.xdata$x:00004699                 db    0
.xdata$x:0000469A                 db    0
.xdata$x:0000469B                 db    0
.xdata$x:0000469C                 db    0
.xdata$x:0000469D                 db    0
.xdata$x:0000469E                 db    0
.xdata$x:0000469F                 db    0
.xdata$x:000046A0                 db    0
.xdata$x:000046A1                 db    0
.xdata$x:000046A2                 db    0
.xdata$x:000046A3                 db    0
.xdata$x:000046A4                 db    0
.xdata$x:000046A5                 db    0
.xdata$x:000046A6                 db    0
.xdata$x:000046A7                 db    0
.xdata$x:000046A7 _xdata$x        ends
.xdata$x:000046A7
.xdata$x:000046A8 ; ===========================================================================
.xdata$x:000046A8
.xdata$x:000046A8 ; Segment type: Pure data
.xdata$x:000046A8 ; Segment permissions: Read
.xdata$x:000046A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000046A8                 assume cs:_xdata$x
.xdata$x:000046A8                 ;org 46A8h
.xdata$x:000046A8 ; COMDAT (pick associative to section at 3060)
.xdata$x:000046A8 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000046A8                                         ; DATA XREF: .xdata$x:000046B8o
.xdata$x:000046A9                 db 0FFh
.xdata$x:000046AA                 db 0FFh
.xdata$x:000046AB                 db 0FFh
.xdata$x:000046AC                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:000046B0 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000046B0                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:000046B1                 db    5
.xdata$x:000046B2                 db  93h ; ô
.xdata$x:000046B3                 db  19h
.xdata$x:000046B4                 db    1
.xdata$x:000046B5                 db    0
.xdata$x:000046B6                 db    0
.xdata$x:000046B7                 db    0
.xdata$x:000046B8                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:000046BC                 db    0
.xdata$x:000046BD                 db    0
.xdata$x:000046BE                 db    0
.xdata$x:000046BF                 db    0
.xdata$x:000046C0                 db    0
.xdata$x:000046C1                 db    0
.xdata$x:000046C2                 db    0
.xdata$x:000046C3                 db    0
.xdata$x:000046C4                 db    0
.xdata$x:000046C5                 db    0
.xdata$x:000046C6                 db    0
.xdata$x:000046C7                 db    0
.xdata$x:000046C8                 db    0
.xdata$x:000046C9                 db    0
.xdata$x:000046CA                 db    0
.xdata$x:000046CB                 db    0
.xdata$x:000046CC                 db    0
.xdata$x:000046CD                 db    0
.xdata$x:000046CE                 db    0
.xdata$x:000046CF                 db    0
.xdata$x:000046D0                 db    0
.xdata$x:000046D1                 db    0
.xdata$x:000046D2                 db    0
.xdata$x:000046D3                 db    0
.xdata$x:000046D3 _xdata$x        ends
.xdata$x:000046D3
.xdata$x:000046D4 ; ===========================================================================
.xdata$x:000046D4
.xdata$x:000046D4 ; Segment type: Pure data
.xdata$x:000046D4 ; Segment permissions: Read
.xdata$x:000046D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000046D4                 assume cs:_xdata$x
.xdata$x:000046D4                 ;org 46D4h
.xdata$x:000046D4 ; COMDAT (pick associative to section at 2C94)
.xdata$x:000046D4 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000046D4                                         ; DATA XREF: .xdata$x:000046E4o
.xdata$x:000046D5                 db 0FFh
.xdata$x:000046D6                 db 0FFh
.xdata$x:000046D7                 db 0FFh
.xdata$x:000046D8                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:000046DC __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000046DC                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:000046DD                 db    5
.xdata$x:000046DE                 db  93h ; ô
.xdata$x:000046DF                 db  19h
.xdata$x:000046E0                 db    1
.xdata$x:000046E1                 db    0
.xdata$x:000046E2                 db    0
.xdata$x:000046E3                 db    0
.xdata$x:000046E4                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:000046E8                 align 20h
.xdata$x:000046E8 _xdata$x        ends
.xdata$x:000046E8
.xdata$x:00004700 ; ===========================================================================
.xdata$x:00004700
.xdata$x:00004700 ; Segment type: Pure data
.xdata$x:00004700 ; Segment permissions: Read
.xdata$x:00004700 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004700                 assume cs:_xdata$x
.xdata$x:00004700                 ;org 4700h
.xdata$x:00004700 ; COMDAT (pick associative to section at 4140)
.xdata$x:00004700 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00004700                                         ; DATA XREF: .xdata$x:00004710o
.xdata$x:00004701                 db 0FFh
.xdata$x:00004702                 db 0FFh
.xdata$x:00004703                 db 0FFh
.xdata$x:00004704                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00004708 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00004708                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00004709                 db    5
.xdata$x:0000470A                 db  93h ; ô
.xdata$x:0000470B                 db  19h
.xdata$x:0000470C                 db    1
.xdata$x:0000470D                 db    0
.xdata$x:0000470E                 db    0
.xdata$x:0000470F                 db    0
.xdata$x:00004710                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00004714                 db    0
.xdata$x:00004715                 db    0
.xdata$x:00004716                 db    0
.xdata$x:00004717                 db    0
.xdata$x:00004718                 db    0
.xdata$x:00004719                 db    0
.xdata$x:0000471A                 db    0
.xdata$x:0000471B                 db    0
.xdata$x:0000471C                 db    0
.xdata$x:0000471D                 db    0
.xdata$x:0000471E                 db    0
.xdata$x:0000471F                 db    0
.xdata$x:00004720                 db    0
.xdata$x:00004721                 db    0
.xdata$x:00004722                 db    0
.xdata$x:00004723                 db    0
.xdata$x:00004724                 db    0
.xdata$x:00004725                 db    0
.xdata$x:00004726                 db    0
.xdata$x:00004727                 db    0
.xdata$x:00004728                 db    0
.xdata$x:00004729                 db    0
.xdata$x:0000472A                 db    0
.xdata$x:0000472B                 db    0
.xdata$x:0000472B _xdata$x        ends
.xdata$x:0000472B
.xdata$x:0000472C ; ===========================================================================
.xdata$x:0000472C
.xdata$x:0000472C ; Segment type: Pure data
.xdata$x:0000472C ; Segment permissions: Read
.xdata$x:0000472C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000472C                 assume cs:_xdata$x
.xdata$x:0000472C                 ;org 472Ch
.xdata$x:0000472C ; COMDAT (pick associative to section at 30D0)
.xdata$x:0000472C __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000472C                                         ; DATA XREF: .xdata$x:0000473Co
.xdata$x:0000472D                 db 0FFh
.xdata$x:0000472E                 db 0FFh
.xdata$x:0000472F                 db 0FFh
.xdata$x:00004730                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00004734 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00004734                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00004735                 db    5
.xdata$x:00004736                 db  93h ; ô
.xdata$x:00004737                 db  19h
.xdata$x:00004738                 db    1
.xdata$x:00004739                 db    0
.xdata$x:0000473A                 db    0
.xdata$x:0000473B                 db    0
.xdata$x:0000473C                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00004740                 db    0
.xdata$x:00004741                 db    0
.xdata$x:00004742                 db    0
.xdata$x:00004743                 db    0
.xdata$x:00004744                 db    0
.xdata$x:00004745                 db    0
.xdata$x:00004746                 db    0
.xdata$x:00004747                 db    0
.xdata$x:00004748                 db    0
.xdata$x:00004749                 db    0
.xdata$x:0000474A                 db    0
.xdata$x:0000474B                 db    0
.xdata$x:0000474C                 db    0
.xdata$x:0000474D                 db    0
.xdata$x:0000474E                 db    0
.xdata$x:0000474F                 db    0
.xdata$x:00004750                 db    0
.xdata$x:00004751                 db    0
.xdata$x:00004752                 db    0
.xdata$x:00004753                 db    0
.xdata$x:00004754                 db    0
.xdata$x:00004755                 db    0
.xdata$x:00004756                 db    0
.xdata$x:00004757                 db    0
.xdata$x:00004757 _xdata$x        ends
.xdata$x:00004757
.xdata$x:00004758 ; ===========================================================================
.xdata$x:00004758
.xdata$x:00004758 ; Segment type: Pure data
.xdata$x:00004758 ; Segment permissions: Read
.xdata$x:00004758 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004758                 assume cs:_xdata$x
.xdata$x:00004758                 ;org 4758h
.xdata$x:00004758 ; COMDAT (pick associative to section at 2D10)
.xdata$x:00004758 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00004758                                         ; DATA XREF: .xdata$x:00004768o
.xdata$x:00004759                 db 0FFh
.xdata$x:0000475A                 db 0FFh
.xdata$x:0000475B                 db 0FFh
.xdata$x:0000475C                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00004760 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00004760                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00004761                 db    5
.xdata$x:00004762                 db  93h ; ô
.xdata$x:00004763                 db  19h
.xdata$x:00004764                 db    1
.xdata$x:00004765                 db    0
.xdata$x:00004766                 db    0
.xdata$x:00004767                 db    0
.xdata$x:00004768                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:0000476C                 db    0
.xdata$x:0000476D                 db    0
.xdata$x:0000476E                 db    0
.xdata$x:0000476F                 db    0
.xdata$x:00004770                 db    0
.xdata$x:00004771                 db    0
.xdata$x:00004772                 db    0
.xdata$x:00004773                 db    0
.xdata$x:00004774                 db    0
.xdata$x:00004775                 db    0
.xdata$x:00004776                 db    0
.xdata$x:00004777                 db    0
.xdata$x:00004778                 db    0
.xdata$x:00004779                 db    0
.xdata$x:0000477A                 db    0
.xdata$x:0000477B                 db    0
.xdata$x:0000477C                 db    0
.xdata$x:0000477D                 db    0
.xdata$x:0000477E                 db    0
.xdata$x:0000477F                 db    0
.xdata$x:00004780                 db    0
.xdata$x:00004781                 db    0
.xdata$x:00004782                 db    0
.xdata$x:00004783                 db    0
.xdata$x:00004783 _xdata$x        ends
.xdata$x:00004783
.xdata$x:00004784 ; ===========================================================================
.xdata$x:00004784
.xdata$x:00004784 ; Segment type: Pure data
.xdata$x:00004784 ; Segment permissions: Read
.xdata$x:00004784 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004784                 assume cs:_xdata$x
.xdata$x:00004784                 ;org 4784h
.xdata$x:00004784 ; COMDAT (pick associative to section at 4204)
.xdata$x:00004784 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00004784                                         ; DATA XREF: .xdata$x:00004794o
.xdata$x:00004785                 db 0FFh
.xdata$x:00004786                 db 0FFh
.xdata$x:00004787                 db 0FFh
.xdata$x:00004788                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000478C __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000478C                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000478D                 db    5
.xdata$x:0000478E                 db  93h ; ô
.xdata$x:0000478F                 db  19h
.xdata$x:00004790                 db    1
.xdata$x:00004791                 db    0
.xdata$x:00004792                 db    0
.xdata$x:00004793                 db    0
.xdata$x:00004794                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00004798                 db    0
.xdata$x:00004799                 db    0
.xdata$x:0000479A                 db    0
.xdata$x:0000479B                 db    0
.xdata$x:0000479C                 db    0
.xdata$x:0000479D                 db    0
.xdata$x:0000479E                 db    0
.xdata$x:0000479F                 db    0
.xdata$x:000047A0                 db    0
.xdata$x:000047A1                 db    0
.xdata$x:000047A2                 db    0
.xdata$x:000047A3                 db    0
.xdata$x:000047A4                 db    0
.xdata$x:000047A5                 db    0
.xdata$x:000047A6                 db    0
.xdata$x:000047A7                 db    0
.xdata$x:000047A8                 db    0
.xdata$x:000047A9                 db    0
.xdata$x:000047AA                 db    0
.xdata$x:000047AB                 db    0
.xdata$x:000047AC                 db    0
.xdata$x:000047AD                 db    0
.xdata$x:000047AE                 db    0
.xdata$x:000047AF                 db    0
.xdata$x:000047AF _xdata$x        ends
.xdata$x:000047AF
.xdata$x:000047B0 ; ===========================================================================
.xdata$x:000047B0
.xdata$x:000047B0 ; Segment type: Pure data
.xdata$x:000047B0 ; Segment permissions: Read
.xdata$x:000047B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000047B0                 assume cs:_xdata$x
.xdata$x:000047B0                 ;org 47B0h
.xdata$x:000047B0 ; COMDAT (pick associative to section at 3140)
.xdata$x:000047B0 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000047B0                                         ; DATA XREF: .xdata$x:000047C0o
.xdata$x:000047B1                 db 0FFh
.xdata$x:000047B2                 db 0FFh
.xdata$x:000047B3                 db 0FFh
.xdata$x:000047B4                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:000047B8 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000047B8                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:000047B9                 db    5
.xdata$x:000047BA                 db  93h ; ô
.xdata$x:000047BB                 db  19h
.xdata$x:000047BC                 db    1
.xdata$x:000047BD                 db    0
.xdata$x:000047BE                 db    0
.xdata$x:000047BF                 db    0
.xdata$x:000047C0                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:000047C4                 db    0
.xdata$x:000047C5                 db    0
.xdata$x:000047C6                 db    0
.xdata$x:000047C7                 db    0
.xdata$x:000047C8                 db    0
.xdata$x:000047C9                 db    0
.xdata$x:000047CA                 db    0
.xdata$x:000047CB                 db    0
.xdata$x:000047CC                 db    0
.xdata$x:000047CD                 db    0
.xdata$x:000047CE                 db    0
.xdata$x:000047CF                 db    0
.xdata$x:000047D0                 db    0
.xdata$x:000047D1                 db    0
.xdata$x:000047D2                 db    0
.xdata$x:000047D3                 db    0
.xdata$x:000047D4                 db    0
.xdata$x:000047D5                 db    0
.xdata$x:000047D6                 db    0
.xdata$x:000047D7                 db    0
.xdata$x:000047D8                 db    0
.xdata$x:000047D9                 db    0
.xdata$x:000047DA                 db    0
.xdata$x:000047DB                 db    0
.xdata$x:000047DB _xdata$x        ends
.xdata$x:000047DB
.xdata$x:000047DC ; ===========================================================================
.xdata$x:000047DC
.xdata$x:000047DC ; Segment type: Pure data
.xdata$x:000047DC ; Segment permissions: Read
.xdata$x:000047DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000047DC                 assume cs:_xdata$x
.xdata$x:000047DC                 ;org 47DCh
.xdata$x:000047DC ; COMDAT (pick associative to section at 28EC)
.xdata$x:000047DC __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:000047DC                                         ; DATA XREF: .xdata$x:000047ECo
.xdata$x:000047DD                 db 0FFh
.xdata$x:000047DE                 db 0FFh
.xdata$x:000047DF                 db 0FFh
.xdata$x:000047E0                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:000047E4 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:000047E4                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:000047E5                 db    5
.xdata$x:000047E6                 db  93h ; ô
.xdata$x:000047E7                 db  19h
.xdata$x:000047E8                 db    1
.xdata$x:000047E9                 db    0
.xdata$x:000047EA                 db    0
.xdata$x:000047EB                 db    0
.xdata$x:000047EC                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:000047F0                 db    0
.xdata$x:000047F1                 db    0
.xdata$x:000047F2                 db    0
.xdata$x:000047F3                 db    0
.xdata$x:000047F4                 db    0
.xdata$x:000047F5                 db    0
.xdata$x:000047F6                 db    0
.xdata$x:000047F7                 db    0
.xdata$x:000047F8                 db    0
.xdata$x:000047F9                 db    0
.xdata$x:000047FA                 db    0
.xdata$x:000047FB                 db    0
.xdata$x:000047FC                 db    0
.xdata$x:000047FD                 db    0
.xdata$x:000047FE                 db    0
.xdata$x:000047FF                 db    0
.xdata$x:00004800                 db    0
.xdata$x:00004801                 db    0
.xdata$x:00004802                 db    0
.xdata$x:00004803                 db    0
.xdata$x:00004804                 db    0
.xdata$x:00004805                 db    0
.xdata$x:00004806                 db    0
.xdata$x:00004807                 db    0
.xdata$x:00004807 _xdata$x        ends
.xdata$x:00004807
.xdata$x:00004808 ; ===========================================================================
.xdata$x:00004808
.xdata$x:00004808 ; Segment type: Pure data
.xdata$x:00004808 ; Segment permissions: Read
.xdata$x:00004808 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004808                 assume cs:_xdata$x
.xdata$x:00004808                 ;org 4808h
.xdata$x:00004808 ; COMDAT (pick associative to section at 2818)
.xdata$x:00004808 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00004808                                         ; DATA XREF: .xdata$x:00004818o
.xdata$x:00004809                 db 0FFh
.xdata$x:0000480A                 db 0FFh
.xdata$x:0000480B                 db 0FFh
.xdata$x:0000480C                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00004810 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00004810                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00004811                 db    5
.xdata$x:00004812                 db  93h ; ô
.xdata$x:00004813                 db  19h
.xdata$x:00004814                 db    1
.xdata$x:00004815                 db    0
.xdata$x:00004816                 db    0
.xdata$x:00004817                 db    0
.xdata$x:00004818                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:0000481C                 db    0
.xdata$x:0000481D                 db    0
.xdata$x:0000481E                 db    0
.xdata$x:0000481F                 db    0
.xdata$x:00004820                 db    0
.xdata$x:00004821                 db    0
.xdata$x:00004822                 db    0
.xdata$x:00004823                 db    0
.xdata$x:00004824                 db    0
.xdata$x:00004825                 db    0
.xdata$x:00004826                 db    0
.xdata$x:00004827                 db    0
.xdata$x:00004828                 db    0
.xdata$x:00004829                 db    0
.xdata$x:0000482A                 db    0
.xdata$x:0000482B                 db    0
.xdata$x:0000482C                 db    0
.xdata$x:0000482D                 db    0
.xdata$x:0000482E                 db    0
.xdata$x:0000482F                 db    0
.xdata$x:00004830                 db    0
.xdata$x:00004831                 db    0
.xdata$x:00004832                 db    0
.xdata$x:00004833                 db    0
.xdata$x:00004833 _xdata$x        ends
.xdata$x:00004833
.rdata:00004834 ; ===========================================================================
.rdata:00004834
.rdata:00004834 ; Segment type: Pure data
.rdata:00004834 ; Segment permissions: Read
.rdata:00004834 _rdata          segment dword public 'DATA' use32
.rdata:00004834                 assume cs:_rdata
.rdata:00004834                 ;org 4834h
.rdata:00004834 ; COMDAT (pick largest)
.rdata:00004834                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:00004838                 public ??_7runtime_error@std@@6B@
.rdata:00004838 ; const std::runtime_error::`vftable'
.rdata:00004838 ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:00004838                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:00004838                                         ; std::runtime_error::runtime_error(char const *)+3Co
.rdata:00004838                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:0000483C                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:0000483C _rdata          ends
.rdata:0000483C
.xdata$x:00004840 ; ===========================================================================
.xdata$x:00004840
.xdata$x:00004840 ; Segment type: Pure data
.xdata$x:00004840 ; Segment permissions: Read
.xdata$x:00004840 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004840                 assume cs:_xdata$x
.xdata$x:00004840                 ;org 4840h
.xdata$x:00004840 ; COMDAT (pick any)
.xdata$x:00004840                 public __TI2?AVruntime_error@std@@
.xdata$x:00004840 __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+FDo
.xdata$x:00004840                                         ; TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+128o ...
.xdata$x:00004841                 db    0
.xdata$x:00004842                 db    0
.xdata$x:00004843                 db    0
.xdata$x:00004844                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:00004848                 db    0
.xdata$x:00004849                 db    0
.xdata$x:0000484A                 db    0
.xdata$x:0000484B                 db    0
.xdata$x:0000484C                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:0000484C _xdata$x        ends
.xdata$x:0000484C
.xdata$x:00004850 ; ===========================================================================
.xdata$x:00004850
.xdata$x:00004850 ; Segment type: Pure data
.xdata$x:00004850 ; Segment permissions: Read
.xdata$x:00004850 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004850                 assume cs:_xdata$x
.xdata$x:00004850                 ;org 4850h
.xdata$x:00004850 ; COMDAT (pick any)
.xdata$x:00004850                 public __CTA2?AVruntime_error@std@@
.xdata$x:00004850 __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:0000484Co
.xdata$x:00004851                 db    0
.xdata$x:00004852                 db    0
.xdata$x:00004853                 db    0
.xdata$x:00004854                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00004858                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00004858 _xdata$x        ends
.xdata$x:00004858
.data$r:0000485C ; ===========================================================================
.data$r:0000485C
.data$r:0000485C ; Segment type: Pure data
.data$r:0000485C ; Segment permissions: Read/Write
.data$r:0000485C _data$r         segment dword public 'DATA' use32
.data$r:0000485C                 assume cs:_data$r
.data$r:0000485C                 ;org 485Ch
.data$r:0000485C ; COMDAT (pick any)
.data$r:0000485C                 public ??_R0?AVruntime_error@std@@@8
.data$r:0000485C ; class std::runtime_error `RTTI Type Descriptor'
.data$r:0000485C ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000485C                                         ; DATA XREF: .xdata$x:00004880o
.data$r:0000485C                                         ; .rdata$r:00004AC4o ...
.data$r:0000485C                                         ; const type_info::`vftable'
.data$r:00004860                 db    0
.data$r:00004861                 db    0
.data$r:00004862                 db    0
.data$r:00004863                 db    0
.data$r:00004864                 db  2Eh ; .
.data$r:00004865                 db  3Fh ; ?
.data$r:00004866                 db  41h ; A
.data$r:00004867                 db  56h ; V
.data$r:00004868                 db  72h ; r
.data$r:00004869                 db  75h ; u
.data$r:0000486A                 db  6Eh ; n
.data$r:0000486B                 db  74h ; t
.data$r:0000486C                 db  69h ; i
.data$r:0000486D                 db  6Dh ; m
.data$r:0000486E                 db  65h ; e
.data$r:0000486F                 db  5Fh ; _
.data$r:00004870                 db  65h ; e
.data$r:00004871                 db  72h ; r
.data$r:00004872                 db  72h ; r
.data$r:00004873                 db  6Fh ; o
.data$r:00004874                 db  72h ; r
.data$r:00004875                 db  40h ; @
.data$r:00004876                 db  73h ; s
.data$r:00004877                 db  74h ; t
.data$r:00004878                 db  64h ; d
.data$r:00004879                 db  40h ; @
.data$r:0000487A                 db  40h ; @
.data$r:0000487B                 db    0
.data$r:0000487B _data$r         ends
.data$r:0000487B
.xdata$x:0000487C ; ===========================================================================
.xdata$x:0000487C
.xdata$x:0000487C ; Segment type: Pure data
.xdata$x:0000487C ; Segment permissions: Read
.xdata$x:0000487C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000487C                 assume cs:_xdata$x
.xdata$x:0000487C                 ;org 487Ch
.xdata$x:0000487C ; COMDAT (pick any)
.xdata$x:0000487C                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:0000487C __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:0000487C                                         ; DATA XREF: .xdata$x:00004854o
.xdata$x:0000487D                 db    0
.xdata$x:0000487E                 db    0
.xdata$x:0000487F                 db    0
.xdata$x:00004880                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:00004884                 align 8
.xdata$x:00004888                 db 0FFh
.xdata$x:00004889                 db 0FFh
.xdata$x:0000488A                 db 0FFh
.xdata$x:0000488B                 db 0FFh
.xdata$x:0000488C                 db    0
.xdata$x:0000488D                 db    0
.xdata$x:0000488E                 db    0
.xdata$x:0000488F                 db    0
.xdata$x:00004890                 db  0Ch
.xdata$x:00004891                 db    0
.xdata$x:00004892                 db    0
.xdata$x:00004893                 db    0
.xdata$x:00004894                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:00004894 _xdata$x        ends
.xdata$x:00004894
.data$r:00004898 ; ===========================================================================
.data$r:00004898
.data$r:00004898 ; Segment type: Pure data
.data$r:00004898 ; Segment permissions: Read/Write
.data$r:00004898 _data$r         segment dword public 'DATA' use32
.data$r:00004898                 assume cs:_data$r
.data$r:00004898                 ;org 4898h
.data$r:00004898 ; COMDAT (pick any)
.data$r:00004898                 public ??_R0?AVexception@std@@@8
.data$r:00004898 ; class std::exception `RTTI Type Descriptor'
.data$r:00004898 ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004898                                         ; DATA XREF: .xdata$x:000048B8o
.data$r:00004898                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004898                                         ; const type_info::`vftable'
.data$r:0000489C                 align 10h
.data$r:000048A0 a_?avexception@ db '.?AVexception@std@@',0
.data$r:000048A0 _data$r         ends
.data$r:000048A0
.xdata$x:000048B4 ; ===========================================================================
.xdata$x:000048B4
.xdata$x:000048B4 ; Segment type: Pure data
.xdata$x:000048B4 ; Segment permissions: Read
.xdata$x:000048B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000048B4                 assume cs:_xdata$x
.xdata$x:000048B4                 ;org 48B4h
.xdata$x:000048B4 ; COMDAT (pick any)
.xdata$x:000048B4                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:000048B4 __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:000048B4                                         ; DATA XREF: .xdata$x:00004858o
.xdata$x:000048B5                 db    0
.xdata$x:000048B6                 db    0
.xdata$x:000048B7                 db    0
.xdata$x:000048B8                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:000048BC                 align 10h
.xdata$x:000048C0                 db 0FFh
.xdata$x:000048C1                 db 0FFh
.xdata$x:000048C2                 db 0FFh
.xdata$x:000048C3                 db 0FFh
.xdata$x:000048C4                 db    0
.xdata$x:000048C5                 db    0
.xdata$x:000048C6                 db    0
.xdata$x:000048C7                 db    0
.xdata$x:000048C8                 db  0Ch
.xdata$x:000048C9                 db    0
.xdata$x:000048CA                 db    0
.xdata$x:000048CB                 db    0
.xdata$x:000048CC                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:000048CC _xdata$x        ends
.xdata$x:000048CC
.rdata:000048D0 ; ===========================================================================
.rdata:000048D0
.rdata:000048D0 ; Segment type: Pure data
.rdata:000048D0 ; Segment permissions: Read
.rdata:000048D0 _rdata          segment dword public 'DATA' use32
.rdata:000048D0                 assume cs:_rdata
.rdata:000048D0                 ;org 48D0h
.rdata:000048D0 ; COMDAT (pick largest)
.rdata:000048D0                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:000048D4                 public ??_7error_category@std@@6B@
.rdata:000048D4 ; const std::error_category::`vftable'
.rdata:000048D4 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:000048D4                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:000048D4                                         ; std::error_category::~error_category(void)+Ao
.rdata:000048D4                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:000048D8                 dd offset __purecall
.rdata:000048DC                 dd offset __purecall
.rdata:000048E0                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000048E4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000048E8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000048E8 _rdata          ends
.rdata:000048E8
.rdata:000048EC ; ===========================================================================
.rdata:000048EC
.rdata:000048EC ; Segment type: Pure data
.rdata:000048EC ; Segment permissions: Read
.rdata:000048EC _rdata          segment dword public 'DATA' use32
.rdata:000048EC                 assume cs:_rdata
.rdata:000048EC                 ;org 48ECh
.rdata:000048EC ; COMDAT (pick largest)
.rdata:000048EC                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:000048F0                 public ??_7_Generic_error_category@std@@6B@
.rdata:000048F0 ; const std::_Generic_error_category::`vftable'
.rdata:000048F0 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:000048F0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:000048F0                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:000048F4                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:000048F8                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:000048FC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00004900                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00004904                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00004904 _rdata          ends
.rdata:00004904
.rdata:00004908 ; ===========================================================================
.rdata:00004908
.rdata:00004908 ; Segment type: Pure data
.rdata:00004908 ; Segment permissions: Read
.rdata:00004908 _rdata          segment dword public 'DATA' use32
.rdata:00004908                 assume cs:_rdata
.rdata:00004908                 ;org 4908h
.rdata:00004908 ; COMDAT (pick any)
.rdata:00004908                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00004908 ; `string'
.rdata:00004908 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00004908                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00004908 _rdata          ends
.rdata:00004908
.rdata:00004910 ; ===========================================================================
.rdata:00004910
.rdata:00004910 ; Segment type: Pure data
.rdata:00004910 ; Segment permissions: Read
.rdata:00004910 _rdata          segment dword public 'DATA' use32
.rdata:00004910                 assume cs:_rdata
.rdata:00004910                 ;org 4910h
.rdata:00004910 ; COMDAT (pick any)
.rdata:00004910                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00004910 ; `string'
.rdata:00004910 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00004910                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_40D4o
.rdata:00004910                                         ; std::_System_error_category::message(int):loc_4250o
.rdata:0000491E                 align 10h
.rdata:0000491E _rdata          ends
.rdata:0000491E
.rdata:00004920 ; ===========================================================================
.rdata:00004920
.rdata:00004920 ; Segment type: Pure data
.rdata:00004920 ; Segment permissions: Read
.rdata:00004920 _rdata          segment dword public 'DATA' use32
.rdata:00004920                 assume cs:_rdata
.rdata:00004920                 ;org 4920h
.rdata:00004920 ; COMDAT (pick largest)
.rdata:00004920                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00004924                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00004924 ; const std::_Iostream_error_category::`vftable'
.rdata:00004924 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00004924                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00004924                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00004928                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:0000492C                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00004930                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00004934                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00004938                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00004938 _rdata          ends
.rdata:00004938
.rdata:0000493C ; ===========================================================================
.rdata:0000493C
.rdata:0000493C ; Segment type: Pure data
.rdata:0000493C ; Segment permissions: Read
.rdata:0000493C _rdata          segment dword public 'DATA' use32
.rdata:0000493C                 assume cs:_rdata
.rdata:0000493C                 ;org 493Ch
.rdata:0000493C ; COMDAT (pick any)
.rdata:0000493C                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:0000493C ; `string'
.rdata:0000493C ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:0000493C                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00004945                 align 4
.rdata:00004945 _rdata          ends
.rdata:00004945
.rdata:00004948 ; ===========================================================================
.rdata:00004948
.rdata:00004948 ; Segment type: Pure data
.rdata:00004948 ; Segment permissions: Read
.rdata:00004948 _rdata          segment dword public 'DATA' use32
.rdata:00004948                 assume cs:_rdata
.rdata:00004948                 ;org 4948h
.rdata:00004948 ; COMDAT (pick any)
.rdata:00004948                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00004948 ; char `string'[]
.rdata:00004948 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00004948                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000495E                 align 10h
.rdata:0000495E _rdata          ends
.rdata:0000495E
.rdata:00004960 ; ===========================================================================
.rdata:00004960
.rdata:00004960 ; Segment type: Pure data
.rdata:00004960 ; Segment permissions: Read
.rdata:00004960 _rdata          segment dword public 'DATA' use32
.rdata:00004960                 assume cs:_rdata
.rdata:00004960                 ;org 4960h
.rdata:00004960 ; COMDAT (pick largest)
.rdata:00004960                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00004964                 public ??_7_System_error_category@std@@6B@
.rdata:00004964 ; const std::_System_error_category::`vftable'
.rdata:00004964 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00004964                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00004964                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00004968                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:0000496C                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00004970                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00004974                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00004978                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00004978 _rdata          ends
.rdata:00004978
.rdata:0000497C ; ===========================================================================
.rdata:0000497C
.rdata:0000497C ; Segment type: Pure data
.rdata:0000497C ; Segment permissions: Read
.rdata:0000497C _rdata          segment dword public 'DATA' use32
.rdata:0000497C                 assume cs:_rdata
.rdata:0000497C                 ;org 497Ch
.rdata:0000497C ; COMDAT (pick any)
.rdata:0000497C                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:0000497C ; `string'
.rdata:0000497C ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:0000497C                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00004983                 align 4
.rdata:00004983 _rdata          ends
.rdata:00004983
.bss:00004984 ; ===========================================================================
.bss:00004984
.bss:00004984 ; Segment type: Uninitialized
.bss:00004984 ; Segment permissions: Read/Write
.bss:00004984 _bss            segment dword public 'BSS' use32
.bss:00004984                 assume cs:_bss
.bss:00004984                 ;org 4984h
.bss:00004984 ; COMDAT (pick any)
.bss:00004984                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00004984                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00004984 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00004984 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00004984                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00004984                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00004985                 db    ? ;
.bss:00004986                 db    ? ;
.bss:00004987                 db    ? ;
.bss:00004987 _bss            ends
.bss:00004987
.bss:00004988 ; ===========================================================================
.bss:00004988
.bss:00004988 ; Segment type: Uninitialized
.bss:00004988 ; Segment permissions: Read/Write
.bss:00004988 _bss            segment dword public 'BSS' use32
.bss:00004988                 assume cs:_bss
.bss:00004988                 ;org 4988h
.bss:00004988 ; COMDAT (pick any)
.bss:00004988                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00004988                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00004988 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00004988 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00004988                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00004988                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00004989                 db    ? ;
.bss:0000498A                 db    ? ;
.bss:0000498B                 db    ? ;
.bss:0000498B _bss            ends
.bss:0000498B
.bss:0000498C ; ===========================================================================
.bss:0000498C
.bss:0000498C ; Segment type: Uninitialized
.bss:0000498C ; Segment permissions: Read/Write
.bss:0000498C _bss            segment dword public 'BSS' use32
.bss:0000498C                 assume cs:_bss
.bss:0000498C                 ;org 498Ch
.bss:0000498C ; COMDAT (pick any)
.bss:0000498C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000498C                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:0000498C ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:0000498C ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:0000498C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:0000498C                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:0000498D                 db    ? ;
.bss:0000498E                 db    ? ;
.bss:0000498F                 db    ? ;
.bss:0000498F _bss            ends
.bss:0000498F
.bss:00004990 ; ===========================================================================
.bss:00004990
.bss:00004990 ; Segment type: Uninitialized
.bss:00004990 ; Segment permissions: Read/Write
.bss:00004990 _bss            segment dword public 'BSS' use32
.bss:00004990                 assume cs:_bss
.bss:00004990                 ;org 4990h
.bss:00004990 ; COMDAT (pick any)
.bss:00004990                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00004990                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00004990 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00004990 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00004990                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00004991                 db    ? ;
.bss:00004992                 db    ? ;
.bss:00004993                 db    ? ;
.bss:00004993 _bss            ends
.bss:00004993
.bss:00004994 ; ===========================================================================
.bss:00004994
.bss:00004994 ; Segment type: Uninitialized
.bss:00004994 ; Segment permissions: Read/Write
.bss:00004994 _bss            segment dword public 'BSS' use32
.bss:00004994                 assume cs:_bss
.bss:00004994                 ;org 4994h
.bss:00004994 ; COMDAT (pick any)
.bss:00004994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00004994                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00004994 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00004994 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00004994                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00004995                 db    ? ;
.bss:00004996                 db    ? ;
.bss:00004997                 db    ? ;
.bss:00004997 _bss            ends
.bss:00004997
.rdata:00004998 ; ===========================================================================
.rdata:00004998
.rdata:00004998 ; Segment type: Pure data
.rdata:00004998 ; Segment permissions: Read
.rdata:00004998 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00004998 _rdata          segment para public 'DATA' use32
.rdata:00004998                 assume cs:_rdata
.rdata:00004998                 ;org 4998h
.rdata:00004998 ; COMDAT (pick any)
.rdata:00004998                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00004998 ; wchar_t `string'
.rdata:00004998 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00004998                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00004998                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00004998                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00004998                 unicode 0, <clude\xstring>,0
.rdata:00004A26                 align 4
.rdata:00004A26 _rdata          ends
.rdata:00004A26
.bss:00004A28 ; ===========================================================================
.bss:00004A28
.bss:00004A28 ; Segment type: Uninitialized
.bss:00004A28 ; Segment permissions: Read/Write
.bss:00004A28 _bss            segment dword public 'BSS' use32
.bss:00004A28                 assume cs:_bss
.bss:00004A28                 ;org 4A28h
.bss:00004A28 ; COMDAT (pick any)
.bss:00004A28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00004A28                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00004A28 ; std::locale::id std::numpunct<char>::id
.bss:00004A28 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00004A28                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00004A29                 db    ? ;
.bss:00004A2A                 db    ? ;
.bss:00004A2B                 db    ? ;
.bss:00004A2B _bss            ends
.bss:00004A2B
.bss:00004A2C ; ===========================================================================
.bss:00004A2C
.bss:00004A2C ; Segment type: Uninitialized
.bss:00004A2C ; Segment permissions: Read/Write
.bss:00004A2C _bss            segment dword public 'BSS' use32
.bss:00004A2C                 assume cs:_bss
.bss:00004A2C                 ;org 4A2Ch
.bss:00004A2C ; COMDAT (pick any)
.bss:00004A2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00004A2C                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00004A2C ; std::locale::id std::numpunct<wchar_t>::id
.bss:00004A2C ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00004A2C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00004A2D                 db    ? ;
.bss:00004A2E                 db    ? ;
.bss:00004A2F                 db    ? ;
.bss:00004A2F _bss            ends
.bss:00004A2F
.rdata:00004A30 ; ===========================================================================
.rdata:00004A30
.rdata:00004A30 ; Segment type: Pure data
.rdata:00004A30 ; Segment permissions: Read
.rdata:00004A30 _rdata          segment dword public 'DATA' use32
.rdata:00004A30                 assume cs:_rdata
.rdata:00004A30                 ;org 4A30h
.rdata:00004A30 ; COMDAT (pick any)
.rdata:00004A30                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00004A30 ; char `string'[]
.rdata:00004A30 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00004A30                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00004A30 _rdata          ends
.rdata:00004A30
.rdata:00004A40 ; ===========================================================================
.rdata:00004A40
.rdata:00004A40 ; Segment type: Pure data
.rdata:00004A40 ; Segment permissions: Read
.rdata:00004A40 _rdata          segment dword public 'DATA' use32
.rdata:00004A40                 assume cs:_rdata
.rdata:00004A40                 ;org 4A40h
.rdata:00004A40 ; COMDAT (pick any)
.rdata:00004A40                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00004A40 ; char `string'[]
.rdata:00004A40 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00004A40                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00004A40 _rdata          ends
.rdata:00004A40
.rdata:00004A58 ; ===========================================================================
.rdata:00004A58
.rdata:00004A58 ; Segment type: Pure data
.rdata:00004A58 ; Segment permissions: Read
.rdata:00004A58 _rdata          segment dword public 'DATA' use32
.rdata:00004A58                 assume cs:_rdata
.rdata:00004A58                 ;org 4A58h
.rdata:00004A58 ; COMDAT (pick any)
.rdata:00004A58                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00004A58 ; wchar_t `string'
.rdata:00004A58 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00004A58                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00004A58                 unicode 0, <invalid null pointer>,0
.rdata:00004A82                 align 4
.rdata:00004A82 _rdata          ends
.rdata:00004A82
.rdata$r:00004A84 ; ===========================================================================
.rdata$r:00004A84
.rdata$r:00004A84 ; Segment type: Pure data
.rdata$r:00004A84 ; Segment permissions: Read
.rdata$r:00004A84 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004A84                 assume cs:_rdata$r
.rdata$r:00004A84                 ;org 4A84h
.rdata$r:00004A84 ; COMDAT (pick any)
.rdata$r:00004A84                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00004A84 ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004A84 ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:00004A84                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:00004A84                                         ; .rdata$r:00004AE0o
.rdata$r:00004A84                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:00004A88                 align 10h
.rdata$r:00004A90                 db 0FFh
.rdata$r:00004A91                 db 0FFh
.rdata$r:00004A92                 db 0FFh
.rdata$r:00004A93                 db 0FFh
.rdata$r:00004A94                 db    0
.rdata$r:00004A95                 db    0
.rdata$r:00004A96                 db    0
.rdata$r:00004A97                 db    0
.rdata$r:00004A98                 db  40h ; @
.rdata$r:00004A99                 db    0
.rdata$r:00004A9A                 db    0
.rdata$r:00004A9B                 db    0
.rdata$r:00004A9C                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004A9C _rdata$r        ends
.rdata$r:00004A9C
.rdata$r:00004AA0 ; ===========================================================================
.rdata$r:00004AA0
.rdata$r:00004AA0 ; Segment type: Pure data
.rdata$r:00004AA0 ; Segment permissions: Read
.rdata$r:00004AA0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004AA0                 assume cs:_rdata$r
.rdata$r:00004AA0                 ;org 4AA0h
.rdata$r:00004AA0 ; COMDAT (pick any)
.rdata$r:00004AA0                 public ??_R3exception@std@@8
.rdata$r:00004AA0 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004AA0 ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:00004A9Co
.rdata$r:00004AA1                 db    0
.rdata$r:00004AA2                 db    0
.rdata$r:00004AA3                 db    0
.rdata$r:00004AA4                 db    0
.rdata$r:00004AA5                 db    0
.rdata$r:00004AA6                 db    0
.rdata$r:00004AA7                 db    0
.rdata$r:00004AA8                 db    1
.rdata$r:00004AA9                 db    0
.rdata$r:00004AAA                 db    0
.rdata$r:00004AAB                 db    0
.rdata$r:00004AAC                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:00004AAC _rdata$r        ends
.rdata$r:00004AAC
.rdata$r:00004AB0 ; ===========================================================================
.rdata$r:00004AB0
.rdata$r:00004AB0 ; Segment type: Pure data
.rdata$r:00004AB0 ; Segment permissions: Read
.rdata$r:00004AB0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004AB0                 assume cs:_rdata$r
.rdata$r:00004AB0                 ;org 4AB0h
.rdata$r:00004AB0 ; COMDAT (pick any)
.rdata$r:00004AB0                 public ??_R2exception@std@@8
.rdata$r:00004AB0 ; std::exception::`RTTI Base Class Array'
.rdata$r:00004AB0 ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00004AB0                                         ; DATA XREF: .rdata$r:00004AACo
.rdata$r:00004AB0                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004AB4                 db    0
.rdata$r:00004AB5                 align 4
.rdata$r:00004AB5 _rdata$r        ends
.rdata$r:00004AB5
.rdata$r:00004AB8 ; ===========================================================================
.rdata$r:00004AB8
.rdata$r:00004AB8 ; Segment type: Pure data
.rdata$r:00004AB8 ; Segment permissions: Read
.rdata$r:00004AB8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004AB8                 assume cs:_rdata$r
.rdata$r:00004AB8                 ;org 4AB8h
.rdata$r:00004AB8 ; COMDAT (pick any)
.rdata$r:00004AB8                 public ??_R4runtime_error@std@@6B@
.rdata$r:00004AB8 ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:00004AB8 ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:00004834o
.rdata$r:00004AB9                 db    0
.rdata$r:00004ABA                 db    0
.rdata$r:00004ABB                 db    0
.rdata$r:00004ABC                 db    0
.rdata$r:00004ABD                 db    0
.rdata$r:00004ABE                 db    0
.rdata$r:00004ABF                 db    0
.rdata$r:00004AC0                 db    0
.rdata$r:00004AC1                 db    0
.rdata$r:00004AC2                 db    0
.rdata$r:00004AC3                 db    0
.rdata$r:00004AC4                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00004AC8                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004AC8 _rdata$r        ends
.rdata$r:00004AC8
.rdata$r:00004ACC ; ===========================================================================
.rdata$r:00004ACC
.rdata$r:00004ACC ; Segment type: Pure data
.rdata$r:00004ACC ; Segment permissions: Read
.rdata$r:00004ACC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004ACC                 assume cs:_rdata$r
.rdata$r:00004ACC                 ;org 4ACCh
.rdata$r:00004ACC ; COMDAT (pick any)
.rdata$r:00004ACC                 public ??_R3runtime_error@std@@8
.rdata$r:00004ACC ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004ACC ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:00004AC8o
.rdata$r:00004ACC                                         ; .rdata$r:00004B00o
.rdata$r:00004ACD                 db    0
.rdata$r:00004ACE                 db    0
.rdata$r:00004ACF                 db    0
.rdata$r:00004AD0                 db    0
.rdata$r:00004AD1                 db    0
.rdata$r:00004AD2                 db    0
.rdata$r:00004AD3                 db    0
.rdata$r:00004AD4                 db    2
.rdata$r:00004AD5                 db    0
.rdata$r:00004AD6                 db    0
.rdata$r:00004AD7                 db    0
.rdata$r:00004AD8                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00004AD8 _rdata$r        ends
.rdata$r:00004AD8
.rdata$r:00004ADC ; ===========================================================================
.rdata$r:00004ADC
.rdata$r:00004ADC ; Segment type: Pure data
.rdata$r:00004ADC ; Segment permissions: Read
.rdata$r:00004ADC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004ADC                 assume cs:_rdata$r
.rdata$r:00004ADC                 ;org 4ADCh
.rdata$r:00004ADC ; COMDAT (pick any)
.rdata$r:00004ADC                 public ??_R2runtime_error@std@@8
.rdata$r:00004ADC ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00004ADC ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00004ADC                                         ; DATA XREF: .rdata$r:00004AD8o
.rdata$r:00004ADC                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004AE0                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004AE4                 db    0
.rdata$r:00004AE5                 align 4
.rdata$r:00004AE5 _rdata$r        ends
.rdata$r:00004AE5
.rdata$r:00004AE8 ; ===========================================================================
.rdata$r:00004AE8
.rdata$r:00004AE8 ; Segment type: Pure data
.rdata$r:00004AE8 ; Segment permissions: Read
.rdata$r:00004AE8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004AE8                 assume cs:_rdata$r
.rdata$r:00004AE8                 ;org 4AE8h
.rdata$r:00004AE8 ; COMDAT (pick any)
.rdata$r:00004AE8                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00004AE8 ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004AE8 ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:00004AE8                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:00004AE8                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00004AEC                 db    1
.rdata$r:00004AED                 db    0
.rdata$r:00004AEE                 db    0
.rdata$r:00004AEF                 db    0
.rdata$r:00004AF0                 db    0
.rdata$r:00004AF1                 db    0
.rdata$r:00004AF2                 db    0
.rdata$r:00004AF3                 db    0
.rdata$r:00004AF4                 db 0FFh
.rdata$r:00004AF5                 db 0FFh
.rdata$r:00004AF6                 db 0FFh
.rdata$r:00004AF7                 db 0FFh
.rdata$r:00004AF8                 db    0
.rdata$r:00004AF9                 db    0
.rdata$r:00004AFA                 db    0
.rdata$r:00004AFB                 db    0
.rdata$r:00004AFC                 db  40h ; @
.rdata$r:00004AFD                 db    0
.rdata$r:00004AFE                 db    0
.rdata$r:00004AFF                 db    0
.rdata$r:00004B00                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004B00 _rdata$r        ends
.rdata$r:00004B00
.rdata$r:00004B04 ; ===========================================================================
.rdata$r:00004B04
.rdata$r:00004B04 ; Segment type: Pure data
.rdata$r:00004B04 ; Segment permissions: Read
.rdata$r:00004B04 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004B04                 assume cs:_rdata$r
.rdata$r:00004B04                 ;org 4B04h
.rdata$r:00004B04 ; COMDAT (pick any)
.rdata$r:00004B04                 public ??_R4error_category@std@@6B@
.rdata$r:00004B04 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00004B04 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:000048D0o
.rdata$r:00004B05                 db    0
.rdata$r:00004B06                 db    0
.rdata$r:00004B07                 db    0
.rdata$r:00004B08                 db    0
.rdata$r:00004B09                 db    0
.rdata$r:00004B0A                 db    0
.rdata$r:00004B0B                 db    0
.rdata$r:00004B0C                 db    0
.rdata$r:00004B0D                 db    0
.rdata$r:00004B0E                 db    0
.rdata$r:00004B0F                 db    0
.rdata$r:00004B10                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00004B14                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004B14 _rdata$r        ends
.rdata$r:00004B14
.data$r:00004B18 ; ===========================================================================
.data$r:00004B18
.data$r:00004B18 ; Segment type: Pure data
.data$r:00004B18 ; Segment permissions: Read/Write
.data$r:00004B18 _data$r         segment dword public 'DATA' use32
.data$r:00004B18                 assume cs:_data$r
.data$r:00004B18                 ;org 4B18h
.data$r:00004B18 ; COMDAT (pick any)
.data$r:00004B18                 public ??_R0?AVerror_category@std@@@8
.data$r:00004B18 ; class std::error_category `RTTI Type Descriptor'
.data$r:00004B18 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004B18                                         ; DATA XREF: .rdata$r:00004B10o
.data$r:00004B18                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004B18                                         ; const type_info::`vftable'
.data$r:00004B1C                 align 10h
.data$r:00004B20 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:00004B39                 align 4
.data$r:00004B39 _data$r         ends
.data$r:00004B39
.rdata$r:00004B3C ; ===========================================================================
.rdata$r:00004B3C
.rdata$r:00004B3C ; Segment type: Pure data
.rdata$r:00004B3C ; Segment permissions: Read
.rdata$r:00004B3C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004B3C                 assume cs:_rdata$r
.rdata$r:00004B3C                 ;org 4B3Ch
.rdata$r:00004B3C ; COMDAT (pick any)
.rdata$r:00004B3C                 public ??_R3error_category@std@@8
.rdata$r:00004B3C ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004B3C ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00004B14o
.rdata$r:00004B3C                                         ; .rdata$r:00004B6Co
.rdata$r:00004B3D                 db    0
.rdata$r:00004B3E                 db    0
.rdata$r:00004B3F                 db    0
.rdata$r:00004B40                 db    0
.rdata$r:00004B41                 db    0
.rdata$r:00004B42                 db    0
.rdata$r:00004B43                 db    0
.rdata$r:00004B44                 db    1
.rdata$r:00004B45                 db    0
.rdata$r:00004B46                 db    0
.rdata$r:00004B47                 db    0
.rdata$r:00004B48                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00004B48 _rdata$r        ends
.rdata$r:00004B48
.rdata$r:00004B4C ; ===========================================================================
.rdata$r:00004B4C
.rdata$r:00004B4C ; Segment type: Pure data
.rdata$r:00004B4C ; Segment permissions: Read
.rdata$r:00004B4C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004B4C                 assume cs:_rdata$r
.rdata$r:00004B4C                 ;org 4B4Ch
.rdata$r:00004B4C ; COMDAT (pick any)
.rdata$r:00004B4C                 public ??_R2error_category@std@@8
.rdata$r:00004B4C ; std::error_category::`RTTI Base Class Array'
.rdata$r:00004B4C ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00004B4C                                         ; DATA XREF: .rdata$r:00004B48o
.rdata$r:00004B4C                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004B50                 db    0
.rdata$r:00004B51                 align 4
.rdata$r:00004B51 _rdata$r        ends
.rdata$r:00004B51
.rdata$r:00004B54 ; ===========================================================================
.rdata$r:00004B54
.rdata$r:00004B54 ; Segment type: Pure data
.rdata$r:00004B54 ; Segment permissions: Read
.rdata$r:00004B54 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004B54                 assume cs:_rdata$r
.rdata$r:00004B54                 ;org 4B54h
.rdata$r:00004B54 ; COMDAT (pick any)
.rdata$r:00004B54                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00004B54 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004B54 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00004B54                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00004B54                                         ; .rdata$r:00004BC4o ...
.rdata$r:00004B54                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00004B58                 align 10h
.rdata$r:00004B60                 db 0FFh
.rdata$r:00004B61                 db 0FFh
.rdata$r:00004B62                 db 0FFh
.rdata$r:00004B63                 db 0FFh
.rdata$r:00004B64                 db    0
.rdata$r:00004B65                 db    0
.rdata$r:00004B66                 db    0
.rdata$r:00004B67                 db    0
.rdata$r:00004B68                 db  40h ; @
.rdata$r:00004B69                 db    0
.rdata$r:00004B6A                 db    0
.rdata$r:00004B6B                 db    0
.rdata$r:00004B6C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004B6C _rdata$r        ends
.rdata$r:00004B6C
.rdata$r:00004B70 ; ===========================================================================
.rdata$r:00004B70
.rdata$r:00004B70 ; Segment type: Pure data
.rdata$r:00004B70 ; Segment permissions: Read
.rdata$r:00004B70 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004B70                 assume cs:_rdata$r
.rdata$r:00004B70                 ;org 4B70h
.rdata$r:00004B70 ; COMDAT (pick any)
.rdata$r:00004B70                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00004B70 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00004B70 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00004B70                                         ; DATA XREF: .rdata:000048ECo
.rdata$r:00004B71                 db    0
.rdata$r:00004B72                 db    0
.rdata$r:00004B73                 db    0
.rdata$r:00004B74                 db    0
.rdata$r:00004B75                 db    0
.rdata$r:00004B76                 db    0
.rdata$r:00004B77                 db    0
.rdata$r:00004B78                 db    0
.rdata$r:00004B79                 db    0
.rdata$r:00004B7A                 db    0
.rdata$r:00004B7B                 db    0
.rdata$r:00004B7C                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00004B80                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004B80 _rdata$r        ends
.rdata$r:00004B80
.data$r:00004B84 ; ===========================================================================
.data$r:00004B84
.data$r:00004B84 ; Segment type: Pure data
.data$r:00004B84 ; Segment permissions: Read/Write
.data$r:00004B84 _data$r         segment dword public 'DATA' use32
.data$r:00004B84                 assume cs:_data$r
.data$r:00004B84                 ;org 4B84h
.data$r:00004B84 ; COMDAT (pick any)
.data$r:00004B84                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00004B84 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00004B84 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004B84                                         ; DATA XREF: .rdata$r:00004B7Co
.data$r:00004B84                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004B84                                         ; const type_info::`vftable'
.data$r:00004B88                 db    0
.data$r:00004B89                 db    0
.data$r:00004B8A                 db    0
.data$r:00004B8B                 db    0
.data$r:00004B8C                 db  2Eh ; .
.data$r:00004B8D                 db  3Fh ; ?
.data$r:00004B8E                 db  41h ; A
.data$r:00004B8F                 db  56h ; V
.data$r:00004B90                 db  5Fh ; _
.data$r:00004B91                 db  47h ; G
.data$r:00004B92                 db  65h ; e
.data$r:00004B93                 db  6Eh ; n
.data$r:00004B94                 db  65h ; e
.data$r:00004B95                 db  72h ; r
.data$r:00004B96                 db  69h ; i
.data$r:00004B97                 db  63h ; c
.data$r:00004B98                 db  5Fh ; _
.data$r:00004B99                 db  65h ; e
.data$r:00004B9A                 db  72h ; r
.data$r:00004B9B                 db  72h ; r
.data$r:00004B9C                 db  6Fh ; o
.data$r:00004B9D                 db  72h ; r
.data$r:00004B9E                 db  5Fh ; _
.data$r:00004B9F                 db  63h ; c
.data$r:00004BA0                 db  61h ; a
.data$r:00004BA1                 db  74h ; t
.data$r:00004BA2                 db  65h ; e
.data$r:00004BA3                 db  67h ; g
.data$r:00004BA4                 db  6Fh ; o
.data$r:00004BA5                 db  72h ; r
.data$r:00004BA6                 db  79h ; y
.data$r:00004BA7                 db  40h ; @
.data$r:00004BA8                 db  73h ; s
.data$r:00004BA9                 db  74h ; t
.data$r:00004BAA                 db  64h ; d
.data$r:00004BAB                 db  40h ; @
.data$r:00004BAC                 db  40h ; @
.data$r:00004BAD                 db    0
.data$r:00004BAE                 align 10h
.data$r:00004BAE _data$r         ends
.data$r:00004BAE
.rdata$r:00004BB0 ; ===========================================================================
.rdata$r:00004BB0
.rdata$r:00004BB0 ; Segment type: Pure data
.rdata$r:00004BB0 ; Segment permissions: Read
.rdata$r:00004BB0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004BB0                 assume cs:_rdata$r
.rdata$r:00004BB0                 ;org 4BB0h
.rdata$r:00004BB0 ; COMDAT (pick any)
.rdata$r:00004BB0                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00004BB0 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004BB0 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00004BB0                                         ; DATA XREF: .rdata$r:00004B80o
.rdata$r:00004BB0                                         ; .rdata$r:00004BE4o
.rdata$r:00004BB1                 db    0
.rdata$r:00004BB2                 db    0
.rdata$r:00004BB3                 db    0
.rdata$r:00004BB4                 db    0
.rdata$r:00004BB5                 db    0
.rdata$r:00004BB6                 db    0
.rdata$r:00004BB7                 db    0
.rdata$r:00004BB8                 db    2
.rdata$r:00004BB9                 db    0
.rdata$r:00004BBA                 db    0
.rdata$r:00004BBB                 db    0
.rdata$r:00004BBC                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00004BBC _rdata$r        ends
.rdata$r:00004BBC
.rdata$r:00004BC0 ; ===========================================================================
.rdata$r:00004BC0
.rdata$r:00004BC0 ; Segment type: Pure data
.rdata$r:00004BC0 ; Segment permissions: Read
.rdata$r:00004BC0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004BC0                 assume cs:_rdata$r
.rdata$r:00004BC0                 ;org 4BC0h
.rdata$r:00004BC0 ; COMDAT (pick any)
.rdata$r:00004BC0                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00004BC0 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00004BC0 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00004BC0                                         ; DATA XREF: .rdata$r:00004BBCo
.rdata$r:00004BC0                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004BC4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004BC8                 db    0
.rdata$r:00004BC9                 align 4
.rdata$r:00004BC9 _rdata$r        ends
.rdata$r:00004BC9
.rdata$r:00004BCC ; ===========================================================================
.rdata$r:00004BCC
.rdata$r:00004BCC ; Segment type: Pure data
.rdata$r:00004BCC ; Segment permissions: Read
.rdata$r:00004BCC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004BCC                 assume cs:_rdata$r
.rdata$r:00004BCC                 ;org 4BCCh
.rdata$r:00004BCC ; COMDAT (pick any)
.rdata$r:00004BCC                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00004BCC ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004BCC ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00004BCC                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00004BCC                                         ; .rdata$r:00004C3Co ...
.rdata$r:00004BCC                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00004BD0                 db    1
.rdata$r:00004BD1                 db    0
.rdata$r:00004BD2                 db    0
.rdata$r:00004BD3                 db    0
.rdata$r:00004BD4                 db    0
.rdata$r:00004BD5                 db    0
.rdata$r:00004BD6                 db    0
.rdata$r:00004BD7                 db    0
.rdata$r:00004BD8                 db 0FFh
.rdata$r:00004BD9                 db 0FFh
.rdata$r:00004BDA                 db 0FFh
.rdata$r:00004BDB                 db 0FFh
.rdata$r:00004BDC                 db    0
.rdata$r:00004BDD                 db    0
.rdata$r:00004BDE                 db    0
.rdata$r:00004BDF                 db    0
.rdata$r:00004BE0                 db  40h ; @
.rdata$r:00004BE1                 db    0
.rdata$r:00004BE2                 db    0
.rdata$r:00004BE3                 db    0
.rdata$r:00004BE4                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004BE4 _rdata$r        ends
.rdata$r:00004BE4
.rdata$r:00004BE8 ; ===========================================================================
.rdata$r:00004BE8
.rdata$r:00004BE8 ; Segment type: Pure data
.rdata$r:00004BE8 ; Segment permissions: Read
.rdata$r:00004BE8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004BE8                 assume cs:_rdata$r
.rdata$r:00004BE8                 ;org 4BE8h
.rdata$r:00004BE8 ; COMDAT (pick any)
.rdata$r:00004BE8                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00004BE8 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00004BE8 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00004BE8                                         ; DATA XREF: .rdata:00004920o
.rdata$r:00004BE9                 db    0
.rdata$r:00004BEA                 db    0
.rdata$r:00004BEB                 db    0
.rdata$r:00004BEC                 db    0
.rdata$r:00004BED                 db    0
.rdata$r:00004BEE                 db    0
.rdata$r:00004BEF                 db    0
.rdata$r:00004BF0                 db    0
.rdata$r:00004BF1                 db    0
.rdata$r:00004BF2                 db    0
.rdata$r:00004BF3                 db    0
.rdata$r:00004BF4                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00004BF8                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004BF8 _rdata$r        ends
.rdata$r:00004BF8
.data$r:00004BFC ; ===========================================================================
.data$r:00004BFC
.data$r:00004BFC ; Segment type: Pure data
.data$r:00004BFC ; Segment permissions: Read/Write
.data$r:00004BFC _data$r         segment dword public 'DATA' use32
.data$r:00004BFC                 assume cs:_data$r
.data$r:00004BFC                 ;org 4BFCh
.data$r:00004BFC ; COMDAT (pick any)
.data$r:00004BFC                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00004BFC ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00004BFC ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004BFC                                         ; DATA XREF: .rdata$r:00004BF4o
.data$r:00004BFC                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004BFC                                         ; const type_info::`vftable'
.data$r:00004C00                 db    0
.data$r:00004C01                 db    0
.data$r:00004C02                 db    0
.data$r:00004C03                 db    0
.data$r:00004C04                 db  2Eh ; .
.data$r:00004C05                 db  3Fh ; ?
.data$r:00004C06                 db  41h ; A
.data$r:00004C07                 db  56h ; V
.data$r:00004C08                 db  5Fh ; _
.data$r:00004C09                 db  49h ; I
.data$r:00004C0A                 db  6Fh ; o
.data$r:00004C0B                 db  73h ; s
.data$r:00004C0C                 db  74h ; t
.data$r:00004C0D                 db  72h ; r
.data$r:00004C0E                 db  65h ; e
.data$r:00004C0F                 db  61h ; a
.data$r:00004C10                 db  6Dh ; m
.data$r:00004C11                 db  5Fh ; _
.data$r:00004C12                 db  65h ; e
.data$r:00004C13                 db  72h ; r
.data$r:00004C14                 db  72h ; r
.data$r:00004C15                 db  6Fh ; o
.data$r:00004C16                 db  72h ; r
.data$r:00004C17                 db  5Fh ; _
.data$r:00004C18                 db  63h ; c
.data$r:00004C19                 db  61h ; a
.data$r:00004C1A                 db  74h ; t
.data$r:00004C1B                 db  65h ; e
.data$r:00004C1C                 db  67h ; g
.data$r:00004C1D                 db  6Fh ; o
.data$r:00004C1E                 db  72h ; r
.data$r:00004C1F                 db  79h ; y
.data$r:00004C20                 db  40h ; @
.data$r:00004C21                 db  73h ; s
.data$r:00004C22                 db  74h ; t
.data$r:00004C23                 db  64h ; d
.data$r:00004C24                 db  40h ; @
.data$r:00004C25                 db  40h ; @
.data$r:00004C26                 db    0
.data$r:00004C27                 align 4
.data$r:00004C27 _data$r         ends
.data$r:00004C27
.rdata$r:00004C28 ; ===========================================================================
.rdata$r:00004C28
.rdata$r:00004C28 ; Segment type: Pure data
.rdata$r:00004C28 ; Segment permissions: Read
.rdata$r:00004C28 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004C28                 assume cs:_rdata$r
.rdata$r:00004C28                 ;org 4C28h
.rdata$r:00004C28 ; COMDAT (pick any)
.rdata$r:00004C28                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00004C28 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004C28 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00004C28                                         ; DATA XREF: .rdata$r:00004BF8o
.rdata$r:00004C28                                         ; .rdata$r:00004C60o
.rdata$r:00004C29                 db    0
.rdata$r:00004C2A                 db    0
.rdata$r:00004C2B                 db    0
.rdata$r:00004C2C                 db    0
.rdata$r:00004C2D                 db    0
.rdata$r:00004C2E                 db    0
.rdata$r:00004C2F                 db    0
.rdata$r:00004C30                 db    3
.rdata$r:00004C31                 db    0
.rdata$r:00004C32                 db    0
.rdata$r:00004C33                 db    0
.rdata$r:00004C34                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00004C34 _rdata$r        ends
.rdata$r:00004C34
.rdata$r:00004C38 ; ===========================================================================
.rdata$r:00004C38
.rdata$r:00004C38 ; Segment type: Pure data
.rdata$r:00004C38 ; Segment permissions: Read
.rdata$r:00004C38 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004C38                 assume cs:_rdata$r
.rdata$r:00004C38                 ;org 4C38h
.rdata$r:00004C38 ; COMDAT (pick any)
.rdata$r:00004C38                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00004C38 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00004C38 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00004C38                                         ; DATA XREF: .rdata$r:00004C34o
.rdata$r:00004C38                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004C3C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004C40                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004C44                 db    0
.rdata$r:00004C45                 align 4
.rdata$r:00004C45 _rdata$r        ends
.rdata$r:00004C45
.rdata$r:00004C48 ; ===========================================================================
.rdata$r:00004C48
.rdata$r:00004C48 ; Segment type: Pure data
.rdata$r:00004C48 ; Segment permissions: Read
.rdata$r:00004C48 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004C48                 assume cs:_rdata$r
.rdata$r:00004C48                 ;org 4C48h
.rdata$r:00004C48 ; COMDAT (pick any)
.rdata$r:00004C48                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00004C48 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004C48 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00004C48                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00004C48                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00004C4C                 db    2
.rdata$r:00004C4D                 db    0
.rdata$r:00004C4E                 db    0
.rdata$r:00004C4F                 db    0
.rdata$r:00004C50                 db    0
.rdata$r:00004C51                 db    0
.rdata$r:00004C52                 db    0
.rdata$r:00004C53                 db    0
.rdata$r:00004C54                 db 0FFh
.rdata$r:00004C55                 db 0FFh
.rdata$r:00004C56                 db 0FFh
.rdata$r:00004C57                 db 0FFh
.rdata$r:00004C58                 db    0
.rdata$r:00004C59                 db    0
.rdata$r:00004C5A                 db    0
.rdata$r:00004C5B                 db    0
.rdata$r:00004C5C                 db  40h ; @
.rdata$r:00004C5D                 db    0
.rdata$r:00004C5E                 db    0
.rdata$r:00004C5F                 db    0
.rdata$r:00004C60                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004C60 _rdata$r        ends
.rdata$r:00004C60
.rdata$r:00004C64 ; ===========================================================================
.rdata$r:00004C64
.rdata$r:00004C64 ; Segment type: Pure data
.rdata$r:00004C64 ; Segment permissions: Read
.rdata$r:00004C64 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004C64                 assume cs:_rdata$r
.rdata$r:00004C64                 ;org 4C64h
.rdata$r:00004C64 ; COMDAT (pick any)
.rdata$r:00004C64                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00004C64 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00004C64 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00004960o
.rdata$r:00004C65                 db    0
.rdata$r:00004C66                 db    0
.rdata$r:00004C67                 db    0
.rdata$r:00004C68                 db    0
.rdata$r:00004C69                 db    0
.rdata$r:00004C6A                 db    0
.rdata$r:00004C6B                 db    0
.rdata$r:00004C6C                 db    0
.rdata$r:00004C6D                 db    0
.rdata$r:00004C6E                 db    0
.rdata$r:00004C6F                 db    0
.rdata$r:00004C70                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00004C74                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004C74 _rdata$r        ends
.rdata$r:00004C74
.data$r:00004C78 ; ===========================================================================
.data$r:00004C78
.data$r:00004C78 ; Segment type: Pure data
.data$r:00004C78 ; Segment permissions: Read/Write
.data$r:00004C78 _data$r         segment dword public 'DATA' use32
.data$r:00004C78                 assume cs:_data$r
.data$r:00004C78                 ;org 4C78h
.data$r:00004C78 ; COMDAT (pick any)
.data$r:00004C78                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00004C78 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00004C78 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004C78                                         ; DATA XREF: .rdata$r:00004C70o
.data$r:00004C78                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004C78                                         ; const type_info::`vftable'
.data$r:00004C7C                 align 10h
.data$r:00004C80 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:00004CA1                 align 4
.data$r:00004CA1 _data$r         ends
.data$r:00004CA1
.rdata$r:00004CA4 ; ===========================================================================
.rdata$r:00004CA4
.rdata$r:00004CA4 ; Segment type: Pure data
.rdata$r:00004CA4 ; Segment permissions: Read
.rdata$r:00004CA4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004CA4                 assume cs:_rdata$r
.rdata$r:00004CA4                 ;org 4CA4h
.rdata$r:00004CA4 ; COMDAT (pick any)
.rdata$r:00004CA4                 public ??_R3_System_error_category@std@@8
.rdata$r:00004CA4 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004CA4 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00004C74o
.rdata$r:00004CA4                                         ; .rdata$r:00004CDCo
.rdata$r:00004CA5                 db    0
.rdata$r:00004CA6                 db    0
.rdata$r:00004CA7                 db    0
.rdata$r:00004CA8                 db    0
.rdata$r:00004CA9                 db    0
.rdata$r:00004CAA                 db    0
.rdata$r:00004CAB                 db    0
.rdata$r:00004CAC                 db    3
.rdata$r:00004CAD                 db    0
.rdata$r:00004CAE                 db    0
.rdata$r:00004CAF                 db    0
.rdata$r:00004CB0                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00004CB0 _rdata$r        ends
.rdata$r:00004CB0
.rdata$r:00004CB4 ; ===========================================================================
.rdata$r:00004CB4
.rdata$r:00004CB4 ; Segment type: Pure data
.rdata$r:00004CB4 ; Segment permissions: Read
.rdata$r:00004CB4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004CB4                 assume cs:_rdata$r
.rdata$r:00004CB4                 ;org 4CB4h
.rdata$r:00004CB4 ; COMDAT (pick any)
.rdata$r:00004CB4                 public ??_R2_System_error_category@std@@8
.rdata$r:00004CB4 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00004CB4 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00004CB4                                         ; DATA XREF: .rdata$r:00004CB0o
.rdata$r:00004CB4                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004CB8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004CBC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004CC0                 db    0
.rdata$r:00004CC1                 align 4
.rdata$r:00004CC1 _rdata$r        ends
.rdata$r:00004CC1
.rdata$r:00004CC4 ; ===========================================================================
.rdata$r:00004CC4
.rdata$r:00004CC4 ; Segment type: Pure data
.rdata$r:00004CC4 ; Segment permissions: Read
.rdata$r:00004CC4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004CC4                 assume cs:_rdata$r
.rdata$r:00004CC4                 ;org 4CC4h
.rdata$r:00004CC4 ; COMDAT (pick any)
.rdata$r:00004CC4                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00004CC4 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004CC4 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00004CC4                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00004CC4                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00004CC8                 db    2
.rdata$r:00004CC9                 db    0
.rdata$r:00004CCA                 db    0
.rdata$r:00004CCB                 db    0
.rdata$r:00004CCC                 db    0
.rdata$r:00004CCD                 db    0
.rdata$r:00004CCE                 db    0
.rdata$r:00004CCF                 db    0
.rdata$r:00004CD0                 db 0FFh
.rdata$r:00004CD1                 db 0FFh
.rdata$r:00004CD2                 db 0FFh
.rdata$r:00004CD3                 db 0FFh
.rdata$r:00004CD4                 db    0
.rdata$r:00004CD5                 db    0
.rdata$r:00004CD6                 db    0
.rdata$r:00004CD7                 db    0
.rdata$r:00004CD8                 db  40h ; @
.rdata$r:00004CD9                 db    0
.rdata$r:00004CDA                 db    0
.rdata$r:00004CDB                 db    0
.rdata$r:00004CDC                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004CDC _rdata$r        ends
.rdata$r:00004CDC
.CRT$XCU:00004CE0 ; ===========================================================================
.CRT$XCU:00004CE0
.CRT$XCU:00004CE0 ; Segment type: Pure data
.CRT$XCU:00004CE0 ; Segment permissions: Read
.CRT$XCU:00004CE0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004CE0                 assume cs:_CRT$XCU
.CRT$XCU:00004CE0                 ;org 4CE0h
.CRT$XCU:00004CE0 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00004CE4 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00004CE8 ; protected: static void (__cdecl *TabBarPlus::_activeTextColour$initializer$)(void)
.CRT$XCU:00004CE8 ?_activeTextColour$initializer$@TabBarPlus@@1P6AXXZA dd offset ??__E?_activeTextColour@TabBarPlus@@1KA@@YAXXZ ; `dynamic initializer for 'ulong TabBarPlus::_activeTextColour''(void)
.CRT$XCU:00004CE8 _CRT$XCU        ends
.CRT$XCU:00004CE8
.CRT$XCU:00004CEC ; ===========================================================================
.CRT$XCU:00004CEC
.CRT$XCU:00004CEC ; Segment type: Pure data
.CRT$XCU:00004CEC ; Segment permissions: Read
.CRT$XCU:00004CEC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004CEC                 assume cs:_CRT$XCU
.CRT$XCU:00004CEC                 ;org 4CECh
.CRT$XCU:00004CEC ; COMDAT (pick associative to section at 4984)
.CRT$XCU:00004CEC ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00004CEC ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00004CEC _CRT$XCU        ends
.CRT$XCU:00004CEC
.CRT$XCU:00004CF0 ; ===========================================================================
.CRT$XCU:00004CF0
.CRT$XCU:00004CF0 ; Segment type: Pure data
.CRT$XCU:00004CF0 ; Segment permissions: Read
.CRT$XCU:00004CF0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004CF0                 assume cs:_CRT$XCU
.CRT$XCU:00004CF0                 ;org 4CF0h
.CRT$XCU:00004CF0 ; COMDAT (pick associative to section at 4988)
.CRT$XCU:00004CF0 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00004CF0 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00004CF0 _CRT$XCU        ends
.CRT$XCU:00004CF0
.CRT$XCU:00004CF4 ; ===========================================================================
.CRT$XCU:00004CF4
.CRT$XCU:00004CF4 ; Segment type: Pure data
.CRT$XCU:00004CF4 ; Segment permissions: Read
.CRT$XCU:00004CF4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004CF4                 assume cs:_CRT$XCU
.CRT$XCU:00004CF4                 ;org 4CF4h
.CRT$XCU:00004CF4 ; COMDAT (pick associative to section at 498C)
.CRT$XCU:00004CF4 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00004CF4 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00004CF4 _CRT$XCU        ends
.CRT$XCU:00004CF4
.CRT$XCU:00004CF8 ; ===========================================================================
.CRT$XCU:00004CF8
.CRT$XCU:00004CF8 ; Segment type: Pure data
.CRT$XCU:00004CF8 ; Segment permissions: Read
.CRT$XCU:00004CF8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004CF8                 assume cs:_CRT$XCU
.CRT$XCU:00004CF8                 ;org 4CF8h
.CRT$XCU:00004CF8 ; COMDAT (pick associative to section at 4990)
.CRT$XCU:00004CF8 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00004CF8 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00004CF8 _CRT$XCU        ends
.CRT$XCU:00004CF8
.CRT$XCU:00004CFC ; ===========================================================================
.CRT$XCU:00004CFC
.CRT$XCU:00004CFC ; Segment type: Pure data
.CRT$XCU:00004CFC ; Segment permissions: Read
.CRT$XCU:00004CFC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004CFC                 assume cs:_CRT$XCU
.CRT$XCU:00004CFC                 ;org 4CFCh
.CRT$XCU:00004CFC ; COMDAT (pick associative to section at 4994)
.CRT$XCU:00004CFC ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00004CFC ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00004CFC _CRT$XCU        ends
.CRT$XCU:00004CFC
.CRT$XCU:00004D00 ; ===========================================================================
.CRT$XCU:00004D00
.CRT$XCU:00004D00 ; Segment type: Pure data
.CRT$XCU:00004D00 ; Segment permissions: Read
.CRT$XCU:00004D00 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004D00                 assume cs:_CRT$XCU
.CRT$XCU:00004D00                 ;org 4D00h
.CRT$XCU:00004D00 ; COMDAT (pick associative to section at 4A28)
.CRT$XCU:00004D00 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00004D00 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00004D00 _CRT$XCU        ends
.CRT$XCU:00004D00
.CRT$XCU:00004D04 ; ===========================================================================
.CRT$XCU:00004D04
.CRT$XCU:00004D04 ; Segment type: Pure data
.CRT$XCU:00004D04 ; Segment permissions: Read
.CRT$XCU:00004D04 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004D04                 assume cs:_CRT$XCU
.CRT$XCU:00004D04                 ;org 4D04h
.CRT$XCU:00004D04 ; COMDAT (pick associative to section at 4A2C)
.CRT$XCU:00004D04 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00004D04 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00004D04 _CRT$XCU        ends
.CRT$XCU:00004D04
UNDEF:00004D10 ; ===========================================================================
UNDEF:00004D10
UNDEF:00004D10 ; Segment type: Externs
UNDEF:00004D10 ; UNDEF
UNDEF:00004D10                 extrn __purecall:near   ; DATA XREF: .rdata:000048D8o
UNDEF:00004D10                                         ; .rdata:000048DCo
UNDEF:00004D14 ; void *__cdecl operator new(unsigned int)
UNDEF:00004D14                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00004D14                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00004D18 ; void __cdecl operator delete(void *)
UNDEF:00004D18                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00004D18                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:00004D1C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:00004D1C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:00004D1C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00004D20 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00004D20                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00004D24 ; size_t __cdecl strlen(const char *Str)
UNDEF:00004D24                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00004D28 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00004D28                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00004D2C ; int __stdcall MulDiv(int nNumber, int nNumerator, int nDenominator)
UNDEF:00004D2C                 extrn __imp__MulDiv@12:near
UNDEF:00004D2C                                         ; CODE XREF: DPIManager::scaleX(int)+13p
UNDEF:00004D2C                                         ; DPIManager::scaleY(int)+14p
UNDEF:00004D2C                                         ; DATA XREF: ...
UNDEF:00004D30 ; int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
UNDEF:00004D30                 extrn __imp__lstrcmpW@8:near
UNDEF:00004D30                                         ; CODE XREF: TabBarPlus::draggingCursor(tagPOINT)+7Cp
UNDEF:00004D30                                         ; TabBarPlus::draggingCursor(tagPOINT)+92p
UNDEF:00004D30                                         ; DATA XREF: ...
UNDEF:00004D34 ; int __stdcall lstrlenW(LPCWSTR lpString)
UNDEF:00004D34                 extrn __imp__lstrlenW@4:near
UNDEF:00004D34                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+C03p
UNDEF:00004D34                                         ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+C03r
UNDEF:00004D38 ; HDC __stdcall CreateCompatibleDC(HDC hdc)
UNDEF:00004D38                 extrn __imp__CreateCompatibleDC@4:near
UNDEF:00004D38                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+470p
UNDEF:00004D38                                         ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+470r
UNDEF:00004D3C ; HFONT __stdcall CreateFontIndirectW(const LOGFONTW *lplf)
UNDEF:00004D3C                 extrn __imp__CreateFontIndirectW@4:near
UNDEF:00004D3C                                         ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+32Dp
UNDEF:00004D3C                                         ; TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+344p
UNDEF:00004D3C                                         ; DATA XREF: ...
UNDEF:00004D40 ; HFONT __stdcall CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
UNDEF:00004D40                 extrn __imp__CreateFontW@56:near
UNDEF:00004D40                                         ; CODE XREF: TabBar::setFont(wchar_t *,uint)+7Cp
UNDEF:00004D40                                         ; DATA XREF: TabBar::setFont(wchar_t *,uint)+7Cr
UNDEF:00004D44 ; HBRUSH __stdcall CreateSolidBrush(COLORREF color)
UNDEF:00004D44                 extrn __imp__CreateSolidBrush@4:near
UNDEF:00004D44                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+141p
UNDEF:00004D44                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+275p ...
UNDEF:00004D48 ; BOOL __stdcall DeleteDC(HDC hdc)
UNDEF:00004D48                 extrn __imp__DeleteDC@4:near
UNDEF:00004D48                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+578p
UNDEF:00004D48                                         ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+578r
UNDEF:00004D4C ; BOOL __stdcall DeleteObject(HGDIOBJ ho)
UNDEF:00004D4C                 extrn __imp__DeleteObject@4:near
UNDEF:00004D4C                                         ; CODE XREF: TabBar::destroy(void)+17p
UNDEF:00004D4C                                         ; TabBar::destroy(void)+2Dp ...
UNDEF:00004D50 ; HGDIOBJ __stdcall GetStockObject(int i)
UNDEF:00004D50                 extrn __imp__GetStockObject@4:near
UNDEF:00004D50                                         ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+2E1p
UNDEF:00004D50                                         ; TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+2F8p
UNDEF:00004D50                                         ; DATA XREF: ...
UNDEF:00004D54 ; BOOL __stdcall GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
UNDEF:00004D54                 extrn __imp__GetTextExtentPointW@16:near
UNDEF:00004D54                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+5BFp
UNDEF:00004D54                                         ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+5BFr
UNDEF:00004D58 ; BOOL __stdcall RestoreDC(HDC hdc, int nSavedDC)
UNDEF:00004D58                 extrn __imp__RestoreDC@8:near
UNDEF:00004D58                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+C2Cp
UNDEF:00004D58                                         ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+C2Cr
UNDEF:00004D5C ; int __stdcall SaveDC(HDC hdc)
UNDEF:00004D5C                 extrn __imp__SaveDC@4:near
UNDEF:00004D5C                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+11Dp
UNDEF:00004D5C                                         ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+11Dr
UNDEF:00004D60 ; HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h)
UNDEF:00004D60                 extrn __imp__SelectObject@8:near
UNDEF:00004D60                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+524p
UNDEF:00004D60                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+88Ep ...
UNDEF:00004D64 ; int __stdcall SetBkMode(HDC hdc, int mode)
UNDEF:00004D64                 extrn __imp__SetBkMode@8:near
UNDEF:00004D64                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+132p
UNDEF:00004D64                                         ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+132r
UNDEF:00004D68 ; BOOL __stdcall StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
UNDEF:00004D68                 extrn __imp__StretchBlt@44:near
UNDEF:00004D68                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+56Bp
UNDEF:00004D68                                         ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+56Br
UNDEF:00004D6C ; COLORREF __stdcall SetTextColor(HDC hdc, COLORREF color)
UNDEF:00004D6C                 extrn __imp__SetTextColor@8:near
UNDEF:00004D6C                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+A02p
UNDEF:00004D6C                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+B31p
UNDEF:00004D6C                                         ; DATA XREF: ...
UNDEF:00004D70 ; int __stdcall GetObjectW(HANDLE h, int c, LPVOID pv)
UNDEF:00004D70                 extrn __imp__GetObjectW@12:near
UNDEF:00004D70                                         ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+311p
UNDEF:00004D70                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+4AAp
UNDEF:00004D70                                         ; DATA XREF: ...
UNDEF:00004D74 ; BOOL __stdcall TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack)
UNDEF:00004D74                 extrn __imp__TrackMouseEvent@4:near
UNDEF:00004D74                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+4C3p
UNDEF:00004D74                                         ; DATA XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+4C3r
UNDEF:00004D78 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00004D78                 extrn __imp__SendMessageW@16:near
UNDEF:00004D78                                         ; CODE XREF: TabBar::reSizeTo(tagRECT &)+6Ep
UNDEF:00004D78                                         ; TabBar::reSizeTo(tagRECT &)+89p ...
UNDEF:00004D7C ; LRESULT __stdcall CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00004D7C                 extrn __imp__CallWindowProcW@20:near
UNDEF:00004D7C                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+1E1p
UNDEF:00004D7C                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long)+2E4p ...
UNDEF:00004D80 ; HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
UNDEF:00004D80                 extrn __imp__CreateWindowExW@48:near
UNDEF:00004D80                                         ; CODE XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+DBp
UNDEF:00004D80                                         ; TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+103p ...
UNDEF:00004D84 ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:00004D84                 extrn __imp__DestroyWindow@4:near
UNDEF:00004D84                                         ; CODE XREF: TabBar::destroy(void)+66p
UNDEF:00004D84                                         ; TabBarPlus::destroy(void)+16p
UNDEF:00004D84                                         ; DATA XREF: ...
UNDEF:00004D88 ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:00004D88                 extrn __imp__MoveWindow@24:near
UNDEF:00004D88                                         ; CODE XREF: Window::reSizeTo(tagRECT &)+2Bp
UNDEF:00004D88                                         ; DATA XREF: Window::reSizeTo(tagRECT &)+2Br
UNDEF:00004D8C ; SHORT __stdcall GetKeyState(int nVirtKey)
UNDEF:00004D8C                 extrn __imp__GetKeyState@4:near
UNDEF:00004D8C                                         ; CODE XREF: TabBarPlus::draggingCursor(tagPOINT)+A1p
UNDEF:00004D8C                                         ; DATA XREF: TabBarPlus::draggingCursor(tagPOINT)+A1r
UNDEF:00004D90 ; HWND __stdcall GetCapture()
UNDEF:00004D90                 extrn __imp__GetCapture@0:near
UNDEF:00004D90                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+54Dp
UNDEF:00004D90                                         ; DATA XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+54Dr
UNDEF:00004D94 ; HWND __stdcall SetCapture(HWND hWnd)
UNDEF:00004D94                 extrn __imp__SetCapture@4:near
UNDEF:00004D94                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+27Cp
UNDEF:00004D94                                         ; DATA XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+27Cr
UNDEF:00004D98 ; BOOL __stdcall ReleaseCapture()
UNDEF:00004D98                 extrn __imp__ReleaseCapture@0:near
UNDEF:00004D98                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+55Bp
UNDEF:00004D98                                         ; DATA XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+55Br
UNDEF:00004D9C ; int __stdcall GetSystemMetrics(int nIndex)
UNDEF:00004D9C                 extrn __imp__GetSystemMetrics@4:near
UNDEF:00004D9C                                         ; CODE XREF: TabBar::reSizeTo(tagRECT &)+CEp
UNDEF:00004D9C                                         ; TabBar::reSizeTo(tagRECT &)+107p ...
UNDEF:00004DA0 ; BOOL __stdcall DragDetect(HWND hwnd, POINT pt)
UNDEF:00004DA0                 extrn __imp__DragDetect@12:near
UNDEF:00004DA0                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+267p
UNDEF:00004DA0                                         ; DATA XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+267r
UNDEF:00004DA4 ; int __stdcall DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
UNDEF:00004DA4                 extrn __imp__DrawTextW@20:near
UNDEF:00004DA4                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+C18p
UNDEF:00004DA4                                         ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+C18r
UNDEF:00004DA8 ; BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
UNDEF:00004DA8                 extrn __imp__InvalidateRect@12:near
UNDEF:00004DA8                                         ; CODE XREF: TabBarPlus::doOwnerDrawTab(void)+B7p
UNDEF:00004DA8                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long)+135p ...
UNDEF:00004DAC ; BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect)
UNDEF:00004DAC                 extrn __imp__GetWindowRect@8:near
UNDEF:00004DAC                                         ; CODE XREF: TabBarPlus::isPointInParentZone(tagPOINT)+1Ep
UNDEF:00004DAC                                         ; DATA XREF: TabBarPlus::isPointInParentZone(tagPOINT)+1Er
UNDEF:00004DB0 ; int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
UNDEF:00004DB0                 extrn __imp__MessageBoxW@16:near
UNDEF:00004DB0                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+66p
UNDEF:00004DB0                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+104p
UNDEF:00004DB0                                         ; DATA XREF: ...
UNDEF:00004DB4 ; HCURSOR __stdcall SetCursor(HCURSOR hCursor)
UNDEF:00004DB4                 extrn __imp__SetCursor@4:near
UNDEF:00004DB4                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+6B6p
UNDEF:00004DB4                                         ; TabBarPlus::draggingCursor(tagPOINT)+4Cp ...
UNDEF:00004DB8 ; BOOL __stdcall GetCursorPos(LPPOINT lpPoint)
UNDEF:00004DB8                 extrn __imp__GetCursorPos@4:near
UNDEF:00004DB8                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+336p
UNDEF:00004DB8                                         ; DATA XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+336r
UNDEF:00004DBC ; BOOL __stdcall ClientToScreen(HWND hWnd, LPPOINT lpPoint)
UNDEF:00004DBC                 extrn __imp__ClientToScreen@8:near
UNDEF:00004DBC                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+255p
UNDEF:00004DBC                                         ; DATA XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+255r
UNDEF:00004DC0 ; HWND __stdcall WindowFromPoint(POINT Point)
UNDEF:00004DC0                 extrn __imp__WindowFromPoint@8:near
UNDEF:00004DC0                                         ; CODE XREF: TabBarPlus::draggingCursor(tagPOINT)+21p
UNDEF:00004DC0                                         ; DATA XREF: TabBarPlus::draggingCursor(tagPOINT)+21r
UNDEF:00004DC4 ; DWORD __stdcall GetSysColor(int nIndex)
UNDEF:00004DC4                 extrn __imp__GetSysColor@4:near
UNDEF:00004DC4                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+13Ap
UNDEF:00004DC4                                         ; `dynamic initializer for 'ulong TabBarPlus::_activeTextColour''(void)+5p
UNDEF:00004DC4                                         ; DATA XREF: ...
UNDEF:00004DC8 ; int __stdcall FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
UNDEF:00004DC8                 extrn __imp__FillRect@12:near
UNDEF:00004DC8                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+162p
UNDEF:00004DC8                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+2ABp ...
UNDEF:00004DCC ; BOOL __stdcall SetRectEmpty(LPRECT lprc)
UNDEF:00004DCC                 extrn __imp__SetRectEmpty@4:near
UNDEF:00004DCC                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+41Fp
UNDEF:00004DCC                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long)+4FDp
UNDEF:00004DCC                                         ; DATA XREF: ...
UNDEF:00004DD0 ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:00004DD0                 extrn __imp__GetWindowLongW@8:near
UNDEF:00004DD0                                         ; CODE XREF: TabBarPlus::doOwnerDrawTab(void)+63p
UNDEF:00004DD0                                         ; TabBarPlus::runProc(HWND__ *,uint,uint,long)+B2p ...
UNDEF:00004DD4 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:00004DD4                 extrn __imp__SetWindowLongW@12:near
UNDEF:00004DD4                                         ; CODE XREF: TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+29Dp
UNDEF:00004DD4                                         ; TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+2B1p ...
UNDEF:00004DD8 ; int __stdcall GetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount)
UNDEF:00004DD8                 extrn __imp__GetClassNameW@12:near
UNDEF:00004DD8                                         ; CODE XREF: TabBarPlus::draggingCursor(tagPOINT)+6Ap
UNDEF:00004DD8                                         ; DATA XREF: TabBarPlus::draggingCursor(tagPOINT)+6Ar
UNDEF:00004DDC ; HBITMAP __stdcall LoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName)
UNDEF:00004DDC                 extrn __imp__LoadBitmapW@8:near
UNDEF:00004DDC                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+48Ep
UNDEF:00004DDC                                         ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+48Er
UNDEF:00004DE0 ; HCURSOR __stdcall LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName)
UNDEF:00004DE0                 extrn __imp__LoadCursorW@8:near
UNDEF:00004DE0                                         ; CODE XREF: TabBarPlus::runProc(HWND__ *,uint,uint,long)+6AFp
UNDEF:00004DE0                                         ; TabBarPlus::draggingCursor(tagPOINT)+45p ...
UNDEF:00004DE4 ; BOOL __stdcall InitCommonControlsEx(const INITCOMMONCONTROLSEX *picce)
UNDEF:00004DE4                 extrn __imp__InitCommonControlsEx@4:near
UNDEF:00004DE4                                         ; CODE XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+64p
UNDEF:00004DE4                                         ; TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+7Ap
UNDEF:00004DE4                                         ; DATA XREF: ...
UNDEF:00004DE8 ; BOOL __stdcall ImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle)
UNDEF:00004DE8                 extrn __imp__ImageList_Draw@24:near
UNDEF:00004DE8                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+787p
UNDEF:00004DE8                                         ; TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+801p
UNDEF:00004DE8                                         ; DATA XREF: ...
UNDEF:00004DEC ; BOOL __stdcall ImageList_GetImageInfo(HIMAGELIST himl, int i, IMAGEINFO *pImageInfo)
UNDEF:00004DEC                 extrn __imp__ImageList_GetImageInfo@12:near
UNDEF:00004DEC                                         ; CODE XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+61Ep
UNDEF:00004DEC                                         ; DATA XREF: TabBarPlus::drawItem(tagDRAWITEMSTRUCT *)+61Er
UNDEF:00004DF0 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00004DF0                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00004DF0                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00004DF4 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00004DF4                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00004DF4                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00004DF4                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00004DF8                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00004DFC ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:00004DFC                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:00004DFC                                         ; CODE XREF: std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:00004E00 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:00004E00                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:00004E00                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:00004E00                                         ; DATA XREF: .xdata$x:000048CCo
UNDEF:00004E04 ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:00004E04                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:00004E04                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:00004E04                                         ; __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0+3j ...
UNDEF:00004E08 ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:00004E08                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:00004E08                                         ; DATA XREF: .rdata:0000483Co
UNDEF:00004E0C ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00004E0C                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00004E0C                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00004E10 ; void __cdecl std::_Xbad_alloc()
UNDEF:00004E10                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00004E10                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_2776p
UNDEF:00004E10                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_27B8p
UNDEF:00004E14 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00004E14                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00004E14                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00004E18 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00004E18                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00004E18                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00004E1C ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:00004E1C                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:00004E1C                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:00004E20 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004E20                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004E20                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00004E24 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00004E24                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00004E24                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00004E24                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00004E28 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00004E28                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00004E28                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00004E2C ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004E2C                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004E2C                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00004E30 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004E30                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004E30                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00004E34 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004E34                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004E34                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00004E38 ; __fastcall __security_check_cookie(x)
UNDEF:00004E38                 extrn @__security_check_cookie@4:near
UNDEF:00004E38                                         ; CODE XREF: TabBar::reSizeTo(tagRECT &)+136p
UNDEF:00004E38                                         ; TabBar::deletItemAt(uint)+D9p ...
UNDEF:00004E3C ; __stdcall _CxxThrowException(x, x)
UNDEF:00004E3C                 extrn __CxxThrowException@8:near
UNDEF:00004E3C                                         ; CODE XREF: TabBar::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+106p
UNDEF:00004E3C                                         ; TabBarPlus::init(HINSTANCE__ *,HWND__ *,bool,bool,bool)+134p ...
UNDEF:00004E40                 extrn ___CxxFrameHandler3:near
UNDEF:00004E40                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:00004E40                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:00004E44 ; const type_info::`vftable'
UNDEF:00004E44                 extrn ??_7type_info@@6B@:near
UNDEF:00004E44                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:00004E44                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:00004E48 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:00004E48                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:00004E48                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:00004E4C                 extrn ___security_cookie:near
UNDEF:00004E4C                                         ; DATA XREF: TabBar::reSizeTo(tagRECT &)+6r
UNDEF:00004E4C                                         ; TabBar::deletItemAt(uint)+6r ...
UNDEF:00004E50                 extrn __fltused:near
UNDEF:00004E50
UNDEF:00004E50
UNDEF:00004E50                 end