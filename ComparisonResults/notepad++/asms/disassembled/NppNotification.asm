.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : 4E6AE1DCF4ACC53F8A5431259F01CA3D
.data:00000000 ; Input CRC32 : F3E7DCAB
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\NppNotification.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 ; Segment alignment 'qword' can not be represented in assembly
.data:00000000 _data           segment para public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000 _acTop_xpm      dd offset $SG143413     ; "12 12 56 1"
.data:00000004                 dd offset $SG143414     ; " \tc #FFFFFF"
.data:00000008                 dd offset $SG143415     ; ".\tc #8AB2E9"
.data:0000000C                 dd offset $SG143416     ; "+\tc #CCDCF6"
.data:00000010                 dd offset $SG143417     ; "@\tc #80ABEA"
.data:00000014                 dd offset $SG143418     ; "#\tc #7DA9E8"
.data:00000018                 dd offset $SG143419     ; "$\tc #C7DAF3"
.data:0000001C                 dd offset $SG143420     ; "%\tc #79A7E6"
.data:00000020 off_20          dd offset $SG143421     ; DATA XREF: .rdata:$SG172606o
.data:00000020                                         ; .rdata:$SG172607o ...
.data:00000020                                         ; "&\tc #ADC8EF"
.data:00000024 off_24          dd offset $SG143422     ; DATA XREF: .xdata$x:__tryblocktable$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Zo
.data:00000024                                         ; .xdata$x:0000BD00o ...
.data:00000024                                         ; "*\tc #87B0E8"
.data:00000028                 dd offset $SG143423     ; "=\tc #BBD2F0"
.data:0000002C                 dd offset $SG143424     ; "-\tc #6EA0E2"
.data:00000030                 dd offset $SG143425     ; ";\tc #A8C7EE"
.data:00000034                 dd offset $SG143426     ; ">\tc #A3C2ED"
.data:00000038                 dd offset $SG143427     ; ",\tc #75A4E3"
.data:0000003C                 dd offset $SG143428     ; "'\tc #A7C4EB"
.data:00000040                 dd offset $SG143429     ; ")\tc #6297E1"
.data:00000044                 dd offset $SG143430     ; "!\tc #A1C1EC"
.data:00000048                 dd offset $SG143431     ; "~\tc #92B7E8"
.data:0000004C                 dd offset $SG143432     ; "{\tc #99BBE9"
.data:00000050                 dd offset $SG143433     ; "]\tc #6197DD"
.data:00000054                 dd offset $SG143434     ; "^\tc #96B9E6"
.data:00000058                 dd offset $SG143435     ; "/\tc #538EDB"
.data:0000005C                 dd offset $SG143436     ; "(\tc #99BBEA"
.data:00000060                 dd offset $SG143437     ; "_\tc #80AAE3"
.data:00000064                 dd offset $SG143438     ; ":\tc #81ABE3"
.data:00000068                 dd offset $SG143439     ; "<\tc #8AB1E4"
.data:0000006C                 dd offset $SG143440     ; "[\tc #4B88D6"
.data:00000070                 dd offset $SG143441     ; "}\tc #4882D1"
.data:00000074                 dd offset $SG143442     ; "|\tc #4384D6"
.data:00000078                 dd offset $SG143443     ; "1\tc #90B5E7"
.data:0000007C                 dd offset $SG143444     ; "2\tc #74A3E0"
.data:00000080                 dd offset $SG143445     ; "3\tc #77A4E0"
.data:00000084                 dd offset $SG143446     ; "4\tc #81ABE2"
.data:00000088                 dd offset $SG143447     ; "5\tc #437FD3"
.data:0000008C                 dd offset $SG143448     ; "6\tc #7FA2DF"
.data:00000090                 dd offset $SG143449     ; "7\tc #3577D2"
.data:00000094                 dd offset $SG143450     ; "8\tc #87AFE4"
.data:00000098                 dd offset $SG143451     ; "9\tc #72A1DF"
.data:0000009C                 dd offset $SG143452     ; "0\tc #7CA9E1"
.data:000000A0                 dd offset $SG143453     ; "a\tc #3F7AD0"
.data:000000A4                 dd offset $SG143454     ; "b\tc #85A4DE"
.data:000000A8                 dd offset $SG143455     ; "c\tc #FBFCFE"
.data:000000AC                 dd offset $SG143456     ; "d\tc #236ECD"
.data:000000B0                 dd offset $SG143457     ; "e\tc #7EA8E1"
.data:000000B4                 dd offset $SG143458     ; "f\tc #79A6E0"
.data:000000B8                 dd offset $SG143459     ; "g\tc #3D77D0"
.data:000000BC                 dd offset $SG143460     ; "h\tc #87A4DC"
.data:000000C0                 dd offset $SG143461     ; "i\tc #1A62C9"
.data:000000C4                 dd offset $SG143462     ; "j\tc #75A3DF"
.data:000000C8                 dd offset $SG143463     ; "k\tc #3C74CF"
.data:000000CC                 dd offset $SG143464     ; "l\tc #8DA6DE"
.data:000000D0                 dd offset $SG143465     ; "m\tc #1859C4"
.data:000000D4                 dd offset $SG143466     ; "n\tc #3B71CC"
.data:000000D8                 dd offset $SG143467     ; "o\tc #8EA5DD"
.data:000000DC                 dd offset $SG143468     ; "p\tc #164EC0"
.data:000000E0                 dd offset $SG143469     ; "q\tc #92A7DD"
.data:000000E4                 dd offset $SG143470     ; "    .+      "
.data:000000E8                 dd offset $SG143471     ; "    @#$     "
.data:000000EC                 dd offset $SG143472     ; "    %&*=    "
.data:000000F0                 dd offset $SG143473     ; "    -;>,'   "
.data:000000F4                 dd offset $SG143474     ; "    )!~{]^  "
.data:000000F8                 dd offset $SG143475     ; "    /(_:<[} "
.data:000000FC                 dd offset $SG143476     ; "    |123456 "
.data:00000100                 dd offset $SG143477     ; "    7890abc "
.data:00000104                 dd offset $SG143478     ; "    defgh   "
.data:00000108                 dd offset $SG143479     ; "    ijkl    "
.data:0000010C                 dd offset $SG143480     ; "    mno     "
.data:00000110                 dd offset $SG143481     ; "    pq      "
.data:00000114                 align 8
.data:00000118 _acBottom_xpm   dd offset $SG143483     ; "12 12 54 1"
.data:0000011C                 dd offset $SG143484     ; " \tc #FFFFFF"
.data:00000120                 dd offset $SG143485     ; ".\tc #C4D7F3"
.data:00000124                 dd offset $SG143486     ; "+\tc #72A1E3"
.data:00000128                 dd offset $SG143487     ; "@\tc #C1D6F2"
.data:0000012C                 dd offset $SG143488     ; "#\tc #6397E1"
.data:00000130                 dd offset $SG143489     ; "$\tc #5990DD"
.data:00000134                 dd offset $SG143490     ; "%\tc #BBD2F0"
.data:00000138                 dd offset $SG143491     ; "&\tc #7AA6E5"
.data:0000013C                 dd offset $SG143492     ; "*\tc #9ABDEA"
.data:00000140                 dd offset $SG143493     ; "=\tc #4A87D9"
.data:00000144                 dd offset $SG143494     ; "-\tc #B1CAEE"
.data:00000148                 dd offset $SG143495     ; ";\tc #75A4E3"
.data:0000014C                 dd offset $SG143496     ; ">\tc #99BBE9"
.data:00000150                 dd offset $SG143497     ; ",\tc #95B9E8"
.data:00000154                 dd offset $SG143498     ; "'\tc #3A7CD4"
.data:00000158                 dd offset $SG143499     ; ")\tc #A9C6EC"
.data:0000015C                 dd offset $SG143500     ; "!\tc #71A0E0"
.data:00000160                 dd offset $SG143501     ; "~\tc #86AFE5"
.data:00000164                 dd offset $SG143502     ; "{\tc #8DB2E6"
.data:00000168                 dd offset $SG143503     ; "]\tc #2A72CF"
.data:0000016C                 dd offset $SG143504     ; "^\tc #73A0E0"
.data:00000170                 dd offset $SG143505     ; "/\tc #6B9DE0"
.data:00000174                 dd offset $SG143506     ; "(\tc #95B8E8"
.data:00000178                 dd offset $SG143507     ; "_\tc #81ABE3"
.data:0000017C                 dd offset $SG143508     ; ":\tc #72A1DF"
.data:00000180                 dd offset $SG143509     ; "<\tc #83ADE3"
.data:00000184                 dd offset $SG143510     ; "[\tc #1B65C9"
.data:00000188                 dd offset $SG143511     ; "}\tc #5F95DC"
.data:0000018C                 dd offset $SG143512     ; "|\tc #8BB3E5"
.data:00000190                 dd offset $SG143513     ; "1\tc #77A4E0"
.data:00000194                 dd offset $SG143514     ; "2\tc #679ADC"
.data:00000198                 dd offset $SG143515     ; "3\tc #7AA6E1"
.data:0000019C                 dd offset $SG143516     ; "4\tc #195CC6"
.data:000001A0                 dd offset $SG143517     ; "5\tc #FCFDFE"
.data:000001A4                 dd offset $SG143518     ; "6\tc #8DB2E4"
.data:000001A8                 dd offset $SG143519     ; "7\tc #4885D6"
.data:000001AC                 dd offset $SG143520     ; "8\tc #7CA9E1"
.data:000001B0                 dd offset $SG143521     ; "9\tc #6698DB"
.data:000001B4                 dd offset $SG143522     ; "0\tc #71A1DE"
.data:000001B8                 dd offset $SG143523     ; "a\tc #1752C0"
.data:000001BC                 dd offset $SG143524     ; "b\tc #88ABE0"
.data:000001C0                 dd offset $SG143525     ; "c\tc #3D77D0"
.data:000001C4                 dd offset $SG143526     ; "d\tc #6E9FDD"
.data:000001C8                 dd offset $SG143527     ; "e\tc #699BDC"
.data:000001CC                 dd offset $SG143528     ; "f\tc #1547BD"
.data:000001D0                 dd offset $SG143529     ; "g\tc #8DA6DE"
.data:000001D4                 dd offset $SG143530     ; "h\tc #376BC9"
.data:000001D8                 dd offset $SG143531     ; "i\tc #6295DA"
.data:000001DC                 dd offset $SG143532     ; "j\tc #1440B9"
.data:000001E0                 dd offset $SG143533     ; "k\tc #8DA0DB"
.data:000001E4                 dd offset $SG143534     ; "l\tc #315FC4"
.data:000001E8                 dd offset $SG143535     ; "m\tc #1339B7"
.data:000001EC                 dd offset $SG143536     ; "n\tc #909FDA"
.data:000001F0                 dd offset $SG143537     ; "o\tc #1233B4"
.data:000001F4                 dd offset $SG143538     ; "         .+ "
.data:000001F8                 dd offset $SG143539     ; "        @#$ "
.data:000001FC                 dd offset $SG143540     ; "       %&*= L"
.data:00000200                 dd offset $SG143541     ; "      -;>,' "
.data:00000204                 dd offset $SG143542     ; "     )!>~{] "
.data:00000208                 dd offset $SG143543     ; "    ^/(_:<[ "
.data:0000020C                 dd offset $SG143544     ; "    (}|1234 "
.data:00000210                 dd offset $SG143545     ; "    567890a "
.data:00000214                 dd offset $SG143546     ; "      bcdef "
.data:00000218                 dd offset $SG143547     ; "       ghij "
.data:0000021C                 dd offset $SG143548     ; "        klm "
.data:00000220                 dd offset $SG143549     ; "         no "
.data:00000224                 align 8
.data:00000228 _bookmark_xpm   dd offset $SG143551     ; "13 14 54 1"
.data:0000022C                 dd offset $SG143552     ; " \tc None"
.data:00000230                 dd offset $SG143553     ; ".\tc #545254"
.data:00000234                 dd offset $SG143554     ; "+\tc #3C3E3C"
.data:00000238                 dd offset $SG143555     ; "@\tc #646464"
.data:0000023C                 dd offset $SG143556     ; "#\tc #A4A4A4"
.data:00000240                 dd offset $SG143557     ; "$\tc #B7B8B7"
.data:00000244                 dd offset $SG143558     ; "%\tc #747284"
.data:00000248                 dd offset $SG143559     ; "&\tc #B4B2C4"
.data:0000024C                 dd offset $SG143560     ; "*\tc #DCD7E4"
.data:00000250                 dd offset $SG143561     ; "=\tc #1C1A1C"
.data:00000254                 dd offset $SG143562     ; "-\tc #403E58"
.data:00000258                 dd offset $SG143563     ; ";\tc #5C5A8C"
.data:0000025C                 dd offset $SG143564     ; ">\tc #7C7EAC"
.data:00000260                 dd offset $SG143565     ; ",\tc #7C8EBC"
.data:00000264                 dd offset $SG143566     ; "'\tc #242644"
.data:00000268                 dd offset $SG143567     ; ")\tc #282668"
.data:0000026C                 dd offset $SG143568     ; "!\tc #24367C"
.data:00000270                 dd offset $SG143569     ; "~\tc #244A84"
.data:00000274                 dd offset $SG143570     ; "{\tc #2C5098"
.data:00000278                 dd offset $SG143571     ; "]\tc #14162C"
.data:0000027C                 dd offset $SG143572     ; "^\tc #142E7C"
.data:00000280                 dd offset $SG143573     ; "/\tc #143789"
.data:00000284                 dd offset $SG143574     ; "(\tc #204990"
.data:00000288                 dd offset $SG143575     ; "_\tc #174091"
.data:0000028C                 dd offset $SG143576     ; ":\tc #0C0630"
.data:00000290                 dd offset $SG143577     ; "<\tc #24327C"
.data:00000294                 dd offset $SG143578     ; "[\tc #2450A0"
.data:00000298                 dd offset $SG143579     ; "}\tc #345DB4"
.data:0000029C                 dd offset $SG143580     ; "|\tc #3C68B8"
.data:000002A0                 dd offset $SG143581     ; "1\tc #141244"
.data:000002A4                 dd offset $SG143582     ; "2\tc #24428C"
.data:000002A8                 dd offset $SG143583     ; "3\tc #3462B9"
.data:000002AC                 dd offset $SG143584     ; "4\tc #4470C4"
.data:000002B0                 dd offset $SG143585     ; "5\tc #4C7FD6"
.data:000002B4                 dd offset $SG143586     ; "6\tc #4472CC"
.data:000002B8                 dd offset $SG143587     ; "7\tc #24224C"
.data:000002BC                 dd offset $SG143588     ; "8\tc #5C8DEC"
.data:000002C0                 dd offset $SG143589     ; "9\tc #5C94F6"
.data:000002C4                 dd offset $SG143590     ; "0\tc #5482DF"
.data:000002C8                 dd offset $SG143591     ; "a\tc #619DF7"
.data:000002CC                 dd offset $SG143592     ; "b\tc #6CA6FC"
.data:000002D0                 dd offset $SG143593     ; "c\tc #64A2FC"
.data:000002D4                 dd offset $SG143594     ; "d\tc #1C2E5C"
.data:000002D8                 dd offset $SG143595     ; "e\tc #6CA2FC"
.data:000002DC                 dd offset $SG143596     ; "f\tc #74B2FC"
.data:000002E0                 dd offset $SG143597     ; "g\tc #7CB8FC"
.data:000002E4                 dd offset $SG143598     ; "h\tc #1C3264"
.data:000002E8                 dd offset $SG143599     ; "i\tc #346AD4"
.data:000002EC                 dd offset $SG143600     ; "j\tc #7CBEFC"
.data:000002F0                 dd offset $SG143601     ; "k\tc #3C72DC"
.data:000002F4                 dd offset $SG143602     ; "l\tc #243250"
.data:000002F8                 dd offset $SG143603     ; "m\tc #346AB4"
.data:000002FC                 dd offset $SG143604     ; "n\tc #3C82DC"
.data:00000300                 dd offset $SG143605     ; "o\tc #6C6A6C"
.data:00000304                 dd offset $SG143606     ; "     .+.     "
.data:00000308                 dd offset $SG143607     ; "   @##$##@   "
.data:0000030C                 dd offset $SG143608     ; "  @%&***&%@  "
.data:00000310                 dd offset $SG143609     ; " =-;>,,,>;-= "
.data:00000314                 dd offset $SG143610     ; " ')!~{{{~!)' "
.data:00000318                 dd offset $SG143611     ; "])^/({{{(_^)]"
.data:0000031C                 dd offset $SG143612     ; ":<_[}|||}[_<:"
.data:00000320                 dd offset $SG143613     ; "12[3455563[21"
.data:00000324                 dd offset $SG143614     ; "7_365899063_7"
.data:00000328                 dd offset $SG143615     ; " /|09abc904/ "
.data:0000032C                 dd offset $SG143616     ; " d}8efgfb83d "
.data:00000330                 dd offset $SG143617     ; "  hiafjgakh  "
.data:00000334                 dd offset $SG143618     ; "   l~mnm~l   "
.data:00000338                 dd offset $SG143619     ; "     o@o     "
.data:00000338 _data           ends
.data:00000338
.rdata:0000033C ; ===========================================================================
.rdata:0000033C
.rdata:0000033C ; Segment type: Pure data
.rdata:0000033C ; Segment permissions: Read
.rdata:0000033C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000033C _rdata          segment para public 'DATA' use32
.rdata:0000033C                 assume cs:_rdata
.rdata:0000033C                 ;org 33Ch
.rdata:0000033C $SG143413       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:00000347                 align 4
.rdata:00000348 $SG143414       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000004o
.rdata:00000354 $SG143415       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000008o
.rdata:00000360 $SG143416       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:0000000Co
.rdata:0000036C $SG143417       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000010o
.rdata:00000378 $SG143418       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000014o
.rdata:00000384 $SG143419       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000018o
.rdata:00000390 $SG143420       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:0000001Co
.rdata:0000039C $SG143421       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:off_20o
.rdata:000003A8 $SG143422       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:off_24o
.rdata:000003B4 $SG143423       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000028o
.rdata:000003C0 $SG143424       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:0000002Co
.rdata:000003CC $SG143425       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000030o
.rdata:000003D8 $SG143426       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000034o
.rdata:000003E4 $SG143427       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000038o
.rdata:000003F0 $SG143428       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:0000003Co
.rdata:000003FC $SG143429       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000040o
.rdata:00000408 $SG143430       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000044o
.rdata:00000414 $SG143431       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000048o
.rdata:00000420 $SG143432       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:0000004Co
.rdata:0000042C $SG143433       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000050o
.rdata:00000438 $SG143434       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000054o
.rdata:00000444 $SG143435       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000058o
.rdata:00000450 $SG143436       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:0000005Co
.rdata:0000045C $SG143437       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000060o
.rdata:00000468 $SG143438       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000064o
.rdata:00000474 $SG143439       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000068o
.rdata:00000480 $SG143440       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:0000006Co
.rdata:0000048C $SG143441       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000070o
.rdata:00000498 $SG143442       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000074o
.rdata:000004A4 $SG143443       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000078o
.rdata:000004B0 $SG143444       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:0000007Co
.rdata:000004BC $SG143445       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000080o
.rdata:000004C8 $SG143446       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000084o
.rdata:000004D4 $SG143447       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000088o
.rdata:000004E0 $SG143448       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:0000008Co
.rdata:000004EC $SG143449       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000090o
.rdata:000004F8 $SG143450       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000094o
.rdata:00000504 $SG143451       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000098o
.rdata:00000510 $SG143452       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:0000009Co
.rdata:0000051C $SG143453       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:000000A0o
.rdata:00000528 $SG143454       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:000000A4o
.rdata:00000534 $SG143455       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:000000A8o
.rdata:00000540 $SG143456       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:000000ACo
.rdata:0000054C $SG143457       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:000000B0o
.rdata:00000558 $SG143458       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:000000B4o
.rdata:00000564 $SG143459       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:000000B8o
.rdata:00000570 $SG143460       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:000000BCo
.rdata:0000057C $SG143461       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:000000C0o
.rdata:00000588 $SG143462       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:000000C4o
.rdata:00000594 $SG143463       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:000000C8o
.rdata:000005A0 $SG143464       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:000000CCo
.rdata:000005AC $SG143465       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:000000D0o
.rdata:000005B8 $SG143466       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:000000D4o
.rdata:000005C4 $SG143467       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:000000D8o
.rdata:000005D0 $SG143468       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:000000DCo
.rdata:000005DC $SG143469       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:000000E0o
.rdata:000005E8 $SG143470       db '    .+      ',0     ; DATA XREF: .data:000000E4o
.rdata:000005F5                 align 4
.rdata:000005F8 $SG143471       db '    @#$     ',0     ; DATA XREF: .data:000000E8o
.rdata:00000605                 align 4
.rdata:00000608 $SG143472       db '    %&*=    ',0     ; DATA XREF: .data:000000ECo
.rdata:00000615                 align 4
.rdata:00000618 $SG143473       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:000000F0o
.rdata:00000625                 align 4
.rdata:00000628 $SG143474       db '    )!~{]^  ',0     ; DATA XREF: .data:000000F4o
.rdata:00000635                 align 4
.rdata:00000638 $SG143475       db '    /(_:<[} ',0     ; DATA XREF: .data:000000F8o
.rdata:00000645                 align 4
.rdata:00000648 $SG143476       db '    |123456 ',0     ; DATA XREF: .data:000000FCo
.rdata:00000655                 align 4
.rdata:00000658 $SG143477       db '    7890abc ',0     ; DATA XREF: .data:00000100o
.rdata:00000665                 align 4
.rdata:00000668 $SG143478       db '    defgh   ',0     ; DATA XREF: .data:00000104o
.rdata:00000675                 align 4
.rdata:00000678 $SG143479       db '    ijkl    ',0     ; DATA XREF: .data:00000108o
.rdata:00000685                 align 4
.rdata:00000688 $SG143480       db '    mno     ',0     ; DATA XREF: .data:0000010Co
.rdata:00000695                 align 4
.rdata:00000698 $SG143481       db '    pq      ',0     ; DATA XREF: .data:00000110o
.rdata:000006A5                 align 4
.rdata:000006A8 $SG143483       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:000006B3                 align 4
.rdata:000006B4 $SG143484       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:0000011Co
.rdata:000006C0 $SG143485       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000120o
.rdata:000006CC $SG143486       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000124o
.rdata:000006D8 $SG143487       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000128o
.rdata:000006E4 $SG143488       db '#',9,'c #6397E1',0  ; DATA XREF: .data:0000012Co
.rdata:000006F0 $SG143489       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000130o
.rdata:000006FC $SG143490       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000134o
.rdata:00000708 $SG143491       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000138o
.rdata:00000714 $SG143492       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:0000013Co
.rdata:00000720 $SG143493       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000140o
.rdata:0000072C $SG143494       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000144o
.rdata:00000738 $SG143495       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000148o
.rdata:00000744 $SG143496       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:0000014Co
.rdata:00000750 $SG143497       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000150o
.rdata:0000075C $SG143498       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000154o
.rdata:00000768 $SG143499       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000158o
.rdata:00000774 $SG143500       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:0000015Co
.rdata:00000780 $SG143501       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000160o
.rdata:0000078C $SG143502       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000164o
.rdata:00000798 $SG143503       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000168o
.rdata:000007A4 $SG143504       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:0000016Co
.rdata:000007B0 $SG143505       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000170o
.rdata:000007BC $SG143506       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000174o
.rdata:000007C8 $SG143507       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000178o
.rdata:000007D4 $SG143508       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:0000017Co
.rdata:000007E0 $SG143509       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000180o
.rdata:000007EC $SG143510       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000184o
.rdata:000007F8 $SG143511       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000188o
.rdata:00000804 $SG143512       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:0000018Co
.rdata:00000810 $SG143513       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000190o
.rdata:0000081C $SG143514       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000194o
.rdata:00000828 $SG143515       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000198o
.rdata:00000834 $SG143516       db '4',9,'c #195CC6',0  ; DATA XREF: .data:0000019Co
.rdata:00000840 $SG143517       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:000001A0o
.rdata:0000084C $SG143518       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:000001A4o
.rdata:00000858 $SG143519       db '7',9,'c #4885D6',0  ; DATA XREF: .data:000001A8o
.rdata:00000864 $SG143520       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:000001ACo
.rdata:00000870 $SG143521       db '9',9,'c #6698DB',0  ; DATA XREF: .data:000001B0o
.rdata:0000087C $SG143522       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:000001B4o
.rdata:00000888 $SG143523       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:000001B8o
.rdata:00000894 $SG143524       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:000001BCo
.rdata:000008A0 $SG143525       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:000001C0o
.rdata:000008AC $SG143526       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:000001C4o
.rdata:000008B8 $SG143527       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:000001C8o
.rdata:000008C4 $SG143528       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:000001CCo
.rdata:000008D0 $SG143529       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:000001D0o
.rdata:000008DC $SG143530       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:000001D4o
.rdata:000008E8 $SG143531       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:000001D8o
.rdata:000008F4 $SG143532       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:000001DCo
.rdata:00000900 $SG143533       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:000001E0o
.rdata:0000090C $SG143534       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:000001E4o
.rdata:00000918 $SG143535       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:000001E8o
.rdata:00000924 $SG143536       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:000001ECo
.rdata:00000930 $SG143537       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:000001F0o
.rdata:0000093C $SG143538       db '         .+ ',0     ; DATA XREF: .data:000001F4o
.rdata:00000949                 align 4
.rdata:0000094C $SG143539       db '        @#$ ',0     ; DATA XREF: .data:000001F8o
.rdata:00000959                 align 4
.rdata:0000095C $SG143540       db '       %&*= L',0    ; DATA XREF: .data:000001FCo
.rdata:0000096A                 align 4
.rdata:0000096C $SG143541       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000200o
.rdata:00000979                 align 4
.rdata:0000097C $SG143542       db '     )!>~{] ',0     ; DATA XREF: .data:00000204o
.rdata:00000989                 align 4
.rdata:0000098C $SG143543       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000208o
.rdata:00000999                 align 4
.rdata:0000099C $SG143544       db '    (}|1234 ',0     ; DATA XREF: .data:0000020Co
.rdata:000009A9                 align 4
.rdata:000009AC $SG143545       db '    567890a ',0     ; DATA XREF: .data:00000210o
.rdata:000009B9                 align 4
.rdata:000009BC $SG143546       db '      bcdef ',0     ; DATA XREF: .data:00000214o
.rdata:000009C9                 align 4
.rdata:000009CC $SG143547       db '       ghij ',0     ; DATA XREF: .data:00000218o
.rdata:000009D9                 align 4
.rdata:000009DC $SG143548       db '        klm ',0     ; DATA XREF: .data:0000021Co
.rdata:000009E9                 align 4
.rdata:000009EC $SG143549       db '         no ',0     ; DATA XREF: .data:00000220o
.rdata:000009F9                 align 4
.rdata:000009FC $SG143551       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:00000A07                 align 4
.rdata:00000A08 $SG143552       db ' ',9,'c None',0     ; DATA XREF: .data:0000022Co
.rdata:00000A11                 align 4
.rdata:00000A14 $SG143553       db '.',9,'c #545254',0  ; DATA XREF: .data:00000230o
.rdata:00000A20 $SG143554       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000234o
.rdata:00000A2C $SG143555       db '@',9,'c #646464',0  ; DATA XREF: .data:00000238o
.rdata:00000A38 $SG143556       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:0000023Co
.rdata:00000A44 $SG143557       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000240o
.rdata:00000A50 $SG143558       db '%',9,'c #747284',0  ; DATA XREF: .data:00000244o
.rdata:00000A5C $SG143559       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000248o
.rdata:00000A68 $SG143560       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:0000024Co
.rdata:00000A74 $SG143561       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000250o
.rdata:00000A80 $SG143562       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000254o
.rdata:00000A8C $SG143563       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000258o
.rdata:00000A98 $SG143564       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:0000025Co
.rdata:00000AA4 $SG143565       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000260o
.rdata:00000AB0 $SG143566       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000264o
.rdata:00000ABC $SG143567       db ')',9,'c #282668',0  ; DATA XREF: .data:00000268o
.rdata:00000AC8 $SG143568       db '!',9,'c #24367C',0  ; DATA XREF: .data:0000026Co
.rdata:00000AD4 $SG143569       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000270o
.rdata:00000AE0 $SG143570       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000274o
.rdata:00000AEC $SG143571       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000278o
.rdata:00000AF8 $SG143572       db '^',9,'c #142E7C',0  ; DATA XREF: .data:0000027Co
.rdata:00000B04 $SG143573       db '/',9,'c #143789',0  ; DATA XREF: .data:00000280o
.rdata:00000B10 $SG143574       db '(',9,'c #204990',0  ; DATA XREF: .data:00000284o
.rdata:00000B1C $SG143575       db '_',9,'c #174091',0  ; DATA XREF: .data:00000288o
.rdata:00000B28 $SG143576       db ':',9,'c #0C0630',0  ; DATA XREF: .data:0000028Co
.rdata:00000B34 $SG143577       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000290o
.rdata:00000B40 $SG143578       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000294o
.rdata:00000B4C $SG143579       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000298o
.rdata:00000B58 $SG143580       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:0000029Co
.rdata:00000B64 $SG143581       db '1',9,'c #141244',0  ; DATA XREF: .data:000002A0o
.rdata:00000B70 $SG143582       db '2',9,'c #24428C',0  ; DATA XREF: .data:000002A4o
.rdata:00000B7C $SG143583       db '3',9,'c #3462B9',0  ; DATA XREF: .data:000002A8o
.rdata:00000B88 $SG143584       db '4',9,'c #4470C4',0  ; DATA XREF: .data:000002ACo
.rdata:00000B94 $SG143585       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:000002B0o
.rdata:00000BA0 $SG143586       db '6',9,'c #4472CC',0  ; DATA XREF: .data:000002B4o
.rdata:00000BAC $SG143587       db '7',9,'c #24224C',0  ; DATA XREF: .data:000002B8o
.rdata:00000BB8 $SG143588       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:000002BCo
.rdata:00000BC4 $SG143589       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:000002C0o
.rdata:00000BD0 $SG143590       db '0',9,'c #5482DF',0  ; DATA XREF: .data:000002C4o
.rdata:00000BDC $SG143591       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:000002C8o
.rdata:00000BE8 $SG143592       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:000002CCo
.rdata:00000BF4 $SG143593       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:000002D0o
.rdata:00000C00 $SG143594       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:000002D4o
.rdata:00000C0C $SG143595       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:000002D8o
.rdata:00000C18 $SG143596       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:000002DCo
.rdata:00000C24 $SG143597       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:000002E0o
.rdata:00000C30 $SG143598       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:000002E4o
.rdata:00000C3C $SG143599       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:000002E8o
.rdata:00000C48 $SG143600       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:000002ECo
.rdata:00000C54 $SG143601       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:000002F0o
.rdata:00000C60 $SG143602       db 'l',9,'c #243250',0  ; DATA XREF: .data:000002F4o
.rdata:00000C6C $SG143603       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:000002F8o
.rdata:00000C78 $SG143604       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:000002FCo
.rdata:00000C84 $SG143605       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000300o
.rdata:00000C90 $SG143606       db '     .+.     ',0    ; DATA XREF: .data:00000304o
.rdata:00000C9E                 align 10h
.rdata:00000CA0 $SG143607       db '   @##$##@   ',0    ; DATA XREF: .data:00000308o
.rdata:00000CAE                 align 10h
.rdata:00000CB0 $SG143608       db '  @%&***&%@  ',0    ; DATA XREF: .data:0000030Co
.rdata:00000CBE                 align 10h
.rdata:00000CC0 $SG143609       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000310o
.rdata:00000CCE                 align 10h
.rdata:00000CD0 $SG143610       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:00000CD0                                         ; DATA XREF: .data:00000314o
.rdata:00000CDE                 align 10h
.rdata:00000CE0 $SG143611       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000318o
.rdata:00000CEE                 align 10h
.rdata:00000CF0 $SG143612       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:0000031Co
.rdata:00000CFE                 align 10h
.rdata:00000D00 $SG143613       db '12[3455563[21',0    ; DATA XREF: .data:00000320o
.rdata:00000D0E                 align 10h
.rdata:00000D10 $SG143614       db '7_365899063_7',0    ; DATA XREF: .data:00000324o
.rdata:00000D1E                 align 10h
.rdata:00000D20 $SG143615       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000328o
.rdata:00000D2E                 align 10h
.rdata:00000D30 $SG143616       db ' d}8efgfb83d ',0    ; DATA XREF: .data:0000032Co
.rdata:00000D3E                 align 10h
.rdata:00000D40 $SG143617       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000330o
.rdata:00000D4E                 align 10h
.rdata:00000D50 $SG143618       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000334o
.rdata:00000D5E                 align 10h
.rdata:00000D60 $SG143619       db '     o@o     ',0    ; DATA XREF: .data:00000338o
.rdata:00000D6E                 align 10h
.rdata:00000D70 ; wchar_t _SG173541
.rdata:00000D70 $SG173541:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+2615o
.rdata:00000D70                 unicode 0, <..\src\NppNotification.cpp>,0
.rdata:00000DA6                 align 4
.rdata:00000DA8 ; wchar_t _SG173580
.rdata:00000DA8 $SG173580       dw 0                    ; DATA XREF: Notepad_plus::notify(SCNotification *)+29E3o
.rdata:00000DAA                 db    0
.rdata:00000DAB                 db    0
.rdata:00000DAC ; wchar_t _SG173542
.rdata:00000DAC $SG173542:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+261Ao
.rdata:00000DAC                 unicode 0, <(leftmost_position == -1 && rightmost_position == -1) || >
.rdata:00000DAC                 unicode 0, <(leftmost_position >
.rdata:00000DAC                 dw 3Eh
.rdata:00000DAC                 unicode 0, <= 0 && rightmost_position >
.rdata:00000DAC                 dw 3Eh
.rdata:00000DAC                 unicode 0, <= 0)>,0
.rdata:00000E86                 align 4
.rdata:00000E88 $SG172588:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+63Eo
.rdata:00000E88                 unicode 0, <Move to other view>,0
.rdata:00000EAE                 align 10h
.rdata:00000EB0 $SG172590:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+667o
.rdata:00000EB0                 unicode 0, <Clone to other View>,0
.rdata:00000ED8 ; wchar_t _SG172606
.rdata:00000ED8 $SG172606       dd offset off_20+2      ; DATA XREF: Notepad_plus::notify(SCNotification *):loc_1CD6o
.rdata:00000EDC $SG173619       db 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-+'
.rdata:00000EDC                                         ; DATA XREF: Notepad_plus::notify(SCNotification *):$LN16o
.rdata:00000EDC                 db '.,:?&@=/%#()',0
.rdata:00000F2A                 align 4
.rdata:00000F2C $SG173627       db '[A-Za-z]+://[A-Za-z0-9_\-\+~.:?&@=/%#,;\{\}\(\)\[\]\|\*\!\\]+',0
.rdata:00000F2C                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+2F5Bo
.rdata:00000F6A                 align 4
.rdata:00000F6C ; char _SG173628[]
.rdata:00000F6C $SG173628       db '[A-Za-z]+://[A-Za-z0-9_\-\+~.:?&@=/%#,;\{\}\(\)\[\]\|\*\!\\]+',0
.rdata:00000F6C                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+2F60o
.rdata:00000FAA                 align 4
.rdata:00000FAC ; wchar_t _SG172607
.rdata:00000FAC $SG172607       dd offset off_20+2      ; DATA XREF: Notepad_plus::notify(SCNotification *)+8EDo
.rdata:00000FB0 ; const WCHAR _SG173637
.rdata:00000FB0 $SG173637:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+30AEo
.rdata:00000FB0                 unicode 0, <open>,0
.rdata:00000FBA                 align 4
.rdata:00000FBC ; wchar_t _SG172622
.rdata:00000FBC $SG172622:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+A43o
.rdata:00000FBC                 unicode 0, <Move to new Notepad++ Instance>,0
.rdata:00000FFA                 align 4
.rdata:00000FFC ; wchar_t _SG172623
.rdata:00000FFC $SG172623:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+A48o
.rdata:00000FFC                 unicode 0, <Document is modified, save it then try again.>,0
.rdata:00001058 ; char _SG172624[]
.rdata:00001058 $SG172624       db 'CannotMoveDoc',0    ; DATA XREF: Notepad_plus::notify(SCNotification *)+A5Co
.rdata:00001066                 align 4
.rdata:00001068 $SG172653:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+DD2o
.rdata:00001068                 unicode 0, <OVR>,0
.rdata:00001070 $SG172654:                              ; DATA XREF: Notepad_plus::notify(SCNotification *):loc_2202o
.rdata:00001070                 unicode 0, <INS>,0
.rdata:00001078 ; char _SG172670[]
.rdata:00001078 $SG172670       db 'GoToLine',0         ; DATA XREF: Notepad_plus::notify(SCNotification *)+F84o
.rdata:00001081                 align 4
.rdata:00001084 ; char _SG172681[]
.rdata:00001084 $SG172681       db 'edit-eolConversion',0
.rdata:00001084                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+1058o
.rdata:00001097                 align 4
.rdata:00001098 ; char _SG172702[]
.rdata:00001098 $SG172702       db 'edit-eolConversion',0
.rdata:00001098                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+1211o
.rdata:000010AB                 align 4
.rdata:000010AC ; wchar_t _SG172717
.rdata:000010AC $SG172717:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+1341o
.rdata:000010AC                 unicode 0, <Close Selected files>,0
.rdata:000010D6                 align 4
.rdata:000010D8 ; wchar_t _SG172719
.rdata:000010D8 $SG172719:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+138Fo
.rdata:000010D8                 unicode 0, <Close others files>,0
.rdata:000010FE                 align 10h
.rdata:00001100 ; wchar_t _SG172728
.rdata:00001100 $SG172728:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+1497o
.rdata:00001100                 unicode 0, <Close>,0
.rdata:0000110C ; wchar_t _SG172730
.rdata:0000110C $SG172730:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+14E5o
.rdata:0000110C                 unicode 0, <Close All BUT This>,0
.rdata:00001132                 align 4
.rdata:00001134 ; wchar_t _SG172732
.rdata:00001134 $SG172732:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+1533o
.rdata:00001134                 unicode 0, <Close All to the Left>,0
.rdata:00001160 ; wchar_t _SG172734
.rdata:00001160 $SG172734:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+1581o
.rdata:00001160                 unicode 0, <Close All to the Right>,0
.rdata:0000118E                 align 10h
.rdata:00001190 ; wchar_t _SG172736
.rdata:00001190 $SG172736:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+15CFo
.rdata:00001190                 unicode 0, <Save>,0
.rdata:0000119A                 align 4
.rdata:0000119C ; wchar_t _SG172738
.rdata:0000119C $SG172738:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+161Do
.rdata:0000119C                 unicode 0, <Save As...>,0
.rdata:000011B2                 align 4
.rdata:000011B4 ; wchar_t _SG172740
.rdata:000011B4 $SG172740:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+166Bo
.rdata:000011B4                 unicode 0, <Rename>,0
.rdata:000011C2                 align 4
.rdata:000011C4 ; wchar_t _SG172742
.rdata:000011C4 $SG172742:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+16B9o
.rdata:000011C4                 unicode 0, <Move to Recycle Bin>,0
.rdata:000011EC ; wchar_t _SG172744
.rdata:000011EC $SG172744:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+1707o
.rdata:000011EC                 unicode 0, <Reload>,0
.rdata:000011FA                 align 4
.rdata:000011FC ; wchar_t _SG172746
.rdata:000011FC $SG172746:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+1755o
.rdata:000011FC                 unicode 0, <Print>,0
.rdata:00001208 ; wchar_t _SG172751
.rdata:00001208 $SG172751:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+1839o
.rdata:00001208                 unicode 0, <Open Containing Folder in cmd>,0
.rdata:00001244 ; wchar_t _SG172749
.rdata:00001244 $SG172749:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+17EBo
.rdata:00001244                 unicode 0, <Open Containing Folder in Explorer>,0
.rdata:0000128A                 align 4
.rdata:0000128C ; wchar_t _SG172754
.rdata:0000128C $SG172754:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+18CFo
.rdata:0000128C                 unicode 0, <Read-Only>,0
.rdata:000012A0 ; wchar_t _SG172756
.rdata:000012A0 $SG172756:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+191Do
.rdata:000012A0                 unicode 0, <Clear Read-Only Flag>,0
.rdata:000012CA                 align 4
.rdata:000012CC ; wchar_t _SG172759
.rdata:000012CC $SG172759:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+19B3o
.rdata:000012CC                 unicode 0, <Full File Path to Clipboard>,0
.rdata:00001304 ; wchar_t _SG172761
.rdata:00001304 $SG172761:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+1A01o
.rdata:00001304                 unicode 0, <Filename to Clipboard>,0
.rdata:00001330 ; wchar_t _SG172763
.rdata:00001330 $SG172763:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+1A4Fo
.rdata:00001330                 unicode 0, <Current Dir. Path to Clipboard>,0
.rdata:0000136E                 align 10h
.rdata:00001370 ; wchar_t _SG172766
.rdata:00001370 $SG172766:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+1AE5o
.rdata:00001370                 unicode 0, <Move to Other View>,0
.rdata:00001396                 align 4
.rdata:00001398 ; wchar_t _SG172768
.rdata:00001398 $SG172768:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+1B33o
.rdata:00001398                 unicode 0, <Clone to Other View>,0
.rdata:000013C0 ; wchar_t _SG172770
.rdata:000013C0 $SG172770:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+1B81o
.rdata:000013C0                 unicode 0, <Move to New Instance>,0
.rdata:000013EA                 align 4
.rdata:000013EC ; wchar_t _SG172772
.rdata:000013EC $SG172772:                              ; DATA XREF: Notepad_plus::notify(SCNotification *)+1BCFo
.rdata:000013EC                 unicode 0, <Open in New Instance>,0
.rdata:00001416                 align 4
.rdata:00001416 _rdata          ends
.rdata:00001416
.bss:00001418 ; ===========================================================================
.bss:00001418
.bss:00001418 ; Segment type: Uninitialized
.bss:00001418 ; Segment permissions: Read/Write
.bss:00001418 _bss            segment dword public 'BSS' use32
.bss:00001418                 assume cs:_bss
.bss:00001418                 ;org 1418h
.bss:00001418                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00001418 _hWndServer     db    ? ;
.bss:00001419                 db    ? ;
.bss:0000141A                 db    ? ;
.bss:0000141B                 db    ? ;
.bss:0000141C _hook           db    ? ;
.bss:0000141D                 db    ? ;
.bss:0000141E                 db    ? ;
.bss:0000141F                 db    ? ;
.bss:00001420 __Tuple_alloc   db    ? ;
.bss:00001421 ; std::_Ignore ignore
.bss:00001421 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:00001422 _allocator_arg  db    ? ;
.bss:00001423 _piecewise_construct db    ? ;
.bss:00001423 _bss            ends
.bss:00001423
.text$mn:00001424 ; ===========================================================================
.text$mn:00001424
.text$mn:00001424 ; Segment type: Pure code
.text$mn:00001424 ; Segment permissions: Read/Execute
.text$mn:00001424 _text$mn        segment para public 'CODE' use32
.text$mn:00001424                 assume cs:_text$mn
.text$mn:00001424                 ;org 1424h
.text$mn:00001424                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001424
.text$mn:00001424 ; =============== S U B R O U T I N E =======================================
.text$mn:00001424
.text$mn:00001424 ; Attributes: bp-based frame
.text$mn:00001424
.text$mn:00001424 ; int __thiscall Notepad_plus::notify(Notepad_plus *this, struct SCNotification *)
.text$mn:00001424                 public ?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z
.text$mn:00001424 ?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z proc near
.text$mn:00001424
.text$mn:00001424 Dst             = dword ptr -11F8h
.text$mn:00001424 var_11F4        = dword ptr -11F4h
.text$mn:00001424 var_11D8        = dword ptr -11D8h
.text$mn:00001424 var_11A8        = dword ptr -11A8h
.text$mn:00001424 var_11A4        = dword ptr -11A4h
.text$mn:00001424 var_11A0        = byte ptr -11A0h
.text$mn:00001424 var_118C        = byte ptr -118Ch
.text$mn:00001424 var_117C        = byte ptr -117Ch
.text$mn:00001424 lParam          = dword ptr -116Ch
.text$mn:00001424 var_1168        = dword ptr -1168h
.text$mn:00001424 var_1164        = dword ptr -1164h
.text$mn:00001424 var_1160        = tagPOINT ptr -1160h
.text$mn:00001424 var_1158        = tagPOINT ptr -1158h
.text$mn:00001424 var_1150        = tagPOINT ptr -1150h
.text$mn:00001424 var_1148        = tagPOINT ptr -1148h
.text$mn:00001424 var_1140        = tagPOINT ptr -1140h
.text$mn:00001424 var_1138        = dword ptr -1138h
.text$mn:00001424 var_1134        = dword ptr -1134h
.text$mn:00001424 var_1130        = dword ptr -1130h
.text$mn:00001424 var_112C        = dword ptr -112Ch
.text$mn:00001424 var_1128        = dword ptr -1128h
.text$mn:00001424 var_1124        = dword ptr -1124h
.text$mn:00001424 var_1120        = dword ptr -1120h
.text$mn:00001424 var_111C        = dword ptr -111Ch
.text$mn:00001424 var_1118        = dword ptr -1118h
.text$mn:00001424 var_1114        = dword ptr -1114h
.text$mn:00001424 var_1110        = dword ptr -1110h
.text$mn:00001424 var_110C        = dword ptr -110Ch
.text$mn:00001424 var_1108        = dword ptr -1108h
.text$mn:00001424 var_1104        = dword ptr -1104h
.text$mn:00001424 var_1100        = dword ptr -1100h
.text$mn:00001424 var_10FC        = dword ptr -10FCh
.text$mn:00001424 var_10F8        = dword ptr -10F8h
.text$mn:00001424 var_10F4        = dword ptr -10F4h
.text$mn:00001424 var_10F0        = dword ptr -10F0h
.text$mn:00001424 var_10EC        = dword ptr -10ECh
.text$mn:00001424 var_10E8        = dword ptr -10E8h
.text$mn:00001424 var_10E4        = dword ptr -10E4h
.text$mn:00001424 var_10E0        = dword ptr -10E0h
.text$mn:00001424 var_10DC        = dword ptr -10DCh
.text$mn:00001424 var_10D8        = dword ptr -10D8h
.text$mn:00001424 var_10D4        = dword ptr -10D4h
.text$mn:00001424 var_10D0        = dword ptr -10D0h
.text$mn:00001424 var_10CC        = dword ptr -10CCh
.text$mn:00001424 var_10C8        = dword ptr -10C8h
.text$mn:00001424 var_10C4        = dword ptr -10C4h
.text$mn:00001424 var_10C0        = dword ptr -10C0h
.text$mn:00001424 var_10BC        = dword ptr -10BCh
.text$mn:00001424 var_10B8        = dword ptr -10B8h
.text$mn:00001424 var_10B4        = dword ptr -10B4h
.text$mn:00001424 var_10B0        = dword ptr -10B0h
.text$mn:00001424 var_10AC        = dword ptr -10ACh
.text$mn:00001424 var_10A8        = dword ptr -10A8h
.text$mn:00001424 var_10A4        = dword ptr -10A4h
.text$mn:00001424 var_10A0        = dword ptr -10A0h
.text$mn:00001424 var_109C        = dword ptr -109Ch
.text$mn:00001424 var_1098        = dword ptr -1098h
.text$mn:00001424 var_1094        = dword ptr -1094h
.text$mn:00001424 var_1090        = dword ptr -1090h
.text$mn:00001424 var_108C        = dword ptr -108Ch
.text$mn:00001424 var_1088        = dword ptr -1088h
.text$mn:00001424 var_1084        = dword ptr -1084h
.text$mn:00001424 var_1080        = dword ptr -1080h
.text$mn:00001424 var_107C        = dword ptr -107Ch
.text$mn:00001424 var_1078        = dword ptr -1078h
.text$mn:00001424 var_1074        = dword ptr -1074h
.text$mn:00001424 var_1070        = dword ptr -1070h
.text$mn:00001424 var_106C        = dword ptr -106Ch
.text$mn:00001424 var_1068        = dword ptr -1068h
.text$mn:00001424 var_1064        = dword ptr -1064h
.text$mn:00001424 var_1060        = dword ptr -1060h
.text$mn:00001424 var_105C        = dword ptr -105Ch
.text$mn:00001424 var_1058        = dword ptr -1058h
.text$mn:00001424 var_1054        = dword ptr -1054h
.text$mn:00001424 var_1050        = dword ptr -1050h
.text$mn:00001424 var_104C        = dword ptr -104Ch
.text$mn:00001424 var_1048        = dword ptr -1048h
.text$mn:00001424 var_1044        = byte ptr -1044h
.text$mn:00001424 hMenu           = dword ptr -1040h
.text$mn:00001424 var_103C        = dword ptr -103Ch
.text$mn:00001424 var_1038        = dword ptr -1038h
.text$mn:00001424 var_1034        = dword ptr -1034h
.text$mn:00001424 var_1030        = dword ptr -1030h
.text$mn:00001424 var_102C        = dword ptr -102Ch
.text$mn:00001424 var_1028        = dword ptr -1028h
.text$mn:00001424 var_1024        = dword ptr -1024h
.text$mn:00001424 var_1020        = dword ptr -1020h
.text$mn:00001424 var_101C        = dword ptr -101Ch
.text$mn:00001424 var_1018        = dword ptr -1018h
.text$mn:00001424 var_1014        = dword ptr -1014h
.text$mn:00001424 var_1010        = dword ptr -1010h
.text$mn:00001424 var_100C        = dword ptr -100Ch
.text$mn:00001424 var_1008        = dword ptr -1008h
.text$mn:00001424 var_1004        = dword ptr -1004h
.text$mn:00001424 var_1000        = dword ptr -1000h
.text$mn:00001424 var_FFC         = dword ptr -0FFCh
.text$mn:00001424 var_FF8         = dword ptr -0FF8h
.text$mn:00001424 var_FF4         = dword ptr -0FF4h
.text$mn:00001424 var_FF0         = dword ptr -0FF0h
.text$mn:00001424 var_FEC         = dword ptr -0FECh
.text$mn:00001424 var_FE8         = dword ptr -0FE8h
.text$mn:00001424 var_FE4         = dword ptr -0FE4h
.text$mn:00001424 var_FE0         = dword ptr -0FE0h
.text$mn:00001424 var_FDC         = dword ptr -0FDCh
.text$mn:00001424 var_FD8         = dword ptr -0FD8h
.text$mn:00001424 ptParentClientCoords= POINT ptr -0FD4h
.text$mn:00001424 var_FCC         = dword ptr -0FCCh
.text$mn:00001424 var_FC8         = tagPOINT ptr -0FC8h
.text$mn:00001424 var_FC0         = dword ptr -0FC0h
.text$mn:00001424 var_FBC         = dword ptr -0FBCh
.text$mn:00001424 var_FB8         = dword ptr -0FB8h
.text$mn:00001424 var_FB4         = dword ptr -0FB4h
.text$mn:00001424 var_FB0         = dword ptr -0FB0h
.text$mn:00001424 var_FAC         = dword ptr -0FACh
.text$mn:00001424 var_FA8         = dword ptr -0FA8h
.text$mn:00001424 var_FA4         = dword ptr -0FA4h
.text$mn:00001424 var_FA0         = dword ptr -0FA0h
.text$mn:00001424 var_F9C         = dword ptr -0F9Ch
.text$mn:00001424 var_F98         = dword ptr -0F98h
.text$mn:00001424 var_F94         = dword ptr -0F94h
.text$mn:00001424 var_F90         = dword ptr -0F90h
.text$mn:00001424 var_F8C         = dword ptr -0F8Ch
.text$mn:00001424 var_F88         = dword ptr -0F88h
.text$mn:00001424 var_F84         = dword ptr -0F84h
.text$mn:00001424 var_F80         = dword ptr -0F80h
.text$mn:00001424 var_F7C         = dword ptr -0F7Ch
.text$mn:00001424 var_F78         = dword ptr -0F78h
.text$mn:00001424 var_F74         = dword ptr -0F74h
.text$mn:00001424 var_F70         = dword ptr -0F70h
.text$mn:00001424 var_F6C         = dword ptr -0F6Ch
.text$mn:00001424 var_F68         = dword ptr -0F68h
.text$mn:00001424 var_F64         = dword ptr -0F64h
.text$mn:00001424 var_F60         = dword ptr -0F60h
.text$mn:00001424 var_F5C         = dword ptr -0F5Ch
.text$mn:00001424 var_F58         = dword ptr -0F58h
.text$mn:00001424 var_F54         = dword ptr -0F54h
.text$mn:00001424 var_F50         = dword ptr -0F50h
.text$mn:00001424 var_F4C         = dword ptr -0F4Ch
.text$mn:00001424 var_F48         = dword ptr -0F48h
.text$mn:00001424 var_F44         = dword ptr -0F44h
.text$mn:00001424 var_F40         = dword ptr -0F40h
.text$mn:00001424 var_F3C         = dword ptr -0F3Ch
.text$mn:00001424 var_F38         = dword ptr -0F38h
.text$mn:00001424 var_F34         = dword ptr -0F34h
.text$mn:00001424 var_F30         = dword ptr -0F30h
.text$mn:00001424 var_F2C         = dword ptr -0F2Ch
.text$mn:00001424 var_F28         = dword ptr -0F28h
.text$mn:00001424 var_F24         = dword ptr -0F24h
.text$mn:00001424 var_F20         = dword ptr -0F20h
.text$mn:00001424 var_F1C         = dword ptr -0F1Ch
.text$mn:00001424 var_F18         = dword ptr -0F18h
.text$mn:00001424 var_F14         = dword ptr -0F14h
.text$mn:00001424 var_F10         = dword ptr -0F10h
.text$mn:00001424 var_F0C         = dword ptr -0F0Ch
.text$mn:00001424 var_F08         = dword ptr -0F08h
.text$mn:00001424 var_F04         = dword ptr -0F04h
.text$mn:00001424 var_F00         = dword ptr -0F00h
.text$mn:00001424 var_EFC         = dword ptr -0EFCh
.text$mn:00001424 var_EF8         = dword ptr -0EF8h
.text$mn:00001424 var_EF4         = dword ptr -0EF4h
.text$mn:00001424 var_EF0         = dword ptr -0EF0h
.text$mn:00001424 var_EEC         = dword ptr -0EECh
.text$mn:00001424 Point           = POINT ptr -0EE8h
.text$mn:00001424 var_EE0         = dword ptr -0EE0h
.text$mn:00001424 var_EDC         = dword ptr -0EDCh
.text$mn:00001424 var_ED8         = dword ptr -0ED8h
.text$mn:00001424 var_ED4         = dword ptr -0ED4h
.text$mn:00001424 var_ED0         = dword ptr -0ED0h
.text$mn:00001424 var_ECC         = dword ptr -0ECCh
.text$mn:00001424 var_EC8         = dword ptr -0EC8h
.text$mn:00001424 var_EC4         = dword ptr -0EC4h
.text$mn:00001424 var_EC0         = dword ptr -0EC0h
.text$mn:00001424 var_EBC         = dword ptr -0EBCh
.text$mn:00001424 Str             = dword ptr -0EB8h
.text$mn:00001424 var_EB4         = dword ptr -0EB4h
.text$mn:00001424 var_EB0         = dword ptr -0EB0h
.text$mn:00001424 var_EAC         = dword ptr -0EACh
.text$mn:00001424 var_EA8         = dword ptr -0EA8h
.text$mn:00001424 var_EA4         = dword ptr -0EA4h
.text$mn:00001424 hWnd            = dword ptr -0EA0h
.text$mn:00001424 var_E9C         = dword ptr -0E9Ch
.text$mn:00001424 var_E98         = byte ptr -0E98h
.text$mn:00001424 var_E88         = dword ptr -0E88h
.text$mn:00001424 var_E84         = byte ptr -0E84h
.text$mn:00001424 var_E83         = byte ptr -0E83h
.text$mn:00001424 var_E82         = byte ptr -0E82h
.text$mn:00001424 var_E81         = byte ptr -0E81h
.text$mn:00001424 var_E80         = byte ptr -0E80h
.text$mn:00001424 var_E7F         = byte ptr -0E7Fh
.text$mn:00001424 var_E7E         = byte ptr -0E7Eh
.text$mn:00001424 var_E7D         = byte ptr -0E7Dh
.text$mn:00001424 var_E7C         = byte ptr -0E7Ch
.text$mn:00001424 var_E7B         = byte ptr -0E7Bh
.text$mn:00001424 var_E7A         = byte ptr -0E7Ah
.text$mn:00001424 var_E79         = byte ptr -0E79h
.text$mn:00001424 var_E78         = dword ptr -0E78h
.text$mn:00001424 var_E74         = dword ptr -0E74h
.text$mn:00001424 var_E70         = dword ptr -0E70h
.text$mn:00001424 var_E6C         = dword ptr -0E6Ch
.text$mn:00001424 var_E68         = dword ptr -0E68h
.text$mn:00001424 var_E64         = dword ptr -0E64h
.text$mn:00001424 var_E5F         = byte ptr -0E5Fh
.text$mn:00001424 var_E5E         = byte ptr -0E5Eh
.text$mn:00001424 var_E5D         = byte ptr -0E5Dh
.text$mn:00001424 var_E5C         = byte ptr -0E5Ch
.text$mn:00001424 var_E5B         = byte ptr -0E5Bh
.text$mn:00001424 var_E5A         = byte ptr -0E5Ah
.text$mn:00001424 var_E59         = byte ptr -0E59h
.text$mn:00001424 var_E58         = dword ptr -0E58h
.text$mn:00001424 var_E52         = byte ptr -0E52h
.text$mn:00001424 var_E51         = byte ptr -0E51h
.text$mn:00001424 var_E50         = dword ptr -0E50h
.text$mn:00001424 var_E4C         = dword ptr -0E4Ch
.text$mn:00001424 var_E45         = byte ptr -0E45h
.text$mn:00001424 var_E44         = dword ptr -0E44h
.text$mn:00001424 var_E40         = byte ptr -0E40h
.text$mn:00001424 var_E04         = byte ptr -0E04h
.text$mn:00001424 var_DC8         = byte ptr -0DC8h
.text$mn:00001424 var_D8C         = byte ptr -0D8Ch
.text$mn:00001424 var_D50         = byte ptr -0D50h
.text$mn:00001424 var_D14         = byte ptr -0D14h
.text$mn:00001424 var_CD8         = byte ptr -0CD8h
.text$mn:00001424 var_C9C         = byte ptr -0C9Ch
.text$mn:00001424 var_C60         = byte ptr -0C60h
.text$mn:00001424 var_C24         = byte ptr -0C24h
.text$mn:00001424 var_BE8         = byte ptr -0BE8h
.text$mn:00001424 var_BAC         = byte ptr -0BACh
.text$mn:00001424 var_B70         = byte ptr -0B70h
.text$mn:00001424 var_B34         = byte ptr -0B34h
.text$mn:00001424 var_AF8         = byte ptr -0AF8h
.text$mn:00001424 var_ABC         = byte ptr -0ABCh
.text$mn:00001424 var_A80         = byte ptr -0A80h
.text$mn:00001424 var_A44         = byte ptr -0A44h
.text$mn:00001424 var_A08         = byte ptr -0A08h
.text$mn:00001424 var_9CC         = byte ptr -9CCh
.text$mn:00001424 var_990         = byte ptr -990h
.text$mn:00001424 var_954         = byte ptr -954h
.text$mn:00001424 var_918         = byte ptr -918h
.text$mn:00001424 var_8DC         = byte ptr -8DCh
.text$mn:00001424 var_8A0         = byte ptr -8A0h
.text$mn:00001424 var_864         = byte ptr -864h
.text$mn:00001424 var_828         = byte ptr -828h
.text$mn:00001424 var_7EC         = byte ptr -7ECh
.text$mn:00001424 var_7B0         = byte ptr -7B0h
.text$mn:00001424 var_774         = byte ptr -774h
.text$mn:00001424 var_748         = byte ptr -748h
.text$mn:00001424 var_72C         = byte ptr -72Ch
.text$mn:00001424 var_710         = byte ptr -710h
.text$mn:00001424 Rect            = tagRECT ptr -6F4h
.text$mn:00001424 var_6E4         = byte ptr -6E4h
.text$mn:00001424 var_6C8         = byte ptr -6C8h
.text$mn:00001424 ClassName       = word ptr -6ACh
.text$mn:00001424 Src             = word ptr -4A4h
.text$mn:00001424 var_94          = word ptr -94h
.text$mn:00001424 var_6C          = dword ptr -6Ch
.text$mn:00001424 var_68          = dword ptr -68h
.text$mn:00001424 var_64          = dword ptr -64h
.text$mn:00001424 var_60          = dword ptr -60h
.text$mn:00001424 var_5C          = dword ptr -5Ch
.text$mn:00001424 var_58          = dword ptr -58h
.text$mn:00001424 var_54          = word ptr -54h
.text$mn:00001424 var_2E          = dword ptr -2Eh
.text$mn:00001424 var_2A          = dword ptr -2Ah
.text$mn:00001424 var_26          = dword ptr -26h
.text$mn:00001424 var_22          = dword ptr -22h
.text$mn:00001424 var_1E          = dword ptr -1Eh
.text$mn:00001424 var_1A          = dword ptr -1Ah
.text$mn:00001424 var_16          = word ptr -16h
.text$mn:00001424 var_14          = dword ptr -14h
.text$mn:00001424 var_10          = dword ptr -10h
.text$mn:00001424 var_C           = dword ptr -0Ch
.text$mn:00001424 var_4           = dword ptr -4
.text$mn:00001424 arg_0           = dword ptr  8
.text$mn:00001424
.text$mn:00001424 ; FUNCTION CHUNK AT .text$mn:000040EA SIZE 00000009 BYTES
.text$mn:00001424 ; FUNCTION CHUNK AT .text$mn:000040FA SIZE 00000005 BYTES
.text$mn:00001424 ; FUNCTION CHUNK AT .text$mn:00004104 SIZE 000006AF BYTES
.text$mn:00001424
.text$mn:00001424                 push    ebp
.text$mn:00001425                 mov     ebp, esp
.text$mn:00001427                 push    0FFFFFFFFh
.text$mn:00001429                 push    offset __ehhandler$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z
.text$mn:0000142E                 mov     eax, large fs:0
.text$mn:00001434                 push    eax
.text$mn:00001435                 push    ecx
.text$mn:00001436                 mov     eax, 11E8h
.text$mn:0000143B                 call    __chkstk
.text$mn:00001440                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001445                 xor     eax, ebp
.text$mn:00001447                 mov     [ebp+var_14], eax
.text$mn:0000144A                 push    ebx
.text$mn:0000144B                 push    esi
.text$mn:0000144C                 push    edi
.text$mn:0000144D                 push    eax
.text$mn:0000144E                 lea     eax, [ebp+var_C]
.text$mn:00001451                 mov     large fs:0, eax
.text$mn:00001457                 mov     [ebp+var_10], esp
.text$mn:0000145A                 mov     [ebp+var_E44], ecx
.text$mn:00001460                 mov     ecx, [ebp+var_E44]
.text$mn:00001466                 add     ecx, 4C0h       ; this
.text$mn:0000146C                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001471                 mov     ecx, [ebp+arg_0]
.text$mn:00001474                 cmp     eax, [ecx]
.text$mn:00001476                 jz      short loc_149C
.text$mn:00001478                 mov     ecx, [ebp+var_E44]
.text$mn:0000147E                 add     ecx, 35Ch       ; this
.text$mn:00001484                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001489                 mov     edx, [ebp+arg_0]
.text$mn:0000148C                 cmp     eax, [edx]
.text$mn:0000148E                 jz      short loc_149C
.text$mn:00001490                 mov     [ebp+var_FB4], 0
.text$mn:0000149A                 jmp     short loc_14A6
.text$mn:0000149C ; ---------------------------------------------------------------------------
.text$mn:0000149C
.text$mn:0000149C loc_149C:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+52j
.text$mn:0000149C                                         ; Notepad_plus::notify(SCNotification *)+6Aj
.text$mn:0000149C                 mov     [ebp+var_FB4], 1
.text$mn:000014A6
.text$mn:000014A6 loc_14A6:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+76j
.text$mn:000014A6                 mov     al, byte ptr [ebp+var_FB4]
.text$mn:000014AC                 mov     [ebp+var_E45], al
.text$mn:000014B2                 movzx   ecx, [ebp+var_E45]
.text$mn:000014B9                 test    ecx, ecx
.text$mn:000014BB                 jnz     short loc_14F9
.text$mn:000014BD                 mov     ecx, [ebp+var_E44]
.text$mn:000014C3                 add     ecx, 464h       ; this
.text$mn:000014C9                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000014CE                 mov     edx, [ebp+arg_0]
.text$mn:000014D1                 cmp     eax, [edx]
.text$mn:000014D3                 jz      short loc_14ED
.text$mn:000014D5                 mov     ecx, [ebp+var_E44]
.text$mn:000014DB                 add     ecx, 3DCh       ; this
.text$mn:000014E1                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000014E6                 mov     ecx, [ebp+arg_0]
.text$mn:000014E9                 cmp     eax, [ecx]
.text$mn:000014EB                 jnz     short loc_14F9
.text$mn:000014ED
.text$mn:000014ED loc_14ED:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+AFj
.text$mn:000014ED                 mov     [ebp+var_F20], 1
.text$mn:000014F7                 jmp     short loc_1503
.text$mn:000014F9 ; ---------------------------------------------------------------------------
.text$mn:000014F9
.text$mn:000014F9 loc_14F9:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+97j
.text$mn:000014F9                                         ; Notepad_plus::notify(SCNotification *)+C7j
.text$mn:000014F9                 mov     [ebp+var_F20], 0
.text$mn:00001503
.text$mn:00001503 loc_1503:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+D3j
.text$mn:00001503                 mov     dl, byte ptr [ebp+var_F20]
.text$mn:00001509                 mov     [ebp+var_E83], dl
.text$mn:0000150F                 movzx   eax, [ebp+var_E45]
.text$mn:00001516                 test    eax, eax
.text$mn:00001518                 jz      short loc_152E
.text$mn:0000151A                 mov     ecx, [ebp+var_E44]
.text$mn:00001520                 add     ecx, 4C0h
.text$mn:00001526                 mov     [ebp+var_F74], ecx
.text$mn:0000152C                 jmp     short loc_1540
.text$mn:0000152E ; ---------------------------------------------------------------------------
.text$mn:0000152E
.text$mn:0000152E loc_152E:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+F4j
.text$mn:0000152E                 mov     edx, [ebp+var_E44]
.text$mn:00001534                 add     edx, 464h
.text$mn:0000153A                 mov     [ebp+var_F74], edx
.text$mn:00001540
.text$mn:00001540 loc_1540:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+108j
.text$mn:00001540                 mov     eax, [ebp+var_F74]
.text$mn:00001546                 mov     [ebp+var_E4C], eax
.text$mn:0000154C                 movzx   ecx, [ebp+var_E45]
.text$mn:00001553                 test    ecx, ecx
.text$mn:00001555                 jz      short loc_156B
.text$mn:00001557                 mov     edx, [ebp+var_E44]
.text$mn:0000155D                 add     edx, 35Ch
.text$mn:00001563                 mov     [ebp+var_F28], edx
.text$mn:00001569                 jmp     short loc_157C
.text$mn:0000156B ; ---------------------------------------------------------------------------
.text$mn:0000156B
.text$mn:0000156B loc_156B:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+131j
.text$mn:0000156B                 mov     eax, [ebp+var_E44]
.text$mn:00001571                 add     eax, 3DCh
.text$mn:00001576                 mov     [ebp+var_F28], eax
.text$mn:0000157C
.text$mn:0000157C loc_157C:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+145j
.text$mn:0000157C                 mov     ecx, [ebp+var_F28]
.text$mn:00001582                 mov     [ebp+var_F54], ecx
.text$mn:00001588                 mov     edx, [ebp+arg_0]
.text$mn:0000158B                 mov     [ebp+var_1020], edx
.text$mn:00001591                 mov     eax, [ebp+arg_0]
.text$mn:00001594                 mov     ecx, [eax+8]
.text$mn:00001597                 mov     [ebp+var_E50], ecx
.text$mn:0000159D                 cmp     [ebp+var_E50], 7E5h
.text$mn:000015A7                 ja      short loc_15EC
.text$mn:000015A9                 cmp     [ebp+var_E50], 7E5h
.text$mn:000015B3                 jz      loc_4609
.text$mn:000015B9                 mov     edx, [ebp+var_E50]
.text$mn:000015BF                 sub     edx, 7D1h
.text$mn:000015C5                 mov     [ebp+var_E50], edx
.text$mn:000015CB                 cmp     [ebp+var_E50], 13h ; switch 20 cases
.text$mn:000015D2                 ja      $LN190          ; jumptable 000015E5 default case
.text$mn:000015D8                 mov     eax, [ebp+var_E50]
.text$mn:000015DE                 movzx   ecx, ds:$LN303[eax]
.text$mn:000015E5                 jmp     ds:$LN305[ecx*4] ; switch jump
.text$mn:000015EC ; ---------------------------------------------------------------------------
.text$mn:000015EC
.text$mn:000015EC loc_15EC:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+183j
.text$mn:000015EC                 cmp     [ebp+var_E50], 0FFFFFDD9h
.text$mn:000015F6                 ja      loc_1682
.text$mn:000015FC                 cmp     [ebp+var_E50], 0FFFFFDD9h
.text$mn:00001606                 jz      loc_206A
.text$mn:0000160C                 cmp     [ebp+var_E50], 0FFFFFCC1h
.text$mn:00001616                 ja      short loc_164D
.text$mn:00001618                 cmp     [ebp+var_E50], 0FFFFFCC1h
.text$mn:00001622                 jz      loc_465C
.text$mn:00001628                 cmp     [ebp+var_E50], 821h
.text$mn:00001632                 jz      loc_341A
.text$mn:00001638                 cmp     [ebp+var_E50], 0FFFFFCB7h
.text$mn:00001642                 jz      loc_467C
.text$mn:00001648                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:0000164D ; ---------------------------------------------------------------------------
.text$mn:0000164D
.text$mn:0000164D loc_164D:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1F2j
.text$mn:0000164D                 cmp     [ebp+var_E50], 0FFFFFDCEh
.text$mn:00001657                 jz      loc_1FB4
.text$mn:0000165D                 cmp     [ebp+var_E50], 0FFFFFDCEh
.text$mn:00001667                 jbe     $LN190          ; jumptable 000015E5 default case
.text$mn:0000166D                 cmp     [ebp+var_E50], 0FFFFFDD0h
.text$mn:00001677                 jbe     loc_19A7
.text$mn:0000167D                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:00001682 ; ---------------------------------------------------------------------------
.text$mn:00001682
.text$mn:00001682 loc_1682:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1D2j
.text$mn:00001682                 cmp     [ebp+var_E50], 0FFFFFFFDh
.text$mn:00001689                 ja      short loc_16BA
.text$mn:0000168B                 cmp     [ebp+var_E50], 0FFFFFFFDh
.text$mn:00001692                 jz      loc_22FA
.text$mn:00001698                 cmp     [ebp+var_E50], 0FFFFFDEEh
.text$mn:000016A2                 jz      loc_3D5B
.text$mn:000016A8                 cmp     [ebp+var_E50], 0FFFFFFFBh
.text$mn:000016AF                 jz      loc_2529
.text$mn:000016B5                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:000016BA ; ---------------------------------------------------------------------------
.text$mn:000016BA
.text$mn:000016BA loc_16BA:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+265j
.text$mn:000016BA                 cmp     [ebp+var_E50], 0FFFFFFFEh
.text$mn:000016C1                 jz      loc_2123
.text$mn:000016C7                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:000016CC ; ---------------------------------------------------------------------------
.text$mn:000016CC
.text$mn:000016CC $LN189:                                 ; CODE XREF: Notepad_plus::notify(SCNotification *)+1C1j
.text$mn:000016CC                                         ; DATA XREF: .text$mn:$LN305o
.text$mn:000016CC                 mov     edx, [ebp+arg_0] ; jumptable 000015E5 case 7
.text$mn:000016CF                 mov     eax, [edx+18h]
.text$mn:000016D2                 and     eax, 3
.text$mn:000016D5                 jz      short loc_172A
.text$mn:000016D7                 mov     ecx, [ebp+arg_0]
.text$mn:000016DA                 mov     edx, [ecx+20h]
.text$mn:000016DD                 push    edx             ; int
.text$mn:000016DE                 mov     eax, [ebp+arg_0]
.text$mn:000016E1                 mov     ecx, [eax+0Ch]
.text$mn:000016E4                 push    ecx             ; int
.text$mn:000016E5                 mov     edx, [ebp+arg_0]
.text$mn:000016E8                 mov     eax, [edx+18h]
.text$mn:000016EB                 and     eax, 1
.text$mn:000016EE                 push    eax             ; bool
.text$mn:000016EF                 mov     ecx, [ebp+var_E44]
.text$mn:000016F5                 mov     ecx, [ecx+5D4h] ; this
.text$mn:000016FB                 call    ?updateBeginEndSelectPosition@ScintillaEditView@@QAEX_NHH@Z ; ScintillaEditView::updateBeginEndSelectPosition(bool,int,int)
.text$mn:00001700                 mov     ds:?prevWasEdit@?4??notify@Notepad_plus@@AAEHPAUSCNotification@@@Z@4_NA, 1 ; bool `Notepad_plus::notify(SCNotification *)'::`5'::prevWasEdit
.text$mn:00001707                 mov     edx, [ebp+var_E44]
.text$mn:0000170D                 mov     byte ptr [edx+54B68h], 1
.text$mn:00001714                 push    1               ; bErase
.text$mn:00001716                 push    0               ; lpRect
.text$mn:00001718                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:0000171E                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001723                 push    eax             ; hWnd
.text$mn:00001724                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:0000172A
.text$mn:0000172A loc_172A:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2B1j
.text$mn:0000172A                 mov     eax, [ebp+arg_0]
.text$mn:0000172D                 mov     ecx, [eax+18h]
.text$mn:00001730                 and     ecx, 63h
.text$mn:00001733                 jz      short loc_174F
.text$mn:00001735                 push    1               ; bool
.text$mn:00001737                 mov     edx, [ebp+var_E44]
.text$mn:0000173D                 mov     ecx, [edx+5D4h] ; this
.text$mn:00001743                 call    ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBuffer(void)
.text$mn:00001748                 mov     ecx, eax        ; this
.text$mn:0000174A                 call    ?setModifiedStatus@Buffer@@QAEX_N@Z ; Buffer::setModifiedStatus(bool)
.text$mn:0000174F
.text$mn:0000174F loc_174F:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+30Fj
.text$mn:0000174F                 mov     eax, [ebp+arg_0]
.text$mn:00001752                 mov     ecx, [eax+18h]
.text$mn:00001755                 and     ecx, 8
.text$mn:00001758                 jz      short loc_178E
.text$mn:0000175A                 movzx   edx, ds:?prevWasEdit@?4??notify@Notepad_plus@@AAEHPAUSCNotification@@@Z@4_NA ; bool `Notepad_plus::notify(SCNotification *)'::`5'::prevWasEdit
.text$mn:00001761                 test    edx, edx
.text$mn:00001763                 jz      short loc_178C
.text$mn:00001765                 mov     eax, [ebp+arg_0]
.text$mn:00001768                 mov     ecx, [eax+3Ch]
.text$mn:0000176B                 push    ecx             ; int
.text$mn:0000176C                 mov     edx, [ebp+arg_0]
.text$mn:0000176F                 mov     eax, [edx+38h]
.text$mn:00001772                 push    eax             ; int
.text$mn:00001773                 mov     ecx, [ebp+arg_0]
.text$mn:00001776                 mov     edx, [ecx+34h]
.text$mn:00001779                 push    edx             ; int
.text$mn:0000177A                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00001780                 call    ?foldChanged@ScintillaEditView@@QAEXHHH@Z ; ScintillaEditView::foldChanged(int,int,int)
.text$mn:00001785                 mov     ds:?prevWasEdit@?4??notify@Notepad_plus@@AAEHPAUSCNotification@@@Z@4_NA, 0 ; bool `Notepad_plus::notify(SCNotification *)'::`5'::prevWasEdit
.text$mn:0000178C
.text$mn:0000178C loc_178C:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+33Fj
.text$mn:0000178C                 jmp     short loc_17A0
.text$mn:0000178E ; ---------------------------------------------------------------------------
.text$mn:0000178E
.text$mn:0000178E loc_178E:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+334j
.text$mn:0000178E                 mov     eax, [ebp+arg_0]
.text$mn:00001791                 mov     ecx, [eax+18h]
.text$mn:00001794                 and     ecx, 3
.text$mn:00001797                 jnz     short loc_17A0
.text$mn:00001799                 mov     ds:?prevWasEdit@?4??notify@Notepad_plus@@AAEHPAUSCNotification@@@Z@4_NA, 0 ; bool `Notepad_plus::notify(SCNotification *)'::`5'::prevWasEdit
.text$mn:000017A0
.text$mn:000017A0 loc_17A0:                               ; CODE XREF: Notepad_plus::notify(SCNotification *):loc_178Cj
.text$mn:000017A0                                         ; Notepad_plus::notify(SCNotification *)+373j
.text$mn:000017A0                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:000017A5 ; ---------------------------------------------------------------------------
.text$mn:000017A5
.text$mn:000017A5 $LN182:                                 ; CODE XREF: Notepad_plus::notify(SCNotification *)+1C1j
.text$mn:000017A5                                         ; DATA XREF: .text$mn:$LN305o
.text$mn:000017A5                 mov     [ebp+var_EAC], 0 ; jumptable 000015E5 cases 1,2
.text$mn:000017AF                 movzx   edx, [ebp+var_E45]
.text$mn:000017B6                 test    edx, edx
.text$mn:000017B8                 jz      short loc_17D6
.text$mn:000017BA                 mov     ecx, [ebp+var_E44]
.text$mn:000017C0                 add     ecx, 4C0h       ; this
.text$mn:000017C6                 call    ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBuffer(void)
.text$mn:000017CB                 mov     [ebp+var_EAC], eax
.text$mn:000017D1                 jmp     loc_18C3
.text$mn:000017D6 ; ---------------------------------------------------------------------------
.text$mn:000017D6
.text$mn:000017D6 loc_17D6:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+394j
.text$mn:000017D6                 movzx   eax, [ebp+var_E83]
.text$mn:000017DD                 test    eax, eax
.text$mn:000017DF                 jz      short loc_17FD
.text$mn:000017E1                 mov     ecx, [ebp+var_E44]
.text$mn:000017E7                 add     ecx, 464h       ; this
.text$mn:000017ED                 call    ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBuffer(void)
.text$mn:000017F2                 mov     [ebp+var_EAC], eax
.text$mn:000017F8                 jmp     loc_18C3
.text$mn:000017FD ; ---------------------------------------------------------------------------
.text$mn:000017FD
.text$mn:000017FD loc_17FD:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+3BBj
.text$mn:000017FD                 mov     [ebp+var_EC8], 0
.text$mn:00001807                 mov     ecx, [ebp+var_E44]
.text$mn:0000180D                 add     ecx, 51Ch       ; this
.text$mn:00001813                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001818                 mov     ecx, [ebp+arg_0]
.text$mn:0000181B                 cmp     [ecx], eax
.text$mn:0000181D                 jnz     short loc_184E
.text$mn:0000181F                 push    0               ; __int32
.text$mn:00001821                 push    0               ; unsigned int
.text$mn:00001823                 push    935h            ; unsigned int
.text$mn:00001828                 mov     ecx, [ebp+var_E44]
.text$mn:0000182E                 add     ecx, 51Ch       ; this
.text$mn:00001834                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001839                 push    eax             ; __int32
.text$mn:0000183A                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:0000183F                 mov     ecx, eax        ; this
.text$mn:00001841                 call    ?getBufferFromDocument@FileManager@@QAEPAVBuffer@@J@Z ; FileManager::getBufferFromDocument(long)
.text$mn:00001846                 mov     [ebp+var_EC8], eax
.text$mn:0000184C                 jmp     short loc_189A
.text$mn:0000184E ; ---------------------------------------------------------------------------
.text$mn:0000184E
.text$mn:0000184E loc_184E:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+3F9j
.text$mn:0000184E                 mov     ecx, [ebp+var_E44]
.text$mn:00001854                 add     ecx, 578h       ; this
.text$mn:0000185A                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:0000185F                 mov     edx, [ebp+arg_0]
.text$mn:00001862                 cmp     [edx], eax
.text$mn:00001864                 jnz     short loc_1895
.text$mn:00001866                 push    0               ; __int32
.text$mn:00001868                 push    0               ; unsigned int
.text$mn:0000186A                 push    935h            ; unsigned int
.text$mn:0000186F                 mov     ecx, [ebp+var_E44]
.text$mn:00001875                 add     ecx, 578h       ; this
.text$mn:0000187B                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001880                 push    eax             ; __int32
.text$mn:00001881                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00001886                 mov     ecx, eax        ; this
.text$mn:00001888                 call    ?getBufferFromDocument@FileManager@@QAEPAVBuffer@@J@Z ; FileManager::getBufferFromDocument(long)
.text$mn:0000188D                 mov     [ebp+var_EC8], eax
.text$mn:00001893                 jmp     short loc_189A
.text$mn:00001895 ; ---------------------------------------------------------------------------
.text$mn:00001895
.text$mn:00001895 loc_1895:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+440j
.text$mn:00001895                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:0000189A ; ---------------------------------------------------------------------------
.text$mn:0000189A
.text$mn:0000189A loc_189A:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+428j
.text$mn:0000189A                                         ; Notepad_plus::notify(SCNotification *)+46Fj
.text$mn:0000189A                 cmp     [ebp+var_EC8], 0
.text$mn:000018A1                 jz      short loc_18BE
.text$mn:000018A3                 mov     eax, [ebp+var_EC8]
.text$mn:000018A9                 push    eax             ; struct Buffer *
.text$mn:000018AA                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:000018AF                 mov     ecx, eax        ; this
.text$mn:000018B1                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:000018B6                 mov     [ebp+var_EAC], eax
.text$mn:000018BC                 jmp     short loc_18C3
.text$mn:000018BE ; ---------------------------------------------------------------------------
.text$mn:000018BE
.text$mn:000018BE loc_18BE:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+47Dj
.text$mn:000018BE                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:000018C3 ; ---------------------------------------------------------------------------
.text$mn:000018C3
.text$mn:000018C3 loc_18C3:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+3ADj
.text$mn:000018C3                                         ; Notepad_plus::notify(SCNotification *)+3D4j ...
.text$mn:000018C3                 mov     ecx, [ebp+arg_0]
.text$mn:000018C6                 cmp     dword ptr [ecx+8], 7D3h
.text$mn:000018CD                 jnz     short loc_18DB
.text$mn:000018CF                 mov     [ebp+var_F9C], 1
.text$mn:000018D9                 jmp     short loc_18E5
.text$mn:000018DB ; ---------------------------------------------------------------------------
.text$mn:000018DB
.text$mn:000018DB loc_18DB:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+4A9j
.text$mn:000018DB                 mov     [ebp+var_F9C], 0
.text$mn:000018E5
.text$mn:000018E5 loc_18E5:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+4B5j
.text$mn:000018E5                 mov     dl, byte ptr [ebp+var_F9C]
.text$mn:000018EB                 mov     [ebp+var_E51], dl
.text$mn:000018F1                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000018F6                 mov     ecx, eax        ; this
.text$mn:000018F8                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:000018FD                 mov     ecx, eax        ; this
.text$mn:000018FF                 call    ?isSnapshotMode@NppGUI@@QBE_NXZ ; NppGUI::isSnapshotMode(void)
.text$mn:00001904                 mov     [ebp+var_E84], al
.text$mn:0000190A                 movzx   eax, [ebp+var_E84]
.text$mn:00001911                 test    eax, eax
.text$mn:00001913                 jz      short loc_1985
.text$mn:00001915                 movzx   ecx, [ebp+var_E51]
.text$mn:0000191C                 test    ecx, ecx
.text$mn:0000191E                 jnz     short loc_1985
.text$mn:00001920                 push    0               ; __int32
.text$mn:00001922                 push    0               ; unsigned int
.text$mn:00001924                 push    87Eh            ; unsigned int
.text$mn:00001929                 mov     edx, [ebp+var_E44]
.text$mn:0000192F                 mov     ecx, [edx+5D4h] ; this
.text$mn:00001935                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000193A                 cmp     eax, 1
.text$mn:0000193D                 jnz     short loc_194B
.text$mn:0000193F                 mov     [ebp+var_F34], 1
.text$mn:00001949                 jmp     short loc_1955
.text$mn:0000194B ; ---------------------------------------------------------------------------
.text$mn:0000194B
.text$mn:0000194B loc_194B:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+519j
.text$mn:0000194B                 mov     [ebp+var_F34], 0
.text$mn:00001955
.text$mn:00001955 loc_1955:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+525j
.text$mn:00001955                 mov     al, byte ptr [ebp+var_F34]
.text$mn:0000195B                 mov     [ebp+var_E7D], al
.text$mn:00001961                 movzx   ecx, [ebp+var_E7D]
.text$mn:00001968                 test    ecx, ecx
.text$mn:0000196A                 jnz     short loc_1985
.text$mn:0000196C                 mov     ecx, [ebp+var_EAC] ; this
.text$mn:00001972                 call    ?isLoadedDirty@Buffer@@QBE_NXZ ; Buffer::isLoadedDirty(void)
.text$mn:00001977                 movzx   edx, al
.text$mn:0000197A                 test    edx, edx
.text$mn:0000197C                 jz      short loc_1985
.text$mn:0000197E                 mov     [ebp+var_E51], 1
.text$mn:00001985
.text$mn:00001985 loc_1985:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+4EFj
.text$mn:00001985                                         ; Notepad_plus::notify(SCNotification *)+4FAj ...
.text$mn:00001985                 movzx   eax, [ebp+var_E51]
.text$mn:0000198C                 push    eax             ; bool
.text$mn:0000198D                 mov     ecx, [ebp+var_EAC] ; this
.text$mn:00001993                 call    ?setDirty@Buffer@@QAEX_N@Z ; Buffer::setDirty(bool)
.text$mn:00001998                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:0000199D ; ---------------------------------------------------------------------------
.text$mn:0000199D                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:000019A2 ; ---------------------------------------------------------------------------
.text$mn:000019A2                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:000019A7 ; ---------------------------------------------------------------------------
.text$mn:000019A7
.text$mn:000019A7 loc_19A7:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+253j
.text$mn:000019A7                 mov     ecx, [ebp+arg_0]
.text$mn:000019AA                 mov     edx, [ecx+4]
.text$mn:000019AD                 mov     [ebp+var_FA4], edx
.text$mn:000019B3                 push    0A2h ; 'ó'      ; nVirtKey
.text$mn:000019B8                 call    dword ptr ds:__imp__GetKeyState@4 ; GetKeyState(x)
.text$mn:000019BE                 cwde
.text$mn:000019BF                 and     eax, 80000000h
.text$mn:000019C4                 jz      short loc_19D2
.text$mn:000019C6                 mov     [ebp+var_F7C], 1
.text$mn:000019D0                 jmp     short loc_19DC
.text$mn:000019D2 ; ---------------------------------------------------------------------------
.text$mn:000019D2
.text$mn:000019D2 loc_19D2:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+5A0j
.text$mn:000019D2                 mov     [ebp+var_F7C], 0
.text$mn:000019DC
.text$mn:000019DC loc_19DC:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+5ACj
.text$mn:000019DC                 mov     cl, byte ptr [ebp+var_F7C]
.text$mn:000019E2                 mov     [ebp+var_E52], cl
.text$mn:000019E8                 mov     edx, [ebp+arg_0]
.text$mn:000019EB                 cmp     dword ptr [edx+8], 0FFFFFDCFh
.text$mn:000019F2                 jnz     loc_1F9F
.text$mn:000019F8                 lea     eax, [ebp+Point]
.text$mn:000019FE                 push    eax
.text$mn:000019FF                 mov     ecx, [ebp+var_FA4] ; this
.text$mn:00001A05                 call    ?getDraggingPoint@TabBarPlus@@QBE?AUtagPOINT@@XZ ; TabBarPlus::getDraggingPoint(void)
.text$mn:00001A0A                 mov     ecx, [ebp+Point.y]
.text$mn:00001A10                 push    ecx
.text$mn:00001A11                 mov     edx, [ebp+Point.x]
.text$mn:00001A17                 push    edx             ; Point
.text$mn:00001A18                 call    dword ptr ds:__imp__WindowFromPoint@8 ; WindowFromPoint(x,x)
.text$mn:00001A1E                 mov     [ebp+hWnd], eax
.text$mn:00001A24                 mov     eax, [ebp+var_E44]
.text$mn:00001A2A                 mov     ecx, [eax+5D4h] ; this
.text$mn:00001A30                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001A35                 cmp     [ebp+hWnd], eax
.text$mn:00001A3B                 jnz     loc_1BE1
.text$mn:00001A41                 mov     ecx, [ebp+var_E44]
.text$mn:00001A47                 add     ecx, 680h       ; this
.text$mn:00001A4D                 call    ?isCreated@ContextMenu@@QBE_NXZ ; ContextMenu::isCreated(void)
.text$mn:00001A52                 movzx   ecx, al
.text$mn:00001A55                 test    ecx, ecx
.text$mn:00001A57                 jnz     loc_1BC4
.text$mn:00001A5D                 mov     ecx, 9
.text$mn:00001A62                 mov     esi, offset $SG172588 ; "Move to other view"
.text$mn:00001A67                 lea     edi, [ebp+var_54]
.text$mn:00001A6A                 rep movsd
.text$mn:00001A6C                 movsw
.text$mn:00001A6E                 xor     edx, edx
.text$mn:00001A70                 mov     [ebp+var_2E], edx
.text$mn:00001A73                 mov     [ebp+var_2A], edx
.text$mn:00001A76                 mov     [ebp+var_26], edx
.text$mn:00001A79                 mov     [ebp+var_22], edx
.text$mn:00001A7C                 mov     [ebp+var_1E], edx
.text$mn:00001A7F                 mov     [ebp+var_1A], edx
.text$mn:00001A82                 mov     [ebp+var_16], dx
.text$mn:00001A86                 mov     ecx, 0Ah
.text$mn:00001A8B                 mov     esi, offset $SG172590 ; "Clone to other View"
.text$mn:00001A90                 lea     edi, [ebp+var_94]
.text$mn:00001A96                 rep movsd
.text$mn:00001A98                 xor     eax, eax
.text$mn:00001A9A                 mov     [ebp+var_6C], eax
.text$mn:00001A9D                 mov     [ebp+var_68], eax
.text$mn:00001AA0                 mov     [ebp+var_64], eax
.text$mn:00001AA3                 mov     [ebp+var_60], eax
.text$mn:00001AA6                 mov     [ebp+var_5C], eax
.text$mn:00001AA9                 mov     [ebp+var_58], eax
.text$mn:00001AAC                 lea     ecx, [ebp+var_117C]
.text$mn:00001AB2                 call    ??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)
.text$mn:00001AB7                 mov     [ebp+var_4], 0
.text$mn:00001ABE                 push    0               ; wchar_t *
.text$mn:00001AC0                 lea     ecx, [ebp+var_54]
.text$mn:00001AC3                 push    ecx             ; wchar_t *
.text$mn:00001AC4                 push    2711h           ; unsigned __int32
.text$mn:00001AC9                 lea     ecx, [ebp+var_828] ; this
.text$mn:00001ACF                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00001AD4                 mov     [ebp+var_1088], eax
.text$mn:00001ADA                 mov     edx, [ebp+var_1088]
.text$mn:00001AE0                 mov     [ebp+var_FE0], edx
.text$mn:00001AE6                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001AEA                 mov     eax, [ebp+var_FE0]
.text$mn:00001AF0                 push    eax
.text$mn:00001AF1                 lea     ecx, [ebp+var_117C]
.text$mn:00001AF7                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00001AFC                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001B00                 lea     ecx, [ebp+var_828] ; this
.text$mn:00001B06                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00001B0B                 push    0               ; wchar_t *
.text$mn:00001B0D                 lea     ecx, [ebp+var_94]
.text$mn:00001B13                 push    ecx             ; wchar_t *
.text$mn:00001B14                 push    2712h           ; unsigned __int32
.text$mn:00001B19                 lea     ecx, [ebp+var_D8C] ; this
.text$mn:00001B1F                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00001B24                 mov     [ebp+var_FE8], eax
.text$mn:00001B2A                 mov     edx, [ebp+var_FE8]
.text$mn:00001B30                 mov     [ebp+var_1000], edx
.text$mn:00001B36                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001B3A                 mov     eax, [ebp+var_1000]
.text$mn:00001B40                 push    eax
.text$mn:00001B41                 lea     ecx, [ebp+var_117C]
.text$mn:00001B47                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00001B4C                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001B50                 lea     ecx, [ebp+var_D8C] ; this
.text$mn:00001B56                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00001B5B                 mov     ecx, [ebp+var_E44]
.text$mn:00001B61                 mov     edx, [ecx+54AE8h]
.text$mn:00001B67                 push    edx
.text$mn:00001B68                 lea     eax, [ebp+var_117C]
.text$mn:00001B6E                 push    eax
.text$mn:00001B6F                 mov     ecx, [ebp+var_E44]
.text$mn:00001B75                 mov     ecx, [ecx+4]    ; this
.text$mn:00001B78                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001B7D                 push    eax
.text$mn:00001B7E                 mov     ecx, [ebp+var_E44]
.text$mn:00001B84                 add     ecx, 680h
.text$mn:00001B8A                 call    ?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z ; ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)
.text$mn:00001B8F                 mov     ecx, [ebp+var_E44]
.text$mn:00001B95                 add     ecx, 680h       ; this
.text$mn:00001B9B                 call    ?getMenuHandle@ContextMenu@@QAEPAUHMENU__@@XZ ; ContextMenu::getMenuHandle(void)
.text$mn:00001BA0                 push    eax             ; HMENU
.text$mn:00001BA1                 mov     ecx, [ebp+var_E44]
.text$mn:00001BA7                 add     ecx, 34Ch       ; this
.text$mn:00001BAD                 call    ?changeLangTabDrapContextMenu@NativeLangSpeaker@@QAEXPAUHMENU__@@@Z ; NativeLangSpeaker::changeLangTabDrapContextMenu(HMENU__ *)
.text$mn:00001BB2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001BB9                 lea     ecx, [ebp+var_117C]
.text$mn:00001BBF                 call    ??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::~vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)
.text$mn:00001BC4
.text$mn:00001BC4 loc_1BC4:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+633j
.text$mn:00001BC4                 lea     edx, [ebp+Point]
.text$mn:00001BCA                 push    edx             ; struct tagPOINT *
.text$mn:00001BCB                 mov     ecx, [ebp+var_E44]
.text$mn:00001BD1                 add     ecx, 680h       ; this
.text$mn:00001BD7                 call    ?display@ContextMenu@@QBEXABUtagPOINT@@@Z ; ContextMenu::display(tagPOINT const &)
.text$mn:00001BDC                 jmp     loc_1F9F
.text$mn:00001BE1 ; ---------------------------------------------------------------------------
.text$mn:00001BE1
.text$mn:00001BE1 loc_1BE1:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+617j
.text$mn:00001BE1                 mov     eax, [ebp+var_E44]
.text$mn:00001BE7                 mov     ecx, [eax+460h] ; this
.text$mn:00001BED                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001BF2                 cmp     [ebp+hWnd], eax
.text$mn:00001BF8                 jz      short loc_1C13
.text$mn:00001BFA                 mov     ecx, [ebp+var_E44]
.text$mn:00001C00                 mov     ecx, [ecx+5D8h] ; this
.text$mn:00001C06                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001C0B                 cmp     [ebp+hWnd], eax
.text$mn:00001C11                 jnz     short loc_1C4B
.text$mn:00001C13
.text$mn:00001C13 loc_1C13:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+7D4j
.text$mn:00001C13                 movzx   edx, [ebp+var_E52]
.text$mn:00001C1A                 test    edx, edx
.text$mn:00001C1C                 jz      short loc_1C2A
.text$mn:00001C1E                 mov     [ebp+var_F3C], 1
.text$mn:00001C28                 jmp     short loc_1C34
.text$mn:00001C2A ; ---------------------------------------------------------------------------
.text$mn:00001C2A
.text$mn:00001C2A loc_1C2A:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+7F8j
.text$mn:00001C2A                 mov     [ebp+var_F3C], 2
.text$mn:00001C34
.text$mn:00001C34 loc_1C34:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+804j
.text$mn:00001C34                 mov     eax, [ebp+var_F3C]
.text$mn:00001C3A                 push    eax
.text$mn:00001C3B                 mov     ecx, [ebp+var_E44]
.text$mn:00001C41                 call    ?docGotoAnotherEditView@Notepad_plus@@AAEXW4FileTransferMode@@@Z ; Notepad_plus::docGotoAnotherEditView(FileTransferMode)
.text$mn:00001C46                 jmp     loc_1F9F
.text$mn:00001C4B ; ---------------------------------------------------------------------------
.text$mn:00001C4B
.text$mn:00001C4B loc_1C4B:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+7EDj
.text$mn:00001C4B                 lea     ecx, [ebp+Rect]
.text$mn:00001C51                 push    ecx             ; lpRect
.text$mn:00001C52                 mov     edx, [ebp+var_E44]
.text$mn:00001C58                 mov     ecx, [edx+4]    ; this
.text$mn:00001C5B                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001C60                 push    eax             ; hWnd
.text$mn:00001C61                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:00001C67                 mov     eax, [ebp+Point.x]
.text$mn:00001C6D                 cmp     eax, [ebp+Rect.left]
.text$mn:00001C73                 jl      short loc_1CAB
.text$mn:00001C75                 mov     ecx, [ebp+Point.x]
.text$mn:00001C7B                 cmp     ecx, [ebp+Rect.right]
.text$mn:00001C81                 jg      short loc_1CAB
.text$mn:00001C83                 mov     edx, [ebp+Point.y]
.text$mn:00001C89                 cmp     edx, [ebp+Rect.top]
.text$mn:00001C8F                 jl      short loc_1CAB
.text$mn:00001C91                 mov     eax, [ebp+Point.y]
.text$mn:00001C97                 cmp     eax, [ebp+Rect.bottom]
.text$mn:00001C9D                 jg      short loc_1CAB
.text$mn:00001C9F                 mov     [ebp+var_FBC], 1
.text$mn:00001CA9                 jmp     short loc_1CB5
.text$mn:00001CAB ; ---------------------------------------------------------------------------
.text$mn:00001CAB
.text$mn:00001CAB loc_1CAB:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+84Fj
.text$mn:00001CAB                                         ; Notepad_plus::notify(SCNotification *)+85Dj ...
.text$mn:00001CAB                 mov     [ebp+var_FBC], 0
.text$mn:00001CB5
.text$mn:00001CB5 loc_1CB5:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+885j
.text$mn:00001CB5                 mov     cl, byte ptr [ebp+var_FBC]
.text$mn:00001CBB                 mov     [ebp+var_E81], cl
.text$mn:00001CC1                 movzx   edx, [ebp+var_E81]
.text$mn:00001CC8                 test    edx, edx
.text$mn:00001CCA                 jz      short loc_1CD6
.text$mn:00001CCC                 mov     eax, 1
.text$mn:00001CD1                 jmp     loc_4795
.text$mn:00001CD6 ; ---------------------------------------------------------------------------
.text$mn:00001CD6
.text$mn:00001CD6 loc_1CD6:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+8A6j
.text$mn:00001CD6                 push    offset $SG172606 ; Str
.text$mn:00001CDB                 lea     ecx, [ebp+var_710]
.text$mn:00001CE1                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00001CE6                 mov     [ebp+var_4], 3
.text$mn:00001CED                 mov     eax, [ebp+var_E44]
.text$mn:00001CF3                 mov     ecx, [eax+5D4h] ; this
.text$mn:00001CF9                 call    ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBuffer(void)
.text$mn:00001CFE                 mov     ecx, eax        ; this
.text$mn:00001D00                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00001D05                 push    eax             ; Str
.text$mn:00001D06                 lea     ecx, [ebp+var_710]
.text$mn:00001D0C                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00001D11                 push    offset $SG172607 ; Str
.text$mn:00001D16                 lea     ecx, [ebp+var_710]
.text$mn:00001D1C                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00001D21                 mov     [ebp+lParam], 2
.text$mn:00001D2B                 lea     ecx, [ebp+var_710]
.text$mn:00001D31                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00001D36                 mov     [ebp+var_1164], eax
.text$mn:00001D3C                 lea     ecx, [ebp+var_710]
.text$mn:00001D42                 call    ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::length(void)
.text$mn:00001D47                 lea     ecx, [eax+eax+2]
.text$mn:00001D4B                 mov     [ebp+var_1168], ecx
.text$mn:00001D51                 mov     edx, [ebp+hWnd]
.text$mn:00001D57                 push    edx             ; hWnd
.text$mn:00001D58                 call    dword ptr ds:__imp__GetParent@4 ; GetParent(x)
.text$mn:00001D5E                 mov     [ebp+var_EDC], eax
.text$mn:00001D64                 mov     [ebp+var_11A4], 104h
.text$mn:00001D6E                 push    104h            ; nMaxCount
.text$mn:00001D73                 lea     eax, [ebp+ClassName]
.text$mn:00001D79                 push    eax             ; lpClassName
.text$mn:00001D7A                 mov     ecx, [ebp+var_EDC]
.text$mn:00001D80                 push    ecx             ; hWnd
.text$mn:00001D81                 call    dword ptr ds:__imp__GetClassNameW@12 ; GetClassNameW(x,x,x)
.text$mn:00001D87                 call    ?getClassName@Notepad_plus_Window@@SAPB_WXZ ; Notepad_plus_Window::getClassName(void)
.text$mn:00001D8C                 push    eax             ; lpString2
.text$mn:00001D8D                 lea     edx, [ebp+ClassName]
.text$mn:00001D93                 push    edx             ; lpString1
.text$mn:00001D94                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:00001D9A                 test    eax, eax
.text$mn:00001D9C                 jnz     loc_1F4C
.text$mn:00001DA2                 mov     eax, [ebp+var_E44]
.text$mn:00001DA8                 mov     ecx, [eax+4]    ; this
.text$mn:00001DAB                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001DB0                 cmp     [ebp+var_EDC], eax
.text$mn:00001DB6                 jz      loc_1F4C
.text$mn:00001DBC                 mov     ecx, [ebp+var_E44]
.text$mn:00001DC2                 mov     ecx, [ecx+45Ch] ; this
.text$mn:00001DC8                 call    ?getCurrentTabIndex@TabBar@@QBEHXZ ; TabBar::getCurrentTabIndex(void)
.text$mn:00001DCD                 mov     [ebp+var_1008], eax
.text$mn:00001DD3                 mov     edx, [ebp+var_1008]
.text$mn:00001DD9                 push    edx             ; int
.text$mn:00001DDA                 mov     ecx, [ebp+var_F54] ; this
.text$mn:00001DE0                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00001DE5                 mov     [ebp+var_F84], eax
.text$mn:00001DEB                 mov     eax, [ebp+var_F84]
.text$mn:00001DF1                 push    eax             ; struct Buffer *
.text$mn:00001DF2                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00001DF7                 mov     ecx, eax        ; this
.text$mn:00001DF9                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00001DFE                 mov     [ebp+var_1010], eax
.text$mn:00001E04                 movzx   ecx, [ebp+var_E45]
.text$mn:00001E0B                 test    ecx, ecx
.text$mn:00001E0D                 jz      short loc_1E1B
.text$mn:00001E0F                 mov     [ebp+var_F44], 0
.text$mn:00001E19                 jmp     short loc_1E25
.text$mn:00001E1B ; ---------------------------------------------------------------------------
.text$mn:00001E1B
.text$mn:00001E1B loc_1E1B:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+9E9j
.text$mn:00001E1B                 mov     [ebp+var_F44], 1
.text$mn:00001E25
.text$mn:00001E25 loc_1E25:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+9F5j
.text$mn:00001E25                 mov     edx, [ebp+var_F44]
.text$mn:00001E2B                 mov     [ebp+var_1018], edx
.text$mn:00001E31                 mov     ecx, [ebp+var_1010] ; this
.text$mn:00001E37                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:00001E3C                 movzx   eax, al
.text$mn:00001E3F                 test    eax, eax
.text$mn:00001E41                 jz      short loc_1EB9
.text$mn:00001E43                 lea     ecx, [ebp+var_748]
.text$mn:00001E49                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001E4E                 mov     byte ptr [ebp+var_4], 4
.text$mn:00001E52                 lea     ecx, [ebp+var_72C]
.text$mn:00001E58                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001E5D                 mov     byte ptr [ebp+var_4], 5
.text$mn:00001E61                 push    0               ; wchar_t *
.text$mn:00001E63                 push    0               ; int
.text$mn:00001E65                 push    0               ; int
.text$mn:00001E67                 push    offset $SG172622 ; "Move to new Notepad++ Instance"
.text$mn:00001E6C                 push    offset $SG172623 ; "Document is modified, save it then try "...
.text$mn:00001E71                 mov     ecx, [ebp+var_E44]
.text$mn:00001E77                 mov     ecx, [ecx+4]    ; this
.text$mn:00001E7A                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001E7F                 push    eax             ; HWND
.text$mn:00001E80                 push    offset $SG172624 ; "CannotMoveDoc"
.text$mn:00001E85                 mov     ecx, [ebp+var_E44]
.text$mn:00001E8B                 add     ecx, 34Ch       ; this
.text$mn:00001E91                 call    ?messageBox@NativeLangSpeaker@@QAEHPBDPAUHWND__@@PB_W2HH2@Z ; NativeLangSpeaker::messageBox(char const *,HWND__ *,wchar_t const *,wchar_t const *,int,int,wchar_t const *)
.text$mn:00001E96                 mov     byte ptr [ebp+var_4], 4
.text$mn:00001E9A                 lea     ecx, [ebp+var_72C]
.text$mn:00001EA0                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001EA5                 mov     byte ptr [ebp+var_4], 3
.text$mn:00001EA9                 lea     ecx, [ebp+var_748]
.text$mn:00001EAF                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001EB4                 jmp     loc_1F4A
.text$mn:00001EB9 ; ---------------------------------------------------------------------------
.text$mn:00001EB9
.text$mn:00001EB9 loc_1EB9:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+A1Dj
.text$mn:00001EB9                 mov     edx, [ebp+hWnd]
.text$mn:00001EBF                 push    edx             ; lParam
.text$mn:00001EC0                 push    0               ; wParam
.text$mn:00001EC2                 push    416h            ; Msg
.text$mn:00001EC7                 mov     eax, [ebp+var_EDC]
.text$mn:00001ECD                 push    eax             ; hWnd
.text$mn:00001ECE                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001ED4                 lea     ecx, [ebp+lParam]
.text$mn:00001EDA                 push    ecx             ; lParam
.text$mn:00001EDB                 mov     edx, [ebp+var_E44]
.text$mn:00001EE1                 mov     ecx, [edx+4]    ; this
.text$mn:00001EE4                 call    ?getHinst@Window@@QBEPAUHINSTANCE__@@XZ ; Window::getHinst(void)
.text$mn:00001EE9                 push    eax             ; wParam
.text$mn:00001EEA                 push    4Ah ; 'J'       ; Msg
.text$mn:00001EEC                 mov     eax, [ebp+var_EDC]
.text$mn:00001EF2                 push    eax             ; hWnd
.text$mn:00001EF3                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001EF9                 movzx   ecx, [ebp+var_E52]
.text$mn:00001F00                 test    ecx, ecx
.text$mn:00001F02                 jnz     short loc_1F4A
.text$mn:00001F04                 mov     edx, [ebp+var_1018]
.text$mn:00001F0A                 push    edx             ; int
.text$mn:00001F0B                 mov     eax, [ebp+var_F84]
.text$mn:00001F11                 push    eax             ; struct Buffer *
.text$mn:00001F12                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00001F18                 call    ?fileClose@Notepad_plus@@QAE_NPAVBuffer@@H@Z ; Notepad_plus::fileClose(Buffer *,int)
.text$mn:00001F1D                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00001F23                 call    ?noOpenedDoc@Notepad_plus@@ABE_NXZ ; Notepad_plus::noOpenedDoc(void)
.text$mn:00001F28                 movzx   ecx, al
.text$mn:00001F2B                 test    ecx, ecx
.text$mn:00001F2D                 jz      short loc_1F4A
.text$mn:00001F2F                 push    0               ; lParam
.text$mn:00001F31                 push    0               ; wParam
.text$mn:00001F33                 push    10h             ; Msg
.text$mn:00001F35                 mov     edx, [ebp+var_E44]
.text$mn:00001F3B                 mov     ecx, [edx+4]    ; this
.text$mn:00001F3E                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001F43                 push    eax             ; hWnd
.text$mn:00001F44                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001F4A
.text$mn:00001F4A loc_1F4A:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+A90j
.text$mn:00001F4A                                         ; Notepad_plus::notify(SCNotification *)+ADEj ...
.text$mn:00001F4A                 jmp     short loc_1F8D
.text$mn:00001F4C ; ---------------------------------------------------------------------------
.text$mn:00001F4C
.text$mn:00001F4C loc_1F4C:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+978j
.text$mn:00001F4C                                         ; Notepad_plus::notify(SCNotification *)+992j
.text$mn:00001F4C                 movzx   eax, [ebp+var_E52]
.text$mn:00001F53                 test    eax, eax
.text$mn:00001F55                 jz      short loc_1F63
.text$mn:00001F57                 mov     [ebp+var_F4C], 1
.text$mn:00001F61                 jmp     short loc_1F6D
.text$mn:00001F63 ; ---------------------------------------------------------------------------
.text$mn:00001F63
.text$mn:00001F63 loc_1F63:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+B31j
.text$mn:00001F63                 mov     [ebp+var_F4C], 2
.text$mn:00001F6D
.text$mn:00001F6D loc_1F6D:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+B3Dj
.text$mn:00001F6D                 mov     ecx, [ebp+Point.y]
.text$mn:00001F73                 push    ecx
.text$mn:00001F74                 mov     edx, [ebp+Point.x]
.text$mn:00001F7A                 push    edx
.text$mn:00001F7B                 mov     eax, [ebp+var_F4C]
.text$mn:00001F81                 push    eax
.text$mn:00001F82                 mov     ecx, [ebp+var_E44]
.text$mn:00001F88                 call    ?docOpenInNewInstance@Notepad_plus@@AAEXW4FileTransferMode@@HH@Z ; Notepad_plus::docOpenInNewInstance(FileTransferMode,int,int)
.text$mn:00001F8D
.text$mn:00001F8D loc_1F8D:                               ; CODE XREF: Notepad_plus::notify(SCNotification *):loc_1F4Aj
.text$mn:00001F8D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001F94                 lea     ecx, [ebp+var_710]
.text$mn:00001F9A                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001F9F
.text$mn:00001F9F loc_1F9F:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+5CEj
.text$mn:00001F9F                                         ; Notepad_plus::notify(SCNotification *)+7B8j ...
.text$mn:00001F9F                 mov     ecx, [ebp+var_FA4] ; this
.text$mn:00001FA5                 call    ?resetDraggingPoint@TabBarPlus@@QAEXXZ ; TabBarPlus::resetDraggingPoint(void)
.text$mn:00001FAA                 mov     eax, 1
.text$mn:00001FAF                 jmp     loc_4795
.text$mn:00001FB4 ; ---------------------------------------------------------------------------
.text$mn:00001FB4
.text$mn:00001FB4 loc_1FB4:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+233j
.text$mn:00001FB4                 mov     ecx, [ebp+var_1020]
.text$mn:00001FBA                 mov     edx, [ecx+0Ch]
.text$mn:00001FBD                 mov     [ebp+var_1028], edx
.text$mn:00001FC3                 mov     eax, [ebp+var_1028]
.text$mn:00001FC9                 push    eax             ; int
.text$mn:00001FCA                 mov     ecx, [ebp+var_F54] ; this
.text$mn:00001FD0                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00001FD5                 mov     [ebp+var_EEC], eax
.text$mn:00001FDB                 mov     ecx, [ebp+var_EEC]
.text$mn:00001FE1                 push    ecx             ; struct Buffer *
.text$mn:00001FE2                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00001FE7                 mov     ecx, eax        ; this
.text$mn:00001FE9                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00001FEE                 mov     [ebp+var_1030], eax
.text$mn:00001FF4                 movzx   edx, [ebp+var_E45]
.text$mn:00001FFB                 test    edx, edx
.text$mn:00001FFD                 jz      short loc_200B
.text$mn:00001FFF                 mov     [ebp+var_F8C], 0
.text$mn:00002009                 jmp     short loc_2015
.text$mn:0000200B ; ---------------------------------------------------------------------------
.text$mn:0000200B
.text$mn:0000200B loc_200B:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+BD9j
.text$mn:0000200B                 mov     [ebp+var_F8C], 1
.text$mn:00002015
.text$mn:00002015 loc_2015:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+BE5j
.text$mn:00002015                 mov     eax, [ebp+var_F8C]
.text$mn:0000201B                 mov     [ebp+var_F5C], eax
.text$mn:00002021                 mov     ecx, [ebp+var_1030] ; this
.text$mn:00002027                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:0000202C                 movzx   ecx, al
.text$mn:0000202F                 test    ecx, ecx
.text$mn:00002031                 jz      short loc_204C
.text$mn:00002033                 mov     edx, [ebp+var_F5C]
.text$mn:00002039                 push    edx             ; int
.text$mn:0000203A                 mov     eax, [ebp+var_EEC]
.text$mn:00002040                 push    eax             ; struct Buffer *
.text$mn:00002041                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00002047                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:0000204C
.text$mn:0000204C loc_204C:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+C0Dj
.text$mn:0000204C                 mov     ecx, [ebp+var_F5C]
.text$mn:00002052                 push    ecx             ; int
.text$mn:00002053                 mov     edx, [ebp+var_EEC]
.text$mn:00002059                 push    edx             ; struct Buffer *
.text$mn:0000205A                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00002060                 call    ?fileClose@Notepad_plus@@QAE_NPAVBuffer@@H@Z ; Notepad_plus::fileClose(Buffer *,int)
.text$mn:00002065                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:0000206A ; ---------------------------------------------------------------------------
.text$mn:0000206A
.text$mn:0000206A loc_206A:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1E2j
.text$mn:0000206A                 mov     [ebp+var_ED0], 0FFFFFFFFh
.text$mn:00002074                 mov     ecx, [ebp+var_E44]
.text$mn:0000207A                 add     ecx, 35Ch       ; this
.text$mn:00002080                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002085                 mov     ecx, [ebp+arg_0]
.text$mn:00002088                 cmp     [ecx], eax
.text$mn:0000208A                 jnz     short loc_2098
.text$mn:0000208C                 mov     [ebp+var_ED0], 0
.text$mn:00002096                 jmp     short loc_20C1
.text$mn:00002098 ; ---------------------------------------------------------------------------
.text$mn:00002098
.text$mn:00002098 loc_2098:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+C66j
.text$mn:00002098                 mov     ecx, [ebp+var_E44]
.text$mn:0000209E                 add     ecx, 3DCh       ; this
.text$mn:000020A4                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000020A9                 mov     edx, [ebp+arg_0]
.text$mn:000020AC                 cmp     [edx], eax
.text$mn:000020AE                 jnz     short loc_20BC
.text$mn:000020B0                 mov     [ebp+var_ED0], 1
.text$mn:000020BA                 jmp     short loc_20C1
.text$mn:000020BC ; ---------------------------------------------------------------------------
.text$mn:000020BC
.text$mn:000020BC loc_20BC:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+C8Aj
.text$mn:000020BC                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:000020C1 ; ---------------------------------------------------------------------------
.text$mn:000020C1
.text$mn:000020C1 loc_20C1:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+C72j
.text$mn:000020C1                                         ; Notepad_plus::notify(SCNotification *)+C96j
.text$mn:000020C1                 mov     eax, [ebp+var_ED0]
.text$mn:000020C7                 push    eax             ; int
.text$mn:000020C8                 mov     ecx, [ebp+var_E44] ; this
.text$mn:000020CE                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:000020D3                 mov     ecx, [ebp+var_E44]
.text$mn:000020D9                 mov     ecx, [ecx+45Ch] ; this
.text$mn:000020DF                 call    ?getCurrentTabIndex@TabBar@@QBEHXZ ; TabBar::getCurrentTabIndex(void)
.text$mn:000020E4                 push    eax             ; int
.text$mn:000020E5                 mov     edx, [ebp+var_E44]
.text$mn:000020EB                 mov     ecx, [edx+45Ch] ; this
.text$mn:000020F1                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:000020F6                 mov     [ebp+var_F04], eax
.text$mn:000020FC                 cmp     [ebp+var_F04], 0
.text$mn:00002103                 jz      short loc_211E
.text$mn:00002105                 mov     eax, [ebp+var_ED0]
.text$mn:0000210B                 push    eax             ; int
.text$mn:0000210C                 mov     ecx, [ebp+var_F04]
.text$mn:00002112                 push    ecx             ; struct Buffer *
.text$mn:00002113                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00002119                 call    ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z ; Notepad_plus::activateBuffer(Buffer *,int)
.text$mn:0000211E
.text$mn:0000211E loc_211E:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+CDFj
.text$mn:0000211E                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:00002123 ; ---------------------------------------------------------------------------
.text$mn:00002123
.text$mn:00002123 loc_2123:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+29Dj
.text$mn:00002123                 mov     ecx, [ebp+var_E44]
.text$mn:00002129                 add     ecx, 83Ch       ; this
.text$mn:0000212F                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002134                 mov     edx, [ebp+arg_0]
.text$mn:00002137                 cmp     [edx], eax
.text$mn:00002139                 jnz     loc_222B
.text$mn:0000213F                 mov     eax, [ebp+arg_0]
.text$mn:00002142                 mov     [ebp+var_1038], eax
.text$mn:00002148                 mov     ecx, [ebp+var_1038]
.text$mn:0000214E                 cmp     dword ptr [ecx+0Ch], 5
.text$mn:00002152                 jnz     loc_2226
.text$mn:00002158                 push    0               ; __int32
.text$mn:0000215A                 push    0               ; unsigned int
.text$mn:0000215C                 push    88Bh            ; unsigned int
.text$mn:00002161                 mov     edx, [ebp+var_E44]
.text$mn:00002167                 mov     ecx, [edx+5D4h] ; this
.text$mn:0000216D                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00002172                 test    eax, eax
.text$mn:00002174                 jz      short loc_2182
.text$mn:00002176                 mov     [ebp+var_F64], 1
.text$mn:00002180                 jmp     short loc_218C
.text$mn:00002182 ; ---------------------------------------------------------------------------
.text$mn:00002182
.text$mn:00002182 loc_2182:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+D50j
.text$mn:00002182                 mov     [ebp+var_F64], 0
.text$mn:0000218C
.text$mn:0000218C loc_218C:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+D5Cj
.text$mn:0000218C                 mov     al, byte ptr [ebp+var_F64]
.text$mn:00002192                 mov     [ebp+var_E79], al
.text$mn:00002198                 movzx   ecx, [ebp+var_E79]
.text$mn:0000219F                 test    ecx, ecx
.text$mn:000021A1                 jnz     short loc_21AF
.text$mn:000021A3                 mov     [ebp+var_F08], 1
.text$mn:000021AD                 jmp     short loc_21B9
.text$mn:000021AF ; ---------------------------------------------------------------------------
.text$mn:000021AF
.text$mn:000021AF loc_21AF:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+D7Dj
.text$mn:000021AF                 mov     [ebp+var_F08], 0
.text$mn:000021B9
.text$mn:000021B9 loc_21B9:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+D89j
.text$mn:000021B9                 push    0               ; __int32
.text$mn:000021BB                 mov     edx, [ebp+var_F08]
.text$mn:000021C1                 push    edx             ; unsigned int
.text$mn:000021C2                 push    88Ah            ; unsigned int
.text$mn:000021C7                 mov     eax, [ebp+var_E44]
.text$mn:000021CD                 mov     ecx, [eax+5D4h] ; this
.text$mn:000021D3                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000021D8                 push    0               ; __int32
.text$mn:000021DA                 push    0               ; unsigned int
.text$mn:000021DC                 push    88Bh            ; unsigned int
.text$mn:000021E1                 mov     ecx, [ebp+var_E44]
.text$mn:000021E7                 mov     ecx, [ecx+5D4h] ; this
.text$mn:000021ED                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000021F2                 test    eax, eax
.text$mn:000021F4                 jz      short loc_2202
.text$mn:000021F6                 mov     [ebp+var_F0C], offset $SG172653 ; "OVR"
.text$mn:00002200                 jmp     short loc_220C
.text$mn:00002202 ; ---------------------------------------------------------------------------
.text$mn:00002202
.text$mn:00002202 loc_2202:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+DD0j
.text$mn:00002202                 mov     [ebp+var_F0C], offset $SG172654 ; "INS"
.text$mn:0000220C
.text$mn:0000220C loc_220C:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+DDCj
.text$mn:0000220C                 push    5               ; int
.text$mn:0000220E                 mov     edx, [ebp+var_F0C]
.text$mn:00002214                 push    edx             ; wchar_t *
.text$mn:00002215                 mov     ecx, [ebp+var_E44]
.text$mn:0000221B                 add     ecx, 83Ch       ; this
.text$mn:00002221                 call    ?setText@StatusBar@@QAE_NPB_WH@Z ; StatusBar::setText(wchar_t const *,int)
.text$mn:00002226
.text$mn:00002226 loc_2226:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+D2Ej
.text$mn:00002226                 jmp     loc_22F5
.text$mn:0000222B ; ---------------------------------------------------------------------------
.text$mn:0000222B
.text$mn:0000222B loc_222B:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+D15j
.text$mn:0000222B                 mov     ecx, [ebp+var_E44]
.text$mn:00002231                 add     ecx, 35Ch       ; this
.text$mn:00002237                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:0000223C                 mov     ecx, [ebp+arg_0]
.text$mn:0000223F                 cmp     [ecx], eax
.text$mn:00002241                 jnz     short loc_2291
.text$mn:00002243                 mov     edx, [ebp+var_E44]
.text$mn:00002249                 cmp     dword ptr [edx+551C8h], 1
.text$mn:00002250                 jnz     short loc_2291
.text$mn:00002252                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00002257                 mov     ecx, eax        ; this
.text$mn:00002259                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:0000225E                 mov     ecx, eax        ; this
.text$mn:00002260                 call    ?isSnapshotMode@NppGUI@@QBE_NXZ ; NppGUI::isSnapshotMode(void)
.text$mn:00002265                 mov     [ebp+var_E7F], al
.text$mn:0000226B                 movzx   eax, [ebp+var_E7F]
.text$mn:00002272                 test    eax, eax
.text$mn:00002274                 jz      short loc_2282
.text$mn:00002276                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:0000227B                 mov     ecx, eax        ; this
.text$mn:0000227D                 call    ?backupCurrentBuffer@FileManager@@QAE_NXZ ; FileManager::backupCurrentBuffer(void)
.text$mn:00002282
.text$mn:00002282 loc_2282:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+E50j
.text$mn:00002282                 push    0               ; int
.text$mn:00002284                 mov     ecx, [ebp+var_E44] ; this
.text$mn:0000228A                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:0000228F                 jmp     short loc_22F5
.text$mn:00002291 ; ---------------------------------------------------------------------------
.text$mn:00002291
.text$mn:00002291 loc_2291:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+E1Dj
.text$mn:00002291                                         ; Notepad_plus::notify(SCNotification *)+E2Cj
.text$mn:00002291                 mov     ecx, [ebp+var_E44]
.text$mn:00002297                 add     ecx, 3DCh       ; this
.text$mn:0000229D                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000022A2                 mov     ecx, [ebp+arg_0]
.text$mn:000022A5                 cmp     [ecx], eax
.text$mn:000022A7                 jnz     short loc_22F5
.text$mn:000022A9                 mov     edx, [ebp+var_E44]
.text$mn:000022AF                 cmp     dword ptr [edx+551C8h], 0
.text$mn:000022B6                 jnz     short loc_22F5
.text$mn:000022B8                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000022BD                 mov     ecx, eax        ; this
.text$mn:000022BF                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:000022C4                 mov     ecx, eax        ; this
.text$mn:000022C6                 call    ?isSnapshotMode@NppGUI@@QBE_NXZ ; NppGUI::isSnapshotMode(void)
.text$mn:000022CB                 mov     [ebp+var_E7B], al
.text$mn:000022D1                 movzx   eax, [ebp+var_E7B]
.text$mn:000022D8                 test    eax, eax
.text$mn:000022DA                 jz      short loc_22E8
.text$mn:000022DC                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:000022E1                 mov     ecx, eax        ; this
.text$mn:000022E3                 call    ?backupCurrentBuffer@FileManager@@QAE_NXZ ; FileManager::backupCurrentBuffer(void)
.text$mn:000022E8
.text$mn:000022E8 loc_22E8:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+EB6j
.text$mn:000022E8                 push    1               ; int
.text$mn:000022EA                 mov     ecx, [ebp+var_E44] ; this
.text$mn:000022F0                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:000022F5
.text$mn:000022F5 loc_22F5:                               ; CODE XREF: Notepad_plus::notify(SCNotification *):loc_2226j
.text$mn:000022F5                                         ; Notepad_plus::notify(SCNotification *)+E6Bj ...
.text$mn:000022F5                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:000022FA ; ---------------------------------------------------------------------------
.text$mn:000022FA
.text$mn:000022FA loc_22FA:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+26Ej
.text$mn:000022FA                 mov     ecx, [ebp+var_E44]
.text$mn:00002300                 add     ecx, 83Ch       ; this
.text$mn:00002306                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:0000230B                 mov     ecx, [ebp+arg_0]
.text$mn:0000230E                 cmp     [ecx], eax
.text$mn:00002310                 jnz     loc_2524
.text$mn:00002316                 mov     edx, [ebp+arg_0]
.text$mn:00002319                 mov     [ebp+var_ED8], edx
.text$mn:0000231F                 mov     eax, [ebp+var_ED8]
.text$mn:00002325                 cmp     dword ptr [eax+0Ch], 2
.text$mn:00002329                 jnz     loc_23D5
.text$mn:0000232F                 mov     ecx, [ebp+var_E44]
.text$mn:00002335                 add     ecx, 1310h
.text$mn:0000233B                 mov     edx, [ebp+var_E44]
.text$mn:00002341                 mov     eax, [edx+1310h]
.text$mn:00002347                 mov     edx, [eax+34h]
.text$mn:0000234A                 call    edx
.text$mn:0000234C                 movzx   eax, al
.text$mn:0000234F                 test    eax, eax
.text$mn:00002351                 jnz     short loc_235F
.text$mn:00002353                 mov     [ebp+var_F14], 1
.text$mn:0000235D                 jmp     short loc_2369
.text$mn:0000235F ; ---------------------------------------------------------------------------
.text$mn:0000235F
.text$mn:0000235F loc_235F:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+F2Dj
.text$mn:0000235F                 mov     [ebp+var_F14], 0
.text$mn:00002369
.text$mn:00002369 loc_2369:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+F39j
.text$mn:00002369                 mov     cl, byte ptr [ebp+var_F14]
.text$mn:0000236F                 mov     [ebp+var_E7A], cl
.text$mn:00002375                 mov     ecx, [ebp+var_E44]
.text$mn:0000237B                 add     ecx, 34Ch       ; this
.text$mn:00002381                 call    ?isRTL@NativeLangSpeaker@@QBE_NXZ ; NativeLangSpeaker::isRTL(void)
.text$mn:00002386                 movzx   edx, al
.text$mn:00002389                 push    edx             ; bool
.text$mn:0000238A                 mov     ecx, [ebp+var_E44]
.text$mn:00002390                 add     ecx, 1310h      ; this
.text$mn:00002396                 call    ?doDialog@GoToLineDlg@@QAEX_N@Z ; GoToLineDlg::doDialog(bool)
.text$mn:0000239B                 movzx   eax, [ebp+var_E7A]
.text$mn:000023A2                 test    eax, eax
.text$mn:000023A4                 jz      short loc_23D0
.text$mn:000023A6                 push    0               ; char *
.text$mn:000023A8                 push    offset $SG172670 ; "GoToLine"
.text$mn:000023AD                 mov     ecx, [ebp+var_E44]
.text$mn:000023B3                 add     ecx, 1310h      ; this
.text$mn:000023B9                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000023BE                 push    eax             ; HWND
.text$mn:000023BF                 mov     ecx, [ebp+var_E44]
.text$mn:000023C5                 add     ecx, 34Ch       ; this
.text$mn:000023CB                 call    ?changeDlgLang@NativeLangSpeaker@@QAE_NPAUHWND__@@PBDPAD@Z ; NativeLangSpeaker::changeDlgLang(HWND__ *,char const *,char *)
.text$mn:000023D0
.text$mn:000023D0 loc_23D0:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+F80j
.text$mn:000023D0                 jmp     loc_2524
.text$mn:000023D5 ; ---------------------------------------------------------------------------
.text$mn:000023D5
.text$mn:000023D5 loc_23D5:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+F05j
.text$mn:000023D5                 mov     ecx, [ebp+var_ED8]
.text$mn:000023DB                 cmp     dword ptr [ecx+0Ch], 1
.text$mn:000023DF                 jnz     short loc_23F6
.text$mn:000023E1                 push    0AC11h          ; int
.text$mn:000023E6                 mov     ecx, [ebp+var_E44] ; this
.text$mn:000023EC                 call    ?command@Notepad_plus@@AAEXH@Z ; Notepad_plus::command(int)
.text$mn:000023F1                 jmp     loc_2524
.text$mn:000023F6 ; ---------------------------------------------------------------------------
.text$mn:000023F6
.text$mn:000023F6 loc_23F6:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+FBBj
.text$mn:000023F6                 mov     edx, [ebp+var_ED8]
.text$mn:000023FC                 cmp     dword ptr [edx+0Ch], 0
.text$mn:00002400                 jnz     short loc_245F
.text$mn:00002402                 lea     eax, [ebp+var_1140]
.text$mn:00002408                 push    eax             ; lpPoint
.text$mn:00002409                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:0000240F                 push    5               ; nPos
.text$mn:00002411                 mov     ecx, [ebp+var_E44]
.text$mn:00002417                 mov     edx, [ecx+54AE8h]
.text$mn:0000241D                 push    edx             ; hMenu
.text$mn:0000241E                 call    dword ptr ds:__imp__GetSubMenu@8 ; GetSubMenu(x,x)
.text$mn:00002424                 mov     [ebp+hMenu], eax
.text$mn:0000242A                 push    0               ; prcRect
.text$mn:0000242C                 mov     eax, [ebp+var_E44]
.text$mn:00002432                 mov     ecx, [eax+4]    ; this
.text$mn:00002435                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:0000243A                 push    eax             ; hWnd
.text$mn:0000243B                 push    0               ; nReserved
.text$mn:0000243D                 mov     ecx, [ebp+var_1140.y]
.text$mn:00002443                 push    ecx             ; y
.text$mn:00002444                 mov     edx, [ebp+var_1140.x]
.text$mn:0000244A                 push    edx             ; x
.text$mn:0000244B                 push    0               ; uFlags
.text$mn:0000244D                 mov     eax, [ebp+hMenu]
.text$mn:00002453                 push    eax             ; hMenu
.text$mn:00002454                 call    dword ptr ds:__imp__TrackPopupMenu@28 ; TrackPopupMenu(x,x,x,x,x,x,x)
.text$mn:0000245A                 jmp     loc_2524
.text$mn:0000245F ; ---------------------------------------------------------------------------
.text$mn:0000245F
.text$mn:0000245F loc_245F:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+FDCj
.text$mn:0000245F                 mov     ecx, [ebp+var_ED8]
.text$mn:00002465                 cmp     dword ptr [ecx+0Ch], 3
.text$mn:00002469                 jnz     loc_2524
.text$mn:0000246F                 lea     edx, [ebp+var_1148]
.text$mn:00002475                 push    edx             ; lpPoint
.text$mn:00002476                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:0000247C                 push    offset $SG172681 ; "edit-eolConversion"
.text$mn:00002481                 call    ?getMenuPosition@@YAAAVMenuPosition@@PBD@Z ; getMenuPosition(char const *)
.text$mn:00002486                 add     esp, 4
.text$mn:00002489                 mov     [ebp+var_F1C], eax
.text$mn:0000248F                 mov     eax, [ebp+var_F1C]
.text$mn:00002495                 mov     ecx, [eax]
.text$mn:00002497                 push    ecx             ; nPos
.text$mn:00002498                 mov     edx, [ebp+var_E44]
.text$mn:0000249E                 mov     eax, [edx+54AE8h]
.text$mn:000024A4                 push    eax             ; hMenu
.text$mn:000024A5                 call    dword ptr ds:__imp__GetSubMenu@8 ; GetSubMenu(x,x)
.text$mn:000024AB                 mov     [ebp+var_F24], eax
.text$mn:000024B1                 cmp     [ebp+var_F24], 0
.text$mn:000024B8                 jnz     short loc_24C4
.text$mn:000024BA                 mov     eax, 1
.text$mn:000024BF                 jmp     loc_4795
.text$mn:000024C4 ; ---------------------------------------------------------------------------
.text$mn:000024C4
.text$mn:000024C4 loc_24C4:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1094j
.text$mn:000024C4                 mov     ecx, [ebp+var_F1C]
.text$mn:000024CA                 mov     edx, [ecx+4]
.text$mn:000024CD                 push    edx             ; nPos
.text$mn:000024CE                 mov     eax, [ebp+var_F24]
.text$mn:000024D4                 push    eax             ; hMenu
.text$mn:000024D5                 call    dword ptr ds:__imp__GetSubMenu@8 ; GetSubMenu(x,x)
.text$mn:000024DB                 mov     [ebp+var_F30], eax
.text$mn:000024E1                 cmp     [ebp+var_F30], 0
.text$mn:000024E8                 jnz     short loc_24F4
.text$mn:000024EA                 mov     eax, 1
.text$mn:000024EF                 jmp     loc_4795
.text$mn:000024F4 ; ---------------------------------------------------------------------------
.text$mn:000024F4
.text$mn:000024F4 loc_24F4:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+10C4j
.text$mn:000024F4                 push    0               ; prcRect
.text$mn:000024F6                 mov     ecx, [ebp+var_E44]
.text$mn:000024FC                 mov     ecx, [ecx+4]    ; this
.text$mn:000024FF                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002504                 push    eax             ; hWnd
.text$mn:00002505                 push    0               ; nReserved
.text$mn:00002507                 mov     edx, [ebp+var_1148.y]
.text$mn:0000250D                 push    edx             ; y
.text$mn:0000250E                 mov     eax, [ebp+var_1148.x]
.text$mn:00002514                 push    eax             ; x
.text$mn:00002515                 push    0               ; uFlags
.text$mn:00002517                 mov     ecx, [ebp+var_F30]
.text$mn:0000251D                 push    ecx             ; hMenu
.text$mn:0000251E                 call    dword ptr ds:__imp__TrackPopupMenu@28 ; TrackPopupMenu(x,x,x,x,x,x,x)
.text$mn:00002524
.text$mn:00002524 loc_2524:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+EECj
.text$mn:00002524                                         ; Notepad_plus::notify(SCNotification *):loc_23D0j ...
.text$mn:00002524                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:00002529 ; ---------------------------------------------------------------------------
.text$mn:00002529
.text$mn:00002529 loc_2529:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+28Bj
.text$mn:00002529                 lea     edx, [ebp+var_1158]
.text$mn:0000252F                 push    edx             ; lpPoint
.text$mn:00002530                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:00002536                 mov     ecx, [ebp+var_E44]
.text$mn:0000253C                 add     ecx, 35Ch       ; this
.text$mn:00002542                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002547                 mov     ecx, [ebp+arg_0]
.text$mn:0000254A                 cmp     [ecx], eax
.text$mn:0000254C                 jnz     short loc_2560
.text$mn:0000254E                 push    0               ; int
.text$mn:00002550                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00002556                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:0000255B                 jmp     loc_288B
.text$mn:00002560 ; ---------------------------------------------------------------------------
.text$mn:00002560
.text$mn:00002560 loc_2560:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1128j
.text$mn:00002560                 mov     ecx, [ebp+var_E44]
.text$mn:00002566                 add     ecx, 3DCh       ; this
.text$mn:0000256C                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002571                 mov     edx, [ebp+arg_0]
.text$mn:00002574                 cmp     [edx], eax
.text$mn:00002576                 jnz     short loc_258A
.text$mn:00002578                 push    1               ; int
.text$mn:0000257A                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00002580                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:00002585                 jmp     loc_288B
.text$mn:0000258A ; ---------------------------------------------------------------------------
.text$mn:0000258A
.text$mn:0000258A loc_258A:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1152j
.text$mn:0000258A                 mov     ecx, [ebp+var_E44]
.text$mn:00002590                 add     ecx, 83Ch       ; this
.text$mn:00002596                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:0000259B                 mov     ecx, [ebp+arg_0]
.text$mn:0000259E                 cmp     [ecx], eax
.text$mn:000025A0                 jnz     loc_26EC
.text$mn:000025A6                 mov     edx, [ebp+arg_0]
.text$mn:000025A9                 mov     [ebp+var_F38], edx
.text$mn:000025AF                 mov     eax, [ebp+var_F38]
.text$mn:000025B5                 cmp     dword ptr [eax+0Ch], 0
.text$mn:000025B9                 jnz     short loc_2618
.text$mn:000025BB                 lea     ecx, [ebp+var_1150]
.text$mn:000025C1                 push    ecx             ; lpPoint
.text$mn:000025C2                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:000025C8                 push    5               ; nPos
.text$mn:000025CA                 mov     edx, [ebp+var_E44]
.text$mn:000025D0                 mov     eax, [edx+54AE8h]
.text$mn:000025D6                 push    eax             ; hMenu
.text$mn:000025D7                 call    dword ptr ds:__imp__GetSubMenu@8 ; GetSubMenu(x,x)
.text$mn:000025DD                 mov     [ebp+var_1048], eax
.text$mn:000025E3                 push    0               ; prcRect
.text$mn:000025E5                 mov     ecx, [ebp+var_E44]
.text$mn:000025EB                 mov     ecx, [ecx+4]    ; this
.text$mn:000025EE                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000025F3                 push    eax             ; hWnd
.text$mn:000025F4                 push    0               ; nReserved
.text$mn:000025F6                 mov     edx, [ebp+var_1150.y]
.text$mn:000025FC                 push    edx             ; y
.text$mn:000025FD                 mov     eax, [ebp+var_1150.x]
.text$mn:00002603                 push    eax             ; x
.text$mn:00002604                 push    0               ; uFlags
.text$mn:00002606                 mov     ecx, [ebp+var_1048]
.text$mn:0000260C                 push    ecx             ; hMenu
.text$mn:0000260D                 call    dword ptr ds:__imp__TrackPopupMenu@28 ; TrackPopupMenu(x,x,x,x,x,x,x)
.text$mn:00002613                 jmp     loc_26DD
.text$mn:00002618 ; ---------------------------------------------------------------------------
.text$mn:00002618
.text$mn:00002618 loc_2618:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1195j
.text$mn:00002618                 mov     edx, [ebp+var_F38]
.text$mn:0000261E                 cmp     dword ptr [edx+0Ch], 3
.text$mn:00002622                 jnz     loc_26DD
.text$mn:00002628                 lea     eax, [ebp+var_1160]
.text$mn:0000262E                 push    eax             ; lpPoint
.text$mn:0000262F                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:00002635                 push    offset $SG172702 ; "edit-eolConversion"
.text$mn:0000263A                 call    ?getMenuPosition@@YAAAVMenuPosition@@PBD@Z ; getMenuPosition(char const *)
.text$mn:0000263F                 add     esp, 4
.text$mn:00002642                 mov     [ebp+var_F40], eax
.text$mn:00002648                 mov     ecx, [ebp+var_F40]
.text$mn:0000264E                 mov     edx, [ecx]
.text$mn:00002650                 push    edx             ; nPos
.text$mn:00002651                 mov     eax, [ebp+var_E44]
.text$mn:00002657                 mov     ecx, [eax+54AE8h]
.text$mn:0000265D                 push    ecx             ; hMenu
.text$mn:0000265E                 call    dword ptr ds:__imp__GetSubMenu@8 ; GetSubMenu(x,x)
.text$mn:00002664                 mov     [ebp+var_F48], eax
.text$mn:0000266A                 cmp     [ebp+var_F48], 0
.text$mn:00002671                 jnz     short loc_267D
.text$mn:00002673                 mov     eax, 1
.text$mn:00002678                 jmp     loc_4795
.text$mn:0000267D ; ---------------------------------------------------------------------------
.text$mn:0000267D
.text$mn:0000267D loc_267D:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+124Dj
.text$mn:0000267D                 mov     edx, [ebp+var_F40]
.text$mn:00002683                 mov     eax, [edx+4]
.text$mn:00002686                 push    eax             ; nPos
.text$mn:00002687                 mov     ecx, [ebp+var_F48]
.text$mn:0000268D                 push    ecx             ; hMenu
.text$mn:0000268E                 call    dword ptr ds:__imp__GetSubMenu@8 ; GetSubMenu(x,x)
.text$mn:00002694                 mov     [ebp+var_F50], eax
.text$mn:0000269A                 cmp     [ebp+var_F50], 0
.text$mn:000026A1                 jnz     short loc_26AD
.text$mn:000026A3                 mov     eax, 1
.text$mn:000026A8                 jmp     loc_4795
.text$mn:000026AD ; ---------------------------------------------------------------------------
.text$mn:000026AD
.text$mn:000026AD loc_26AD:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+127Dj
.text$mn:000026AD                 push    0               ; prcRect
.text$mn:000026AF                 mov     edx, [ebp+var_E44]
.text$mn:000026B5                 mov     ecx, [edx+4]    ; this
.text$mn:000026B8                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000026BD                 push    eax             ; hWnd
.text$mn:000026BE                 push    0               ; nReserved
.text$mn:000026C0                 mov     eax, [ebp+var_1160.y]
.text$mn:000026C6                 push    eax             ; y
.text$mn:000026C7                 mov     ecx, [ebp+var_1160.x]
.text$mn:000026CD                 push    ecx             ; x
.text$mn:000026CE                 push    0               ; uFlags
.text$mn:000026D0                 mov     edx, [ebp+var_F50]
.text$mn:000026D6                 push    edx             ; hMenu
.text$mn:000026D7                 call    dword ptr ds:__imp__TrackPopupMenu@28 ; TrackPopupMenu(x,x,x,x,x,x,x)
.text$mn:000026DD
.text$mn:000026DD loc_26DD:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+11EFj
.text$mn:000026DD                                         ; Notepad_plus::notify(SCNotification *)+11FEj
.text$mn:000026DD                 mov     eax, 1
.text$mn:000026E2                 jmp     loc_4795
.text$mn:000026E7 ; ---------------------------------------------------------------------------
.text$mn:000026E7                 jmp     loc_288B
.text$mn:000026EC ; ---------------------------------------------------------------------------
.text$mn:000026EC
.text$mn:000026EC loc_26EC:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+117Cj
.text$mn:000026EC                 mov     eax, [ebp+var_E44]
.text$mn:000026F2                 cmp     dword ptr [eax+551ACh], 0
.text$mn:000026F9                 jz      loc_2881
.text$mn:000026FF                 mov     ecx, [ebp+var_E44]
.text$mn:00002705                 mov     ecx, [ecx+551ACh] ; this
.text$mn:0000270B                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002710                 mov     edx, [ebp+arg_0]
.text$mn:00002713                 cmp     [edx], eax
.text$mn:00002715                 jnz     loc_2881
.text$mn:0000271B                 mov     eax, [ebp+var_E44]
.text$mn:00002721                 mov     ecx, [eax+551ACh] ; this
.text$mn:00002727                 call    ?nbSelectedFiles@VerticalFileSwitcher@@QBEHXZ ; VerticalFileSwitcher::nbSelectedFiles(void)
.text$mn:0000272C                 cmp     eax, 1
.text$mn:0000272F                 jle     loc_287F
.text$mn:00002735                 mov     ecx, [ebp+var_E44]
.text$mn:0000273B                 add     ecx, 698h       ; this
.text$mn:00002741                 call    ?isCreated@ContextMenu@@QBE_NXZ ; ContextMenu::isCreated(void)
.text$mn:00002746                 movzx   ecx, al
.text$mn:00002749                 test    ecx, ecx
.text$mn:0000274B                 jnz     loc_285D
.text$mn:00002751                 lea     ecx, [ebp+var_118C]
.text$mn:00002757                 call    ??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)
.text$mn:0000275C                 mov     [ebp+var_4], 6
.text$mn:00002763                 push    0               ; wchar_t *
.text$mn:00002765                 push    offset $SG172717 ; "Close Selected files"
.text$mn:0000276A                 push    0A9EDh          ; unsigned __int32
.text$mn:0000276F                 lea     ecx, [ebp+var_8DC] ; this
.text$mn:00002775                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:0000277A                 mov     [ebp+var_1050], eax
.text$mn:00002780                 mov     edx, [ebp+var_1050]
.text$mn:00002786                 mov     [ebp+var_1058], edx
.text$mn:0000278C                 mov     byte ptr [ebp+var_4], 7
.text$mn:00002790                 mov     eax, [ebp+var_1058]
.text$mn:00002796                 push    eax
.text$mn:00002797                 lea     ecx, [ebp+var_118C]
.text$mn:0000279D                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:000027A2                 mov     byte ptr [ebp+var_4], 6
.text$mn:000027A6                 lea     ecx, [ebp+var_8DC] ; this
.text$mn:000027AC                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:000027B1                 push    0               ; wchar_t *
.text$mn:000027B3                 push    offset $SG172719 ; "Close others files"
.text$mn:000027B8                 push    0A9EEh          ; unsigned __int32
.text$mn:000027BD                 lea     ecx, [ebp+var_BAC] ; this
.text$mn:000027C3                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:000027C8                 mov     [ebp+var_1060], eax
.text$mn:000027CE                 mov     ecx, [ebp+var_1060]
.text$mn:000027D4                 mov     [ebp+var_1068], ecx
.text$mn:000027DA                 mov     byte ptr [ebp+var_4], 8
.text$mn:000027DE                 mov     edx, [ebp+var_1068]
.text$mn:000027E4                 push    edx
.text$mn:000027E5                 lea     ecx, [ebp+var_118C]
.text$mn:000027EB                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:000027F0                 mov     byte ptr [ebp+var_4], 6
.text$mn:000027F4                 lea     ecx, [ebp+var_BAC] ; this
.text$mn:000027FA                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:000027FF                 push    0
.text$mn:00002801                 lea     eax, [ebp+var_118C]
.text$mn:00002807                 push    eax
.text$mn:00002808                 mov     ecx, [ebp+var_E44]
.text$mn:0000280E                 mov     ecx, [ecx+4]    ; this
.text$mn:00002811                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00002816                 push    eax
.text$mn:00002817                 mov     ecx, [ebp+var_E44]
.text$mn:0000281D                 add     ecx, 698h
.text$mn:00002823                 call    ?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z ; ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)
.text$mn:00002828                 mov     ecx, [ebp+var_E44]
.text$mn:0000282E                 add     ecx, 698h       ; this
.text$mn:00002834                 call    ?getMenuHandle@ContextMenu@@QAEPAUHMENU__@@XZ ; ContextMenu::getMenuHandle(void)
.text$mn:00002839                 push    eax             ; HMENU
.text$mn:0000283A                 mov     ecx, [ebp+var_E44]
.text$mn:00002840                 add     ecx, 34Ch       ; this
.text$mn:00002846                 call    ?changeLangTabContextMenu@NativeLangSpeaker@@QAEXPAUHMENU__@@@Z ; NativeLangSpeaker::changeLangTabContextMenu(HMENU__ *)
.text$mn:0000284B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002852                 lea     ecx, [ebp+var_118C]
.text$mn:00002858                 call    ??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::~vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)
.text$mn:0000285D
.text$mn:0000285D loc_285D:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1327j
.text$mn:0000285D                 lea     edx, [ebp+var_1158]
.text$mn:00002863                 push    edx             ; struct tagPOINT *
.text$mn:00002864                 mov     ecx, [ebp+var_E44]
.text$mn:0000286A                 add     ecx, 698h       ; this
.text$mn:00002870                 call    ?display@ContextMenu@@QBEXABUtagPOINT@@@Z ; ContextMenu::display(tagPOINT const &)
.text$mn:00002875                 mov     eax, 1
.text$mn:0000287A                 jmp     loc_4795
.text$mn:0000287F ; ---------------------------------------------------------------------------
.text$mn:0000287F
.text$mn:0000287F loc_287F:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+130Bj
.text$mn:0000287F                 jmp     short loc_288B
.text$mn:00002881 ; ---------------------------------------------------------------------------
.text$mn:00002881
.text$mn:00002881 loc_2881:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+12D5j
.text$mn:00002881                                         ; Notepad_plus::notify(SCNotification *)+12F1j
.text$mn:00002881                 mov     eax, 1
.text$mn:00002886                 jmp     loc_4795
.text$mn:0000288B ; ---------------------------------------------------------------------------
.text$mn:0000288B
.text$mn:0000288B loc_288B:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1137j
.text$mn:0000288B                                         ; Notepad_plus::notify(SCNotification *)+1161j ...
.text$mn:0000288B                 mov     ecx, [ebp+var_E44]
.text$mn:00002891                 add     ecx, 668h       ; this
.text$mn:00002897                 call    ?isCreated@ContextMenu@@QBE_NXZ ; ContextMenu::isCreated(void)
.text$mn:0000289C                 movzx   eax, al
.text$mn:0000289F                 test    eax, eax
.text$mn:000028A1                 jnz     loc_309D
.text$mn:000028A7                 lea     ecx, [ebp+var_E98]
.text$mn:000028AD                 call    ??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)
.text$mn:000028B2                 mov     [ebp+var_4], 9
.text$mn:000028B9                 push    0               ; wchar_t *
.text$mn:000028BB                 push    offset $SG172728 ; "Close"
.text$mn:000028C0                 push    0A02Bh          ; unsigned __int32
.text$mn:000028C5                 lea     ecx, [ebp+var_954] ; this
.text$mn:000028CB                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:000028D0                 mov     [ebp+var_1070], eax
.text$mn:000028D6                 mov     ecx, [ebp+var_1070]
.text$mn:000028DC                 mov     [ebp+var_1078], ecx
.text$mn:000028E2                 mov     byte ptr [ebp+var_4], 0Ah
.text$mn:000028E6                 mov     edx, [ebp+var_1078]
.text$mn:000028EC                 push    edx
.text$mn:000028ED                 lea     ecx, [ebp+var_E98]
.text$mn:000028F3                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:000028F8                 mov     byte ptr [ebp+var_4], 9
.text$mn:000028FC                 lea     ecx, [ebp+var_954] ; this
.text$mn:00002902                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002907                 push    0               ; wchar_t *
.text$mn:00002909                 push    offset $SG172730 ; "Close All BUT This"
.text$mn:0000290E                 push    0A02Dh          ; unsigned __int32
.text$mn:00002913                 lea     ecx, [ebp+var_D14] ; this
.text$mn:00002919                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:0000291E                 mov     [ebp+var_1080], eax
.text$mn:00002924                 mov     eax, [ebp+var_1080]
.text$mn:0000292A                 mov     [ebp+var_FCC], eax
.text$mn:00002930                 mov     byte ptr [ebp+var_4], 0Bh
.text$mn:00002934                 mov     ecx, [ebp+var_FCC]
.text$mn:0000293A                 push    ecx
.text$mn:0000293B                 lea     ecx, [ebp+var_E98]
.text$mn:00002941                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002946                 mov     byte ptr [ebp+var_4], 9
.text$mn:0000294A                 lea     ecx, [ebp+var_D14] ; this
.text$mn:00002950                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002955                 push    0               ; wchar_t *
.text$mn:00002957                 push    offset $SG172732 ; "Close All to the Left"
.text$mn:0000295C                 push    0A031h          ; unsigned __int32
.text$mn:00002961                 lea     ecx, [ebp+var_9CC] ; this
.text$mn:00002967                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:0000296C                 mov     [ebp+var_1090], eax
.text$mn:00002972                 mov     edx, [ebp+var_1090]
.text$mn:00002978                 mov     [ebp+var_1098], edx
.text$mn:0000297E                 mov     byte ptr [ebp+var_4], 0Ch
.text$mn:00002982                 mov     eax, [ebp+var_1098]
.text$mn:00002988                 push    eax
.text$mn:00002989                 lea     ecx, [ebp+var_E98]
.text$mn:0000298F                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002994                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002998                 lea     ecx, [ebp+var_9CC] ; this
.text$mn:0000299E                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:000029A3                 push    0               ; wchar_t *
.text$mn:000029A5                 push    offset $SG172734 ; "Close All to the Right"
.text$mn:000029AA                 push    0A03Ah          ; unsigned __int32
.text$mn:000029AF                 lea     ecx, [ebp+var_7B0] ; this
.text$mn:000029B5                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:000029BA                 mov     [ebp+var_10A0], eax
.text$mn:000029C0                 mov     ecx, [ebp+var_10A0]
.text$mn:000029C6                 mov     [ebp+var_10A8], ecx
.text$mn:000029CC                 mov     byte ptr [ebp+var_4], 0Dh
.text$mn:000029D0                 mov     edx, [ebp+var_10A8]
.text$mn:000029D6                 push    edx
.text$mn:000029D7                 lea     ecx, [ebp+var_E98]
.text$mn:000029DD                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:000029E2                 mov     byte ptr [ebp+var_4], 9
.text$mn:000029E6                 lea     ecx, [ebp+var_7B0] ; this
.text$mn:000029EC                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:000029F1                 push    0               ; wchar_t *
.text$mn:000029F3                 push    offset $SG172736 ; "Save"
.text$mn:000029F8                 push    0A02Eh          ; unsigned __int32
.text$mn:000029FD                 lea     ecx, [ebp+var_A44] ; this
.text$mn:00002A03                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002A08                 mov     [ebp+var_10B0], eax
.text$mn:00002A0E                 mov     eax, [ebp+var_10B0]
.text$mn:00002A14                 mov     [ebp+var_10B8], eax
.text$mn:00002A1A                 mov     byte ptr [ebp+var_4], 0Eh
.text$mn:00002A1E                 mov     ecx, [ebp+var_10B8]
.text$mn:00002A24                 push    ecx
.text$mn:00002A25                 lea     ecx, [ebp+var_E98]
.text$mn:00002A2B                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002A30                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002A34                 lea     ecx, [ebp+var_A44] ; this
.text$mn:00002A3A                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002A3F                 push    0               ; wchar_t *
.text$mn:00002A41                 push    offset $SG172738 ; "Save As..."
.text$mn:00002A46                 push    0A030h          ; unsigned __int32
.text$mn:00002A4B                 lea     ecx, [ebp+var_E04] ; this
.text$mn:00002A51                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002A56                 mov     [ebp+var_10C0], eax
.text$mn:00002A5C                 mov     edx, [ebp+var_10C0]
.text$mn:00002A62                 mov     [ebp+var_10C8], edx
.text$mn:00002A68                 mov     byte ptr [ebp+var_4], 0Fh
.text$mn:00002A6C                 mov     eax, [ebp+var_10C8]
.text$mn:00002A72                 push    eax
.text$mn:00002A73                 lea     ecx, [ebp+var_E98]
.text$mn:00002A79                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002A7E                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002A82                 lea     ecx, [ebp+var_E04] ; this
.text$mn:00002A88                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002A8D                 push    0               ; wchar_t *
.text$mn:00002A8F                 push    offset $SG172740 ; "Rename"
.text$mn:00002A94                 push    0A039h          ; unsigned __int32
.text$mn:00002A99                 lea     ecx, [ebp+var_ABC] ; this
.text$mn:00002A9F                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002AA4                 mov     [ebp+var_10D0], eax
.text$mn:00002AAA                 mov     ecx, [ebp+var_10D0]
.text$mn:00002AB0                 mov     [ebp+var_10D8], ecx
.text$mn:00002AB6                 mov     byte ptr [ebp+var_4], 10h
.text$mn:00002ABA                 mov     edx, [ebp+var_10D8]
.text$mn:00002AC0                 push    edx
.text$mn:00002AC1                 lea     ecx, [ebp+var_E98]
.text$mn:00002AC7                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002ACC                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002AD0                 lea     ecx, [ebp+var_ABC] ; this
.text$mn:00002AD6                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002ADB                 push    0               ; wchar_t *
.text$mn:00002ADD                 push    offset $SG172742 ; "Move to Recycle Bin"
.text$mn:00002AE2                 push    0A038h          ; unsigned __int32
.text$mn:00002AE7                 lea     ecx, [ebp+var_C9C] ; this
.text$mn:00002AED                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002AF2                 mov     [ebp+var_10E0], eax
.text$mn:00002AF8                 mov     eax, [ebp+var_10E0]
.text$mn:00002AFE                 mov     [ebp+var_10E8], eax
.text$mn:00002B04                 mov     byte ptr [ebp+var_4], 11h
.text$mn:00002B08                 mov     ecx, [ebp+var_10E8]
.text$mn:00002B0E                 push    ecx
.text$mn:00002B0F                 lea     ecx, [ebp+var_E98]
.text$mn:00002B15                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002B1A                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002B1E                 lea     ecx, [ebp+var_C9C] ; this
.text$mn:00002B24                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002B29                 push    0               ; wchar_t *
.text$mn:00002B2B                 push    offset $SG172744 ; "Reload"
.text$mn:00002B30                 push    0A036h          ; unsigned __int32
.text$mn:00002B35                 lea     ecx, [ebp+var_B34] ; this
.text$mn:00002B3B                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002B40                 mov     [ebp+var_10F0], eax
.text$mn:00002B46                 mov     edx, [ebp+var_10F0]
.text$mn:00002B4C                 mov     [ebp+var_10F8], edx
.text$mn:00002B52                 mov     byte ptr [ebp+var_4], 12h
.text$mn:00002B56                 mov     eax, [ebp+var_10F8]
.text$mn:00002B5C                 push    eax
.text$mn:00002B5D                 lea     ecx, [ebp+var_E98]
.text$mn:00002B63                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002B68                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002B6C                 lea     ecx, [ebp+var_B34] ; this
.text$mn:00002B72                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002B77                 push    0               ; wchar_t *
.text$mn:00002B79                 push    offset $SG172746 ; "Print"
.text$mn:00002B7E                 push    0A032h          ; unsigned __int32
.text$mn:00002B83                 lea     ecx, [ebp+var_7EC] ; this
.text$mn:00002B89                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002B8E                 mov     [ebp+var_1100], eax
.text$mn:00002B94                 mov     ecx, [ebp+var_1100]
.text$mn:00002B9A                 mov     [ebp+var_1108], ecx
.text$mn:00002BA0                 mov     byte ptr [ebp+var_4], 13h
.text$mn:00002BA4                 mov     edx, [ebp+var_1108]
.text$mn:00002BAA                 push    edx
.text$mn:00002BAB                 lea     ecx, [ebp+var_E98]
.text$mn:00002BB1                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002BB6                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002BBA                 lea     ecx, [ebp+var_7EC] ; this
.text$mn:00002BC0                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002BC5                 push    0               ; wchar_t *
.text$mn:00002BC7                 push    0               ; wchar_t *
.text$mn:00002BC9                 push    0               ; unsigned __int32
.text$mn:00002BCB                 lea     ecx, [ebp+var_8A0] ; this
.text$mn:00002BD1                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002BD6                 mov     [ebp+var_1110], eax
.text$mn:00002BDC                 mov     eax, [ebp+var_1110]
.text$mn:00002BE2                 mov     [ebp+var_1118], eax
.text$mn:00002BE8                 mov     byte ptr [ebp+var_4], 14h
.text$mn:00002BEC                 mov     ecx, [ebp+var_1118]
.text$mn:00002BF2                 push    ecx
.text$mn:00002BF3                 lea     ecx, [ebp+var_E98]
.text$mn:00002BF9                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002BFE                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002C02                 lea     ecx, [ebp+var_8A0] ; this
.text$mn:00002C08                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002C0D                 push    0               ; wchar_t *
.text$mn:00002C0F                 push    offset $SG172749 ; "Open Containing Folder in Explorer"
.text$mn:00002C14                 push    0A03Bh          ; unsigned __int32
.text$mn:00002C19                 lea     ecx, [ebp+var_918] ; this
.text$mn:00002C1F                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002C24                 mov     [ebp+var_1120], eax
.text$mn:00002C2A                 mov     edx, [ebp+var_1120]
.text$mn:00002C30                 mov     [ebp+var_1128], edx
.text$mn:00002C36                 mov     byte ptr [ebp+var_4], 15h
.text$mn:00002C3A                 mov     eax, [ebp+var_1128]
.text$mn:00002C40                 push    eax
.text$mn:00002C41                 lea     ecx, [ebp+var_E98]
.text$mn:00002C47                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002C4C                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002C50                 lea     ecx, [ebp+var_918] ; this
.text$mn:00002C56                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002C5B                 push    0               ; wchar_t *
.text$mn:00002C5D                 push    offset $SG172751 ; "Open Containing Folder in cmd"
.text$mn:00002C62                 push    0A03Ch          ; unsigned __int32
.text$mn:00002C67                 lea     ecx, [ebp+var_990] ; this
.text$mn:00002C6D                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002C72                 mov     [ebp+var_1130], eax
.text$mn:00002C78                 mov     ecx, [ebp+var_1130]
.text$mn:00002C7E                 mov     [ebp+var_1138], ecx
.text$mn:00002C84                 mov     byte ptr [ebp+var_4], 16h
.text$mn:00002C88                 mov     edx, [ebp+var_1138]
.text$mn:00002C8E                 push    edx
.text$mn:00002C8F                 lea     ecx, [ebp+var_E98]
.text$mn:00002C95                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002C9A                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002C9E                 lea     ecx, [ebp+var_990] ; this
.text$mn:00002CA4                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002CA9                 push    0               ; wchar_t *
.text$mn:00002CAB                 push    0               ; wchar_t *
.text$mn:00002CAD                 push    0               ; unsigned __int32
.text$mn:00002CAF                 lea     ecx, [ebp+var_A08] ; this
.text$mn:00002CB5                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002CBA                 mov     [ebp+var_FDC], eax
.text$mn:00002CC0                 mov     eax, [ebp+var_FDC]
.text$mn:00002CC6                 mov     [ebp+var_FF0], eax
.text$mn:00002CCC                 mov     byte ptr [ebp+var_4], 17h
.text$mn:00002CD0                 mov     ecx, [ebp+var_FF0]
.text$mn:00002CD6                 push    ecx
.text$mn:00002CD7                 lea     ecx, [ebp+var_E98]
.text$mn:00002CDD                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002CE2                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002CE6                 lea     ecx, [ebp+var_A08] ; this
.text$mn:00002CEC                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002CF1                 push    0               ; wchar_t *
.text$mn:00002CF3                 push    offset $SG172754 ; "Read-Only"
.text$mn:00002CF8                 push    0A42Ch          ; unsigned __int32
.text$mn:00002CFD                 lea     ecx, [ebp+var_A80] ; this
.text$mn:00002D03                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002D08                 mov     [ebp+var_FF8], eax
.text$mn:00002D0E                 mov     edx, [ebp+var_FF8]
.text$mn:00002D14                 mov     [ebp+var_108C], edx
.text$mn:00002D1A                 mov     byte ptr [ebp+var_4], 18h
.text$mn:00002D1E                 mov     eax, [ebp+var_108C]
.text$mn:00002D24                 push    eax
.text$mn:00002D25                 lea     ecx, [ebp+var_E98]
.text$mn:00002D2B                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002D30                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002D34                 lea     ecx, [ebp+var_A80] ; this
.text$mn:00002D3A                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002D3F                 push    0               ; wchar_t *
.text$mn:00002D41                 push    offset $SG172756 ; "Clear Read-Only Flag"
.text$mn:00002D46                 push    0A431h          ; unsigned __int32
.text$mn:00002D4B                 lea     ecx, [ebp+var_AF8] ; this
.text$mn:00002D51                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002D56                 mov     [ebp+var_FE4], eax
.text$mn:00002D5C                 mov     ecx, [ebp+var_FE4]
.text$mn:00002D62                 mov     [ebp+var_10E4], ecx
.text$mn:00002D68                 mov     byte ptr [ebp+var_4], 19h
.text$mn:00002D6C                 mov     edx, [ebp+var_10E4]
.text$mn:00002D72                 push    edx
.text$mn:00002D73                 lea     ecx, [ebp+var_E98]
.text$mn:00002D79                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002D7E                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002D82                 lea     ecx, [ebp+var_AF8] ; this
.text$mn:00002D88                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002D8D                 push    0               ; wchar_t *
.text$mn:00002D8F                 push    0               ; wchar_t *
.text$mn:00002D91                 push    0               ; unsigned __int32
.text$mn:00002D93                 lea     ecx, [ebp+var_B70] ; this
.text$mn:00002D99                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002D9E                 mov     [ebp+var_FEC], eax
.text$mn:00002DA4                 mov     eax, [ebp+var_FEC]
.text$mn:00002DAA                 mov     [ebp+var_1094], eax
.text$mn:00002DB0                 mov     byte ptr [ebp+var_4], 1Ah
.text$mn:00002DB4                 mov     ecx, [ebp+var_1094]
.text$mn:00002DBA                 push    ecx
.text$mn:00002DBB                 lea     ecx, [ebp+var_E98]
.text$mn:00002DC1                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002DC6                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002DCA                 lea     ecx, [ebp+var_B70] ; this
.text$mn:00002DD0                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002DD5                 push    0               ; wchar_t *
.text$mn:00002DD7                 push    offset $SG172759 ; "Full File Path to Clipboard"
.text$mn:00002DDC                 push    0A42Dh          ; unsigned __int32
.text$mn:00002DE1                 lea     ecx, [ebp+var_BE8] ; this
.text$mn:00002DE7                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002DEC                 mov     [ebp+var_FF4], eax
.text$mn:00002DF2                 mov     edx, [ebp+var_FF4]
.text$mn:00002DF8                 mov     [ebp+var_1124], edx
.text$mn:00002DFE                 mov     byte ptr [ebp+var_4], 1Bh
.text$mn:00002E02                 mov     eax, [ebp+var_1124]
.text$mn:00002E08                 push    eax
.text$mn:00002E09                 lea     ecx, [ebp+var_E98]
.text$mn:00002E0F                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002E14                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002E18                 lea     ecx, [ebp+var_BE8] ; this
.text$mn:00002E1E                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002E23                 push    0               ; wchar_t *
.text$mn:00002E25                 push    offset $SG172761 ; "Filename to Clipboard"
.text$mn:00002E2A                 push    0A42Eh          ; unsigned __int32
.text$mn:00002E2F                 lea     ecx, [ebp+var_C60] ; this
.text$mn:00002E35                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002E3A                 mov     [ebp+var_FFC], eax
.text$mn:00002E40                 mov     ecx, [ebp+var_FFC]
.text$mn:00002E46                 mov     [ebp+var_109C], ecx
.text$mn:00002E4C                 mov     byte ptr [ebp+var_4], 1Ch
.text$mn:00002E50                 mov     edx, [ebp+var_109C]
.text$mn:00002E56                 push    edx
.text$mn:00002E57                 lea     ecx, [ebp+var_E98]
.text$mn:00002E5D                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002E62                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002E66                 lea     ecx, [ebp+var_C60] ; this
.text$mn:00002E6C                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002E71                 push    0               ; wchar_t *
.text$mn:00002E73                 push    offset $SG172763 ; "Current Dir. Path to Clipboard"
.text$mn:00002E78                 push    0A42Fh          ; unsigned __int32
.text$mn:00002E7D                 lea     ecx, [ebp+var_CD8] ; this
.text$mn:00002E83                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002E88                 mov     [ebp+var_1004], eax
.text$mn:00002E8E                 mov     eax, [ebp+var_1004]
.text$mn:00002E94                 mov     [ebp+var_10EC], eax
.text$mn:00002E9A                 mov     byte ptr [ebp+var_4], 1Dh
.text$mn:00002E9E                 mov     ecx, [ebp+var_10EC]
.text$mn:00002EA4                 push    ecx
.text$mn:00002EA5                 lea     ecx, [ebp+var_E98]
.text$mn:00002EAB                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002EB0                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002EB4                 lea     ecx, [ebp+var_CD8] ; this
.text$mn:00002EBA                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002EBF                 push    0               ; wchar_t *
.text$mn:00002EC1                 push    0               ; wchar_t *
.text$mn:00002EC3                 push    0               ; unsigned __int32
.text$mn:00002EC5                 lea     ecx, [ebp+var_D50] ; this
.text$mn:00002ECB                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002ED0                 mov     [ebp+var_100C], eax
.text$mn:00002ED6                 mov     edx, [ebp+var_100C]
.text$mn:00002EDC                 mov     [ebp+var_10A4], edx
.text$mn:00002EE2                 mov     byte ptr [ebp+var_4], 1Eh
.text$mn:00002EE6                 mov     eax, [ebp+var_10A4]
.text$mn:00002EEC                 push    eax
.text$mn:00002EED                 lea     ecx, [ebp+var_E98]
.text$mn:00002EF3                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002EF8                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002EFC                 lea     ecx, [ebp+var_D50] ; this
.text$mn:00002F02                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002F07                 push    0               ; wchar_t *
.text$mn:00002F09                 push    offset $SG172766 ; "Move to Other View"
.text$mn:00002F0E                 push    2711h           ; unsigned __int32
.text$mn:00002F13                 lea     ecx, [ebp+var_DC8] ; this
.text$mn:00002F19                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002F1E                 mov     [ebp+var_1014], eax
.text$mn:00002F24                 mov     ecx, [ebp+var_1014]
.text$mn:00002F2A                 mov     [ebp+var_1114], ecx
.text$mn:00002F30                 mov     byte ptr [ebp+var_4], 1Fh
.text$mn:00002F34                 mov     edx, [ebp+var_1114]
.text$mn:00002F3A                 push    edx
.text$mn:00002F3B                 lea     ecx, [ebp+var_E98]
.text$mn:00002F41                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002F46                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002F4A                 lea     ecx, [ebp+var_DC8] ; this
.text$mn:00002F50                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002F55                 push    0               ; wchar_t *
.text$mn:00002F57                 push    offset $SG172768 ; "Clone to Other View"
.text$mn:00002F5C                 push    2712h           ; unsigned __int32
.text$mn:00002F61                 lea     ecx, [ebp+var_E40] ; this
.text$mn:00002F67                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002F6C                 mov     [ebp+var_101C], eax
.text$mn:00002F72                 mov     eax, [ebp+var_101C]
.text$mn:00002F78                 mov     [ebp+var_10AC], eax
.text$mn:00002F7E                 mov     byte ptr [ebp+var_4], 20h ; ' '
.text$mn:00002F82                 mov     ecx, [ebp+var_10AC]
.text$mn:00002F88                 push    ecx
.text$mn:00002F89                 lea     ecx, [ebp+var_E98]
.text$mn:00002F8F                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002F94                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002F98                 lea     ecx, [ebp+var_E40] ; this
.text$mn:00002F9E                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002FA3                 push    0               ; wchar_t *
.text$mn:00002FA5                 push    offset $SG172770 ; "Move to New Instance"
.text$mn:00002FAA                 push    2713h           ; unsigned __int32
.text$mn:00002FAF                 lea     ecx, [ebp+var_864] ; this
.text$mn:00002FB5                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00002FBA                 mov     [ebp+var_1024], eax
.text$mn:00002FC0                 mov     edx, [ebp+var_1024]
.text$mn:00002FC6                 mov     [ebp+var_10F4], edx
.text$mn:00002FCC                 mov     byte ptr [ebp+var_4], 21h ; '!'
.text$mn:00002FD0                 mov     eax, [ebp+var_10F4]
.text$mn:00002FD6                 push    eax
.text$mn:00002FD7                 lea     ecx, [ebp+var_E98]
.text$mn:00002FDD                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00002FE2                 mov     byte ptr [ebp+var_4], 9
.text$mn:00002FE6                 lea     ecx, [ebp+var_864] ; this
.text$mn:00002FEC                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:00002FF1                 push    0               ; wchar_t *
.text$mn:00002FF3                 push    offset $SG172772 ; "Open in New Instance"
.text$mn:00002FF8                 push    2714h           ; unsigned __int32
.text$mn:00002FFD                 lea     ecx, [ebp+var_C24] ; this
.text$mn:00003003                 call    ??0MenuItemUnit@@QAE@KPB_W0@Z ; MenuItemUnit::MenuItemUnit(ulong,wchar_t const *,wchar_t const *)
.text$mn:00003008                 mov     [ebp+var_102C], eax
.text$mn:0000300E                 mov     ecx, [ebp+var_102C]
.text$mn:00003014                 mov     [ebp+var_10B4], ecx
.text$mn:0000301A                 mov     byte ptr [ebp+var_4], 22h ; '"'
.text$mn:0000301E                 mov     edx, [ebp+var_10B4]
.text$mn:00003024                 push    edx
.text$mn:00003025                 lea     ecx, [ebp+var_E98]
.text$mn:0000302B                 call    ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)
.text$mn:00003030                 mov     byte ptr [ebp+var_4], 9
.text$mn:00003034                 lea     ecx, [ebp+var_C24] ; this
.text$mn:0000303A                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:0000303F                 push    0
.text$mn:00003041                 lea     eax, [ebp+var_E98]
.text$mn:00003047                 push    eax
.text$mn:00003048                 mov     ecx, [ebp+var_E44]
.text$mn:0000304E                 mov     ecx, [ecx+4]    ; this
.text$mn:00003051                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00003056                 push    eax
.text$mn:00003057                 mov     ecx, [ebp+var_E44]
.text$mn:0000305D                 add     ecx, 668h
.text$mn:00003063                 call    ?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z ; ContextMenu::create(HWND__ *,std::vector<MenuItemUnit,std::allocator<MenuItemUnit>> const &,HMENU__ * const)
.text$mn:00003068                 mov     ecx, [ebp+var_E44]
.text$mn:0000306E                 add     ecx, 668h       ; this
.text$mn:00003074                 call    ?getMenuHandle@ContextMenu@@QAEPAUHMENU__@@XZ ; ContextMenu::getMenuHandle(void)
.text$mn:00003079                 push    eax             ; HMENU
.text$mn:0000307A                 mov     ecx, [ebp+var_E44]
.text$mn:00003080                 add     ecx, 34Ch       ; this
.text$mn:00003086                 call    ?changeLangTabContextMenu@NativeLangSpeaker@@QAEXPAUHMENU__@@@Z ; NativeLangSpeaker::changeLangTabContextMenu(HMENU__ *)
.text$mn:0000308B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003092                 lea     ecx, [ebp+var_E98]
.text$mn:00003098                 call    ??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::~vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)
.text$mn:0000309D
.text$mn:0000309D loc_309D:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+147Dj
.text$mn:0000309D                 push    0               ; uFlags
.text$mn:0000309F                 push    0A02Eh          ; uId
.text$mn:000030A4                 mov     edx, [ebp+var_E44]
.text$mn:000030AA                 mov     eax, [edx+54AE8h]
.text$mn:000030B0                 push    eax             ; hMenu
.text$mn:000030B1                 call    dword ptr ds:__imp__GetMenuState@12 ; GetMenuState(x,x,x)
.text$mn:000030B7                 and     eax, 2
.text$mn:000030BA                 jnz     short loc_30C8
.text$mn:000030BC                 mov     [ebp+var_F58], 1
.text$mn:000030C6                 jmp     short loc_30D2
.text$mn:000030C8 ; ---------------------------------------------------------------------------
.text$mn:000030C8
.text$mn:000030C8 loc_30C8:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1C96j
.text$mn:000030C8                 mov     [ebp+var_F58], 0
.text$mn:000030D2
.text$mn:000030D2 loc_30D2:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1CA2j
.text$mn:000030D2                 mov     cl, byte ptr [ebp+var_F58]
.text$mn:000030D8                 mov     [ebp+var_E7C], cl
.text$mn:000030DE                 movzx   edx, [ebp+var_E7C]
.text$mn:000030E5                 push    edx             ; bool
.text$mn:000030E6                 push    0A02Eh          ; uIDEnableItem
.text$mn:000030EB                 mov     ecx, [ebp+var_E44]
.text$mn:000030F1                 add     ecx, 668h       ; this
.text$mn:000030F7                 call    ?enableItem@ContextMenu@@QBEXH_N@Z ; ContextMenu::enableItem(int,bool)
.text$mn:000030FC                 mov     eax, [ebp+var_E44]
.text$mn:00003102                 mov     ecx, [eax+5D4h] ; this
.text$mn:00003108                 call    ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBuffer(void)
.text$mn:0000310D                 mov     [ebp+var_EA8], eax
.text$mn:00003113                 mov     ecx, [ebp+var_EA8] ; this
.text$mn:00003119                 call    ?getUserReadOnly@Buffer@@QBE_NXZ ; Buffer::getUserReadOnly(void)
.text$mn:0000311E                 mov     [ebp+var_E7E], al
.text$mn:00003124                 movzx   ecx, [ebp+var_E7E]
.text$mn:0000312B                 push    ecx             ; bool
.text$mn:0000312C                 push    0A42Ch          ; uIDCheckItem
.text$mn:00003131                 mov     ecx, [ebp+var_E44]
.text$mn:00003137                 add     ecx, 668h       ; this
.text$mn:0000313D                 call    ?checkItem@ContextMenu@@QBEXH_N@Z ; ContextMenu::checkItem(int,bool)
.text$mn:00003142                 mov     ecx, [ebp+var_EA8] ; this
.text$mn:00003148                 call    ?getFileReadOnly@Buffer@@QBE_NXZ ; Buffer::getFileReadOnly(void)
.text$mn:0000314D                 mov     [ebp+var_E59], al
.text$mn:00003153                 movzx   edx, [ebp+var_E59]
.text$mn:0000315A                 test    edx, edx
.text$mn:0000315C                 jnz     short loc_3167
.text$mn:0000315E                 mov     [ebp+var_E5B], 1
.text$mn:00003165                 jmp     short loc_316E
.text$mn:00003167 ; ---------------------------------------------------------------------------
.text$mn:00003167
.text$mn:00003167 loc_3167:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1D38j
.text$mn:00003167                 mov     [ebp+var_E5B], 0
.text$mn:0000316E
.text$mn:0000316E loc_316E:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1D41j
.text$mn:0000316E                 movzx   eax, [ebp+var_E5B]
.text$mn:00003175                 push    eax             ; bool
.text$mn:00003176                 push    0A42Ch          ; uIDEnableItem
.text$mn:0000317B                 mov     ecx, [ebp+var_E44]
.text$mn:00003181                 add     ecx, 668h       ; this
.text$mn:00003187                 call    ?enableItem@ContextMenu@@QBEXH_N@Z ; ContextMenu::enableItem(int,bool)
.text$mn:0000318C                 movzx   ecx, [ebp+var_E59]
.text$mn:00003193                 push    ecx             ; bool
.text$mn:00003194                 push    0A431h          ; uIDEnableItem
.text$mn:00003199                 mov     ecx, [ebp+var_E44]
.text$mn:0000319F                 add     ecx, 668h       ; this
.text$mn:000031A5                 call    ?enableItem@ContextMenu@@QBEXH_N@Z ; ContextMenu::enableItem(int,bool)
.text$mn:000031AA                 mov     ecx, [ebp+var_EA8] ; this
.text$mn:000031B0                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:000031B5                 push    eax             ; pszPath
.text$mn:000031B6                 call    dword ptr ds:__imp__PathFileExistsW@4 ; PathFileExistsW(x)
.text$mn:000031BC                 test    eax, eax
.text$mn:000031BE                 jz      short loc_31CC
.text$mn:000031C0                 mov     [ebp+var_F60], 1
.text$mn:000031CA                 jmp     short loc_31D6
.text$mn:000031CC ; ---------------------------------------------------------------------------
.text$mn:000031CC
.text$mn:000031CC loc_31CC:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1D9Aj
.text$mn:000031CC                 mov     [ebp+var_F60], 0
.text$mn:000031D6
.text$mn:000031D6 loc_31D6:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1DA6j
.text$mn:000031D6                 mov     dl, byte ptr [ebp+var_F60]
.text$mn:000031DC                 mov     [ebp+var_E5A], dl
.text$mn:000031E2                 movzx   eax, [ebp+var_E5A]
.text$mn:000031E9                 push    eax             ; bool
.text$mn:000031EA                 push    0A038h          ; uIDEnableItem
.text$mn:000031EF                 mov     ecx, [ebp+var_E44]
.text$mn:000031F5                 add     ecx, 668h       ; this
.text$mn:000031FB                 call    ?enableItem@ContextMenu@@QBEXH_N@Z ; ContextMenu::enableItem(int,bool)
.text$mn:00003200                 movzx   ecx, [ebp+var_E5A]
.text$mn:00003207                 push    ecx             ; bool
.text$mn:00003208                 push    0A039h          ; uIDEnableItem
.text$mn:0000320D                 mov     ecx, [ebp+var_E44]
.text$mn:00003213                 add     ecx, 668h       ; this
.text$mn:00003219                 call    ?enableItem@ContextMenu@@QBEXH_N@Z ; ContextMenu::enableItem(int,bool)
.text$mn:0000321E                 mov     ecx, [ebp+var_EA8] ; this
.text$mn:00003224                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:00003229                 mov     [ebp+var_E5F], al
.text$mn:0000322F                 mov     ecx, [ebp+var_EA8] ; this
.text$mn:00003235                 call    ?isUntitled@Buffer@@QBE_NXZ ; Buffer::isUntitled(void)
.text$mn:0000323A                 mov     [ebp+var_E5C], al
.text$mn:00003240                 movzx   edx, [ebp+var_E5F]
.text$mn:00003247                 test    edx, edx
.text$mn:00003249                 jnz     short loc_325F
.text$mn:0000324B                 movzx   eax, [ebp+var_E5C]
.text$mn:00003252                 test    eax, eax
.text$mn:00003254                 jnz     short loc_325F
.text$mn:00003256                 mov     [ebp+var_E5D], 1
.text$mn:0000325D                 jmp     short loc_3266
.text$mn:0000325F ; ---------------------------------------------------------------------------
.text$mn:0000325F
.text$mn:0000325F loc_325F:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1E25j
.text$mn:0000325F                                         ; Notepad_plus::notify(SCNotification *)+1E30j
.text$mn:0000325F                 mov     [ebp+var_E5D], 0
.text$mn:00003266
.text$mn:00003266 loc_3266:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1E39j
.text$mn:00003266                 movzx   ecx, [ebp+var_E5D]
.text$mn:0000326D                 push    ecx             ; bool
.text$mn:0000326E                 push    2713h           ; uIDEnableItem
.text$mn:00003273                 mov     ecx, [ebp+var_E44]
.text$mn:00003279                 add     ecx, 668h       ; this
.text$mn:0000327F                 call    ?enableItem@ContextMenu@@QBEXH_N@Z ; ContextMenu::enableItem(int,bool)
.text$mn:00003284                 movzx   edx, [ebp+var_E5F]
.text$mn:0000328B                 test    edx, edx
.text$mn:0000328D                 jnz     short loc_32A3
.text$mn:0000328F                 movzx   eax, [ebp+var_E5C]
.text$mn:00003296                 test    eax, eax
.text$mn:00003298                 jnz     short loc_32A3
.text$mn:0000329A                 mov     [ebp+var_E5E], 1
.text$mn:000032A1                 jmp     short loc_32AA
.text$mn:000032A3 ; ---------------------------------------------------------------------------
.text$mn:000032A3
.text$mn:000032A3 loc_32A3:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1E69j
.text$mn:000032A3                                         ; Notepad_plus::notify(SCNotification *)+1E74j
.text$mn:000032A3                 mov     [ebp+var_E5E], 0
.text$mn:000032AA
.text$mn:000032AA loc_32AA:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1E7Dj
.text$mn:000032AA                 movzx   ecx, [ebp+var_E5E]
.text$mn:000032B1                 push    ecx             ; bool
.text$mn:000032B2                 push    2714h           ; uIDEnableItem
.text$mn:000032B7                 mov     ecx, [ebp+var_E44]
.text$mn:000032BD                 add     ecx, 668h       ; this
.text$mn:000032C3                 call    ?enableItem@ContextMenu@@QBEXH_N@Z ; ContextMenu::enableItem(int,bool)
.text$mn:000032C8                 lea     edx, [ebp+var_1158]
.text$mn:000032CE                 push    edx             ; struct tagPOINT *
.text$mn:000032CF                 mov     ecx, [ebp+var_E44]
.text$mn:000032D5                 add     ecx, 668h       ; this
.text$mn:000032DB                 call    ?display@ContextMenu@@QBEXABUtagPOINT@@@Z ; ContextMenu::display(tagPOINT const &)
.text$mn:000032E0                 mov     eax, 1
.text$mn:000032E5                 jmp     loc_4795
.text$mn:000032EA ; ---------------------------------------------------------------------------
.text$mn:000032EA
.text$mn:000032EA $LN106:                                 ; CODE XREF: Notepad_plus::notify(SCNotification *)+1C1j
.text$mn:000032EA                                         ; DATA XREF: .text$mn:$LN305o
.text$mn:000032EA                 mov     ecx, [ebp+var_E44] ; jumptable 000015E5 case 9
.text$mn:000032F0                 add     ecx, 4C0h       ; this
.text$mn:000032F6                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000032FB                 mov     ecx, [ebp+arg_0]
.text$mn:000032FE                 cmp     [ecx], eax
.text$mn:00003300                 jnz     short loc_3311
.text$mn:00003302                 push    0               ; int
.text$mn:00003304                 mov     ecx, [ebp+var_E44] ; this
.text$mn:0000330A                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:0000330F                 jmp     short loc_3336
.text$mn:00003311 ; ---------------------------------------------------------------------------
.text$mn:00003311
.text$mn:00003311 loc_3311:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1EDCj
.text$mn:00003311                 mov     ecx, [ebp+var_E44]
.text$mn:00003317                 add     ecx, 464h       ; this
.text$mn:0000331D                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00003322                 mov     edx, [ebp+arg_0]
.text$mn:00003325                 cmp     [edx], eax
.text$mn:00003327                 jnz     short loc_3336
.text$mn:00003329                 push    1               ; int
.text$mn:0000332B                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00003331                 call    ?switchEditViewTo@Notepad_plus@@AAEHH@Z ; Notepad_plus::switchEditViewTo(int)
.text$mn:00003336
.text$mn:00003336 loc_3336:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1EEBj
.text$mn:00003336                                         ; Notepad_plus::notify(SCNotification *)+1F03j
.text$mn:00003336                 push    0               ; __int32
.text$mn:00003338                 mov     eax, [ebp+arg_0]
.text$mn:0000333B                 mov     ecx, [eax+0Ch]
.text$mn:0000333E                 push    ecx             ; unsigned int
.text$mn:0000333F                 push    876h            ; unsigned int
.text$mn:00003344                 mov     edx, [ebp+var_E44]
.text$mn:0000334A                 mov     ecx, [edx+5D4h] ; this
.text$mn:00003350                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003355                 mov     [ebp+var_EE0], eax
.text$mn:0000335B                 mov     eax, [ebp+arg_0]
.text$mn:0000335E                 mov     ecx, [eax+40h]
.text$mn:00003361                 cmp     ecx, dword ptr ds:?_SC_MARGE_FOLDER@ScintillaEditView@@2HB ; int const ScintillaEditView::_SC_MARGE_FOLDER
.text$mn:00003367                 jnz     short loc_33CD
.text$mn:00003369                 mov     edx, [ebp+arg_0]
.text$mn:0000336C                 mov     eax, [edx+14h]
.text$mn:0000336F                 push    eax             ; int
.text$mn:00003370                 mov     ecx, [ebp+arg_0]
.text$mn:00003373                 mov     edx, [ecx+0Ch]
.text$mn:00003376                 push    edx             ; int
.text$mn:00003377                 mov     eax, [ebp+var_E44]
.text$mn:0000337D                 mov     ecx, [eax+5D4h] ; this
.text$mn:00003383                 call    ?marginClick@ScintillaEditView@@QAEXHH@Z ; ScintillaEditView::marginClick(int,int)
.text$mn:00003388                 mov     ecx, [ebp+var_E44]
.text$mn:0000338E                 cmp     dword ptr [ecx+551BCh], 0
.text$mn:00003395                 jz      short loc_33CB
.text$mn:00003397                 mov     edx, [ebp+var_EE0]
.text$mn:0000339D                 push    edx             ; int
.text$mn:0000339E                 mov     eax, [ebp+var_E44]
.text$mn:000033A4                 mov     ecx, [eax+5D4h] ; this
.text$mn:000033AA                 call    ?isFolded@ScintillaEditView@@QAE_NH@Z ; ScintillaEditView::isFolded(int)
.text$mn:000033AF                 movzx   ecx, al
.text$mn:000033B2                 push    ecx             ; bool
.text$mn:000033B3                 mov     edx, [ebp+var_EE0]
.text$mn:000033B9                 push    edx             ; int
.text$mn:000033BA                 mov     eax, [ebp+var_E44]
.text$mn:000033C0                 mov     ecx, [eax+551BCh] ; this
.text$mn:000033C6                 call    ?fold@DocumentMap@@QAEXH_N@Z ; DocumentMap::fold(int,bool)
.text$mn:000033CB
.text$mn:000033CB loc_33CB:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1F71j
.text$mn:000033CB                 jmp     short loc_3415
.text$mn:000033CD ; ---------------------------------------------------------------------------
.text$mn:000033CD
.text$mn:000033CD loc_33CD:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1F43j
.text$mn:000033CD                 mov     ecx, [ebp+arg_0]
.text$mn:000033D0                 mov     edx, [ecx+40h]
.text$mn:000033D3                 cmp     edx, dword ptr ds:?_SC_MARGE_SYBOLE@ScintillaEditView@@2HB ; int const ScintillaEditView::_SC_MARGE_SYBOLE
.text$mn:000033D9                 jnz     short loc_3415
.text$mn:000033DB                 mov     eax, [ebp+arg_0]
.text$mn:000033DE                 cmp     dword ptr [eax+14h], 0
.text$mn:000033E2                 jnz     short loc_3415
.text$mn:000033E4                 mov     ecx, [ebp+var_EE0]
.text$mn:000033EA                 push    ecx             ; int
.text$mn:000033EB                 mov     edx, [ebp+var_E44]
.text$mn:000033F1                 mov     ecx, [edx+5D4h] ; this
.text$mn:000033F7                 call    ?markerMarginClick@ScintillaEditView@@QAE_NH@Z ; ScintillaEditView::markerMarginClick(int)
.text$mn:000033FC                 movzx   eax, al
.text$mn:000033FF                 test    eax, eax
.text$mn:00003401                 jnz     short loc_3415
.text$mn:00003403                 mov     ecx, [ebp+var_EE0]
.text$mn:00003409                 push    ecx             ; int
.text$mn:0000340A                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00003410                 call    ?bookmarkToggle@Notepad_plus@@ABEXH@Z ; Notepad_plus::bookmarkToggle(int)
.text$mn:00003415
.text$mn:00003415 loc_3415:                               ; CODE XREF: Notepad_plus::notify(SCNotification *):loc_33CBj
.text$mn:00003415                                         ; Notepad_plus::notify(SCNotification *)+1FB5j ...
.text$mn:00003415                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:0000341A ; ---------------------------------------------------------------------------
.text$mn:0000341A
.text$mn:0000341A loc_341A:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+20Ej
.text$mn:0000341A                 mov     ecx, [ebp+var_E44]
.text$mn:00003420                 add     ecx, 4C0h       ; this
.text$mn:00003426                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:0000342B                 mov     edx, [ebp+arg_0]
.text$mn:0000342E                 cmp     [edx], eax
.text$mn:00003430                 jz      short loc_344E
.text$mn:00003432                 mov     ecx, [ebp+var_E44]
.text$mn:00003438                 add     ecx, 464h       ; this
.text$mn:0000343E                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00003443                 mov     ecx, [ebp+arg_0]
.text$mn:00003446                 cmp     [ecx], eax
.text$mn:00003448                 jnz     loc_34E0
.text$mn:0000344E
.text$mn:0000344E loc_344E:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+200Cj
.text$mn:0000344E                 mov     edx, [ebp+arg_0]
.text$mn:00003451                 mov     eax, [edx+34h]
.text$mn:00003454                 mov     [ebp+var_F70], eax
.text$mn:0000345A                 mov     ecx, [ebp+var_E44]
.text$mn:00003460                 movzx   edx, byte ptr [ecx+54B6Ah]
.text$mn:00003467                 test    edx, edx
.text$mn:00003469                 jnz     short loc_349D
.text$mn:0000346B                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00003470                 mov     ecx, eax        ; this
.text$mn:00003472                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00003477                 mov     eax, [eax+4Ch]
.text$mn:0000347A                 mov     [ebp+var_F68], eax
.text$mn:00003480                 cmp     [ebp+var_F68], 1
.text$mn:00003487                 jz      short loc_3492
.text$mn:00003489                 cmp     [ebp+var_F68], 2
.text$mn:00003490                 jnz     short loc_349D
.text$mn:00003492
.text$mn:00003492 loc_3492:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2063j
.text$mn:00003492                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00003498                 call    ?addHotSpot@Notepad_plus@@AAEXXZ ; Notepad_plus::addHotSpot(void)
.text$mn:0000349D
.text$mn:0000349D loc_349D:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2045j
.text$mn:0000349D                                         ; Notepad_plus::notify(SCNotification *)+206Cj
.text$mn:0000349D                 mov     ecx, [ebp+var_E44]
.text$mn:000034A3                 cmp     dword ptr [ecx+551BCh], 0
.text$mn:000034AA                 jz      short loc_34E0
.text$mn:000034AC                 mov     edx, [ebp+var_F70]
.text$mn:000034B2                 push    edx             ; int
.text$mn:000034B3                 mov     eax, [ebp+var_E44]
.text$mn:000034B9                 mov     ecx, [eax+5D4h] ; this
.text$mn:000034BF                 call    ?isFolded@ScintillaEditView@@QAE_NH@Z ; ScintillaEditView::isFolded(int)
.text$mn:000034C4                 movzx   ecx, al
.text$mn:000034C7                 push    ecx             ; bool
.text$mn:000034C8                 mov     edx, [ebp+var_F70]
.text$mn:000034CE                 push    edx             ; int
.text$mn:000034CF                 mov     eax, [ebp+var_E44]
.text$mn:000034D5                 mov     ecx, [eax+551BCh] ; this
.text$mn:000034DB                 call    ?fold@DocumentMap@@QAEXH_N@Z ; DocumentMap::fold(int,bool)
.text$mn:000034E0
.text$mn:000034E0 loc_34E0:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2024j
.text$mn:000034E0                                         ; Notepad_plus::notify(SCNotification *)+2086j
.text$mn:000034E0                 mov     eax, 1
.text$mn:000034E5                 jmp     loc_4795
.text$mn:000034EA ; ---------------------------------------------------------------------------
.text$mn:000034EA
.text$mn:000034EA $LN90:                                  ; CODE XREF: Notepad_plus::notify(SCNotification *)+1C1j
.text$mn:000034EA                                         ; DATA XREF: .text$mn:$LN305o
.text$mn:000034EA                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; jumptable 000015E5 case 0
.text$mn:000034EF                 mov     ecx, eax        ; this
.text$mn:000034F1                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:000034F6                 mov     [ebp+var_EF4], eax
.text$mn:000034FC                 mov     ecx, [ebp+var_EF4]
.text$mn:00003502                 mov     dl, [ecx+3Eh]
.text$mn:00003505                 mov     [ebp+var_E80], dl
.text$mn:0000350B                 movzx   eax, [ebp+var_E80]
.text$mn:00003512                 test    eax, eax
.text$mn:00003514                 jz      short loc_3529
.text$mn:00003516                 mov     ecx, [ebp+arg_0]
.text$mn:00003519                 movzx   edx, word ptr [ecx+10h]
.text$mn:0000351D                 push    edx             ; wchar_t
.text$mn:0000351E                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00003524                 call    ?maintainIndentation@Notepad_plus@@AAEX_W@Z ; Notepad_plus::maintainIndentation(wchar_t)
.text$mn:00003529
.text$mn:00003529 loc_3529:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+20F0j
.text$mn:00003529                 movzx   eax, [ebp+var_E45]
.text$mn:00003530                 test    eax, eax
.text$mn:00003532                 jz      short loc_3548
.text$mn:00003534                 mov     ecx, [ebp+var_E44]
.text$mn:0000353A                 add     ecx, 198h
.text$mn:00003540                 mov     [ebp+var_F78], ecx
.text$mn:00003546                 jmp     short loc_355A
.text$mn:00003548 ; ---------------------------------------------------------------------------
.text$mn:00003548
.text$mn:00003548 loc_3548:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+210Ej
.text$mn:00003548                 mov     edx, [ebp+var_E44]
.text$mn:0000354E                 add     edx, 270h
.text$mn:00003554                 mov     [ebp+var_F78], edx
.text$mn:0000355A
.text$mn:0000355A loc_355A:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2122j
.text$mn:0000355A                 mov     eax, [ebp+var_F78]
.text$mn:00003560                 mov     [ebp+var_F88], eax
.text$mn:00003566                 push    0               ; __int32
.text$mn:00003568                 push    0               ; unsigned int
.text$mn:0000356A                 push    0A0Ah           ; unsigned int
.text$mn:0000356F                 mov     ecx, [ebp+var_E44]
.text$mn:00003575                 mov     ecx, [ecx+5D4h] ; this
.text$mn:0000357B                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003580                 cmp     eax, 1
.text$mn:00003583                 jle     short loc_3591
.text$mn:00003585                 mov     [ebp+var_F80], 1
.text$mn:0000358F                 jmp     short loc_359B
.text$mn:00003591 ; ---------------------------------------------------------------------------
.text$mn:00003591
.text$mn:00003591 loc_3591:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+215Fj
.text$mn:00003591                 mov     [ebp+var_F80], 0
.text$mn:0000359B
.text$mn:0000359B loc_359B:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+216Bj
.text$mn:0000359B                 mov     dl, byte ptr [ebp+var_F80]
.text$mn:000035A1                 mov     [ebp+var_E82], dl
.text$mn:000035A7                 mov     ecx, [ebp+var_EF4]
.text$mn:000035AD                 add     ecx, 1F8h       ; this
.text$mn:000035B3                 call    ?hasAnyPairsPair@MatchedPairConf@@QBE_NXZ ; MatchedPairConf::hasAnyPairsPair(void)
.text$mn:000035B8                 movzx   eax, al
.text$mn:000035BB                 test    eax, eax
.text$mn:000035BD                 jz      short loc_35E9
.text$mn:000035BF                 movzx   ecx, [ebp+var_E82]
.text$mn:000035C6                 test    ecx, ecx
.text$mn:000035C8                 jnz     short loc_35E9
.text$mn:000035CA                 mov     edx, [ebp+var_EF4]
.text$mn:000035D0                 add     edx, 1F8h
.text$mn:000035D6                 push    edx             ; struct MatchedPairConf *
.text$mn:000035D7                 mov     eax, [ebp+arg_0]
.text$mn:000035DA                 mov     ecx, [eax+10h]
.text$mn:000035DD                 push    ecx             ; int
.text$mn:000035DE                 mov     ecx, [ebp+var_F88] ; this
.text$mn:000035E4                 call    ?insertMatchedChars@AutoCompletion@@QAEXHABUMatchedPairConf@@@Z ; AutoCompletion::insertMatchedChars(int,MatchedPairConf const &)
.text$mn:000035E9
.text$mn:000035E9 loc_35E9:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2199j
.text$mn:000035E9                                         ; Notepad_plus::notify(SCNotification *)+21A4j
.text$mn:000035E9                 mov     edx, [ebp+arg_0]
.text$mn:000035EC                 mov     eax, [edx+10h]
.text$mn:000035EF                 push    eax             ; int
.text$mn:000035F0                 mov     ecx, [ebp+var_F88] ; this
.text$mn:000035F6                 call    ?update@AutoCompletion@@QAEXH@Z ; AutoCompletion::update(int)
.text$mn:000035FB                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:00003600 ; ---------------------------------------------------------------------------
.text$mn:00003600
.text$mn:00003600 $LN87:                                  ; CODE XREF: Notepad_plus::notify(SCNotification *)+1C1j
.text$mn:00003600                                         ; DATA XREF: .text$mn:$LN305o
.text$mn:00003600                 mov     ecx, [ebp+arg_0] ; jumptable 000015E5 case 5
.text$mn:00003603                 cmp     dword ptr [ecx+14h], 2
.text$mn:00003607                 jnz     loc_3B83
.text$mn:0000360D                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00003612                 mov     ecx, eax        ; this
.text$mn:00003614                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00003619                 mov     [ebp+var_E64], eax
.text$mn:0000361F                 lea     ecx, [ebp+var_6E4]
.text$mn:00003625                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:0000362A                 mov     [ebp+var_4], 23h ; '#'
.text$mn:00003631                 mov     edx, [ebp+arg_0]
.text$mn:00003634                 cmp     dword ptr [edx+0Ch], 0FFFFFFFFh
.text$mn:00003638                 jz      short loc_3648
.text$mn:0000363A                 mov     eax, [ebp+arg_0]
.text$mn:0000363D                 mov     ecx, [eax+0Ch]
.text$mn:00003640                 mov     [ebp+var_E78], ecx
.text$mn:00003646                 jmp     short loc_3668
.text$mn:00003648 ; ---------------------------------------------------------------------------
.text$mn:00003648
.text$mn:00003648 loc_3648:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2214j
.text$mn:00003648                 push    0               ; __int32
.text$mn:0000364A                 push    0               ; unsigned int
.text$mn:0000364C                 push    7D8h            ; unsigned int
.text$mn:00003651                 mov     edx, [ebp+var_E44]
.text$mn:00003657                 mov     ecx, [edx+5D4h] ; this
.text$mn:0000365D                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003662                 mov     [ebp+var_E78], eax
.text$mn:00003668
.text$mn:00003668 loc_3668:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2222j
.text$mn:00003668                 mov     eax, [ebp+var_E64]
.text$mn:0000366E                 movzx   ecx, byte ptr [eax+48h]
.text$mn:00003672                 test    ecx, ecx
.text$mn:00003674                 jz      short loc_36DA
.text$mn:00003676                 push    0               ; __int32
.text$mn:00003678                 push    0               ; unsigned int
.text$mn:0000367A                 push    7D6h            ; unsigned int
.text$mn:0000367F                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00003685                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000368A                 mov     [ebp+var_EB0], eax
.text$mn:00003690                 mov     edx, [ebp+var_EB0]
.text$mn:00003696                 add     edx, 1
.text$mn:00003699                 push    edx             ; unsigned int
.text$mn:0000369A                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:0000369F                 add     esp, 4
.text$mn:000036A2                 mov     [ebp+var_1034], eax
.text$mn:000036A8                 mov     eax, [ebp+var_1034]
.text$mn:000036AE                 mov     [ebp+Str], eax
.text$mn:000036B4                 mov     ecx, [ebp+Str]
.text$mn:000036BA                 push    ecx             ; __int32
.text$mn:000036BB                 mov     edx, [ebp+var_EB0]
.text$mn:000036C1                 add     edx, 1
.text$mn:000036C4                 push    edx             ; unsigned int
.text$mn:000036C5                 push    886h            ; unsigned int
.text$mn:000036CA                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:000036D0                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000036D5                 jmp     loc_376C
.text$mn:000036DA ; ---------------------------------------------------------------------------
.text$mn:000036DA
.text$mn:000036DA loc_36DA:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2250j
.text$mn:000036DA                 push    0               ; __int32
.text$mn:000036DC                 push    0               ; unsigned int
.text$mn:000036DE                 push    7EBh            ; unsigned int
.text$mn:000036E3                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:000036E9                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000036EE                 mov     [ebp+var_EB0], eax
.text$mn:000036F4                 mov     eax, [ebp+var_EB0]
.text$mn:000036FA                 add     eax, 1
.text$mn:000036FD                 push    eax             ; unsigned int
.text$mn:000036FE                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00003703                 add     esp, 4
.text$mn:00003706                 mov     [ebp+var_1134], eax
.text$mn:0000370C                 mov     ecx, [ebp+var_1134]
.text$mn:00003712                 mov     [ebp+Str], ecx
.text$mn:00003718                 mov     edx, [ebp+Str]
.text$mn:0000371E                 push    edx             ; __int32
.text$mn:0000371F                 mov     eax, [ebp+var_EB0]
.text$mn:00003725                 push    eax             ; unsigned int
.text$mn:00003726                 push    7EBh            ; unsigned int
.text$mn:0000372B                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00003731                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003736                 push    0               ; __int32
.text$mn:00003738                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:0000373E                 call    ?getCurrentLineNumber@ScintillaEditView@@QBEJXZ ; ScintillaEditView::getCurrentLineNumber(void)
.text$mn:00003743                 push    eax             ; unsigned int
.text$mn:00003744                 push    877h            ; unsigned int
.text$mn:00003749                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:0000374F                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003754                 mov     [ebp+var_103C], eax
.text$mn:0000375A                 mov     ecx, [ebp+var_E78]
.text$mn:00003760                 sub     ecx, [ebp+var_103C]
.text$mn:00003766                 mov     [ebp+var_E78], ecx
.text$mn:0000376C
.text$mn:0000376C loc_376C:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+22B1j
.text$mn:0000376C                 mov     edx, [ebp+Str]
.text$mn:00003772                 push    edx             ; Str
.text$mn:00003773                 lea     ecx, [ebp+var_6E4]
.text$mn:00003779                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:0000377E                 mov     eax, [ebp+Str]
.text$mn:00003784                 mov     [ebp+var_10BC], eax
.text$mn:0000378A                 mov     ecx, [ebp+var_10BC]
.text$mn:00003790                 push    ecx             ; void *
.text$mn:00003791                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00003796                 add     esp, 4
.text$mn:00003799                 mov     [ebp+var_E58], 0FFFFFFFFh
.text$mn:000037A3                 mov     [ebp+var_E70], 0FFFFFFFFh
.text$mn:000037AD                 mov     edx, [ebp+var_E64]
.text$mn:000037B3                 movsx   eax, byte ptr [edx+47h]
.text$mn:000037B7                 mov     ecx, [ebp+var_E64]
.text$mn:000037BD                 movsx   edx, byte ptr [ecx+46h]
.text$mn:000037C1                 cmp     eax, edx
.text$mn:000037C3                 jnz     loc_393A
.text$mn:000037C9                 mov     eax, [ebp+var_E78]
.text$mn:000037CF                 mov     [ebp+var_E6C], eax
.text$mn:000037D5                 jmp     short loc_37E6
.text$mn:000037D7 ; ---------------------------------------------------------------------------
.text$mn:000037D7
.text$mn:000037D7 loc_37D7:                               ; CODE XREF: Notepad_plus::notify(SCNotification *):loc_3865j
.text$mn:000037D7                 mov     ecx, [ebp+var_E6C]
.text$mn:000037DD                 sub     ecx, 1
.text$mn:000037E0                 mov     [ebp+var_E6C], ecx
.text$mn:000037E6
.text$mn:000037E6 loc_37E6:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+23B1j
.text$mn:000037E6                 cmp     [ebp+var_E6C], 0
.text$mn:000037ED                 jl      short loc_386A
.text$mn:000037EF                 mov     edx, [ebp+var_E6C]
.text$mn:000037F5                 push    edx
.text$mn:000037F6                 lea     ecx, [ebp+var_6E4]
.text$mn:000037FC                 call    ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::at(uint)
.text$mn:00003801                 movsx   eax, byte ptr [eax]
.text$mn:00003804                 mov     ecx, [ebp+var_E64]
.text$mn:0000380A                 movsx   edx, byte ptr [ecx+46h]
.text$mn:0000380E                 cmp     eax, edx
.text$mn:00003810                 jnz     short loc_3865
.text$mn:00003812                 mov     eax, [ebp+var_E64]
.text$mn:00003818                 movsx   ecx, byte ptr [eax+46h]
.text$mn:0000381C                 cmp     ecx, 22h ; '"'
.text$mn:0000381F                 jnz     short loc_3857
.text$mn:00003821                 cmp     [ebp+var_E6C], 0
.text$mn:00003828                 jle     short loc_3847
.text$mn:0000382A                 mov     edx, [ebp+var_E6C]
.text$mn:00003830                 sub     edx, 1
.text$mn:00003833                 push    edx
.text$mn:00003834                 lea     ecx, [ebp+var_6E4]
.text$mn:0000383A                 call    ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::at(uint)
.text$mn:0000383F                 movsx   eax, byte ptr [eax]
.text$mn:00003842                 cmp     eax, 5Ch ; '\'
.text$mn:00003845                 jz      short loc_3855
.text$mn:00003847
.text$mn:00003847 loc_3847:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2404j
.text$mn:00003847                 mov     ecx, [ebp+var_E6C]
.text$mn:0000384D                 mov     [ebp+var_E58], ecx
.text$mn:00003853                 jmp     short loc_386A
.text$mn:00003855 ; ---------------------------------------------------------------------------
.text$mn:00003855
.text$mn:00003855 loc_3855:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2421j
.text$mn:00003855                 jmp     short loc_3865
.text$mn:00003857 ; ---------------------------------------------------------------------------
.text$mn:00003857
.text$mn:00003857 loc_3857:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+23FBj
.text$mn:00003857                 mov     edx, [ebp+var_E6C]
.text$mn:0000385D                 mov     [ebp+var_E58], edx
.text$mn:00003863                 jmp     short loc_386A
.text$mn:00003865 ; ---------------------------------------------------------------------------
.text$mn:00003865
.text$mn:00003865 loc_3865:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+23ECj
.text$mn:00003865                                         ; Notepad_plus::notify(SCNotification *):loc_3855j
.text$mn:00003865                 jmp     loc_37D7
.text$mn:0000386A ; ---------------------------------------------------------------------------
.text$mn:0000386A
.text$mn:0000386A loc_386A:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+23C9j
.text$mn:0000386A                                         ; Notepad_plus::notify(SCNotification *)+242Fj ...
.text$mn:0000386A                 cmp     [ebp+var_E58], 0FFFFFFFFh
.text$mn:00003871                 jnz     short loc_388A
.text$mn:00003873                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000387A                 lea     ecx, [ebp+var_6E4]
.text$mn:00003880                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00003885                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:0000388A ; ---------------------------------------------------------------------------
.text$mn:0000388A
.text$mn:0000388A loc_388A:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+244Dj
.text$mn:0000388A                 mov     eax, [ebp+var_E78]
.text$mn:00003890                 mov     [ebp+var_E68], eax
.text$mn:00003896                 jmp     short loc_38A7
.text$mn:00003898 ; ---------------------------------------------------------------------------
.text$mn:00003898
.text$mn:00003898 loc_3898:                               ; CODE XREF: Notepad_plus::notify(SCNotification *):loc_3930j
.text$mn:00003898                 mov     ecx, [ebp+var_E68]
.text$mn:0000389E                 add     ecx, 1
.text$mn:000038A1                 mov     [ebp+var_E68], ecx
.text$mn:000038A7
.text$mn:000038A7 loc_38A7:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2472j
.text$mn:000038A7                 lea     ecx, [ebp+var_6E4]
.text$mn:000038AD                 call    ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::length(void)
.text$mn:000038B2                 cmp     [ebp+var_E68], eax
.text$mn:000038B8                 jnb     short loc_3935
.text$mn:000038BA                 mov     edx, [ebp+var_E68]
.text$mn:000038C0                 push    edx
.text$mn:000038C1                 lea     ecx, [ebp+var_6E4]
.text$mn:000038C7                 call    ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::at(uint)
.text$mn:000038CC                 movsx   eax, byte ptr [eax]
.text$mn:000038CF                 mov     ecx, [ebp+var_E64]
.text$mn:000038D5                 movsx   edx, byte ptr [ecx+47h]
.text$mn:000038D9                 cmp     eax, edx
.text$mn:000038DB                 jnz     short loc_3930
.text$mn:000038DD                 mov     eax, [ebp+var_E64]
.text$mn:000038E3                 movsx   ecx, byte ptr [eax+47h]
.text$mn:000038E7                 cmp     ecx, 22h ; '"'
.text$mn:000038EA                 jnz     short loc_3922
.text$mn:000038EC                 cmp     [ebp+var_E68], 0
.text$mn:000038F3                 jbe     short loc_3912
.text$mn:000038F5                 mov     edx, [ebp+var_E68]
.text$mn:000038FB                 sub     edx, 1
.text$mn:000038FE                 push    edx
.text$mn:000038FF                 lea     ecx, [ebp+var_6E4]
.text$mn:00003905                 call    ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::at(uint)
.text$mn:0000390A                 movsx   eax, byte ptr [eax]
.text$mn:0000390D                 cmp     eax, 5Ch ; '\'
.text$mn:00003910                 jz      short loc_3920
.text$mn:00003912
.text$mn:00003912 loc_3912:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+24CFj
.text$mn:00003912                 mov     ecx, [ebp+var_E68]
.text$mn:00003918                 mov     [ebp+var_E70], ecx
.text$mn:0000391E                 jmp     short loc_3935
.text$mn:00003920 ; ---------------------------------------------------------------------------
.text$mn:00003920
.text$mn:00003920 loc_3920:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+24ECj
.text$mn:00003920                 jmp     short loc_3930
.text$mn:00003922 ; ---------------------------------------------------------------------------
.text$mn:00003922
.text$mn:00003922 loc_3922:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+24C6j
.text$mn:00003922                 mov     edx, [ebp+var_E68]
.text$mn:00003928                 mov     [ebp+var_E70], edx
.text$mn:0000392E                 jmp     short loc_3935
.text$mn:00003930 ; ---------------------------------------------------------------------------
.text$mn:00003930
.text$mn:00003930 loc_3930:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+24B7j
.text$mn:00003930                                         ; Notepad_plus::notify(SCNotification *):loc_3920j
.text$mn:00003930                 jmp     loc_3898
.text$mn:00003935 ; ---------------------------------------------------------------------------
.text$mn:00003935
.text$mn:00003935 loc_3935:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2494j
.text$mn:00003935                                         ; Notepad_plus::notify(SCNotification *)+24FAj ...
.text$mn:00003935                 jmp     loc_3AAA
.text$mn:0000393A ; ---------------------------------------------------------------------------
.text$mn:0000393A
.text$mn:0000393A loc_393A:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+239Fj
.text$mn:0000393A                 lea     ecx, [ebp+var_11A0]
.text$mn:00003940                 call    ??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::stack<uint,std::deque<uint,std::allocator<uint>>>::stack<uint,std::deque<uint,std::allocator<uint>>>(void)
.text$mn:00003945                 mov     byte ptr [ebp+var_4], 24h ; '$'
.text$mn:00003949                 mov     [ebp+var_E74], 0
.text$mn:00003953                 jmp     short loc_3964
.text$mn:00003955 ; ---------------------------------------------------------------------------
.text$mn:00003955
.text$mn:00003955 loc_3955:                               ; CODE XREF: Notepad_plus::notify(SCNotification *):loc_3A96j
.text$mn:00003955                 mov     eax, [ebp+var_E74]
.text$mn:0000395B                 add     eax, 1
.text$mn:0000395E                 mov     [ebp+var_E74], eax
.text$mn:00003964
.text$mn:00003964 loc_3964:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+252Fj
.text$mn:00003964                 lea     ecx, [ebp+var_6E4]
.text$mn:0000396A                 call    ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::length(void)
.text$mn:0000396F                 cmp     [ebp+var_E74], eax
.text$mn:00003975                 jnb     loc_3A9B
.text$mn:0000397B                 mov     ecx, [ebp+var_E74]
.text$mn:00003981                 push    ecx
.text$mn:00003982                 lea     ecx, [ebp+var_6E4]
.text$mn:00003988                 call    ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::at(uint)
.text$mn:0000398D                 movsx   edx, byte ptr [eax]
.text$mn:00003990                 mov     eax, [ebp+var_E64]
.text$mn:00003996                 movsx   ecx, byte ptr [eax+46h]
.text$mn:0000399A                 cmp     edx, ecx
.text$mn:0000399C                 jnz     short loc_39B5
.text$mn:0000399E                 lea     edx, [ebp+var_E74]
.text$mn:000039A4                 push    edx
.text$mn:000039A5                 lea     ecx, [ebp+var_11A0]
.text$mn:000039AB                 call    ?push@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAEXABI@Z ; std::stack<uint,std::deque<uint,std::allocator<uint>>>::push(uint const &)
.text$mn:000039B0                 jmp     loc_3A96
.text$mn:000039B5 ; ---------------------------------------------------------------------------
.text$mn:000039B5
.text$mn:000039B5 loc_39B5:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2578j
.text$mn:000039B5                 mov     eax, [ebp+var_E74]
.text$mn:000039BB                 push    eax
.text$mn:000039BC                 lea     ecx, [ebp+var_6E4]
.text$mn:000039C2                 call    ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::at(uint)
.text$mn:000039C7                 movsx   ecx, byte ptr [eax]
.text$mn:000039CA                 mov     edx, [ebp+var_E64]
.text$mn:000039D0                 movsx   eax, byte ptr [edx+47h]
.text$mn:000039D4                 cmp     ecx, eax
.text$mn:000039D6                 jnz     loc_3A96
.text$mn:000039DC                 lea     ecx, [ebp+var_11A0]
.text$mn:000039E2                 call    ?empty@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QBE_NXZ ; std::stack<uint,std::deque<uint,std::allocator<uint>>>::empty(void)
.text$mn:000039E7                 movzx   ecx, al
.text$mn:000039EA                 test    ecx, ecx
.text$mn:000039EC                 jnz     loc_3A96
.text$mn:000039F2                 lea     ecx, [ebp+var_11A0]
.text$mn:000039F8                 call    ?top@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAEAAIXZ ; std::stack<uint,std::deque<uint,std::allocator<uint>>>::top(void)
.text$mn:000039FD                 mov     edx, [eax]
.text$mn:000039FF                 mov     [ebp+var_EFC], edx
.text$mn:00003A05                 lea     ecx, [ebp+var_11A0]
.text$mn:00003A0B                 call    ?pop@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAEXXZ ; std::stack<uint,std::deque<uint,std::allocator<uint>>>::pop(void)
.text$mn:00003A10                 cmp     [ebp+var_E58], 0FFFFFFFFh
.text$mn:00003A17                 jnz     short loc_3A22
.text$mn:00003A19                 cmp     [ebp+var_E70], 0FFFFFFFFh
.text$mn:00003A20                 jz      short loc_3A4B
.text$mn:00003A22
.text$mn:00003A22 loc_3A22:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+25F3j
.text$mn:00003A22                 cmp     [ebp+var_E58], 0
.text$mn:00003A29                 jl      short loc_3A34
.text$mn:00003A2B                 cmp     [ebp+var_E70], 0
.text$mn:00003A32                 jge     short loc_3A4B
.text$mn:00003A34
.text$mn:00003A34 loc_3A34:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2605j
.text$mn:00003A34                 push    283h            ; Line
.text$mn:00003A39                 push    offset $SG173541 ; "..\\src\\NppNotification.cpp"
.text$mn:00003A3E                 push    offset $SG173542 ; "(leftmost_position == -1 && rightmost_p"...
.text$mn:00003A43                 call    __wassert
.text$mn:00003A48 ; ---------------------------------------------------------------------------
.text$mn:00003A48                 add     esp, 0Ch
.text$mn:00003A4B
.text$mn:00003A4B loc_3A4B:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+25FCj
.text$mn:00003A4B                                         ; Notepad_plus::notify(SCNotification *)+260Ej
.text$mn:00003A4B                 mov     ecx, [ebp+var_EFC]
.text$mn:00003A51                 cmp     ecx, [ebp+var_E78]
.text$mn:00003A57                 ja      short loc_3A96
.text$mn:00003A59                 mov     edx, [ebp+var_E74]
.text$mn:00003A5F                 cmp     edx, [ebp+var_E78]
.text$mn:00003A65                 jb      short loc_3A96
.text$mn:00003A67                 cmp     [ebp+var_E58], 0FFFFFFFFh
.text$mn:00003A6E                 jz      short loc_3A7E
.text$mn:00003A70                 mov     eax, [ebp+var_EFC]
.text$mn:00003A76                 cmp     eax, [ebp+var_E58]
.text$mn:00003A7C                 jbe     short loc_3A96
.text$mn:00003A7E
.text$mn:00003A7E loc_3A7E:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+264Aj
.text$mn:00003A7E                 mov     ecx, [ebp+var_EFC]
.text$mn:00003A84                 mov     [ebp+var_E58], ecx
.text$mn:00003A8A                 mov     edx, [ebp+var_E74]
.text$mn:00003A90                 mov     [ebp+var_E70], edx
.text$mn:00003A96
.text$mn:00003A96 loc_3A96:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+258Cj
.text$mn:00003A96                                         ; Notepad_plus::notify(SCNotification *)+25B2j ...
.text$mn:00003A96                 jmp     loc_3955
.text$mn:00003A9B ; ---------------------------------------------------------------------------
.text$mn:00003A9B
.text$mn:00003A9B loc_3A9B:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2551j
.text$mn:00003A9B                 mov     byte ptr [ebp+var_4], 23h ; '#'
.text$mn:00003A9F                 lea     ecx, [ebp+var_11A0]
.text$mn:00003AA5                 call    ??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::stack<uint,std::deque<uint,std::allocator<uint>>>::~stack<uint,std::deque<uint,std::allocator<uint>>>(void)
.text$mn:00003AAA
.text$mn:00003AAA loc_3AAA:                               ; CODE XREF: Notepad_plus::notify(SCNotification *):loc_3935j
.text$mn:00003AAA                 cmp     [ebp+var_E70], 0FFFFFFFFh
.text$mn:00003AB1                 jz      loc_3B6F
.text$mn:00003AB7                 cmp     [ebp+var_E58], 0FFFFFFFFh
.text$mn:00003ABE                 jz      loc_3B6F
.text$mn:00003AC4                 mov     eax, [ebp+var_E64]
.text$mn:00003ACA                 movzx   ecx, byte ptr [eax+48h]
.text$mn:00003ACE                 test    ecx, ecx
.text$mn:00003AD0                 jz      short loc_3B09
.text$mn:00003AD2                 push    0               ; __int32
.text$mn:00003AD4                 mov     edx, [ebp+var_E70]
.text$mn:00003ADA                 push    edx             ; unsigned int
.text$mn:00003ADB                 push    85Dh            ; unsigned int
.text$mn:00003AE0                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00003AE6                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003AEB                 push    0               ; __int32
.text$mn:00003AED                 mov     eax, [ebp+var_E58]
.text$mn:00003AF3                 add     eax, 1
.text$mn:00003AF6                 push    eax             ; unsigned int
.text$mn:00003AF7                 push    7EAh            ; unsigned int
.text$mn:00003AFC                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00003B02                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003B07                 jmp     short loc_3B6F
.text$mn:00003B09 ; ---------------------------------------------------------------------------
.text$mn:00003B09
.text$mn:00003B09 loc_3B09:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+26ACj
.text$mn:00003B09                 push    0               ; __int32
.text$mn:00003B0B                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00003B11                 call    ?getCurrentLineNumber@ScintillaEditView@@QBEJXZ ; ScintillaEditView::getCurrentLineNumber(void)
.text$mn:00003B16                 push    eax             ; unsigned int
.text$mn:00003B17                 push    877h            ; unsigned int
.text$mn:00003B1C                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00003B22                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003B27                 mov     [ebp+var_F90], eax
.text$mn:00003B2D                 push    0               ; __int32
.text$mn:00003B2F                 mov     ecx, [ebp+var_F90]
.text$mn:00003B35                 add     ecx, [ebp+var_E70]
.text$mn:00003B3B                 push    ecx             ; unsigned int
.text$mn:00003B3C                 push    85Dh            ; unsigned int
.text$mn:00003B41                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00003B47                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003B4C                 push    0               ; __int32
.text$mn:00003B4E                 mov     edx, [ebp+var_E58]
.text$mn:00003B54                 mov     eax, [ebp+var_F90]
.text$mn:00003B5A                 lea     ecx, [eax+edx+1]
.text$mn:00003B5E                 push    ecx             ; unsigned int
.text$mn:00003B5F                 push    7EAh            ; unsigned int
.text$mn:00003B64                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00003B6A                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003B6F
.text$mn:00003B6F loc_3B6F:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+268Dj
.text$mn:00003B6F                                         ; Notepad_plus::notify(SCNotification *)+269Aj ...
.text$mn:00003B6F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003B76                 lea     ecx, [ebp+var_6E4]
.text$mn:00003B7C                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00003B81                 jmp     short loc_3BED
.text$mn:00003B83 ; ---------------------------------------------------------------------------
.text$mn:00003B83
.text$mn:00003B83 loc_3B83:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+21E3j
.text$mn:00003B83                 mov     edx, [ebp+var_E44]
.text$mn:00003B89                 movzx   eax, byte ptr [edx+54B69h]
.text$mn:00003B90                 test    eax, eax
.text$mn:00003B92                 jz      short loc_3BED
.text$mn:00003B94                 push    0               ; __int32
.text$mn:00003B96                 push    0               ; unsigned int
.text$mn:00003B98                 push    7D8h            ; unsigned int
.text$mn:00003B9D                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00003BA3                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003BA8                 mov     [ebp+var_F98], eax
.text$mn:00003BAE                 push    0               ; __int32
.text$mn:00003BB0                 mov     ecx, [ebp+var_F98]
.text$mn:00003BB6                 push    ecx             ; unsigned int
.text$mn:00003BB7                 push    85Dh            ; unsigned int
.text$mn:00003BBC                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00003BC2                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003BC7                 push    0               ; __int32
.text$mn:00003BC9                 mov     edx, [ebp+var_F98]
.text$mn:00003BCF                 push    edx             ; unsigned int
.text$mn:00003BD0                 push    7EAh            ; unsigned int
.text$mn:00003BD5                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00003BDB                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00003BE0                 mov     eax, [ebp+var_E44]
.text$mn:00003BE6                 mov     byte ptr [eax+54B69h], 0
.text$mn:00003BED
.text$mn:00003BED loc_3BED:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+275Dj
.text$mn:00003BED                                         ; Notepad_plus::notify(SCNotification *)+276Ej
.text$mn:00003BED                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:00003BF2 ; ---------------------------------------------------------------------------
.text$mn:00003BF2
.text$mn:00003BF2 $LN49:                                  ; CODE XREF: Notepad_plus::notify(SCNotification *)+1C1j
.text$mn:00003BF2                                         ; DATA XREF: .text$mn:$LN305o
.text$mn:00003BF2                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; jumptable 000015E5 case 6
.text$mn:00003BF7                 mov     [ebp+var_FA8], eax
.text$mn:00003BFD                 mov     ecx, [ebp+arg_0]
.text$mn:00003C00                 mov     edx, [ecx+58h]
.text$mn:00003C03                 and     edx, 4
.text$mn:00003C06                 jz      short loc_3C3A
.text$mn:00003C08                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00003C0D                 mov     ecx, eax        ; this
.text$mn:00003C0F                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00003C14                 mov     eax, [eax+4Ch]
.text$mn:00003C17                 mov     [ebp+var_FA0], eax
.text$mn:00003C1D                 cmp     [ebp+var_FA0], 1
.text$mn:00003C24                 jz      short loc_3C2F
.text$mn:00003C26                 cmp     [ebp+var_FA0], 2
.text$mn:00003C2D                 jnz     short loc_3C3A
.text$mn:00003C2F
.text$mn:00003C2F loc_3C2F:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2800j
.text$mn:00003C2F                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00003C35                 call    ?addHotSpot@Notepad_plus@@AAEXXZ ; Notepad_plus::addHotSpot(void)
.text$mn:00003C3A
.text$mn:00003C3A loc_3C3A:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+27E2j
.text$mn:00003C3A                                         ; Notepad_plus::notify(SCNotification *)+2809j
.text$mn:00003C3A                 mov     ecx, [ebp+var_FA8]
.text$mn:00003C40                 movzx   edx, byte ptr [ecx+8]
.text$mn:00003C44                 test    edx, edx
.text$mn:00003C46                 jz      short loc_3C4D
.text$mn:00003C48                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:00003C4D ; ---------------------------------------------------------------------------
.text$mn:00003C4D
.text$mn:00003C4D loc_3C4D:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2822j
.text$mn:00003C4D                 mov     eax, [ebp+var_E44]
.text$mn:00003C53                 mov     ecx, [eax+5D4h] ; this
.text$mn:00003C59                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00003C5E                 mov     ecx, [ebp+arg_0]
.text$mn:00003C61                 cmp     [ecx], eax
.text$mn:00003C63                 jz      short loc_3C6A
.text$mn:00003C65                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:00003C6A ; ---------------------------------------------------------------------------
.text$mn:00003C6A
.text$mn:00003C6A loc_3C6A:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+283Fj
.text$mn:00003C6A                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00003C70                 call    ?braceMatch@Notepad_plus@@AAE_NXZ ; Notepad_plus::braceMatch(void)
.text$mn:00003C75                 mov     ecx, [ebp+var_FA8] ; this
.text$mn:00003C7B                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00003C80                 mov     [ebp+var_EC0], eax
.text$mn:00003C86                 mov     edx, [ebp+var_EC0]
.text$mn:00003C8C                 movzx   eax, byte ptr [edx+42h]
.text$mn:00003C90                 test    eax, eax
.text$mn:00003C92                 jz      short loc_3CC2
.text$mn:00003C94                 mov     ecx, [ebp+var_E44]
.text$mn:00003C9A                 mov     edx, [ecx+5D4h]
.text$mn:00003CA0                 push    edx             ; struct ScintillaEditView *
.text$mn:00003CA1                 lea     ecx, [ebp+var_1044] ; this
.text$mn:00003CA7                 call    ??0XmlMatchedTagsHighlighter@@QAE@PAVScintillaEditView@@@Z ; XmlMatchedTagsHighlighter::XmlMatchedTagsHighlighter(ScintillaEditView *)
.text$mn:00003CAC                 mov     eax, [ebp+var_EC0]
.text$mn:00003CB2                 movzx   ecx, byte ptr [eax+43h]
.text$mn:00003CB6                 push    ecx             ; bool
.text$mn:00003CB7                 lea     ecx, [ebp+var_1044] ; this
.text$mn:00003CBD                 call    ?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z ; XmlMatchedTagsHighlighter::tagMatch(bool)
.text$mn:00003CC2
.text$mn:00003CC2 loc_3CC2:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+286Ej
.text$mn:00003CC2                 mov     edx, [ebp+var_EC0]
.text$mn:00003CC8                 movzx   eax, byte ptr [edx+3Fh]
.text$mn:00003CCC                 test    eax, eax
.text$mn:00003CCE                 jz      short loc_3D02
.text$mn:00003CD0                 mov     ecx, [ebp+var_EC0]
.text$mn:00003CD6                 movzx   edx, byte ptr [ecx+41h]
.text$mn:00003CDA                 test    edx, edx
.text$mn:00003CDC                 jz      short loc_3CEA
.text$mn:00003CDE                 mov     eax, [ebp+var_EC0]
.text$mn:00003CE4                 mov     byte ptr [eax+41h], 0
.text$mn:00003CE8                 jmp     short loc_3D02
.text$mn:00003CEA ; ---------------------------------------------------------------------------
.text$mn:00003CEA
.text$mn:00003CEA loc_3CEA:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+28B8j
.text$mn:00003CEA                 mov     ecx, [ebp+var_E4C]
.text$mn:00003CF0                 push    ecx             ; struct ScintillaEditView *
.text$mn:00003CF1                 mov     ecx, [ebp+var_E44]
.text$mn:00003CF7                 add     ecx, 348h       ; this
.text$mn:00003CFD                 call    ?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z ; SmartHighlighter::highlightView(ScintillaEditView *)
.text$mn:00003D02
.text$mn:00003D02 loc_3D02:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+28AAj
.text$mn:00003D02                                         ; Notepad_plus::notify(SCNotification *)+28C4j
.text$mn:00003D02                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00003D08                 call    ?updateStatusBar@Notepad_plus@@AAEXXZ ; Notepad_plus::updateStatusBar(void)
.text$mn:00003D0D                 movzx   edx, [ebp+var_E45]
.text$mn:00003D14                 test    edx, edx
.text$mn:00003D16                 jz      short loc_3D2B
.text$mn:00003D18                 mov     eax, [ebp+var_E44]
.text$mn:00003D1E                 add     eax, 198h
.text$mn:00003D23                 mov     [ebp+var_FB0], eax
.text$mn:00003D29                 jmp     short loc_3D3D
.text$mn:00003D2B ; ---------------------------------------------------------------------------
.text$mn:00003D2B
.text$mn:00003D2B loc_3D2B:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+28F2j
.text$mn:00003D2B                 mov     ecx, [ebp+var_E44]
.text$mn:00003D31                 add     ecx, 270h
.text$mn:00003D37                 mov     [ebp+var_FB0], ecx
.text$mn:00003D3D
.text$mn:00003D3D loc_3D3D:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2905j
.text$mn:00003D3D                 mov     edx, [ebp+var_FB0]
.text$mn:00003D43                 mov     [ebp+var_10FC], edx
.text$mn:00003D49                 push    0               ; int
.text$mn:00003D4B                 mov     ecx, [ebp+var_10FC] ; this
.text$mn:00003D51                 call    ?update@AutoCompletion@@QAEXH@Z ; AutoCompletion::update(int)
.text$mn:00003D56                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:00003D5B ; ---------------------------------------------------------------------------
.text$mn:00003D5B
.text$mn:00003D5B loc_3D5B:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+27Ej
.text$mn:00003D5B                 mov     [ebp+var_4], 25h ; '%'
.text$mn:00003D62                 mov     eax, [ebp+arg_0]
.text$mn:00003D65                 mov     [ebp+var_EA4], eax
.text$mn:00003D6B                 mov     ecx, [ebp+var_EA4]
.text$mn:00003D71                 mov     dword ptr [ecx+0B0h], 0
.text$mn:00003D7B                 lea     edx, [ebp+ptParentClientCoords]
.text$mn:00003D81                 push    edx             ; lpPoint
.text$mn:00003D82                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:00003D88                 lea     eax, [ebp+ptParentClientCoords]
.text$mn:00003D8E                 push    eax             ; lpPoint
.text$mn:00003D8F                 mov     ecx, [ebp+var_E44]
.text$mn:00003D95                 mov     ecx, [ecx+4]    ; this
.text$mn:00003D98                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00003D9D                 push    eax             ; hWnd
.text$mn:00003D9E                 call    dword ptr ds:__imp__ScreenToClient@8 ; ScreenToClient(x,x)
.text$mn:00003DA4                 mov     edx, [ebp+ptParentClientCoords.y]
.text$mn:00003DAA                 push    edx
.text$mn:00003DAB                 mov     eax, [ebp+ptParentClientCoords.x]
.text$mn:00003DB1                 push    eax             ; ptParentClientCoords
.text$mn:00003DB2                 mov     ecx, [ebp+var_E44]
.text$mn:00003DB8                 mov     ecx, [ecx+4]    ; this
.text$mn:00003DBB                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00003DC0                 push    eax             ; hwndParent
.text$mn:00003DC1                 call    dword ptr ds:__imp__RealChildWindowFromPoint@12 ; RealChildWindowFromPoint(x,x,x)
.text$mn:00003DC7                 mov     [ebp+var_EF0], eax
.text$mn:00003DCD                 mov     [ebp+var_11A8], 400h
.text$mn:00003DD7                 mov     edx, 2
.text$mn:00003DDC                 imul    eax, edx, 0
.text$mn:00003DDF                 mov     [ebp+var_FB8], eax
.text$mn:00003DE5                 cmp     [ebp+var_FB8], 800h
.text$mn:00003DEF                 jnb     short loc_3DF3
.text$mn:00003DF1                 jmp     short loc_3DF8
.text$mn:00003DF3 ; ---------------------------------------------------------------------------
.text$mn:00003DF3
.text$mn:00003DF3 loc_3DF3:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+29CBj
.text$mn:00003DF3                 call    ___report_rangecheckfailure
.text$mn:00003DF8
.text$mn:00003DF8 loc_3DF8:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+29CDj
.text$mn:00003DF8                 xor     ecx, ecx
.text$mn:00003DFA                 mov     edx, [ebp+var_FB8]
.text$mn:00003E00                 mov     ds:?docTip@?BDC@??notify@Notepad_plus@@AAEHPAUSCNotification@@@Z@4PA_WA[edx], cx ; wchar_t * `Notepad_plus::notify(SCNotification *)'::`306'::docTip
.text$mn:00003E07                 push    offset $SG173580 ; Str
.text$mn:00003E0C                 lea     ecx, [ebp+var_6C8]
.text$mn:00003E12                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00003E17                 mov     byte ptr [ebp+var_4], 26h ; '&'
.text$mn:00003E1B                 mov     eax, [ebp+var_EA4]
.text$mn:00003E21                 mov     ecx, [eax+4]
.text$mn:00003E24                 mov     [ebp+var_EF8], ecx
.text$mn:00003E2A                 mov     ecx, [ebp+var_E44]
.text$mn:00003E30                 add     ecx, 87Ch       ; this
.text$mn:00003E36                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00003E3B                 cmp     [ebp+var_EF0], eax
.text$mn:00003E41                 jnz     loc_3ED6
.text$mn:00003E47                 lea     edx, [ebp+var_6C8]
.text$mn:00003E4D                 push    edx
.text$mn:00003E4E                 mov     eax, [ebp+var_EF8]
.text$mn:00003E54                 push    eax
.text$mn:00003E55                 call    ?getNameStrFromCmd@@YAXKAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; getNameStrFromCmd(ulong,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00003E5A                 add     esp, 8
.text$mn:00003E5D                 lea     ecx, [ebp+var_6C8]
.text$mn:00003E63                 call    ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::length(void)
.text$mn:00003E68                 cmp     eax, 50h ; 'P'
.text$mn:00003E6B                 jb      short loc_3E91
.text$mn:00003E6D                 mov     [ebp+var_104C], 0
.text$mn:00003E77                 mov     byte ptr [ebp+var_4], 25h ; '%'
.text$mn:00003E7B                 lea     ecx, [ebp+var_6C8]
.text$mn:00003E81                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00003E86                 mov     eax, [ebp+var_104C]
.text$mn:00003E8C                 jmp     loc_4795
.text$mn:00003E91 ; ---------------------------------------------------------------------------
.text$mn:00003E91
.text$mn:00003E91 loc_3E91:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2A47j
.text$mn:00003E91                 lea     ecx, [ebp+var_6C8]
.text$mn:00003E97                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00003E9C                 push    eax             ; lpString2
.text$mn:00003E9D                 mov     ecx, [ebp+var_EA4]
.text$mn:00003EA3                 add     ecx, 10h
.text$mn:00003EA6                 push    ecx             ; lpString1
.text$mn:00003EA7                 call    dword ptr ds:__imp__lstrcpyW@8 ; lstrcpyW(x,x)
.text$mn:00003EAD                 mov     [ebp+var_10C4], 1
.text$mn:00003EB7                 mov     byte ptr [ebp+var_4], 25h ; '%'
.text$mn:00003EBB                 lea     ecx, [ebp+var_6C8]
.text$mn:00003EC1                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00003EC6                 mov     eax, [ebp+var_10C4]
.text$mn:00003ECC                 jmp     loc_4795
.text$mn:00003ED1 ; ---------------------------------------------------------------------------
.text$mn:00003ED1                 jmp     loc_40D3
.text$mn:00003ED6 ; ---------------------------------------------------------------------------
.text$mn:00003ED6
.text$mn:00003ED6 loc_3ED6:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2A1Dj
.text$mn:00003ED6                 mov     ecx, [ebp+var_E44]
.text$mn:00003EDC                 add     ecx, 35Ch       ; this
.text$mn:00003EE2                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00003EE7                 cmp     [ebp+var_EF0], eax
.text$mn:00003EED                 jnz     loc_3FC4
.text$mn:00003EF3                 mov     edx, [ebp+var_EF8]
.text$mn:00003EF9                 push    edx             ; int
.text$mn:00003EFA                 mov     ecx, [ebp+var_E44]
.text$mn:00003F00                 add     ecx, 35Ch       ; this
.text$mn:00003F06                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00003F0B                 mov     [ebp+var_1054], eax
.text$mn:00003F11                 mov     eax, [ebp+var_1054]
.text$mn:00003F17                 push    eax             ; struct Buffer *
.text$mn:00003F18                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00003F1D                 mov     ecx, eax        ; this
.text$mn:00003F1F                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00003F24                 mov     [ebp+var_111C], eax
.text$mn:00003F2A                 mov     ecx, [ebp+var_111C] ; this
.text$mn:00003F30                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00003F35                 push    eax             ; Str
.text$mn:00003F36                 lea     ecx, [ebp+var_6C8]
.text$mn:00003F3C                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:00003F41                 lea     ecx, [ebp+var_6C8]
.text$mn:00003F47                 call    ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::length(void)
.text$mn:00003F4C                 cmp     eax, 400h
.text$mn:00003F51                 jb      short loc_3F77
.text$mn:00003F53                 mov     [ebp+var_105C], 0
.text$mn:00003F5D                 mov     byte ptr [ebp+var_4], 25h ; '%'
.text$mn:00003F61                 lea     ecx, [ebp+var_6C8]
.text$mn:00003F67                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00003F6C                 mov     eax, [ebp+var_105C]
.text$mn:00003F72                 jmp     loc_4795
.text$mn:00003F77 ; ---------------------------------------------------------------------------
.text$mn:00003F77
.text$mn:00003F77 loc_3F77:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2B2Dj
.text$mn:00003F77                 lea     ecx, [ebp+var_6C8]
.text$mn:00003F7D                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00003F82                 push    eax             ; lpString2
.text$mn:00003F83                 push    offset ?docTip@?BDC@??notify@Notepad_plus@@AAEHPAUSCNotification@@@Z@4PA_WA ; lpString1
.text$mn:00003F88                 call    dword ptr ds:__imp__lstrcpyW@8 ; lstrcpyW(x,x)
.text$mn:00003F8E                 mov     ecx, [ebp+var_EA4]
.text$mn:00003F94                 mov     dword ptr [ecx+0Ch], offset ?docTip@?BDC@??notify@Notepad_plus@@AAEHPAUSCNotification@@@Z@4PA_WA ; wchar_t * `Notepad_plus::notify(SCNotification *)'::`306'::docTip
.text$mn:00003F9B                 mov     [ebp+var_10CC], 1
.text$mn:00003FA5                 mov     byte ptr [ebp+var_4], 25h ; '%'
.text$mn:00003FA9                 lea     ecx, [ebp+var_6C8]
.text$mn:00003FAF                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00003FB4                 mov     eax, [ebp+var_10CC]
.text$mn:00003FBA                 jmp     loc_4795
.text$mn:00003FBF ; ---------------------------------------------------------------------------
.text$mn:00003FBF                 jmp     loc_40D3
.text$mn:00003FC4 ; ---------------------------------------------------------------------------
.text$mn:00003FC4
.text$mn:00003FC4 loc_3FC4:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2AC9j
.text$mn:00003FC4                 mov     ecx, [ebp+var_E44]
.text$mn:00003FCA                 add     ecx, 3DCh       ; this
.text$mn:00003FD0                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00003FD5                 cmp     [ebp+var_EF0], eax
.text$mn:00003FDB                 jnz     loc_40AF
.text$mn:00003FE1                 mov     edx, [ebp+var_EF8]
.text$mn:00003FE7                 push    edx             ; int
.text$mn:00003FE8                 mov     ecx, [ebp+var_E44]
.text$mn:00003FEE                 add     ecx, 3DCh       ; this
.text$mn:00003FF4                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00003FF9                 mov     [ebp+var_1064], eax
.text$mn:00003FFF                 mov     eax, [ebp+var_1064]
.text$mn:00004005                 push    eax             ; struct Buffer *
.text$mn:00004006                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:0000400B                 mov     ecx, eax        ; this
.text$mn:0000400D                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00004012                 mov     [ebp+var_1104], eax
.text$mn:00004018                 mov     ecx, [ebp+var_1104] ; this
.text$mn:0000401E                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00004023                 push    eax             ; Str
.text$mn:00004024                 lea     ecx, [ebp+var_6C8]
.text$mn:0000402A                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:0000402F                 lea     ecx, [ebp+var_6C8]
.text$mn:00004035                 call    ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::length(void)
.text$mn:0000403A                 cmp     eax, 400h
.text$mn:0000403F                 jb      short loc_4065
.text$mn:00004041                 mov     [ebp+var_106C], 0
.text$mn:0000404B                 mov     byte ptr [ebp+var_4], 25h ; '%'
.text$mn:0000404F                 lea     ecx, [ebp+var_6C8]
.text$mn:00004055                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000405A                 mov     eax, [ebp+var_106C]
.text$mn:00004060                 jmp     loc_4795
.text$mn:00004065 ; ---------------------------------------------------------------------------
.text$mn:00004065
.text$mn:00004065 loc_4065:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2C1Bj
.text$mn:00004065                 lea     ecx, [ebp+var_6C8]
.text$mn:0000406B                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00004070                 push    eax             ; lpString2
.text$mn:00004071                 push    offset ?docTip@?BDC@??notify@Notepad_plus@@AAEHPAUSCNotification@@@Z@4PA_WA ; lpString1
.text$mn:00004076                 call    dword ptr ds:__imp__lstrcpyW@8 ; lstrcpyW(x,x)
.text$mn:0000407C                 mov     ecx, [ebp+var_EA4]
.text$mn:00004082                 mov     dword ptr [ecx+0Ch], offset ?docTip@?BDC@??notify@Notepad_plus@@AAEHPAUSCNotification@@@Z@4PA_WA ; wchar_t * `Notepad_plus::notify(SCNotification *)'::`306'::docTip
.text$mn:00004089                 mov     [ebp+var_10D4], 1
.text$mn:00004093                 mov     byte ptr [ebp+var_4], 25h ; '%'
.text$mn:00004097                 lea     ecx, [ebp+var_6C8]
.text$mn:0000409D                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000040A2                 mov     eax, [ebp+var_10D4]
.text$mn:000040A8                 jmp     loc_4795
.text$mn:000040AD ; ---------------------------------------------------------------------------
.text$mn:000040AD                 jmp     short loc_40D3
.text$mn:000040AF ; ---------------------------------------------------------------------------
.text$mn:000040AF
.text$mn:000040AF loc_40AF:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2BB7j
.text$mn:000040AF                 mov     [ebp+var_1074], 0
.text$mn:000040B9                 mov     byte ptr [ebp+var_4], 25h ; '%'
.text$mn:000040BD                 lea     ecx, [ebp+var_6C8]
.text$mn:000040C3                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000040C8                 mov     eax, [ebp+var_1074]
.text$mn:000040CE                 jmp     loc_4795
.text$mn:000040D3 ; ---------------------------------------------------------------------------
.text$mn:000040D3
.text$mn:000040D3 loc_40D3:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2AADj
.text$mn:000040D3                                         ; Notepad_plus::notify(SCNotification *)+2B9Bj ...
.text$mn:000040D3                 mov     byte ptr [ebp+var_4], 25h ; '%'
.text$mn:000040D7                 lea     ecx, [ebp+var_6C8]
.text$mn:000040DD                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000040E2                 jmp     short loc_40EA
.text$mn:000040E2 ?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z endp ; sp-analysis failed
.text$mn:000040E2
.text$mn:000040E4
.text$mn:000040E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000040E4
.text$mn:000040E4
.text$mn:000040E4 __catch$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$0 proc near
.text$mn:000040E4                                         ; DATA XREF: .xdata$x:0000BCF8o
.text$mn:000040E4                 mov     eax, offset $LN302
.text$mn:000040E9                 retn
.text$mn:000040E9 __catch$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$0 endp
.text$mn:000040E9
.text$mn:000040EA ; ---------------------------------------------------------------------------
.text$mn:000040EA ; START OF FUNCTION CHUNK FOR ?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z
.text$mn:000040EA
.text$mn:000040EA loc_40EA:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2CBEj
.text$mn:000040EA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000040F1                 jmp     short loc_40FA
.text$mn:000040F1 ; END OF FUNCTION CHUNK FOR ?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z
.text$mn:000040F3 ; ---------------------------------------------------------------------------
.text$mn:000040F3
.text$mn:000040F3 $LN302:                                 ; DATA XREF: __catch$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$0o
.text$mn:000040F3                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000040FA ; START OF FUNCTION CHUNK FOR ?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z
.text$mn:000040FA
.text$mn:000040FA loc_40FA:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2CCDj
.text$mn:000040FA                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:000040FA ; END OF FUNCTION CHUNK FOR ?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z
.text$mn:000040FF ; ---------------------------------------------------------------------------
.text$mn:000040FF                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:00004104 ; ---------------------------------------------------------------------------
.text$mn:00004104 ; START OF FUNCTION CHUNK FOR ?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z
.text$mn:00004104
.text$mn:00004104 $LN27:                                  ; CODE XREF: Notepad_plus::notify(SCNotification *)+1C1j
.text$mn:00004104                                         ; DATA XREF: .text$mn:$LN305o
.text$mn:00004104                 push    0               ; jumptable 000015E5 case 8
.text$mn:00004106                 push    0               ; unsigned int
.text$mn:00004108                 push    859h            ; unsigned int
.text$mn:0000410D                 mov     edx, [ebp+var_E44]
.text$mn:00004113                 mov     ecx, [edx+5D4h] ; this
.text$mn:00004119                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000411E                 push    eax             ; int
.text$mn:0000411F                 mov     eax, [ebp+arg_0]
.text$mn:00004122                 mov     ecx, [eax+30h]
.text$mn:00004125                 push    ecx             ; __int32
.text$mn:00004126                 mov     edx, [ebp+arg_0]
.text$mn:00004129                 mov     eax, [edx+2Ch]
.text$mn:0000412C                 push    eax             ; __int32
.text$mn:0000412D                 mov     ecx, [ebp+arg_0]
.text$mn:00004130                 mov     edx, [ecx+28h]
.text$mn:00004133                 push    edx             ; int
.text$mn:00004134                 lea     ecx, [ebp+var_774] ; this
.text$mn:0000413A                 call    ??0recordedMacroStep@@QAE@HJJH@Z ; recordedMacroStep::recordedMacroStep(int,long,long,int)
.text$mn:0000413F                 mov     [ebp+var_112C], eax
.text$mn:00004145                 mov     eax, [ebp+var_112C]
.text$mn:0000414B                 mov     [ebp+var_107C], eax
.text$mn:00004151                 mov     [ebp+var_4], 28h ; '('
.text$mn:00004158                 mov     ecx, [ebp+var_107C]
.text$mn:0000415E                 push    ecx
.text$mn:0000415F                 mov     ecx, [ebp+var_E44]
.text$mn:00004165                 add     ecx, 54B28h
.text$mn:0000416B                 call    ?push_back@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEX$$QAUrecordedMacroStep@@@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::push_back(recordedMacroStep &&)
.text$mn:00004170                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004177                 lea     ecx, [ebp+var_774] ; this
.text$mn:0000417D                 call    ??1recordedMacroStep@@QAE@XZ ; recordedMacroStep::~recordedMacroStep(void)
.text$mn:00004182                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:00004187 ; ---------------------------------------------------------------------------
.text$mn:00004187
.text$mn:00004187 $LN26:                                  ; CODE XREF: Notepad_plus::notify(SCNotification *)+1C1j
.text$mn:00004187                                         ; DATA XREF: .text$mn:$LN305o
.text$mn:00004187                 mov     ecx, [ebp+var_E44] ; jumptable 000015E5 case 12
.text$mn:0000418D                 add     ecx, 4C0h       ; this
.text$mn:00004193                 call    ?isWrapRestoreNeeded@ScintillaEditView@@QBE_NXZ ; ScintillaEditView::isWrapRestoreNeeded(void)
.text$mn:00004198                 movzx   edx, al
.text$mn:0000419B                 test    edx, edx
.text$mn:0000419D                 jz      short loc_41C3
.text$mn:0000419F                 mov     ecx, [ebp+var_E44]
.text$mn:000041A5                 add     ecx, 4C0h       ; this
.text$mn:000041AB                 call    ?restoreCurrentPos@ScintillaEditView@@QAEXXZ ; ScintillaEditView::restoreCurrentPos(void)
.text$mn:000041B0                 push    0               ; bool
.text$mn:000041B2                 mov     ecx, [ebp+var_E44]
.text$mn:000041B8                 add     ecx, 4C0h       ; this
.text$mn:000041BE                 call    ?setWrapRestoreNeeded@ScintillaEditView@@QAEX_N@Z ; ScintillaEditView::setWrapRestoreNeeded(bool)
.text$mn:000041C3
.text$mn:000041C3 loc_41C3:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2D79j
.text$mn:000041C3                 mov     ecx, [ebp+var_E44]
.text$mn:000041C9                 add     ecx, 464h       ; this
.text$mn:000041CF                 call    ?isWrapRestoreNeeded@ScintillaEditView@@QBE_NXZ ; ScintillaEditView::isWrapRestoreNeeded(void)
.text$mn:000041D4                 movzx   eax, al
.text$mn:000041D7                 test    eax, eax
.text$mn:000041D9                 jz      short loc_41FF
.text$mn:000041DB                 mov     ecx, [ebp+var_E44]
.text$mn:000041E1                 add     ecx, 464h       ; this
.text$mn:000041E7                 call    ?restoreCurrentPos@ScintillaEditView@@QAEXXZ ; ScintillaEditView::restoreCurrentPos(void)
.text$mn:000041EC                 push    0               ; bool
.text$mn:000041EE                 mov     ecx, [ebp+var_E44]
.text$mn:000041F4                 add     ecx, 464h       ; this
.text$mn:000041FA                 call    ?setWrapRestoreNeeded@ScintillaEditView@@QAEX_N@Z ; ScintillaEditView::setWrapRestoreNeeded(bool)
.text$mn:000041FF
.text$mn:000041FF loc_41FF:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2DB5j
.text$mn:000041FF                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00004205                 call    ?updateLineNumberWidth@ScintillaEditView@@QAEXXZ ; ScintillaEditView::updateLineNumberWidth(void)
.text$mn:0000420A                 mov     ecx, [ebp+var_E44]
.text$mn:00004210                 add     ecx, 54B80h     ; this
.text$mn:00004216                 call    ?doSync@SyncInfo@Notepad_plus@@QBE_NXZ ; Notepad_plus::SyncInfo::doSync(void)
.text$mn:0000421B                 movzx   ecx, al
.text$mn:0000421E                 test    ecx, ecx
.text$mn:00004220                 jz      short loc_4233
.text$mn:00004222                 mov     edx, [ebp+arg_0]
.text$mn:00004225                 mov     eax, [edx]
.text$mn:00004227                 push    eax             ; HWND
.text$mn:00004228                 mov     ecx, [ebp+var_E44] ; this
.text$mn:0000422E                 call    ?doSynScorll@Notepad_plus@@AAEXPAUHWND__@@@Z ; Notepad_plus::doSynScorll(HWND__ *)
.text$mn:00004233
.text$mn:00004233 loc_4233:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2DFCj
.text$mn:00004233                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00004238                 mov     [ebp+var_10DC], eax
.text$mn:0000423E                 mov     ecx, [ebp+var_E44]
.text$mn:00004244                 movzx   edx, byte ptr [ecx+54B68h]
.text$mn:0000424B                 test    edx, edx
.text$mn:0000424D                 jz      short loc_425D
.text$mn:0000424F                 mov     eax, [ebp+var_10DC]
.text$mn:00004255                 movzx   ecx, byte ptr [eax+8]
.text$mn:00004259                 test    ecx, ecx
.text$mn:0000425B                 jz      short loc_4269
.text$mn:0000425D
.text$mn:0000425D loc_425D:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2E29j
.text$mn:0000425D                 mov     edx, [ebp+arg_0]
.text$mn:00004260                 cmp     dword ptr [edx+2Ch], 62Bh
.text$mn:00004267                 jnz     short loc_42A8
.text$mn:00004269
.text$mn:00004269 loc_4269:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2E37j
.text$mn:00004269                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:0000426E                 mov     ecx, eax        ; this
.text$mn:00004270                 call    ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ ; NppParameters::getNppGUI(void)
.text$mn:00004275                 mov     eax, [eax+4Ch]
.text$mn:00004278                 mov     [ebp+var_FC0], eax
.text$mn:0000427E                 cmp     [ebp+var_FC0], 1
.text$mn:00004285                 jz      short loc_4290
.text$mn:00004287                 cmp     [ebp+var_FC0], 2
.text$mn:0000428E                 jnz     short loc_429B
.text$mn:00004290
.text$mn:00004290 loc_4290:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2E61j
.text$mn:00004290                 mov     ecx, [ebp+var_E44] ; this
.text$mn:00004296                 call    ?addHotSpot@Notepad_plus@@AAEXXZ ; Notepad_plus::addHotSpot(void)
.text$mn:0000429B
.text$mn:0000429B loc_429B:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2E6Aj
.text$mn:0000429B                 mov     ecx, [ebp+var_E44]
.text$mn:000042A1                 mov     byte ptr [ecx+54B68h], 0
.text$mn:000042A8
.text$mn:000042A8 loc_42A8:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2E43j
.text$mn:000042A8                 mov     edx, [ebp+var_E44]
.text$mn:000042AE                 cmp     dword ptr [edx+551BCh], 0
.text$mn:000042B5                 jz      short loc_42D9
.text$mn:000042B7                 mov     eax, [ebp+var_E44]
.text$mn:000042BD                 mov     ecx, [eax+551BCh] ; this
.text$mn:000042C3                 call    ?wrapMap@DocumentMap@@QAEXXZ ; DocumentMap::wrapMap(void)
.text$mn:000042C8                 mov     ecx, [ebp+var_E44]
.text$mn:000042CE                 mov     ecx, [ecx+551BCh] ; this
.text$mn:000042D4                 call    ?scrollMap@DocumentMap@@QAEXXZ ; DocumentMap::scrollMap(void)
.text$mn:000042D9
.text$mn:000042D9 loc_42D9:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2E91j
.text$mn:000042D9                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:000042DE ; ---------------------------------------------------------------------------
.text$mn:000042DE
.text$mn:000042DE $LN16:                                  ; CODE XREF: Notepad_plus::notify(SCNotification *)+1C1j
.text$mn:000042DE                                         ; DATA XREF: .text$mn:$LN305o
.text$mn:000042DE                 push    offset $SG173619 ; jumptable 000015E5 case 19
.text$mn:000042E3                 push    0               ; unsigned int
.text$mn:000042E5                 push    81Dh            ; unsigned int
.text$mn:000042EA                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:000042F0                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000042F5                 push    0               ; __int32
.text$mn:000042F7                 push    0               ; unsigned int
.text$mn:000042F9                 push    7D8h            ; unsigned int
.text$mn:000042FE                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00004304                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00004309                 mov     [ebp+var_F2C], eax
.text$mn:0000430F                 push    0               ; __int32
.text$mn:00004311                 mov     edx, [ebp+var_F2C]
.text$mn:00004317                 push    edx             ; unsigned int
.text$mn:00004318                 push    8DAh            ; unsigned int
.text$mn:0000431D                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00004323                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00004328                 mov     [ebp+var_E9C], eax
.text$mn:0000432E                 push    0               ; __int32
.text$mn:00004330                 mov     eax, [ebp+var_F2C]
.text$mn:00004336                 push    eax             ; unsigned int
.text$mn:00004337                 push    8DBh            ; unsigned int
.text$mn:0000433C                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00004342                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00004347                 mov     [ebp+var_EB4], eax
.text$mn:0000434D                 push    0               ; __int32
.text$mn:0000434F                 mov     ecx, [ebp+var_E9C]
.text$mn:00004355                 push    ecx             ; unsigned int
.text$mn:00004356                 push    88Eh            ; unsigned int
.text$mn:0000435B                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00004361                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00004366                 push    0               ; __int32
.text$mn:00004368                 mov     edx, [ebp+var_EB4]
.text$mn:0000436E                 push    edx             ; unsigned int
.text$mn:0000436F                 push    890h            ; unsigned int
.text$mn:00004374                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:0000437A                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000437F                 push    offset $SG173627 ; "[A-Za-z]+://[A-Za-z0-9_\\-\\+~.:?&@=/%#"...
.text$mn:00004384                 push    offset $SG173628 ; "[A-Za-z]+://[A-Za-z0-9_\\-\\+~.:?&@=/%#"...
.text$mn:00004389                 call    _strlen
.text$mn:0000438E                 add     esp, 4
.text$mn:00004391                 push    eax             ; unsigned int
.text$mn:00004392                 push    895h            ; unsigned int
.text$mn:00004397                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:0000439D                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000043A2                 mov     [ebp+var_F94], eax
.text$mn:000043A8                 cmp     [ebp+var_F94], 0FFFFFFFEh
.text$mn:000043AF                 jz      loc_450D
.text$mn:000043B5                 cmp     [ebp+var_F94], 0FFFFFFFFh
.text$mn:000043BC                 jz      short loc_43F2
.text$mn:000043BE                 push    0               ; __int32
.text$mn:000043C0                 push    0               ; unsigned int
.text$mn:000043C2                 push    88Fh            ; unsigned int
.text$mn:000043C7                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:000043CD                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000043D2                 mov     [ebp+var_E9C], eax
.text$mn:000043D8                 push    0               ; __int32
.text$mn:000043DA                 push    0               ; unsigned int
.text$mn:000043DC                 push    891h            ; unsigned int
.text$mn:000043E1                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:000043E7                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000043EC                 mov     [ebp+var_EB4], eax
.text$mn:000043F2
.text$mn:000043F2 loc_43F2:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2F98j
.text$mn:000043F2                 mov     eax, [ebp+var_EB4]
.text$mn:000043F8                 sub     eax, [ebp+var_E9C]
.text$mn:000043FE                 cmp     eax, 208h
.text$mn:00004403                 jle     short loc_4417
.text$mn:00004405                 mov     ecx, [ebp+var_E9C]
.text$mn:0000440B                 add     ecx, 208h
.text$mn:00004411                 mov     [ebp+var_EB4], ecx
.text$mn:00004417
.text$mn:00004417 loc_4417:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2FDFj
.text$mn:00004417                 mov     edx, [ebp+var_EB4]
.text$mn:0000441D                 push    edx             ; int
.text$mn:0000441E                 mov     eax, [ebp+var_E9C]
.text$mn:00004424                 push    eax             ; int
.text$mn:00004425                 push    208h            ; unsigned int
.text$mn:0000442A                 lea     ecx, [ebp+Src]
.text$mn:00004430                 push    ecx             ; wchar_t *
.text$mn:00004431                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00004437                 call    ?getGenericText@ScintillaEditView@@QBEXPA_WIHH@Z ; ScintillaEditView::getGenericText(wchar_t *,uint,int,int)
.text$mn:0000443C                 push    208h            ; MaxCount
.text$mn:00004441                 lea     edx, [ebp+Src]
.text$mn:00004447                 push    edx             ; Src
.text$mn:00004448                 call    _wcsnlen
.text$mn:0000444D                 add     esp, 8
.text$mn:00004450                 sub     eax, 1
.text$mn:00004453                 mov     [ebp+var_EBC], eax
.text$mn:00004459                 js      short loc_44C5
.text$mn:0000445B                 mov     eax, [ebp+var_EBC]
.text$mn:00004461                 movzx   ecx, [ebp+eax*2+Src]
.text$mn:00004469                 cmp     ecx, 2Ch ; ','
.text$mn:0000446C                 jz      short loc_4494
.text$mn:0000446E                 mov     edx, [ebp+var_EBC]
.text$mn:00004474                 movzx   eax, [ebp+edx*2+Src]
.text$mn:0000447C                 cmp     eax, 29h ; ')'
.text$mn:0000447F                 jz      short loc_4494
.text$mn:00004481                 mov     ecx, [ebp+var_EBC]
.text$mn:00004487                 movzx   edx, [ebp+ecx*2+Src]
.text$mn:0000448F                 cmp     edx, 28h ; '('
.text$mn:00004492                 jnz     short loc_44C5
.text$mn:00004494
.text$mn:00004494 loc_4494:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+3048j
.text$mn:00004494                                         ; Notepad_plus::notify(SCNotification *)+305Bj
.text$mn:00004494                 mov     eax, [ebp+var_EBC]
.text$mn:0000449A                 shl     eax, 1
.text$mn:0000449C                 mov     [ebp+var_F10], eax
.text$mn:000044A2                 cmp     [ebp+var_F10], 410h
.text$mn:000044AC                 jnb     short loc_44B0
.text$mn:000044AE                 jmp     short loc_44B5
.text$mn:000044B0 ; ---------------------------------------------------------------------------
.text$mn:000044B0
.text$mn:000044B0 loc_44B0:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+3088j
.text$mn:000044B0                 call    ___report_rangecheckfailure
.text$mn:000044B5
.text$mn:000044B5 loc_44B5:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+308Aj
.text$mn:000044B5                 xor     ecx, ecx
.text$mn:000044B7                 mov     edx, [ebp+var_F10]
.text$mn:000044BD                 mov     [ebp+edx+Src], cx
.text$mn:000044C5
.text$mn:000044C5 loc_44C5:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+3035j
.text$mn:000044C5                                         ; Notepad_plus::notify(SCNotification *)+306Ej
.text$mn:000044C5                 push    5               ; nShowCmd
.text$mn:000044C7                 push    0               ; lpDirectory
.text$mn:000044C9                 push    0               ; lpParameters
.text$mn:000044CB                 lea     eax, [ebp+Src]
.text$mn:000044D1                 push    eax             ; lpFile
.text$mn:000044D2                 push    offset $SG173637 ; "open"
.text$mn:000044D7                 mov     ecx, [ebp+var_E44]
.text$mn:000044DD                 mov     ecx, [ecx+4]    ; this
.text$mn:000044E0                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000044E5                 push    eax             ; hwnd
.text$mn:000044E6                 call    dword ptr ds:__imp__ShellExecuteW@24 ; ShellExecuteW(x,x,x,x,x,x)
.text$mn:000044EC                 mov     edx, [ebp+var_E44]
.text$mn:000044F2                 mov     byte ptr [edx+54B69h], 1
.text$mn:000044F9                 push    0               ; __int32
.text$mn:000044FB                 push    0               ; unsigned int
.text$mn:000044FD                 push    98Ch            ; unsigned int
.text$mn:00004502                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00004508                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000450D
.text$mn:0000450D loc_450D:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+2F8Bj
.text$mn:0000450D                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:00004512 ; ---------------------------------------------------------------------------
.text$mn:00004512
.text$mn:00004512 $LN10:                                  ; CODE XREF: Notepad_plus::notify(SCNotification *)+1C1j
.text$mn:00004512                                         ; DATA XREF: .text$mn:$LN305o
.text$mn:00004512                 push    0               ; jumptable 000015E5 case 10
.text$mn:00004514                 mov     eax, [ebp+arg_0]
.text$mn:00004517                 mov     ecx, [eax+0Ch]
.text$mn:0000451A                 push    ecx             ; unsigned int
.text$mn:0000451B                 push    876h            ; unsigned int
.text$mn:00004520                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:00004526                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000452B                 mov     [ebp+var_ED4], eax
.text$mn:00004531                 push    0               ; __int32
.text$mn:00004533                 mov     edx, [ebp+arg_0]
.text$mn:00004536                 mov     eax, [edx+0Ch]
.text$mn:00004539                 mov     ecx, [ebp+arg_0]
.text$mn:0000453C                 add     eax, [ecx+20h]
.text$mn:0000453F                 push    eax             ; unsigned int
.text$mn:00004540                 push    876h            ; unsigned int
.text$mn:00004545                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:0000454B                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00004550                 mov     [ebp+var_EC4], eax
.text$mn:00004556                 mov     edx, [ebp+var_ED4]
.text$mn:0000455C                 cmp     edx, [ebp+var_EC4]
.text$mn:00004562                 jge     short loc_4572
.text$mn:00004564                 mov     eax, [ebp+var_ED4]
.text$mn:0000456A                 mov     [ebp+var_F6C], eax
.text$mn:00004570                 jmp     short loc_457E
.text$mn:00004572 ; ---------------------------------------------------------------------------
.text$mn:00004572
.text$mn:00004572 loc_4572:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+313Ej
.text$mn:00004572                 mov     ecx, [ebp+var_EC4]
.text$mn:00004578                 mov     [ebp+var_F6C], ecx
.text$mn:0000457E
.text$mn:0000457E loc_457E:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+314Cj
.text$mn:0000457E                 mov     edx, [ebp+var_F6C]
.text$mn:00004584                 mov     [ebp+var_1084], edx
.text$mn:0000458A                 mov     eax, [ebp+var_ED4]
.text$mn:00004590                 cmp     eax, [ebp+var_EC4]
.text$mn:00004596                 jle     short loc_45A6
.text$mn:00004598                 mov     ecx, [ebp+var_ED4]
.text$mn:0000459E                 mov     [ebp+var_F18], ecx
.text$mn:000045A4                 jmp     short loc_45B2
.text$mn:000045A6 ; ---------------------------------------------------------------------------
.text$mn:000045A6
.text$mn:000045A6 loc_45A6:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+3172j
.text$mn:000045A6                 mov     edx, [ebp+var_EC4]
.text$mn:000045AC                 mov     [ebp+var_F18], edx
.text$mn:000045B2
.text$mn:000045B2 loc_45B2:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+3180j
.text$mn:000045B2                 mov     eax, [ebp+var_F18]
.text$mn:000045B8                 mov     [ebp+var_110C], eax
.text$mn:000045BE                 mov     ecx, [ebp+var_1084]
.text$mn:000045C4                 mov     [ebp+var_ECC], ecx
.text$mn:000045CA                 jmp     short loc_45DB
.text$mn:000045CC ; ---------------------------------------------------------------------------
.text$mn:000045CC
.text$mn:000045CC loc_45CC:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+31DEj
.text$mn:000045CC                 mov     edx, [ebp+var_ECC]
.text$mn:000045D2                 add     edx, 1
.text$mn:000045D5                 mov     [ebp+var_ECC], edx
.text$mn:000045DB
.text$mn:000045DB loc_45DB:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+31A6j
.text$mn:000045DB                 mov     eax, [ebp+var_ECC]
.text$mn:000045E1                 cmp     eax, [ebp+var_110C]
.text$mn:000045E7                 jg      short loc_4604
.text$mn:000045E9                 push    0               ; __int32
.text$mn:000045EB                 mov     ecx, [ebp+var_ECC]
.text$mn:000045F1                 push    ecx             ; unsigned int
.text$mn:000045F2                 push    8B8h            ; unsigned int
.text$mn:000045F7                 mov     ecx, [ebp+var_E4C] ; this
.text$mn:000045FD                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00004602                 jmp     short loc_45CC
.text$mn:00004604 ; ---------------------------------------------------------------------------
.text$mn:00004604
.text$mn:00004604 loc_4604:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+31C3j
.text$mn:00004604                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:00004609 ; ---------------------------------------------------------------------------
.text$mn:00004609
.text$mn:00004609 loc_4609:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+18Fj
.text$mn:00004609                 movzx   edx, [ebp+var_E45]
.text$mn:00004610                 test    edx, edx
.text$mn:00004612                 jz      short loc_4627
.text$mn:00004614                 mov     eax, [ebp+var_E44]
.text$mn:0000461A                 add     eax, 198h
.text$mn:0000461F                 mov     [ebp+var_FAC], eax
.text$mn:00004625                 jmp     short loc_4639
.text$mn:00004627 ; ---------------------------------------------------------------------------
.text$mn:00004627
.text$mn:00004627 loc_4627:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+31EEj
.text$mn:00004627                 mov     ecx, [ebp+var_E44]
.text$mn:0000462D                 add     ecx, 270h
.text$mn:00004633                 mov     [ebp+var_FAC], ecx
.text$mn:00004639
.text$mn:00004639 loc_4639:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+3201j
.text$mn:00004639                 mov     edx, [ebp+var_FAC]
.text$mn:0000463F                 mov     [ebp+var_FD8], edx
.text$mn:00004645                 mov     eax, [ebp+arg_0]
.text$mn:00004648                 mov     ecx, [eax+0Ch]
.text$mn:0000464B                 push    ecx             ; int
.text$mn:0000464C                 mov     ecx, [ebp+var_FD8] ; this
.text$mn:00004652                 call    ?callTipClick@AutoCompletion@@QAEXH@Z ; AutoCompletion::callTipClick(int)
.text$mn:00004657                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:0000465C ; ---------------------------------------------------------------------------
.text$mn:0000465C
.text$mn:0000465C loc_465C:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+1FEj
.text$mn:0000465C                 push    0               ; lParam
.text$mn:0000465E                 push    0               ; wParam
.text$mn:00004660                 push    5               ; Msg
.text$mn:00004662                 mov     edx, [ebp+var_E44]
.text$mn:00004668                 mov     ecx, [edx+4]    ; this
.text$mn:0000466B                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00004670                 push    eax             ; hWnd
.text$mn:00004671                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00004677                 jmp     $LN190          ; jumptable 000015E5 default case
.text$mn:0000467C ; ---------------------------------------------------------------------------
.text$mn:0000467C
.text$mn:0000467C loc_467C:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+21Ej
.text$mn:0000467C                 mov     eax, [ebp+arg_0]
.text$mn:0000467F                 mov     [ebp+var_E88], eax
.text$mn:00004685                 mov     ecx, [ebp+var_E44]
.text$mn:0000468B                 add     ecx, 87Ch
.text$mn:00004691                 mov     [ebp+var_F00], ecx
.text$mn:00004697                 mov     ecx, [ebp+var_E44]
.text$mn:0000469D                 add     ecx, 89Ch       ; this
.text$mn:000046A3                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000046A8                 mov     edx, [ebp+var_E88]
.text$mn:000046AE                 cmp     eax, [edx]
.text$mn:000046B0                 jnz     short loc_46C3
.text$mn:000046B2                 mov     eax, [ebp+var_E44]
.text$mn:000046B8                 add     eax, 89Ch
.text$mn:000046BD                 mov     [ebp+var_F00], eax
.text$mn:000046C3
.text$mn:000046C3 loc_46C3:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+328Cj
.text$mn:000046C3                 mov     ecx, [ebp+var_E88]
.text$mn:000046C9                 cmp     dword ptr [ecx+10h], 0
.text$mn:000046CD                 jnz     short loc_472C
.text$mn:000046CF                 mov     edx, [ebp+var_E88]
.text$mn:000046D5                 mov     eax, [edx+18h]
.text$mn:000046D8                 mov     [ebp+var_FC8.x], eax
.text$mn:000046DE                 mov     ecx, [ebp+var_E88]
.text$mn:000046E4                 mov     edx, [ecx+24h]
.text$mn:000046E7                 mov     [ebp+var_FC8.y], edx
.text$mn:000046ED                 lea     eax, [ebp+var_FC8]
.text$mn:000046F3                 push    eax             ; lpPoint
.text$mn:000046F4                 mov     ecx, [ebp+var_F00] ; this
.text$mn:000046FA                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000046FF                 push    eax             ; hWnd
.text$mn:00004700                 call    dword ptr ds:__imp__ClientToScreen@8 ; ClientToScreen(x,x)
.text$mn:00004706                 mov     ecx, [ebp+var_FC8.y]
.text$mn:0000470C                 push    ecx
.text$mn:0000470D                 mov     edx, [ebp+var_FC8.x]
.text$mn:00004713                 push    edx             ; struct tagPOINT
.text$mn:00004714                 mov     ecx, [ebp+var_E44]
.text$mn:0000471A                 add     ecx, 6B0h       ; this
.text$mn:00004720                 call    ?doPopop@ToolBar@@QAEXUtagPOINT@@@Z ; ToolBar::doPopop(tagPOINT)
.text$mn:00004725                 mov     eax, 1
.text$mn:0000472A                 jmp     short loc_4795
.text$mn:0000472C ; ---------------------------------------------------------------------------
.text$mn:0000472C
.text$mn:0000472C loc_472C:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+32A9j
.text$mn:0000472C                 push    38h ; '8'       ; Size
.text$mn:0000472E                 push    0               ; Val
.text$mn:00004730                 lea     eax, [ebp+Dst]
.text$mn:00004736                 push    eax             ; Dst
.text$mn:00004737                 call    _memset
.text$mn:0000473C                 add     esp, 0Ch
.text$mn:0000473F                 mov     [ebp+Dst], 38h ; '8'
.text$mn:00004749                 mov     [ebp+var_11F4], 10h
.text$mn:00004753                 lea     ecx, [ebp+Dst]
.text$mn:00004759                 push    ecx             ; lParam
.text$mn:0000475A                 mov     edx, [ebp+var_E88]
.text$mn:00004760                 mov     eax, [edx+0Ch]
.text$mn:00004763                 push    eax             ; wParam
.text$mn:00004764                 push    41Ch            ; Msg
.text$mn:00004769                 mov     ecx, [ebp+var_F00] ; this
.text$mn:0000476F                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00004774                 push    eax             ; hWnd
.text$mn:00004775                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000477B                 mov     ecx, [ebp+var_E88]
.text$mn:00004781                 push    ecx             ; lParam
.text$mn:00004782                 push    0               ; wParam
.text$mn:00004784                 push    4Eh ; 'N'       ; Msg
.text$mn:00004786                 mov     edx, [ebp+var_11D8]
.text$mn:0000478C                 push    edx             ; hWnd
.text$mn:0000478D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00004793
.text$mn:00004793 $LN190:                                 ; CODE XREF: Notepad_plus::notify(SCNotification *)+1AEj
.text$mn:00004793                                         ; Notepad_plus::notify(SCNotification *)+1C1j ...
.text$mn:00004793                 xor     eax, eax        ; jumptable 000015E5 default case
.text$mn:00004795
.text$mn:00004795 loc_4795:                               ; CODE XREF: Notepad_plus::notify(SCNotification *)+8ADj
.text$mn:00004795                                         ; Notepad_plus::notify(SCNotification *)+B8Bj ...
.text$mn:00004795                 mov     ecx, [ebp+var_C]
.text$mn:00004798                 mov     large fs:0, ecx
.text$mn:0000479F                 pop     ecx
.text$mn:000047A0                 pop     edi
.text$mn:000047A1                 pop     esi
.text$mn:000047A2                 pop     ebx
.text$mn:000047A3                 mov     ecx, [ebp+var_14]
.text$mn:000047A6                 xor     ecx, ebp
.text$mn:000047A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000047AD                 mov     esp, ebp
.text$mn:000047AF                 pop     ebp
.text$mn:000047B0                 retn    4
.text$mn:000047B0 ; END OF FUNCTION CHUNK FOR ?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z
.text$mn:000047B0 ; ---------------------------------------------------------------------------
.text$mn:000047B3                 align 4
.text$mn:000047B4 $LN305          dd offset $LN90         ; DATA XREF: Notepad_plus::notify(SCNotification *)+1C1r
.text$mn:000047B4                 dd offset $LN182        ; jump table for switch statement
.text$mn:000047B4                 dd offset $LN87
.text$mn:000047B4                 dd offset $LN49
.text$mn:000047B4                 dd offset $LN189
.text$mn:000047B4                 dd offset $LN27
.text$mn:000047B4                 dd offset $LN106
.text$mn:000047B4                 dd offset $LN10
.text$mn:000047B4                 dd offset $LN26
.text$mn:000047B4                 dd offset $LN16
.text$mn:000047B4                 dd offset $LN190
.text$mn:000047E0 $LN303          db      0,     1,     1,   0Ah
.text$mn:000047E0                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+1BAr
.text$mn:000047E0                 db    0Ah,     2,     3,     4 ; indirect table for switch statement
.text$mn:000047E0                 db      5,     6,     7,   0Ah
.text$mn:000047E0                 db      8,   0Ah,   0Ah,   0Ah
.text$mn:000047E0                 db    0Ah,   0Ah,   0Ah,     9
.text$mn:000047E0 _text$mn        ends
.text$mn:000047E0
.text$x:000047F4 ; ===========================================================================
.text$x:000047F4
.text$x:000047F4 ; Segment type: Pure code
.text$x:000047F4 ; Segment permissions: Read/Execute
.text$x:000047F4 _text$x         segment para public 'CODE' use32
.text$x:000047F4                 assume cs:_text$x
.text$x:000047F4                 ;org 47F4h
.text$x:000047F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000047F4
.text$x:000047F4 ; =============== S U B R O U T I N E =======================================
.text$x:000047F4
.text$x:000047F4
.text$x:000047F4 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$2 proc near
.text$x:000047F4                                         ; DATA XREF: .xdata$x:0000BD38o
.text$x:000047F4                 lea     ecx, [ebp-117Ch]
.text$x:000047FA                 jmp     ??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::~vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)
.text$x:000047FA __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$2 endp
.text$x:000047FA
.text$x:000047FF
.text$x:000047FF ; =============== S U B R O U T I N E =======================================
.text$x:000047FF
.text$x:000047FF
.text$x:000047FF __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$3 proc near
.text$x:000047FF                                         ; DATA XREF: .xdata$x:0000BD40o
.text$x:000047FF                 lea     ecx, [ebp-828h] ; this
.text$x:00004805                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004805 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$3 endp
.text$x:00004805
.text$x:0000480A
.text$x:0000480A ; =============== S U B R O U T I N E =======================================
.text$x:0000480A
.text$x:0000480A
.text$x:0000480A __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$4 proc near
.text$x:0000480A                                         ; DATA XREF: .xdata$x:0000BD48o
.text$x:0000480A                 lea     ecx, [ebp-0D8Ch] ; this
.text$x:00004810                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004810 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$4 endp
.text$x:00004810
.text$x:00004815
.text$x:00004815 ; =============== S U B R O U T I N E =======================================
.text$x:00004815
.text$x:00004815
.text$x:00004815 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$5 proc near
.text$x:00004815                                         ; DATA XREF: .xdata$x:0000BD50o
.text$x:00004815                 lea     ecx, [ebp-710h]
.text$x:0000481B                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000481B __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$5 endp
.text$x:0000481B
.text$x:00004820
.text$x:00004820 ; =============== S U B R O U T I N E =======================================
.text$x:00004820
.text$x:00004820
.text$x:00004820 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$6 proc near
.text$x:00004820                                         ; DATA XREF: .xdata$x:0000BD58o
.text$x:00004820                 lea     ecx, [ebp-748h]
.text$x:00004826                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00004826 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$6 endp
.text$x:00004826
.text$x:0000482B
.text$x:0000482B ; =============== S U B R O U T I N E =======================================
.text$x:0000482B
.text$x:0000482B
.text$x:0000482B __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$7 proc near
.text$x:0000482B                                         ; DATA XREF: .xdata$x:0000BD60o
.text$x:0000482B                 lea     ecx, [ebp-72Ch]
.text$x:00004831                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00004831 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$7 endp
.text$x:00004831
.text$x:00004836
.text$x:00004836 ; =============== S U B R O U T I N E =======================================
.text$x:00004836
.text$x:00004836
.text$x:00004836 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$8 proc near
.text$x:00004836                                         ; DATA XREF: .xdata$x:0000BD68o
.text$x:00004836                 lea     ecx, [ebp-118Ch]
.text$x:0000483C                 jmp     ??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::~vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)
.text$x:0000483C __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$8 endp
.text$x:0000483C
.text$x:00004841
.text$x:00004841 ; =============== S U B R O U T I N E =======================================
.text$x:00004841
.text$x:00004841
.text$x:00004841 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$9 proc near
.text$x:00004841                                         ; DATA XREF: .xdata$x:0000BD70o
.text$x:00004841                 lea     ecx, [ebp-8DCh] ; this
.text$x:00004847                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004847 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$9 endp
.text$x:00004847
.text$x:0000484C
.text$x:0000484C ; =============== S U B R O U T I N E =======================================
.text$x:0000484C
.text$x:0000484C
.text$x:0000484C __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$10 proc near
.text$x:0000484C                                         ; DATA XREF: .xdata$x:0000BD78o
.text$x:0000484C                 lea     ecx, [ebp-0BACh] ; this
.text$x:00004852                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004852 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$10 endp
.text$x:00004852
.text$x:00004857
.text$x:00004857 ; =============== S U B R O U T I N E =======================================
.text$x:00004857
.text$x:00004857
.text$x:00004857 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$11 proc near
.text$x:00004857                                         ; DATA XREF: .xdata$x:0000BD80o
.text$x:00004857                 lea     ecx, [ebp-0E98h]
.text$x:0000485D                 jmp     ??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::~vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)
.text$x:0000485D __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$11 endp
.text$x:0000485D
.text$x:00004862
.text$x:00004862 ; =============== S U B R O U T I N E =======================================
.text$x:00004862
.text$x:00004862
.text$x:00004862 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$12 proc near
.text$x:00004862                                         ; DATA XREF: .xdata$x:0000BD88o
.text$x:00004862                 lea     ecx, [ebp-954h] ; this
.text$x:00004868                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004868 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$12 endp
.text$x:00004868
.text$x:0000486D
.text$x:0000486D ; =============== S U B R O U T I N E =======================================
.text$x:0000486D
.text$x:0000486D
.text$x:0000486D __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$13 proc near
.text$x:0000486D                                         ; DATA XREF: .xdata$x:0000BD90o
.text$x:0000486D                 lea     ecx, [ebp-0D14h] ; this
.text$x:00004873                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004873 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$13 endp
.text$x:00004873
.text$x:00004878
.text$x:00004878 ; =============== S U B R O U T I N E =======================================
.text$x:00004878
.text$x:00004878
.text$x:00004878 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$14 proc near
.text$x:00004878                                         ; DATA XREF: .xdata$x:0000BD98o
.text$x:00004878                 lea     ecx, [ebp-9CCh] ; this
.text$x:0000487E                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:0000487E __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$14 endp
.text$x:0000487E
.text$x:00004883
.text$x:00004883 ; =============== S U B R O U T I N E =======================================
.text$x:00004883
.text$x:00004883
.text$x:00004883 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$15 proc near
.text$x:00004883                                         ; DATA XREF: .xdata$x:0000BDA0o
.text$x:00004883                 lea     ecx, [ebp-7B0h] ; this
.text$x:00004889                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004889 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$15 endp
.text$x:00004889
.text$x:0000488E
.text$x:0000488E ; =============== S U B R O U T I N E =======================================
.text$x:0000488E
.text$x:0000488E
.text$x:0000488E __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$16 proc near
.text$x:0000488E                                         ; DATA XREF: .xdata$x:0000BDA8o
.text$x:0000488E                 lea     ecx, [ebp-0A44h] ; this
.text$x:00004894                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004894 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$16 endp
.text$x:00004894
.text$x:00004899
.text$x:00004899 ; =============== S U B R O U T I N E =======================================
.text$x:00004899
.text$x:00004899
.text$x:00004899 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$17 proc near
.text$x:00004899                                         ; DATA XREF: .xdata$x:0000BDB0o
.text$x:00004899                 lea     ecx, [ebp-0E04h] ; this
.text$x:0000489F                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:0000489F __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$17 endp
.text$x:0000489F
.text$x:000048A4
.text$x:000048A4 ; =============== S U B R O U T I N E =======================================
.text$x:000048A4
.text$x:000048A4
.text$x:000048A4 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$18 proc near
.text$x:000048A4                                         ; DATA XREF: .xdata$x:0000BDB8o
.text$x:000048A4                 lea     ecx, [ebp-0ABCh] ; this
.text$x:000048AA                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:000048AA __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$18 endp
.text$x:000048AA
.text$x:000048AF
.text$x:000048AF ; =============== S U B R O U T I N E =======================================
.text$x:000048AF
.text$x:000048AF
.text$x:000048AF __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$19 proc near
.text$x:000048AF                                         ; DATA XREF: .xdata$x:0000BDC0o
.text$x:000048AF                 lea     ecx, [ebp-0C9Ch] ; this
.text$x:000048B5                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:000048B5 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$19 endp
.text$x:000048B5
.text$x:000048BA
.text$x:000048BA ; =============== S U B R O U T I N E =======================================
.text$x:000048BA
.text$x:000048BA
.text$x:000048BA __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$20 proc near
.text$x:000048BA                                         ; DATA XREF: .xdata$x:0000BDC8o
.text$x:000048BA                 lea     ecx, [ebp-0B34h] ; this
.text$x:000048C0                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:000048C0 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$20 endp
.text$x:000048C0
.text$x:000048C5
.text$x:000048C5 ; =============== S U B R O U T I N E =======================================
.text$x:000048C5
.text$x:000048C5
.text$x:000048C5 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$21 proc near
.text$x:000048C5                                         ; DATA XREF: .xdata$x:0000BDD0o
.text$x:000048C5                 lea     ecx, [ebp-7ECh] ; this
.text$x:000048CB                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:000048CB __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$21 endp
.text$x:000048CB
.text$x:000048D0
.text$x:000048D0 ; =============== S U B R O U T I N E =======================================
.text$x:000048D0
.text$x:000048D0
.text$x:000048D0 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$22 proc near
.text$x:000048D0                                         ; DATA XREF: .xdata$x:0000BDD8o
.text$x:000048D0                 lea     ecx, [ebp-8A0h] ; this
.text$x:000048D6                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:000048D6 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$22 endp
.text$x:000048D6
.text$x:000048DB
.text$x:000048DB ; =============== S U B R O U T I N E =======================================
.text$x:000048DB
.text$x:000048DB
.text$x:000048DB __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$23 proc near
.text$x:000048DB                                         ; DATA XREF: .xdata$x:0000BDE0o
.text$x:000048DB                 lea     ecx, [ebp-918h] ; this
.text$x:000048E1                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:000048E1 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$23 endp
.text$x:000048E1
.text$x:000048E6
.text$x:000048E6 ; =============== S U B R O U T I N E =======================================
.text$x:000048E6
.text$x:000048E6
.text$x:000048E6 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$24 proc near
.text$x:000048E6                                         ; DATA XREF: .xdata$x:0000BDE8o
.text$x:000048E6                 lea     ecx, [ebp-990h] ; this
.text$x:000048EC                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:000048EC __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$24 endp
.text$x:000048EC
.text$x:000048F1
.text$x:000048F1 ; =============== S U B R O U T I N E =======================================
.text$x:000048F1
.text$x:000048F1
.text$x:000048F1 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$25 proc near
.text$x:000048F1                                         ; DATA XREF: .xdata$x:0000BDF0o
.text$x:000048F1                 lea     ecx, [ebp-0A08h] ; this
.text$x:000048F7                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:000048F7 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$25 endp
.text$x:000048F7
.text$x:000048FC
.text$x:000048FC ; =============== S U B R O U T I N E =======================================
.text$x:000048FC
.text$x:000048FC
.text$x:000048FC __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$26 proc near
.text$x:000048FC                                         ; DATA XREF: .xdata$x:0000BDF8o
.text$x:000048FC                 lea     ecx, [ebp-0A80h] ; this
.text$x:00004902                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004902 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$26 endp
.text$x:00004902
.text$x:00004907
.text$x:00004907 ; =============== S U B R O U T I N E =======================================
.text$x:00004907
.text$x:00004907
.text$x:00004907 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$27 proc near
.text$x:00004907                                         ; DATA XREF: .xdata$x:0000BE00o
.text$x:00004907                 lea     ecx, [ebp-0AF8h] ; this
.text$x:0000490D                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:0000490D __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$27 endp
.text$x:0000490D
.text$x:00004912
.text$x:00004912 ; =============== S U B R O U T I N E =======================================
.text$x:00004912
.text$x:00004912
.text$x:00004912 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$28 proc near
.text$x:00004912                                         ; DATA XREF: .xdata$x:0000BE08o
.text$x:00004912                 lea     ecx, [ebp-0B70h] ; this
.text$x:00004918                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004918 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$28 endp
.text$x:00004918
.text$x:0000491D
.text$x:0000491D ; =============== S U B R O U T I N E =======================================
.text$x:0000491D
.text$x:0000491D
.text$x:0000491D __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$29 proc near
.text$x:0000491D                                         ; DATA XREF: .xdata$x:0000BE10o
.text$x:0000491D                 lea     ecx, [ebp-0BE8h] ; this
.text$x:00004923                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004923 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$29 endp
.text$x:00004923
.text$x:00004928
.text$x:00004928 ; =============== S U B R O U T I N E =======================================
.text$x:00004928
.text$x:00004928
.text$x:00004928 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$30 proc near
.text$x:00004928                                         ; DATA XREF: .xdata$x:0000BE18o
.text$x:00004928                 lea     ecx, [ebp-0C60h] ; this
.text$x:0000492E                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:0000492E __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$30 endp
.text$x:0000492E
.text$x:00004933
.text$x:00004933 ; =============== S U B R O U T I N E =======================================
.text$x:00004933
.text$x:00004933
.text$x:00004933 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$31 proc near
.text$x:00004933                                         ; DATA XREF: .xdata$x:0000BE20o
.text$x:00004933                 lea     ecx, [ebp-0CD8h] ; this
.text$x:00004939                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004939 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$31 endp
.text$x:00004939
.text$x:0000493E
.text$x:0000493E ; =============== S U B R O U T I N E =======================================
.text$x:0000493E
.text$x:0000493E
.text$x:0000493E __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$32 proc near
.text$x:0000493E                                         ; DATA XREF: .xdata$x:0000BE28o
.text$x:0000493E                 lea     ecx, [ebp-0D50h] ; this
.text$x:00004944                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004944 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$32 endp
.text$x:00004944
.text$x:00004949
.text$x:00004949 ; =============== S U B R O U T I N E =======================================
.text$x:00004949
.text$x:00004949
.text$x:00004949 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$33 proc near
.text$x:00004949                                         ; DATA XREF: .xdata$x:0000BE30o
.text$x:00004949                 lea     ecx, [ebp-0DC8h] ; this
.text$x:0000494F                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:0000494F __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$33 endp
.text$x:0000494F
.text$x:00004954
.text$x:00004954 ; =============== S U B R O U T I N E =======================================
.text$x:00004954
.text$x:00004954
.text$x:00004954 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$34 proc near
.text$x:00004954                                         ; DATA XREF: .xdata$x:0000BE38o
.text$x:00004954                 lea     ecx, [ebp-0E40h] ; this
.text$x:0000495A                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:0000495A __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$34 endp
.text$x:0000495A
.text$x:0000495F
.text$x:0000495F ; =============== S U B R O U T I N E =======================================
.text$x:0000495F
.text$x:0000495F
.text$x:0000495F __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$35 proc near
.text$x:0000495F                                         ; DATA XREF: .xdata$x:0000BE40o
.text$x:0000495F                 lea     ecx, [ebp-864h] ; this
.text$x:00004965                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004965 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$35 endp
.text$x:00004965
.text$x:0000496A
.text$x:0000496A ; =============== S U B R O U T I N E =======================================
.text$x:0000496A
.text$x:0000496A
.text$x:0000496A __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$36 proc near
.text$x:0000496A                                         ; DATA XREF: .xdata$x:0000BE48o
.text$x:0000496A                 lea     ecx, [ebp-0C24h] ; this
.text$x:00004970                 jmp     ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$x:00004970 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$36 endp
.text$x:00004970
.text$x:00004975
.text$x:00004975 ; =============== S U B R O U T I N E =======================================
.text$x:00004975
.text$x:00004975
.text$x:00004975 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$37 proc near
.text$x:00004975                                         ; DATA XREF: .xdata$x:0000BE50o
.text$x:00004975                 lea     ecx, [ebp-6E4h]
.text$x:0000497B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000497B __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$37 endp
.text$x:0000497B
.text$x:00004980
.text$x:00004980 ; =============== S U B R O U T I N E =======================================
.text$x:00004980
.text$x:00004980
.text$x:00004980 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$38 proc near
.text$x:00004980                                         ; DATA XREF: .xdata$x:0000BE58o
.text$x:00004980                 lea     ecx, [ebp-11A0h]
.text$x:00004986                 jmp     ??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::stack<uint,std::deque<uint,std::allocator<uint>>>::~stack<uint,std::deque<uint,std::allocator<uint>>>(void)
.text$x:00004986 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$38 endp
.text$x:00004986
.text$x:0000498B
.text$x:0000498B ; =============== S U B R O U T I N E =======================================
.text$x:0000498B
.text$x:0000498B
.text$x:0000498B __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$39 proc near
.text$x:0000498B                                         ; DATA XREF: .xdata$x:0000BE68o
.text$x:0000498B                 lea     ecx, [ebp-6C8h]
.text$x:00004991                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00004991 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$39 endp
.text$x:00004991
.text$x:00004996
.text$x:00004996 ; =============== S U B R O U T I N E =======================================
.text$x:00004996
.text$x:00004996
.text$x:00004996 __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$40 proc near
.text$x:00004996                                         ; DATA XREF: .xdata$x:0000BE78o
.text$x:00004996                 lea     ecx, [ebp-774h] ; this
.text$x:0000499C                 jmp     ??1recordedMacroStep@@QAE@XZ ; recordedMacroStep::~recordedMacroStep(void)
.text$x:0000499C __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$40 endp
.text$x:0000499C
.text$x:000049A1
.text$x:000049A1 ; =============== S U B R O U T I N E =======================================
.text$x:000049A1
.text$x:000049A1
.text$x:000049A1 __ehhandler$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z proc near
.text$x:000049A1                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+5o
.text$x:000049A1
.text$x:000049A1 arg_4           = dword ptr  8
.text$x:000049A1
.text$x:000049A1                 mov     edx, [esp+arg_4]
.text$x:000049A5                 lea     eax, [edx+0Ch]
.text$x:000049A8                 mov     ecx, [edx-11FCh]
.text$x:000049AE                 xor     ecx, eax
.text$x:000049B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000049B5                 mov     ecx, [edx-8]
.text$x:000049B8                 xor     ecx, eax
.text$x:000049BA                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000049BF                 mov     eax, offset __ehfuncinfo$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z
.text$x:000049C4                 jmp     ___CxxFrameHandler3
.text$x:000049C4 __ehhandler$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z endp
.text$x:000049C4
.text$x:000049C4 ; ---------------------------------------------------------------------------
.text$x:000049C9                 align 4
.text$x:000049C9 _text$x         ends
.text$x:000049C9
.text$mn:000049CC ; ===========================================================================
.text$mn:000049CC
.text$mn:000049CC ; Segment type: Pure code
.text$mn:000049CC ; Segment permissions: Read/Execute
.text$mn:000049CC _text$mn        segment para public 'CODE' use32
.text$mn:000049CC                 assume cs:_text$mn
.text$mn:000049CC                 ;org 49CCh
.text$mn:000049CC ; COMDAT (pick any)
.text$mn:000049CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000049CC
.text$mn:000049CC ; =============== S U B R O U T I N E =======================================
.text$mn:000049CC
.text$mn:000049CC ; Attributes: bp-based frame
.text$mn:000049CC
.text$mn:000049CC ; public: __thiscall std::allocator<unsigned int *>::allocator<unsigned int *>(class std::allocator<unsigned int> const &)
.text$mn:000049CC                 public ??$?0I@?$allocator@PAI@std@@QAE@ABV?$allocator@I@1@@Z
.text$mn:000049CC ??$?0I@?$allocator@PAI@std@@QAE@ABV?$allocator@I@1@@Z proc near
.text$mn:000049CC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint *>>::_Wrap_alloc<std::allocator<uint *>>(std::_Wrap_alloc<std::allocator<uint>> const &)+Ep
.text$mn:000049CC
.text$mn:000049CC var_4           = dword ptr -4
.text$mn:000049CC
.text$mn:000049CC                 push    ebp
.text$mn:000049CD                 mov     ebp, esp
.text$mn:000049CF                 push    ecx
.text$mn:000049D0                 mov     [ebp+var_4], ecx
.text$mn:000049D3                 mov     eax, [ebp+var_4]
.text$mn:000049D6                 mov     esp, ebp
.text$mn:000049D8                 pop     ebp
.text$mn:000049D9                 retn    4
.text$mn:000049D9 ??$?0I@?$allocator@PAI@std@@QAE@ABV?$allocator@I@1@@Z endp
.text$mn:000049D9
.text$mn:000049D9 _text$mn        ends
.text$mn:000049D9
.text$mn:000049DC ; ===========================================================================
.text$mn:000049DC
.text$mn:000049DC ; Segment type: Pure code
.text$mn:000049DC ; Segment permissions: Read/Execute
.text$mn:000049DC _text$mn        segment para public 'CODE' use32
.text$mn:000049DC                 assume cs:_text$mn
.text$mn:000049DC                 ;org 49DCh
.text$mn:000049DC ; COMDAT (pick any)
.text$mn:000049DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000049DC
.text$mn:000049DC ; =============== S U B R O U T I N E =======================================
.text$mn:000049DC
.text$mn:000049DC ; Attributes: bp-based frame
.text$mn:000049DC
.text$mn:000049DC ; public: __thiscall std::_Wrap_alloc<class std::allocator<unsigned int *>>::_Wrap_alloc<class std::allocator<unsigned int *>>(struct std::_Wrap_alloc<class std::allocator<unsigned int>> const &)
.text$mn:000049DC                 public ??$?0U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@I@std@@@1@@Z
.text$mn:000049DC ??$?0U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@I@std@@@1@@Z proc near
.text$mn:000049DC                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+19p
.text$mn:000049DC                                         ; std::deque<uint,std::allocator<uint>>::_Tidy(void)+19p
.text$mn:000049DC
.text$mn:000049DC var_4           = dword ptr -4
.text$mn:000049DC arg_0           = dword ptr  8
.text$mn:000049DC
.text$mn:000049DC                 push    ebp
.text$mn:000049DD                 mov     ebp, esp
.text$mn:000049DF                 push    ecx
.text$mn:000049E0                 mov     [ebp+var_4], ecx
.text$mn:000049E3                 mov     eax, [ebp+arg_0]
.text$mn:000049E6                 push    eax
.text$mn:000049E7                 mov     ecx, [ebp+var_4]
.text$mn:000049EA                 call    ??$?0I@?$allocator@PAI@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<uint *>::allocator<uint *>(std::allocator<uint> const &)
.text$mn:000049EF                 mov     eax, [ebp+var_4]
.text$mn:000049F2                 mov     esp, ebp
.text$mn:000049F4                 pop     ebp
.text$mn:000049F5                 retn    4
.text$mn:000049F5 ??$?0U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@I@std@@@1@@Z endp
.text$mn:000049F5
.text$mn:000049F5 _text$mn        ends
.text$mn:000049F5
.text$mn:000049F8 ; ===========================================================================
.text$mn:000049F8
.text$mn:000049F8 ; Segment type: Pure code
.text$mn:000049F8 ; Segment permissions: Read/Execute
.text$mn:000049F8 _text$mn        segment para public 'CODE' use32
.text$mn:000049F8                 assume cs:_text$mn
.text$mn:000049F8                 ;org 49F8h
.text$mn:000049F8 ; COMDAT (pick any)
.text$mn:000049F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000049F8
.text$mn:000049F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000049F8
.text$mn:000049F8 ; Attributes: bp-based frame
.text$mn:000049F8
.text$mn:000049F8 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:000049F8                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:000049F8 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:000049F8                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:000049F8
.text$mn:000049F8 var_4           = dword ptr -4
.text$mn:000049F8 arg_0           = dword ptr  8
.text$mn:000049F8
.text$mn:000049F8                 push    ebp
.text$mn:000049F9                 mov     ebp, esp
.text$mn:000049FB                 push    ecx
.text$mn:000049FC                 mov     [ebp+var_4], 0
.text$mn:00004A03                 cmp     [ebp+arg_0], 0
.text$mn:00004A07                 jnz     short loc_4A0B
.text$mn:00004A09                 jmp     short loc_4A2B
.text$mn:00004A0B ; ---------------------------------------------------------------------------
.text$mn:00004A0B
.text$mn:00004A0B loc_4A0B:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00004A0B                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00004A0F                 ja      short loc_4A26
.text$mn:00004A11                 mov     eax, [ebp+arg_0]
.text$mn:00004A14                 push    eax             ; unsigned int
.text$mn:00004A15                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00004A1A                 add     esp, 4
.text$mn:00004A1D                 mov     [ebp+var_4], eax
.text$mn:00004A20                 cmp     [ebp+var_4], 0
.text$mn:00004A24                 jnz     short loc_4A2B
.text$mn:00004A26
.text$mn:00004A26 loc_4A26:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00004A26                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00004A2B
.text$mn:00004A2B loc_4A2B:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00004A2B                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00004A2B                 mov     eax, [ebp+var_4]
.text$mn:00004A2E                 mov     esp, ebp
.text$mn:00004A30                 pop     ebp
.text$mn:00004A31                 retn
.text$mn:00004A31 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00004A31
.text$mn:00004A31 ; ---------------------------------------------------------------------------
.text$mn:00004A32                 align 4
.text$mn:00004A32 _text$mn        ends
.text$mn:00004A32
.text$mn:00004A34 ; ===========================================================================
.text$mn:00004A34
.text$mn:00004A34 ; Segment type: Pure code
.text$mn:00004A34 ; Segment permissions: Read/Execute
.text$mn:00004A34 _text$mn        segment para public 'CODE' use32
.text$mn:00004A34                 assume cs:_text$mn
.text$mn:00004A34                 ;org 4A34h
.text$mn:00004A34 ; COMDAT (pick any)
.text$mn:00004A34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004A34
.text$mn:00004A34 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A34
.text$mn:00004A34 ; Attributes: bp-based frame
.text$mn:00004A34
.text$mn:00004A34 ; unsigned int * __cdecl std::_Allocate<unsigned int>(unsigned int, unsigned int *)
.text$mn:00004A34                 public ??$_Allocate@I@std@@YAPAIIPAI@Z
.text$mn:00004A34 ??$_Allocate@I@std@@YAPAIIPAI@Z proc near
.text$mn:00004A34                                         ; CODE XREF: std::allocator<uint>::allocate(uint)+Dp
.text$mn:00004A34
.text$mn:00004A34 var_4           = dword ptr -4
.text$mn:00004A34 arg_0           = dword ptr  8
.text$mn:00004A34
.text$mn:00004A34                 push    ebp
.text$mn:00004A35                 mov     ebp, esp
.text$mn:00004A37                 push    ecx
.text$mn:00004A38                 mov     [ebp+var_4], 0
.text$mn:00004A3F                 cmp     [ebp+arg_0], 0
.text$mn:00004A43                 jnz     short loc_4A47
.text$mn:00004A45                 jmp     short loc_4A6D
.text$mn:00004A47 ; ---------------------------------------------------------------------------
.text$mn:00004A47
.text$mn:00004A47 loc_4A47:                               ; CODE XREF: std::_Allocate<uint>(uint,uint *)+Fj
.text$mn:00004A47                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:00004A4E                 ja      short loc_4A68
.text$mn:00004A50                 mov     eax, [ebp+arg_0]
.text$mn:00004A53                 shl     eax, 2
.text$mn:00004A56                 push    eax             ; unsigned int
.text$mn:00004A57                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00004A5C                 add     esp, 4
.text$mn:00004A5F                 mov     [ebp+var_4], eax
.text$mn:00004A62                 cmp     [ebp+var_4], 0
.text$mn:00004A66                 jnz     short loc_4A6D
.text$mn:00004A68
.text$mn:00004A68 loc_4A68:                               ; CODE XREF: std::_Allocate<uint>(uint,uint *)+1Aj
.text$mn:00004A68                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00004A6D
.text$mn:00004A6D loc_4A6D:                               ; CODE XREF: std::_Allocate<uint>(uint,uint *)+11j
.text$mn:00004A6D                                         ; std::_Allocate<uint>(uint,uint *)+32j
.text$mn:00004A6D                 mov     eax, [ebp+var_4]
.text$mn:00004A70                 mov     esp, ebp
.text$mn:00004A72                 pop     ebp
.text$mn:00004A73                 retn
.text$mn:00004A73 ??$_Allocate@I@std@@YAPAIIPAI@Z endp
.text$mn:00004A73
.text$mn:00004A73 _text$mn        ends
.text$mn:00004A73
.text$mn:00004A74 ; ===========================================================================
.text$mn:00004A74
.text$mn:00004A74 ; Segment type: Pure code
.text$mn:00004A74 ; Segment permissions: Read/Execute
.text$mn:00004A74 _text$mn        segment para public 'CODE' use32
.text$mn:00004A74                 assume cs:_text$mn
.text$mn:00004A74                 ;org 4A74h
.text$mn:00004A74 ; COMDAT (pick any)
.text$mn:00004A74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004A74
.text$mn:00004A74 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A74
.text$mn:00004A74 ; Attributes: bp-based frame
.text$mn:00004A74
.text$mn:00004A74 ; unsigned int * * __cdecl std::_Allocate<unsigned int *>(unsigned int, unsigned int * *)
.text$mn:00004A74                 public ??$_Allocate@PAI@std@@YAPAPAIIPAPAI@Z
.text$mn:00004A74 ??$_Allocate@PAI@std@@YAPAPAIIPAPAI@Z proc near
.text$mn:00004A74                                         ; CODE XREF: std::allocator<uint *>::allocate(uint)+Dp
.text$mn:00004A74
.text$mn:00004A74 var_4           = dword ptr -4
.text$mn:00004A74 arg_0           = dword ptr  8
.text$mn:00004A74
.text$mn:00004A74                 push    ebp
.text$mn:00004A75                 mov     ebp, esp
.text$mn:00004A77                 push    ecx
.text$mn:00004A78                 mov     [ebp+var_4], 0
.text$mn:00004A7F                 cmp     [ebp+arg_0], 0
.text$mn:00004A83                 jnz     short loc_4A87
.text$mn:00004A85                 jmp     short loc_4AAD
.text$mn:00004A87 ; ---------------------------------------------------------------------------
.text$mn:00004A87
.text$mn:00004A87 loc_4A87:                               ; CODE XREF: std::_Allocate<uint *>(uint,uint * *)+Fj
.text$mn:00004A87                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:00004A8E                 ja      short loc_4AA8
.text$mn:00004A90                 mov     eax, [ebp+arg_0]
.text$mn:00004A93                 shl     eax, 2
.text$mn:00004A96                 push    eax             ; unsigned int
.text$mn:00004A97                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00004A9C                 add     esp, 4
.text$mn:00004A9F                 mov     [ebp+var_4], eax
.text$mn:00004AA2                 cmp     [ebp+var_4], 0
.text$mn:00004AA6                 jnz     short loc_4AAD
.text$mn:00004AA8
.text$mn:00004AA8 loc_4AA8:                               ; CODE XREF: std::_Allocate<uint *>(uint,uint * *)+1Aj
.text$mn:00004AA8                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00004AAD
.text$mn:00004AAD loc_4AAD:                               ; CODE XREF: std::_Allocate<uint *>(uint,uint * *)+11j
.text$mn:00004AAD                                         ; std::_Allocate<uint *>(uint,uint * *)+32j
.text$mn:00004AAD                 mov     eax, [ebp+var_4]
.text$mn:00004AB0                 mov     esp, ebp
.text$mn:00004AB2                 pop     ebp
.text$mn:00004AB3                 retn
.text$mn:00004AB3 ??$_Allocate@PAI@std@@YAPAPAIIPAPAI@Z endp
.text$mn:00004AB3
.text$mn:00004AB3 _text$mn        ends
.text$mn:00004AB3
.text$mn:00004AB4 ; ===========================================================================
.text$mn:00004AB4
.text$mn:00004AB4 ; Segment type: Pure code
.text$mn:00004AB4 ; Segment permissions: Read/Execute
.text$mn:00004AB4 _text$mn        segment para public 'CODE' use32
.text$mn:00004AB4                 assume cs:_text$mn
.text$mn:00004AB4                 ;org 4AB4h
.text$mn:00004AB4 ; COMDAT (pick any)
.text$mn:00004AB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004AB4
.text$mn:00004AB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AB4
.text$mn:00004AB4 ; Attributes: bp-based frame
.text$mn:00004AB4
.text$mn:00004AB4 ; struct MenuItemUnit * __cdecl std::_Allocate<struct MenuItemUnit>(unsigned int, struct MenuItemUnit *)
.text$mn:00004AB4                 public ??$_Allocate@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@IPAU1@@Z
.text$mn:00004AB4 ??$_Allocate@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@IPAU1@@Z proc near
.text$mn:00004AB4                                         ; CODE XREF: std::allocator<MenuItemUnit>::allocate(uint)+Dp
.text$mn:00004AB4
.text$mn:00004AB4 var_4           = dword ptr -4
.text$mn:00004AB4 arg_0           = dword ptr  8
.text$mn:00004AB4
.text$mn:00004AB4                 push    ebp
.text$mn:00004AB5                 mov     ebp, esp
.text$mn:00004AB7                 push    ecx
.text$mn:00004AB8                 mov     [ebp+var_4], 0
.text$mn:00004ABF                 cmp     [ebp+arg_0], 0
.text$mn:00004AC3                 jnz     short loc_4AC7
.text$mn:00004AC5                 jmp     short loc_4AEB
.text$mn:00004AC7 ; ---------------------------------------------------------------------------
.text$mn:00004AC7
.text$mn:00004AC7 loc_4AC7:                               ; CODE XREF: std::_Allocate<MenuItemUnit>(uint,MenuItemUnit *)+Fj
.text$mn:00004AC7                 cmp     [ebp+arg_0], 4444444h
.text$mn:00004ACE                 ja      short loc_4AE6
.text$mn:00004AD0                 imul    eax, [ebp+arg_0], 3Ch
.text$mn:00004AD4                 push    eax             ; unsigned int
.text$mn:00004AD5                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00004ADA                 add     esp, 4
.text$mn:00004ADD                 mov     [ebp+var_4], eax
.text$mn:00004AE0                 cmp     [ebp+var_4], 0
.text$mn:00004AE4                 jnz     short loc_4AEB
.text$mn:00004AE6
.text$mn:00004AE6 loc_4AE6:                               ; CODE XREF: std::_Allocate<MenuItemUnit>(uint,MenuItemUnit *)+1Aj
.text$mn:00004AE6                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00004AEB
.text$mn:00004AEB loc_4AEB:                               ; CODE XREF: std::_Allocate<MenuItemUnit>(uint,MenuItemUnit *)+11j
.text$mn:00004AEB                                         ; std::_Allocate<MenuItemUnit>(uint,MenuItemUnit *)+30j
.text$mn:00004AEB                 mov     eax, [ebp+var_4]
.text$mn:00004AEE                 mov     esp, ebp
.text$mn:00004AF0                 pop     ebp
.text$mn:00004AF1                 retn
.text$mn:00004AF1 ??$_Allocate@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@IPAU1@@Z endp
.text$mn:00004AF1
.text$mn:00004AF1 ; ---------------------------------------------------------------------------
.text$mn:00004AF2                 align 4
.text$mn:00004AF2 _text$mn        ends
.text$mn:00004AF2
.text$mn:00004AF4 ; ===========================================================================
.text$mn:00004AF4
.text$mn:00004AF4 ; Segment type: Pure code
.text$mn:00004AF4 ; Segment permissions: Read/Execute
.text$mn:00004AF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004AF4                 assume cs:_text$mn
.text$mn:00004AF4                 ;org 4AF4h
.text$mn:00004AF4 ; COMDAT (pick any)
.text$mn:00004AF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004AF4
.text$mn:00004AF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AF4
.text$mn:00004AF4 ; Attributes: bp-based frame
.text$mn:00004AF4
.text$mn:00004AF4 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00004AF4                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00004AF4 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00004AF4                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00004AF4
.text$mn:00004AF4 var_4           = dword ptr -4
.text$mn:00004AF4 arg_0           = dword ptr  8
.text$mn:00004AF4
.text$mn:00004AF4                 push    ebp
.text$mn:00004AF5                 mov     ebp, esp
.text$mn:00004AF7                 push    ecx
.text$mn:00004AF8                 mov     [ebp+var_4], 0
.text$mn:00004AFF                 cmp     [ebp+arg_0], 0
.text$mn:00004B03                 jnz     short loc_4B07
.text$mn:00004B05                 jmp     short loc_4B2D
.text$mn:00004B07 ; ---------------------------------------------------------------------------
.text$mn:00004B07
.text$mn:00004B07 loc_4B07:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00004B07                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00004B0E                 ja      short loc_4B28
.text$mn:00004B10                 mov     eax, [ebp+arg_0]
.text$mn:00004B13                 shl     eax, 3
.text$mn:00004B16                 push    eax             ; unsigned int
.text$mn:00004B17                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00004B1C                 add     esp, 4
.text$mn:00004B1F                 mov     [ebp+var_4], eax
.text$mn:00004B22                 cmp     [ebp+var_4], 0
.text$mn:00004B26                 jnz     short loc_4B2D
.text$mn:00004B28
.text$mn:00004B28 loc_4B28:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00004B28                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00004B2D
.text$mn:00004B2D loc_4B2D:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00004B2D                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00004B2D                 mov     eax, [ebp+var_4]
.text$mn:00004B30                 mov     esp, ebp
.text$mn:00004B32                 pop     ebp
.text$mn:00004B33                 retn
.text$mn:00004B33 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00004B33
.text$mn:00004B33 _text$mn        ends
.text$mn:00004B33
.text$mn:00004B34 ; ===========================================================================
.text$mn:00004B34
.text$mn:00004B34 ; Segment type: Pure code
.text$mn:00004B34 ; Segment permissions: Read/Execute
.text$mn:00004B34 _text$mn        segment para public 'CODE' use32
.text$mn:00004B34                 assume cs:_text$mn
.text$mn:00004B34                 ;org 4B34h
.text$mn:00004B34 ; COMDAT (pick any)
.text$mn:00004B34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004B34
.text$mn:00004B34 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B34
.text$mn:00004B34 ; Attributes: bp-based frame
.text$mn:00004B34
.text$mn:00004B34 ; struct recordedMacroStep * __cdecl std::_Allocate<struct recordedMacroStep>(unsigned int, struct recordedMacroStep *)
.text$mn:00004B34                 public ??$_Allocate@UrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@IPAU1@@Z
.text$mn:00004B34 ??$_Allocate@UrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@IPAU1@@Z proc near
.text$mn:00004B34                                         ; CODE XREF: std::allocator<recordedMacroStep>::allocate(uint)+Dp
.text$mn:00004B34
.text$mn:00004B34 var_4           = dword ptr -4
.text$mn:00004B34 arg_0           = dword ptr  8
.text$mn:00004B34
.text$mn:00004B34                 push    ebp
.text$mn:00004B35                 mov     ebp, esp
.text$mn:00004B37                 push    ecx
.text$mn:00004B38                 mov     [ebp+var_4], 0
.text$mn:00004B3F                 cmp     [ebp+arg_0], 0
.text$mn:00004B43                 jnz     short loc_4B47
.text$mn:00004B45                 jmp     short loc_4B6B
.text$mn:00004B47 ; ---------------------------------------------------------------------------
.text$mn:00004B47
.text$mn:00004B47 loc_4B47:                               ; CODE XREF: std::_Allocate<recordedMacroStep>(uint,recordedMacroStep *)+Fj
.text$mn:00004B47                 cmp     [ebp+arg_0], 5D1745Dh
.text$mn:00004B4E                 ja      short loc_4B66
.text$mn:00004B50                 imul    eax, [ebp+arg_0], 2Ch
.text$mn:00004B54                 push    eax             ; unsigned int
.text$mn:00004B55                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00004B5A                 add     esp, 4
.text$mn:00004B5D                 mov     [ebp+var_4], eax
.text$mn:00004B60                 cmp     [ebp+var_4], 0
.text$mn:00004B64                 jnz     short loc_4B6B
.text$mn:00004B66
.text$mn:00004B66 loc_4B66:                               ; CODE XREF: std::_Allocate<recordedMacroStep>(uint,recordedMacroStep *)+1Aj
.text$mn:00004B66                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00004B6B
.text$mn:00004B6B loc_4B6B:                               ; CODE XREF: std::_Allocate<recordedMacroStep>(uint,recordedMacroStep *)+11j
.text$mn:00004B6B                                         ; std::_Allocate<recordedMacroStep>(uint,recordedMacroStep *)+30j
.text$mn:00004B6B                 mov     eax, [ebp+var_4]
.text$mn:00004B6E                 mov     esp, ebp
.text$mn:00004B70                 pop     ebp
.text$mn:00004B71                 retn
.text$mn:00004B71 ??$_Allocate@UrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@IPAU1@@Z endp
.text$mn:00004B71
.text$mn:00004B71 ; ---------------------------------------------------------------------------
.text$mn:00004B72                 align 4
.text$mn:00004B72 _text$mn        ends
.text$mn:00004B72
.text$mn:00004B74 ; ===========================================================================
.text$mn:00004B74
.text$mn:00004B74 ; Segment type: Pure code
.text$mn:00004B74 ; Segment permissions: Read/Execute
.text$mn:00004B74 _text$mn        segment para public 'CODE' use32
.text$mn:00004B74                 assume cs:_text$mn
.text$mn:00004B74                 ;org 4B74h
.text$mn:00004B74 ; COMDAT (pick any)
.text$mn:00004B74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004B74
.text$mn:00004B74 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B74
.text$mn:00004B74 ; Attributes: bp-based frame
.text$mn:00004B74
.text$mn:00004B74 ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:00004B74                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:00004B74 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:00004B74                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:00004B74
.text$mn:00004B74 var_4           = dword ptr -4
.text$mn:00004B74 arg_0           = dword ptr  8
.text$mn:00004B74
.text$mn:00004B74                 push    ebp
.text$mn:00004B75                 mov     ebp, esp
.text$mn:00004B77                 push    ecx
.text$mn:00004B78                 mov     [ebp+var_4], 0
.text$mn:00004B7F                 cmp     [ebp+arg_0], 0
.text$mn:00004B83                 jnz     short loc_4B87
.text$mn:00004B85                 jmp     short loc_4BAC
.text$mn:00004B87 ; ---------------------------------------------------------------------------
.text$mn:00004B87
.text$mn:00004B87 loc_4B87:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:00004B87                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:00004B8E                 ja      short loc_4BA7
.text$mn:00004B90                 mov     eax, [ebp+arg_0]
.text$mn:00004B93                 shl     eax, 1
.text$mn:00004B95                 push    eax             ; unsigned int
.text$mn:00004B96                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00004B9B                 add     esp, 4
.text$mn:00004B9E                 mov     [ebp+var_4], eax
.text$mn:00004BA1                 cmp     [ebp+var_4], 0
.text$mn:00004BA5                 jnz     short loc_4BAC
.text$mn:00004BA7
.text$mn:00004BA7 loc_4BA7:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:00004BA7                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00004BAC
.text$mn:00004BAC loc_4BAC:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:00004BAC                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:00004BAC                 mov     eax, [ebp+var_4]
.text$mn:00004BAF                 mov     esp, ebp
.text$mn:00004BB1                 pop     ebp
.text$mn:00004BB2                 retn
.text$mn:00004BB2 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:00004BB2
.text$mn:00004BB2 ; ---------------------------------------------------------------------------
.text$mn:00004BB3                 align 4
.text$mn:00004BB3 _text$mn        ends
.text$mn:00004BB3
.text$mn:00004BB4 ; ===========================================================================
.text$mn:00004BB4
.text$mn:00004BB4 ; Segment type: Pure code
.text$mn:00004BB4 ; Segment permissions: Read/Execute
.text$mn:00004BB4 _text$mn        segment para public 'CODE' use32
.text$mn:00004BB4                 assume cs:_text$mn
.text$mn:00004BB4                 ;org 4BB4h
.text$mn:00004BB4 ; COMDAT (pick any)
.text$mn:00004BB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004BB4
.text$mn:00004BB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BB4
.text$mn:00004BB4 ; Attributes: bp-based frame
.text$mn:00004BB4
.text$mn:00004BB4 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00004BB4                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00004BB4 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00004BB4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00004BB4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00004BB4
.text$mn:00004BB4 arg_0           = dword ptr  8
.text$mn:00004BB4 arg_4           = dword ptr  0Ch
.text$mn:00004BB4 arg_8           = dword ptr  10h
.text$mn:00004BB4
.text$mn:00004BB4                 push    ebp
.text$mn:00004BB5                 mov     ebp, esp
.text$mn:00004BB7                 cmp     [ebp+arg_0], 0
.text$mn:00004BBB                 jnz     short loc_4BD2
.text$mn:00004BBD                 mov     eax, [ebp+arg_8]
.text$mn:00004BC0                 push    eax             ; unsigned int
.text$mn:00004BC1                 mov     ecx, [ebp+arg_4]
.text$mn:00004BC4                 push    ecx             ; wchar_t *
.text$mn:00004BC5                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00004BCA                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00004BCF                 add     esp, 0Ch
.text$mn:00004BD2
.text$mn:00004BD2 loc_4BD2:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00004BD2                 pop     ebp
.text$mn:00004BD3                 retn
.text$mn:00004BD3 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00004BD3
.text$mn:00004BD3 _text$mn        ends
.text$mn:00004BD3
.text$mn:00004BD4 ; ===========================================================================
.text$mn:00004BD4
.text$mn:00004BD4 ; Segment type: Pure code
.text$mn:00004BD4 ; Segment permissions: Read/Execute
.text$mn:00004BD4 _text$mn        segment para public 'CODE' use32
.text$mn:00004BD4                 assume cs:_text$mn
.text$mn:00004BD4                 ;org 4BD4h
.text$mn:00004BD4 ; COMDAT (pick any)
.text$mn:00004BD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004BD4
.text$mn:00004BD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BD4
.text$mn:00004BD4 ; Attributes: bp-based frame
.text$mn:00004BD4
.text$mn:00004BD4 ; int __cdecl std::_Debug_pointer<unsigned int *>(int, wchar_t *, unsigned int)
.text$mn:00004BD4                 public ??$_Debug_pointer@PAI@std@@YAXPAPAIPB_WI@Z
.text$mn:00004BD4 ??$_Debug_pointer@PAI@std@@YAXPAPAIPB_WI@Z proc near
.text$mn:00004BD4                                         ; CODE XREF: std::_Debug_range2<uint * *>(uint * *,uint * *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00004BD4                                         ; std::_Debug_range2<uint * *>(uint * *,uint * *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00004BD4
.text$mn:00004BD4 arg_0           = dword ptr  8
.text$mn:00004BD4 arg_4           = dword ptr  0Ch
.text$mn:00004BD4 arg_8           = dword ptr  10h
.text$mn:00004BD4
.text$mn:00004BD4                 push    ebp
.text$mn:00004BD5                 mov     ebp, esp
.text$mn:00004BD7                 cmp     [ebp+arg_0], 0
.text$mn:00004BDB                 jnz     short loc_4BF2
.text$mn:00004BDD                 mov     eax, [ebp+arg_8]
.text$mn:00004BE0                 push    eax             ; unsigned int
.text$mn:00004BE1                 mov     ecx, [ebp+arg_4]
.text$mn:00004BE4                 push    ecx             ; wchar_t *
.text$mn:00004BE5                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00004BEA                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00004BEF                 add     esp, 0Ch
.text$mn:00004BF2
.text$mn:00004BF2 loc_4BF2:                               ; CODE XREF: std::_Debug_pointer<uint *>(uint * *,wchar_t const *,uint)+7j
.text$mn:00004BF2                 pop     ebp
.text$mn:00004BF3                 retn
.text$mn:00004BF3 ??$_Debug_pointer@PAI@std@@YAXPAPAIPB_WI@Z endp
.text$mn:00004BF3
.text$mn:00004BF3 _text$mn        ends
.text$mn:00004BF3
.text$mn:00004BF4 ; ===========================================================================
.text$mn:00004BF4
.text$mn:00004BF4 ; Segment type: Pure code
.text$mn:00004BF4 ; Segment permissions: Read/Execute
.text$mn:00004BF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004BF4                 assume cs:_text$mn
.text$mn:00004BF4                 ;org 4BF4h
.text$mn:00004BF4 ; COMDAT (pick any)
.text$mn:00004BF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004BF4
.text$mn:00004BF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BF4
.text$mn:00004BF4 ; Attributes: bp-based frame
.text$mn:00004BF4
.text$mn:00004BF4 ; int __cdecl std::_Debug_pointer<MenuItemUnit>(int, wchar_t *, unsigned int)
.text$mn:00004BF4                 public ??$_Debug_pointer@UMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@PB_WI@Z
.text$mn:00004BF4 ??$_Debug_pointer@UMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@PB_WI@Z proc near
.text$mn:00004BF4                                         ; CODE XREF: std::_Debug_range2<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00004BF4                                         ; std::_Debug_range2<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00004BF4
.text$mn:00004BF4 arg_0           = dword ptr  8
.text$mn:00004BF4 arg_4           = dword ptr  0Ch
.text$mn:00004BF4 arg_8           = dword ptr  10h
.text$mn:00004BF4
.text$mn:00004BF4                 push    ebp
.text$mn:00004BF5                 mov     ebp, esp
.text$mn:00004BF7                 cmp     [ebp+arg_0], 0
.text$mn:00004BFB                 jnz     short loc_4C12
.text$mn:00004BFD                 mov     eax, [ebp+arg_8]
.text$mn:00004C00                 push    eax             ; unsigned int
.text$mn:00004C01                 mov     ecx, [ebp+arg_4]
.text$mn:00004C04                 push    ecx             ; wchar_t *
.text$mn:00004C05                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00004C0A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00004C0F                 add     esp, 0Ch
.text$mn:00004C12
.text$mn:00004C12 loc_4C12:                               ; CODE XREF: std::_Debug_pointer<MenuItemUnit>(MenuItemUnit *,wchar_t const *,uint)+7j
.text$mn:00004C12                 pop     ebp
.text$mn:00004C13                 retn
.text$mn:00004C13 ??$_Debug_pointer@UMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@PB_WI@Z endp
.text$mn:00004C13
.text$mn:00004C13 _text$mn        ends
.text$mn:00004C13
.text$mn:00004C14 ; ===========================================================================
.text$mn:00004C14
.text$mn:00004C14 ; Segment type: Pure code
.text$mn:00004C14 ; Segment permissions: Read/Execute
.text$mn:00004C14 _text$mn        segment para public 'CODE' use32
.text$mn:00004C14                 assume cs:_text$mn
.text$mn:00004C14                 ;org 4C14h
.text$mn:00004C14 ; COMDAT (pick any)
.text$mn:00004C14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004C14
.text$mn:00004C14 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C14
.text$mn:00004C14 ; Attributes: bp-based frame
.text$mn:00004C14
.text$mn:00004C14 ; int __cdecl std::_Debug_pointer<recordedMacroStep>(int, wchar_t *, unsigned int)
.text$mn:00004C14                 public ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@PB_WI@Z
.text$mn:00004C14 ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@PB_WI@Z proc near
.text$mn:00004C14                                         ; CODE XREF: std::_Debug_range2<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00004C14                                         ; std::_Debug_range2<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00004C14
.text$mn:00004C14 arg_0           = dword ptr  8
.text$mn:00004C14 arg_4           = dword ptr  0Ch
.text$mn:00004C14 arg_8           = dword ptr  10h
.text$mn:00004C14
.text$mn:00004C14                 push    ebp
.text$mn:00004C15                 mov     ebp, esp
.text$mn:00004C17                 cmp     [ebp+arg_0], 0
.text$mn:00004C1B                 jnz     short loc_4C32
.text$mn:00004C1D                 mov     eax, [ebp+arg_8]
.text$mn:00004C20                 push    eax             ; unsigned int
.text$mn:00004C21                 mov     ecx, [ebp+arg_4]
.text$mn:00004C24                 push    ecx             ; wchar_t *
.text$mn:00004C25                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00004C2A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00004C2F                 add     esp, 0Ch
.text$mn:00004C32
.text$mn:00004C32 loc_4C32:                               ; CODE XREF: std::_Debug_pointer<recordedMacroStep>(recordedMacroStep *,wchar_t const *,uint)+7j
.text$mn:00004C32                 pop     ebp
.text$mn:00004C33                 retn
.text$mn:00004C33 ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@PB_WI@Z endp
.text$mn:00004C33
.text$mn:00004C33 _text$mn        ends
.text$mn:00004C33
.text$mn:00004C34 ; ===========================================================================
.text$mn:00004C34
.text$mn:00004C34 ; Segment type: Pure code
.text$mn:00004C34 ; Segment permissions: Read/Execute
.text$mn:00004C34 _text$mn        segment para public 'CODE' use32
.text$mn:00004C34                 assume cs:_text$mn
.text$mn:00004C34                 ;org 4C34h
.text$mn:00004C34 ; COMDAT (pick any)
.text$mn:00004C34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004C34
.text$mn:00004C34 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C34
.text$mn:00004C34 ; Attributes: bp-based frame
.text$mn:00004C34
.text$mn:00004C34 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:00004C34                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:00004C34 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:00004C34                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+15p
.text$mn:00004C34                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+1Dp ...
.text$mn:00004C34
.text$mn:00004C34 arg_0           = dword ptr  8
.text$mn:00004C34 arg_4           = dword ptr  0Ch
.text$mn:00004C34 arg_8           = dword ptr  10h
.text$mn:00004C34
.text$mn:00004C34                 push    ebp
.text$mn:00004C35                 mov     ebp, esp
.text$mn:00004C37                 cmp     [ebp+arg_0], 0
.text$mn:00004C3B                 jnz     short loc_4C52
.text$mn:00004C3D                 mov     eax, [ebp+arg_8]
.text$mn:00004C40                 push    eax             ; unsigned int
.text$mn:00004C41                 mov     ecx, [ebp+arg_4]
.text$mn:00004C44                 push    ecx             ; wchar_t *
.text$mn:00004C45                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00004C4A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00004C4F                 add     esp, 0Ch
.text$mn:00004C52
.text$mn:00004C52 loc_4C52:                               ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:00004C52                 pop     ebp
.text$mn:00004C53                 retn
.text$mn:00004C53 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:00004C53
.text$mn:00004C53 _text$mn        ends
.text$mn:00004C53
.text$mn:00004C54 ; ===========================================================================
.text$mn:00004C54
.text$mn:00004C54 ; Segment type: Pure code
.text$mn:00004C54 ; Segment permissions: Read/Execute
.text$mn:00004C54 _text$mn        segment para public 'CODE' use32
.text$mn:00004C54                 assume cs:_text$mn
.text$mn:00004C54                 ;org 4C54h
.text$mn:00004C54 ; COMDAT (pick any)
.text$mn:00004C54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004C54
.text$mn:00004C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C54
.text$mn:00004C54 ; Attributes: bp-based frame
.text$mn:00004C54
.text$mn:00004C54 ; int __cdecl std::_Debug_range2<unsigned int * *>(int, int, wchar_t *, unsigned int)
.text$mn:00004C54                 public ??$_Debug_range2@PAPAI@std@@YAXPAPAI0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00004C54 ??$_Debug_range2@PAPAI@std@@YAXPAPAI0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00004C54                                         ; CODE XREF: std::_Debug_range<uint * *>(uint * *,uint * *,wchar_t const *,uint)+2Ap
.text$mn:00004C54
.text$mn:00004C54 arg_0           = dword ptr  8
.text$mn:00004C54 arg_4           = dword ptr  0Ch
.text$mn:00004C54 arg_8           = dword ptr  10h
.text$mn:00004C54 arg_C           = dword ptr  14h
.text$mn:00004C54
.text$mn:00004C54                 push    ebp
.text$mn:00004C55                 mov     ebp, esp
.text$mn:00004C57                 mov     eax, [ebp+arg_0]
.text$mn:00004C5A                 cmp     eax, [ebp+arg_4]
.text$mn:00004C5D                 jz      short loc_4CA4
.text$mn:00004C5F                 mov     ecx, [ebp+arg_C]
.text$mn:00004C62                 push    ecx             ; unsigned int
.text$mn:00004C63                 mov     edx, [ebp+arg_8]
.text$mn:00004C66                 push    edx             ; wchar_t *
.text$mn:00004C67                 mov     eax, [ebp+arg_0]
.text$mn:00004C6A                 push    eax             ; int
.text$mn:00004C6B                 call    ??$_Debug_pointer@PAI@std@@YAXPAPAIPB_WI@Z ; std::_Debug_pointer<uint *>(uint * *,wchar_t const *,uint)
.text$mn:00004C70                 add     esp, 0Ch
.text$mn:00004C73                 mov     ecx, [ebp+arg_C]
.text$mn:00004C76                 push    ecx             ; unsigned int
.text$mn:00004C77                 mov     edx, [ebp+arg_8]
.text$mn:00004C7A                 push    edx             ; wchar_t *
.text$mn:00004C7B                 mov     eax, [ebp+arg_4]
.text$mn:00004C7E                 push    eax             ; int
.text$mn:00004C7F                 call    ??$_Debug_pointer@PAI@std@@YAXPAPAIPB_WI@Z ; std::_Debug_pointer<uint *>(uint * *,wchar_t const *,uint)
.text$mn:00004C84                 add     esp, 0Ch
.text$mn:00004C87                 mov     ecx, [ebp+arg_4]
.text$mn:00004C8A                 cmp     ecx, [ebp+arg_0]
.text$mn:00004C8D                 jnb     short loc_4CA4
.text$mn:00004C8F                 mov     edx, [ebp+arg_C]
.text$mn:00004C92                 push    edx             ; unsigned int
.text$mn:00004C93                 mov     eax, [ebp+arg_8]
.text$mn:00004C96                 push    eax             ; wchar_t *
.text$mn:00004C97                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00004C9C                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00004CA1                 add     esp, 0Ch
.text$mn:00004CA4
.text$mn:00004CA4 loc_4CA4:                               ; CODE XREF: std::_Debug_range2<uint * *>(uint * *,uint * *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00004CA4                                         ; std::_Debug_range2<uint * *>(uint * *,uint * *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00004CA4                 pop     ebp
.text$mn:00004CA5                 retn
.text$mn:00004CA5 ??$_Debug_range2@PAPAI@std@@YAXPAPAI0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00004CA5
.text$mn:00004CA5 ; ---------------------------------------------------------------------------
.text$mn:00004CA6                 align 4
.text$mn:00004CA6 _text$mn        ends
.text$mn:00004CA6
.text$mn:00004CA8 ; ===========================================================================
.text$mn:00004CA8
.text$mn:00004CA8 ; Segment type: Pure code
.text$mn:00004CA8 ; Segment permissions: Read/Execute
.text$mn:00004CA8 _text$mn        segment para public 'CODE' use32
.text$mn:00004CA8                 assume cs:_text$mn
.text$mn:00004CA8                 ;org 4CA8h
.text$mn:00004CA8 ; COMDAT (pick any)
.text$mn:00004CA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004CA8
.text$mn:00004CA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CA8
.text$mn:00004CA8 ; Attributes: bp-based frame
.text$mn:00004CA8
.text$mn:00004CA8 ; int __cdecl std::_Debug_range2<MenuItemUnit *>(int, int, wchar_t *, unsigned int)
.text$mn:00004CA8                 public ??$_Debug_range2@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00004CA8 ??$_Debug_range2@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00004CA8                                         ; CODE XREF: std::_Debug_range<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint)+2Ap
.text$mn:00004CA8
.text$mn:00004CA8 arg_0           = dword ptr  8
.text$mn:00004CA8 arg_4           = dword ptr  0Ch
.text$mn:00004CA8 arg_8           = dword ptr  10h
.text$mn:00004CA8 arg_C           = dword ptr  14h
.text$mn:00004CA8
.text$mn:00004CA8                 push    ebp
.text$mn:00004CA9                 mov     ebp, esp
.text$mn:00004CAB                 mov     eax, [ebp+arg_0]
.text$mn:00004CAE                 cmp     eax, [ebp+arg_4]
.text$mn:00004CB1                 jz      short loc_4CF8
.text$mn:00004CB3                 mov     ecx, [ebp+arg_C]
.text$mn:00004CB6                 push    ecx             ; unsigned int
.text$mn:00004CB7                 mov     edx, [ebp+arg_8]
.text$mn:00004CBA                 push    edx             ; wchar_t *
.text$mn:00004CBB                 mov     eax, [ebp+arg_0]
.text$mn:00004CBE                 push    eax             ; int
.text$mn:00004CBF                 call    ??$_Debug_pointer@UMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@PB_WI@Z ; std::_Debug_pointer<MenuItemUnit>(MenuItemUnit *,wchar_t const *,uint)
.text$mn:00004CC4                 add     esp, 0Ch
.text$mn:00004CC7                 mov     ecx, [ebp+arg_C]
.text$mn:00004CCA                 push    ecx             ; unsigned int
.text$mn:00004CCB                 mov     edx, [ebp+arg_8]
.text$mn:00004CCE                 push    edx             ; wchar_t *
.text$mn:00004CCF                 mov     eax, [ebp+arg_4]
.text$mn:00004CD2                 push    eax             ; int
.text$mn:00004CD3                 call    ??$_Debug_pointer@UMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@PB_WI@Z ; std::_Debug_pointer<MenuItemUnit>(MenuItemUnit *,wchar_t const *,uint)
.text$mn:00004CD8                 add     esp, 0Ch
.text$mn:00004CDB                 mov     ecx, [ebp+arg_4]
.text$mn:00004CDE                 cmp     ecx, [ebp+arg_0]
.text$mn:00004CE1                 jnb     short loc_4CF8
.text$mn:00004CE3                 mov     edx, [ebp+arg_C]
.text$mn:00004CE6                 push    edx             ; unsigned int
.text$mn:00004CE7                 mov     eax, [ebp+arg_8]
.text$mn:00004CEA                 push    eax             ; wchar_t *
.text$mn:00004CEB                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00004CF0                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00004CF5                 add     esp, 0Ch
.text$mn:00004CF8
.text$mn:00004CF8 loc_4CF8:                               ; CODE XREF: std::_Debug_range2<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00004CF8                                         ; std::_Debug_range2<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00004CF8                 pop     ebp
.text$mn:00004CF9                 retn
.text$mn:00004CF9 ??$_Debug_range2@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00004CF9
.text$mn:00004CF9 ; ---------------------------------------------------------------------------
.text$mn:00004CFA                 align 4
.text$mn:00004CFA _text$mn        ends
.text$mn:00004CFA
.text$mn:00004CFC ; ===========================================================================
.text$mn:00004CFC
.text$mn:00004CFC ; Segment type: Pure code
.text$mn:00004CFC ; Segment permissions: Read/Execute
.text$mn:00004CFC _text$mn        segment para public 'CODE' use32
.text$mn:00004CFC                 assume cs:_text$mn
.text$mn:00004CFC                 ;org 4CFCh
.text$mn:00004CFC ; COMDAT (pick any)
.text$mn:00004CFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004CFC
.text$mn:00004CFC ; =============== S U B R O U T I N E =======================================
.text$mn:00004CFC
.text$mn:00004CFC ; Attributes: bp-based frame
.text$mn:00004CFC
.text$mn:00004CFC ; int __cdecl std::_Debug_range2<recordedMacroStep *>(int, int, wchar_t *, unsigned int)
.text$mn:00004CFC                 public ??$_Debug_range2@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00004CFC ??$_Debug_range2@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00004CFC                                         ; CODE XREF: std::_Debug_range<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint)+2Ap
.text$mn:00004CFC
.text$mn:00004CFC arg_0           = dword ptr  8
.text$mn:00004CFC arg_4           = dword ptr  0Ch
.text$mn:00004CFC arg_8           = dword ptr  10h
.text$mn:00004CFC arg_C           = dword ptr  14h
.text$mn:00004CFC
.text$mn:00004CFC                 push    ebp
.text$mn:00004CFD                 mov     ebp, esp
.text$mn:00004CFF                 mov     eax, [ebp+arg_0]
.text$mn:00004D02                 cmp     eax, [ebp+arg_4]
.text$mn:00004D05                 jz      short loc_4D4C
.text$mn:00004D07                 mov     ecx, [ebp+arg_C]
.text$mn:00004D0A                 push    ecx             ; unsigned int
.text$mn:00004D0B                 mov     edx, [ebp+arg_8]
.text$mn:00004D0E                 push    edx             ; wchar_t *
.text$mn:00004D0F                 mov     eax, [ebp+arg_0]
.text$mn:00004D12                 push    eax             ; int
.text$mn:00004D13                 call    ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@PB_WI@Z ; std::_Debug_pointer<recordedMacroStep>(recordedMacroStep *,wchar_t const *,uint)
.text$mn:00004D18                 add     esp, 0Ch
.text$mn:00004D1B                 mov     ecx, [ebp+arg_C]
.text$mn:00004D1E                 push    ecx             ; unsigned int
.text$mn:00004D1F                 mov     edx, [ebp+arg_8]
.text$mn:00004D22                 push    edx             ; wchar_t *
.text$mn:00004D23                 mov     eax, [ebp+arg_4]
.text$mn:00004D26                 push    eax             ; int
.text$mn:00004D27                 call    ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@PB_WI@Z ; std::_Debug_pointer<recordedMacroStep>(recordedMacroStep *,wchar_t const *,uint)
.text$mn:00004D2C                 add     esp, 0Ch
.text$mn:00004D2F                 mov     ecx, [ebp+arg_4]
.text$mn:00004D32                 cmp     ecx, [ebp+arg_0]
.text$mn:00004D35                 jnb     short loc_4D4C
.text$mn:00004D37                 mov     edx, [ebp+arg_C]
.text$mn:00004D3A                 push    edx             ; unsigned int
.text$mn:00004D3B                 mov     eax, [ebp+arg_8]
.text$mn:00004D3E                 push    eax             ; wchar_t *
.text$mn:00004D3F                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00004D44                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00004D49                 add     esp, 0Ch
.text$mn:00004D4C
.text$mn:00004D4C loc_4D4C:                               ; CODE XREF: std::_Debug_range2<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00004D4C                                         ; std::_Debug_range2<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00004D4C                 pop     ebp
.text$mn:00004D4D                 retn
.text$mn:00004D4D ??$_Debug_range2@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00004D4D
.text$mn:00004D4D ; ---------------------------------------------------------------------------
.text$mn:00004D4E                 align 10h
.text$mn:00004D4E _text$mn        ends
.text$mn:00004D4E
.text$mn:00004D50 ; ===========================================================================
.text$mn:00004D50
.text$mn:00004D50 ; Segment type: Pure code
.text$mn:00004D50 ; Segment permissions: Read/Execute
.text$mn:00004D50 _text$mn        segment para public 'CODE' use32
.text$mn:00004D50                 assume cs:_text$mn
.text$mn:00004D50                 ;org 4D50h
.text$mn:00004D50 ; COMDAT (pick any)
.text$mn:00004D50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004D50
.text$mn:00004D50 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D50
.text$mn:00004D50 ; Attributes: bp-based frame
.text$mn:00004D50
.text$mn:00004D50 ; int __cdecl std::_Debug_range<unsigned int * *>(int, int, wchar_t *, unsigned int)
.text$mn:00004D50                 public ??$_Debug_range@PAPAI@std@@YAXPAPAI0PB_WI@Z
.text$mn:00004D50 ??$_Debug_range@PAPAI@std@@YAXPAPAI0PB_WI@Z proc near
.text$mn:00004D50                                         ; CODE XREF: std::_Uninit_copy<uint *,uint *>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:00004D50
.text$mn:00004D50 var_1           = byte ptr -1
.text$mn:00004D50 arg_0           = dword ptr  8
.text$mn:00004D50 arg_4           = dword ptr  0Ch
.text$mn:00004D50 arg_8           = dword ptr  10h
.text$mn:00004D50 arg_C           = dword ptr  14h
.text$mn:00004D50
.text$mn:00004D50                 push    ebp
.text$mn:00004D51                 mov     ebp, esp
.text$mn:00004D53                 push    ecx
.text$mn:00004D54                 lea     eax, [ebp+arg_0]
.text$mn:00004D57                 push    eax
.text$mn:00004D58                 lea     ecx, [ebp+var_1]
.text$mn:00004D5B                 push    ecx
.text$mn:00004D5C                 call    ??$_Iter_cat@PAPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAI@Z ; std::_Iter_cat<uint * *>(uint * * const &)
.text$mn:00004D61                 add     esp, 8
.text$mn:00004D64                 mov     dl, [eax]
.text$mn:00004D66                 movzx   eax, dl
.text$mn:00004D69                 push    eax
.text$mn:00004D6A                 mov     ecx, [ebp+arg_C]
.text$mn:00004D6D                 push    ecx             ; unsigned int
.text$mn:00004D6E                 mov     edx, [ebp+arg_8]
.text$mn:00004D71                 push    edx             ; wchar_t *
.text$mn:00004D72                 mov     eax, [ebp+arg_4]
.text$mn:00004D75                 push    eax             ; int
.text$mn:00004D76                 mov     ecx, [ebp+arg_0]
.text$mn:00004D79                 push    ecx             ; int
.text$mn:00004D7A                 call    ??$_Debug_range2@PAPAI@std@@YAXPAPAI0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<uint * *>(uint * *,uint * *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00004D7F                 add     esp, 14h
.text$mn:00004D82                 mov     esp, ebp
.text$mn:00004D84                 pop     ebp
.text$mn:00004D85                 retn
.text$mn:00004D85 ??$_Debug_range@PAPAI@std@@YAXPAPAI0PB_WI@Z endp
.text$mn:00004D85
.text$mn:00004D85 ; ---------------------------------------------------------------------------
.text$mn:00004D86                 align 4
.text$mn:00004D86 _text$mn        ends
.text$mn:00004D86
.text$mn:00004D88 ; ===========================================================================
.text$mn:00004D88
.text$mn:00004D88 ; Segment type: Pure code
.text$mn:00004D88 ; Segment permissions: Read/Execute
.text$mn:00004D88 _text$mn        segment para public 'CODE' use32
.text$mn:00004D88                 assume cs:_text$mn
.text$mn:00004D88                 ;org 4D88h
.text$mn:00004D88 ; COMDAT (pick any)
.text$mn:00004D88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004D88
.text$mn:00004D88 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D88
.text$mn:00004D88 ; Attributes: bp-based frame
.text$mn:00004D88
.text$mn:00004D88 ; int __cdecl std::_Debug_range<MenuItemUnit *>(int, int, wchar_t *, unsigned int)
.text$mn:00004D88                 public ??$_Debug_range@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WI@Z
.text$mn:00004D88 ??$_Debug_range@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WI@Z proc near
.text$mn:00004D88                                         ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00004D88
.text$mn:00004D88 var_1           = byte ptr -1
.text$mn:00004D88 arg_0           = dword ptr  8
.text$mn:00004D88 arg_4           = dword ptr  0Ch
.text$mn:00004D88 arg_8           = dword ptr  10h
.text$mn:00004D88 arg_C           = dword ptr  14h
.text$mn:00004D88
.text$mn:00004D88                 push    ebp
.text$mn:00004D89                 mov     ebp, esp
.text$mn:00004D8B                 push    ecx
.text$mn:00004D8C                 lea     eax, [ebp+arg_0]
.text$mn:00004D8F                 push    eax
.text$mn:00004D90                 lea     ecx, [ebp+var_1]
.text$mn:00004D93                 push    ecx
.text$mn:00004D94                 call    ??$_Iter_cat@PAUMenuItemUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUMenuItemUnit@@@Z ; std::_Iter_cat<MenuItemUnit *>(MenuItemUnit * const &)
.text$mn:00004D99                 add     esp, 8
.text$mn:00004D9C                 mov     dl, [eax]
.text$mn:00004D9E                 movzx   eax, dl
.text$mn:00004DA1                 push    eax
.text$mn:00004DA2                 mov     ecx, [ebp+arg_C]
.text$mn:00004DA5                 push    ecx             ; unsigned int
.text$mn:00004DA6                 mov     edx, [ebp+arg_8]
.text$mn:00004DA9                 push    edx             ; wchar_t *
.text$mn:00004DAA                 mov     eax, [ebp+arg_4]
.text$mn:00004DAD                 push    eax             ; int
.text$mn:00004DAE                 mov     ecx, [ebp+arg_0]
.text$mn:00004DB1                 push    ecx             ; int
.text$mn:00004DB2                 call    ??$_Debug_range2@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00004DB7                 add     esp, 14h
.text$mn:00004DBA                 mov     esp, ebp
.text$mn:00004DBC                 pop     ebp
.text$mn:00004DBD                 retn
.text$mn:00004DBD ??$_Debug_range@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WI@Z endp
.text$mn:00004DBD
.text$mn:00004DBD ; ---------------------------------------------------------------------------
.text$mn:00004DBE                 align 10h
.text$mn:00004DBE _text$mn        ends
.text$mn:00004DBE
.text$mn:00004DC0 ; ===========================================================================
.text$mn:00004DC0
.text$mn:00004DC0 ; Segment type: Pure code
.text$mn:00004DC0 ; Segment permissions: Read/Execute
.text$mn:00004DC0 _text$mn        segment para public 'CODE' use32
.text$mn:00004DC0                 assume cs:_text$mn
.text$mn:00004DC0                 ;org 4DC0h
.text$mn:00004DC0 ; COMDAT (pick any)
.text$mn:00004DC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004DC0
.text$mn:00004DC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DC0
.text$mn:00004DC0 ; Attributes: bp-based frame
.text$mn:00004DC0
.text$mn:00004DC0 ; int __cdecl std::_Debug_range<recordedMacroStep *>(int, int, wchar_t *, unsigned int)
.text$mn:00004DC0                 public ??$_Debug_range@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WI@Z
.text$mn:00004DC0 ??$_Debug_range@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WI@Z proc near
.text$mn:00004DC0                                         ; CODE XREF: std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>,recordedMacroStep>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,recordedMacroStep *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00004DC0
.text$mn:00004DC0 var_1           = byte ptr -1
.text$mn:00004DC0 arg_0           = dword ptr  8
.text$mn:00004DC0 arg_4           = dword ptr  0Ch
.text$mn:00004DC0 arg_8           = dword ptr  10h
.text$mn:00004DC0 arg_C           = dword ptr  14h
.text$mn:00004DC0
.text$mn:00004DC0                 push    ebp
.text$mn:00004DC1                 mov     ebp, esp
.text$mn:00004DC3                 push    ecx
.text$mn:00004DC4                 lea     eax, [ebp+arg_0]
.text$mn:00004DC7                 push    eax
.text$mn:00004DC8                 lea     ecx, [ebp+var_1]
.text$mn:00004DCB                 push    ecx
.text$mn:00004DCC                 call    ??$_Iter_cat@PAUrecordedMacroStep@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUrecordedMacroStep@@@Z ; std::_Iter_cat<recordedMacroStep *>(recordedMacroStep * const &)
.text$mn:00004DD1                 add     esp, 8
.text$mn:00004DD4                 mov     dl, [eax]
.text$mn:00004DD6                 movzx   eax, dl
.text$mn:00004DD9                 push    eax
.text$mn:00004DDA                 mov     ecx, [ebp+arg_C]
.text$mn:00004DDD                 push    ecx             ; unsigned int
.text$mn:00004DDE                 mov     edx, [ebp+arg_8]
.text$mn:00004DE1                 push    edx             ; wchar_t *
.text$mn:00004DE2                 mov     eax, [ebp+arg_4]
.text$mn:00004DE5                 push    eax             ; int
.text$mn:00004DE6                 mov     ecx, [ebp+arg_0]
.text$mn:00004DE9                 push    ecx             ; int
.text$mn:00004DEA                 call    ??$_Debug_range2@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00004DEF                 add     esp, 14h
.text$mn:00004DF2                 mov     esp, ebp
.text$mn:00004DF4                 pop     ebp
.text$mn:00004DF5                 retn
.text$mn:00004DF5 ??$_Debug_range@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WI@Z endp
.text$mn:00004DF5
.text$mn:00004DF5 ; ---------------------------------------------------------------------------
.text$mn:00004DF6                 align 4
.text$mn:00004DF6 _text$mn        ends
.text$mn:00004DF6
.text$mn:00004DF8 ; ===========================================================================
.text$mn:00004DF8
.text$mn:00004DF8 ; Segment type: Pure code
.text$mn:00004DF8 ; Segment permissions: Read/Execute
.text$mn:00004DF8 _text$mn        segment para public 'CODE' use32
.text$mn:00004DF8                 assume cs:_text$mn
.text$mn:00004DF8                 ;org 4DF8h
.text$mn:00004DF8 ; COMDAT (pick any)
.text$mn:00004DF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004DF8
.text$mn:00004DF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DF8
.text$mn:00004DF8 ; Attributes: bp-based frame
.text$mn:00004DF8
.text$mn:00004DF8 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<unsigned int *>>>(unsigned int * *, unsigned int * *, struct std::_Wrap_alloc<class std::allocator<unsigned int *>> &)
.text$mn:00004DF8                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAXPAPAI0AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z
.text$mn:00004DF8 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAXPAPAI0AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z proc near
.text$mn:00004DF8                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+1C3p
.text$mn:00004DF8
.text$mn:00004DF8 var_1           = byte ptr -1
.text$mn:00004DF8 arg_0           = dword ptr  8
.text$mn:00004DF8 arg_4           = dword ptr  0Ch
.text$mn:00004DF8 arg_8           = dword ptr  10h
.text$mn:00004DF8
.text$mn:00004DF8                 push    ebp
.text$mn:00004DF9                 mov     ebp, esp
.text$mn:00004DFB                 push    ecx
.text$mn:00004DFC                 mov     eax, [ebp+arg_4]
.text$mn:00004DFF                 push    eax
.text$mn:00004E00                 mov     ecx, [ebp+arg_0]
.text$mn:00004E03                 push    ecx
.text$mn:00004E04                 call    ??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAI0@Z ; std::_Ptr_cat<uint *,uint *>(uint * *,uint * *)
.text$mn:00004E09                 add     esp, 8
.text$mn:00004E0C                 mov     [ebp+var_1], al
.text$mn:00004E0F                 movzx   edx, [ebp+var_1]
.text$mn:00004E13                 push    edx
.text$mn:00004E14                 mov     eax, [ebp+arg_8]
.text$mn:00004E17                 push    eax
.text$mn:00004E18                 mov     ecx, [ebp+arg_4]
.text$mn:00004E1B                 push    ecx
.text$mn:00004E1C                 mov     edx, [ebp+arg_0]
.text$mn:00004E1F                 push    edx
.text$mn:00004E20                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAXPAPAI0AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00004E25                 add     esp, 10h
.text$mn:00004E28                 mov     esp, ebp
.text$mn:00004E2A                 pop     ebp
.text$mn:00004E2B                 retn
.text$mn:00004E2B ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAXPAPAI0AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z endp
.text$mn:00004E2B
.text$mn:00004E2B _text$mn        ends
.text$mn:00004E2B
.text$mn:00004E2C ; ===========================================================================
.text$mn:00004E2C
.text$mn:00004E2C ; Segment type: Pure code
.text$mn:00004E2C ; Segment permissions: Read/Execute
.text$mn:00004E2C _text$mn        segment para public 'CODE' use32
.text$mn:00004E2C                 assume cs:_text$mn
.text$mn:00004E2C                 ;org 4E2Ch
.text$mn:00004E2C ; COMDAT (pick any)
.text$mn:00004E2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004E2C
.text$mn:00004E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00004E2C
.text$mn:00004E2C ; Attributes: bp-based frame
.text$mn:00004E2C
.text$mn:00004E2C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<unsigned int *>>>(unsigned int * *, unsigned int * *, struct std::_Wrap_alloc<class std::allocator<unsigned int *>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00004E2C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAXPAPAI0AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00004E2C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAXPAPAI0AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00004E2C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &)+28p
.text$mn:00004E2C                 push    ebp
.text$mn:00004E2D                 mov     ebp, esp
.text$mn:00004E2F                 pop     ebp
.text$mn:00004E30                 retn
.text$mn:00004E30 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAXPAPAI0AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004E30
.text$mn:00004E30 ; ---------------------------------------------------------------------------
.text$mn:00004E31                 align 4
.text$mn:00004E31 _text$mn        ends
.text$mn:00004E31
.text$mn:00004E34 ; ===========================================================================
.text$mn:00004E34
.text$mn:00004E34 ; Segment type: Pure code
.text$mn:00004E34 ; Segment permissions: Read/Execute
.text$mn:00004E34 _text$mn        segment para public 'CODE' use32
.text$mn:00004E34                 assume cs:_text$mn
.text$mn:00004E34                 ;org 4E34h
.text$mn:00004E34 ; COMDAT (pick any)
.text$mn:00004E34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004E34
.text$mn:00004E34 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E34
.text$mn:00004E34 ; Attributes: bp-based frame
.text$mn:00004E34
.text$mn:00004E34 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>>(struct MenuItemUnit *, struct MenuItemUnit *, struct std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>> &)
.text$mn:00004E34                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z
.text$mn:00004E34 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z proc near
.text$mn:00004E34                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Destroy(MenuItemUnit *,MenuItemUnit *)+21p
.text$mn:00004E34
.text$mn:00004E34 var_1           = byte ptr -1
.text$mn:00004E34 arg_0           = dword ptr  8
.text$mn:00004E34 arg_4           = dword ptr  0Ch
.text$mn:00004E34 arg_8           = dword ptr  10h
.text$mn:00004E34
.text$mn:00004E34                 push    ebp
.text$mn:00004E35                 mov     ebp, esp
.text$mn:00004E37                 push    ecx
.text$mn:00004E38                 mov     eax, [ebp+arg_4]
.text$mn:00004E3B                 push    eax
.text$mn:00004E3C                 mov     ecx, [ebp+arg_0]
.text$mn:00004E3F                 push    ecx
.text$mn:00004E40                 call    ??$_Ptr_cat@UMenuItemUnit@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMenuItemUnit@@0@Z ; std::_Ptr_cat<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *)
.text$mn:00004E45                 add     esp, 8
.text$mn:00004E48                 mov     [ebp+var_1], al
.text$mn:00004E4B                 movzx   edx, [ebp+var_1]
.text$mn:00004E4F                 push    edx
.text$mn:00004E50                 mov     eax, [ebp+arg_8]
.text$mn:00004E53                 push    eax
.text$mn:00004E54                 mov     ecx, [ebp+arg_4]
.text$mn:00004E57                 push    ecx
.text$mn:00004E58                 mov     edx, [ebp+arg_0]
.text$mn:00004E5B                 push    edx
.text$mn:00004E5C                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00004E61                 add     esp, 10h
.text$mn:00004E64                 mov     esp, ebp
.text$mn:00004E66                 pop     ebp
.text$mn:00004E67                 retn
.text$mn:00004E67 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z endp
.text$mn:00004E67
.text$mn:00004E67 _text$mn        ends
.text$mn:00004E67
.text$mn:00004E68 ; ===========================================================================
.text$mn:00004E68
.text$mn:00004E68 ; Segment type: Pure code
.text$mn:00004E68 ; Segment permissions: Read/Execute
.text$mn:00004E68 _text$mn        segment para public 'CODE' use32
.text$mn:00004E68                 assume cs:_text$mn
.text$mn:00004E68                 ;org 4E68h
.text$mn:00004E68 ; COMDAT (pick any)
.text$mn:00004E68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004E68
.text$mn:00004E68 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E68
.text$mn:00004E68 ; Attributes: bp-based frame
.text$mn:00004E68
.text$mn:00004E68 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>>(struct MenuItemUnit *, struct MenuItemUnit *, struct std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00004E68                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00004E68 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00004E68                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+28p
.text$mn:00004E68
.text$mn:00004E68 arg_0           = dword ptr  8
.text$mn:00004E68 arg_4           = dword ptr  0Ch
.text$mn:00004E68 arg_8           = dword ptr  10h
.text$mn:00004E68
.text$mn:00004E68                 push    ebp
.text$mn:00004E69                 mov     ebp, esp
.text$mn:00004E6B                 jmp     short loc_4E76
.text$mn:00004E6D ; ---------------------------------------------------------------------------
.text$mn:00004E6D
.text$mn:00004E6D loc_4E6D:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00004E6D                 mov     eax, [ebp+arg_0]
.text$mn:00004E70                 add     eax, 3Ch ; '<'
.text$mn:00004E73                 mov     [ebp+arg_0], eax
.text$mn:00004E76
.text$mn:00004E76 loc_4E76:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00004E76                 mov     ecx, [ebp+arg_0]
.text$mn:00004E79                 cmp     ecx, [ebp+arg_4]
.text$mn:00004E7C                 jz      short loc_4E8C
.text$mn:00004E7E                 mov     edx, [ebp+arg_0]
.text$mn:00004E81                 push    edx
.text$mn:00004E82                 mov     ecx, [ebp+arg_8]
.text$mn:00004E85                 call    ??$destroy@UMenuItemUnit@@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::destroy<MenuItemUnit>(MenuItemUnit *)
.text$mn:00004E8A                 jmp     short loc_4E6D
.text$mn:00004E8C ; ---------------------------------------------------------------------------
.text$mn:00004E8C
.text$mn:00004E8C loc_4E8C:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00004E8C                 pop     ebp
.text$mn:00004E8D                 retn
.text$mn:00004E8D ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004E8D
.text$mn:00004E8D ; ---------------------------------------------------------------------------
.text$mn:00004E8E                 align 10h
.text$mn:00004E8E _text$mn        ends
.text$mn:00004E8E
.text$mn:00004E90 ; ===========================================================================
.text$mn:00004E90
.text$mn:00004E90 ; Segment type: Pure code
.text$mn:00004E90 ; Segment permissions: Read/Execute
.text$mn:00004E90 _text$mn        segment para public 'CODE' use32
.text$mn:00004E90                 assume cs:_text$mn
.text$mn:00004E90                 ;org 4E90h
.text$mn:00004E90 ; COMDAT (pick any)
.text$mn:00004E90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004E90
.text$mn:00004E90 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E90
.text$mn:00004E90 ; Attributes: bp-based frame
.text$mn:00004E90
.text$mn:00004E90 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>>(struct recordedMacroStep *, struct recordedMacroStep *, struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> &)
.text$mn:00004E90                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z
.text$mn:00004E90 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z proc near
.text$mn:00004E90                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Destroy(recordedMacroStep *,recordedMacroStep *)+21p
.text$mn:00004E90
.text$mn:00004E90 var_1           = byte ptr -1
.text$mn:00004E90 arg_0           = dword ptr  8
.text$mn:00004E90 arg_4           = dword ptr  0Ch
.text$mn:00004E90 arg_8           = dword ptr  10h
.text$mn:00004E90
.text$mn:00004E90                 push    ebp
.text$mn:00004E91                 mov     ebp, esp
.text$mn:00004E93                 push    ecx
.text$mn:00004E94                 mov     eax, [ebp+arg_4]
.text$mn:00004E97                 push    eax
.text$mn:00004E98                 mov     ecx, [ebp+arg_0]
.text$mn:00004E9B                 push    ecx
.text$mn:00004E9C                 call    ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUrecordedMacroStep@@0@Z ; std::_Ptr_cat<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep *)
.text$mn:00004EA1                 add     esp, 8
.text$mn:00004EA4                 mov     [ebp+var_1], al
.text$mn:00004EA7                 movzx   edx, [ebp+var_1]
.text$mn:00004EAB                 push    edx
.text$mn:00004EAC                 mov     eax, [ebp+arg_8]
.text$mn:00004EAF                 push    eax
.text$mn:00004EB0                 mov     ecx, [ebp+arg_4]
.text$mn:00004EB3                 push    ecx
.text$mn:00004EB4                 mov     edx, [ebp+arg_0]
.text$mn:00004EB7                 push    edx
.text$mn:00004EB8                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00004EBD                 add     esp, 10h
.text$mn:00004EC0                 mov     esp, ebp
.text$mn:00004EC2                 pop     ebp
.text$mn:00004EC3                 retn
.text$mn:00004EC3 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z endp
.text$mn:00004EC3
.text$mn:00004EC3 _text$mn        ends
.text$mn:00004EC3
.text$mn:00004EC4 ; ===========================================================================
.text$mn:00004EC4
.text$mn:00004EC4 ; Segment type: Pure code
.text$mn:00004EC4 ; Segment permissions: Read/Execute
.text$mn:00004EC4 _text$mn        segment para public 'CODE' use32
.text$mn:00004EC4                 assume cs:_text$mn
.text$mn:00004EC4                 ;org 4EC4h
.text$mn:00004EC4 ; COMDAT (pick any)
.text$mn:00004EC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004EC4
.text$mn:00004EC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EC4
.text$mn:00004EC4 ; Attributes: bp-based frame
.text$mn:00004EC4
.text$mn:00004EC4 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>>(struct recordedMacroStep *, struct recordedMacroStep *, struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00004EC4                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00004EC4 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00004EC4                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+28p
.text$mn:00004EC4
.text$mn:00004EC4 arg_0           = dword ptr  8
.text$mn:00004EC4 arg_4           = dword ptr  0Ch
.text$mn:00004EC4 arg_8           = dword ptr  10h
.text$mn:00004EC4
.text$mn:00004EC4                 push    ebp
.text$mn:00004EC5                 mov     ebp, esp
.text$mn:00004EC7                 jmp     short loc_4ED2
.text$mn:00004EC9 ; ---------------------------------------------------------------------------
.text$mn:00004EC9
.text$mn:00004EC9 loc_4EC9:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00004EC9                 mov     eax, [ebp+arg_0]
.text$mn:00004ECC                 add     eax, 2Ch ; ','
.text$mn:00004ECF                 mov     [ebp+arg_0], eax
.text$mn:00004ED2
.text$mn:00004ED2 loc_4ED2:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00004ED2                 mov     ecx, [ebp+arg_0]
.text$mn:00004ED5                 cmp     ecx, [ebp+arg_4]
.text$mn:00004ED8                 jz      short loc_4EE8
.text$mn:00004EDA                 mov     edx, [ebp+arg_0]
.text$mn:00004EDD                 push    edx
.text$mn:00004EDE                 mov     ecx, [ebp+arg_8]
.text$mn:00004EE1                 call    ??$destroy@UrecordedMacroStep@@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::destroy<recordedMacroStep>(recordedMacroStep *)
.text$mn:00004EE6                 jmp     short loc_4EC9
.text$mn:00004EE8 ; ---------------------------------------------------------------------------
.text$mn:00004EE8
.text$mn:00004EE8 loc_4EE8:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00004EE8                 pop     ebp
.text$mn:00004EE9                 retn
.text$mn:00004EE9 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00004EE9
.text$mn:00004EE9 ; ---------------------------------------------------------------------------
.text$mn:00004EEA                 align 4
.text$mn:00004EEA _text$mn        ends
.text$mn:00004EEA
.text$mn:00004EEC ; ===========================================================================
.text$mn:00004EEC
.text$mn:00004EEC ; Segment type: Pure code
.text$mn:00004EEC ; Segment permissions: Read/Execute
.text$mn:00004EEC _text$mn        segment para public 'CODE' use32
.text$mn:00004EEC                 assume cs:_text$mn
.text$mn:00004EEC                 ;org 4EECh
.text$mn:00004EEC ; COMDAT (pick any)
.text$mn:00004EEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004EEC
.text$mn:00004EEC ; =============== S U B R O U T I N E =======================================
.text$mn:00004EEC
.text$mn:00004EEC ; Attributes: bp-based frame
.text$mn:00004EEC
.text$mn:00004EEC ; unsigned int * * __cdecl std::_Fill_n<unsigned int * *, unsigned int, unsigned int *>(unsigned int * *, unsigned int, unsigned int * const &)
.text$mn:00004EEC                 public ??$_Fill_n@PAPAIIPAI@std@@YAPAPAIPAPAIIABQAI@Z
.text$mn:00004EEC ??$_Fill_n@PAPAIIPAI@std@@YAPAPAIPAPAIIABQAI@Z proc near
.text$mn:00004EEC                                         ; CODE XREF: std::_Uninit_def_fill_n<uint *,uint,uint *>(uint * *,uint,std::_Wrap_alloc<std::allocator<uint *>> &,uint * *,std::_Scalar_ptr_iterator_tag)+17p
.text$mn:00004EEC
.text$mn:00004EEC arg_0           = dword ptr  8
.text$mn:00004EEC arg_4           = dword ptr  0Ch
.text$mn:00004EEC arg_8           = dword ptr  10h
.text$mn:00004EEC
.text$mn:00004EEC                 push    ebp
.text$mn:00004EED                 mov     ebp, esp
.text$mn:00004EEF                 jmp     short loc_4F03
.text$mn:00004EF1 ; ---------------------------------------------------------------------------
.text$mn:00004EF1
.text$mn:00004EF1 loc_4EF1:                               ; CODE XREF: std::_Fill_n<uint * *,uint,uint *>(uint * *,uint,uint * const &)+27j
.text$mn:00004EF1                 mov     eax, [ebp+arg_4]
.text$mn:00004EF4                 sub     eax, 1
.text$mn:00004EF7                 mov     [ebp+arg_4], eax
.text$mn:00004EFA                 mov     ecx, [ebp+arg_0]
.text$mn:00004EFD                 add     ecx, 4
.text$mn:00004F00                 mov     [ebp+arg_0], ecx
.text$mn:00004F03
.text$mn:00004F03 loc_4F03:                               ; CODE XREF: std::_Fill_n<uint * *,uint,uint *>(uint * *,uint,uint * const &)+3j
.text$mn:00004F03                 cmp     [ebp+arg_4], 0
.text$mn:00004F07                 jbe     short loc_4F15
.text$mn:00004F09                 mov     edx, [ebp+arg_0]
.text$mn:00004F0C                 mov     eax, [ebp+arg_8]
.text$mn:00004F0F                 mov     ecx, [eax]
.text$mn:00004F11                 mov     [edx], ecx
.text$mn:00004F13                 jmp     short loc_4EF1
.text$mn:00004F15 ; ---------------------------------------------------------------------------
.text$mn:00004F15
.text$mn:00004F15 loc_4F15:                               ; CODE XREF: std::_Fill_n<uint * *,uint,uint *>(uint * *,uint,uint * const &)+1Bj
.text$mn:00004F15                 mov     eax, [ebp+arg_0]
.text$mn:00004F18                 pop     ebp
.text$mn:00004F19                 retn
.text$mn:00004F19 ??$_Fill_n@PAPAIIPAI@std@@YAPAPAIPAPAIIABQAI@Z endp
.text$mn:00004F19
.text$mn:00004F19 ; ---------------------------------------------------------------------------
.text$mn:00004F1A                 align 4
.text$mn:00004F1A _text$mn        ends
.text$mn:00004F1A
.text$mn:00004F1C ; ===========================================================================
.text$mn:00004F1C
.text$mn:00004F1C ; Segment type: Pure code
.text$mn:00004F1C ; Segment permissions: Read/Execute
.text$mn:00004F1C _text$mn        segment para public 'CODE' use32
.text$mn:00004F1C                 assume cs:_text$mn
.text$mn:00004F1C                 ;org 4F1Ch
.text$mn:00004F1C ; COMDAT (pick any)
.text$mn:00004F1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004F1C
.text$mn:00004F1C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F1C
.text$mn:00004F1C ; Attributes: bp-based frame
.text$mn:00004F1C
.text$mn:00004F1C ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<unsigned int * *>(unsigned int * * const &)
.text$mn:00004F1C                 public ??$_Iter_cat@PAPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAI@Z
.text$mn:00004F1C ??$_Iter_cat@PAPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAI@Z proc near
.text$mn:00004F1C                                         ; CODE XREF: std::_Debug_range<uint * *>(uint * *,uint * *,wchar_t const *,uint)+Cp
.text$mn:00004F1C
.text$mn:00004F1C var_1           = byte ptr -1
.text$mn:00004F1C arg_0           = dword ptr  8
.text$mn:00004F1C
.text$mn:00004F1C                 push    ebp
.text$mn:00004F1D                 mov     ebp, esp
.text$mn:00004F1F                 push    ecx
.text$mn:00004F20                 mov     eax, [ebp+arg_0]
.text$mn:00004F23                 mov     cl, [ebp+var_1]
.text$mn:00004F26                 mov     [eax], cl
.text$mn:00004F28                 mov     eax, [ebp+arg_0]
.text$mn:00004F2B                 mov     esp, ebp
.text$mn:00004F2D                 pop     ebp
.text$mn:00004F2E                 retn
.text$mn:00004F2E ??$_Iter_cat@PAPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAI@Z endp
.text$mn:00004F2E
.text$mn:00004F2E ; ---------------------------------------------------------------------------
.text$mn:00004F2F                 align 10h
.text$mn:00004F2F _text$mn        ends
.text$mn:00004F2F
.text$mn:00004F30 ; ===========================================================================
.text$mn:00004F30
.text$mn:00004F30 ; Segment type: Pure code
.text$mn:00004F30 ; Segment permissions: Read/Execute
.text$mn:00004F30 _text$mn        segment para public 'CODE' use32
.text$mn:00004F30                 assume cs:_text$mn
.text$mn:00004F30                 ;org 4F30h
.text$mn:00004F30 ; COMDAT (pick any)
.text$mn:00004F30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004F30
.text$mn:00004F30 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F30
.text$mn:00004F30 ; Attributes: bp-based frame
.text$mn:00004F30
.text$mn:00004F30 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct MenuItemUnit *>(struct MenuItemUnit * const &)
.text$mn:00004F30                 public ??$_Iter_cat@PAUMenuItemUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUMenuItemUnit@@@Z
.text$mn:00004F30 ??$_Iter_cat@PAUMenuItemUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUMenuItemUnit@@@Z proc near
.text$mn:00004F30                                         ; CODE XREF: std::_Debug_range<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint)+Cp
.text$mn:00004F30
.text$mn:00004F30 var_1           = byte ptr -1
.text$mn:00004F30 arg_0           = dword ptr  8
.text$mn:00004F30
.text$mn:00004F30                 push    ebp
.text$mn:00004F31                 mov     ebp, esp
.text$mn:00004F33                 push    ecx
.text$mn:00004F34                 mov     eax, [ebp+arg_0]
.text$mn:00004F37                 mov     cl, [ebp+var_1]
.text$mn:00004F3A                 mov     [eax], cl
.text$mn:00004F3C                 mov     eax, [ebp+arg_0]
.text$mn:00004F3F                 mov     esp, ebp
.text$mn:00004F41                 pop     ebp
.text$mn:00004F42                 retn
.text$mn:00004F42 ??$_Iter_cat@PAUMenuItemUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUMenuItemUnit@@@Z endp
.text$mn:00004F42
.text$mn:00004F42 ; ---------------------------------------------------------------------------
.text$mn:00004F43                 align 4
.text$mn:00004F43 _text$mn        ends
.text$mn:00004F43
.text$mn:00004F44 ; ===========================================================================
.text$mn:00004F44
.text$mn:00004F44 ; Segment type: Pure code
.text$mn:00004F44 ; Segment permissions: Read/Execute
.text$mn:00004F44 _text$mn        segment para public 'CODE' use32
.text$mn:00004F44                 assume cs:_text$mn
.text$mn:00004F44                 ;org 4F44h
.text$mn:00004F44 ; COMDAT (pick any)
.text$mn:00004F44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004F44
.text$mn:00004F44 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F44
.text$mn:00004F44 ; Attributes: bp-based frame
.text$mn:00004F44
.text$mn:00004F44 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct recordedMacroStep *>(struct recordedMacroStep * const &)
.text$mn:00004F44                 public ??$_Iter_cat@PAUrecordedMacroStep@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUrecordedMacroStep@@@Z
.text$mn:00004F44 ??$_Iter_cat@PAUrecordedMacroStep@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUrecordedMacroStep@@@Z proc near
.text$mn:00004F44                                         ; CODE XREF: std::_Debug_range<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint)+Cp
.text$mn:00004F44
.text$mn:00004F44 var_1           = byte ptr -1
.text$mn:00004F44 arg_0           = dword ptr  8
.text$mn:00004F44
.text$mn:00004F44                 push    ebp
.text$mn:00004F45                 mov     ebp, esp
.text$mn:00004F47                 push    ecx
.text$mn:00004F48                 mov     eax, [ebp+arg_0]
.text$mn:00004F4B                 mov     cl, [ebp+var_1]
.text$mn:00004F4E                 mov     [eax], cl
.text$mn:00004F50                 mov     eax, [ebp+arg_0]
.text$mn:00004F53                 mov     esp, ebp
.text$mn:00004F55                 pop     ebp
.text$mn:00004F56                 retn
.text$mn:00004F56 ??$_Iter_cat@PAUrecordedMacroStep@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUrecordedMacroStep@@@Z endp
.text$mn:00004F56
.text$mn:00004F56 ; ---------------------------------------------------------------------------
.text$mn:00004F57                 align 4
.text$mn:00004F57 _text$mn        ends
.text$mn:00004F57
.text$mn:00004F58 ; ===========================================================================
.text$mn:00004F58
.text$mn:00004F58 ; Segment type: Pure code
.text$mn:00004F58 ; Segment permissions: Read/Execute
.text$mn:00004F58 _text$mn        segment para public 'CODE' use32
.text$mn:00004F58                 assume cs:_text$mn
.text$mn:00004F58                 ;org 4F58h
.text$mn:00004F58 ; COMDAT (pick any)
.text$mn:00004F58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004F58
.text$mn:00004F58 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F58
.text$mn:00004F58 ; Attributes: bp-based frame
.text$mn:00004F58
.text$mn:00004F58 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<unsigned int *, unsigned int *>(unsigned int * *, unsigned int * *)
.text$mn:00004F58                 public ??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAI0@Z
.text$mn:00004F58 ??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAI0@Z proc near
.text$mn:00004F58                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &)+Cp
.text$mn:00004F58                                         ; std::_Uninit_copy<uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &)+Cp ...
.text$mn:00004F58
.text$mn:00004F58 var_1           = byte ptr -1
.text$mn:00004F58
.text$mn:00004F58                 push    ebp
.text$mn:00004F59                 mov     ebp, esp
.text$mn:00004F5B                 push    ecx
.text$mn:00004F5C                 mov     al, [ebp+var_1]
.text$mn:00004F5F                 mov     esp, ebp
.text$mn:00004F61                 pop     ebp
.text$mn:00004F62                 retn
.text$mn:00004F62 ??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAI0@Z endp
.text$mn:00004F62
.text$mn:00004F62 ; ---------------------------------------------------------------------------
.text$mn:00004F63                 align 4
.text$mn:00004F63 _text$mn        ends
.text$mn:00004F63
.text$mn:00004F64 ; ===========================================================================
.text$mn:00004F64
.text$mn:00004F64 ; Segment type: Pure code
.text$mn:00004F64 ; Segment permissions: Read/Execute
.text$mn:00004F64 _text$mn        segment para public 'CODE' use32
.text$mn:00004F64                 assume cs:_text$mn
.text$mn:00004F64                 ;org 4F64h
.text$mn:00004F64 ; COMDAT (pick any)
.text$mn:00004F64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004F64
.text$mn:00004F64 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F64
.text$mn:00004F64 ; Attributes: bp-based frame
.text$mn:00004F64
.text$mn:00004F64 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct MenuItemUnit, struct MenuItemUnit>(struct MenuItemUnit *, struct MenuItemUnit *)
.text$mn:00004F64                 public ??$_Ptr_cat@UMenuItemUnit@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMenuItemUnit@@0@Z
.text$mn:00004F64 ??$_Ptr_cat@UMenuItemUnit@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMenuItemUnit@@0@Z proc near
.text$mn:00004F64                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+Cp
.text$mn:00004F64                                         ; std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+Cp
.text$mn:00004F64
.text$mn:00004F64 var_1           = byte ptr -1
.text$mn:00004F64
.text$mn:00004F64                 push    ebp
.text$mn:00004F65                 mov     ebp, esp
.text$mn:00004F67                 push    ecx
.text$mn:00004F68                 mov     al, [ebp+var_1]
.text$mn:00004F6B                 mov     esp, ebp
.text$mn:00004F6D                 pop     ebp
.text$mn:00004F6E                 retn
.text$mn:00004F6E ??$_Ptr_cat@UMenuItemUnit@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMenuItemUnit@@0@Z endp
.text$mn:00004F6E
.text$mn:00004F6E ; ---------------------------------------------------------------------------
.text$mn:00004F6F                 align 10h
.text$mn:00004F6F _text$mn        ends
.text$mn:00004F6F
.text$mn:00004F70 ; ===========================================================================
.text$mn:00004F70
.text$mn:00004F70 ; Segment type: Pure code
.text$mn:00004F70 ; Segment permissions: Read/Execute
.text$mn:00004F70 _text$mn        segment para public 'CODE' use32
.text$mn:00004F70                 assume cs:_text$mn
.text$mn:00004F70                 ;org 4F70h
.text$mn:00004F70 ; COMDAT (pick any)
.text$mn:00004F70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004F70
.text$mn:00004F70 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F70
.text$mn:00004F70 ; Attributes: bp-based frame
.text$mn:00004F70
.text$mn:00004F70 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct recordedMacroStep, struct recordedMacroStep>(struct recordedMacroStep *, struct recordedMacroStep *)
.text$mn:00004F70                 public ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUrecordedMacroStep@@0@Z
.text$mn:00004F70 ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUrecordedMacroStep@@0@Z proc near
.text$mn:00004F70                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+Cp
.text$mn:00004F70                                         ; std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+Cp
.text$mn:00004F70
.text$mn:00004F70 var_1           = byte ptr -1
.text$mn:00004F70
.text$mn:00004F70                 push    ebp
.text$mn:00004F71                 mov     ebp, esp
.text$mn:00004F73                 push    ecx
.text$mn:00004F74                 mov     al, [ebp+var_1]
.text$mn:00004F77                 mov     esp, ebp
.text$mn:00004F79                 pop     ebp
.text$mn:00004F7A                 retn
.text$mn:00004F7A ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUrecordedMacroStep@@0@Z endp
.text$mn:00004F7A
.text$mn:00004F7A ; ---------------------------------------------------------------------------
.text$mn:00004F7B                 align 4
.text$mn:00004F7B _text$mn        ends
.text$mn:00004F7B
.text$mn:00004F7C ; ===========================================================================
.text$mn:00004F7C
.text$mn:00004F7C ; Segment type: Pure code
.text$mn:00004F7C ; Segment permissions: Read/Execute
.text$mn:00004F7C _text$mn        segment para public 'CODE' use32
.text$mn:00004F7C                 assume cs:_text$mn
.text$mn:00004F7C                 ;org 4F7Ch
.text$mn:00004F7C ; COMDAT (pick any)
.text$mn:00004F7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004F7C
.text$mn:00004F7C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F7C
.text$mn:00004F7C ; Attributes: bp-based frame
.text$mn:00004F7C
.text$mn:00004F7C ; unsigned int * * & __cdecl std::_Rechecked<unsigned int * *, unsigned int * *>(unsigned int * * &, unsigned int * *)
.text$mn:00004F7C                 public ??$_Rechecked@PAPAIPAPAI@std@@YAAAPAPAIAAPAPAIPAPAI@Z
.text$mn:00004F7C ??$_Rechecked@PAPAIPAPAI@std@@YAAAPAPAIAAPAPAIPAPAI@Z proc near
.text$mn:00004F7C                                         ; CODE XREF: std::_Uninitialized_copy<uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &)+3Bp
.text$mn:00004F7C
.text$mn:00004F7C arg_0           = dword ptr  8
.text$mn:00004F7C arg_4           = dword ptr  0Ch
.text$mn:00004F7C
.text$mn:00004F7C                 push    ebp
.text$mn:00004F7D                 mov     ebp, esp
.text$mn:00004F7F                 mov     eax, [ebp+arg_0]
.text$mn:00004F82                 mov     ecx, [ebp+arg_4]
.text$mn:00004F85                 mov     [eax], ecx
.text$mn:00004F87                 mov     eax, [ebp+arg_0]
.text$mn:00004F8A                 pop     ebp
.text$mn:00004F8B                 retn
.text$mn:00004F8B ??$_Rechecked@PAPAIPAPAI@std@@YAAAPAPAIAAPAPAIPAPAI@Z endp
.text$mn:00004F8B
.text$mn:00004F8B _text$mn        ends
.text$mn:00004F8B
.text$mn:00004F8C ; ===========================================================================
.text$mn:00004F8C
.text$mn:00004F8C ; Segment type: Pure code
.text$mn:00004F8C ; Segment permissions: Read/Execute
.text$mn:00004F8C _text$mn        segment para public 'CODE' use32
.text$mn:00004F8C                 assume cs:_text$mn
.text$mn:00004F8C                 ;org 4F8Ch
.text$mn:00004F8C ; COMDAT (pick any)
.text$mn:00004F8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004F8C
.text$mn:00004F8C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F8C
.text$mn:00004F8C ; Attributes: bp-based frame
.text$mn:00004F8C
.text$mn:00004F8C ; struct MenuItemUnit * & __cdecl std::_Rechecked<struct MenuItemUnit *, struct MenuItemUnit *>(struct MenuItemUnit * &, struct MenuItemUnit *)
.text$mn:00004F8C                 public ??$_Rechecked@PAUMenuItemUnit@@PAU1@@std@@YAAAPAUMenuItemUnit@@AAPAU1@PAU1@@Z
.text$mn:00004F8C ??$_Rechecked@PAUMenuItemUnit@@PAU1@@std@@YAAAPAUMenuItemUnit@@AAPAU1@PAU1@@Z proc near
.text$mn:00004F8C                                         ; CODE XREF: std::_Uninitialized_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+3Bp
.text$mn:00004F8C
.text$mn:00004F8C arg_0           = dword ptr  8
.text$mn:00004F8C arg_4           = dword ptr  0Ch
.text$mn:00004F8C
.text$mn:00004F8C                 push    ebp
.text$mn:00004F8D                 mov     ebp, esp
.text$mn:00004F8F                 mov     eax, [ebp+arg_0]
.text$mn:00004F92                 mov     ecx, [ebp+arg_4]
.text$mn:00004F95                 mov     [eax], ecx
.text$mn:00004F97                 mov     eax, [ebp+arg_0]
.text$mn:00004F9A                 pop     ebp
.text$mn:00004F9B                 retn
.text$mn:00004F9B ??$_Rechecked@PAUMenuItemUnit@@PAU1@@std@@YAAAPAUMenuItemUnit@@AAPAU1@PAU1@@Z endp
.text$mn:00004F9B
.text$mn:00004F9B _text$mn        ends
.text$mn:00004F9B
.text$mn:00004F9C ; ===========================================================================
.text$mn:00004F9C
.text$mn:00004F9C ; Segment type: Pure code
.text$mn:00004F9C ; Segment permissions: Read/Execute
.text$mn:00004F9C _text$mn        segment para public 'CODE' use32
.text$mn:00004F9C                 assume cs:_text$mn
.text$mn:00004F9C                 ;org 4F9Ch
.text$mn:00004F9C ; COMDAT (pick any)
.text$mn:00004F9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004F9C
.text$mn:00004F9C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F9C
.text$mn:00004F9C ; Attributes: bp-based frame
.text$mn:00004F9C
.text$mn:00004F9C ; struct recordedMacroStep * & __cdecl std::_Rechecked<struct recordedMacroStep *, struct recordedMacroStep *>(struct recordedMacroStep * &, struct recordedMacroStep *)
.text$mn:00004F9C                 public ??$_Rechecked@PAUrecordedMacroStep@@PAU1@@std@@YAAAPAUrecordedMacroStep@@AAPAU1@PAU1@@Z
.text$mn:00004F9C ??$_Rechecked@PAUrecordedMacroStep@@PAU1@@std@@YAAAPAUrecordedMacroStep@@AAPAU1@PAU1@@Z proc near
.text$mn:00004F9C                                         ; CODE XREF: std::_Uninitialized_move<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+3Bp
.text$mn:00004F9C
.text$mn:00004F9C arg_0           = dword ptr  8
.text$mn:00004F9C arg_4           = dword ptr  0Ch
.text$mn:00004F9C
.text$mn:00004F9C                 push    ebp
.text$mn:00004F9D                 mov     ebp, esp
.text$mn:00004F9F                 mov     eax, [ebp+arg_0]
.text$mn:00004FA2                 mov     ecx, [ebp+arg_4]
.text$mn:00004FA5                 mov     [eax], ecx
.text$mn:00004FA7                 mov     eax, [ebp+arg_0]
.text$mn:00004FAA                 pop     ebp
.text$mn:00004FAB                 retn
.text$mn:00004FAB ??$_Rechecked@PAUrecordedMacroStep@@PAU1@@std@@YAAAPAUrecordedMacroStep@@AAPAU1@PAU1@@Z endp
.text$mn:00004FAB
.text$mn:00004FAB _text$mn        ends
.text$mn:00004FAB
.text$mn:00004FAC ; ===========================================================================
.text$mn:00004FAC
.text$mn:00004FAC ; Segment type: Pure code
.text$mn:00004FAC ; Segment permissions: Read/Execute
.text$mn:00004FAC _text$mn        segment para public 'CODE' use32
.text$mn:00004FAC                 assume cs:_text$mn
.text$mn:00004FAC                 ;org 4FACh
.text$mn:00004FAC ; COMDAT (pick any)
.text$mn:00004FAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004FAC
.text$mn:00004FAC ; =============== S U B R O U T I N E =======================================
.text$mn:00004FAC
.text$mn:00004FAC ; Attributes: bp-based frame
.text$mn:00004FAC
.text$mn:00004FAC ; protected: struct MenuItemUnit * __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Umove<struct MenuItemUnit *>(struct MenuItemUnit *, struct MenuItemUnit *, struct MenuItemUnit *)
.text$mn:00004FAC                 public ??$_Umove@PAUMenuItemUnit@@@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEPAUMenuItemUnit@@PAU2@00@Z
.text$mn:00004FAC ??$_Umove@PAUMenuItemUnit@@@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEPAUMenuItemUnit@@PAU2@00@Z proc near
.text$mn:00004FAC                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+65p
.text$mn:00004FAC
.text$mn:00004FAC var_8           = dword ptr -8
.text$mn:00004FAC var_1           = byte ptr -1
.text$mn:00004FAC arg_0           = dword ptr  8
.text$mn:00004FAC arg_4           = dword ptr  0Ch
.text$mn:00004FAC arg_8           = dword ptr  10h
.text$mn:00004FAC
.text$mn:00004FAC                 push    ebp
.text$mn:00004FAD                 mov     ebp, esp
.text$mn:00004FAF                 sub     esp, 8
.text$mn:00004FB2                 mov     [ebp+var_8], ecx
.text$mn:00004FB5                 lea     eax, [ebp+var_1]
.text$mn:00004FB8                 push    eax
.text$mn:00004FB9                 mov     ecx, [ebp+var_8]
.text$mn:00004FBC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:00004FC1                 lea     ecx, [ebp+var_1]
.text$mn:00004FC4                 push    ecx
.text$mn:00004FC5                 mov     edx, [ebp+arg_8]
.text$mn:00004FC8                 push    edx
.text$mn:00004FC9                 mov     eax, [ebp+arg_4]
.text$mn:00004FCC                 push    eax
.text$mn:00004FCD                 mov     ecx, [ebp+arg_0]
.text$mn:00004FD0                 push    ecx
.text$mn:00004FD1                 call    ??$_Uninitialized_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z ; std::_Uninitialized_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)
.text$mn:00004FD6                 add     esp, 10h
.text$mn:00004FD9                 mov     esp, ebp
.text$mn:00004FDB                 pop     ebp
.text$mn:00004FDC                 retn    0Ch
.text$mn:00004FDC ??$_Umove@PAUMenuItemUnit@@@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEPAUMenuItemUnit@@PAU2@00@Z endp
.text$mn:00004FDC
.text$mn:00004FDC ; ---------------------------------------------------------------------------
.text$mn:00004FDF                 align 10h
.text$mn:00004FDF _text$mn        ends
.text$mn:00004FDF
.text$mn:00004FE0 ; ===========================================================================
.text$mn:00004FE0
.text$mn:00004FE0 ; Segment type: Pure code
.text$mn:00004FE0 ; Segment permissions: Read/Execute
.text$mn:00004FE0 _text$mn        segment para public 'CODE' use32
.text$mn:00004FE0                 assume cs:_text$mn
.text$mn:00004FE0                 ;org 4FE0h
.text$mn:00004FE0 ; COMDAT (pick any)
.text$mn:00004FE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00004FE0
.text$mn:00004FE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FE0
.text$mn:00004FE0 ; Attributes: bp-based frame
.text$mn:00004FE0
.text$mn:00004FE0 ; protected: struct recordedMacroStep * __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Umove<struct recordedMacroStep *>(struct recordedMacroStep *, struct recordedMacroStep *, struct recordedMacroStep *)
.text$mn:00004FE0                 public ??$_Umove@PAUrecordedMacroStep@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@PAU2@00@Z
.text$mn:00004FE0 ??$_Umove@PAUrecordedMacroStep@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@PAU2@00@Z proc near
.text$mn:00004FE0                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reallocate(uint)+65p
.text$mn:00004FE0
.text$mn:00004FE0 var_8           = dword ptr -8
.text$mn:00004FE0 var_1           = byte ptr -1
.text$mn:00004FE0 arg_0           = dword ptr  8
.text$mn:00004FE0 arg_4           = dword ptr  0Ch
.text$mn:00004FE0 arg_8           = dword ptr  10h
.text$mn:00004FE0
.text$mn:00004FE0                 push    ebp
.text$mn:00004FE1                 mov     ebp, esp
.text$mn:00004FE3                 sub     esp, 8
.text$mn:00004FE6                 mov     [ebp+var_8], ecx
.text$mn:00004FE9                 lea     eax, [ebp+var_1]
.text$mn:00004FEC                 push    eax
.text$mn:00004FED                 mov     ecx, [ebp+var_8]
.text$mn:00004FF0                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:00004FF5                 lea     ecx, [ebp+var_1]
.text$mn:00004FF8                 push    ecx
.text$mn:00004FF9                 mov     edx, [ebp+arg_8]
.text$mn:00004FFC                 push    edx
.text$mn:00004FFD                 mov     eax, [ebp+arg_4]
.text$mn:00005000                 push    eax
.text$mn:00005001                 mov     ecx, [ebp+arg_0]
.text$mn:00005004                 push    ecx
.text$mn:00005005                 call    ??$_Uninitialized_move@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z ; std::_Uninitialized_move<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)
.text$mn:0000500A                 add     esp, 10h
.text$mn:0000500D                 mov     esp, ebp
.text$mn:0000500F                 pop     ebp
.text$mn:00005010                 retn    0Ch
.text$mn:00005010 ??$_Umove@PAUrecordedMacroStep@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@PAU2@00@Z endp
.text$mn:00005010
.text$mn:00005010 ; ---------------------------------------------------------------------------
.text$mn:00005013                 align 4
.text$mn:00005013 _text$mn        ends
.text$mn:00005013
.text$mn:00005014 ; ===========================================================================
.text$mn:00005014
.text$mn:00005014 ; Segment type: Pure code
.text$mn:00005014 ; Segment permissions: Read/Execute
.text$mn:00005014 _text$mn        segment para public 'CODE' use32
.text$mn:00005014                 assume cs:_text$mn
.text$mn:00005014                 ;org 5014h
.text$mn:00005014 ; COMDAT (pick any)
.text$mn:00005014                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005014
.text$mn:00005014 ; =============== S U B R O U T I N E =======================================
.text$mn:00005014
.text$mn:00005014 ; Attributes: bp-based frame
.text$mn:00005014
.text$mn:00005014 ; unsigned int * * __cdecl std::_Unchecked<unsigned int * *>(unsigned int * *)
.text$mn:00005014                 public ??$_Unchecked@PAPAI@std@@YAPAPAIPAPAI@Z
.text$mn:00005014 ??$_Unchecked@PAPAI@std@@YAPAPAIPAPAI@Z proc near
.text$mn:00005014                                         ; CODE XREF: std::_Uninitialized_copy<uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &)+Bp
.text$mn:00005014                                         ; std::_Uninitialized_copy<uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &)+18p ...
.text$mn:00005014
.text$mn:00005014 arg_0           = dword ptr  8
.text$mn:00005014
.text$mn:00005014                 push    ebp
.text$mn:00005015                 mov     ebp, esp
.text$mn:00005017                 mov     eax, [ebp+arg_0]
.text$mn:0000501A                 pop     ebp
.text$mn:0000501B                 retn
.text$mn:0000501B ??$_Unchecked@PAPAI@std@@YAPAPAIPAPAI@Z endp
.text$mn:0000501B
.text$mn:0000501B _text$mn        ends
.text$mn:0000501B
.text$mn:0000501C ; ===========================================================================
.text$mn:0000501C
.text$mn:0000501C ; Segment type: Pure code
.text$mn:0000501C ; Segment permissions: Read/Execute
.text$mn:0000501C _text$mn        segment para public 'CODE' use32
.text$mn:0000501C                 assume cs:_text$mn
.text$mn:0000501C                 ;org 501Ch
.text$mn:0000501C ; COMDAT (pick any)
.text$mn:0000501C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000501C
.text$mn:0000501C ; =============== S U B R O U T I N E =======================================
.text$mn:0000501C
.text$mn:0000501C ; Attributes: bp-based frame
.text$mn:0000501C
.text$mn:0000501C ; struct MenuItemUnit * __cdecl std::_Unchecked<struct MenuItemUnit *>(struct MenuItemUnit *)
.text$mn:0000501C                 public ??$_Unchecked@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z
.text$mn:0000501C ??$_Unchecked@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z proc near
.text$mn:0000501C                                         ; CODE XREF: std::_Uninitialized_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+Bp
.text$mn:0000501C                                         ; std::_Uninitialized_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+18p ...
.text$mn:0000501C
.text$mn:0000501C arg_0           = dword ptr  8
.text$mn:0000501C
.text$mn:0000501C                 push    ebp
.text$mn:0000501D                 mov     ebp, esp
.text$mn:0000501F                 mov     eax, [ebp+arg_0]
.text$mn:00005022                 pop     ebp
.text$mn:00005023                 retn
.text$mn:00005023 ??$_Unchecked@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z endp
.text$mn:00005023
.text$mn:00005023 _text$mn        ends
.text$mn:00005023
.text$mn:00005024 ; ===========================================================================
.text$mn:00005024
.text$mn:00005024 ; Segment type: Pure code
.text$mn:00005024 ; Segment permissions: Read/Execute
.text$mn:00005024 _text$mn        segment para public 'CODE' use32
.text$mn:00005024                 assume cs:_text$mn
.text$mn:00005024                 ;org 5024h
.text$mn:00005024 ; COMDAT (pick any)
.text$mn:00005024                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005024
.text$mn:00005024 ; =============== S U B R O U T I N E =======================================
.text$mn:00005024
.text$mn:00005024 ; Attributes: bp-based frame
.text$mn:00005024
.text$mn:00005024 ; struct recordedMacroStep * __cdecl std::_Unchecked<struct recordedMacroStep *>(struct recordedMacroStep *)
.text$mn:00005024                 public ??$_Unchecked@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z
.text$mn:00005024 ??$_Unchecked@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z proc near
.text$mn:00005024                                         ; CODE XREF: std::_Uninitialized_move<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+Bp
.text$mn:00005024                                         ; std::_Uninitialized_move<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+18p ...
.text$mn:00005024
.text$mn:00005024 arg_0           = dword ptr  8
.text$mn:00005024
.text$mn:00005024                 push    ebp
.text$mn:00005025                 mov     ebp, esp
.text$mn:00005027                 mov     eax, [ebp+arg_0]
.text$mn:0000502A                 pop     ebp
.text$mn:0000502B                 retn
.text$mn:0000502B ??$_Unchecked@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z endp
.text$mn:0000502B
.text$mn:0000502B _text$mn        ends
.text$mn:0000502B
.text$mn:0000502C ; ===========================================================================
.text$mn:0000502C
.text$mn:0000502C ; Segment type: Pure code
.text$mn:0000502C ; Segment permissions: Read/Execute
.text$mn:0000502C _text$mn        segment para public 'CODE' use32
.text$mn:0000502C                 assume cs:_text$mn
.text$mn:0000502C                 ;org 502Ch
.text$mn:0000502C ; COMDAT (pick any)
.text$mn:0000502C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000502C
.text$mn:0000502C ; =============== S U B R O U T I N E =======================================
.text$mn:0000502C
.text$mn:0000502C ; Attributes: bp-based frame
.text$mn:0000502C
.text$mn:0000502C ; int __cdecl std::_Uninit_copy<unsigned int *,unsigned int *>(void *Src, int, void *Dst)
.text$mn:0000502C                 public ??$_Uninit_copy@PAIPAI@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:0000502C ??$_Uninit_copy@PAIPAI@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:0000502C                                         ; CODE XREF: std::_Uninit_copy<uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &)+2Cp
.text$mn:0000502C
.text$mn:0000502C var_4           = dword ptr -4
.text$mn:0000502C Src             = dword ptr  8
.text$mn:0000502C arg_4           = dword ptr  0Ch
.text$mn:0000502C Dst             = dword ptr  10h
.text$mn:0000502C
.text$mn:0000502C                 push    ebp
.text$mn:0000502D                 mov     ebp, esp
.text$mn:0000502F                 push    ecx
.text$mn:00005030                 push    192h            ; unsigned int
.text$mn:00005035                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000503A                 mov     eax, [ebp+arg_4]
.text$mn:0000503D                 push    eax             ; int
.text$mn:0000503E                 mov     ecx, [ebp+Src]
.text$mn:00005041                 push    ecx             ; int
.text$mn:00005042                 call    ??$_Debug_range@PAPAI@std@@YAXPAPAI0PB_WI@Z ; std::_Debug_range<uint * *>(uint * *,uint * *,wchar_t const *,uint)
.text$mn:00005047                 add     esp, 10h
.text$mn:0000504A                 push    193h            ; unsigned int
.text$mn:0000504F                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005054                 mov     edx, [ebp+Dst]
.text$mn:00005057                 push    edx             ; int
.text$mn:00005058                 call    ??$_Debug_pointer@PAI@std@@YAXPAPAIPB_WI@Z ; std::_Debug_pointer<uint *>(uint * *,wchar_t const *,uint)
.text$mn:0000505D                 add     esp, 0Ch
.text$mn:00005060                 mov     eax, [ebp+arg_4]
.text$mn:00005063                 sub     eax, [ebp+Src]
.text$mn:00005066                 sar     eax, 2
.text$mn:00005069                 mov     [ebp+var_4], eax
.text$mn:0000506C                 mov     ecx, [ebp+var_4]
.text$mn:0000506F                 shl     ecx, 2
.text$mn:00005072                 push    ecx             ; Size
.text$mn:00005073                 mov     edx, [ebp+Src]
.text$mn:00005076                 push    edx             ; Src
.text$mn:00005077                 mov     eax, [ebp+Dst]
.text$mn:0000507A                 push    eax             ; Dst
.text$mn:0000507B                 call    _memmove
.text$mn:00005080                 add     esp, 0Ch
.text$mn:00005083                 mov     ecx, [ebp+var_4]
.text$mn:00005086                 lea     eax, [eax+ecx*4]
.text$mn:00005089                 mov     esp, ebp
.text$mn:0000508B                 pop     ebp
.text$mn:0000508C                 retn
.text$mn:0000508C ??$_Uninit_copy@PAIPAI@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000508C
.text$mn:0000508C ; ---------------------------------------------------------------------------
.text$mn:0000508D                 align 10h
.text$mn:0000508D _text$mn        ends
.text$mn:0000508D
.text$mn:00005090 ; ===========================================================================
.text$mn:00005090
.text$mn:00005090 ; Segment type: Pure code
.text$mn:00005090 ; Segment permissions: Read/Execute
.text$mn:00005090 _text$mn        segment para public 'CODE' use32
.text$mn:00005090                 assume cs:_text$mn
.text$mn:00005090                 ;org 5090h
.text$mn:00005090 ; COMDAT (pick any)
.text$mn:00005090                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005090
.text$mn:00005090 ; =============== S U B R O U T I N E =======================================
.text$mn:00005090
.text$mn:00005090 ; Attributes: bp-based frame
.text$mn:00005090
.text$mn:00005090 ; int __cdecl std::_Uninit_copy<unsigned int * *,unsigned int * *,std::_Wrap_alloc<std::allocator<unsigned int *>>>(void *Src, int, void *Dst, int)
.text$mn:00005090                 public ??$_Uninit_copy@PAPAIPAPAIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z
.text$mn:00005090 ??$_Uninit_copy@PAPAIPAPAIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z proc near
.text$mn:00005090                                         ; CODE XREF: std::_Uninitialized_copy<uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &)+2Ep
.text$mn:00005090
.text$mn:00005090 var_1           = byte ptr -1
.text$mn:00005090 Src             = dword ptr  8
.text$mn:00005090 arg_4           = dword ptr  0Ch
.text$mn:00005090 Dst             = dword ptr  10h
.text$mn:00005090 arg_C           = dword ptr  14h
.text$mn:00005090
.text$mn:00005090                 push    ebp
.text$mn:00005091                 mov     ebp, esp
.text$mn:00005093                 push    ecx
.text$mn:00005094                 mov     eax, [ebp+Dst]
.text$mn:00005097                 push    eax
.text$mn:00005098                 mov     ecx, [ebp+Src]
.text$mn:0000509B                 push    ecx
.text$mn:0000509C                 call    ??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAI0@Z ; std::_Ptr_cat<uint *,uint *>(uint * *,uint * *)
.text$mn:000050A1                 add     esp, 8
.text$mn:000050A4                 mov     [ebp+var_1], al
.text$mn:000050A7                 movzx   edx, [ebp+var_1]
.text$mn:000050AB                 push    edx
.text$mn:000050AC                 mov     eax, [ebp+arg_C]
.text$mn:000050AF                 push    eax
.text$mn:000050B0                 mov     ecx, [ebp+Dst]
.text$mn:000050B3                 push    ecx             ; Dst
.text$mn:000050B4                 mov     edx, [ebp+arg_4]
.text$mn:000050B7                 push    edx             ; int
.text$mn:000050B8                 mov     eax, [ebp+Src]
.text$mn:000050BB                 push    eax             ; Src
.text$mn:000050BC                 call    ??$_Uninit_copy@PAIPAI@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<uint *,uint *>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:000050C1                 add     esp, 14h
.text$mn:000050C4                 mov     esp, ebp
.text$mn:000050C6                 pop     ebp
.text$mn:000050C7                 retn
.text$mn:000050C7 ??$_Uninit_copy@PAPAIPAPAIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z endp
.text$mn:000050C7
.text$mn:000050C7 _text$mn        ends
.text$mn:000050C7
.text$mn:000050C8 ; ===========================================================================
.text$mn:000050C8
.text$mn:000050C8 ; Segment type: Pure code
.text$mn:000050C8 ; Segment permissions: Read/Execute
.text$mn:000050C8 _text$mn        segment para public 'CODE' use32
.text$mn:000050C8                 assume cs:_text$mn
.text$mn:000050C8                 ;org 50C8h
.text$mn:000050C8 ; COMDAT (pick any)
.text$mn:000050C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000050C8
.text$mn:000050C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000050C8
.text$mn:000050C8 ; Attributes: bp-based frame
.text$mn:000050C8
.text$mn:000050C8 ; void __cdecl std::_Uninit_def_fill_n<unsigned int *, unsigned int, unsigned int *>(unsigned int * *, unsigned int, struct std::_Wrap_alloc<class std::allocator<unsigned int *>> &, unsigned int * *, struct std::_Scalar_ptr_iterator_tag)
.text$mn:000050C8                 public ??$_Uninit_def_fill_n@PAIIPAI@std@@YAXPAPAIIAAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:000050C8 ??$_Uninit_def_fill_n@PAIIPAI@std@@YAXPAPAIIAAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000050C8                                         ; CODE XREF: std::_Uninitialized_default_fill_n<uint * *,uint,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint,std::_Wrap_alloc<std::allocator<uint *>> &)+35p
.text$mn:000050C8
.text$mn:000050C8 var_4           = dword ptr -4
.text$mn:000050C8 arg_0           = dword ptr  8
.text$mn:000050C8 arg_4           = dword ptr  0Ch
.text$mn:000050C8
.text$mn:000050C8                 push    ebp
.text$mn:000050C9                 mov     ebp, esp
.text$mn:000050CB                 push    ecx
.text$mn:000050CC                 mov     [ebp+var_4], 0
.text$mn:000050D3                 lea     eax, [ebp+var_4]
.text$mn:000050D6                 push    eax
.text$mn:000050D7                 mov     ecx, [ebp+arg_4]
.text$mn:000050DA                 push    ecx
.text$mn:000050DB                 mov     edx, [ebp+arg_0]
.text$mn:000050DE                 push    edx
.text$mn:000050DF                 call    ??$_Fill_n@PAPAIIPAI@std@@YAPAPAIPAPAIIABQAI@Z ; std::_Fill_n<uint * *,uint,uint *>(uint * *,uint,uint * const &)
.text$mn:000050E4                 add     esp, 0Ch
.text$mn:000050E7                 mov     esp, ebp
.text$mn:000050E9                 pop     ebp
.text$mn:000050EA                 retn
.text$mn:000050EA ??$_Uninit_def_fill_n@PAIIPAI@std@@YAXPAPAIIAAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:000050EA
.text$mn:000050EA ; ---------------------------------------------------------------------------
.text$mn:000050EB                 align 4
.text$mn:000050EB _text$mn        ends
.text$mn:000050EB
.text$mn:000050EC ; ===========================================================================
.text$mn:000050EC
.text$mn:000050EC ; Segment type: Pure code
.text$mn:000050EC ; Segment permissions: Read/Execute
.text$mn:000050EC _text$mn        segment para public 'CODE' use32
.text$mn:000050EC                 assume cs:_text$mn
.text$mn:000050EC                 ;org 50ECh
.text$mn:000050EC ; COMDAT (pick any)
.text$mn:000050EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000050EC
.text$mn:000050EC ; =============== S U B R O U T I N E =======================================
.text$mn:000050EC
.text$mn:000050EC ; Attributes: bp-based frame
.text$mn:000050EC
.text$mn:000050EC ; int __cdecl std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(int, int, void *, int)
.text$mn:000050EC                 public ??$_Uninit_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z
.text$mn:000050EC ??$_Uninit_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z proc near
.text$mn:000050EC                                         ; CODE XREF: std::_Uninitialized_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+2Ep
.text$mn:000050EC
.text$mn:000050EC var_1           = byte ptr -1
.text$mn:000050EC arg_0           = dword ptr  8
.text$mn:000050EC arg_4           = dword ptr  0Ch
.text$mn:000050EC arg_8           = dword ptr  10h
.text$mn:000050EC arg_C           = dword ptr  14h
.text$mn:000050EC
.text$mn:000050EC                 push    ebp
.text$mn:000050ED                 mov     ebp, esp
.text$mn:000050EF                 push    ecx
.text$mn:000050F0                 mov     eax, [ebp+arg_8]
.text$mn:000050F3                 push    eax
.text$mn:000050F4                 mov     ecx, [ebp+arg_0]
.text$mn:000050F7                 push    ecx
.text$mn:000050F8                 call    ??$_Ptr_cat@UMenuItemUnit@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUMenuItemUnit@@0@Z ; std::_Ptr_cat<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *)
.text$mn:000050FD                 add     esp, 8
.text$mn:00005100                 mov     [ebp+var_1], al
.text$mn:00005103                 movzx   edx, [ebp+var_1]
.text$mn:00005107                 push    edx
.text$mn:00005108                 mov     eax, [ebp+arg_0]
.text$mn:0000510B                 push    eax
.text$mn:0000510C                 call    ??$_Val_type@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z ; std::_Val_type<MenuItemUnit *>(MenuItemUnit *)
.text$mn:00005111                 add     esp, 4
.text$mn:00005114                 push    eax
.text$mn:00005115                 mov     ecx, [ebp+arg_C]
.text$mn:00005118                 push    ecx             ; int
.text$mn:00005119                 mov     edx, [ebp+arg_8]
.text$mn:0000511C                 push    edx             ; void *
.text$mn:0000511D                 mov     eax, [ebp+arg_4]
.text$mn:00005120                 push    eax             ; int
.text$mn:00005121                 mov     ecx, [ebp+arg_0]
.text$mn:00005124                 push    ecx             ; int
.text$mn:00005125                 call    ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000512A                 add     esp, 18h
.text$mn:0000512D                 mov     esp, ebp
.text$mn:0000512F                 pop     ebp
.text$mn:00005130                 retn
.text$mn:00005130 ??$_Uninit_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z endp
.text$mn:00005130
.text$mn:00005130 ; ---------------------------------------------------------------------------
.text$mn:00005131                 align 4
.text$mn:00005131 _text$mn        ends
.text$mn:00005131
.text$mn:00005134 ; ===========================================================================
.text$mn:00005134
.text$mn:00005134 ; Segment type: Pure code
.text$mn:00005134 ; Segment permissions: Read/Execute
.text$mn:00005134 _text$mn        segment para public 'CODE' use32
.text$mn:00005134                 assume cs:_text$mn
.text$mn:00005134                 ;org 5134h
.text$mn:00005134 ; COMDAT (pick any)
.text$mn:00005134                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005134
.text$mn:00005134 ; =============== S U B R O U T I N E =======================================
.text$mn:00005134
.text$mn:00005134 ; Attributes: bp-based frame
.text$mn:00005134
.text$mn:00005134 ; int __cdecl std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(int, int, void *, int)
.text$mn:00005134                 public ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00005134 ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00005134                                         ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+39p
.text$mn:00005134
.text$mn:00005134 var_14          = dword ptr -14h
.text$mn:00005134 var_10          = dword ptr -10h
.text$mn:00005134 var_C           = dword ptr -0Ch
.text$mn:00005134 var_4           = dword ptr -4
.text$mn:00005134 arg_0           = dword ptr  8
.text$mn:00005134 arg_4           = dword ptr  0Ch
.text$mn:00005134 arg_8           = dword ptr  10h
.text$mn:00005134 arg_C           = dword ptr  14h
.text$mn:00005134
.text$mn:00005134 ; FUNCTION CHUNK AT .text$mn:000051FB SIZE 00000009 BYTES
.text$mn:00005134 ; FUNCTION CHUNK AT .text$mn:0000520B SIZE 00000015 BYTES
.text$mn:00005134
.text$mn:00005134                 push    ebp
.text$mn:00005135                 mov     ebp, esp
.text$mn:00005137                 push    0FFFFFFFFh
.text$mn:00005139                 push    offset __ehhandler$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000513E                 mov     eax, large fs:0
.text$mn:00005144                 push    eax
.text$mn:00005145                 push    ecx
.text$mn:00005146                 push    ecx
.text$mn:00005147                 push    ebx
.text$mn:00005148                 push    esi
.text$mn:00005149                 push    edi
.text$mn:0000514A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000514F                 xor     eax, ebp
.text$mn:00005151                 push    eax
.text$mn:00005152                 lea     eax, [ebp+var_C]
.text$mn:00005155                 mov     large fs:0, eax
.text$mn:0000515B                 mov     [ebp+var_10], esp
.text$mn:0000515E                 push    1B6h            ; unsigned int
.text$mn:00005163                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005168                 mov     eax, [ebp+arg_4]
.text$mn:0000516B                 push    eax             ; int
.text$mn:0000516C                 mov     ecx, [ebp+arg_0]
.text$mn:0000516F                 push    ecx             ; int
.text$mn:00005170                 call    ??$_Debug_range@PAUMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@0PB_WI@Z ; std::_Debug_range<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint)
.text$mn:00005175                 add     esp, 10h
.text$mn:00005178                 push    1B7h            ; unsigned int
.text$mn:0000517D                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005182                 mov     edx, [ebp+arg_8]
.text$mn:00005185                 push    edx             ; int
.text$mn:00005186                 call    ??$_Debug_pointer@UMenuItemUnit@@@std@@YAXPAUMenuItemUnit@@PB_WI@Z ; std::_Debug_pointer<MenuItemUnit>(MenuItemUnit *,wchar_t const *,uint)
.text$mn:0000518B                 add     esp, 0Ch
.text$mn:0000518E                 mov     eax, [ebp+arg_8]
.text$mn:00005191                 mov     [ebp+var_14], eax
.text$mn:00005194                 mov     [ebp+var_4], 0
.text$mn:0000519B                 jmp     short loc_51AF
.text$mn:0000519D ; ---------------------------------------------------------------------------
.text$mn:0000519D
.text$mn:0000519D loc_519D:                               ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:0000519D                 mov     ecx, [ebp+arg_8]
.text$mn:000051A0                 add     ecx, 3Ch ; '<'
.text$mn:000051A3                 mov     [ebp+arg_8], ecx
.text$mn:000051A6                 mov     edx, [ebp+arg_0]
.text$mn:000051A9                 add     edx, 3Ch ; '<'
.text$mn:000051AC                 mov     [ebp+arg_0], edx
.text$mn:000051AF
.text$mn:000051AF loc_51AF:                               ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:000051AF                 mov     eax, [ebp+arg_0]
.text$mn:000051B2                 cmp     eax, [ebp+arg_4]
.text$mn:000051B5                 jz      short loc_51C9
.text$mn:000051B7                 mov     ecx, [ebp+arg_0]
.text$mn:000051BA                 push    ecx             ; int
.text$mn:000051BB                 mov     edx, [ebp+arg_8]
.text$mn:000051BE                 push    edx             ; void *
.text$mn:000051BF                 mov     ecx, [ebp+arg_C]
.text$mn:000051C2                 call    ??$construct@UMenuItemUnit@@U1@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)
.text$mn:000051C7                 jmp     short loc_519D
.text$mn:000051C9 ; ---------------------------------------------------------------------------
.text$mn:000051C9
.text$mn:000051C9 loc_51C9:                               ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:000051C9                 jmp     short loc_51FB
.text$mn:000051C9 ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000051C9
.text$mn:000051CB
.text$mn:000051CB ; =============== S U B R O U T I N E =======================================
.text$mn:000051CB
.text$mn:000051CB ; Attributes: noreturn
.text$mn:000051CB
.text$mn:000051CB __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:000051CB                                         ; DATA XREF: .xdata$x:0000C2E4o
.text$mn:000051CB                 jmp     short loc_51D6
.text$mn:000051CD ; ---------------------------------------------------------------------------
.text$mn:000051CD
.text$mn:000051CD loc_51CD:                               ; CODE XREF: __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:000051CD                 mov     eax, [ebp-14h]
.text$mn:000051D0                 add     eax, 3Ch ; '<'
.text$mn:000051D3                 mov     [ebp-14h], eax
.text$mn:000051D6
.text$mn:000051D6 loc_51D6:                               ; CODE XREF: __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:000051D6                 mov     ecx, [ebp-14h]
.text$mn:000051D9                 cmp     ecx, [ebp+10h]
.text$mn:000051DC                 jz      short loc_51EC
.text$mn:000051DE                 mov     edx, [ebp-14h]
.text$mn:000051E1                 push    edx
.text$mn:000051E2                 mov     ecx, [ebp+14h]
.text$mn:000051E5                 call    ??$destroy@UMenuItemUnit@@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::destroy<MenuItemUnit>(MenuItemUnit *)
.text$mn:000051EA                 jmp     short loc_51CD
.text$mn:000051EC ; ---------------------------------------------------------------------------
.text$mn:000051EC
.text$mn:000051EC loc_51EC:                               ; CODE XREF: __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:000051EC                 push    0
.text$mn:000051EE                 push    0
.text$mn:000051F0                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000051F0 __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:000051F0
.text$mn:000051F5 ; ---------------------------------------------------------------------------
.text$mn:000051F5                 mov     eax, offset $LN13_0
.text$mn:000051FA                 retn
.text$mn:000051FB ; ---------------------------------------------------------------------------
.text$mn:000051FB ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000051FB
.text$mn:000051FB loc_51FB:                               ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag):loc_51C9j
.text$mn:000051FB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005202                 jmp     short loc_520B
.text$mn:00005202 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00005204
.text$mn:00005204 ; =============== S U B R O U T I N E =======================================
.text$mn:00005204
.text$mn:00005204
.text$mn:00005204 $LN13_0         proc near               ; DATA XREF: .text$mn:000051F5o
.text$mn:00005204                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00005204 $LN13_0         endp ; sp-analysis failed
.text$mn:00005204
.text$mn:0000520B ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000520B
.text$mn:0000520B loc_520B:                               ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:0000520B                 mov     eax, [ebp+arg_8]
.text$mn:0000520E                 mov     ecx, [ebp+var_C]
.text$mn:00005211                 mov     large fs:0, ecx
.text$mn:00005218                 pop     ecx
.text$mn:00005219                 pop     edi
.text$mn:0000521A                 pop     esi
.text$mn:0000521B                 pop     ebx
.text$mn:0000521C                 mov     esp, ebp
.text$mn:0000521E                 pop     ebp
.text$mn:0000521F                 retn
.text$mn:0000521F ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000521F _text$mn        ends
.text$mn:0000521F
.text$x:00005220 ; ===========================================================================
.text$x:00005220
.text$x:00005220 ; Segment type: Pure code
.text$x:00005220 ; Segment permissions: Read/Execute
.text$x:00005220 _text$x         segment para public 'CODE' use32
.text$x:00005220                 assume cs:_text$x
.text$x:00005220                 ;org 5220h
.text$x:00005220 ; COMDAT (pick associative to section at 5134)
.text$x:00005220                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005220
.text$x:00005220 ; =============== S U B R O U T I N E =======================================
.text$x:00005220
.text$x:00005220
.text$x:00005220 __ehhandler$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00005220                                         ; DATA XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00005220
.text$x:00005220 arg_4           = dword ptr  8
.text$x:00005220
.text$x:00005220                 mov     edx, [esp+arg_4]
.text$x:00005224                 lea     eax, [edx+0Ch]
.text$x:00005227                 mov     ecx, [edx-18h]
.text$x:0000522A                 xor     ecx, eax
.text$x:0000522C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005231                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00005236                 jmp     ___CxxFrameHandler3
.text$x:00005236 __ehhandler$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00005236
.text$x:00005236 ; ---------------------------------------------------------------------------
.text$x:0000523B                 align 4
.text$x:0000523B _text$x         ends
.text$x:0000523B
.text$mn:0000523C ; ===========================================================================
.text$mn:0000523C
.text$mn:0000523C ; Segment type: Pure code
.text$mn:0000523C ; Segment permissions: Read/Execute
.text$mn:0000523C _text$mn        segment para public 'CODE' use32
.text$mn:0000523C                 assume cs:_text$mn
.text$mn:0000523C                 ;org 523Ch
.text$mn:0000523C ; COMDAT (pick any)
.text$mn:0000523C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000523C
.text$mn:0000523C ; =============== S U B R O U T I N E =======================================
.text$mn:0000523C
.text$mn:0000523C ; Attributes: bp-based frame
.text$mn:0000523C
.text$mn:0000523C ; int __cdecl std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(int, int, void *, int)
.text$mn:0000523C                 public ??$_Uninit_move@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z
.text$mn:0000523C ??$_Uninit_move@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z proc near
.text$mn:0000523C                                         ; CODE XREF: std::_Uninitialized_move<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+2Ep
.text$mn:0000523C
.text$mn:0000523C var_1           = byte ptr -1
.text$mn:0000523C arg_0           = dword ptr  8
.text$mn:0000523C arg_4           = dword ptr  0Ch
.text$mn:0000523C arg_8           = dword ptr  10h
.text$mn:0000523C arg_C           = dword ptr  14h
.text$mn:0000523C
.text$mn:0000523C                 push    ebp
.text$mn:0000523D                 mov     ebp, esp
.text$mn:0000523F                 push    ecx
.text$mn:00005240                 mov     eax, [ebp+arg_8]
.text$mn:00005243                 push    eax
.text$mn:00005244                 mov     ecx, [ebp+arg_0]
.text$mn:00005247                 push    ecx
.text$mn:00005248                 call    ??$_Ptr_cat@UrecordedMacroStep@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUrecordedMacroStep@@0@Z ; std::_Ptr_cat<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep *)
.text$mn:0000524D                 add     esp, 8
.text$mn:00005250                 mov     [ebp+var_1], al
.text$mn:00005253                 movzx   edx, [ebp+var_1]
.text$mn:00005257                 push    edx
.text$mn:00005258                 mov     eax, [ebp+arg_0]
.text$mn:0000525B                 push    eax
.text$mn:0000525C                 call    ??$_Val_type@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z ; std::_Val_type<recordedMacroStep *>(recordedMacroStep *)
.text$mn:00005261                 add     esp, 4
.text$mn:00005264                 push    eax
.text$mn:00005265                 mov     ecx, [ebp+arg_C]
.text$mn:00005268                 push    ecx             ; int
.text$mn:00005269                 mov     edx, [ebp+arg_8]
.text$mn:0000526C                 push    edx             ; void *
.text$mn:0000526D                 mov     eax, [ebp+arg_4]
.text$mn:00005270                 push    eax             ; int
.text$mn:00005271                 mov     ecx, [ebp+arg_0]
.text$mn:00005274                 push    ecx             ; int
.text$mn:00005275                 call    ??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>,recordedMacroStep>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,recordedMacroStep *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000527A                 add     esp, 18h
.text$mn:0000527D                 mov     esp, ebp
.text$mn:0000527F                 pop     ebp
.text$mn:00005280                 retn
.text$mn:00005280 ??$_Uninit_move@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z endp
.text$mn:00005280
.text$mn:00005280 ; ---------------------------------------------------------------------------
.text$mn:00005281                 align 4
.text$mn:00005281 _text$mn        ends
.text$mn:00005281
.text$mn:00005284 ; ===========================================================================
.text$mn:00005284
.text$mn:00005284 ; Segment type: Pure code
.text$mn:00005284 ; Segment permissions: Read/Execute
.text$mn:00005284 _text$mn        segment para public 'CODE' use32
.text$mn:00005284                 assume cs:_text$mn
.text$mn:00005284                 ;org 5284h
.text$mn:00005284 ; COMDAT (pick any)
.text$mn:00005284                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005284
.text$mn:00005284 ; =============== S U B R O U T I N E =======================================
.text$mn:00005284
.text$mn:00005284 ; Attributes: bp-based frame
.text$mn:00005284
.text$mn:00005284 ; int __cdecl std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>,recordedMacroStep>(int, int, void *, int)
.text$mn:00005284                 public ??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00005284 ??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00005284                                         ; CODE XREF: std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+39p
.text$mn:00005284
.text$mn:00005284 var_14          = dword ptr -14h
.text$mn:00005284 var_10          = dword ptr -10h
.text$mn:00005284 var_C           = dword ptr -0Ch
.text$mn:00005284 var_4           = dword ptr -4
.text$mn:00005284 arg_0           = dword ptr  8
.text$mn:00005284 arg_4           = dword ptr  0Ch
.text$mn:00005284 arg_8           = dword ptr  10h
.text$mn:00005284 arg_C           = dword ptr  14h
.text$mn:00005284
.text$mn:00005284 ; FUNCTION CHUNK AT .text$mn:0000534B SIZE 00000009 BYTES
.text$mn:00005284 ; FUNCTION CHUNK AT .text$mn:0000535B SIZE 00000015 BYTES
.text$mn:00005284
.text$mn:00005284                 push    ebp
.text$mn:00005285                 mov     ebp, esp
.text$mn:00005287                 push    0FFFFFFFFh
.text$mn:00005289                 push    offset __ehhandler$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000528E                 mov     eax, large fs:0
.text$mn:00005294                 push    eax
.text$mn:00005295                 push    ecx
.text$mn:00005296                 push    ecx
.text$mn:00005297                 push    ebx
.text$mn:00005298                 push    esi
.text$mn:00005299                 push    edi
.text$mn:0000529A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000529F                 xor     eax, ebp
.text$mn:000052A1                 push    eax
.text$mn:000052A2                 lea     eax, [ebp+var_C]
.text$mn:000052A5                 mov     large fs:0, eax
.text$mn:000052AB                 mov     [ebp+var_10], esp
.text$mn:000052AE                 push    1B6h            ; unsigned int
.text$mn:000052B3                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000052B8                 mov     eax, [ebp+arg_4]
.text$mn:000052BB                 push    eax             ; int
.text$mn:000052BC                 mov     ecx, [ebp+arg_0]
.text$mn:000052BF                 push    ecx             ; int
.text$mn:000052C0                 call    ??$_Debug_range@PAUrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@0PB_WI@Z ; std::_Debug_range<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,wchar_t const *,uint)
.text$mn:000052C5                 add     esp, 10h
.text$mn:000052C8                 push    1B7h            ; unsigned int
.text$mn:000052CD                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000052D2                 mov     edx, [ebp+arg_8]
.text$mn:000052D5                 push    edx             ; int
.text$mn:000052D6                 call    ??$_Debug_pointer@UrecordedMacroStep@@@std@@YAXPAUrecordedMacroStep@@PB_WI@Z ; std::_Debug_pointer<recordedMacroStep>(recordedMacroStep *,wchar_t const *,uint)
.text$mn:000052DB                 add     esp, 0Ch
.text$mn:000052DE                 mov     eax, [ebp+arg_8]
.text$mn:000052E1                 mov     [ebp+var_14], eax
.text$mn:000052E4                 mov     [ebp+var_4], 0
.text$mn:000052EB                 jmp     short loc_52FF
.text$mn:000052ED ; ---------------------------------------------------------------------------
.text$mn:000052ED
.text$mn:000052ED loc_52ED:                               ; CODE XREF: std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>,recordedMacroStep>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,recordedMacroStep *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:000052ED                 mov     ecx, [ebp+arg_8]
.text$mn:000052F0                 add     ecx, 2Ch ; ','
.text$mn:000052F3                 mov     [ebp+arg_8], ecx
.text$mn:000052F6                 mov     edx, [ebp+arg_0]
.text$mn:000052F9                 add     edx, 2Ch ; ','
.text$mn:000052FC                 mov     [ebp+arg_0], edx
.text$mn:000052FF
.text$mn:000052FF loc_52FF:                               ; CODE XREF: std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>,recordedMacroStep>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,recordedMacroStep *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:000052FF                 mov     eax, [ebp+arg_0]
.text$mn:00005302                 cmp     eax, [ebp+arg_4]
.text$mn:00005305                 jz      short loc_5319
.text$mn:00005307                 mov     ecx, [ebp+arg_0]
.text$mn:0000530A                 push    ecx             ; int
.text$mn:0000530B                 mov     edx, [ebp+arg_8]
.text$mn:0000530E                 push    edx             ; void *
.text$mn:0000530F                 mov     ecx, [ebp+arg_C]
.text$mn:00005312                 call    ??$construct@UrecordedMacroStep@@U1@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep &&)
.text$mn:00005317                 jmp     short loc_52ED
.text$mn:00005319 ; ---------------------------------------------------------------------------
.text$mn:00005319
.text$mn:00005319 loc_5319:                               ; CODE XREF: std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>,recordedMacroStep>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,recordedMacroStep *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00005319                 jmp     short loc_534B
.text$mn:00005319 ??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00005319
.text$mn:0000531B
.text$mn:0000531B ; =============== S U B R O U T I N E =======================================
.text$mn:0000531B
.text$mn:0000531B ; Attributes: noreturn
.text$mn:0000531B
.text$mn:0000531B __catch$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:0000531B                                         ; DATA XREF: .xdata$x:0000C28Co
.text$mn:0000531B                 jmp     short loc_5326
.text$mn:0000531D ; ---------------------------------------------------------------------------
.text$mn:0000531D
.text$mn:0000531D loc_531D:                               ; CODE XREF: __catch$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:0000531D                 mov     eax, [ebp-14h]
.text$mn:00005320                 add     eax, 2Ch ; ','
.text$mn:00005323                 mov     [ebp-14h], eax
.text$mn:00005326
.text$mn:00005326 loc_5326:                               ; CODE XREF: __catch$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:00005326                 mov     ecx, [ebp-14h]
.text$mn:00005329                 cmp     ecx, [ebp+10h]
.text$mn:0000532C                 jz      short loc_533C
.text$mn:0000532E                 mov     edx, [ebp-14h]
.text$mn:00005331                 push    edx
.text$mn:00005332                 mov     ecx, [ebp+14h]
.text$mn:00005335                 call    ??$destroy@UrecordedMacroStep@@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::destroy<recordedMacroStep>(recordedMacroStep *)
.text$mn:0000533A                 jmp     short loc_531D
.text$mn:0000533C ; ---------------------------------------------------------------------------
.text$mn:0000533C
.text$mn:0000533C loc_533C:                               ; CODE XREF: __catch$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:0000533C                 push    0
.text$mn:0000533E                 push    0
.text$mn:00005340                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00005340 __catch$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:00005340
.text$mn:00005345 ; ---------------------------------------------------------------------------
.text$mn:00005345                 mov     eax, offset $LN13
.text$mn:0000534A                 retn
.text$mn:0000534B ; ---------------------------------------------------------------------------
.text$mn:0000534B ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000534B
.text$mn:0000534B loc_534B:                               ; CODE XREF: std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>,recordedMacroStep>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,recordedMacroStep *,std::_Nonscalar_ptr_iterator_tag):loc_5319j
.text$mn:0000534B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005352                 jmp     short loc_535B
.text$mn:00005352 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00005354
.text$mn:00005354 ; =============== S U B R O U T I N E =======================================
.text$mn:00005354
.text$mn:00005354
.text$mn:00005354 $LN13           proc near               ; DATA XREF: .text$mn:00005345o
.text$mn:00005354                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00005354 $LN13           endp ; sp-analysis failed
.text$mn:00005354
.text$mn:0000535B ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000535B
.text$mn:0000535B loc_535B:                               ; CODE XREF: std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>,recordedMacroStep>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,recordedMacroStep *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:0000535B                 mov     eax, [ebp+arg_8]
.text$mn:0000535E                 mov     ecx, [ebp+var_C]
.text$mn:00005361                 mov     large fs:0, ecx
.text$mn:00005368                 pop     ecx
.text$mn:00005369                 pop     edi
.text$mn:0000536A                 pop     esi
.text$mn:0000536B                 pop     ebx
.text$mn:0000536C                 mov     esp, ebp
.text$mn:0000536E                 pop     ebp
.text$mn:0000536F                 retn
.text$mn:0000536F ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000536F _text$mn        ends
.text$mn:0000536F
.text$x:00005370 ; ===========================================================================
.text$x:00005370
.text$x:00005370 ; Segment type: Pure code
.text$x:00005370 ; Segment permissions: Read/Execute
.text$x:00005370 _text$x         segment para public 'CODE' use32
.text$x:00005370                 assume cs:_text$x
.text$x:00005370                 ;org 5370h
.text$x:00005370 ; COMDAT (pick associative to section at 5284)
.text$x:00005370                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005370
.text$x:00005370 ; =============== S U B R O U T I N E =======================================
.text$x:00005370
.text$x:00005370
.text$x:00005370 __ehhandler$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00005370                                         ; DATA XREF: std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>,recordedMacroStep>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,recordedMacroStep *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00005370
.text$x:00005370 arg_4           = dword ptr  8
.text$x:00005370
.text$x:00005370                 mov     edx, [esp+arg_4]
.text$x:00005374                 lea     eax, [edx+0Ch]
.text$x:00005377                 mov     ecx, [edx-18h]
.text$x:0000537A                 xor     ecx, eax
.text$x:0000537C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005381                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00005386                 jmp     ___CxxFrameHandler3
.text$x:00005386 __ehhandler$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00005386
.text$x:00005386 ; ---------------------------------------------------------------------------
.text$x:0000538B                 align 4
.text$x:0000538B _text$x         ends
.text$x:0000538B
.text$mn:0000538C ; ===========================================================================
.text$mn:0000538C
.text$mn:0000538C ; Segment type: Pure code
.text$mn:0000538C ; Segment permissions: Read/Execute
.text$mn:0000538C _text$mn        segment para public 'CODE' use32
.text$mn:0000538C                 assume cs:_text$mn
.text$mn:0000538C                 ;org 538Ch
.text$mn:0000538C ; COMDAT (pick any)
.text$mn:0000538C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000538C
.text$mn:0000538C ; =============== S U B R O U T I N E =======================================
.text$mn:0000538C
.text$mn:0000538C ; Attributes: bp-based frame
.text$mn:0000538C
.text$mn:0000538C ; unsigned int * * __cdecl std::_Uninitialized_copy<unsigned int * *, unsigned int * *, struct std::_Wrap_alloc<class std::allocator<unsigned int *>>>(unsigned int * *, unsigned int * *, unsigned int * *, struct std::_Wrap_alloc<class std::allocator<unsigned int *>> &)
.text$mn:0000538C                 public ??$_Uninitialized_copy@PAPAIPAPAIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z
.text$mn:0000538C ??$_Uninitialized_copy@PAPAIPAPAIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z proc near
.text$mn:0000538C                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+D6p
.text$mn:0000538C                                         ; std::deque<uint,std::allocator<uint>>::_Growmap(uint)+105p ...
.text$mn:0000538C
.text$mn:0000538C arg_0           = dword ptr  8
.text$mn:0000538C arg_4           = dword ptr  0Ch
.text$mn:0000538C arg_8           = dword ptr  10h
.text$mn:0000538C arg_C           = dword ptr  14h
.text$mn:0000538C
.text$mn:0000538C                 push    ebp
.text$mn:0000538D                 mov     ebp, esp
.text$mn:0000538F                 mov     eax, [ebp+arg_C]
.text$mn:00005392                 push    eax             ; int
.text$mn:00005393                 mov     ecx, [ebp+arg_8]
.text$mn:00005396                 push    ecx
.text$mn:00005397                 call    ??$_Unchecked@PAPAI@std@@YAPAPAIPAPAI@Z ; std::_Unchecked<uint * *>(uint * *)
.text$mn:0000539C                 add     esp, 4
.text$mn:0000539F                 push    eax             ; Dst
.text$mn:000053A0                 mov     edx, [ebp+arg_4]
.text$mn:000053A3                 push    edx
.text$mn:000053A4                 call    ??$_Unchecked@PAPAI@std@@YAPAPAIPAPAI@Z ; std::_Unchecked<uint * *>(uint * *)
.text$mn:000053A9                 add     esp, 4
.text$mn:000053AC                 push    eax             ; int
.text$mn:000053AD                 mov     eax, [ebp+arg_0]
.text$mn:000053B0                 push    eax
.text$mn:000053B1                 call    ??$_Unchecked@PAPAI@std@@YAPAPAIPAPAI@Z ; std::_Unchecked<uint * *>(uint * *)
.text$mn:000053B6                 add     esp, 4
.text$mn:000053B9                 push    eax             ; Src
.text$mn:000053BA                 call    ??$_Uninit_copy@PAPAIPAPAIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z ; std::_Uninit_copy<uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &)
.text$mn:000053BF                 add     esp, 10h
.text$mn:000053C2                 push    eax
.text$mn:000053C3                 lea     ecx, [ebp+arg_8]
.text$mn:000053C6                 push    ecx
.text$mn:000053C7                 call    ??$_Rechecked@PAPAIPAPAI@std@@YAAAPAPAIAAPAPAIPAPAI@Z ; std::_Rechecked<uint * *,uint * *>(uint * * &,uint * *)
.text$mn:000053CC                 add     esp, 8
.text$mn:000053CF                 mov     eax, [eax]
.text$mn:000053D1                 pop     ebp
.text$mn:000053D2                 retn
.text$mn:000053D2 ??$_Uninitialized_copy@PAPAIPAPAIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z endp
.text$mn:000053D2
.text$mn:000053D2 ; ---------------------------------------------------------------------------
.text$mn:000053D3                 align 4
.text$mn:000053D3 _text$mn        ends
.text$mn:000053D3
.text$mn:000053D4 ; ===========================================================================
.text$mn:000053D4
.text$mn:000053D4 ; Segment type: Pure code
.text$mn:000053D4 ; Segment permissions: Read/Execute
.text$mn:000053D4 _text$mn        segment para public 'CODE' use32
.text$mn:000053D4                 assume cs:_text$mn
.text$mn:000053D4                 ;org 53D4h
.text$mn:000053D4 ; COMDAT (pick any)
.text$mn:000053D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000053D4
.text$mn:000053D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000053D4
.text$mn:000053D4 ; Attributes: bp-based frame
.text$mn:000053D4
.text$mn:000053D4 ; void __cdecl std::_Uninitialized_default_fill_n<unsigned int * *, unsigned int, struct std::_Wrap_alloc<class std::allocator<unsigned int *>>>(unsigned int * *, unsigned int, struct std::_Wrap_alloc<class std::allocator<unsigned int *>> &)
.text$mn:000053D4                 public ??$_Uninitialized_default_fill_n@PAPAIIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAXPAPAIIAAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z
.text$mn:000053D4 ??$_Uninitialized_default_fill_n@PAPAIIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAXPAPAIIAAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z proc near
.text$mn:000053D4                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+11Fp
.text$mn:000053D4                                         ; std::deque<uint,std::allocator<uint>>::_Growmap(uint)+133p ...
.text$mn:000053D4
.text$mn:000053D4 var_1           = byte ptr -1
.text$mn:000053D4 arg_0           = dword ptr  8
.text$mn:000053D4 arg_4           = dword ptr  0Ch
.text$mn:000053D4 arg_8           = dword ptr  10h
.text$mn:000053D4
.text$mn:000053D4                 push    ebp
.text$mn:000053D5                 mov     ebp, esp
.text$mn:000053D7                 push    ecx
.text$mn:000053D8                 mov     eax, [ebp+arg_0]
.text$mn:000053DB                 push    eax
.text$mn:000053DC                 mov     ecx, [ebp+arg_0]
.text$mn:000053DF                 push    ecx
.text$mn:000053E0                 call    ??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAI0@Z ; std::_Ptr_cat<uint *,uint *>(uint * *,uint * *)
.text$mn:000053E5                 add     esp, 8
.text$mn:000053E8                 mov     [ebp+var_1], al
.text$mn:000053EB                 movzx   edx, [ebp+var_1]
.text$mn:000053EF                 push    edx
.text$mn:000053F0                 mov     eax, [ebp+arg_0]
.text$mn:000053F3                 push    eax
.text$mn:000053F4                 call    ??$_Val_type@PAPAI@std@@YAPAPAIPAPAI@Z ; std::_Val_type<uint * *>(uint * *)
.text$mn:000053F9                 add     esp, 4
.text$mn:000053FC                 push    eax
.text$mn:000053FD                 mov     ecx, [ebp+arg_8]
.text$mn:00005400                 push    ecx
.text$mn:00005401                 mov     edx, [ebp+arg_4]
.text$mn:00005404                 push    edx
.text$mn:00005405                 mov     eax, [ebp+arg_0]
.text$mn:00005408                 push    eax
.text$mn:00005409                 call    ??$_Uninit_def_fill_n@PAIIPAI@std@@YAXPAPAIIAAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<uint *,uint,uint *>(uint * *,uint,std::_Wrap_alloc<std::allocator<uint *>> &,uint * *,std::_Scalar_ptr_iterator_tag)
.text$mn:0000540E                 add     esp, 14h
.text$mn:00005411                 mov     esp, ebp
.text$mn:00005413                 pop     ebp
.text$mn:00005414                 retn
.text$mn:00005414 ??$_Uninitialized_default_fill_n@PAPAIIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAXPAPAIIAAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z endp
.text$mn:00005414
.text$mn:00005414 ; ---------------------------------------------------------------------------
.text$mn:00005415                 align 4
.text$mn:00005415 _text$mn        ends
.text$mn:00005415
.text$mn:00005418 ; ===========================================================================
.text$mn:00005418
.text$mn:00005418 ; Segment type: Pure code
.text$mn:00005418 ; Segment permissions: Read/Execute
.text$mn:00005418 _text$mn        segment para public 'CODE' use32
.text$mn:00005418                 assume cs:_text$mn
.text$mn:00005418                 ;org 5418h
.text$mn:00005418 ; COMDAT (pick any)
.text$mn:00005418                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005418
.text$mn:00005418 ; =============== S U B R O U T I N E =======================================
.text$mn:00005418
.text$mn:00005418 ; Attributes: bp-based frame
.text$mn:00005418
.text$mn:00005418 ; struct MenuItemUnit * __cdecl std::_Uninitialized_move<struct MenuItemUnit *, struct MenuItemUnit *, struct std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>>(struct MenuItemUnit *, struct MenuItemUnit *, struct MenuItemUnit *, struct std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>> &)
.text$mn:00005418                 public ??$_Uninitialized_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z
.text$mn:00005418 ??$_Uninitialized_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z proc near
.text$mn:00005418                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Umove<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *)+25p
.text$mn:00005418
.text$mn:00005418 arg_0           = dword ptr  8
.text$mn:00005418 arg_4           = dword ptr  0Ch
.text$mn:00005418 arg_8           = dword ptr  10h
.text$mn:00005418 arg_C           = dword ptr  14h
.text$mn:00005418
.text$mn:00005418                 push    ebp
.text$mn:00005419                 mov     ebp, esp
.text$mn:0000541B                 mov     eax, [ebp+arg_C]
.text$mn:0000541E                 push    eax             ; int
.text$mn:0000541F                 mov     ecx, [ebp+arg_8]
.text$mn:00005422                 push    ecx
.text$mn:00005423                 call    ??$_Unchecked@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z ; std::_Unchecked<MenuItemUnit *>(MenuItemUnit *)
.text$mn:00005428                 add     esp, 4
.text$mn:0000542B                 push    eax             ; void *
.text$mn:0000542C                 mov     edx, [ebp+arg_4]
.text$mn:0000542F                 push    edx
.text$mn:00005430                 call    ??$_Unchecked@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z ; std::_Unchecked<MenuItemUnit *>(MenuItemUnit *)
.text$mn:00005435                 add     esp, 4
.text$mn:00005438                 push    eax             ; int
.text$mn:00005439                 mov     eax, [ebp+arg_0]
.text$mn:0000543C                 push    eax
.text$mn:0000543D                 call    ??$_Unchecked@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z ; std::_Unchecked<MenuItemUnit *>(MenuItemUnit *)
.text$mn:00005442                 add     esp, 4
.text$mn:00005445                 push    eax             ; int
.text$mn:00005446                 call    ??$_Uninit_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z ; std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)
.text$mn:0000544B                 add     esp, 10h
.text$mn:0000544E                 push    eax
.text$mn:0000544F                 lea     ecx, [ebp+arg_8]
.text$mn:00005452                 push    ecx
.text$mn:00005453                 call    ??$_Rechecked@PAUMenuItemUnit@@PAU1@@std@@YAAAPAUMenuItemUnit@@AAPAU1@PAU1@@Z ; std::_Rechecked<MenuItemUnit *,MenuItemUnit *>(MenuItemUnit * &,MenuItemUnit *)
.text$mn:00005458                 add     esp, 8
.text$mn:0000545B                 mov     eax, [eax]
.text$mn:0000545D                 pop     ebp
.text$mn:0000545E                 retn
.text$mn:0000545E ??$_Uninitialized_move@PAUMenuItemUnit@@PAU1@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z endp
.text$mn:0000545E
.text$mn:0000545E ; ---------------------------------------------------------------------------
.text$mn:0000545F                 align 10h
.text$mn:0000545F _text$mn        ends
.text$mn:0000545F
.text$mn:00005460 ; ===========================================================================
.text$mn:00005460
.text$mn:00005460 ; Segment type: Pure code
.text$mn:00005460 ; Segment permissions: Read/Execute
.text$mn:00005460 _text$mn        segment para public 'CODE' use32
.text$mn:00005460                 assume cs:_text$mn
.text$mn:00005460                 ;org 5460h
.text$mn:00005460 ; COMDAT (pick any)
.text$mn:00005460                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005460
.text$mn:00005460 ; =============== S U B R O U T I N E =======================================
.text$mn:00005460
.text$mn:00005460 ; Attributes: bp-based frame
.text$mn:00005460
.text$mn:00005460 ; struct recordedMacroStep * __cdecl std::_Uninitialized_move<struct recordedMacroStep *, struct recordedMacroStep *, struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>>(struct recordedMacroStep *, struct recordedMacroStep *, struct recordedMacroStep *, struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> &)
.text$mn:00005460                 public ??$_Uninitialized_move@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z
.text$mn:00005460 ??$_Uninitialized_move@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z proc near
.text$mn:00005460                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Umove<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *)+25p
.text$mn:00005460
.text$mn:00005460 arg_0           = dword ptr  8
.text$mn:00005460 arg_4           = dword ptr  0Ch
.text$mn:00005460 arg_8           = dword ptr  10h
.text$mn:00005460 arg_C           = dword ptr  14h
.text$mn:00005460
.text$mn:00005460                 push    ebp
.text$mn:00005461                 mov     ebp, esp
.text$mn:00005463                 mov     eax, [ebp+arg_C]
.text$mn:00005466                 push    eax             ; int
.text$mn:00005467                 mov     ecx, [ebp+arg_8]
.text$mn:0000546A                 push    ecx
.text$mn:0000546B                 call    ??$_Unchecked@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z ; std::_Unchecked<recordedMacroStep *>(recordedMacroStep *)
.text$mn:00005470                 add     esp, 4
.text$mn:00005473                 push    eax             ; void *
.text$mn:00005474                 mov     edx, [ebp+arg_4]
.text$mn:00005477                 push    edx
.text$mn:00005478                 call    ??$_Unchecked@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z ; std::_Unchecked<recordedMacroStep *>(recordedMacroStep *)
.text$mn:0000547D                 add     esp, 4
.text$mn:00005480                 push    eax             ; int
.text$mn:00005481                 mov     eax, [ebp+arg_0]
.text$mn:00005484                 push    eax
.text$mn:00005485                 call    ??$_Unchecked@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z ; std::_Unchecked<recordedMacroStep *>(recordedMacroStep *)
.text$mn:0000548A                 add     esp, 4
.text$mn:0000548D                 push    eax             ; int
.text$mn:0000548E                 call    ??$_Uninit_move@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z ; std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)
.text$mn:00005493                 add     esp, 10h
.text$mn:00005496                 push    eax
.text$mn:00005497                 lea     ecx, [ebp+arg_8]
.text$mn:0000549A                 push    ecx
.text$mn:0000549B                 call    ??$_Rechecked@PAUrecordedMacroStep@@PAU1@@std@@YAAAPAUrecordedMacroStep@@AAPAU1@PAU1@@Z ; std::_Rechecked<recordedMacroStep *,recordedMacroStep *>(recordedMacroStep * &,recordedMacroStep *)
.text$mn:000054A0                 add     esp, 8
.text$mn:000054A3                 mov     eax, [eax]
.text$mn:000054A5                 pop     ebp
.text$mn:000054A6                 retn
.text$mn:000054A6 ??$_Uninitialized_move@PAUrecordedMacroStep@@PAU1@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z endp
.text$mn:000054A6
.text$mn:000054A6 ; ---------------------------------------------------------------------------
.text$mn:000054A7                 align 4
.text$mn:000054A7 _text$mn        ends
.text$mn:000054A7
.text$mn:000054A8 ; ===========================================================================
.text$mn:000054A8
.text$mn:000054A8 ; Segment type: Pure code
.text$mn:000054A8 ; Segment permissions: Read/Execute
.text$mn:000054A8 _text$mn        segment para public 'CODE' use32
.text$mn:000054A8                 assume cs:_text$mn
.text$mn:000054A8                 ;org 54A8h
.text$mn:000054A8 ; COMDAT (pick any)
.text$mn:000054A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054A8
.text$mn:000054A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000054A8
.text$mn:000054A8 ; Attributes: bp-based frame
.text$mn:000054A8
.text$mn:000054A8 ; unsigned int * * __cdecl std::_Val_type<unsigned int * *>(unsigned int * *)
.text$mn:000054A8                 public ??$_Val_type@PAPAI@std@@YAPAPAIPAPAI@Z
.text$mn:000054A8 ??$_Val_type@PAPAI@std@@YAPAPAIPAPAI@Z proc near
.text$mn:000054A8                                         ; CODE XREF: std::_Uninitialized_default_fill_n<uint * *,uint,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint,std::_Wrap_alloc<std::allocator<uint *>> &)+20p
.text$mn:000054A8                 push    ebp
.text$mn:000054A9                 mov     ebp, esp
.text$mn:000054AB                 xor     eax, eax
.text$mn:000054AD                 pop     ebp
.text$mn:000054AE                 retn
.text$mn:000054AE ??$_Val_type@PAPAI@std@@YAPAPAIPAPAI@Z endp
.text$mn:000054AE
.text$mn:000054AE ; ---------------------------------------------------------------------------
.text$mn:000054AF                 align 10h
.text$mn:000054AF _text$mn        ends
.text$mn:000054AF
.text$mn:000054B0 ; ===========================================================================
.text$mn:000054B0
.text$mn:000054B0 ; Segment type: Pure code
.text$mn:000054B0 ; Segment permissions: Read/Execute
.text$mn:000054B0 _text$mn        segment para public 'CODE' use32
.text$mn:000054B0                 assume cs:_text$mn
.text$mn:000054B0                 ;org 54B0h
.text$mn:000054B0 ; COMDAT (pick any)
.text$mn:000054B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054B0
.text$mn:000054B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054B0
.text$mn:000054B0 ; Attributes: bp-based frame
.text$mn:000054B0
.text$mn:000054B0 ; struct MenuItemUnit * __cdecl std::_Val_type<struct MenuItemUnit *>(struct MenuItemUnit *)
.text$mn:000054B0                 public ??$_Val_type@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z
.text$mn:000054B0 ??$_Val_type@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z proc near
.text$mn:000054B0                                         ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)+20p
.text$mn:000054B0                 push    ebp
.text$mn:000054B1                 mov     ebp, esp
.text$mn:000054B3                 xor     eax, eax
.text$mn:000054B5                 pop     ebp
.text$mn:000054B6                 retn
.text$mn:000054B6 ??$_Val_type@PAUMenuItemUnit@@@std@@YAPAUMenuItemUnit@@PAU1@@Z endp
.text$mn:000054B6
.text$mn:000054B6 ; ---------------------------------------------------------------------------
.text$mn:000054B7                 align 4
.text$mn:000054B7 _text$mn        ends
.text$mn:000054B7
.text$mn:000054B8 ; ===========================================================================
.text$mn:000054B8
.text$mn:000054B8 ; Segment type: Pure code
.text$mn:000054B8 ; Segment permissions: Read/Execute
.text$mn:000054B8 _text$mn        segment para public 'CODE' use32
.text$mn:000054B8                 assume cs:_text$mn
.text$mn:000054B8                 ;org 54B8h
.text$mn:000054B8 ; COMDAT (pick any)
.text$mn:000054B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054B8
.text$mn:000054B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000054B8
.text$mn:000054B8 ; Attributes: bp-based frame
.text$mn:000054B8
.text$mn:000054B8 ; struct recordedMacroStep * __cdecl std::_Val_type<struct recordedMacroStep *>(struct recordedMacroStep *)
.text$mn:000054B8                 public ??$_Val_type@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z
.text$mn:000054B8 ??$_Val_type@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z proc near
.text$mn:000054B8                                         ; CODE XREF: std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)+20p
.text$mn:000054B8                 push    ebp
.text$mn:000054B9                 mov     ebp, esp
.text$mn:000054BB                 xor     eax, eax
.text$mn:000054BD                 pop     ebp
.text$mn:000054BE                 retn
.text$mn:000054BE ??$_Val_type@PAUrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@PAU1@@Z endp
.text$mn:000054BE
.text$mn:000054BE ; ---------------------------------------------------------------------------
.text$mn:000054BF                 align 10h
.text$mn:000054BF _text$mn        ends
.text$mn:000054BF
.text$mn:000054C0 ; ===========================================================================
.text$mn:000054C0
.text$mn:000054C0 ; Segment type: Pure code
.text$mn:000054C0 ; Segment permissions: Read/Execute
.text$mn:000054C0 _text$mn        segment para public 'CODE' use32
.text$mn:000054C0                 assume cs:_text$mn
.text$mn:000054C0                 ;org 54C0h
.text$mn:000054C0 ; COMDAT (pick any)
.text$mn:000054C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054C0
.text$mn:000054C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054C0
.text$mn:000054C0 ; Attributes: bp-based frame
.text$mn:000054C0
.text$mn:000054C0 ; char * __cdecl std::addressof<char>(char &)
.text$mn:000054C0                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000054C0 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000054C0                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000054C0                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000054C0
.text$mn:000054C0 arg_0           = dword ptr  8
.text$mn:000054C0
.text$mn:000054C0                 push    ebp
.text$mn:000054C1                 mov     ebp, esp
.text$mn:000054C3                 mov     eax, [ebp+arg_0]
.text$mn:000054C6                 pop     ebp
.text$mn:000054C7                 retn
.text$mn:000054C7 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000054C7
.text$mn:000054C7 _text$mn        ends
.text$mn:000054C7
.text$mn:000054C8 ; ===========================================================================
.text$mn:000054C8
.text$mn:000054C8 ; Segment type: Pure code
.text$mn:000054C8 ; Segment permissions: Read/Execute
.text$mn:000054C8 _text$mn        segment para public 'CODE' use32
.text$mn:000054C8                 assume cs:_text$mn
.text$mn:000054C8                 ;org 54C8h
.text$mn:000054C8 ; COMDAT (pick any)
.text$mn:000054C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054C8
.text$mn:000054C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000054C8
.text$mn:000054C8 ; Attributes: bp-based frame
.text$mn:000054C8
.text$mn:000054C8 ; struct MenuItemUnit * __cdecl std::addressof<struct MenuItemUnit>(struct MenuItemUnit &)
.text$mn:000054C8                 public ??$addressof@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@AAU1@@Z
.text$mn:000054C8 ??$addressof@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@AAU1@@Z proc near
.text$mn:000054C8                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+Dp
.text$mn:000054C8                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+2Dp
.text$mn:000054C8
.text$mn:000054C8 arg_0           = dword ptr  8
.text$mn:000054C8
.text$mn:000054C8                 push    ebp
.text$mn:000054C9                 mov     ebp, esp
.text$mn:000054CB                 mov     eax, [ebp+arg_0]
.text$mn:000054CE                 pop     ebp
.text$mn:000054CF                 retn
.text$mn:000054CF ??$addressof@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@AAU1@@Z endp
.text$mn:000054CF
.text$mn:000054CF _text$mn        ends
.text$mn:000054CF
.text$mn:000054D0 ; ===========================================================================
.text$mn:000054D0
.text$mn:000054D0 ; Segment type: Pure code
.text$mn:000054D0 ; Segment permissions: Read/Execute
.text$mn:000054D0 _text$mn        segment para public 'CODE' use32
.text$mn:000054D0                 assume cs:_text$mn
.text$mn:000054D0                 ;org 54D0h
.text$mn:000054D0 ; COMDAT (pick any)
.text$mn:000054D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054D0
.text$mn:000054D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054D0
.text$mn:000054D0 ; Attributes: bp-based frame
.text$mn:000054D0
.text$mn:000054D0 ; struct recordedMacroStep * __cdecl std::addressof<struct recordedMacroStep>(struct recordedMacroStep &)
.text$mn:000054D0                 public ??$addressof@UrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@AAU1@@Z
.text$mn:000054D0 ??$addressof@UrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@AAU1@@Z proc near
.text$mn:000054D0                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::push_back(recordedMacroStep &&)+Dp
.text$mn:000054D0                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::push_back(recordedMacroStep &&)+2Dp
.text$mn:000054D0
.text$mn:000054D0 arg_0           = dword ptr  8
.text$mn:000054D0
.text$mn:000054D0                 push    ebp
.text$mn:000054D1                 mov     ebp, esp
.text$mn:000054D3                 mov     eax, [ebp+arg_0]
.text$mn:000054D6                 pop     ebp
.text$mn:000054D7                 retn
.text$mn:000054D7 ??$addressof@UrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@AAU1@@Z endp
.text$mn:000054D7
.text$mn:000054D7 _text$mn        ends
.text$mn:000054D7
.text$mn:000054D8 ; ===========================================================================
.text$mn:000054D8
.text$mn:000054D8 ; Segment type: Pure code
.text$mn:000054D8 ; Segment permissions: Read/Execute
.text$mn:000054D8 _text$mn        segment para public 'CODE' use32
.text$mn:000054D8                 assume cs:_text$mn
.text$mn:000054D8                 ;org 54D8h
.text$mn:000054D8 ; COMDAT (pick any)
.text$mn:000054D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054D8
.text$mn:000054D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000054D8
.text$mn:000054D8 ; Attributes: bp-based frame
.text$mn:000054D8
.text$mn:000054D8 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:000054D8                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:000054D8 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:000054D8                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:000054D8                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:000054D8
.text$mn:000054D8 arg_0           = dword ptr  8
.text$mn:000054D8
.text$mn:000054D8                 push    ebp
.text$mn:000054D9                 mov     ebp, esp
.text$mn:000054DB                 mov     eax, [ebp+arg_0]
.text$mn:000054DE                 pop     ebp
.text$mn:000054DF                 retn
.text$mn:000054DF ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:000054DF
.text$mn:000054DF _text$mn        ends
.text$mn:000054DF
.text$mn:000054E0 ; ===========================================================================
.text$mn:000054E0
.text$mn:000054E0 ; Segment type: Pure code
.text$mn:000054E0 ; Segment permissions: Read/Execute
.text$mn:000054E0 _text$mn        segment para public 'CODE' use32
.text$mn:000054E0                 assume cs:_text$mn
.text$mn:000054E0                 ;org 54E0h
.text$mn:000054E0 ; COMDAT (pick any)
.text$mn:000054E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000054E0
.text$mn:000054E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054E0
.text$mn:000054E0 ; Attributes: bp-based frame
.text$mn:000054E0
.text$mn:000054E0 ; int __stdcall std::_Wrap_alloc<std::allocator<unsigned int>>::construct<unsigned int,unsigned int const &>(void *, int)
.text$mn:000054E0                 public ??$construct@IABI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAIABI@Z
.text$mn:000054E0 ??$construct@IABI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAIABI@Z proc near
.text$mn:000054E0                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::push_back(uint const &)+DEp
.text$mn:000054E0
.text$mn:000054E0 var_4           = dword ptr -4
.text$mn:000054E0 arg_0           = dword ptr  8
.text$mn:000054E0 arg_4           = dword ptr  0Ch
.text$mn:000054E0
.text$mn:000054E0                 push    ebp
.text$mn:000054E1                 mov     ebp, esp
.text$mn:000054E3                 push    ecx
.text$mn:000054E4                 mov     [ebp+var_4], ecx
.text$mn:000054E7                 mov     eax, [ebp+arg_4]
.text$mn:000054EA                 push    eax
.text$mn:000054EB                 call    ??$forward@ABI@std@@YAABIABI@Z ; std::forward<uint const &>(uint const &)
.text$mn:000054F0                 add     esp, 4
.text$mn:000054F3                 push    eax             ; int
.text$mn:000054F4                 mov     ecx, [ebp+arg_0]
.text$mn:000054F7                 push    ecx             ; void *
.text$mn:000054F8                 mov     edx, [ebp+var_4]
.text$mn:000054FB                 push    edx             ; int
.text$mn:000054FC                 call    ??$construct@IABI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAIABI@Z ; std::allocator_traits<std::allocator<uint>>::construct<uint,uint const &>(std::allocator<uint> &,uint *,uint const &)
.text$mn:00005501                 add     esp, 0Ch
.text$mn:00005504                 mov     esp, ebp
.text$mn:00005506                 pop     ebp
.text$mn:00005507                 retn    8
.text$mn:00005507 ??$construct@IABI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAIABI@Z endp
.text$mn:00005507
.text$mn:00005507 ; ---------------------------------------------------------------------------
.text$mn:0000550A                 align 4
.text$mn:0000550A _text$mn        ends
.text$mn:0000550A
.text$mn:0000550C ; ===========================================================================
.text$mn:0000550C
.text$mn:0000550C ; Segment type: Pure code
.text$mn:0000550C ; Segment permissions: Read/Execute
.text$mn:0000550C _text$mn        segment para public 'CODE' use32
.text$mn:0000550C                 assume cs:_text$mn
.text$mn:0000550C                 ;org 550Ch
.text$mn:0000550C ; COMDAT (pick any)
.text$mn:0000550C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000550C
.text$mn:0000550C ; =============== S U B R O U T I N E =======================================
.text$mn:0000550C
.text$mn:0000550C ; Attributes: bp-based frame
.text$mn:0000550C
.text$mn:0000550C ; int __cdecl std::allocator_traits<std::allocator<unsigned int>>::construct<unsigned int,unsigned int const &>(int, void *, int)
.text$mn:0000550C                 public ??$construct@IABI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAIABI@Z
.text$mn:0000550C ??$construct@IABI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAIABI@Z proc near
.text$mn:0000550C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::construct<uint,uint const &>(uint *,uint const &)+1Cp
.text$mn:0000550C
.text$mn:0000550C arg_0           = dword ptr  8
.text$mn:0000550C arg_4           = dword ptr  0Ch
.text$mn:0000550C arg_8           = dword ptr  10h
.text$mn:0000550C
.text$mn:0000550C                 push    ebp
.text$mn:0000550D                 mov     ebp, esp
.text$mn:0000550F                 mov     eax, [ebp+arg_8]
.text$mn:00005512                 push    eax
.text$mn:00005513                 call    ??$forward@ABI@std@@YAABIABI@Z ; std::forward<uint const &>(uint const &)
.text$mn:00005518                 add     esp, 4
.text$mn:0000551B                 push    eax             ; int
.text$mn:0000551C                 mov     ecx, [ebp+arg_4]
.text$mn:0000551F                 push    ecx             ; void *
.text$mn:00005520                 mov     ecx, [ebp+arg_0]
.text$mn:00005523                 call    ?construct@?$allocator@I@std@@QAEXPAIABI@Z ; std::allocator<uint>::construct(uint *,uint const &)
.text$mn:00005528                 pop     ebp
.text$mn:00005529                 retn
.text$mn:00005529 ??$construct@IABI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAIABI@Z endp
.text$mn:00005529
.text$mn:00005529 ; ---------------------------------------------------------------------------
.text$mn:0000552A                 align 4
.text$mn:0000552A _text$mn        ends
.text$mn:0000552A
.text$mn:0000552C ; ===========================================================================
.text$mn:0000552C
.text$mn:0000552C ; Segment type: Pure code
.text$mn:0000552C ; Segment permissions: Read/Execute
.text$mn:0000552C _text$mn        segment para public 'CODE' use32
.text$mn:0000552C                 assume cs:_text$mn
.text$mn:0000552C                 ;org 552Ch
.text$mn:0000552C ; COMDAT (pick any)
.text$mn:0000552C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000552C
.text$mn:0000552C ; =============== S U B R O U T I N E =======================================
.text$mn:0000552C
.text$mn:0000552C ; Attributes: bp-based frame
.text$mn:0000552C
.text$mn:0000552C ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:0000552C                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:0000552C ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:0000552C                                         ; CODE XREF: $LN19+4Bp
.text$mn:0000552C
.text$mn:0000552C var_4           = dword ptr -4
.text$mn:0000552C arg_0           = dword ptr  8
.text$mn:0000552C arg_4           = dword ptr  0Ch
.text$mn:0000552C
.text$mn:0000552C                 push    ebp
.text$mn:0000552D                 mov     ebp, esp
.text$mn:0000552F                 push    ecx
.text$mn:00005530                 mov     [ebp+var_4], ecx
.text$mn:00005533                 mov     eax, [ebp+arg_4]
.text$mn:00005536                 push    eax
.text$mn:00005537                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000553C                 add     esp, 4
.text$mn:0000553F                 push    eax             ; int
.text$mn:00005540                 mov     ecx, [ebp+arg_0]
.text$mn:00005543                 push    ecx             ; void *
.text$mn:00005544                 mov     edx, [ebp+var_4]
.text$mn:00005547                 push    edx             ; int
.text$mn:00005548                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:0000554D                 add     esp, 0Ch
.text$mn:00005550                 mov     esp, ebp
.text$mn:00005552                 pop     ebp
.text$mn:00005553                 retn    8
.text$mn:00005553 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00005553
.text$mn:00005553 ; ---------------------------------------------------------------------------
.text$mn:00005556                 align 4
.text$mn:00005556 _text$mn        ends
.text$mn:00005556
.text$mn:00005558 ; ===========================================================================
.text$mn:00005558
.text$mn:00005558 ; Segment type: Pure code
.text$mn:00005558 ; Segment permissions: Read/Execute
.text$mn:00005558 _text$mn        segment para public 'CODE' use32
.text$mn:00005558                 assume cs:_text$mn
.text$mn:00005558                 ;org 5558h
.text$mn:00005558 ; COMDAT (pick any)
.text$mn:00005558                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005558
.text$mn:00005558 ; =============== S U B R O U T I N E =======================================
.text$mn:00005558
.text$mn:00005558 ; Attributes: bp-based frame
.text$mn:00005558
.text$mn:00005558 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00005558                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00005558 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00005558                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00005558
.text$mn:00005558 var_1C          = dword ptr -1Ch
.text$mn:00005558 var_18          = dword ptr -18h
.text$mn:00005558 var_14          = dword ptr -14h
.text$mn:00005558 var_10          = dword ptr -10h
.text$mn:00005558 var_C           = dword ptr -0Ch
.text$mn:00005558 var_4           = dword ptr -4
.text$mn:00005558 arg_0           = dword ptr  8
.text$mn:00005558 arg_4           = dword ptr  0Ch
.text$mn:00005558
.text$mn:00005558                 push    ebp
.text$mn:00005559                 mov     ebp, esp
.text$mn:0000555B                 push    0FFFFFFFFh
.text$mn:0000555D                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00005562                 mov     eax, large fs:0
.text$mn:00005568                 push    eax
.text$mn:00005569                 sub     esp, 10h
.text$mn:0000556C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005571                 xor     eax, ebp
.text$mn:00005573                 push    eax
.text$mn:00005574                 lea     eax, [ebp+var_C]
.text$mn:00005577                 mov     large fs:0, eax
.text$mn:0000557D                 mov     [ebp+var_18], ecx
.text$mn:00005580                 mov     eax, [ebp+arg_0]
.text$mn:00005583                 push    eax             ; void *
.text$mn:00005584                 push    4               ; unsigned int
.text$mn:00005586                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000558B                 add     esp, 8
.text$mn:0000558E                 mov     [ebp+var_10], eax
.text$mn:00005591                 mov     [ebp+var_4], 0
.text$mn:00005598                 cmp     [ebp+var_10], 0
.text$mn:0000559C                 jz      short loc_55B9
.text$mn:0000559E                 mov     ecx, [ebp+arg_4]
.text$mn:000055A1                 push    ecx
.text$mn:000055A2                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000055A7                 add     esp, 4
.text$mn:000055AA                 mov     edx, [ebp+var_10]
.text$mn:000055AD                 mov     eax, [eax]
.text$mn:000055AF                 mov     [edx], eax
.text$mn:000055B1                 mov     ecx, [ebp+var_10]
.text$mn:000055B4                 mov     [ebp+var_14], ecx
.text$mn:000055B7                 jmp     short loc_55C0
.text$mn:000055B9 ; ---------------------------------------------------------------------------
.text$mn:000055B9
.text$mn:000055B9 loc_55B9:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000055B9                 mov     [ebp+var_14], 0
.text$mn:000055C0
.text$mn:000055C0 loc_55C0:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000055C0                 mov     edx, [ebp+var_14]
.text$mn:000055C3                 mov     [ebp+var_1C], edx
.text$mn:000055C6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000055CD                 mov     ecx, [ebp+var_C]
.text$mn:000055D0                 mov     large fs:0, ecx
.text$mn:000055D7                 pop     ecx
.text$mn:000055D8                 mov     esp, ebp
.text$mn:000055DA                 pop     ebp
.text$mn:000055DB                 retn    8
.text$mn:000055DB ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000055DB
.text$mn:000055DB ; ---------------------------------------------------------------------------
.text$mn:000055DE                 align 10h
.text$mn:000055DE _text$mn        ends
.text$mn:000055DE
.text$x:000055E0 ; ===========================================================================
.text$x:000055E0
.text$x:000055E0 ; Segment type: Pure code
.text$x:000055E0 ; Segment permissions: Read/Execute
.text$x:000055E0 _text$x         segment para public 'CODE' use32
.text$x:000055E0                 assume cs:_text$x
.text$x:000055E0                 ;org 55E0h
.text$x:000055E0 ; COMDAT (pick associative to section at 5558)
.text$x:000055E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000055E0
.text$x:000055E0 ; =============== S U B R O U T I N E =======================================
.text$x:000055E0
.text$x:000055E0
.text$x:000055E0 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000055E0                                         ; DATA XREF: .xdata$x:0000C22Co
.text$x:000055E0                 mov     eax, [ebp+8]
.text$x:000055E3                 push    eax
.text$x:000055E4                 mov     eax, [ebp-10h]
.text$x:000055E7                 push    eax             ; void *
.text$x:000055E8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000055ED                 add     esp, 8
.text$x:000055F0                 retn
.text$x:000055F0 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000055F0
.text$x:000055F1
.text$x:000055F1 ; =============== S U B R O U T I N E =======================================
.text$x:000055F1
.text$x:000055F1
.text$x:000055F1 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000055F1                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000055F1
.text$x:000055F1 arg_4           = dword ptr  8
.text$x:000055F1
.text$x:000055F1                 mov     edx, [esp+arg_4]
.text$x:000055F5                 lea     eax, [edx+0Ch]
.text$x:000055F8                 mov     ecx, [edx-14h]
.text$x:000055FB                 xor     ecx, eax
.text$x:000055FD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005602                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00005607                 jmp     ___CxxFrameHandler3
.text$x:00005607 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00005607
.text$x:00005607 _text$x         ends
.text$x:00005607
.text$mn:0000560C ; ===========================================================================
.text$mn:0000560C
.text$mn:0000560C ; Segment type: Pure code
.text$mn:0000560C ; Segment permissions: Read/Execute
.text$mn:0000560C _text$mn        segment para public 'CODE' use32
.text$mn:0000560C                 assume cs:_text$mn
.text$mn:0000560C                 ;org 560Ch
.text$mn:0000560C ; COMDAT (pick any)
.text$mn:0000560C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000560C
.text$mn:0000560C ; =============== S U B R O U T I N E =======================================
.text$mn:0000560C
.text$mn:0000560C ; Attributes: bp-based frame
.text$mn:0000560C
.text$mn:0000560C ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:0000560C                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:0000560C ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:0000560C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:0000560C
.text$mn:0000560C arg_0           = dword ptr  8
.text$mn:0000560C arg_4           = dword ptr  0Ch
.text$mn:0000560C arg_8           = dword ptr  10h
.text$mn:0000560C
.text$mn:0000560C                 push    ebp
.text$mn:0000560D                 mov     ebp, esp
.text$mn:0000560F                 mov     eax, [ebp+arg_8]
.text$mn:00005612                 push    eax
.text$mn:00005613                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00005618                 add     esp, 4
.text$mn:0000561B                 push    eax             ; int
.text$mn:0000561C                 mov     ecx, [ebp+arg_4]
.text$mn:0000561F                 push    ecx             ; void *
.text$mn:00005620                 mov     ecx, [ebp+arg_0]
.text$mn:00005623                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00005628                 pop     ebp
.text$mn:00005629                 retn
.text$mn:00005629 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00005629
.text$mn:00005629 ; ---------------------------------------------------------------------------
.text$mn:0000562A                 align 4
.text$mn:0000562A _text$mn        ends
.text$mn:0000562A
.text$mn:0000562C ; ===========================================================================
.text$mn:0000562C
.text$mn:0000562C ; Segment type: Pure code
.text$mn:0000562C ; Segment permissions: Read/Execute
.text$mn:0000562C _text$mn        segment para public 'CODE' use32
.text$mn:0000562C                 assume cs:_text$mn
.text$mn:0000562C                 ;org 562Ch
.text$mn:0000562C ; COMDAT (pick any)
.text$mn:0000562C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000562C
.text$mn:0000562C ; =============== S U B R O U T I N E =======================================
.text$mn:0000562C
.text$mn:0000562C ; Attributes: bp-based frame
.text$mn:0000562C
.text$mn:0000562C ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:0000562C                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:0000562C ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:0000562C                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:0000562C
.text$mn:0000562C var_4           = dword ptr -4
.text$mn:0000562C arg_0           = dword ptr  8
.text$mn:0000562C arg_4           = dword ptr  0Ch
.text$mn:0000562C
.text$mn:0000562C                 push    ebp
.text$mn:0000562D                 mov     ebp, esp
.text$mn:0000562F                 push    ecx
.text$mn:00005630                 mov     [ebp+var_4], ecx
.text$mn:00005633                 mov     eax, [ebp+arg_4]
.text$mn:00005636                 push    eax
.text$mn:00005637                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:0000563C                 add     esp, 4
.text$mn:0000563F                 push    eax             ; int
.text$mn:00005640                 mov     ecx, [ebp+arg_0]
.text$mn:00005643                 push    ecx             ; void *
.text$mn:00005644                 mov     edx, [ebp+var_4]
.text$mn:00005647                 push    edx             ; int
.text$mn:00005648                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:0000564D                 add     esp, 0Ch
.text$mn:00005650                 mov     esp, ebp
.text$mn:00005652                 pop     ebp
.text$mn:00005653                 retn    8
.text$mn:00005653 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00005653
.text$mn:00005653 ; ---------------------------------------------------------------------------
.text$mn:00005656                 align 4
.text$mn:00005656 _text$mn        ends
.text$mn:00005656
.text$mn:00005658 ; ===========================================================================
.text$mn:00005658
.text$mn:00005658 ; Segment type: Pure code
.text$mn:00005658 ; Segment permissions: Read/Execute
.text$mn:00005658 _text$mn        segment para public 'CODE' use32
.text$mn:00005658                 assume cs:_text$mn
.text$mn:00005658                 ;org 5658h
.text$mn:00005658 ; COMDAT (pick any)
.text$mn:00005658                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005658
.text$mn:00005658 ; =============== S U B R O U T I N E =======================================
.text$mn:00005658
.text$mn:00005658 ; Attributes: bp-based frame
.text$mn:00005658
.text$mn:00005658 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00005658                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00005658 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00005658                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:00005658
.text$mn:00005658 var_1C          = dword ptr -1Ch
.text$mn:00005658 var_18          = dword ptr -18h
.text$mn:00005658 var_14          = dword ptr -14h
.text$mn:00005658 var_10          = dword ptr -10h
.text$mn:00005658 var_C           = dword ptr -0Ch
.text$mn:00005658 var_4           = dword ptr -4
.text$mn:00005658 arg_0           = dword ptr  8
.text$mn:00005658 arg_4           = dword ptr  0Ch
.text$mn:00005658
.text$mn:00005658                 push    ebp
.text$mn:00005659                 mov     ebp, esp
.text$mn:0000565B                 push    0FFFFFFFFh
.text$mn:0000565D                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00005662                 mov     eax, large fs:0
.text$mn:00005668                 push    eax
.text$mn:00005669                 sub     esp, 10h
.text$mn:0000566C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005671                 xor     eax, ebp
.text$mn:00005673                 push    eax
.text$mn:00005674                 lea     eax, [ebp+var_C]
.text$mn:00005677                 mov     large fs:0, eax
.text$mn:0000567D                 mov     [ebp+var_18], ecx
.text$mn:00005680                 mov     eax, [ebp+arg_0]
.text$mn:00005683                 push    eax             ; void *
.text$mn:00005684                 push    4               ; unsigned int
.text$mn:00005686                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000568B                 add     esp, 8
.text$mn:0000568E                 mov     [ebp+var_10], eax
.text$mn:00005691                 mov     [ebp+var_4], 0
.text$mn:00005698                 cmp     [ebp+var_10], 0
.text$mn:0000569C                 jz      short loc_56B9
.text$mn:0000569E                 mov     ecx, [ebp+arg_4]
.text$mn:000056A1                 push    ecx
.text$mn:000056A2                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000056A7                 add     esp, 4
.text$mn:000056AA                 mov     edx, [ebp+var_10]
.text$mn:000056AD                 mov     eax, [eax]
.text$mn:000056AF                 mov     [edx], eax
.text$mn:000056B1                 mov     ecx, [ebp+var_10]
.text$mn:000056B4                 mov     [ebp+var_14], ecx
.text$mn:000056B7                 jmp     short loc_56C0
.text$mn:000056B9 ; ---------------------------------------------------------------------------
.text$mn:000056B9
.text$mn:000056B9 loc_56B9:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:000056B9                 mov     [ebp+var_14], 0
.text$mn:000056C0
.text$mn:000056C0 loc_56C0:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:000056C0                 mov     edx, [ebp+var_14]
.text$mn:000056C3                 mov     [ebp+var_1C], edx
.text$mn:000056C6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000056CD                 mov     ecx, [ebp+var_C]
.text$mn:000056D0                 mov     large fs:0, ecx
.text$mn:000056D7                 pop     ecx
.text$mn:000056D8                 mov     esp, ebp
.text$mn:000056DA                 pop     ebp
.text$mn:000056DB                 retn    8
.text$mn:000056DB ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:000056DB
.text$mn:000056DB ; ---------------------------------------------------------------------------
.text$mn:000056DE                 align 10h
.text$mn:000056DE _text$mn        ends
.text$mn:000056DE
.text$x:000056E0 ; ===========================================================================
.text$x:000056E0
.text$x:000056E0 ; Segment type: Pure code
.text$x:000056E0 ; Segment permissions: Read/Execute
.text$x:000056E0 _text$x         segment para public 'CODE' use32
.text$x:000056E0                 assume cs:_text$x
.text$x:000056E0                 ;org 56E0h
.text$x:000056E0 ; COMDAT (pick associative to section at 5658)
.text$x:000056E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000056E0
.text$x:000056E0 ; =============== S U B R O U T I N E =======================================
.text$x:000056E0
.text$x:000056E0
.text$x:000056E0 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:000056E0                                         ; DATA XREF: .xdata$x:0000C258o
.text$x:000056E0                 mov     eax, [ebp+8]
.text$x:000056E3                 push    eax
.text$x:000056E4                 mov     eax, [ebp-10h]
.text$x:000056E7                 push    eax             ; void *
.text$x:000056E8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000056ED                 add     esp, 8
.text$x:000056F0                 retn
.text$x:000056F0 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:000056F0
.text$x:000056F1
.text$x:000056F1 ; =============== S U B R O U T I N E =======================================
.text$x:000056F1
.text$x:000056F1
.text$x:000056F1 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:000056F1                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:000056F1
.text$x:000056F1 arg_4           = dword ptr  8
.text$x:000056F1
.text$x:000056F1                 mov     edx, [esp+arg_4]
.text$x:000056F5                 lea     eax, [edx+0Ch]
.text$x:000056F8                 mov     ecx, [edx-14h]
.text$x:000056FB                 xor     ecx, eax
.text$x:000056FD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005702                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:00005707                 jmp     ___CxxFrameHandler3
.text$x:00005707 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:00005707
.text$x:00005707 _text$x         ends
.text$x:00005707
.text$mn:0000570C ; ===========================================================================
.text$mn:0000570C
.text$mn:0000570C ; Segment type: Pure code
.text$mn:0000570C ; Segment permissions: Read/Execute
.text$mn:0000570C _text$mn        segment para public 'CODE' use32
.text$mn:0000570C                 assume cs:_text$mn
.text$mn:0000570C                 ;org 570Ch
.text$mn:0000570C ; COMDAT (pick any)
.text$mn:0000570C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000570C
.text$mn:0000570C ; =============== S U B R O U T I N E =======================================
.text$mn:0000570C
.text$mn:0000570C ; Attributes: bp-based frame
.text$mn:0000570C
.text$mn:0000570C ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:0000570C                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:0000570C ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:0000570C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:0000570C
.text$mn:0000570C arg_0           = dword ptr  8
.text$mn:0000570C arg_4           = dword ptr  0Ch
.text$mn:0000570C arg_8           = dword ptr  10h
.text$mn:0000570C
.text$mn:0000570C                 push    ebp
.text$mn:0000570D                 mov     ebp, esp
.text$mn:0000570F                 mov     eax, [ebp+arg_8]
.text$mn:00005712                 push    eax
.text$mn:00005713                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00005718                 add     esp, 4
.text$mn:0000571B                 push    eax             ; int
.text$mn:0000571C                 mov     ecx, [ebp+arg_4]
.text$mn:0000571F                 push    ecx             ; void *
.text$mn:00005720                 mov     ecx, [ebp+arg_0]
.text$mn:00005723                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00005728                 pop     ebp
.text$mn:00005729                 retn
.text$mn:00005729 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:00005729
.text$mn:00005729 ; ---------------------------------------------------------------------------
.text$mn:0000572A                 align 4
.text$mn:0000572A _text$mn        ends
.text$mn:0000572A
.text$mn:0000572C ; ===========================================================================
.text$mn:0000572C
.text$mn:0000572C ; Segment type: Pure code
.text$mn:0000572C ; Segment permissions: Read/Execute
.text$mn:0000572C _text$mn        segment para public 'CODE' use32
.text$mn:0000572C                 assume cs:_text$mn
.text$mn:0000572C                 ;org 572Ch
.text$mn:0000572C ; COMDAT (pick any)
.text$mn:0000572C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000572C
.text$mn:0000572C ; =============== S U B R O U T I N E =======================================
.text$mn:0000572C
.text$mn:0000572C ; Attributes: bp-based frame
.text$mn:0000572C
.text$mn:0000572C ; int __stdcall std::_Wrap_alloc<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(void *, int)
.text$mn:0000572C                 public ??$construct@UMenuItemUnit@@U1@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z
.text$mn:0000572C ??$construct@UMenuItemUnit@@U1@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z proc near
.text$mn:0000572C                                         ; CODE XREF: std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:0000572C                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+9Dp ...
.text$mn:0000572C
.text$mn:0000572C var_4           = dword ptr -4
.text$mn:0000572C arg_0           = dword ptr  8
.text$mn:0000572C arg_4           = dword ptr  0Ch
.text$mn:0000572C
.text$mn:0000572C                 push    ebp
.text$mn:0000572D                 mov     ebp, esp
.text$mn:0000572F                 push    ecx
.text$mn:00005730                 mov     [ebp+var_4], ecx
.text$mn:00005733                 mov     eax, [ebp+arg_4]
.text$mn:00005736                 push    eax
.text$mn:00005737                 call    ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z ; std::forward<MenuItemUnit>(MenuItemUnit &)
.text$mn:0000573C                 add     esp, 4
.text$mn:0000573F                 push    eax             ; int
.text$mn:00005740                 mov     ecx, [ebp+arg_0]
.text$mn:00005743                 push    ecx             ; void *
.text$mn:00005744                 mov     edx, [ebp+var_4]
.text$mn:00005747                 push    edx             ; int
.text$mn:00005748                 call    ??$construct@UMenuItemUnit@@U1@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@$$QAU3@@Z ; std::allocator_traits<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(std::allocator<MenuItemUnit> &,MenuItemUnit *,MenuItemUnit &&)
.text$mn:0000574D                 add     esp, 0Ch
.text$mn:00005750                 mov     esp, ebp
.text$mn:00005752                 pop     ebp
.text$mn:00005753                 retn    8
.text$mn:00005753 ??$construct@UMenuItemUnit@@U1@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z endp
.text$mn:00005753
.text$mn:00005753 ; ---------------------------------------------------------------------------
.text$mn:00005756                 align 4
.text$mn:00005756 _text$mn        ends
.text$mn:00005756
.text$mn:00005758 ; ===========================================================================
.text$mn:00005758
.text$mn:00005758 ; Segment type: Pure code
.text$mn:00005758 ; Segment permissions: Read/Execute
.text$mn:00005758 _text$mn        segment para public 'CODE' use32
.text$mn:00005758                 assume cs:_text$mn
.text$mn:00005758                 ;org 5758h
.text$mn:00005758 ; COMDAT (pick any)
.text$mn:00005758                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005758
.text$mn:00005758 ; =============== S U B R O U T I N E =======================================
.text$mn:00005758
.text$mn:00005758 ; Attributes: bp-based frame
.text$mn:00005758
.text$mn:00005758 ; int __stdcall std::allocator<MenuItemUnit>::construct<MenuItemUnit,MenuItemUnit>(void *, int)
.text$mn:00005758                 public ??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z
.text$mn:00005758 ??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z proc near
.text$mn:00005758                                         ; CODE XREF: std::allocator_traits<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(std::allocator<MenuItemUnit> &,MenuItemUnit *,MenuItemUnit &&)+17p
.text$mn:00005758
.text$mn:00005758 var_1C          = dword ptr -1Ch
.text$mn:00005758 var_18          = dword ptr -18h
.text$mn:00005758 var_14          = dword ptr -14h
.text$mn:00005758 var_10          = dword ptr -10h
.text$mn:00005758 var_C           = dword ptr -0Ch
.text$mn:00005758 var_4           = dword ptr -4
.text$mn:00005758 arg_0           = dword ptr  8
.text$mn:00005758 arg_4           = dword ptr  0Ch
.text$mn:00005758
.text$mn:00005758                 push    ebp
.text$mn:00005759                 mov     ebp, esp
.text$mn:0000575B                 push    0FFFFFFFFh
.text$mn:0000575D                 push    offset __ehhandler$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z
.text$mn:00005762                 mov     eax, large fs:0
.text$mn:00005768                 push    eax
.text$mn:00005769                 sub     esp, 10h
.text$mn:0000576C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005771                 xor     eax, ebp
.text$mn:00005773                 push    eax
.text$mn:00005774                 lea     eax, [ebp+var_C]
.text$mn:00005777                 mov     large fs:0, eax
.text$mn:0000577D                 mov     [ebp+var_18], ecx
.text$mn:00005780                 mov     eax, [ebp+arg_0]
.text$mn:00005783                 push    eax             ; void *
.text$mn:00005784                 push    3Ch ; '<'       ; unsigned int
.text$mn:00005786                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000578B                 add     esp, 8
.text$mn:0000578E                 mov     [ebp+var_10], eax
.text$mn:00005791                 mov     [ebp+var_4], 0
.text$mn:00005798                 cmp     [ebp+var_10], 0
.text$mn:0000579C                 jz      short loc_57B8
.text$mn:0000579E                 mov     ecx, [ebp+arg_4]
.text$mn:000057A1                 push    ecx
.text$mn:000057A2                 call    ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z ; std::forward<MenuItemUnit>(MenuItemUnit &)
.text$mn:000057A7                 add     esp, 4
.text$mn:000057AA                 push    eax
.text$mn:000057AB                 mov     ecx, [ebp+var_10]
.text$mn:000057AE                 call    ??0MenuItemUnit@@QAE@ABU0@@Z ; MenuItemUnit::MenuItemUnit(MenuItemUnit const &)
.text$mn:000057B3                 mov     [ebp+var_14], eax
.text$mn:000057B6                 jmp     short loc_57BF
.text$mn:000057B8 ; ---------------------------------------------------------------------------
.text$mn:000057B8
.text$mn:000057B8 loc_57B8:                               ; CODE XREF: std::allocator<MenuItemUnit>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)+44j
.text$mn:000057B8                 mov     [ebp+var_14], 0
.text$mn:000057BF
.text$mn:000057BF loc_57BF:                               ; CODE XREF: std::allocator<MenuItemUnit>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)+5Ej
.text$mn:000057BF                 mov     edx, [ebp+var_14]
.text$mn:000057C2                 mov     [ebp+var_1C], edx
.text$mn:000057C5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000057CC                 mov     ecx, [ebp+var_C]
.text$mn:000057CF                 mov     large fs:0, ecx
.text$mn:000057D6                 pop     ecx
.text$mn:000057D7                 mov     esp, ebp
.text$mn:000057D9                 pop     ebp
.text$mn:000057DA                 retn    8
.text$mn:000057DA ??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z endp
.text$mn:000057DA
.text$mn:000057DA ; ---------------------------------------------------------------------------
.text$mn:000057DD                 align 10h
.text$mn:000057DD _text$mn        ends
.text$mn:000057DD
.text$x:000057E0 ; ===========================================================================
.text$x:000057E0
.text$x:000057E0 ; Segment type: Pure code
.text$x:000057E0 ; Segment permissions: Read/Execute
.text$x:000057E0 _text$x         segment para public 'CODE' use32
.text$x:000057E0                 assume cs:_text$x
.text$x:000057E0                 ;org 57E0h
.text$x:000057E0 ; COMDAT (pick associative to section at 5758)
.text$x:000057E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000057E0
.text$x:000057E0 ; =============== S U B R O U T I N E =======================================
.text$x:000057E0
.text$x:000057E0
.text$x:000057E0 __unwindfunclet$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z$0 proc near
.text$x:000057E0                                         ; DATA XREF: .xdata$x:0000C200o
.text$x:000057E0                 mov     eax, [ebp+8]
.text$x:000057E3                 push    eax
.text$x:000057E4                 mov     eax, [ebp-10h]
.text$x:000057E7                 push    eax             ; void *
.text$x:000057E8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000057ED                 add     esp, 8
.text$x:000057F0                 retn
.text$x:000057F0 __unwindfunclet$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z$0 endp
.text$x:000057F0
.text$x:000057F1
.text$x:000057F1 ; =============== S U B R O U T I N E =======================================
.text$x:000057F1
.text$x:000057F1
.text$x:000057F1 __ehhandler$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z proc near
.text$x:000057F1                                         ; DATA XREF: std::allocator<MenuItemUnit>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)+5o
.text$x:000057F1
.text$x:000057F1 arg_4           = dword ptr  8
.text$x:000057F1
.text$x:000057F1                 mov     edx, [esp+arg_4]
.text$x:000057F5                 lea     eax, [edx+0Ch]
.text$x:000057F8                 mov     ecx, [edx-14h]
.text$x:000057FB                 xor     ecx, eax
.text$x:000057FD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005802                 mov     eax, offset __ehfuncinfo$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z
.text$x:00005807                 jmp     ___CxxFrameHandler3
.text$x:00005807 __ehhandler$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z endp
.text$x:00005807
.text$x:00005807 _text$x         ends
.text$x:00005807
.text$mn:0000580C ; ===========================================================================
.text$mn:0000580C
.text$mn:0000580C ; Segment type: Pure code
.text$mn:0000580C ; Segment permissions: Read/Execute
.text$mn:0000580C _text$mn        segment para public 'CODE' use32
.text$mn:0000580C                 assume cs:_text$mn
.text$mn:0000580C                 ;org 580Ch
.text$mn:0000580C ; COMDAT (pick any)
.text$mn:0000580C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000580C
.text$mn:0000580C ; =============== S U B R O U T I N E =======================================
.text$mn:0000580C
.text$mn:0000580C ; Attributes: bp-based frame
.text$mn:0000580C
.text$mn:0000580C ; int __cdecl std::allocator_traits<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(int, void *, int)
.text$mn:0000580C                 public ??$construct@UMenuItemUnit@@U1@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@$$QAU3@@Z
.text$mn:0000580C ??$construct@UMenuItemUnit@@U1@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@$$QAU3@@Z proc near
.text$mn:0000580C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)+1Cp
.text$mn:0000580C
.text$mn:0000580C arg_0           = dword ptr  8
.text$mn:0000580C arg_4           = dword ptr  0Ch
.text$mn:0000580C arg_8           = dword ptr  10h
.text$mn:0000580C
.text$mn:0000580C                 push    ebp
.text$mn:0000580D                 mov     ebp, esp
.text$mn:0000580F                 mov     eax, [ebp+arg_8]
.text$mn:00005812                 push    eax
.text$mn:00005813                 call    ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z ; std::forward<MenuItemUnit>(MenuItemUnit &)
.text$mn:00005818                 add     esp, 4
.text$mn:0000581B                 push    eax             ; int
.text$mn:0000581C                 mov     ecx, [ebp+arg_4]
.text$mn:0000581F                 push    ecx             ; void *
.text$mn:00005820                 mov     ecx, [ebp+arg_0]
.text$mn:00005823                 call    ??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z ; std::allocator<MenuItemUnit>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)
.text$mn:00005828                 pop     ebp
.text$mn:00005829                 retn
.text$mn:00005829 ??$construct@UMenuItemUnit@@U1@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@$$QAU3@@Z endp
.text$mn:00005829
.text$mn:00005829 ; ---------------------------------------------------------------------------
.text$mn:0000582A                 align 4
.text$mn:0000582A _text$mn        ends
.text$mn:0000582A
.text$mn:0000582C ; ===========================================================================
.text$mn:0000582C
.text$mn:0000582C ; Segment type: Pure code
.text$mn:0000582C ; Segment permissions: Read/Execute
.text$mn:0000582C _text$mn        segment para public 'CODE' use32
.text$mn:0000582C                 assume cs:_text$mn
.text$mn:0000582C                 ;org 582Ch
.text$mn:0000582C ; COMDAT (pick any)
.text$mn:0000582C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000582C
.text$mn:0000582C ; =============== S U B R O U T I N E =======================================
.text$mn:0000582C
.text$mn:0000582C ; Attributes: bp-based frame
.text$mn:0000582C
.text$mn:0000582C ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:0000582C                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000582C ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:0000582C                                         ; CODE XREF: std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Alloc_proxy(void)+32p
.text$mn:0000582C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Alloc_proxy(void)+32p
.text$mn:0000582C
.text$mn:0000582C var_4           = dword ptr -4
.text$mn:0000582C arg_0           = dword ptr  8
.text$mn:0000582C arg_4           = dword ptr  0Ch
.text$mn:0000582C
.text$mn:0000582C                 push    ebp
.text$mn:0000582D                 mov     ebp, esp
.text$mn:0000582F                 push    ecx
.text$mn:00005830                 mov     [ebp+var_4], ecx
.text$mn:00005833                 mov     eax, [ebp+arg_4]
.text$mn:00005836                 push    eax
.text$mn:00005837                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000583C                 add     esp, 4
.text$mn:0000583F                 push    eax             ; int
.text$mn:00005840                 mov     ecx, [ebp+arg_0]
.text$mn:00005843                 push    ecx             ; void *
.text$mn:00005844                 mov     edx, [ebp+var_4]
.text$mn:00005847                 push    edx             ; int
.text$mn:00005848                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000584D                 add     esp, 0Ch
.text$mn:00005850                 mov     esp, ebp
.text$mn:00005852                 pop     ebp
.text$mn:00005853                 retn    8
.text$mn:00005853 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00005853
.text$mn:00005853 ; ---------------------------------------------------------------------------
.text$mn:00005856                 align 4
.text$mn:00005856 _text$mn        ends
.text$mn:00005856
.text$mn:00005858 ; ===========================================================================
.text$mn:00005858
.text$mn:00005858 ; Segment type: Pure code
.text$mn:00005858 ; Segment permissions: Read/Execute
.text$mn:00005858 _text$mn        segment para public 'CODE' use32
.text$mn:00005858                 assume cs:_text$mn
.text$mn:00005858                 ;org 5858h
.text$mn:00005858 ; COMDAT (pick any)
.text$mn:00005858                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005858
.text$mn:00005858 ; =============== S U B R O U T I N E =======================================
.text$mn:00005858
.text$mn:00005858 ; Attributes: bp-based frame
.text$mn:00005858
.text$mn:00005858 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00005858                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00005858 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00005858                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:00005858                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p ...
.text$mn:00005858
.text$mn:00005858 var_1C          = dword ptr -1Ch
.text$mn:00005858 var_18          = dword ptr -18h
.text$mn:00005858 var_14          = dword ptr -14h
.text$mn:00005858 var_10          = dword ptr -10h
.text$mn:00005858 var_C           = dword ptr -0Ch
.text$mn:00005858 var_4           = dword ptr -4
.text$mn:00005858 arg_0           = dword ptr  8
.text$mn:00005858 arg_4           = dword ptr  0Ch
.text$mn:00005858
.text$mn:00005858                 push    ebp
.text$mn:00005859                 mov     ebp, esp
.text$mn:0000585B                 push    0FFFFFFFFh
.text$mn:0000585D                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00005862                 mov     eax, large fs:0
.text$mn:00005868                 push    eax
.text$mn:00005869                 sub     esp, 10h
.text$mn:0000586C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005871                 xor     eax, ebp
.text$mn:00005873                 push    eax
.text$mn:00005874                 lea     eax, [ebp+var_C]
.text$mn:00005877                 mov     large fs:0, eax
.text$mn:0000587D                 mov     [ebp+var_18], ecx
.text$mn:00005880                 mov     eax, [ebp+arg_0]
.text$mn:00005883                 push    eax             ; void *
.text$mn:00005884                 push    8               ; unsigned int
.text$mn:00005886                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000588B                 add     esp, 8
.text$mn:0000588E                 mov     [ebp+var_10], eax
.text$mn:00005891                 mov     [ebp+var_4], 0
.text$mn:00005898                 cmp     [ebp+var_10], 0
.text$mn:0000589C                 jz      short loc_58BF
.text$mn:0000589E                 mov     ecx, [ebp+arg_4]
.text$mn:000058A1                 push    ecx
.text$mn:000058A2                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000058A7                 add     esp, 4
.text$mn:000058AA                 mov     edx, [eax]
.text$mn:000058AC                 mov     eax, [eax+4]
.text$mn:000058AF                 mov     ecx, [ebp+var_10]
.text$mn:000058B2                 mov     [ecx], edx
.text$mn:000058B4                 mov     [ecx+4], eax
.text$mn:000058B7                 mov     edx, [ebp+var_10]
.text$mn:000058BA                 mov     [ebp+var_14], edx
.text$mn:000058BD                 jmp     short loc_58C6
.text$mn:000058BF ; ---------------------------------------------------------------------------
.text$mn:000058BF
.text$mn:000058BF loc_58BF:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:000058BF                 mov     [ebp+var_14], 0
.text$mn:000058C6
.text$mn:000058C6 loc_58C6:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:000058C6                 mov     eax, [ebp+var_14]
.text$mn:000058C9                 mov     [ebp+var_1C], eax
.text$mn:000058CC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000058D3                 mov     ecx, [ebp+var_C]
.text$mn:000058D6                 mov     large fs:0, ecx
.text$mn:000058DD                 pop     ecx
.text$mn:000058DE                 mov     esp, ebp
.text$mn:000058E0                 pop     ebp
.text$mn:000058E1                 retn    8
.text$mn:000058E1 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000058E1
.text$mn:000058E1 _text$mn        ends
.text$mn:000058E1
.text$x:000058E4 ; ===========================================================================
.text$x:000058E4
.text$x:000058E4 ; Segment type: Pure code
.text$x:000058E4 ; Segment permissions: Read/Execute
.text$x:000058E4 _text$x         segment para public 'CODE' use32
.text$x:000058E4                 assume cs:_text$x
.text$x:000058E4                 ;org 58E4h
.text$x:000058E4 ; COMDAT (pick associative to section at 5858)
.text$x:000058E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000058E4
.text$x:000058E4 ; =============== S U B R O U T I N E =======================================
.text$x:000058E4
.text$x:000058E4
.text$x:000058E4 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000058E4                                         ; DATA XREF: .xdata$x:0000C1A8o
.text$x:000058E4                 mov     eax, [ebp+8]
.text$x:000058E7                 push    eax
.text$x:000058E8                 mov     eax, [ebp-10h]
.text$x:000058EB                 push    eax             ; void *
.text$x:000058EC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000058F1                 add     esp, 8
.text$x:000058F4                 retn
.text$x:000058F4 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:000058F4
.text$x:000058F5
.text$x:000058F5 ; =============== S U B R O U T I N E =======================================
.text$x:000058F5
.text$x:000058F5
.text$x:000058F5 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:000058F5                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:000058F5
.text$x:000058F5 arg_4           = dword ptr  8
.text$x:000058F5
.text$x:000058F5                 mov     edx, [esp+arg_4]
.text$x:000058F9                 lea     eax, [edx+0Ch]
.text$x:000058FC                 mov     ecx, [edx-14h]
.text$x:000058FF                 xor     ecx, eax
.text$x:00005901                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005906                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:0000590B                 jmp     ___CxxFrameHandler3
.text$x:0000590B __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:0000590B
.text$x:0000590B _text$x         ends
.text$x:0000590B
.text$mn:00005910 ; ===========================================================================
.text$mn:00005910
.text$mn:00005910 ; Segment type: Pure code
.text$mn:00005910 ; Segment permissions: Read/Execute
.text$mn:00005910 _text$mn        segment para public 'CODE' use32
.text$mn:00005910                 assume cs:_text$mn
.text$mn:00005910                 ;org 5910h
.text$mn:00005910 ; COMDAT (pick any)
.text$mn:00005910                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005910
.text$mn:00005910 ; =============== S U B R O U T I N E =======================================
.text$mn:00005910
.text$mn:00005910 ; Attributes: bp-based frame
.text$mn:00005910
.text$mn:00005910 ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00005910                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00005910 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00005910                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00005910
.text$mn:00005910 arg_0           = dword ptr  8
.text$mn:00005910 arg_4           = dword ptr  0Ch
.text$mn:00005910 arg_8           = dword ptr  10h
.text$mn:00005910
.text$mn:00005910                 push    ebp
.text$mn:00005911                 mov     ebp, esp
.text$mn:00005913                 mov     eax, [ebp+arg_8]
.text$mn:00005916                 push    eax
.text$mn:00005917                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000591C                 add     esp, 4
.text$mn:0000591F                 push    eax             ; int
.text$mn:00005920                 mov     ecx, [ebp+arg_4]
.text$mn:00005923                 push    ecx             ; void *
.text$mn:00005924                 mov     ecx, [ebp+arg_0]
.text$mn:00005927                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:0000592C                 pop     ebp
.text$mn:0000592D                 retn
.text$mn:0000592D ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:0000592D
.text$mn:0000592D ; ---------------------------------------------------------------------------
.text$mn:0000592E                 align 10h
.text$mn:0000592E _text$mn        ends
.text$mn:0000592E
.text$mn:00005930 ; ===========================================================================
.text$mn:00005930
.text$mn:00005930 ; Segment type: Pure code
.text$mn:00005930 ; Segment permissions: Read/Execute
.text$mn:00005930 _text$mn        segment para public 'CODE' use32
.text$mn:00005930                 assume cs:_text$mn
.text$mn:00005930                 ;org 5930h
.text$mn:00005930 ; COMDAT (pick any)
.text$mn:00005930                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005930
.text$mn:00005930 ; =============== S U B R O U T I N E =======================================
.text$mn:00005930
.text$mn:00005930 ; Attributes: bp-based frame
.text$mn:00005930
.text$mn:00005930 ; int __stdcall std::_Wrap_alloc<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep>(void *, int)
.text$mn:00005930                 public ??$construct@UrecordedMacroStep@@U1@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z
.text$mn:00005930 ??$construct@UrecordedMacroStep@@U1@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z proc near
.text$mn:00005930                                         ; CODE XREF: std::_Uninit_move<recordedMacroStep *,recordedMacroStep *,std::allocator<recordedMacroStep>,recordedMacroStep>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,recordedMacroStep *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:00005930                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::push_back(recordedMacroStep &&)+9Dp ...
.text$mn:00005930
.text$mn:00005930 var_4           = dword ptr -4
.text$mn:00005930 arg_0           = dword ptr  8
.text$mn:00005930 arg_4           = dword ptr  0Ch
.text$mn:00005930
.text$mn:00005930                 push    ebp
.text$mn:00005931                 mov     ebp, esp
.text$mn:00005933                 push    ecx
.text$mn:00005934                 mov     [ebp+var_4], ecx
.text$mn:00005937                 mov     eax, [ebp+arg_4]
.text$mn:0000593A                 push    eax
.text$mn:0000593B                 call    ??$forward@UrecordedMacroStep@@@std@@YA$$QAUrecordedMacroStep@@AAU1@@Z ; std::forward<recordedMacroStep>(recordedMacroStep &)
.text$mn:00005940                 add     esp, 4
.text$mn:00005943                 push    eax             ; int
.text$mn:00005944                 mov     ecx, [ebp+arg_0]
.text$mn:00005947                 push    ecx             ; void *
.text$mn:00005948                 mov     edx, [ebp+var_4]
.text$mn:0000594B                 push    edx             ; int
.text$mn:0000594C                 call    ??$construct@UrecordedMacroStep@@U1@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@$$QAU3@@Z ; std::allocator_traits<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep>(std::allocator<recordedMacroStep> &,recordedMacroStep *,recordedMacroStep &&)
.text$mn:00005951                 add     esp, 0Ch
.text$mn:00005954                 mov     esp, ebp
.text$mn:00005956                 pop     ebp
.text$mn:00005957                 retn    8
.text$mn:00005957 ??$construct@UrecordedMacroStep@@U1@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z endp
.text$mn:00005957
.text$mn:00005957 ; ---------------------------------------------------------------------------
.text$mn:0000595A                 align 4
.text$mn:0000595A _text$mn        ends
.text$mn:0000595A
.text$mn:0000595C ; ===========================================================================
.text$mn:0000595C
.text$mn:0000595C ; Segment type: Pure code
.text$mn:0000595C ; Segment permissions: Read/Execute
.text$mn:0000595C _text$mn        segment para public 'CODE' use32
.text$mn:0000595C                 assume cs:_text$mn
.text$mn:0000595C                 ;org 595Ch
.text$mn:0000595C ; COMDAT (pick any)
.text$mn:0000595C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000595C
.text$mn:0000595C ; =============== S U B R O U T I N E =======================================
.text$mn:0000595C
.text$mn:0000595C ; Attributes: bp-based frame
.text$mn:0000595C
.text$mn:0000595C ; int __stdcall std::allocator<recordedMacroStep>::construct<recordedMacroStep,recordedMacroStep>(void *, int)
.text$mn:0000595C                 public ??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z
.text$mn:0000595C ??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z proc near
.text$mn:0000595C                                         ; CODE XREF: std::allocator_traits<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep>(std::allocator<recordedMacroStep> &,recordedMacroStep *,recordedMacroStep &&)+17p
.text$mn:0000595C
.text$mn:0000595C var_1C          = dword ptr -1Ch
.text$mn:0000595C var_18          = dword ptr -18h
.text$mn:0000595C var_14          = dword ptr -14h
.text$mn:0000595C var_10          = dword ptr -10h
.text$mn:0000595C var_C           = dword ptr -0Ch
.text$mn:0000595C var_4           = dword ptr -4
.text$mn:0000595C arg_0           = dword ptr  8
.text$mn:0000595C arg_4           = dword ptr  0Ch
.text$mn:0000595C
.text$mn:0000595C                 push    ebp
.text$mn:0000595D                 mov     ebp, esp
.text$mn:0000595F                 push    0FFFFFFFFh
.text$mn:00005961                 push    offset __ehhandler$??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z
.text$mn:00005966                 mov     eax, large fs:0
.text$mn:0000596C                 push    eax
.text$mn:0000596D                 sub     esp, 10h
.text$mn:00005970                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005975                 xor     eax, ebp
.text$mn:00005977                 push    eax
.text$mn:00005978                 lea     eax, [ebp+var_C]
.text$mn:0000597B                 mov     large fs:0, eax
.text$mn:00005981                 mov     [ebp+var_18], ecx
.text$mn:00005984                 mov     eax, [ebp+arg_0]
.text$mn:00005987                 push    eax             ; void *
.text$mn:00005988                 push    2Ch ; ','       ; unsigned int
.text$mn:0000598A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000598F                 add     esp, 8
.text$mn:00005992                 mov     [ebp+var_10], eax
.text$mn:00005995                 mov     [ebp+var_4], 0
.text$mn:0000599C                 cmp     [ebp+var_10], 0
.text$mn:000059A0                 jz      short loc_59BC
.text$mn:000059A2                 mov     ecx, [ebp+arg_4]
.text$mn:000059A5                 push    ecx
.text$mn:000059A6                 call    ??$forward@UrecordedMacroStep@@@std@@YA$$QAUrecordedMacroStep@@AAU1@@Z ; std::forward<recordedMacroStep>(recordedMacroStep &)
.text$mn:000059AB                 add     esp, 4
.text$mn:000059AE                 push    eax
.text$mn:000059AF                 mov     ecx, [ebp+var_10]
.text$mn:000059B2                 call    ??0recordedMacroStep@@QAE@ABU0@@Z ; recordedMacroStep::recordedMacroStep(recordedMacroStep const &)
.text$mn:000059B7                 mov     [ebp+var_14], eax
.text$mn:000059BA                 jmp     short loc_59C3
.text$mn:000059BC ; ---------------------------------------------------------------------------
.text$mn:000059BC
.text$mn:000059BC loc_59BC:                               ; CODE XREF: std::allocator<recordedMacroStep>::construct<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep &&)+44j
.text$mn:000059BC                 mov     [ebp+var_14], 0
.text$mn:000059C3
.text$mn:000059C3 loc_59C3:                               ; CODE XREF: std::allocator<recordedMacroStep>::construct<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep &&)+5Ej
.text$mn:000059C3                 mov     edx, [ebp+var_14]
.text$mn:000059C6                 mov     [ebp+var_1C], edx
.text$mn:000059C9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000059D0                 mov     ecx, [ebp+var_C]
.text$mn:000059D3                 mov     large fs:0, ecx
.text$mn:000059DA                 pop     ecx
.text$mn:000059DB                 mov     esp, ebp
.text$mn:000059DD                 pop     ebp
.text$mn:000059DE                 retn    8
.text$mn:000059DE ??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z endp
.text$mn:000059DE
.text$mn:000059DE ; ---------------------------------------------------------------------------
.text$mn:000059E1                 align 4
.text$mn:000059E1 _text$mn        ends
.text$mn:000059E1
.text$x:000059E4 ; ===========================================================================
.text$x:000059E4
.text$x:000059E4 ; Segment type: Pure code
.text$x:000059E4 ; Segment permissions: Read/Execute
.text$x:000059E4 _text$x         segment para public 'CODE' use32
.text$x:000059E4                 assume cs:_text$x
.text$x:000059E4                 ;org 59E4h
.text$x:000059E4 ; COMDAT (pick associative to section at 595C)
.text$x:000059E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000059E4
.text$x:000059E4 ; =============== S U B R O U T I N E =======================================
.text$x:000059E4
.text$x:000059E4
.text$x:000059E4 __unwindfunclet$??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z$0 proc near
.text$x:000059E4                                         ; DATA XREF: .xdata$x:0000C1D4o
.text$x:000059E4                 mov     eax, [ebp+8]
.text$x:000059E7                 push    eax
.text$x:000059E8                 mov     eax, [ebp-10h]
.text$x:000059EB                 push    eax             ; void *
.text$x:000059EC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000059F1                 add     esp, 8
.text$x:000059F4                 retn
.text$x:000059F4 __unwindfunclet$??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z$0 endp
.text$x:000059F4
.text$x:000059F5
.text$x:000059F5 ; =============== S U B R O U T I N E =======================================
.text$x:000059F5
.text$x:000059F5
.text$x:000059F5 __ehhandler$??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z proc near
.text$x:000059F5                                         ; DATA XREF: std::allocator<recordedMacroStep>::construct<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep &&)+5o
.text$x:000059F5
.text$x:000059F5 arg_4           = dword ptr  8
.text$x:000059F5
.text$x:000059F5                 mov     edx, [esp+arg_4]
.text$x:000059F9                 lea     eax, [edx+0Ch]
.text$x:000059FC                 mov     ecx, [edx-14h]
.text$x:000059FF                 xor     ecx, eax
.text$x:00005A01                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005A06                 mov     eax, offset __ehfuncinfo$??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z
.text$x:00005A0B                 jmp     ___CxxFrameHandler3
.text$x:00005A0B __ehhandler$??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z endp
.text$x:00005A0B
.text$x:00005A0B _text$x         ends
.text$x:00005A0B
.text$mn:00005A10 ; ===========================================================================
.text$mn:00005A10
.text$mn:00005A10 ; Segment type: Pure code
.text$mn:00005A10 ; Segment permissions: Read/Execute
.text$mn:00005A10 _text$mn        segment para public 'CODE' use32
.text$mn:00005A10                 assume cs:_text$mn
.text$mn:00005A10                 ;org 5A10h
.text$mn:00005A10 ; COMDAT (pick any)
.text$mn:00005A10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A10
.text$mn:00005A10 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A10
.text$mn:00005A10 ; Attributes: bp-based frame
.text$mn:00005A10
.text$mn:00005A10 ; int __cdecl std::allocator_traits<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep>(int, void *, int)
.text$mn:00005A10                 public ??$construct@UrecordedMacroStep@@U1@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@$$QAU3@@Z
.text$mn:00005A10 ??$construct@UrecordedMacroStep@@U1@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@$$QAU3@@Z proc near
.text$mn:00005A10                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep &&)+1Cp
.text$mn:00005A10
.text$mn:00005A10 arg_0           = dword ptr  8
.text$mn:00005A10 arg_4           = dword ptr  0Ch
.text$mn:00005A10 arg_8           = dword ptr  10h
.text$mn:00005A10
.text$mn:00005A10                 push    ebp
.text$mn:00005A11                 mov     ebp, esp
.text$mn:00005A13                 mov     eax, [ebp+arg_8]
.text$mn:00005A16                 push    eax
.text$mn:00005A17                 call    ??$forward@UrecordedMacroStep@@@std@@YA$$QAUrecordedMacroStep@@AAU1@@Z ; std::forward<recordedMacroStep>(recordedMacroStep &)
.text$mn:00005A1C                 add     esp, 4
.text$mn:00005A1F                 push    eax             ; int
.text$mn:00005A20                 mov     ecx, [ebp+arg_4]
.text$mn:00005A23                 push    ecx             ; void *
.text$mn:00005A24                 mov     ecx, [ebp+arg_0]
.text$mn:00005A27                 call    ??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z ; std::allocator<recordedMacroStep>::construct<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep &&)
.text$mn:00005A2C                 pop     ebp
.text$mn:00005A2D                 retn
.text$mn:00005A2D ??$construct@UrecordedMacroStep@@U1@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@$$QAU3@@Z endp
.text$mn:00005A2D
.text$mn:00005A2D ; ---------------------------------------------------------------------------
.text$mn:00005A2E                 align 10h
.text$mn:00005A2E _text$mn        ends
.text$mn:00005A2E
.text$mn:00005A30 ; ===========================================================================
.text$mn:00005A30
.text$mn:00005A30 ; Segment type: Pure code
.text$mn:00005A30 ; Segment permissions: Read/Execute
.text$mn:00005A30 _text$mn        segment para public 'CODE' use32
.text$mn:00005A30                 assume cs:_text$mn
.text$mn:00005A30                 ;org 5A30h
.text$mn:00005A30 ; COMDAT (pick any)
.text$mn:00005A30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A30
.text$mn:00005A30 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A30
.text$mn:00005A30 ; Attributes: bp-based frame
.text$mn:00005A30
.text$mn:00005A30 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned int>>::destroy<unsigned int>(unsigned int *)
.text$mn:00005A30                 public ??$destroy@I@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAI@Z
.text$mn:00005A30 ??$destroy@I@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAI@Z proc near
.text$mn:00005A30                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::pop_back(void)+8Dp
.text$mn:00005A30
.text$mn:00005A30 var_4           = dword ptr -4
.text$mn:00005A30 arg_0           = dword ptr  8
.text$mn:00005A30
.text$mn:00005A30                 push    ebp
.text$mn:00005A31                 mov     ebp, esp
.text$mn:00005A33                 push    ecx
.text$mn:00005A34                 mov     [ebp+var_4], ecx
.text$mn:00005A37                 mov     eax, [ebp+arg_0]
.text$mn:00005A3A                 push    eax
.text$mn:00005A3B                 mov     ecx, [ebp+var_4]
.text$mn:00005A3E                 push    ecx
.text$mn:00005A3F                 call    ??$destroy@I@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAI@Z ; std::allocator_traits<std::allocator<uint>>::destroy<uint>(std::allocator<uint> &,uint *)
.text$mn:00005A44                 add     esp, 8
.text$mn:00005A47                 mov     esp, ebp
.text$mn:00005A49                 pop     ebp
.text$mn:00005A4A                 retn    4
.text$mn:00005A4A ??$destroy@I@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAI@Z endp
.text$mn:00005A4A
.text$mn:00005A4A ; ---------------------------------------------------------------------------
.text$mn:00005A4D                 align 10h
.text$mn:00005A4D _text$mn        ends
.text$mn:00005A4D
.text$mn:00005A50 ; ===========================================================================
.text$mn:00005A50
.text$mn:00005A50 ; Segment type: Pure code
.text$mn:00005A50 ; Segment permissions: Read/Execute
.text$mn:00005A50 _text$mn        segment para public 'CODE' use32
.text$mn:00005A50                 assume cs:_text$mn
.text$mn:00005A50                 ;org 5A50h
.text$mn:00005A50 ; COMDAT (pick any)
.text$mn:00005A50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A50
.text$mn:00005A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A50
.text$mn:00005A50 ; Attributes: bp-based frame
.text$mn:00005A50
.text$mn:00005A50 ; public: void __thiscall std::allocator<unsigned int>::destroy<unsigned int>(unsigned int *)
.text$mn:00005A50                 public ??$destroy@I@?$allocator@I@std@@QAEXPAI@Z
.text$mn:00005A50 ??$destroy@I@?$allocator@I@std@@QAEXPAI@Z proc near
.text$mn:00005A50                                         ; CODE XREF: std::allocator_traits<std::allocator<uint>>::destroy<uint>(std::allocator<uint> &,uint *)+Ap
.text$mn:00005A50
.text$mn:00005A50 var_4           = dword ptr -4
.text$mn:00005A50
.text$mn:00005A50                 push    ebp
.text$mn:00005A51                 mov     ebp, esp
.text$mn:00005A53                 push    ecx
.text$mn:00005A54                 mov     [ebp+var_4], ecx
.text$mn:00005A57                 mov     esp, ebp
.text$mn:00005A59                 pop     ebp
.text$mn:00005A5A                 retn    4
.text$mn:00005A5A ??$destroy@I@?$allocator@I@std@@QAEXPAI@Z endp
.text$mn:00005A5A
.text$mn:00005A5A ; ---------------------------------------------------------------------------
.text$mn:00005A5D                 align 10h
.text$mn:00005A5D _text$mn        ends
.text$mn:00005A5D
.text$mn:00005A60 ; ===========================================================================
.text$mn:00005A60
.text$mn:00005A60 ; Segment type: Pure code
.text$mn:00005A60 ; Segment permissions: Read/Execute
.text$mn:00005A60 _text$mn        segment para public 'CODE' use32
.text$mn:00005A60                 assume cs:_text$mn
.text$mn:00005A60                 ;org 5A60h
.text$mn:00005A60 ; COMDAT (pick any)
.text$mn:00005A60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A60
.text$mn:00005A60 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A60
.text$mn:00005A60 ; Attributes: bp-based frame
.text$mn:00005A60
.text$mn:00005A60 ; public: static void __cdecl std::allocator_traits<class std::allocator<unsigned int>>::destroy<unsigned int>(class std::allocator<unsigned int> &, unsigned int *)
.text$mn:00005A60                 public ??$destroy@I@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAI@Z
.text$mn:00005A60 ??$destroy@I@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAI@Z proc near
.text$mn:00005A60                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::destroy<uint>(uint *)+Fp
.text$mn:00005A60
.text$mn:00005A60 arg_0           = dword ptr  8
.text$mn:00005A60 arg_4           = dword ptr  0Ch
.text$mn:00005A60
.text$mn:00005A60                 push    ebp
.text$mn:00005A61                 mov     ebp, esp
.text$mn:00005A63                 mov     eax, [ebp+arg_4]
.text$mn:00005A66                 push    eax
.text$mn:00005A67                 mov     ecx, [ebp+arg_0]
.text$mn:00005A6A                 call    ??$destroy@I@?$allocator@I@std@@QAEXPAI@Z ; std::allocator<uint>::destroy<uint>(uint *)
.text$mn:00005A6F                 pop     ebp
.text$mn:00005A70                 retn
.text$mn:00005A70 ??$destroy@I@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAI@Z endp
.text$mn:00005A70
.text$mn:00005A70 ; ---------------------------------------------------------------------------
.text$mn:00005A71                 align 4
.text$mn:00005A71 _text$mn        ends
.text$mn:00005A71
.text$mn:00005A74 ; ===========================================================================
.text$mn:00005A74
.text$mn:00005A74 ; Segment type: Pure code
.text$mn:00005A74 ; Segment permissions: Read/Execute
.text$mn:00005A74 _text$mn        segment para public 'CODE' use32
.text$mn:00005A74                 assume cs:_text$mn
.text$mn:00005A74                 ;org 5A74h
.text$mn:00005A74 ; COMDAT (pick any)
.text$mn:00005A74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A74
.text$mn:00005A74 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A74
.text$mn:00005A74 ; Attributes: bp-based frame
.text$mn:00005A74
.text$mn:00005A74 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00005A74                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00005A74 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00005A74                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00005A74
.text$mn:00005A74 var_4           = dword ptr -4
.text$mn:00005A74 arg_0           = dword ptr  8
.text$mn:00005A74
.text$mn:00005A74                 push    ebp
.text$mn:00005A75                 mov     ebp, esp
.text$mn:00005A77                 push    ecx
.text$mn:00005A78                 mov     [ebp+var_4], ecx
.text$mn:00005A7B                 mov     eax, [ebp+arg_0]
.text$mn:00005A7E                 push    eax
.text$mn:00005A7F                 mov     ecx, [ebp+var_4]
.text$mn:00005A82                 push    ecx
.text$mn:00005A83                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00005A88                 add     esp, 8
.text$mn:00005A8B                 mov     esp, ebp
.text$mn:00005A8D                 pop     ebp
.text$mn:00005A8E                 retn    4
.text$mn:00005A8E ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00005A8E
.text$mn:00005A8E ; ---------------------------------------------------------------------------
.text$mn:00005A91                 align 4
.text$mn:00005A91 _text$mn        ends
.text$mn:00005A91
.text$mn:00005A94 ; ===========================================================================
.text$mn:00005A94
.text$mn:00005A94 ; Segment type: Pure code
.text$mn:00005A94 ; Segment permissions: Read/Execute
.text$mn:00005A94 _text$mn        segment para public 'CODE' use32
.text$mn:00005A94                 assume cs:_text$mn
.text$mn:00005A94                 ;org 5A94h
.text$mn:00005A94 ; COMDAT (pick any)
.text$mn:00005A94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005A94
.text$mn:00005A94 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A94
.text$mn:00005A94 ; Attributes: bp-based frame
.text$mn:00005A94
.text$mn:00005A94 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00005A94                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00005A94 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00005A94                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00005A94
.text$mn:00005A94 var_4           = dword ptr -4
.text$mn:00005A94
.text$mn:00005A94                 push    ebp
.text$mn:00005A95                 mov     ebp, esp
.text$mn:00005A97                 push    ecx
.text$mn:00005A98                 mov     [ebp+var_4], ecx
.text$mn:00005A9B                 mov     esp, ebp
.text$mn:00005A9D                 pop     ebp
.text$mn:00005A9E                 retn    4
.text$mn:00005A9E ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00005A9E
.text$mn:00005A9E ; ---------------------------------------------------------------------------
.text$mn:00005AA1                 align 4
.text$mn:00005AA1 _text$mn        ends
.text$mn:00005AA1
.text$mn:00005AA4 ; ===========================================================================
.text$mn:00005AA4
.text$mn:00005AA4 ; Segment type: Pure code
.text$mn:00005AA4 ; Segment permissions: Read/Execute
.text$mn:00005AA4 _text$mn        segment para public 'CODE' use32
.text$mn:00005AA4                 assume cs:_text$mn
.text$mn:00005AA4                 ;org 5AA4h
.text$mn:00005AA4 ; COMDAT (pick any)
.text$mn:00005AA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AA4
.text$mn:00005AA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AA4
.text$mn:00005AA4 ; Attributes: bp-based frame
.text$mn:00005AA4
.text$mn:00005AA4 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00005AA4                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00005AA4 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00005AA4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00005AA4
.text$mn:00005AA4 arg_0           = dword ptr  8
.text$mn:00005AA4 arg_4           = dword ptr  0Ch
.text$mn:00005AA4
.text$mn:00005AA4                 push    ebp
.text$mn:00005AA5                 mov     ebp, esp
.text$mn:00005AA7                 mov     eax, [ebp+arg_4]
.text$mn:00005AAA                 push    eax
.text$mn:00005AAB                 mov     ecx, [ebp+arg_0]
.text$mn:00005AAE                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00005AB3                 pop     ebp
.text$mn:00005AB4                 retn
.text$mn:00005AB4 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00005AB4
.text$mn:00005AB4 ; ---------------------------------------------------------------------------
.text$mn:00005AB5                 align 4
.text$mn:00005AB5 _text$mn        ends
.text$mn:00005AB5
.text$mn:00005AB8 ; ===========================================================================
.text$mn:00005AB8
.text$mn:00005AB8 ; Segment type: Pure code
.text$mn:00005AB8 ; Segment permissions: Read/Execute
.text$mn:00005AB8 _text$mn        segment para public 'CODE' use32
.text$mn:00005AB8                 assume cs:_text$mn
.text$mn:00005AB8                 ;org 5AB8h
.text$mn:00005AB8 ; COMDAT (pick any)
.text$mn:00005AB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AB8
.text$mn:00005AB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AB8
.text$mn:00005AB8 ; Attributes: bp-based frame
.text$mn:00005AB8
.text$mn:00005AB8 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned int>>::destroy<unsigned int *>(unsigned int * *)
.text$mn:00005AB8                 public ??$destroy@PAI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAPAI@Z
.text$mn:00005AB8 ??$destroy@PAI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAPAI@Z proc near
.text$mn:00005AB8                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Tidy(void)+9Bp
.text$mn:00005AB8
.text$mn:00005AB8 var_4           = dword ptr -4
.text$mn:00005AB8 arg_0           = dword ptr  8
.text$mn:00005AB8
.text$mn:00005AB8                 push    ebp
.text$mn:00005AB9                 mov     ebp, esp
.text$mn:00005ABB                 push    ecx
.text$mn:00005ABC                 mov     [ebp+var_4], ecx
.text$mn:00005ABF                 mov     eax, [ebp+arg_0]
.text$mn:00005AC2                 push    eax
.text$mn:00005AC3                 mov     ecx, [ebp+var_4]
.text$mn:00005AC6                 push    ecx
.text$mn:00005AC7                 call    ??$destroy@PAI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAPAI@Z ; std::allocator_traits<std::allocator<uint>>::destroy<uint *>(std::allocator<uint> &,uint * *)
.text$mn:00005ACC                 add     esp, 8
.text$mn:00005ACF                 mov     esp, ebp
.text$mn:00005AD1                 pop     ebp
.text$mn:00005AD2                 retn    4
.text$mn:00005AD2 ??$destroy@PAI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAPAI@Z endp
.text$mn:00005AD2
.text$mn:00005AD2 ; ---------------------------------------------------------------------------
.text$mn:00005AD5                 align 4
.text$mn:00005AD5 _text$mn        ends
.text$mn:00005AD5
.text$mn:00005AD8 ; ===========================================================================
.text$mn:00005AD8
.text$mn:00005AD8 ; Segment type: Pure code
.text$mn:00005AD8 ; Segment permissions: Read/Execute
.text$mn:00005AD8 _text$mn        segment para public 'CODE' use32
.text$mn:00005AD8                 assume cs:_text$mn
.text$mn:00005AD8                 ;org 5AD8h
.text$mn:00005AD8 ; COMDAT (pick any)
.text$mn:00005AD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AD8
.text$mn:00005AD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AD8
.text$mn:00005AD8 ; Attributes: bp-based frame
.text$mn:00005AD8
.text$mn:00005AD8 ; public: void __thiscall std::allocator<unsigned int>::destroy<unsigned int *>(unsigned int * *)
.text$mn:00005AD8                 public ??$destroy@PAI@?$allocator@I@std@@QAEXPAPAI@Z
.text$mn:00005AD8 ??$destroy@PAI@?$allocator@I@std@@QAEXPAPAI@Z proc near
.text$mn:00005AD8                                         ; CODE XREF: std::allocator_traits<std::allocator<uint>>::destroy<uint *>(std::allocator<uint> &,uint * *)+Ap
.text$mn:00005AD8
.text$mn:00005AD8 var_4           = dword ptr -4
.text$mn:00005AD8
.text$mn:00005AD8                 push    ebp
.text$mn:00005AD9                 mov     ebp, esp
.text$mn:00005ADB                 push    ecx
.text$mn:00005ADC                 mov     [ebp+var_4], ecx
.text$mn:00005ADF                 mov     esp, ebp
.text$mn:00005AE1                 pop     ebp
.text$mn:00005AE2                 retn    4
.text$mn:00005AE2 ??$destroy@PAI@?$allocator@I@std@@QAEXPAPAI@Z endp
.text$mn:00005AE2
.text$mn:00005AE2 ; ---------------------------------------------------------------------------
.text$mn:00005AE5                 align 4
.text$mn:00005AE5 _text$mn        ends
.text$mn:00005AE5
.text$mn:00005AE8 ; ===========================================================================
.text$mn:00005AE8
.text$mn:00005AE8 ; Segment type: Pure code
.text$mn:00005AE8 ; Segment permissions: Read/Execute
.text$mn:00005AE8 _text$mn        segment para public 'CODE' use32
.text$mn:00005AE8                 assume cs:_text$mn
.text$mn:00005AE8                 ;org 5AE8h
.text$mn:00005AE8 ; COMDAT (pick any)
.text$mn:00005AE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AE8
.text$mn:00005AE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AE8
.text$mn:00005AE8 ; Attributes: bp-based frame
.text$mn:00005AE8
.text$mn:00005AE8 ; public: static void __cdecl std::allocator_traits<class std::allocator<unsigned int>>::destroy<unsigned int *>(class std::allocator<unsigned int> &, unsigned int * *)
.text$mn:00005AE8                 public ??$destroy@PAI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAPAI@Z
.text$mn:00005AE8 ??$destroy@PAI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAPAI@Z proc near
.text$mn:00005AE8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::destroy<uint *>(uint * *)+Fp
.text$mn:00005AE8
.text$mn:00005AE8 arg_0           = dword ptr  8
.text$mn:00005AE8 arg_4           = dword ptr  0Ch
.text$mn:00005AE8
.text$mn:00005AE8                 push    ebp
.text$mn:00005AE9                 mov     ebp, esp
.text$mn:00005AEB                 mov     eax, [ebp+arg_4]
.text$mn:00005AEE                 push    eax
.text$mn:00005AEF                 mov     ecx, [ebp+arg_0]
.text$mn:00005AF2                 call    ??$destroy@PAI@?$allocator@I@std@@QAEXPAPAI@Z ; std::allocator<uint>::destroy<uint *>(uint * *)
.text$mn:00005AF7                 pop     ebp
.text$mn:00005AF8                 retn
.text$mn:00005AF8 ??$destroy@PAI@?$allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@PAPAI@Z endp
.text$mn:00005AF8
.text$mn:00005AF8 ; ---------------------------------------------------------------------------
.text$mn:00005AF9                 align 4
.text$mn:00005AF9 _text$mn        ends
.text$mn:00005AF9
.text$mn:00005AFC ; ===========================================================================
.text$mn:00005AFC
.text$mn:00005AFC ; Segment type: Pure code
.text$mn:00005AFC ; Segment permissions: Read/Execute
.text$mn:00005AFC _text$mn        segment para public 'CODE' use32
.text$mn:00005AFC                 assume cs:_text$mn
.text$mn:00005AFC                 ;org 5AFCh
.text$mn:00005AFC ; COMDAT (pick any)
.text$mn:00005AFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005AFC
.text$mn:00005AFC ; =============== S U B R O U T I N E =======================================
.text$mn:00005AFC
.text$mn:00005AFC ; Attributes: bp-based frame
.text$mn:00005AFC
.text$mn:00005AFC ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00005AFC                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00005AFC ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00005AFC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00005AFC
.text$mn:00005AFC var_4           = dword ptr -4
.text$mn:00005AFC arg_0           = dword ptr  8
.text$mn:00005AFC
.text$mn:00005AFC                 push    ebp
.text$mn:00005AFD                 mov     ebp, esp
.text$mn:00005AFF                 push    ecx
.text$mn:00005B00                 mov     [ebp+var_4], ecx
.text$mn:00005B03                 mov     eax, [ebp+arg_0]
.text$mn:00005B06                 push    eax
.text$mn:00005B07                 mov     ecx, [ebp+var_4]
.text$mn:00005B0A                 push    ecx
.text$mn:00005B0B                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00005B10                 add     esp, 8
.text$mn:00005B13                 mov     esp, ebp
.text$mn:00005B15                 pop     ebp
.text$mn:00005B16                 retn    4
.text$mn:00005B16 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00005B16
.text$mn:00005B16 ; ---------------------------------------------------------------------------
.text$mn:00005B19                 align 4
.text$mn:00005B19 _text$mn        ends
.text$mn:00005B19
.text$mn:00005B1C ; ===========================================================================
.text$mn:00005B1C
.text$mn:00005B1C ; Segment type: Pure code
.text$mn:00005B1C ; Segment permissions: Read/Execute
.text$mn:00005B1C _text$mn        segment para public 'CODE' use32
.text$mn:00005B1C                 assume cs:_text$mn
.text$mn:00005B1C                 ;org 5B1Ch
.text$mn:00005B1C ; COMDAT (pick any)
.text$mn:00005B1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B1C
.text$mn:00005B1C ; =============== S U B R O U T I N E =======================================
.text$mn:00005B1C
.text$mn:00005B1C ; Attributes: bp-based frame
.text$mn:00005B1C
.text$mn:00005B1C ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00005B1C                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00005B1C ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00005B1C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00005B1C
.text$mn:00005B1C var_4           = dword ptr -4
.text$mn:00005B1C
.text$mn:00005B1C                 push    ebp
.text$mn:00005B1D                 mov     ebp, esp
.text$mn:00005B1F                 push    ecx
.text$mn:00005B20                 mov     [ebp+var_4], ecx
.text$mn:00005B23                 mov     esp, ebp
.text$mn:00005B25                 pop     ebp
.text$mn:00005B26                 retn    4
.text$mn:00005B26 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00005B26
.text$mn:00005B26 ; ---------------------------------------------------------------------------
.text$mn:00005B29                 align 4
.text$mn:00005B29 _text$mn        ends
.text$mn:00005B29
.text$mn:00005B2C ; ===========================================================================
.text$mn:00005B2C
.text$mn:00005B2C ; Segment type: Pure code
.text$mn:00005B2C ; Segment permissions: Read/Execute
.text$mn:00005B2C _text$mn        segment para public 'CODE' use32
.text$mn:00005B2C                 assume cs:_text$mn
.text$mn:00005B2C                 ;org 5B2Ch
.text$mn:00005B2C ; COMDAT (pick any)
.text$mn:00005B2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B2C
.text$mn:00005B2C ; =============== S U B R O U T I N E =======================================
.text$mn:00005B2C
.text$mn:00005B2C ; Attributes: bp-based frame
.text$mn:00005B2C
.text$mn:00005B2C ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00005B2C                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00005B2C ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00005B2C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00005B2C
.text$mn:00005B2C arg_0           = dword ptr  8
.text$mn:00005B2C arg_4           = dword ptr  0Ch
.text$mn:00005B2C
.text$mn:00005B2C                 push    ebp
.text$mn:00005B2D                 mov     ebp, esp
.text$mn:00005B2F                 mov     eax, [ebp+arg_4]
.text$mn:00005B32                 push    eax
.text$mn:00005B33                 mov     ecx, [ebp+arg_0]
.text$mn:00005B36                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00005B3B                 pop     ebp
.text$mn:00005B3C                 retn
.text$mn:00005B3C ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00005B3C
.text$mn:00005B3C ; ---------------------------------------------------------------------------
.text$mn:00005B3D                 align 10h
.text$mn:00005B3D _text$mn        ends
.text$mn:00005B3D
.text$mn:00005B40 ; ===========================================================================
.text$mn:00005B40
.text$mn:00005B40 ; Segment type: Pure code
.text$mn:00005B40 ; Segment permissions: Read/Execute
.text$mn:00005B40 _text$mn        segment para public 'CODE' use32
.text$mn:00005B40                 assume cs:_text$mn
.text$mn:00005B40                 ;org 5B40h
.text$mn:00005B40 ; COMDAT (pick any)
.text$mn:00005B40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B40
.text$mn:00005B40 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B40
.text$mn:00005B40 ; Attributes: bp-based frame
.text$mn:00005B40
.text$mn:00005B40 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>::destroy<struct MenuItemUnit>(struct MenuItemUnit *)
.text$mn:00005B40                 public ??$destroy@UMenuItemUnit@@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@@Z
.text$mn:00005B40 ??$destroy@UMenuItemUnit@@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@@Z proc near
.text$mn:00005B40                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00005B40                                         ; __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:00005B40
.text$mn:00005B40 var_4           = dword ptr -4
.text$mn:00005B40 arg_0           = dword ptr  8
.text$mn:00005B40
.text$mn:00005B40                 push    ebp
.text$mn:00005B41                 mov     ebp, esp
.text$mn:00005B43                 push    ecx
.text$mn:00005B44                 mov     [ebp+var_4], ecx
.text$mn:00005B47                 mov     eax, [ebp+arg_0]
.text$mn:00005B4A                 push    eax
.text$mn:00005B4B                 mov     ecx, [ebp+var_4]
.text$mn:00005B4E                 push    ecx
.text$mn:00005B4F                 call    ??$destroy@UMenuItemUnit@@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@@Z ; std::allocator_traits<std::allocator<MenuItemUnit>>::destroy<MenuItemUnit>(std::allocator<MenuItemUnit> &,MenuItemUnit *)
.text$mn:00005B54                 add     esp, 8
.text$mn:00005B57                 mov     esp, ebp
.text$mn:00005B59                 pop     ebp
.text$mn:00005B5A                 retn    4
.text$mn:00005B5A ??$destroy@UMenuItemUnit@@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@@Z endp
.text$mn:00005B5A
.text$mn:00005B5A ; ---------------------------------------------------------------------------
.text$mn:00005B5D                 align 10h
.text$mn:00005B5D _text$mn        ends
.text$mn:00005B5D
.text$mn:00005B60 ; ===========================================================================
.text$mn:00005B60
.text$mn:00005B60 ; Segment type: Pure code
.text$mn:00005B60 ; Segment permissions: Read/Execute
.text$mn:00005B60 _text$mn        segment para public 'CODE' use32
.text$mn:00005B60                 assume cs:_text$mn
.text$mn:00005B60                 ;org 5B60h
.text$mn:00005B60 ; COMDAT (pick any)
.text$mn:00005B60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B60
.text$mn:00005B60 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B60
.text$mn:00005B60 ; Attributes: bp-based frame
.text$mn:00005B60
.text$mn:00005B60 ; public: void __thiscall std::allocator<struct MenuItemUnit>::destroy<struct MenuItemUnit>(struct MenuItemUnit *)
.text$mn:00005B60                 public ??$destroy@UMenuItemUnit@@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@@Z
.text$mn:00005B60 ??$destroy@UMenuItemUnit@@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@@Z proc near
.text$mn:00005B60                                         ; CODE XREF: std::allocator_traits<std::allocator<MenuItemUnit>>::destroy<MenuItemUnit>(std::allocator<MenuItemUnit> &,MenuItemUnit *)+Ap
.text$mn:00005B60
.text$mn:00005B60 var_4           = dword ptr -4
.text$mn:00005B60 arg_0           = dword ptr  8
.text$mn:00005B60
.text$mn:00005B60                 push    ebp
.text$mn:00005B61                 mov     ebp, esp
.text$mn:00005B63                 push    ecx
.text$mn:00005B64                 mov     [ebp+var_4], ecx
.text$mn:00005B67                 push    0
.text$mn:00005B69                 mov     ecx, [ebp+arg_0]
.text$mn:00005B6C                 call    ??_GMenuItemUnit@@QAEPAXI@Z ; MenuItemUnit::`scalar deleting destructor'(uint)
.text$mn:00005B71                 mov     esp, ebp
.text$mn:00005B73                 pop     ebp
.text$mn:00005B74                 retn    4
.text$mn:00005B74 ??$destroy@UMenuItemUnit@@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@@Z endp
.text$mn:00005B74
.text$mn:00005B74 ; ---------------------------------------------------------------------------
.text$mn:00005B77                 align 4
.text$mn:00005B77 _text$mn        ends
.text$mn:00005B77
.text$mn:00005B78 ; ===========================================================================
.text$mn:00005B78
.text$mn:00005B78 ; Segment type: Pure code
.text$mn:00005B78 ; Segment permissions: Read/Execute
.text$mn:00005B78 _text$mn        segment para public 'CODE' use32
.text$mn:00005B78                 assume cs:_text$mn
.text$mn:00005B78                 ;org 5B78h
.text$mn:00005B78 ; COMDAT (pick any)
.text$mn:00005B78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B78
.text$mn:00005B78 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B78
.text$mn:00005B78 ; Attributes: bp-based frame
.text$mn:00005B78
.text$mn:00005B78 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct MenuItemUnit>>::destroy<struct MenuItemUnit>(class std::allocator<struct MenuItemUnit> &, struct MenuItemUnit *)
.text$mn:00005B78                 public ??$destroy@UMenuItemUnit@@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@@Z
.text$mn:00005B78 ??$destroy@UMenuItemUnit@@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@@Z proc near
.text$mn:00005B78                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MenuItemUnit>>::destroy<MenuItemUnit>(MenuItemUnit *)+Fp
.text$mn:00005B78
.text$mn:00005B78 arg_0           = dword ptr  8
.text$mn:00005B78 arg_4           = dword ptr  0Ch
.text$mn:00005B78
.text$mn:00005B78                 push    ebp
.text$mn:00005B79                 mov     ebp, esp
.text$mn:00005B7B                 mov     eax, [ebp+arg_4]
.text$mn:00005B7E                 push    eax
.text$mn:00005B7F                 mov     ecx, [ebp+arg_0]
.text$mn:00005B82                 call    ??$destroy@UMenuItemUnit@@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@@Z ; std::allocator<MenuItemUnit>::destroy<MenuItemUnit>(MenuItemUnit *)
.text$mn:00005B87                 pop     ebp
.text$mn:00005B88                 retn
.text$mn:00005B88 ??$destroy@UMenuItemUnit@@@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAXAAV?$allocator@UMenuItemUnit@@@1@PAUMenuItemUnit@@@Z endp
.text$mn:00005B88
.text$mn:00005B88 ; ---------------------------------------------------------------------------
.text$mn:00005B89                 align 4
.text$mn:00005B89 _text$mn        ends
.text$mn:00005B89
.text$mn:00005B8C ; ===========================================================================
.text$mn:00005B8C
.text$mn:00005B8C ; Segment type: Pure code
.text$mn:00005B8C ; Segment permissions: Read/Execute
.text$mn:00005B8C _text$mn        segment para public 'CODE' use32
.text$mn:00005B8C                 assume cs:_text$mn
.text$mn:00005B8C                 ;org 5B8Ch
.text$mn:00005B8C ; COMDAT (pick any)
.text$mn:00005B8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005B8C
.text$mn:00005B8C ; =============== S U B R O U T I N E =======================================
.text$mn:00005B8C
.text$mn:00005B8C ; Attributes: bp-based frame
.text$mn:00005B8C
.text$mn:00005B8C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00005B8C                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00005B8C ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00005B8C                                         ; CODE XREF: std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Free_proxy(void)+22p
.text$mn:00005B8C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Free_proxy(void)+22p
.text$mn:00005B8C
.text$mn:00005B8C var_4           = dword ptr -4
.text$mn:00005B8C arg_0           = dword ptr  8
.text$mn:00005B8C
.text$mn:00005B8C                 push    ebp
.text$mn:00005B8D                 mov     ebp, esp
.text$mn:00005B8F                 push    ecx
.text$mn:00005B90                 mov     [ebp+var_4], ecx
.text$mn:00005B93                 mov     eax, [ebp+arg_0]
.text$mn:00005B96                 push    eax
.text$mn:00005B97                 mov     ecx, [ebp+var_4]
.text$mn:00005B9A                 push    ecx
.text$mn:00005B9B                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:00005BA0                 add     esp, 8
.text$mn:00005BA3                 mov     esp, ebp
.text$mn:00005BA5                 pop     ebp
.text$mn:00005BA6                 retn    4
.text$mn:00005BA6 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00005BA6
.text$mn:00005BA6 ; ---------------------------------------------------------------------------
.text$mn:00005BA9                 align 4
.text$mn:00005BA9 _text$mn        ends
.text$mn:00005BA9
.text$mn:00005BAC ; ===========================================================================
.text$mn:00005BAC
.text$mn:00005BAC ; Segment type: Pure code
.text$mn:00005BAC ; Segment permissions: Read/Execute
.text$mn:00005BAC _text$mn        segment para public 'CODE' use32
.text$mn:00005BAC                 assume cs:_text$mn
.text$mn:00005BAC                 ;org 5BACh
.text$mn:00005BAC ; COMDAT (pick any)
.text$mn:00005BAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005BAC
.text$mn:00005BAC ; =============== S U B R O U T I N E =======================================
.text$mn:00005BAC
.text$mn:00005BAC ; Attributes: bp-based frame
.text$mn:00005BAC
.text$mn:00005BAC ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00005BAC                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00005BAC ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00005BAC                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:00005BAC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p ...
.text$mn:00005BAC
.text$mn:00005BAC var_4           = dword ptr -4
.text$mn:00005BAC
.text$mn:00005BAC                 push    ebp
.text$mn:00005BAD                 mov     ebp, esp
.text$mn:00005BAF                 push    ecx
.text$mn:00005BB0                 mov     [ebp+var_4], ecx
.text$mn:00005BB3                 mov     esp, ebp
.text$mn:00005BB5                 pop     ebp
.text$mn:00005BB6                 retn    4
.text$mn:00005BB6 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00005BB6
.text$mn:00005BB6 ; ---------------------------------------------------------------------------
.text$mn:00005BB9                 align 4
.text$mn:00005BB9 _text$mn        ends
.text$mn:00005BB9
.text$mn:00005BBC ; ===========================================================================
.text$mn:00005BBC
.text$mn:00005BBC ; Segment type: Pure code
.text$mn:00005BBC ; Segment permissions: Read/Execute
.text$mn:00005BBC _text$mn        segment para public 'CODE' use32
.text$mn:00005BBC                 assume cs:_text$mn
.text$mn:00005BBC                 ;org 5BBCh
.text$mn:00005BBC ; COMDAT (pick any)
.text$mn:00005BBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005BBC
.text$mn:00005BBC ; =============== S U B R O U T I N E =======================================
.text$mn:00005BBC
.text$mn:00005BBC ; Attributes: bp-based frame
.text$mn:00005BBC
.text$mn:00005BBC ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:00005BBC                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:00005BBC ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:00005BBC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:00005BBC
.text$mn:00005BBC arg_0           = dword ptr  8
.text$mn:00005BBC arg_4           = dword ptr  0Ch
.text$mn:00005BBC
.text$mn:00005BBC                 push    ebp
.text$mn:00005BBD                 mov     ebp, esp
.text$mn:00005BBF                 mov     eax, [ebp+arg_4]
.text$mn:00005BC2                 push    eax
.text$mn:00005BC3                 mov     ecx, [ebp+arg_0]
.text$mn:00005BC6                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00005BCB                 pop     ebp
.text$mn:00005BCC                 retn
.text$mn:00005BCC ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:00005BCC
.text$mn:00005BCC ; ---------------------------------------------------------------------------
.text$mn:00005BCD                 align 10h
.text$mn:00005BCD _text$mn        ends
.text$mn:00005BCD
.text$mn:00005BD0 ; ===========================================================================
.text$mn:00005BD0
.text$mn:00005BD0 ; Segment type: Pure code
.text$mn:00005BD0 ; Segment permissions: Read/Execute
.text$mn:00005BD0 _text$mn        segment para public 'CODE' use32
.text$mn:00005BD0                 assume cs:_text$mn
.text$mn:00005BD0                 ;org 5BD0h
.text$mn:00005BD0 ; COMDAT (pick any)
.text$mn:00005BD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005BD0
.text$mn:00005BD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005BD0
.text$mn:00005BD0 ; Attributes: bp-based frame
.text$mn:00005BD0
.text$mn:00005BD0 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>::destroy<struct recordedMacroStep>(struct recordedMacroStep *)
.text$mn:00005BD0                 public ??$destroy@UrecordedMacroStep@@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@@Z
.text$mn:00005BD0 ??$destroy@UrecordedMacroStep@@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@@Z proc near
.text$mn:00005BD0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00005BD0                                         ; __catch$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:00005BD0
.text$mn:00005BD0 var_4           = dword ptr -4
.text$mn:00005BD0 arg_0           = dword ptr  8
.text$mn:00005BD0
.text$mn:00005BD0                 push    ebp
.text$mn:00005BD1                 mov     ebp, esp
.text$mn:00005BD3                 push    ecx
.text$mn:00005BD4                 mov     [ebp+var_4], ecx
.text$mn:00005BD7                 mov     eax, [ebp+arg_0]
.text$mn:00005BDA                 push    eax
.text$mn:00005BDB                 mov     ecx, [ebp+var_4]
.text$mn:00005BDE                 push    ecx
.text$mn:00005BDF                 call    ??$destroy@UrecordedMacroStep@@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@@Z ; std::allocator_traits<std::allocator<recordedMacroStep>>::destroy<recordedMacroStep>(std::allocator<recordedMacroStep> &,recordedMacroStep *)
.text$mn:00005BE4                 add     esp, 8
.text$mn:00005BE7                 mov     esp, ebp
.text$mn:00005BE9                 pop     ebp
.text$mn:00005BEA                 retn    4
.text$mn:00005BEA ??$destroy@UrecordedMacroStep@@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@@Z endp
.text$mn:00005BEA
.text$mn:00005BEA ; ---------------------------------------------------------------------------
.text$mn:00005BED                 align 10h
.text$mn:00005BED _text$mn        ends
.text$mn:00005BED
.text$mn:00005BF0 ; ===========================================================================
.text$mn:00005BF0
.text$mn:00005BF0 ; Segment type: Pure code
.text$mn:00005BF0 ; Segment permissions: Read/Execute
.text$mn:00005BF0 _text$mn        segment para public 'CODE' use32
.text$mn:00005BF0                 assume cs:_text$mn
.text$mn:00005BF0                 ;org 5BF0h
.text$mn:00005BF0 ; COMDAT (pick any)
.text$mn:00005BF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005BF0
.text$mn:00005BF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005BF0
.text$mn:00005BF0 ; Attributes: bp-based frame
.text$mn:00005BF0
.text$mn:00005BF0 ; public: void __thiscall std::allocator<struct recordedMacroStep>::destroy<struct recordedMacroStep>(struct recordedMacroStep *)
.text$mn:00005BF0                 public ??$destroy@UrecordedMacroStep@@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@@Z
.text$mn:00005BF0 ??$destroy@UrecordedMacroStep@@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@@Z proc near
.text$mn:00005BF0                                         ; CODE XREF: std::allocator_traits<std::allocator<recordedMacroStep>>::destroy<recordedMacroStep>(std::allocator<recordedMacroStep> &,recordedMacroStep *)+Ap
.text$mn:00005BF0
.text$mn:00005BF0 var_4           = dword ptr -4
.text$mn:00005BF0 arg_0           = dword ptr  8
.text$mn:00005BF0
.text$mn:00005BF0                 push    ebp
.text$mn:00005BF1                 mov     ebp, esp
.text$mn:00005BF3                 push    ecx
.text$mn:00005BF4                 mov     [ebp+var_4], ecx
.text$mn:00005BF7                 push    0
.text$mn:00005BF9                 mov     ecx, [ebp+arg_0]
.text$mn:00005BFC                 call    ??_GrecordedMacroStep@@QAEPAXI@Z ; recordedMacroStep::`scalar deleting destructor'(uint)
.text$mn:00005C01                 mov     esp, ebp
.text$mn:00005C03                 pop     ebp
.text$mn:00005C04                 retn    4
.text$mn:00005C04 ??$destroy@UrecordedMacroStep@@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@@Z endp
.text$mn:00005C04
.text$mn:00005C04 ; ---------------------------------------------------------------------------
.text$mn:00005C07                 align 4
.text$mn:00005C07 _text$mn        ends
.text$mn:00005C07
.text$mn:00005C08 ; ===========================================================================
.text$mn:00005C08
.text$mn:00005C08 ; Segment type: Pure code
.text$mn:00005C08 ; Segment permissions: Read/Execute
.text$mn:00005C08 _text$mn        segment para public 'CODE' use32
.text$mn:00005C08                 assume cs:_text$mn
.text$mn:00005C08                 ;org 5C08h
.text$mn:00005C08 ; COMDAT (pick any)
.text$mn:00005C08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C08
.text$mn:00005C08 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C08
.text$mn:00005C08 ; Attributes: bp-based frame
.text$mn:00005C08
.text$mn:00005C08 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct recordedMacroStep>>::destroy<struct recordedMacroStep>(class std::allocator<struct recordedMacroStep> &, struct recordedMacroStep *)
.text$mn:00005C08                 public ??$destroy@UrecordedMacroStep@@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@@Z
.text$mn:00005C08 ??$destroy@UrecordedMacroStep@@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@@Z proc near
.text$mn:00005C08                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::destroy<recordedMacroStep>(recordedMacroStep *)+Fp
.text$mn:00005C08
.text$mn:00005C08 arg_0           = dword ptr  8
.text$mn:00005C08 arg_4           = dword ptr  0Ch
.text$mn:00005C08
.text$mn:00005C08                 push    ebp
.text$mn:00005C09                 mov     ebp, esp
.text$mn:00005C0B                 mov     eax, [ebp+arg_4]
.text$mn:00005C0E                 push    eax
.text$mn:00005C0F                 mov     ecx, [ebp+arg_0]
.text$mn:00005C12                 call    ??$destroy@UrecordedMacroStep@@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@@Z ; std::allocator<recordedMacroStep>::destroy<recordedMacroStep>(recordedMacroStep *)
.text$mn:00005C17                 pop     ebp
.text$mn:00005C18                 retn
.text$mn:00005C18 ??$destroy@UrecordedMacroStep@@@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAXAAV?$allocator@UrecordedMacroStep@@@1@PAUrecordedMacroStep@@@Z endp
.text$mn:00005C18
.text$mn:00005C18 ; ---------------------------------------------------------------------------
.text$mn:00005C19                 align 4
.text$mn:00005C19 _text$mn        ends
.text$mn:00005C19
.text$mn:00005C1C ; ===========================================================================
.text$mn:00005C1C
.text$mn:00005C1C ; Segment type: Pure code
.text$mn:00005C1C ; Segment permissions: Read/Execute
.text$mn:00005C1C _text$mn        segment para public 'CODE' use32
.text$mn:00005C1C                 assume cs:_text$mn
.text$mn:00005C1C                 ;org 5C1Ch
.text$mn:00005C1C ; COMDAT (pick any)
.text$mn:00005C1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C1C
.text$mn:00005C1C ; =============== S U B R O U T I N E =======================================
.text$mn:00005C1C
.text$mn:00005C1C ; Attributes: bp-based frame
.text$mn:00005C1C
.text$mn:00005C1C ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00005C1C                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00005C1C ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00005C1C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00005C1C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00005C1C
.text$mn:00005C1C arg_0           = dword ptr  8
.text$mn:00005C1C
.text$mn:00005C1C                 push    ebp
.text$mn:00005C1D                 mov     ebp, esp
.text$mn:00005C1F                 mov     eax, [ebp+arg_0]
.text$mn:00005C22                 pop     ebp
.text$mn:00005C23                 retn
.text$mn:00005C23 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00005C23
.text$mn:00005C23 _text$mn        ends
.text$mn:00005C23
.text$mn:00005C24 ; ===========================================================================
.text$mn:00005C24
.text$mn:00005C24 ; Segment type: Pure code
.text$mn:00005C24 ; Segment permissions: Read/Execute
.text$mn:00005C24 _text$mn        segment para public 'CODE' use32
.text$mn:00005C24                 assume cs:_text$mn
.text$mn:00005C24                 ;org 5C24h
.text$mn:00005C24 ; COMDAT (pick any)
.text$mn:00005C24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C24
.text$mn:00005C24 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C24
.text$mn:00005C24 ; Attributes: bp-based frame
.text$mn:00005C24
.text$mn:00005C24 ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00005C24                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:00005C24 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:00005C24                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:00005C24                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:00005C24
.text$mn:00005C24 arg_0           = dword ptr  8
.text$mn:00005C24
.text$mn:00005C24                 push    ebp
.text$mn:00005C25                 mov     ebp, esp
.text$mn:00005C27                 mov     eax, [ebp+arg_0]
.text$mn:00005C2A                 pop     ebp
.text$mn:00005C2B                 retn
.text$mn:00005C2B ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:00005C2B
.text$mn:00005C2B _text$mn        ends
.text$mn:00005C2B
.text$mn:00005C2C ; ===========================================================================
.text$mn:00005C2C
.text$mn:00005C2C ; Segment type: Pure code
.text$mn:00005C2C ; Segment permissions: Read/Execute
.text$mn:00005C2C _text$mn        segment para public 'CODE' use32
.text$mn:00005C2C                 assume cs:_text$mn
.text$mn:00005C2C                 ;org 5C2Ch
.text$mn:00005C2C ; COMDAT (pick any)
.text$mn:00005C2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C2C
.text$mn:00005C2C ; =============== S U B R O U T I N E =======================================
.text$mn:00005C2C
.text$mn:00005C2C ; Attributes: bp-based frame
.text$mn:00005C2C
.text$mn:00005C2C ; unsigned int const & __cdecl std::forward<unsigned int const &>(unsigned int const &)
.text$mn:00005C2C                 public ??$forward@ABI@std@@YAABIABI@Z
.text$mn:00005C2C ??$forward@ABI@std@@YAABIABI@Z proc near
.text$mn:00005C2C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::construct<uint,uint const &>(uint *,uint const &)+Bp
.text$mn:00005C2C                                         ; std::allocator_traits<std::allocator<uint>>::construct<uint,uint const &>(std::allocator<uint> &,uint *,uint const &)+7p
.text$mn:00005C2C
.text$mn:00005C2C arg_0           = dword ptr  8
.text$mn:00005C2C
.text$mn:00005C2C                 push    ebp
.text$mn:00005C2D                 mov     ebp, esp
.text$mn:00005C2F                 mov     eax, [ebp+arg_0]
.text$mn:00005C32                 pop     ebp
.text$mn:00005C33                 retn
.text$mn:00005C33 ??$forward@ABI@std@@YAABIABI@Z endp
.text$mn:00005C33
.text$mn:00005C33 _text$mn        ends
.text$mn:00005C33
.text$mn:00005C34 ; ===========================================================================
.text$mn:00005C34
.text$mn:00005C34 ; Segment type: Pure code
.text$mn:00005C34 ; Segment permissions: Read/Execute
.text$mn:00005C34 _text$mn        segment para public 'CODE' use32
.text$mn:00005C34                 assume cs:_text$mn
.text$mn:00005C34                 ;org 5C34h
.text$mn:00005C34 ; COMDAT (pick any)
.text$mn:00005C34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C34
.text$mn:00005C34 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C34
.text$mn:00005C34 ; Attributes: bp-based frame
.text$mn:00005C34
.text$mn:00005C34 ; struct MenuItemUnit && __cdecl std::forward<struct MenuItemUnit>(struct MenuItemUnit &)
.text$mn:00005C34                 public ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z
.text$mn:00005C34 ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z proc near
.text$mn:00005C34                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)+Bp
.text$mn:00005C34                                         ; std::allocator<MenuItemUnit>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)+4Ap ...
.text$mn:00005C34
.text$mn:00005C34 arg_0           = dword ptr  8
.text$mn:00005C34
.text$mn:00005C34                 push    ebp
.text$mn:00005C35                 mov     ebp, esp
.text$mn:00005C37                 mov     eax, [ebp+arg_0]
.text$mn:00005C3A                 pop     ebp
.text$mn:00005C3B                 retn
.text$mn:00005C3B ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z endp
.text$mn:00005C3B
.text$mn:00005C3B _text$mn        ends
.text$mn:00005C3B
.text$mn:00005C3C ; ===========================================================================
.text$mn:00005C3C
.text$mn:00005C3C ; Segment type: Pure code
.text$mn:00005C3C ; Segment permissions: Read/Execute
.text$mn:00005C3C _text$mn        segment para public 'CODE' use32
.text$mn:00005C3C                 assume cs:_text$mn
.text$mn:00005C3C                 ;org 5C3Ch
.text$mn:00005C3C ; COMDAT (pick any)
.text$mn:00005C3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C3C
.text$mn:00005C3C ; =============== S U B R O U T I N E =======================================
.text$mn:00005C3C
.text$mn:00005C3C ; Attributes: bp-based frame
.text$mn:00005C3C
.text$mn:00005C3C ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00005C3C                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00005C3C ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00005C3C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:00005C3C                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:00005C3C
.text$mn:00005C3C arg_0           = dword ptr  8
.text$mn:00005C3C
.text$mn:00005C3C                 push    ebp
.text$mn:00005C3D                 mov     ebp, esp
.text$mn:00005C3F                 mov     eax, [ebp+arg_0]
.text$mn:00005C42                 pop     ebp
.text$mn:00005C43                 retn
.text$mn:00005C43 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00005C43
.text$mn:00005C43 _text$mn        ends
.text$mn:00005C43
.text$mn:00005C44 ; ===========================================================================
.text$mn:00005C44
.text$mn:00005C44 ; Segment type: Pure code
.text$mn:00005C44 ; Segment permissions: Read/Execute
.text$mn:00005C44 _text$mn        segment para public 'CODE' use32
.text$mn:00005C44                 assume cs:_text$mn
.text$mn:00005C44                 ;org 5C44h
.text$mn:00005C44 ; COMDAT (pick any)
.text$mn:00005C44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C44
.text$mn:00005C44 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C44
.text$mn:00005C44 ; Attributes: bp-based frame
.text$mn:00005C44
.text$mn:00005C44 ; struct recordedMacroStep && __cdecl std::forward<struct recordedMacroStep>(struct recordedMacroStep &)
.text$mn:00005C44                 public ??$forward@UrecordedMacroStep@@@std@@YA$$QAUrecordedMacroStep@@AAU1@@Z
.text$mn:00005C44 ??$forward@UrecordedMacroStep@@@std@@YA$$QAUrecordedMacroStep@@AAU1@@Z proc near
.text$mn:00005C44                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep &&)+Bp
.text$mn:00005C44                                         ; std::allocator<recordedMacroStep>::construct<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep &&)+4Ap ...
.text$mn:00005C44
.text$mn:00005C44 arg_0           = dword ptr  8
.text$mn:00005C44
.text$mn:00005C44                 push    ebp
.text$mn:00005C45                 mov     ebp, esp
.text$mn:00005C47                 mov     eax, [ebp+arg_0]
.text$mn:00005C4A                 pop     ebp
.text$mn:00005C4B                 retn
.text$mn:00005C4B ??$forward@UrecordedMacroStep@@@std@@YA$$QAUrecordedMacroStep@@AAU1@@Z endp
.text$mn:00005C4B
.text$mn:00005C4B _text$mn        ends
.text$mn:00005C4B
.text$mn:00005C4C ; ===========================================================================
.text$mn:00005C4C
.text$mn:00005C4C ; Segment type: Pure code
.text$mn:00005C4C ; Segment permissions: Read/Execute
.text$mn:00005C4C _text$mn        segment para public 'CODE' use32
.text$mn:00005C4C                 assume cs:_text$mn
.text$mn:00005C4C                 ;org 5C4Ch
.text$mn:00005C4C ; COMDAT (pick any)
.text$mn:00005C4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005C4C
.text$mn:00005C4C ; =============== S U B R O U T I N E =======================================
.text$mn:00005C4C
.text$mn:00005C4C ; Attributes: bp-based frame
.text$mn:00005C4C
.text$mn:00005C4C ; public: __thiscall std::_Deque_alloc<0, struct std::_Deque_base_types<unsigned int, class std::allocator<unsigned int>>>::_Deque_alloc<0, struct std::_Deque_base_types<unsigned int, class std::allocator<unsigned int>>>(class std::allocator<unsigned int> const &)
.text$mn:00005C4C                 public ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
.text$mn:00005C4C ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z proc near
.text$mn:00005C4C                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::deque<uint,std::allocator<uint>>(void)+34p
.text$mn:00005C4C
.text$mn:00005C4C var_10          = dword ptr -10h
.text$mn:00005C4C var_C           = dword ptr -0Ch
.text$mn:00005C4C var_4           = dword ptr -4
.text$mn:00005C4C
.text$mn:00005C4C                 push    ebp
.text$mn:00005C4D                 mov     ebp, esp
.text$mn:00005C4F                 push    0FFFFFFFFh
.text$mn:00005C51                 push    offset __ehhandler$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
.text$mn:00005C56                 mov     eax, large fs:0
.text$mn:00005C5C                 push    eax
.text$mn:00005C5D                 push    ecx
.text$mn:00005C5E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005C63                 xor     eax, ebp
.text$mn:00005C65                 push    eax
.text$mn:00005C66                 lea     eax, [ebp+var_C]
.text$mn:00005C69                 mov     large fs:0, eax
.text$mn:00005C6F                 mov     [ebp+var_10], ecx
.text$mn:00005C72                 mov     ecx, [ebp+var_10]
.text$mn:00005C75                 call    ??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<uint>>::_Deque_val<std::_Deque_simple_types<uint>>(void)
.text$mn:00005C7A                 mov     [ebp+var_4], 0
.text$mn:00005C81                 mov     ecx, [ebp+var_10]
.text$mn:00005C84                 call    ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Alloc_proxy(void)
.text$mn:00005C89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005C90                 mov     eax, [ebp+var_10]
.text$mn:00005C93                 mov     ecx, [ebp+var_C]
.text$mn:00005C96                 mov     large fs:0, ecx
.text$mn:00005C9D                 pop     ecx
.text$mn:00005C9E                 mov     esp, ebp
.text$mn:00005CA0                 pop     ebp
.text$mn:00005CA1                 retn    4
.text$mn:00005CA1 ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z endp
.text$mn:00005CA1
.text$mn:00005CA1 _text$mn        ends
.text$mn:00005CA1
.text$x:00005CA4 ; ===========================================================================
.text$x:00005CA4
.text$x:00005CA4 ; Segment type: Pure code
.text$x:00005CA4 ; Segment permissions: Read/Execute
.text$x:00005CA4 _text$x         segment para public 'CODE' use32
.text$x:00005CA4                 assume cs:_text$x
.text$x:00005CA4                 ;org 5CA4h
.text$x:00005CA4 ; COMDAT (pick associative to section at 5C4C)
.text$x:00005CA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005CA4
.text$x:00005CA4 ; =============== S U B R O U T I N E =======================================
.text$x:00005CA4
.text$x:00005CA4
.text$x:00005CA4 __unwindfunclet$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z$0 proc near
.text$x:00005CA4                                         ; DATA XREF: .xdata$x:0000BED8o
.text$x:00005CA4                 mov     ecx, [ebp-10h]
.text$x:00005CA7                 jmp     ??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<uint>>::~_Deque_val<std::_Deque_simple_types<uint>>(void)
.text$x:00005CA7 __unwindfunclet$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z$0 endp
.text$x:00005CA7
.text$x:00005CAC
.text$x:00005CAC ; =============== S U B R O U T I N E =======================================
.text$x:00005CAC
.text$x:00005CAC
.text$x:00005CAC __ehhandler$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z proc near
.text$x:00005CAC                                         ; DATA XREF: std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>(std::allocator<uint> const &)+5o
.text$x:00005CAC
.text$x:00005CAC arg_4           = dword ptr  8
.text$x:00005CAC
.text$x:00005CAC                 mov     edx, [esp+arg_4]
.text$x:00005CB0                 lea     eax, [edx+0Ch]
.text$x:00005CB3                 mov     ecx, [edx-8]
.text$x:00005CB6                 xor     ecx, eax
.text$x:00005CB8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005CBD                 mov     eax, offset __ehfuncinfo$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
.text$x:00005CC2                 jmp     ___CxxFrameHandler3
.text$x:00005CC2 __ehhandler$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z endp
.text$x:00005CC2
.text$x:00005CC2 ; ---------------------------------------------------------------------------
.text$x:00005CC7                 align 4
.text$x:00005CC7 _text$x         ends
.text$x:00005CC7
.text$mn:00005CC8 ; ===========================================================================
.text$mn:00005CC8
.text$mn:00005CC8 ; Segment type: Pure code
.text$mn:00005CC8 ; Segment permissions: Read/Execute
.text$mn:00005CC8 _text$mn        segment para public 'CODE' use32
.text$mn:00005CC8                 assume cs:_text$mn
.text$mn:00005CC8                 ;org 5CC8h
.text$mn:00005CC8 ; COMDAT (pick any)
.text$mn:00005CC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005CC8
.text$mn:00005CC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005CC8
.text$mn:00005CC8 ; Attributes: bp-based frame
.text$mn:00005CC8
.text$mn:00005CC8 ; int __stdcall std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned int>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned int>>>(struct std::_Iterator_base12 *)
.text$mn:00005CC8                 public ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005CC8 ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00005CC8                                         ; CODE XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>> const &)+2Dp
.text$mn:00005CC8
.text$mn:00005CC8 var_10          = dword ptr -10h
.text$mn:00005CC8 var_C           = dword ptr -0Ch
.text$mn:00005CC8 var_4           = dword ptr -4
.text$mn:00005CC8 arg_0           = dword ptr  8
.text$mn:00005CC8
.text$mn:00005CC8                 push    ebp
.text$mn:00005CC9                 mov     ebp, esp
.text$mn:00005CCB                 push    0FFFFFFFFh
.text$mn:00005CCD                 push    offset __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005CD2                 mov     eax, large fs:0
.text$mn:00005CD8                 push    eax
.text$mn:00005CD9                 push    ecx
.text$mn:00005CDA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005CDF                 xor     eax, ebp
.text$mn:00005CE1                 push    eax
.text$mn:00005CE2                 lea     eax, [ebp+var_C]
.text$mn:00005CE5                 mov     large fs:0, eax
.text$mn:00005CEB                 mov     [ebp+var_10], ecx
.text$mn:00005CEE                 mov     eax, [ebp+arg_0]
.text$mn:00005CF1                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005CF2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005CF5                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:00005CFA                 mov     [ebp+var_4], 0
.text$mn:00005D01                 mov     ecx, [ebp+var_10]
.text$mn:00005D04                 mov     edx, [ebp+arg_0]
.text$mn:00005D07                 mov     eax, [edx+8]
.text$mn:00005D0A                 mov     [ecx+8], eax
.text$mn:00005D0D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005D14                 mov     eax, [ebp+var_10]
.text$mn:00005D17                 mov     ecx, [ebp+var_C]
.text$mn:00005D1A                 mov     large fs:0, ecx
.text$mn:00005D21                 pop     ecx
.text$mn:00005D22                 mov     esp, ebp
.text$mn:00005D24                 pop     ebp
.text$mn:00005D25                 retn    4
.text$mn:00005D25 ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00005D25
.text$mn:00005D25 _text$mn        ends
.text$mn:00005D25
.text$x:00005D28 ; ===========================================================================
.text$x:00005D28
.text$x:00005D28 ; Segment type: Pure code
.text$x:00005D28 ; Segment permissions: Read/Execute
.text$x:00005D28 _text$x         segment para public 'CODE' use32
.text$x:00005D28                 assume cs:_text$x
.text$x:00005D28                 ;org 5D28h
.text$x:00005D28 ; COMDAT (pick associative to section at 5CC8)
.text$x:00005D28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005D28
.text$x:00005D28 ; =============== S U B R O U T I N E =======================================
.text$x:00005D28
.text$x:00005D28
.text$x:00005D28 __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005D28                                         ; DATA XREF: .xdata$x:0000C0C4o
.text$x:00005D28                 mov     ecx, [ebp-10h]  ; this
.text$x:00005D2B                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00005D2B __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00005D2B
.text$x:00005D30
.text$x:00005D30 ; =============== S U B R O U T I N E =======================================
.text$x:00005D30
.text$x:00005D30
.text$x:00005D30 __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005D30                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>> const &)+5o
.text$x:00005D30
.text$x:00005D30 arg_4           = dword ptr  8
.text$x:00005D30
.text$x:00005D30                 mov     edx, [esp+arg_4]
.text$x:00005D34                 lea     eax, [edx+0Ch]
.text$x:00005D37                 mov     ecx, [edx-8]
.text$x:00005D3A                 xor     ecx, eax
.text$x:00005D3C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005D41                 mov     eax, offset __ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00005D46                 jmp     ___CxxFrameHandler3
.text$x:00005D46 __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00005D46
.text$x:00005D46 ; ---------------------------------------------------------------------------
.text$x:00005D4B                 align 4
.text$x:00005D4B _text$x         ends
.text$x:00005D4B
.text$mn:00005D4C ; ===========================================================================
.text$mn:00005D4C
.text$mn:00005D4C ; Segment type: Pure code
.text$mn:00005D4C ; Segment permissions: Read/Execute
.text$mn:00005D4C _text$mn        segment para public 'CODE' use32
.text$mn:00005D4C                 assume cs:_text$mn
.text$mn:00005D4C                 ;org 5D4Ch
.text$mn:00005D4C ; COMDAT (pick any)
.text$mn:00005D4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005D4C
.text$mn:00005D4C ; =============== S U B R O U T I N E =======================================
.text$mn:00005D4C
.text$mn:00005D4C ; Attributes: bp-based frame
.text$mn:00005D4C
.text$mn:00005D4C ; int __stdcall std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned int>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned int>>>(int, struct std::_Container_base12 *)
.text$mn:00005D4C                 public ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.text$mn:00005D4C ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z proc near
.text$mn:00005D4C                                         ; CODE XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(uint,std::_Container_base12 const *)+31p
.text$mn:00005D4C
.text$mn:00005D4C var_10          = dword ptr -10h
.text$mn:00005D4C var_C           = dword ptr -0Ch
.text$mn:00005D4C var_4           = dword ptr -4
.text$mn:00005D4C arg_0           = dword ptr  8
.text$mn:00005D4C arg_4           = dword ptr  0Ch
.text$mn:00005D4C
.text$mn:00005D4C                 push    ebp
.text$mn:00005D4D                 mov     ebp, esp
.text$mn:00005D4F                 push    0FFFFFFFFh
.text$mn:00005D51                 push    offset __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.text$mn:00005D56                 mov     eax, large fs:0
.text$mn:00005D5C                 push    eax
.text$mn:00005D5D                 push    ecx
.text$mn:00005D5E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005D63                 xor     eax, ebp
.text$mn:00005D65                 push    eax
.text$mn:00005D66                 lea     eax, [ebp+var_C]
.text$mn:00005D69                 mov     large fs:0, eax
.text$mn:00005D6F                 mov     [ebp+var_10], ecx
.text$mn:00005D72                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005D75                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00005D7A                 mov     [ebp+var_4], 0
.text$mn:00005D81                 mov     eax, [ebp+arg_4]
.text$mn:00005D84                 push    eax             ; struct std::_Container_base12 *
.text$mn:00005D85                 mov     ecx, [ebp+var_10]
.text$mn:00005D88                 call    ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@I@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Setcont(std::_Deque_val<std::_Deque_simple_types<uint>> const *)
.text$mn:00005D8D                 mov     ecx, [ebp+var_10]
.text$mn:00005D90                 mov     edx, [ebp+arg_0]
.text$mn:00005D93                 mov     [ecx+8], edx
.text$mn:00005D96                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005D9D                 mov     eax, [ebp+var_10]
.text$mn:00005DA0                 mov     ecx, [ebp+var_C]
.text$mn:00005DA3                 mov     large fs:0, ecx
.text$mn:00005DAA                 pop     ecx
.text$mn:00005DAB                 mov     esp, ebp
.text$mn:00005DAD                 pop     ebp
.text$mn:00005DAE                 retn    8
.text$mn:00005DAE ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z endp
.text$mn:00005DAE
.text$mn:00005DAE ; ---------------------------------------------------------------------------
.text$mn:00005DB1                 align 4
.text$mn:00005DB1 _text$mn        ends
.text$mn:00005DB1
.text$x:00005DB4 ; ===========================================================================
.text$x:00005DB4
.text$x:00005DB4 ; Segment type: Pure code
.text$x:00005DB4 ; Segment permissions: Read/Execute
.text$x:00005DB4 _text$x         segment para public 'CODE' use32
.text$x:00005DB4                 assume cs:_text$x
.text$x:00005DB4                 ;org 5DB4h
.text$x:00005DB4 ; COMDAT (pick associative to section at 5D4C)
.text$x:00005DB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005DB4
.text$x:00005DB4 ; =============== S U B R O U T I N E =======================================
.text$x:00005DB4
.text$x:00005DB4
.text$x:00005DB4 __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0 proc near
.text$x:00005DB4                                         ; DATA XREF: .xdata$x:0000C06Co
.text$x:00005DB4                 mov     ecx, [ebp-10h]  ; this
.text$x:00005DB7                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00005DB7 __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0 endp
.text$x:00005DB7
.text$x:00005DBC
.text$x:00005DBC ; =============== S U B R O U T I N E =======================================
.text$x:00005DBC
.text$x:00005DBC
.text$x:00005DBC __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z proc near
.text$x:00005DBC                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(uint,std::_Container_base12 const *)+5o
.text$x:00005DBC
.text$x:00005DBC arg_4           = dword ptr  8
.text$x:00005DBC
.text$x:00005DBC                 mov     edx, [esp+arg_4]
.text$x:00005DC0                 lea     eax, [edx+0Ch]
.text$x:00005DC3                 mov     ecx, [edx-8]
.text$x:00005DC6                 xor     ecx, eax
.text$x:00005DC8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005DCD                 mov     eax, offset __ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.text$x:00005DD2                 jmp     ___CxxFrameHandler3
.text$x:00005DD2 __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z endp
.text$x:00005DD2
.text$x:00005DD2 ; ---------------------------------------------------------------------------
.text$x:00005DD7                 align 4
.text$x:00005DD7 _text$x         ends
.text$x:00005DD7
.text$mn:00005DD8 ; ===========================================================================
.text$mn:00005DD8
.text$mn:00005DD8 ; Segment type: Pure code
.text$mn:00005DD8 ; Segment permissions: Read/Execute
.text$mn:00005DD8 _text$mn        segment para public 'CODE' use32
.text$mn:00005DD8                 assume cs:_text$mn
.text$mn:00005DD8                 ;org 5DD8h
.text$mn:00005DD8 ; COMDAT (pick any)
.text$mn:00005DD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005DD8
.text$mn:00005DD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005DD8
.text$mn:00005DD8 ; Attributes: bp-based frame
.text$mn:00005DD8
.text$mn:00005DD8 ; int __stdcall std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned int>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned int>>>(struct std::_Iterator_base12 *)
.text$mn:00005DD8                 public ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005DD8 ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00005DD8                                         ; CODE XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator-(int)+36p
.text$mn:00005DD8                                         ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator-(int)+52p
.text$mn:00005DD8
.text$mn:00005DD8 var_10          = dword ptr -10h
.text$mn:00005DD8 var_C           = dword ptr -0Ch
.text$mn:00005DD8 var_4           = dword ptr -4
.text$mn:00005DD8 arg_0           = dword ptr  8
.text$mn:00005DD8
.text$mn:00005DD8                 push    ebp
.text$mn:00005DD9                 mov     ebp, esp
.text$mn:00005DDB                 push    0FFFFFFFFh
.text$mn:00005DDD                 push    offset __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00005DE2                 mov     eax, large fs:0
.text$mn:00005DE8                 push    eax
.text$mn:00005DE9                 push    ecx
.text$mn:00005DEA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005DEF                 xor     eax, ebp
.text$mn:00005DF1                 push    eax
.text$mn:00005DF2                 lea     eax, [ebp+var_C]
.text$mn:00005DF5                 mov     large fs:0, eax
.text$mn:00005DFB                 mov     [ebp+var_10], ecx
.text$mn:00005DFE                 mov     eax, [ebp+arg_0]
.text$mn:00005E01                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005E02                 mov     ecx, [ebp+var_10]
.text$mn:00005E05                 call    ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>> const &)
.text$mn:00005E0A                 mov     [ebp+var_4], 0
.text$mn:00005E11                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005E18                 mov     eax, [ebp+var_10]
.text$mn:00005E1B                 mov     ecx, [ebp+var_C]
.text$mn:00005E1E                 mov     large fs:0, ecx
.text$mn:00005E25                 pop     ecx
.text$mn:00005E26                 mov     esp, ebp
.text$mn:00005E28                 pop     ebp
.text$mn:00005E29                 retn    4
.text$mn:00005E29 ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00005E29
.text$mn:00005E29 _text$mn        ends
.text$mn:00005E29
.text$x:00005E2C ; ===========================================================================
.text$x:00005E2C
.text$x:00005E2C ; Segment type: Pure code
.text$x:00005E2C ; Segment permissions: Read/Execute
.text$x:00005E2C _text$x         segment para public 'CODE' use32
.text$x:00005E2C                 assume cs:_text$x
.text$x:00005E2C                 ;org 5E2Ch
.text$x:00005E2C ; COMDAT (pick associative to section at 5DD8)
.text$x:00005E2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005E2C
.text$x:00005E2C ; =============== S U B R O U T I N E =======================================
.text$x:00005E2C
.text$x:00005E2C
.text$x:00005E2C __unwindfunclet$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00005E2C                                         ; DATA XREF: .xdata$x:0000C17Co
.text$x:00005E2C                 mov     ecx, [ebp-10h]
.text$x:00005E2F                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(void)
.text$x:00005E2F __unwindfunclet$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00005E2F
.text$x:00005E34
.text$x:00005E34 ; =============== S U B R O U T I N E =======================================
.text$x:00005E34
.text$x:00005E34
.text$x:00005E34 __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00005E34                                         ; DATA XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>> const &)+5o
.text$x:00005E34
.text$x:00005E34 arg_4           = dword ptr  8
.text$x:00005E34
.text$x:00005E34                 mov     edx, [esp+arg_4]
.text$x:00005E38                 lea     eax, [edx+0Ch]
.text$x:00005E3B                 mov     ecx, [edx-8]
.text$x:00005E3E                 xor     ecx, eax
.text$x:00005E40                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005E45                 mov     eax, offset __ehfuncinfo$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00005E4A                 jmp     ___CxxFrameHandler3
.text$x:00005E4A __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00005E4A
.text$x:00005E4A ; ---------------------------------------------------------------------------
.text$x:00005E4F                 align 10h
.text$x:00005E4F _text$x         ends
.text$x:00005E4F
.text$mn:00005E50 ; ===========================================================================
.text$mn:00005E50
.text$mn:00005E50 ; Segment type: Pure code
.text$mn:00005E50 ; Segment permissions: Read/Execute
.text$mn:00005E50 _text$mn        segment para public 'CODE' use32
.text$mn:00005E50                 assume cs:_text$mn
.text$mn:00005E50                 ;org 5E50h
.text$mn:00005E50 ; COMDAT (pick any)
.text$mn:00005E50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005E50
.text$mn:00005E50 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E50
.text$mn:00005E50 ; Attributes: bp-based frame
.text$mn:00005E50
.text$mn:00005E50 ; int __stdcall std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned int>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned int>>>(int, struct std::_Container_base12 *)
.text$mn:00005E50                 public ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.text$mn:00005E50 ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z proc near
.text$mn:00005E50                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::end(void)+43p
.text$mn:00005E50
.text$mn:00005E50 var_10          = dword ptr -10h
.text$mn:00005E50 var_C           = dword ptr -0Ch
.text$mn:00005E50 var_4           = dword ptr -4
.text$mn:00005E50 arg_0           = dword ptr  8
.text$mn:00005E50 arg_4           = dword ptr  0Ch
.text$mn:00005E50
.text$mn:00005E50                 push    ebp
.text$mn:00005E51                 mov     ebp, esp
.text$mn:00005E53                 push    0FFFFFFFFh
.text$mn:00005E55                 push    offset __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.text$mn:00005E5A                 mov     eax, large fs:0
.text$mn:00005E60                 push    eax
.text$mn:00005E61                 push    ecx
.text$mn:00005E62                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005E67                 xor     eax, ebp
.text$mn:00005E69                 push    eax
.text$mn:00005E6A                 lea     eax, [ebp+var_C]
.text$mn:00005E6D                 mov     large fs:0, eax
.text$mn:00005E73                 mov     [ebp+var_10], ecx
.text$mn:00005E76                 mov     eax, [ebp+arg_4]
.text$mn:00005E79                 push    eax             ; struct std::_Container_base12 *
.text$mn:00005E7A                 mov     ecx, [ebp+arg_0]
.text$mn:00005E7D                 push    ecx             ; int
.text$mn:00005E7E                 mov     ecx, [ebp+var_10]
.text$mn:00005E81                 call    ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(uint,std::_Container_base12 const *)
.text$mn:00005E86                 mov     [ebp+var_4], 0
.text$mn:00005E8D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005E94                 mov     eax, [ebp+var_10]
.text$mn:00005E97                 mov     ecx, [ebp+var_C]
.text$mn:00005E9A                 mov     large fs:0, ecx
.text$mn:00005EA1                 pop     ecx
.text$mn:00005EA2                 mov     esp, ebp
.text$mn:00005EA4                 pop     ebp
.text$mn:00005EA5                 retn    8
.text$mn:00005EA5 ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z endp
.text$mn:00005EA5
.text$mn:00005EA5 _text$mn        ends
.text$mn:00005EA5
.text$x:00005EA8 ; ===========================================================================
.text$x:00005EA8
.text$x:00005EA8 ; Segment type: Pure code
.text$x:00005EA8 ; Segment permissions: Read/Execute
.text$x:00005EA8 _text$x         segment para public 'CODE' use32
.text$x:00005EA8                 assume cs:_text$x
.text$x:00005EA8                 ;org 5EA8h
.text$x:00005EA8 ; COMDAT (pick associative to section at 5E50)
.text$x:00005EA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005EA8
.text$x:00005EA8 ; =============== S U B R O U T I N E =======================================
.text$x:00005EA8
.text$x:00005EA8
.text$x:00005EA8 __unwindfunclet$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0 proc near
.text$x:00005EA8                                         ; DATA XREF: .xdata$x:0000C0F0o
.text$x:00005EA8                 mov     ecx, [ebp-10h]
.text$x:00005EAB                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(void)
.text$x:00005EAB __unwindfunclet$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0 endp
.text$x:00005EAB
.text$x:00005EB0
.text$x:00005EB0 ; =============== S U B R O U T I N E =======================================
.text$x:00005EB0
.text$x:00005EB0
.text$x:00005EB0 __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z proc near
.text$x:00005EB0                                         ; DATA XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(uint,std::_Container_base12 const *)+5o
.text$x:00005EB0
.text$x:00005EB0 arg_4           = dword ptr  8
.text$x:00005EB0
.text$x:00005EB0                 mov     edx, [esp+arg_4]
.text$x:00005EB4                 lea     eax, [edx+0Ch]
.text$x:00005EB7                 mov     ecx, [edx-8]
.text$x:00005EBA                 xor     ecx, eax
.text$x:00005EBC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005EC1                 mov     eax, offset __ehfuncinfo$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.text$x:00005EC6                 jmp     ___CxxFrameHandler3
.text$x:00005EC6 __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z endp
.text$x:00005EC6
.text$x:00005EC6 ; ---------------------------------------------------------------------------
.text$x:00005ECB                 align 4
.text$x:00005ECB _text$x         ends
.text$x:00005ECB
.text$mn:00005ECC ; ===========================================================================
.text$mn:00005ECC
.text$mn:00005ECC ; Segment type: Pure code
.text$mn:00005ECC ; Segment permissions: Read/Execute
.text$mn:00005ECC _text$mn        segment para public 'CODE' use32
.text$mn:00005ECC                 assume cs:_text$mn
.text$mn:00005ECC                 ;org 5ECCh
.text$mn:00005ECC ; COMDAT (pick any)
.text$mn:00005ECC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005ECC
.text$mn:00005ECC ; =============== S U B R O U T I N E =======================================
.text$mn:00005ECC
.text$mn:00005ECC ; Attributes: bp-based frame
.text$mn:00005ECC
.text$mn:00005ECC ; public: __thiscall std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>::_Deque_val<struct std::_Deque_simple_types<unsigned int>>(void)
.text$mn:00005ECC                 public ??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ
.text$mn:00005ECC ??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ proc near
.text$mn:00005ECC                                         ; CODE XREF: std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>(std::allocator<uint> const &)+29p
.text$mn:00005ECC
.text$mn:00005ECC var_10          = dword ptr -10h
.text$mn:00005ECC var_C           = dword ptr -0Ch
.text$mn:00005ECC var_4           = dword ptr -4
.text$mn:00005ECC
.text$mn:00005ECC                 push    ebp
.text$mn:00005ECD                 mov     ebp, esp
.text$mn:00005ECF                 push    0FFFFFFFFh
.text$mn:00005ED1                 push    offset __ehhandler$??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ
.text$mn:00005ED6                 mov     eax, large fs:0
.text$mn:00005EDC                 push    eax
.text$mn:00005EDD                 push    ecx
.text$mn:00005EDE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005EE3                 xor     eax, ebp
.text$mn:00005EE5                 push    eax
.text$mn:00005EE6                 lea     eax, [ebp+var_C]
.text$mn:00005EE9                 mov     large fs:0, eax
.text$mn:00005EEF                 mov     [ebp+var_10], ecx
.text$mn:00005EF2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005EF5                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00005EFA                 mov     [ebp+var_4], 0
.text$mn:00005F01                 mov     eax, [ebp+var_10]
.text$mn:00005F04                 mov     dword ptr [eax+4], 0
.text$mn:00005F0B                 mov     ecx, [ebp+var_10]
.text$mn:00005F0E                 mov     dword ptr [ecx+8], 0
.text$mn:00005F15                 mov     edx, [ebp+var_10]
.text$mn:00005F18                 mov     dword ptr [edx+0Ch], 0
.text$mn:00005F1F                 mov     eax, [ebp+var_10]
.text$mn:00005F22                 mov     dword ptr [eax+10h], 0
.text$mn:00005F29                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005F30                 mov     eax, [ebp+var_10]
.text$mn:00005F33                 mov     ecx, [ebp+var_C]
.text$mn:00005F36                 mov     large fs:0, ecx
.text$mn:00005F3D                 pop     ecx
.text$mn:00005F3E                 mov     esp, ebp
.text$mn:00005F40                 pop     ebp
.text$mn:00005F41                 retn
.text$mn:00005F41 ??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ endp
.text$mn:00005F41
.text$mn:00005F41 ; ---------------------------------------------------------------------------
.text$mn:00005F42                 align 4
.text$mn:00005F42 _text$mn        ends
.text$mn:00005F42
.text$x:00005F44 ; ===========================================================================
.text$x:00005F44
.text$x:00005F44 ; Segment type: Pure code
.text$x:00005F44 ; Segment permissions: Read/Execute
.text$x:00005F44 _text$x         segment para public 'CODE' use32
.text$x:00005F44                 assume cs:_text$x
.text$x:00005F44                 ;org 5F44h
.text$x:00005F44 ; COMDAT (pick associative to section at 5ECC)
.text$x:00005F44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005F44
.text$x:00005F44 ; =============== S U B R O U T I N E =======================================
.text$x:00005F44
.text$x:00005F44
.text$x:00005F44 __unwindfunclet$??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ$0 proc near
.text$x:00005F44                                         ; DATA XREF: .xdata$x:0000BE80o
.text$x:00005F44                 mov     ecx, [ebp-10h]  ; this
.text$x:00005F47                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00005F47 __unwindfunclet$??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ$0 endp
.text$x:00005F47
.text$x:00005F4C
.text$x:00005F4C ; =============== S U B R O U T I N E =======================================
.text$x:00005F4C
.text$x:00005F4C
.text$x:00005F4C __ehhandler$??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ proc near
.text$x:00005F4C                                         ; DATA XREF: std::_Deque_val<std::_Deque_simple_types<uint>>::_Deque_val<std::_Deque_simple_types<uint>>(void)+5o
.text$x:00005F4C
.text$x:00005F4C arg_4           = dword ptr  8
.text$x:00005F4C
.text$x:00005F4C                 mov     edx, [esp+arg_4]
.text$x:00005F50                 lea     eax, [edx+0Ch]
.text$x:00005F53                 mov     ecx, [edx-8]
.text$x:00005F56                 xor     ecx, eax
.text$x:00005F58                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005F5D                 mov     eax, offset __ehfuncinfo$??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ
.text$x:00005F62                 jmp     ___CxxFrameHandler3
.text$x:00005F62 __ehhandler$??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ endp
.text$x:00005F62
.text$x:00005F62 ; ---------------------------------------------------------------------------
.text$x:00005F67                 align 4
.text$x:00005F67 _text$x         ends
.text$x:00005F67
.text$mn:00005F68 ; ===========================================================================
.text$mn:00005F68
.text$mn:00005F68 ; Segment type: Pure code
.text$mn:00005F68 ; Segment permissions: Read/Execute
.text$mn:00005F68 _text$mn        segment para public 'CODE' use32
.text$mn:00005F68                 assume cs:_text$mn
.text$mn:00005F68                 ;org 5F68h
.text$mn:00005F68 ; COMDAT (pick any)
.text$mn:00005F68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005F68
.text$mn:00005F68 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F68
.text$mn:00005F68 ; Attributes: bp-based frame
.text$mn:00005F68
.text$mn:00005F68 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00005F68                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00005F68 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00005F68                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00005F68                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p
.text$mn:00005F68
.text$mn:00005F68 var_10          = dword ptr -10h
.text$mn:00005F68 var_C           = dword ptr -0Ch
.text$mn:00005F68 var_4           = dword ptr -4
.text$mn:00005F68
.text$mn:00005F68                 push    ebp
.text$mn:00005F69                 mov     ebp, esp
.text$mn:00005F6B                 push    0FFFFFFFFh
.text$mn:00005F6D                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00005F72                 mov     eax, large fs:0
.text$mn:00005F78                 push    eax
.text$mn:00005F79                 push    ecx
.text$mn:00005F7A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005F7F                 xor     eax, ebp
.text$mn:00005F81                 push    eax
.text$mn:00005F82                 lea     eax, [ebp+var_C]
.text$mn:00005F85                 mov     large fs:0, eax
.text$mn:00005F8B                 mov     [ebp+var_10], ecx
.text$mn:00005F8E                 mov     ecx, [ebp+var_10]
.text$mn:00005F91                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00005F96                 mov     [ebp+var_4], 0
.text$mn:00005F9D                 mov     ecx, [ebp+var_10]
.text$mn:00005FA0                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00005FA5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005FAC                 mov     eax, [ebp+var_10]
.text$mn:00005FAF                 mov     ecx, [ebp+var_C]
.text$mn:00005FB2                 mov     large fs:0, ecx
.text$mn:00005FB9                 pop     ecx
.text$mn:00005FBA                 mov     esp, ebp
.text$mn:00005FBC                 pop     ebp
.text$mn:00005FBD                 retn    4
.text$mn:00005FBD ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00005FBD
.text$mn:00005FBD _text$mn        ends
.text$mn:00005FBD
.text$x:00005FC0 ; ===========================================================================
.text$x:00005FC0
.text$x:00005FC0 ; Segment type: Pure code
.text$x:00005FC0 ; Segment permissions: Read/Execute
.text$x:00005FC0 _text$x         segment para public 'CODE' use32
.text$x:00005FC0                 assume cs:_text$x
.text$x:00005FC0                 ;org 5FC0h
.text$x:00005FC0 ; COMDAT (pick associative to section at 5F68)
.text$x:00005FC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00005FC0
.text$x:00005FC0 ; =============== S U B R O U T I N E =======================================
.text$x:00005FC0
.text$x:00005FC0
.text$x:00005FC0 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00005FC0                                         ; DATA XREF: .xdata$x:0000B540o
.text$x:00005FC0                 mov     ecx, [ebp-10h]
.text$x:00005FC3                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00005FC3 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00005FC3
.text$x:00005FC8
.text$x:00005FC8 ; =============== S U B R O U T I N E =======================================
.text$x:00005FC8
.text$x:00005FC8
.text$x:00005FC8 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00005FC8                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00005FC8
.text$x:00005FC8 arg_4           = dword ptr  8
.text$x:00005FC8
.text$x:00005FC8                 mov     edx, [esp+arg_4]
.text$x:00005FCC                 lea     eax, [edx+0Ch]
.text$x:00005FCF                 mov     ecx, [edx-8]
.text$x:00005FD2                 xor     ecx, eax
.text$x:00005FD4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005FD9                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00005FDE                 jmp     ___CxxFrameHandler3
.text$x:00005FDE __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00005FDE
.text$x:00005FDE ; ---------------------------------------------------------------------------
.text$x:00005FE3                 align 4
.text$x:00005FE3 _text$x         ends
.text$x:00005FE3
.text$mn:00005FE4 ; ===========================================================================
.text$mn:00005FE4
.text$mn:00005FE4 ; Segment type: Pure code
.text$mn:00005FE4 ; Segment permissions: Read/Execute
.text$mn:00005FE4 _text$mn        segment para public 'CODE' use32
.text$mn:00005FE4                 assume cs:_text$mn
.text$mn:00005FE4                 ;org 5FE4h
.text$mn:00005FE4 ; COMDAT (pick any)
.text$mn:00005FE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00005FE4
.text$mn:00005FE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005FE4
.text$mn:00005FE4 ; Attributes: bp-based frame
.text$mn:00005FE4
.text$mn:00005FE4 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:00005FE4                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00005FE4 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00005FE4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+43p
.text$mn:00005FE4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+34p ...
.text$mn:00005FE4
.text$mn:00005FE4 var_10          = dword ptr -10h
.text$mn:00005FE4 var_C           = dword ptr -0Ch
.text$mn:00005FE4 var_4           = dword ptr -4
.text$mn:00005FE4
.text$mn:00005FE4                 push    ebp
.text$mn:00005FE5                 mov     ebp, esp
.text$mn:00005FE7                 push    0FFFFFFFFh
.text$mn:00005FE9                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00005FEE                 mov     eax, large fs:0
.text$mn:00005FF4                 push    eax
.text$mn:00005FF5                 push    ecx
.text$mn:00005FF6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005FFB                 xor     eax, ebp
.text$mn:00005FFD                 push    eax
.text$mn:00005FFE                 lea     eax, [ebp+var_C]
.text$mn:00006001                 mov     large fs:0, eax
.text$mn:00006007                 mov     [ebp+var_10], ecx
.text$mn:0000600A                 mov     ecx, [ebp+var_10]
.text$mn:0000600D                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00006012                 mov     [ebp+var_4], 0
.text$mn:00006019                 mov     ecx, [ebp+var_10]
.text$mn:0000601C                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00006021                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006028                 mov     eax, [ebp+var_10]
.text$mn:0000602B                 mov     ecx, [ebp+var_C]
.text$mn:0000602E                 mov     large fs:0, ecx
.text$mn:00006035                 pop     ecx
.text$mn:00006036                 mov     esp, ebp
.text$mn:00006038                 pop     ebp
.text$mn:00006039                 retn    4
.text$mn:00006039 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00006039
.text$mn:00006039 _text$mn        ends
.text$mn:00006039
.text$x:0000603C ; ===========================================================================
.text$x:0000603C
.text$x:0000603C ; Segment type: Pure code
.text$x:0000603C ; Segment permissions: Read/Execute
.text$x:0000603C _text$x         segment para public 'CODE' use32
.text$x:0000603C                 assume cs:_text$x
.text$x:0000603C                 ;org 603Ch
.text$x:0000603C ; COMDAT (pick associative to section at 5FE4)
.text$x:0000603C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000603C
.text$x:0000603C ; =============== S U B R O U T I N E =======================================
.text$x:0000603C
.text$x:0000603C
.text$x:0000603C __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:0000603C                                         ; DATA XREF: .xdata$x:0000B88Co
.text$x:0000603C                 mov     ecx, [ebp-10h]
.text$x:0000603F                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:0000603F __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:0000603F
.text$x:00006044
.text$x:00006044 ; =============== S U B R O U T I N E =======================================
.text$x:00006044
.text$x:00006044
.text$x:00006044 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:00006044                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:00006044
.text$x:00006044 arg_4           = dword ptr  8
.text$x:00006044
.text$x:00006044                 mov     edx, [esp+arg_4]
.text$x:00006048                 lea     eax, [edx+0Ch]
.text$x:0000604B                 mov     ecx, [edx-8]
.text$x:0000604E                 xor     ecx, eax
.text$x:00006050                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006055                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:0000605A                 jmp     ___CxxFrameHandler3
.text$x:0000605A __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:0000605A
.text$x:0000605A ; ---------------------------------------------------------------------------
.text$x:0000605F                 align 10h
.text$x:0000605F _text$x         ends
.text$x:0000605F
.text$mn:00006060 ; ===========================================================================
.text$mn:00006060
.text$mn:00006060 ; Segment type: Pure code
.text$mn:00006060 ; Segment permissions: Read/Execute
.text$mn:00006060 _text$mn        segment para public 'CODE' use32
.text$mn:00006060                 assume cs:_text$mn
.text$mn:00006060                 ;org 6060h
.text$mn:00006060 ; COMDAT (pick any)
.text$mn:00006060                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006060
.text$mn:00006060 ; =============== S U B R O U T I N E =======================================
.text$mn:00006060
.text$mn:00006060 ; Attributes: bp-based frame
.text$mn:00006060
.text$mn:00006060 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00006060                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00006060 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00006060                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00006060
.text$mn:00006060 var_10          = dword ptr -10h
.text$mn:00006060 var_C           = dword ptr -0Ch
.text$mn:00006060 var_4           = dword ptr -4
.text$mn:00006060
.text$mn:00006060                 push    ebp
.text$mn:00006061                 mov     ebp, esp
.text$mn:00006063                 push    0FFFFFFFFh
.text$mn:00006065                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000606A                 mov     eax, large fs:0
.text$mn:00006070                 push    eax
.text$mn:00006071                 push    ecx
.text$mn:00006072                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006077                 xor     eax, ebp
.text$mn:00006079                 push    eax
.text$mn:0000607A                 lea     eax, [ebp+var_C]
.text$mn:0000607D                 mov     large fs:0, eax
.text$mn:00006083                 mov     [ebp+var_10], ecx
.text$mn:00006086                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006089                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000608E                 mov     [ebp+var_4], 0
.text$mn:00006095                 mov     eax, [ebp+var_10]
.text$mn:00006098                 mov     dword ptr [eax+14h], 0
.text$mn:0000609F                 mov     ecx, [ebp+var_10]
.text$mn:000060A2                 mov     dword ptr [ecx+18h], 0
.text$mn:000060A9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000060B0                 mov     eax, [ebp+var_10]
.text$mn:000060B3                 mov     ecx, [ebp+var_C]
.text$mn:000060B6                 mov     large fs:0, ecx
.text$mn:000060BD                 pop     ecx
.text$mn:000060BE                 mov     esp, ebp
.text$mn:000060C0                 pop     ebp
.text$mn:000060C1                 retn
.text$mn:000060C1 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000060C1
.text$mn:000060C1 ; ---------------------------------------------------------------------------
.text$mn:000060C2                 align 4
.text$mn:000060C2 _text$mn        ends
.text$mn:000060C2
.text$x:000060C4 ; ===========================================================================
.text$x:000060C4
.text$x:000060C4 ; Segment type: Pure code
.text$x:000060C4 ; Segment permissions: Read/Execute
.text$x:000060C4 _text$x         segment para public 'CODE' use32
.text$x:000060C4                 assume cs:_text$x
.text$x:000060C4                 ;org 60C4h
.text$x:000060C4 ; COMDAT (pick associative to section at 6060)
.text$x:000060C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000060C4
.text$x:000060C4 ; =============== S U B R O U T I N E =======================================
.text$x:000060C4
.text$x:000060C4
.text$x:000060C4 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000060C4                                         ; DATA XREF: .xdata$x:0000B4E8o
.text$x:000060C4                 mov     ecx, [ebp-10h]  ; this
.text$x:000060C7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000060C7 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000060C7
.text$x:000060CC
.text$x:000060CC ; =============== S U B R O U T I N E =======================================
.text$x:000060CC
.text$x:000060CC
.text$x:000060CC __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000060CC                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000060CC
.text$x:000060CC arg_4           = dword ptr  8
.text$x:000060CC
.text$x:000060CC                 mov     edx, [esp+arg_4]
.text$x:000060D0                 lea     eax, [edx+0Ch]
.text$x:000060D3                 mov     ecx, [edx-8]
.text$x:000060D6                 xor     ecx, eax
.text$x:000060D8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000060DD                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000060E2                 jmp     ___CxxFrameHandler3
.text$x:000060E2 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000060E2
.text$x:000060E2 ; ---------------------------------------------------------------------------
.text$x:000060E7                 align 4
.text$x:000060E7 _text$x         ends
.text$x:000060E7
.text$mn:000060E8 ; ===========================================================================
.text$mn:000060E8
.text$mn:000060E8 ; Segment type: Pure code
.text$mn:000060E8 ; Segment permissions: Read/Execute
.text$mn:000060E8 _text$mn        segment para public 'CODE' use32
.text$mn:000060E8                 assume cs:_text$mn
.text$mn:000060E8                 ;org 60E8h
.text$mn:000060E8 ; COMDAT (pick any)
.text$mn:000060E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000060E8
.text$mn:000060E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000060E8
.text$mn:000060E8 ; Attributes: bp-based frame
.text$mn:000060E8
.text$mn:000060E8 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:000060E8                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000060E8 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:000060E8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:000060E8
.text$mn:000060E8 var_10          = dword ptr -10h
.text$mn:000060E8 var_C           = dword ptr -0Ch
.text$mn:000060E8 var_4           = dword ptr -4
.text$mn:000060E8
.text$mn:000060E8                 push    ebp
.text$mn:000060E9                 mov     ebp, esp
.text$mn:000060EB                 push    0FFFFFFFFh
.text$mn:000060ED                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000060F2                 mov     eax, large fs:0
.text$mn:000060F8                 push    eax
.text$mn:000060F9                 push    ecx
.text$mn:000060FA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000060FF                 xor     eax, ebp
.text$mn:00006101                 push    eax
.text$mn:00006102                 lea     eax, [ebp+var_C]
.text$mn:00006105                 mov     large fs:0, eax
.text$mn:0000610B                 mov     [ebp+var_10], ecx
.text$mn:0000610E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006111                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00006116                 mov     [ebp+var_4], 0
.text$mn:0000611D                 mov     eax, [ebp+var_10]
.text$mn:00006120                 mov     dword ptr [eax+14h], 0
.text$mn:00006127                 mov     ecx, [ebp+var_10]
.text$mn:0000612A                 mov     dword ptr [ecx+18h], 0
.text$mn:00006131                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006138                 mov     eax, [ebp+var_10]
.text$mn:0000613B                 mov     ecx, [ebp+var_C]
.text$mn:0000613E                 mov     large fs:0, ecx
.text$mn:00006145                 pop     ecx
.text$mn:00006146                 mov     esp, ebp
.text$mn:00006148                 pop     ebp
.text$mn:00006149                 retn
.text$mn:00006149 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00006149
.text$mn:00006149 ; ---------------------------------------------------------------------------
.text$mn:0000614A                 align 4
.text$mn:0000614A _text$mn        ends
.text$mn:0000614A
.text$x:0000614C ; ===========================================================================
.text$x:0000614C
.text$x:0000614C ; Segment type: Pure code
.text$x:0000614C ; Segment permissions: Read/Execute
.text$x:0000614C _text$x         segment para public 'CODE' use32
.text$x:0000614C                 assume cs:_text$x
.text$x:0000614C                 ;org 614Ch
.text$x:0000614C ; COMDAT (pick associative to section at 60E8)
.text$x:0000614C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000614C
.text$x:0000614C ; =============== S U B R O U T I N E =======================================
.text$x:0000614C
.text$x:0000614C
.text$x:0000614C __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:0000614C                                         ; DATA XREF: .xdata$x:0000B834o
.text$x:0000614C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000614F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000614F __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:0000614F
.text$x:00006154
.text$x:00006154 ; =============== S U B R O U T I N E =======================================
.text$x:00006154
.text$x:00006154
.text$x:00006154 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00006154                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00006154
.text$x:00006154 arg_4           = dword ptr  8
.text$x:00006154
.text$x:00006154                 mov     edx, [esp+arg_4]
.text$x:00006158                 lea     eax, [edx+0Ch]
.text$x:0000615B                 mov     ecx, [edx-8]
.text$x:0000615E                 xor     ecx, eax
.text$x:00006160                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006165                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:0000616A                 jmp     ___CxxFrameHandler3
.text$x:0000616A __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:0000616A
.text$x:0000616A ; ---------------------------------------------------------------------------
.text$x:0000616F                 align 10h
.text$x:0000616F _text$x         ends
.text$x:0000616F
.text$mn:00006170 ; ===========================================================================
.text$mn:00006170
.text$mn:00006170 ; Segment type: Pure code
.text$mn:00006170 ; Segment permissions: Read/Execute
.text$mn:00006170 _text$mn        segment para public 'CODE' use32
.text$mn:00006170                 assume cs:_text$mn
.text$mn:00006170                 ;org 6170h
.text$mn:00006170 ; COMDAT (pick any)
.text$mn:00006170                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006170
.text$mn:00006170 ; =============== S U B R O U T I N E =======================================
.text$mn:00006170
.text$mn:00006170 ; Attributes: bp-based frame
.text$mn:00006170
.text$mn:00006170 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>>::_Vector_alloc<0, struct std::_Vec_base_types<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>>(class std::allocator<struct MenuItemUnit> const &)
.text$mn:00006170                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z
.text$mn:00006170 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z proc near
.text$mn:00006170                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)+34p
.text$mn:00006170
.text$mn:00006170 var_10          = dword ptr -10h
.text$mn:00006170 var_C           = dword ptr -0Ch
.text$mn:00006170 var_4           = dword ptr -4
.text$mn:00006170
.text$mn:00006170                 push    ebp
.text$mn:00006171                 mov     ebp, esp
.text$mn:00006173                 push    0FFFFFFFFh
.text$mn:00006175                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z
.text$mn:0000617A                 mov     eax, large fs:0
.text$mn:00006180                 push    eax
.text$mn:00006181                 push    ecx
.text$mn:00006182                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006187                 xor     eax, ebp
.text$mn:00006189                 push    eax
.text$mn:0000618A                 lea     eax, [ebp+var_C]
.text$mn:0000618D                 mov     large fs:0, eax
.text$mn:00006193                 mov     [ebp+var_10], ecx
.text$mn:00006196                 mov     ecx, [ebp+var_10]
.text$mn:00006199                 call    ??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<MenuItemUnit>>::_Vector_val<std::_Simple_types<MenuItemUnit>>(void)
.text$mn:0000619E                 mov     [ebp+var_4], 0
.text$mn:000061A5                 mov     ecx, [ebp+var_10]
.text$mn:000061A8                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Alloc_proxy(void)
.text$mn:000061AD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000061B4                 mov     eax, [ebp+var_10]
.text$mn:000061B7                 mov     ecx, [ebp+var_C]
.text$mn:000061BA                 mov     large fs:0, ecx
.text$mn:000061C1                 pop     ecx
.text$mn:000061C2                 mov     esp, ebp
.text$mn:000061C4                 pop     ebp
.text$mn:000061C5                 retn    4
.text$mn:000061C5 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z endp
.text$mn:000061C5
.text$mn:000061C5 _text$mn        ends
.text$mn:000061C5
.text$x:000061C8 ; ===========================================================================
.text$x:000061C8
.text$x:000061C8 ; Segment type: Pure code
.text$x:000061C8 ; Segment permissions: Read/Execute
.text$x:000061C8 _text$x         segment para public 'CODE' use32
.text$x:000061C8                 assume cs:_text$x
.text$x:000061C8                 ;org 61C8h
.text$x:000061C8 ; COMDAT (pick associative to section at 6170)
.text$x:000061C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000061C8
.text$x:000061C8 ; =============== S U B R O U T I N E =======================================
.text$x:000061C8
.text$x:000061C8
.text$x:000061C8 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z$0 proc near
.text$x:000061C8                                         ; DATA XREF: .xdata$x:0000BBBCo
.text$x:000061C8                 mov     ecx, [ebp-10h]
.text$x:000061CB                 jmp     ??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<MenuItemUnit>>::~_Vector_val<std::_Simple_types<MenuItemUnit>>(void)
.text$x:000061CB __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z$0 endp
.text$x:000061CB
.text$x:000061D0
.text$x:000061D0 ; =============== S U B R O U T I N E =======================================
.text$x:000061D0
.text$x:000061D0
.text$x:000061D0 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z proc near
.text$x:000061D0                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(std::allocator<MenuItemUnit> const &)+5o
.text$x:000061D0
.text$x:000061D0 arg_4           = dword ptr  8
.text$x:000061D0
.text$x:000061D0                 mov     edx, [esp+arg_4]
.text$x:000061D4                 lea     eax, [edx+0Ch]
.text$x:000061D7                 mov     ecx, [edx-8]
.text$x:000061DA                 xor     ecx, eax
.text$x:000061DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000061E1                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z
.text$x:000061E6                 jmp     ___CxxFrameHandler3
.text$x:000061E6 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z endp
.text$x:000061E6
.text$x:000061E6 ; ---------------------------------------------------------------------------
.text$x:000061EB                 align 4
.text$x:000061EB _text$x         ends
.text$x:000061EB
.text$mn:000061EC ; ===========================================================================
.text$mn:000061EC
.text$mn:000061EC ; Segment type: Pure code
.text$mn:000061EC ; Segment permissions: Read/Execute
.text$mn:000061EC _text$mn        segment para public 'CODE' use32
.text$mn:000061EC                 assume cs:_text$mn
.text$mn:000061EC                 ;org 61ECh
.text$mn:000061EC ; COMDAT (pick any)
.text$mn:000061EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000061EC
.text$mn:000061EC ; =============== S U B R O U T I N E =======================================
.text$mn:000061EC
.text$mn:000061EC ; Attributes: bp-based frame
.text$mn:000061EC
.text$mn:000061EC ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct MenuItemUnit>>::_Vector_val<struct std::_Simple_types<struct MenuItemUnit>>(void)
.text$mn:000061EC                 public ??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:000061EC ??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$mn:000061EC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(std::allocator<MenuItemUnit> const &)+29p
.text$mn:000061EC
.text$mn:000061EC var_10          = dword ptr -10h
.text$mn:000061EC var_C           = dword ptr -0Ch
.text$mn:000061EC var_4           = dword ptr -4
.text$mn:000061EC
.text$mn:000061EC                 push    ebp
.text$mn:000061ED                 mov     ebp, esp
.text$mn:000061EF                 push    0FFFFFFFFh
.text$mn:000061F1                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:000061F6                 mov     eax, large fs:0
.text$mn:000061FC                 push    eax
.text$mn:000061FD                 push    ecx
.text$mn:000061FE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006203                 xor     eax, ebp
.text$mn:00006205                 push    eax
.text$mn:00006206                 lea     eax, [ebp+var_C]
.text$mn:00006209                 mov     large fs:0, eax
.text$mn:0000620F                 mov     [ebp+var_10], ecx
.text$mn:00006212                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006215                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000621A                 mov     [ebp+var_4], 0
.text$mn:00006221                 mov     eax, [ebp+var_10]
.text$mn:00006224                 mov     dword ptr [eax+4], 0
.text$mn:0000622B                 mov     ecx, [ebp+var_10]
.text$mn:0000622E                 mov     dword ptr [ecx+8], 0
.text$mn:00006235                 mov     edx, [ebp+var_10]
.text$mn:00006238                 mov     dword ptr [edx+0Ch], 0
.text$mn:0000623F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006246                 mov     eax, [ebp+var_10]
.text$mn:00006249                 mov     ecx, [ebp+var_C]
.text$mn:0000624C                 mov     large fs:0, ecx
.text$mn:00006253                 pop     ecx
.text$mn:00006254                 mov     esp, ebp
.text$mn:00006256                 pop     ebp
.text$mn:00006257                 retn
.text$mn:00006257 ??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$mn:00006257
.text$mn:00006257 _text$mn        ends
.text$mn:00006257
.text$x:00006258 ; ===========================================================================
.text$x:00006258
.text$x:00006258 ; Segment type: Pure code
.text$x:00006258 ; Segment permissions: Read/Execute
.text$x:00006258 _text$x         segment para public 'CODE' use32
.text$x:00006258                 assume cs:_text$x
.text$x:00006258                 ;org 6258h
.text$x:00006258 ; COMDAT (pick associative to section at 61EC)
.text$x:00006258                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006258
.text$x:00006258 ; =============== S U B R O U T I N E =======================================
.text$x:00006258
.text$x:00006258
.text$x:00006258 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006258                                         ; DATA XREF: .xdata$x:0000BB64o
.text$x:00006258                 mov     ecx, [ebp-10h]  ; this
.text$x:0000625B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000625B __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000625B
.text$x:00006260
.text$x:00006260 ; =============== S U B R O U T I N E =======================================
.text$x:00006260
.text$x:00006260
.text$x:00006260 __ehhandler$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$x:00006260                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<MenuItemUnit>>::_Vector_val<std::_Simple_types<MenuItemUnit>>(void)+5o
.text$x:00006260
.text$x:00006260 arg_4           = dword ptr  8
.text$x:00006260
.text$x:00006260                 mov     edx, [esp+arg_4]
.text$x:00006264                 lea     eax, [edx+0Ch]
.text$x:00006267                 mov     ecx, [edx-8]
.text$x:0000626A                 xor     ecx, eax
.text$x:0000626C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006271                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$x:00006276                 jmp     ___CxxFrameHandler3
.text$x:00006276 __ehhandler$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$x:00006276
.text$x:00006276 ; ---------------------------------------------------------------------------
.text$x:0000627B                 align 4
.text$x:0000627B _text$x         ends
.text$x:0000627B
.text$mn:0000627C ; ===========================================================================
.text$mn:0000627C
.text$mn:0000627C ; Segment type: Pure code
.text$mn:0000627C ; Segment permissions: Read/Execute
.text$mn:0000627C _text$mn        segment para public 'CODE' use32
.text$mn:0000627C                 assume cs:_text$mn
.text$mn:0000627C                 ;org 627Ch
.text$mn:0000627C ; COMDAT (pick any)
.text$mn:0000627C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000627C
.text$mn:0000627C ; =============== S U B R O U T I N E =======================================
.text$mn:0000627C
.text$mn:0000627C ; Attributes: bp-based frame
.text$mn:0000627C
.text$mn:0000627C ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:0000627C                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:0000627C ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:0000627C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:0000627C
.text$mn:0000627C var_4           = dword ptr -4
.text$mn:0000627C
.text$mn:0000627C                 push    ebp
.text$mn:0000627D                 mov     ebp, esp
.text$mn:0000627F                 push    ecx
.text$mn:00006280                 mov     [ebp+var_4], ecx
.text$mn:00006283                 mov     ecx, [ebp+var_4]
.text$mn:00006286                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000628B                 mov     eax, [ebp+var_4]
.text$mn:0000628E                 mov     esp, ebp
.text$mn:00006290                 pop     ebp
.text$mn:00006291                 retn
.text$mn:00006291 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00006291
.text$mn:00006291 ; ---------------------------------------------------------------------------
.text$mn:00006292                 align 4
.text$mn:00006292 _text$mn        ends
.text$mn:00006292
.text$mn:00006294 ; ===========================================================================
.text$mn:00006294
.text$mn:00006294 ; Segment type: Pure code
.text$mn:00006294 ; Segment permissions: Read/Execute
.text$mn:00006294 _text$mn        segment para public 'CODE' use32
.text$mn:00006294                 assume cs:_text$mn
.text$mn:00006294                 ;org 6294h
.text$mn:00006294 ; COMDAT (pick any)
.text$mn:00006294                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006294
.text$mn:00006294 ; =============== S U B R O U T I N E =======================================
.text$mn:00006294
.text$mn:00006294 ; Attributes: bp-based frame
.text$mn:00006294
.text$mn:00006294 ; public: __thiscall std::_Wrap_alloc<class std::allocator<unsigned int>>::_Wrap_alloc<class std::allocator<unsigned int>>(void)
.text$mn:00006294                 public ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@XZ
.text$mn:00006294 ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@XZ proc near
.text$mn:00006294                                         ; CODE XREF: std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Getal(void)+Ap
.text$mn:00006294
.text$mn:00006294 var_4           = dword ptr -4
.text$mn:00006294
.text$mn:00006294                 push    ebp
.text$mn:00006295                 mov     ebp, esp
.text$mn:00006297                 push    ecx
.text$mn:00006298                 mov     [ebp+var_4], ecx
.text$mn:0000629B                 mov     ecx, [ebp+var_4]
.text$mn:0000629E                 call    ??0?$allocator@I@std@@QAE@XZ ; std::allocator<uint>::allocator<uint>(void)
.text$mn:000062A3                 mov     eax, [ebp+var_4]
.text$mn:000062A6                 mov     esp, ebp
.text$mn:000062A8                 pop     ebp
.text$mn:000062A9                 retn
.text$mn:000062A9 ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@XZ endp
.text$mn:000062A9
.text$mn:000062A9 ; ---------------------------------------------------------------------------
.text$mn:000062AA                 align 4
.text$mn:000062AA _text$mn        ends
.text$mn:000062AA
.text$mn:000062AC ; ===========================================================================
.text$mn:000062AC
.text$mn:000062AC ; Segment type: Pure code
.text$mn:000062AC ; Segment permissions: Read/Execute
.text$mn:000062AC _text$mn        segment para public 'CODE' use32
.text$mn:000062AC                 assume cs:_text$mn
.text$mn:000062AC                 ;org 62ACh
.text$mn:000062AC ; COMDAT (pick any)
.text$mn:000062AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000062AC
.text$mn:000062AC ; =============== S U B R O U T I N E =======================================
.text$mn:000062AC
.text$mn:000062AC ; Attributes: bp-based frame
.text$mn:000062AC
.text$mn:000062AC ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>(void)
.text$mn:000062AC                 public ??0?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:000062AC ??0?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$mn:000062AC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)+Ap
.text$mn:000062AC
.text$mn:000062AC var_4           = dword ptr -4
.text$mn:000062AC
.text$mn:000062AC                 push    ebp
.text$mn:000062AD                 mov     ebp, esp
.text$mn:000062AF                 push    ecx
.text$mn:000062B0                 mov     [ebp+var_4], ecx
.text$mn:000062B3                 mov     ecx, [ebp+var_4]
.text$mn:000062B6                 call    ??0?$allocator@UMenuItemUnit@@@std@@QAE@XZ ; std::allocator<MenuItemUnit>::allocator<MenuItemUnit>(void)
.text$mn:000062BB                 mov     eax, [ebp+var_4]
.text$mn:000062BE                 mov     esp, ebp
.text$mn:000062C0                 pop     ebp
.text$mn:000062C1                 retn
.text$mn:000062C1 ??0?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$mn:000062C1
.text$mn:000062C1 ; ---------------------------------------------------------------------------
.text$mn:000062C2                 align 4
.text$mn:000062C2 _text$mn        ends
.text$mn:000062C2
.text$mn:000062C4 ; ===========================================================================
.text$mn:000062C4
.text$mn:000062C4 ; Segment type: Pure code
.text$mn:000062C4 ; Segment permissions: Read/Execute
.text$mn:000062C4 _text$mn        segment para public 'CODE' use32
.text$mn:000062C4                 assume cs:_text$mn
.text$mn:000062C4                 ;org 62C4h
.text$mn:000062C4 ; COMDAT (pick any)
.text$mn:000062C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000062C4
.text$mn:000062C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000062C4
.text$mn:000062C4 ; Attributes: bp-based frame
.text$mn:000062C4
.text$mn:000062C4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:000062C4                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:000062C4 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000062C4                                         ; CODE XREF: std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Alloc_proxy(void)+Cp
.text$mn:000062C4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Alloc_proxy(void)+Cp ...
.text$mn:000062C4
.text$mn:000062C4 var_4           = dword ptr -4
.text$mn:000062C4
.text$mn:000062C4                 push    ebp
.text$mn:000062C5                 mov     ebp, esp
.text$mn:000062C7                 push    ecx
.text$mn:000062C8                 mov     [ebp+var_4], ecx
.text$mn:000062CB                 mov     ecx, [ebp+var_4]
.text$mn:000062CE                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000062D3                 mov     eax, [ebp+var_4]
.text$mn:000062D6                 mov     esp, ebp
.text$mn:000062D8                 pop     ebp
.text$mn:000062D9                 retn
.text$mn:000062D9 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:000062D9
.text$mn:000062D9 ; ---------------------------------------------------------------------------
.text$mn:000062DA                 align 4
.text$mn:000062DA _text$mn        ends
.text$mn:000062DA
.text$mn:000062DC ; ===========================================================================
.text$mn:000062DC
.text$mn:000062DC ; Segment type: Pure code
.text$mn:000062DC ; Segment permissions: Read/Execute
.text$mn:000062DC _text$mn        segment para public 'CODE' use32
.text$mn:000062DC                 assume cs:_text$mn
.text$mn:000062DC                 ;org 62DCh
.text$mn:000062DC ; COMDAT (pick any)
.text$mn:000062DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000062DC
.text$mn:000062DC ; =============== S U B R O U T I N E =======================================
.text$mn:000062DC
.text$mn:000062DC ; Attributes: bp-based frame
.text$mn:000062DC
.text$mn:000062DC ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>(void)
.text$mn:000062DC                 public ??0?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ
.text$mn:000062DC ??0?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ proc near
.text$mn:000062DC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)+Ap
.text$mn:000062DC
.text$mn:000062DC var_4           = dword ptr -4
.text$mn:000062DC
.text$mn:000062DC                 push    ebp
.text$mn:000062DD                 mov     ebp, esp
.text$mn:000062DF                 push    ecx
.text$mn:000062E0                 mov     [ebp+var_4], ecx
.text$mn:000062E3                 mov     ecx, [ebp+var_4]
.text$mn:000062E6                 call    ??0?$allocator@UrecordedMacroStep@@@std@@QAE@XZ ; std::allocator<recordedMacroStep>::allocator<recordedMacroStep>(void)
.text$mn:000062EB                 mov     eax, [ebp+var_4]
.text$mn:000062EE                 mov     esp, ebp
.text$mn:000062F0                 pop     ebp
.text$mn:000062F1                 retn
.text$mn:000062F1 ??0?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ endp
.text$mn:000062F1
.text$mn:000062F1 ; ---------------------------------------------------------------------------
.text$mn:000062F2                 align 4
.text$mn:000062F2 _text$mn        ends
.text$mn:000062F2
.text$mn:000062F4 ; ===========================================================================
.text$mn:000062F4
.text$mn:000062F4 ; Segment type: Pure code
.text$mn:000062F4 ; Segment permissions: Read/Execute
.text$mn:000062F4 _text$mn        segment para public 'CODE' use32
.text$mn:000062F4                 assume cs:_text$mn
.text$mn:000062F4                 ;org 62F4h
.text$mn:000062F4 ; COMDAT (pick any)
.text$mn:000062F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000062F4
.text$mn:000062F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000062F4
.text$mn:000062F4 ; Attributes: bp-based frame
.text$mn:000062F4
.text$mn:000062F4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(class std::allocator<wchar_t> const &)
.text$mn:000062F4                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:000062F4 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:000062F4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+1Dp
.text$mn:000062F4
.text$mn:000062F4 var_4           = dword ptr -4
.text$mn:000062F4 arg_0           = dword ptr  8
.text$mn:000062F4
.text$mn:000062F4                 push    ebp
.text$mn:000062F5                 mov     ebp, esp
.text$mn:000062F7                 push    ecx
.text$mn:000062F8                 mov     [ebp+var_4], ecx
.text$mn:000062FB                 mov     eax, [ebp+arg_0]
.text$mn:000062FE                 push    eax
.text$mn:000062FF                 mov     ecx, [ebp+var_4]
.text$mn:00006302                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00006307                 mov     eax, [ebp+var_4]
.text$mn:0000630A                 mov     esp, ebp
.text$mn:0000630C                 pop     ebp
.text$mn:0000630D                 retn    4
.text$mn:0000630D ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:0000630D
.text$mn:0000630D _text$mn        ends
.text$mn:0000630D
.text$mn:00006310 ; ===========================================================================
.text$mn:00006310
.text$mn:00006310 ; Segment type: Pure code
.text$mn:00006310 ; Segment permissions: Read/Execute
.text$mn:00006310 _text$mn        segment para public 'CODE' use32
.text$mn:00006310                 assume cs:_text$mn
.text$mn:00006310                 ;org 6310h
.text$mn:00006310 ; COMDAT (pick any)
.text$mn:00006310                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006310
.text$mn:00006310 ; =============== S U B R O U T I N E =======================================
.text$mn:00006310
.text$mn:00006310 ; Attributes: bp-based frame
.text$mn:00006310
.text$mn:00006310 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:00006310                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00006310 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:00006310                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:00006310
.text$mn:00006310 var_4           = dword ptr -4
.text$mn:00006310
.text$mn:00006310                 push    ebp
.text$mn:00006311                 mov     ebp, esp
.text$mn:00006313                 push    ecx
.text$mn:00006314                 mov     [ebp+var_4], ecx
.text$mn:00006317                 mov     ecx, [ebp+var_4]
.text$mn:0000631A                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000631F                 mov     eax, [ebp+var_4]
.text$mn:00006322                 mov     esp, ebp
.text$mn:00006324                 pop     ebp
.text$mn:00006325                 retn
.text$mn:00006325 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00006325
.text$mn:00006325 ; ---------------------------------------------------------------------------
.text$mn:00006326                 align 4
.text$mn:00006326 _text$mn        ends
.text$mn:00006326
.text$mn:00006328 ; ===========================================================================
.text$mn:00006328
.text$mn:00006328 ; Segment type: Pure code
.text$mn:00006328 ; Segment permissions: Read/Execute
.text$mn:00006328 _text$mn        segment para public 'CODE' use32
.text$mn:00006328                 assume cs:_text$mn
.text$mn:00006328                 ;org 6328h
.text$mn:00006328 ; COMDAT (pick any)
.text$mn:00006328                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006328
.text$mn:00006328 ; =============== S U B R O U T I N E =======================================
.text$mn:00006328
.text$mn:00006328 ; Attributes: bp-based frame
.text$mn:00006328
.text$mn:00006328 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00006328                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00006328 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00006328                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp ...
.text$mn:00006328
.text$mn:00006328 var_4           = dword ptr -4
.text$mn:00006328
.text$mn:00006328                 push    ebp
.text$mn:00006329                 mov     ebp, esp
.text$mn:0000632B                 push    ecx
.text$mn:0000632C                 mov     [ebp+var_4], ecx
.text$mn:0000632F                 mov     eax, [ebp+var_4]
.text$mn:00006332                 mov     esp, ebp
.text$mn:00006334                 pop     ebp
.text$mn:00006335                 retn
.text$mn:00006335 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00006335
.text$mn:00006335 ; ---------------------------------------------------------------------------
.text$mn:00006336                 align 4
.text$mn:00006336 _text$mn        ends
.text$mn:00006336
.text$mn:00006338 ; ===========================================================================
.text$mn:00006338
.text$mn:00006338 ; Segment type: Pure code
.text$mn:00006338 ; Segment permissions: Read/Execute
.text$mn:00006338 _text$mn        segment para public 'CODE' use32
.text$mn:00006338                 assume cs:_text$mn
.text$mn:00006338                 ;org 6338h
.text$mn:00006338 ; COMDAT (pick any)
.text$mn:00006338                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006338
.text$mn:00006338 ; =============== S U B R O U T I N E =======================================
.text$mn:00006338
.text$mn:00006338 ; Attributes: bp-based frame
.text$mn:00006338
.text$mn:00006338 ; public: __thiscall std::allocator<unsigned int>::allocator<unsigned int>(void)
.text$mn:00006338                 public ??0?$allocator@I@std@@QAE@XZ
.text$mn:00006338 ??0?$allocator@I@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::_Wrap_alloc<std::allocator<uint>>(void)+Ap
.text$mn:00006338                                         ; std::deque<uint,std::allocator<uint>>::deque<uint,std::allocator<uint>>(void)+2Bp
.text$mn:00006338
.text$mn:00006338 var_4           = dword ptr -4
.text$mn:00006338
.text$mn:00006338                 push    ebp
.text$mn:00006339                 mov     ebp, esp
.text$mn:0000633B                 push    ecx
.text$mn:0000633C                 mov     [ebp+var_4], ecx
.text$mn:0000633F                 mov     eax, [ebp+var_4]
.text$mn:00006342                 mov     esp, ebp
.text$mn:00006344                 pop     ebp
.text$mn:00006345                 retn
.text$mn:00006345 ??0?$allocator@I@std@@QAE@XZ endp
.text$mn:00006345
.text$mn:00006345 ; ---------------------------------------------------------------------------
.text$mn:00006346                 align 4
.text$mn:00006346 _text$mn        ends
.text$mn:00006346
.text$mn:00006348 ; ===========================================================================
.text$mn:00006348
.text$mn:00006348 ; Segment type: Pure code
.text$mn:00006348 ; Segment permissions: Read/Execute
.text$mn:00006348 _text$mn        segment para public 'CODE' use32
.text$mn:00006348                 assume cs:_text$mn
.text$mn:00006348                 ;org 6348h
.text$mn:00006348 ; COMDAT (pick any)
.text$mn:00006348                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006348
.text$mn:00006348 ; =============== S U B R O U T I N E =======================================
.text$mn:00006348
.text$mn:00006348 ; Attributes: bp-based frame
.text$mn:00006348
.text$mn:00006348 ; public: __thiscall std::allocator<struct MenuItemUnit>::allocator<struct MenuItemUnit>(void)
.text$mn:00006348                 public ??0?$allocator@UMenuItemUnit@@@std@@QAE@XZ
.text$mn:00006348 ??0?$allocator@UMenuItemUnit@@@std@@QAE@XZ proc near
.text$mn:00006348                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MenuItemUnit>>::_Wrap_alloc<std::allocator<MenuItemUnit>>(void)+Ap
.text$mn:00006348                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)+2Bp
.text$mn:00006348
.text$mn:00006348 var_4           = dword ptr -4
.text$mn:00006348
.text$mn:00006348                 push    ebp
.text$mn:00006349                 mov     ebp, esp
.text$mn:0000634B                 push    ecx
.text$mn:0000634C                 mov     [ebp+var_4], ecx
.text$mn:0000634F                 mov     eax, [ebp+var_4]
.text$mn:00006352                 mov     esp, ebp
.text$mn:00006354                 pop     ebp
.text$mn:00006355                 retn
.text$mn:00006355 ??0?$allocator@UMenuItemUnit@@@std@@QAE@XZ endp
.text$mn:00006355
.text$mn:00006355 ; ---------------------------------------------------------------------------
.text$mn:00006356                 align 4
.text$mn:00006356 _text$mn        ends
.text$mn:00006356
.text$mn:00006358 ; ===========================================================================
.text$mn:00006358
.text$mn:00006358 ; Segment type: Pure code
.text$mn:00006358 ; Segment permissions: Read/Execute
.text$mn:00006358 _text$mn        segment para public 'CODE' use32
.text$mn:00006358                 assume cs:_text$mn
.text$mn:00006358                 ;org 6358h
.text$mn:00006358 ; COMDAT (pick any)
.text$mn:00006358                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006358
.text$mn:00006358 ; =============== S U B R O U T I N E =======================================
.text$mn:00006358
.text$mn:00006358 ; Attributes: bp-based frame
.text$mn:00006358
.text$mn:00006358 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00006358                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00006358 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00006358                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:00006358                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00006358
.text$mn:00006358 var_4           = dword ptr -4
.text$mn:00006358
.text$mn:00006358                 push    ebp
.text$mn:00006359                 mov     ebp, esp
.text$mn:0000635B                 push    ecx
.text$mn:0000635C                 mov     [ebp+var_4], ecx
.text$mn:0000635F                 mov     eax, [ebp+var_4]
.text$mn:00006362                 mov     esp, ebp
.text$mn:00006364                 pop     ebp
.text$mn:00006365                 retn
.text$mn:00006365 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00006365
.text$mn:00006365 ; ---------------------------------------------------------------------------
.text$mn:00006366                 align 4
.text$mn:00006366 _text$mn        ends
.text$mn:00006366
.text$mn:00006368 ; ===========================================================================
.text$mn:00006368
.text$mn:00006368 ; Segment type: Pure code
.text$mn:00006368 ; Segment permissions: Read/Execute
.text$mn:00006368 _text$mn        segment para public 'CODE' use32
.text$mn:00006368                 assume cs:_text$mn
.text$mn:00006368                 ;org 6368h
.text$mn:00006368 ; COMDAT (pick any)
.text$mn:00006368                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006368
.text$mn:00006368 ; =============== S U B R O U T I N E =======================================
.text$mn:00006368
.text$mn:00006368 ; Attributes: bp-based frame
.text$mn:00006368
.text$mn:00006368 ; public: __thiscall std::allocator<struct recordedMacroStep>::allocator<struct recordedMacroStep>(void)
.text$mn:00006368                 public ??0?$allocator@UrecordedMacroStep@@@std@@QAE@XZ
.text$mn:00006368 ??0?$allocator@UrecordedMacroStep@@@std@@QAE@XZ proc near
.text$mn:00006368                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::_Wrap_alloc<std::allocator<recordedMacroStep>>(void)+Ap
.text$mn:00006368
.text$mn:00006368 var_4           = dword ptr -4
.text$mn:00006368
.text$mn:00006368                 push    ebp
.text$mn:00006369                 mov     ebp, esp
.text$mn:0000636B                 push    ecx
.text$mn:0000636C                 mov     [ebp+var_4], ecx
.text$mn:0000636F                 mov     eax, [ebp+var_4]
.text$mn:00006372                 mov     esp, ebp
.text$mn:00006374                 pop     ebp
.text$mn:00006375                 retn
.text$mn:00006375 ??0?$allocator@UrecordedMacroStep@@@std@@QAE@XZ endp
.text$mn:00006375
.text$mn:00006375 ; ---------------------------------------------------------------------------
.text$mn:00006376                 align 4
.text$mn:00006376 _text$mn        ends
.text$mn:00006376
.text$mn:00006378 ; ===========================================================================
.text$mn:00006378
.text$mn:00006378 ; Segment type: Pure code
.text$mn:00006378 ; Segment permissions: Read/Execute
.text$mn:00006378 _text$mn        segment para public 'CODE' use32
.text$mn:00006378                 assume cs:_text$mn
.text$mn:00006378                 ;org 6378h
.text$mn:00006378 ; COMDAT (pick any)
.text$mn:00006378                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006378
.text$mn:00006378 ; =============== S U B R O U T I N E =======================================
.text$mn:00006378
.text$mn:00006378 ; Attributes: bp-based frame
.text$mn:00006378
.text$mn:00006378 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(class std::allocator<wchar_t> const &)
.text$mn:00006378                 public ??0?$allocator@_W@std@@QAE@ABV01@@Z
.text$mn:00006378 ??0?$allocator@_W@std@@QAE@ABV01@@Z proc near
.text$mn:00006378                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(std::allocator<wchar_t> const &)+Ep
.text$mn:00006378                                         ; std::allocator<wchar_t>::select_on_container_copy_construction(void)+Ep
.text$mn:00006378
.text$mn:00006378 var_4           = dword ptr -4
.text$mn:00006378
.text$mn:00006378                 push    ebp
.text$mn:00006379                 mov     ebp, esp
.text$mn:0000637B                 push    ecx
.text$mn:0000637C                 mov     [ebp+var_4], ecx
.text$mn:0000637F                 mov     eax, [ebp+var_4]
.text$mn:00006382                 mov     esp, ebp
.text$mn:00006384                 pop     ebp
.text$mn:00006385                 retn    4
.text$mn:00006385 ??0?$allocator@_W@std@@QAE@ABV01@@Z endp
.text$mn:00006385
.text$mn:00006385 _text$mn        ends
.text$mn:00006385
.text$mn:00006388 ; ===========================================================================
.text$mn:00006388
.text$mn:00006388 ; Segment type: Pure code
.text$mn:00006388 ; Segment permissions: Read/Execute
.text$mn:00006388 _text$mn        segment para public 'CODE' use32
.text$mn:00006388                 assume cs:_text$mn
.text$mn:00006388                 ;org 6388h
.text$mn:00006388 ; COMDAT (pick any)
.text$mn:00006388                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006388
.text$mn:00006388 ; =============== S U B R O U T I N E =======================================
.text$mn:00006388
.text$mn:00006388 ; Attributes: bp-based frame
.text$mn:00006388
.text$mn:00006388 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00006388                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:00006388 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:00006388                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+2Bp ...
.text$mn:00006388
.text$mn:00006388 var_4           = dword ptr -4
.text$mn:00006388
.text$mn:00006388                 push    ebp
.text$mn:00006389                 mov     ebp, esp
.text$mn:0000638B                 push    ecx
.text$mn:0000638C                 mov     [ebp+var_4], ecx
.text$mn:0000638F                 mov     eax, [ebp+var_4]
.text$mn:00006392                 mov     esp, ebp
.text$mn:00006394                 pop     ebp
.text$mn:00006395                 retn
.text$mn:00006395 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00006395
.text$mn:00006395 ; ---------------------------------------------------------------------------
.text$mn:00006396                 align 4
.text$mn:00006396 _text$mn        ends
.text$mn:00006396
.text$mn:00006398 ; ===========================================================================
.text$mn:00006398
.text$mn:00006398 ; Segment type: Pure code
.text$mn:00006398 ; Segment permissions: Read/Execute
.text$mn:00006398 _text$mn        segment para public 'CODE' use32
.text$mn:00006398                 assume cs:_text$mn
.text$mn:00006398                 ;org 6398h
.text$mn:00006398 ; COMDAT (pick any)
.text$mn:00006398                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006398
.text$mn:00006398 ; =============== S U B R O U T I N E =======================================
.text$mn:00006398
.text$mn:00006398 ; Attributes: bp-based frame
.text$mn:00006398
.text$mn:00006398 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00006398                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00006398 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00006398                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00006398                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00006398
.text$mn:00006398 var_14          = dword ptr -14h
.text$mn:00006398 var_D           = byte ptr -0Dh
.text$mn:00006398 var_C           = dword ptr -0Ch
.text$mn:00006398 var_4           = dword ptr -4
.text$mn:00006398 Str             = dword ptr  8
.text$mn:00006398
.text$mn:00006398                 push    ebp
.text$mn:00006399                 mov     ebp, esp
.text$mn:0000639B                 push    0FFFFFFFFh
.text$mn:0000639D                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000063A2                 mov     eax, large fs:0
.text$mn:000063A8                 push    eax
.text$mn:000063A9                 sub     esp, 8
.text$mn:000063AC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000063B1                 xor     eax, ebp
.text$mn:000063B3                 push    eax
.text$mn:000063B4                 lea     eax, [ebp+var_C]
.text$mn:000063B7                 mov     large fs:0, eax
.text$mn:000063BD                 mov     [ebp+var_14], ecx
.text$mn:000063C0                 lea     ecx, [ebp+var_D]
.text$mn:000063C3                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000063C8                 push    eax
.text$mn:000063C9                 mov     ecx, [ebp+var_14]
.text$mn:000063CC                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000063D1                 mov     [ebp+var_4], 0
.text$mn:000063D8                 push    0               ; Size
.text$mn:000063DA                 push    0               ; char
.text$mn:000063DC                 mov     ecx, [ebp+var_14]
.text$mn:000063DF                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000063E4                 mov     eax, [ebp+Str]
.text$mn:000063E7                 push    eax             ; Str
.text$mn:000063E8                 mov     ecx, [ebp+var_14]
.text$mn:000063EB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000063F0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000063F7                 mov     eax, [ebp+var_14]
.text$mn:000063FA                 mov     ecx, [ebp+var_C]
.text$mn:000063FD                 mov     large fs:0, ecx
.text$mn:00006404                 pop     ecx
.text$mn:00006405                 mov     esp, ebp
.text$mn:00006407                 pop     ebp
.text$mn:00006408                 retn    4
.text$mn:00006408 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00006408
.text$mn:00006408 ; ---------------------------------------------------------------------------
.text$mn:0000640B                 align 4
.text$mn:0000640B _text$mn        ends
.text$mn:0000640B
.text$x:0000640C ; ===========================================================================
.text$x:0000640C
.text$x:0000640C ; Segment type: Pure code
.text$x:0000640C ; Segment permissions: Read/Execute
.text$x:0000640C _text$x         segment para public 'CODE' use32
.text$x:0000640C                 assume cs:_text$x
.text$x:0000640C                 ;org 640Ch
.text$x:0000640C ; COMDAT (pick associative to section at 6398)
.text$x:0000640C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000640C
.text$x:0000640C ; =============== S U B R O U T I N E =======================================
.text$x:0000640C
.text$x:0000640C
.text$x:0000640C __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:0000640C                                         ; DATA XREF: .xdata$x:0000B5C4o
.text$x:0000640C                 mov     ecx, [ebp-14h]
.text$x:0000640F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000640F __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:0000640F
.text$x:00006414
.text$x:00006414 ; =============== S U B R O U T I N E =======================================
.text$x:00006414
.text$x:00006414
.text$x:00006414 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00006414                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00006414
.text$x:00006414 arg_4           = dword ptr  8
.text$x:00006414
.text$x:00006414                 mov     edx, [esp+arg_4]
.text$x:00006418                 lea     eax, [edx+0Ch]
.text$x:0000641B                 mov     ecx, [edx-0Ch]
.text$x:0000641E                 xor     ecx, eax
.text$x:00006420                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006425                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:0000642A                 jmp     ___CxxFrameHandler3
.text$x:0000642A __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:0000642A
.text$x:0000642A ; ---------------------------------------------------------------------------
.text$x:0000642F                 align 10h
.text$x:0000642F _text$x         ends
.text$x:0000642F
.text$mn:00006430 ; ===========================================================================
.text$mn:00006430
.text$mn:00006430 ; Segment type: Pure code
.text$mn:00006430 ; Segment permissions: Read/Execute
.text$mn:00006430 _text$mn        segment para public 'CODE' use32
.text$mn:00006430                 assume cs:_text$mn
.text$mn:00006430                 ;org 6430h
.text$mn:00006430 ; COMDAT (pick any)
.text$mn:00006430                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006430
.text$mn:00006430 ; =============== S U B R O U T I N E =======================================
.text$mn:00006430
.text$mn:00006430 ; Attributes: bp-based frame
.text$mn:00006430
.text$mn:00006430 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00006430                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00006430 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00006430                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2201p
.text$mn:00006430
.text$mn:00006430 var_14          = dword ptr -14h
.text$mn:00006430 var_D           = byte ptr -0Dh
.text$mn:00006430 var_C           = dword ptr -0Ch
.text$mn:00006430 var_4           = dword ptr -4
.text$mn:00006430
.text$mn:00006430                 push    ebp
.text$mn:00006431                 mov     ebp, esp
.text$mn:00006433                 push    0FFFFFFFFh
.text$mn:00006435                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000643A                 mov     eax, large fs:0
.text$mn:00006440                 push    eax
.text$mn:00006441                 sub     esp, 8
.text$mn:00006444                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006449                 xor     eax, ebp
.text$mn:0000644B                 push    eax
.text$mn:0000644C                 lea     eax, [ebp+var_C]
.text$mn:0000644F                 mov     large fs:0, eax
.text$mn:00006455                 mov     [ebp+var_14], ecx
.text$mn:00006458                 lea     ecx, [ebp+var_D]
.text$mn:0000645B                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00006460                 push    eax
.text$mn:00006461                 mov     ecx, [ebp+var_14]
.text$mn:00006464                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00006469                 mov     [ebp+var_4], 0
.text$mn:00006470                 push    0               ; Size
.text$mn:00006472                 push    0               ; char
.text$mn:00006474                 mov     ecx, [ebp+var_14]
.text$mn:00006477                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000647C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006483                 mov     eax, [ebp+var_14]
.text$mn:00006486                 mov     ecx, [ebp+var_C]
.text$mn:00006489                 mov     large fs:0, ecx
.text$mn:00006490                 pop     ecx
.text$mn:00006491                 mov     esp, ebp
.text$mn:00006493                 pop     ebp
.text$mn:00006494                 retn
.text$mn:00006494 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00006494
.text$mn:00006494 ; ---------------------------------------------------------------------------
.text$mn:00006495                 align 4
.text$mn:00006495 _text$mn        ends
.text$mn:00006495
.text$x:00006498 ; ===========================================================================
.text$x:00006498
.text$x:00006498 ; Segment type: Pure code
.text$x:00006498 ; Segment permissions: Read/Execute
.text$x:00006498 _text$x         segment para public 'CODE' use32
.text$x:00006498                 assume cs:_text$x
.text$x:00006498                 ;org 6498h
.text$x:00006498 ; COMDAT (pick associative to section at 6430)
.text$x:00006498                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006498
.text$x:00006498 ; =============== S U B R O U T I N E =======================================
.text$x:00006498
.text$x:00006498
.text$x:00006498 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00006498                                         ; DATA XREF: .xdata$x:0000B598o
.text$x:00006498                 mov     ecx, [ebp-14h]
.text$x:0000649B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000649B __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000649B
.text$x:000064A0
.text$x:000064A0 ; =============== S U B R O U T I N E =======================================
.text$x:000064A0
.text$x:000064A0
.text$x:000064A0 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:000064A0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:000064A0
.text$x:000064A0 arg_4           = dword ptr  8
.text$x:000064A0
.text$x:000064A0                 mov     edx, [esp+arg_4]
.text$x:000064A4                 lea     eax, [edx+0Ch]
.text$x:000064A7                 mov     ecx, [edx-0Ch]
.text$x:000064AA                 xor     ecx, eax
.text$x:000064AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000064B1                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:000064B6                 jmp     ___CxxFrameHandler3
.text$x:000064B6 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:000064B6
.text$x:000064B6 ; ---------------------------------------------------------------------------
.text$x:000064BB                 align 4
.text$x:000064BB _text$x         ends
.text$x:000064BB
.text$mn:000064BC ; ===========================================================================
.text$mn:000064BC
.text$mn:000064BC ; Segment type: Pure code
.text$mn:000064BC ; Segment permissions: Read/Execute
.text$mn:000064BC _text$mn        segment para public 'CODE' use32
.text$mn:000064BC                 assume cs:_text$mn
.text$mn:000064BC                 ;org 64BCh
.text$mn:000064BC ; COMDAT (pick any)
.text$mn:000064BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000064BC
.text$mn:000064BC ; =============== S U B R O U T I N E =======================================
.text$mn:000064BC
.text$mn:000064BC ; Attributes: bp-based frame
.text$mn:000064BC
.text$mn:000064BC ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:000064BC                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:000064BC ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$mn:000064BC                                         ; CODE XREF: MenuItemUnit::MenuItemUnit(MenuItemUnit const &)+3Dp
.text$mn:000064BC                                         ; MenuItemUnit::MenuItemUnit(MenuItemUnit const &)+56p ...
.text$mn:000064BC
.text$mn:000064BC var_14          = dword ptr -14h
.text$mn:000064BC var_E           = byte ptr -0Eh
.text$mn:000064BC var_D           = byte ptr -0Dh
.text$mn:000064BC var_C           = dword ptr -0Ch
.text$mn:000064BC var_4           = dword ptr -4
.text$mn:000064BC arg_0           = dword ptr  8
.text$mn:000064BC
.text$mn:000064BC                 push    ebp
.text$mn:000064BD                 mov     ebp, esp
.text$mn:000064BF                 push    0FFFFFFFFh
.text$mn:000064C1                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:000064C6                 mov     eax, large fs:0
.text$mn:000064CC                 push    eax
.text$mn:000064CD                 sub     esp, 8
.text$mn:000064D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000064D5                 xor     eax, ebp
.text$mn:000064D7                 push    eax
.text$mn:000064D8                 lea     eax, [ebp+var_C]
.text$mn:000064DB                 mov     large fs:0, eax
.text$mn:000064E1                 mov     [ebp+var_14], ecx
.text$mn:000064E4                 lea     eax, [ebp+var_D]
.text$mn:000064E7                 push    eax
.text$mn:000064E8                 lea     ecx, [ebp+var_E]
.text$mn:000064EB                 push    ecx
.text$mn:000064EC                 mov     ecx, [ebp+arg_0]
.text$mn:000064EF                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000064F4                 mov     ecx, eax
.text$mn:000064F6                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)
.text$mn:000064FB                 push    eax
.text$mn:000064FC                 mov     ecx, [ebp+var_14]
.text$mn:000064FF                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00006504                 mov     [ebp+var_4], 0
.text$mn:0000650B                 push    0
.text$mn:0000650D                 push    0
.text$mn:0000650F                 mov     ecx, [ebp+var_14]
.text$mn:00006512                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00006517                 mov     edx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000651D                 push    edx
.text$mn:0000651E                 push    0
.text$mn:00006520                 mov     eax, [ebp+arg_0]
.text$mn:00006523                 push    eax
.text$mn:00006524                 mov     ecx, [ebp+var_14]
.text$mn:00006527                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000652C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006533                 mov     eax, [ebp+var_14]
.text$mn:00006536                 mov     ecx, [ebp+var_C]
.text$mn:00006539                 mov     large fs:0, ecx
.text$mn:00006540                 pop     ecx
.text$mn:00006541                 mov     esp, ebp
.text$mn:00006543                 pop     ebp
.text$mn:00006544                 retn    4
.text$mn:00006544 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$mn:00006544
.text$mn:00006544 ; ---------------------------------------------------------------------------
.text$mn:00006547                 align 4
.text$mn:00006547 _text$mn        ends
.text$mn:00006547
.text$x:00006548 ; ===========================================================================
.text$x:00006548
.text$x:00006548 ; Segment type: Pure code
.text$x:00006548 ; Segment permissions: Read/Execute
.text$x:00006548 _text$x         segment para public 'CODE' use32
.text$x:00006548                 assume cs:_text$x
.text$x:00006548                 ;org 6548h
.text$x:00006548 ; COMDAT (pick associative to section at 64BC)
.text$x:00006548                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006548
.text$x:00006548 ; =============== S U B R O U T I N E =======================================
.text$x:00006548
.text$x:00006548
.text$x:00006548 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00006548                                         ; DATA XREF: .xdata$x:0000B8E4o
.text$x:00006548                 mov     ecx, [ebp-14h]
.text$x:0000654B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000654B __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000654B
.text$x:00006550
.text$x:00006550 ; =============== S U B R O U T I N E =======================================
.text$x:00006550
.text$x:00006550
.text$x:00006550 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$x:00006550                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:00006550
.text$x:00006550 arg_4           = dword ptr  8
.text$x:00006550
.text$x:00006550                 mov     edx, [esp+arg_4]
.text$x:00006554                 lea     eax, [edx+0Ch]
.text$x:00006557                 mov     ecx, [edx-0Ch]
.text$x:0000655A                 xor     ecx, eax
.text$x:0000655C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006561                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$x:00006566                 jmp     ___CxxFrameHandler3
.text$x:00006566 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$x:00006566
.text$x:00006566 ; ---------------------------------------------------------------------------
.text$x:0000656B                 align 4
.text$x:0000656B _text$x         ends
.text$x:0000656B
.text$mn:0000656C ; ===========================================================================
.text$mn:0000656C
.text$mn:0000656C ; Segment type: Pure code
.text$mn:0000656C ; Segment permissions: Read/Execute
.text$mn:0000656C _text$mn        segment para public 'CODE' use32
.text$mn:0000656C                 assume cs:_text$mn
.text$mn:0000656C                 ;org 656Ch
.text$mn:0000656C ; COMDAT (pick any)
.text$mn:0000656C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000656C
.text$mn:0000656C ; =============== S U B R O U T I N E =======================================
.text$mn:0000656C
.text$mn:0000656C ; Attributes: bp-based frame
.text$mn:0000656C
.text$mn:0000656C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:0000656C                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:0000656C ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:0000656C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+8BDp
.text$mn:0000656C                                         ; Notepad_plus::notify(SCNotification *)+29EEp
.text$mn:0000656C
.text$mn:0000656C var_14          = dword ptr -14h
.text$mn:0000656C var_D           = byte ptr -0Dh
.text$mn:0000656C var_C           = dword ptr -0Ch
.text$mn:0000656C var_4           = dword ptr -4
.text$mn:0000656C Str             = dword ptr  8
.text$mn:0000656C
.text$mn:0000656C                 push    ebp
.text$mn:0000656D                 mov     ebp, esp
.text$mn:0000656F                 push    0FFFFFFFFh
.text$mn:00006571                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:00006576                 mov     eax, large fs:0
.text$mn:0000657C                 push    eax
.text$mn:0000657D                 sub     esp, 8
.text$mn:00006580                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006585                 xor     eax, ebp
.text$mn:00006587                 push    eax
.text$mn:00006588                 lea     eax, [ebp+var_C]
.text$mn:0000658B                 mov     large fs:0, eax
.text$mn:00006591                 mov     [ebp+var_14], ecx
.text$mn:00006594                 lea     ecx, [ebp+var_D]
.text$mn:00006597                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000659C                 push    eax
.text$mn:0000659D                 mov     ecx, [ebp+var_14]
.text$mn:000065A0                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:000065A5                 mov     [ebp+var_4], 0
.text$mn:000065AC                 push    0
.text$mn:000065AE                 push    0
.text$mn:000065B0                 mov     ecx, [ebp+var_14]
.text$mn:000065B3                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000065B8                 mov     eax, [ebp+Str]
.text$mn:000065BB                 push    eax             ; Str
.text$mn:000065BC                 mov     ecx, [ebp+var_14]
.text$mn:000065BF                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:000065C4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000065CB                 mov     eax, [ebp+var_14]
.text$mn:000065CE                 mov     ecx, [ebp+var_C]
.text$mn:000065D1                 mov     large fs:0, ecx
.text$mn:000065D8                 pop     ecx
.text$mn:000065D9                 mov     esp, ebp
.text$mn:000065DB                 pop     ebp
.text$mn:000065DC                 retn    4
.text$mn:000065DC ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:000065DC
.text$mn:000065DC ; ---------------------------------------------------------------------------
.text$mn:000065DF                 align 10h
.text$mn:000065DF _text$mn        ends
.text$mn:000065DF
.text$x:000065E0 ; ===========================================================================
.text$x:000065E0
.text$x:000065E0 ; Segment type: Pure code
.text$x:000065E0 ; Segment permissions: Read/Execute
.text$x:000065E0 _text$x         segment para public 'CODE' use32
.text$x:000065E0                 assume cs:_text$x
.text$x:000065E0                 ;org 65E0h
.text$x:000065E0 ; COMDAT (pick associative to section at 656C)
.text$x:000065E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000065E0
.text$x:000065E0 ; =============== S U B R O U T I N E =======================================
.text$x:000065E0
.text$x:000065E0
.text$x:000065E0 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:000065E0                                         ; DATA XREF: .xdata$x:0000B93Co
.text$x:000065E0                 mov     ecx, [ebp-14h]
.text$x:000065E3                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000065E3 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:000065E3
.text$x:000065E8
.text$x:000065E8 ; =============== S U B R O U T I N E =======================================
.text$x:000065E8
.text$x:000065E8
.text$x:000065E8 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:000065E8                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:000065E8
.text$x:000065E8 arg_4           = dword ptr  8
.text$x:000065E8
.text$x:000065E8                 mov     edx, [esp+arg_4]
.text$x:000065EC                 lea     eax, [edx+0Ch]
.text$x:000065EF                 mov     ecx, [edx-0Ch]
.text$x:000065F2                 xor     ecx, eax
.text$x:000065F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000065F9                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:000065FE                 jmp     ___CxxFrameHandler3
.text$x:000065FE __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:000065FE
.text$x:000065FE ; ---------------------------------------------------------------------------
.text$x:00006603                 align 4
.text$x:00006603 _text$x         ends
.text$x:00006603
.text$mn:00006604 ; ===========================================================================
.text$mn:00006604
.text$mn:00006604 ; Segment type: Pure code
.text$mn:00006604 ; Segment permissions: Read/Execute
.text$mn:00006604 _text$mn        segment para public 'CODE' use32
.text$mn:00006604                 assume cs:_text$mn
.text$mn:00006604                 ;org 6604h
.text$mn:00006604 ; COMDAT (pick any)
.text$mn:00006604                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006604
.text$mn:00006604 ; =============== S U B R O U T I N E =======================================
.text$mn:00006604
.text$mn:00006604 ; Attributes: bp-based frame
.text$mn:00006604
.text$mn:00006604 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00006604                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00006604 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00006604                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+A25p
.text$mn:00006604                                         ; Notepad_plus::notify(SCNotification *)+A34p
.text$mn:00006604
.text$mn:00006604 var_14          = dword ptr -14h
.text$mn:00006604 var_D           = byte ptr -0Dh
.text$mn:00006604 var_C           = dword ptr -0Ch
.text$mn:00006604 var_4           = dword ptr -4
.text$mn:00006604
.text$mn:00006604                 push    ebp
.text$mn:00006605                 mov     ebp, esp
.text$mn:00006607                 push    0FFFFFFFFh
.text$mn:00006609                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000660E                 mov     eax, large fs:0
.text$mn:00006614                 push    eax
.text$mn:00006615                 sub     esp, 8
.text$mn:00006618                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000661D                 xor     eax, ebp
.text$mn:0000661F                 push    eax
.text$mn:00006620                 lea     eax, [ebp+var_C]
.text$mn:00006623                 mov     large fs:0, eax
.text$mn:00006629                 mov     [ebp+var_14], ecx
.text$mn:0000662C                 lea     ecx, [ebp+var_D]
.text$mn:0000662F                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00006634                 push    eax
.text$mn:00006635                 mov     ecx, [ebp+var_14]
.text$mn:00006638                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:0000663D                 mov     [ebp+var_4], 0
.text$mn:00006644                 push    0
.text$mn:00006646                 push    0
.text$mn:00006648                 mov     ecx, [ebp+var_14]
.text$mn:0000664B                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00006650                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006657                 mov     eax, [ebp+var_14]
.text$mn:0000665A                 mov     ecx, [ebp+var_C]
.text$mn:0000665D                 mov     large fs:0, ecx
.text$mn:00006664                 pop     ecx
.text$mn:00006665                 mov     esp, ebp
.text$mn:00006667                 pop     ebp
.text$mn:00006668                 retn
.text$mn:00006668 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00006668
.text$mn:00006668 ; ---------------------------------------------------------------------------
.text$mn:00006669                 align 4
.text$mn:00006669 _text$mn        ends
.text$mn:00006669
.text$x:0000666C ; ===========================================================================
.text$x:0000666C
.text$x:0000666C ; Segment type: Pure code
.text$x:0000666C ; Segment permissions: Read/Execute
.text$x:0000666C _text$x         segment para public 'CODE' use32
.text$x:0000666C                 assume cs:_text$x
.text$x:0000666C                 ;org 666Ch
.text$x:0000666C ; COMDAT (pick associative to section at 6604)
.text$x:0000666C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000666C
.text$x:0000666C ; =============== S U B R O U T I N E =======================================
.text$x:0000666C
.text$x:0000666C
.text$x:0000666C __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:0000666C                                         ; DATA XREF: .xdata$x:0000B910o
.text$x:0000666C                 mov     ecx, [ebp-14h]
.text$x:0000666F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000666F __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:0000666F
.text$x:00006674
.text$x:00006674 ; =============== S U B R O U T I N E =======================================
.text$x:00006674
.text$x:00006674
.text$x:00006674 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:00006674                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:00006674
.text$x:00006674 arg_4           = dword ptr  8
.text$x:00006674
.text$x:00006674                 mov     edx, [esp+arg_4]
.text$x:00006678                 lea     eax, [edx+0Ch]
.text$x:0000667B                 mov     ecx, [edx-0Ch]
.text$x:0000667E                 xor     ecx, eax
.text$x:00006680                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006685                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:0000668A                 jmp     ___CxxFrameHandler3
.text$x:0000668A __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:0000668A
.text$x:0000668A ; ---------------------------------------------------------------------------
.text$x:0000668F                 align 10h
.text$x:0000668F _text$x         ends
.text$x:0000668F
.text$mn:00006690 ; ===========================================================================
.text$mn:00006690
.text$mn:00006690 ; Segment type: Pure code
.text$mn:00006690 ; Segment permissions: Read/Execute
.text$mn:00006690 _text$mn        segment para public 'CODE' use32
.text$mn:00006690                 assume cs:_text$mn
.text$mn:00006690                 ;org 6690h
.text$mn:00006690 ; COMDAT (pick any)
.text$mn:00006690                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006690
.text$mn:00006690 ; =============== S U B R O U T I N E =======================================
.text$mn:00006690
.text$mn:00006690 ; Attributes: bp-based frame
.text$mn:00006690
.text$mn:00006690 ; public: __thiscall std::deque<unsigned int, class std::allocator<unsigned int>>::deque<unsigned int, class std::allocator<unsigned int>>(void)
.text$mn:00006690                 public ??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ
.text$mn:00006690 ??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ proc near
.text$mn:00006690                                         ; CODE XREF: std::stack<uint,std::deque<uint,std::allocator<uint>>>::stack<uint,std::deque<uint,std::allocator<uint>>>(void)+29p
.text$mn:00006690
.text$mn:00006690 var_14          = dword ptr -14h
.text$mn:00006690 var_D           = byte ptr -0Dh
.text$mn:00006690 var_C           = dword ptr -0Ch
.text$mn:00006690 var_4           = dword ptr -4
.text$mn:00006690
.text$mn:00006690                 push    ebp
.text$mn:00006691                 mov     ebp, esp
.text$mn:00006693                 push    0FFFFFFFFh
.text$mn:00006695                 push    offset __ehhandler$??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ
.text$mn:0000669A                 mov     eax, large fs:0
.text$mn:000066A0                 push    eax
.text$mn:000066A1                 sub     esp, 8
.text$mn:000066A4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000066A9                 xor     eax, ebp
.text$mn:000066AB                 push    eax
.text$mn:000066AC                 lea     eax, [ebp+var_C]
.text$mn:000066AF                 mov     large fs:0, eax
.text$mn:000066B5                 mov     [ebp+var_14], ecx
.text$mn:000066B8                 lea     ecx, [ebp+var_D]
.text$mn:000066BB                 call    ??0?$allocator@I@std@@QAE@XZ ; std::allocator<uint>::allocator<uint>(void)
.text$mn:000066C0                 push    eax
.text$mn:000066C1                 mov     ecx, [ebp+var_14]
.text$mn:000066C4                 call    ??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>(std::allocator<uint> const &)
.text$mn:000066C9                 mov     [ebp+var_4], 0
.text$mn:000066D0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000066D7                 mov     eax, [ebp+var_14]
.text$mn:000066DA                 mov     ecx, [ebp+var_C]
.text$mn:000066DD                 mov     large fs:0, ecx
.text$mn:000066E4                 pop     ecx
.text$mn:000066E5                 mov     esp, ebp
.text$mn:000066E7                 pop     ebp
.text$mn:000066E8                 retn
.text$mn:000066E8 ??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ endp
.text$mn:000066E8
.text$mn:000066E8 ; ---------------------------------------------------------------------------
.text$mn:000066E9                 align 4
.text$mn:000066E9 _text$mn        ends
.text$mn:000066E9
.text$x:000066EC ; ===========================================================================
.text$x:000066EC
.text$x:000066EC ; Segment type: Pure code
.text$x:000066EC ; Segment permissions: Read/Execute
.text$x:000066EC _text$x         segment para public 'CODE' use32
.text$x:000066EC                 assume cs:_text$x
.text$x:000066EC                 ;org 66ECh
.text$x:000066EC ; COMDAT (pick associative to section at 6690)
.text$x:000066EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000066EC
.text$x:000066EC ; =============== S U B R O U T I N E =======================================
.text$x:000066EC
.text$x:000066EC
.text$x:000066EC __unwindfunclet$??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ$0 proc near
.text$x:000066EC                                         ; DATA XREF: .xdata$x:0000BF30o
.text$x:000066EC                 mov     ecx, [ebp-14h]
.text$x:000066EF                 jmp     ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::~_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>(void)
.text$x:000066EF __unwindfunclet$??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ$0 endp
.text$x:000066EF
.text$x:000066F4
.text$x:000066F4 ; =============== S U B R O U T I N E =======================================
.text$x:000066F4
.text$x:000066F4
.text$x:000066F4 __ehhandler$??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ proc near
.text$x:000066F4                                         ; DATA XREF: std::deque<uint,std::allocator<uint>>::deque<uint,std::allocator<uint>>(void)+5o
.text$x:000066F4
.text$x:000066F4 arg_4           = dword ptr  8
.text$x:000066F4
.text$x:000066F4                 mov     edx, [esp+arg_4]
.text$x:000066F8                 lea     eax, [edx+0Ch]
.text$x:000066FB                 mov     ecx, [edx-0Ch]
.text$x:000066FE                 xor     ecx, eax
.text$x:00006700                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006705                 mov     eax, offset __ehfuncinfo$??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ
.text$x:0000670A                 jmp     ___CxxFrameHandler3
.text$x:0000670A __ehhandler$??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ endp
.text$x:0000670A
.text$x:0000670A ; ---------------------------------------------------------------------------
.text$x:0000670F                 align 10h
.text$x:0000670F _text$x         ends
.text$x:0000670F
.text$mn:00006710 ; ===========================================================================
.text$mn:00006710
.text$mn:00006710 ; Segment type: Pure code
.text$mn:00006710 ; Segment permissions: Read/Execute
.text$mn:00006710 _text$mn        segment para public 'CODE' use32
.text$mn:00006710                 assume cs:_text$mn
.text$mn:00006710                 ;org 6710h
.text$mn:00006710 ; COMDAT (pick any)
.text$mn:00006710                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006710
.text$mn:00006710 ; =============== S U B R O U T I N E =======================================
.text$mn:00006710
.text$mn:00006710 ; Attributes: bp-based frame
.text$mn:00006710
.text$mn:00006710 ; public: __thiscall std::stack<unsigned int, class std::deque<unsigned int, class std::allocator<unsigned int>>>::stack<unsigned int, class std::deque<unsigned int, class std::allocator<unsigned int>>>(void)
.text$mn:00006710                 public ??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$mn:00006710 ??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006710                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+251Cp
.text$mn:00006710
.text$mn:00006710 var_10          = dword ptr -10h
.text$mn:00006710 var_C           = dword ptr -0Ch
.text$mn:00006710 var_4           = dword ptr -4
.text$mn:00006710
.text$mn:00006710                 push    ebp
.text$mn:00006711                 mov     ebp, esp
.text$mn:00006713                 push    0FFFFFFFFh
.text$mn:00006715                 push    offset __ehhandler$??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$mn:0000671A                 mov     eax, large fs:0
.text$mn:00006720                 push    eax
.text$mn:00006721                 push    ecx
.text$mn:00006722                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006727                 xor     eax, ebp
.text$mn:00006729                 push    eax
.text$mn:0000672A                 lea     eax, [ebp+var_C]
.text$mn:0000672D                 mov     large fs:0, eax
.text$mn:00006733                 mov     [ebp+var_10], ecx
.text$mn:00006736                 mov     ecx, [ebp+var_10]
.text$mn:00006739                 call    ??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ ; std::deque<uint,std::allocator<uint>>::deque<uint,std::allocator<uint>>(void)
.text$mn:0000673E                 mov     [ebp+var_4], 0
.text$mn:00006745                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000674C                 mov     eax, [ebp+var_10]
.text$mn:0000674F                 mov     ecx, [ebp+var_C]
.text$mn:00006752                 mov     large fs:0, ecx
.text$mn:00006759                 pop     ecx
.text$mn:0000675A                 mov     esp, ebp
.text$mn:0000675C                 pop     ebp
.text$mn:0000675D                 retn
.text$mn:0000675D ??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000675D
.text$mn:0000675D ; ---------------------------------------------------------------------------
.text$mn:0000675E                 align 10h
.text$mn:0000675E _text$mn        ends
.text$mn:0000675E
.text$x:00006760 ; ===========================================================================
.text$x:00006760
.text$x:00006760 ; Segment type: Pure code
.text$x:00006760 ; Segment permissions: Read/Execute
.text$x:00006760 _text$x         segment para public 'CODE' use32
.text$x:00006760                 assume cs:_text$x
.text$x:00006760                 ;org 6760h
.text$x:00006760 ; COMDAT (pick associative to section at 6710)
.text$x:00006760                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006760
.text$x:00006760 ; =============== S U B R O U T I N E =======================================
.text$x:00006760
.text$x:00006760
.text$x:00006760 __unwindfunclet$??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006760                                         ; DATA XREF: .xdata$x:0000C014o
.text$x:00006760                 mov     ecx, [ebp-10h]
.text$x:00006763                 jmp     ??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ ; std::deque<uint,std::allocator<uint>>::~deque<uint,std::allocator<uint>>(void)
.text$x:00006763 __unwindfunclet$??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006763
.text$x:00006768
.text$x:00006768 ; =============== S U B R O U T I N E =======================================
.text$x:00006768
.text$x:00006768
.text$x:00006768 __ehhandler$??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006768                                         ; DATA XREF: std::stack<uint,std::deque<uint,std::allocator<uint>>>::stack<uint,std::deque<uint,std::allocator<uint>>>(void)+5o
.text$x:00006768
.text$x:00006768 arg_4           = dword ptr  8
.text$x:00006768
.text$x:00006768                 mov     edx, [esp+arg_4]
.text$x:0000676C                 lea     eax, [edx+0Ch]
.text$x:0000676F                 mov     ecx, [edx-8]
.text$x:00006772                 xor     ecx, eax
.text$x:00006774                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006779                 mov     eax, offset __ehfuncinfo$??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$x:0000677E                 jmp     ___CxxFrameHandler3
.text$x:0000677E __ehhandler$??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ endp
.text$x:0000677E
.text$x:0000677E ; ---------------------------------------------------------------------------
.text$x:00006783                 align 4
.text$x:00006783 _text$x         ends
.text$x:00006783
.text$mn:00006784 ; ===========================================================================
.text$mn:00006784
.text$mn:00006784 ; Segment type: Pure code
.text$mn:00006784 ; Segment permissions: Read/Execute
.text$mn:00006784 _text$mn        segment para public 'CODE' use32
.text$mn:00006784                 assume cs:_text$mn
.text$mn:00006784                 ;org 6784h
.text$mn:00006784 ; COMDAT (pick any)
.text$mn:00006784                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006784
.text$mn:00006784 ; =============== S U B R O U T I N E =======================================
.text$mn:00006784
.text$mn:00006784 ; Attributes: bp-based frame
.text$mn:00006784
.text$mn:00006784 ; public: __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>(void)
.text$mn:00006784                 public ??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:00006784 ??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$mn:00006784                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+68Ep
.text$mn:00006784                                         ; Notepad_plus::notify(SCNotification *)+1333p ...
.text$mn:00006784
.text$mn:00006784 var_14          = dword ptr -14h
.text$mn:00006784 var_D           = byte ptr -0Dh
.text$mn:00006784 var_C           = dword ptr -0Ch
.text$mn:00006784 var_4           = dword ptr -4
.text$mn:00006784
.text$mn:00006784                 push    ebp
.text$mn:00006785                 mov     ebp, esp
.text$mn:00006787                 push    0FFFFFFFFh
.text$mn:00006789                 push    offset __ehhandler$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:0000678E                 mov     eax, large fs:0
.text$mn:00006794                 push    eax
.text$mn:00006795                 sub     esp, 8
.text$mn:00006798                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000679D                 xor     eax, ebp
.text$mn:0000679F                 push    eax
.text$mn:000067A0                 lea     eax, [ebp+var_C]
.text$mn:000067A3                 mov     large fs:0, eax
.text$mn:000067A9                 mov     [ebp+var_14], ecx
.text$mn:000067AC                 lea     ecx, [ebp+var_D]
.text$mn:000067AF                 call    ??0?$allocator@UMenuItemUnit@@@std@@QAE@XZ ; std::allocator<MenuItemUnit>::allocator<MenuItemUnit>(void)
.text$mn:000067B4                 push    eax
.text$mn:000067B5                 mov     ecx, [ebp+var_14]
.text$mn:000067B8                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(std::allocator<MenuItemUnit> const &)
.text$mn:000067BD                 mov     [ebp+var_4], 0
.text$mn:000067C4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000067CB                 mov     eax, [ebp+var_14]
.text$mn:000067CE                 mov     ecx, [ebp+var_C]
.text$mn:000067D1                 mov     large fs:0, ecx
.text$mn:000067D8                 pop     ecx
.text$mn:000067D9                 mov     esp, ebp
.text$mn:000067DB                 pop     ebp
.text$mn:000067DC                 retn
.text$mn:000067DC ??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$mn:000067DC
.text$mn:000067DC ; ---------------------------------------------------------------------------
.text$mn:000067DD                 align 10h
.text$mn:000067DD _text$mn        ends
.text$mn:000067DD
.text$x:000067E0 ; ===========================================================================
.text$x:000067E0
.text$x:000067E0 ; Segment type: Pure code
.text$x:000067E0 ; Segment permissions: Read/Execute
.text$x:000067E0 _text$x         segment para public 'CODE' use32
.text$x:000067E0                 assume cs:_text$x
.text$x:000067E0                 ;org 67E0h
.text$x:000067E0 ; COMDAT (pick associative to section at 6784)
.text$x:000067E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000067E0
.text$x:000067E0 ; =============== S U B R O U T I N E =======================================
.text$x:000067E0
.text$x:000067E0
.text$x:000067E0 __unwindfunclet$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000067E0                                         ; DATA XREF: .xdata$x:0000BC14o
.text$x:000067E0                 mov     ecx, [ebp-14h]
.text$x:000067E3                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::~_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(void)
.text$x:000067E3 __unwindfunclet$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 endp
.text$x:000067E3
.text$x:000067E8
.text$x:000067E8 ; =============== S U B R O U T I N E =======================================
.text$x:000067E8
.text$x:000067E8
.text$x:000067E8 __ehhandler$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$x:000067E8                                         ; DATA XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)+5o
.text$x:000067E8
.text$x:000067E8 arg_4           = dword ptr  8
.text$x:000067E8
.text$x:000067E8                 mov     edx, [esp+arg_4]
.text$x:000067EC                 lea     eax, [edx+0Ch]
.text$x:000067EF                 mov     ecx, [edx-0Ch]
.text$x:000067F2                 xor     ecx, eax
.text$x:000067F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000067F9                 mov     eax, offset __ehfuncinfo$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$x:000067FE                 jmp     ___CxxFrameHandler3
.text$x:000067FE __ehhandler$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$x:000067FE
.text$x:000067FE ; ---------------------------------------------------------------------------
.text$x:00006803                 align 4
.text$x:00006803 _text$x         ends
.text$x:00006803
.text$mn:00006804 ; ===========================================================================
.text$mn:00006804
.text$mn:00006804 ; Segment type: Pure code
.text$mn:00006804 ; Segment permissions: Read/Execute
.text$mn:00006804 _text$mn        segment para public 'CODE' use32
.text$mn:00006804                 assume cs:_text$mn
.text$mn:00006804                 ;org 6804h
.text$mn:00006804 ; COMDAT (pick any)
.text$mn:00006804                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006804
.text$mn:00006804 ; =============== S U B R O U T I N E =======================================
.text$mn:00006804
.text$mn:00006804 ; Attributes: bp-based frame
.text$mn:00006804
.text$mn:00006804 ; public: __thiscall MenuItemUnit::MenuItemUnit(struct MenuItemUnit const &)
.text$mn:00006804                 public ??0MenuItemUnit@@QAE@ABU0@@Z
.text$mn:00006804 ??0MenuItemUnit@@QAE@ABU0@@Z proc near  ; CODE XREF: std::allocator<MenuItemUnit>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)+56p
.text$mn:00006804
.text$mn:00006804 var_10          = dword ptr -10h
.text$mn:00006804 var_C           = dword ptr -0Ch
.text$mn:00006804 var_4           = dword ptr -4
.text$mn:00006804 arg_0           = dword ptr  8
.text$mn:00006804
.text$mn:00006804                 push    ebp
.text$mn:00006805                 mov     ebp, esp
.text$mn:00006807                 push    0FFFFFFFFh
.text$mn:00006809                 push    offset __ehhandler$??0MenuItemUnit@@QAE@ABU0@@Z
.text$mn:0000680E                 mov     eax, large fs:0
.text$mn:00006814                 push    eax
.text$mn:00006815                 push    ecx
.text$mn:00006816                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000681B                 xor     eax, ebp
.text$mn:0000681D                 push    eax
.text$mn:0000681E                 lea     eax, [ebp+var_C]
.text$mn:00006821                 mov     large fs:0, eax
.text$mn:00006827                 mov     [ebp+var_10], ecx
.text$mn:0000682A                 mov     eax, [ebp+var_10]
.text$mn:0000682D                 mov     ecx, [ebp+arg_0]
.text$mn:00006830                 mov     edx, [ecx]
.text$mn:00006832                 mov     [eax], edx
.text$mn:00006834                 mov     eax, [ebp+arg_0]
.text$mn:00006837                 add     eax, 4
.text$mn:0000683A                 push    eax
.text$mn:0000683B                 mov     ecx, [ebp+var_10]
.text$mn:0000683E                 add     ecx, 4
.text$mn:00006841                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00006846                 mov     [ebp+var_4], 0
.text$mn:0000684D                 mov     ecx, [ebp+arg_0]
.text$mn:00006850                 add     ecx, 20h ; ' '
.text$mn:00006853                 push    ecx
.text$mn:00006854                 mov     ecx, [ebp+var_10]
.text$mn:00006857                 add     ecx, 20h ; ' '
.text$mn:0000685A                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000685F                 mov     byte ptr [ebp+var_4], 1
.text$mn:00006863                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000686A                 mov     eax, [ebp+var_10]
.text$mn:0000686D                 mov     ecx, [ebp+var_C]
.text$mn:00006870                 mov     large fs:0, ecx
.text$mn:00006877                 pop     ecx
.text$mn:00006878                 mov     esp, ebp
.text$mn:0000687A                 pop     ebp
.text$mn:0000687B                 retn    4
.text$mn:0000687B ??0MenuItemUnit@@QAE@ABU0@@Z endp
.text$mn:0000687B
.text$mn:0000687B ; ---------------------------------------------------------------------------
.text$mn:0000687E                 align 10h
.text$mn:0000687E _text$mn        ends
.text$mn:0000687E
.text$x:00006880 ; ===========================================================================
.text$x:00006880
.text$x:00006880 ; Segment type: Pure code
.text$x:00006880 ; Segment permissions: Read/Execute
.text$x:00006880 _text$x         segment para public 'CODE' use32
.text$x:00006880                 assume cs:_text$x
.text$x:00006880                 ;org 6880h
.text$x:00006880 ; COMDAT (pick associative to section at 6804)
.text$x:00006880                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006880
.text$x:00006880 ; =============== S U B R O U T I N E =======================================
.text$x:00006880
.text$x:00006880
.text$x:00006880 __unwindfunclet$??0MenuItemUnit@@QAE@ABU0@@Z$0 proc near
.text$x:00006880                                         ; DATA XREF: .xdata$x:0000BB30o
.text$x:00006880                 mov     ecx, [ebp-10h]
.text$x:00006883                 add     ecx, 4
.text$x:00006886                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006886 __unwindfunclet$??0MenuItemUnit@@QAE@ABU0@@Z$0 endp
.text$x:00006886
.text$x:0000688B
.text$x:0000688B ; =============== S U B R O U T I N E =======================================
.text$x:0000688B
.text$x:0000688B
.text$x:0000688B __unwindfunclet$??0MenuItemUnit@@QAE@ABU0@@Z$1 proc near
.text$x:0000688B                                         ; DATA XREF: .xdata$x:0000BB38o
.text$x:0000688B                 mov     ecx, [ebp-10h]
.text$x:0000688E                 add     ecx, 20h ; ' '
.text$x:00006891                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006891 __unwindfunclet$??0MenuItemUnit@@QAE@ABU0@@Z$1 endp
.text$x:00006891
.text$x:00006896
.text$x:00006896 ; =============== S U B R O U T I N E =======================================
.text$x:00006896
.text$x:00006896
.text$x:00006896 __ehhandler$??0MenuItemUnit@@QAE@ABU0@@Z proc near
.text$x:00006896                                         ; DATA XREF: MenuItemUnit::MenuItemUnit(MenuItemUnit const &)+5o
.text$x:00006896
.text$x:00006896 arg_4           = dword ptr  8
.text$x:00006896
.text$x:00006896                 mov     edx, [esp+arg_4]
.text$x:0000689A                 lea     eax, [edx+0Ch]
.text$x:0000689D                 mov     ecx, [edx-8]
.text$x:000068A0                 xor     ecx, eax
.text$x:000068A2                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000068A7                 mov     eax, offset __ehfuncinfo$??0MenuItemUnit@@QAE@ABU0@@Z
.text$x:000068AC                 jmp     ___CxxFrameHandler3
.text$x:000068AC __ehhandler$??0MenuItemUnit@@QAE@ABU0@@Z endp
.text$x:000068AC
.text$x:000068AC ; ---------------------------------------------------------------------------
.text$x:000068B1                 align 4
.text$x:000068B1 _text$x         ends
.text$x:000068B1
.text$mn:000068B4 ; ===========================================================================
.text$mn:000068B4
.text$mn:000068B4 ; Segment type: Pure code
.text$mn:000068B4 ; Segment permissions: Read/Execute
.text$mn:000068B4 _text$mn        segment para public 'CODE' use32
.text$mn:000068B4                 assume cs:_text$mn
.text$mn:000068B4                 ;org 68B4h
.text$mn:000068B4 ; COMDAT (pick any)
.text$mn:000068B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000068B4
.text$mn:000068B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000068B4
.text$mn:000068B4 ; Attributes: bp-based frame
.text$mn:000068B4
.text$mn:000068B4 ; _DWORD __thiscall XmlMatchedTagsHighlighter::XmlMatchedTagsHighlighter(XmlMatchedTagsHighlighter *this, struct ScintillaEditView *)
.text$mn:000068B4                 public ??0XmlMatchedTagsHighlighter@@QAE@PAVScintillaEditView@@@Z
.text$mn:000068B4 ??0XmlMatchedTagsHighlighter@@QAE@PAVScintillaEditView@@@Z proc near
.text$mn:000068B4                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2883p
.text$mn:000068B4
.text$mn:000068B4 var_4           = dword ptr -4
.text$mn:000068B4 arg_0           = dword ptr  8
.text$mn:000068B4
.text$mn:000068B4                 push    ebp
.text$mn:000068B5                 mov     ebp, esp
.text$mn:000068B7                 push    ecx
.text$mn:000068B8                 mov     [ebp+var_4], ecx
.text$mn:000068BB                 mov     eax, [ebp+var_4]
.text$mn:000068BE                 mov     ecx, [ebp+arg_0]
.text$mn:000068C1                 mov     [eax], ecx
.text$mn:000068C3                 mov     eax, [ebp+var_4]
.text$mn:000068C6                 mov     esp, ebp
.text$mn:000068C8                 pop     ebp
.text$mn:000068C9                 retn    4
.text$mn:000068C9 ??0XmlMatchedTagsHighlighter@@QAE@PAVScintillaEditView@@@Z endp
.text$mn:000068C9
.text$mn:000068C9 _text$mn        ends
.text$mn:000068C9
.text$mn:000068CC ; ===========================================================================
.text$mn:000068CC
.text$mn:000068CC ; Segment type: Pure code
.text$mn:000068CC ; Segment permissions: Read/Execute
.text$mn:000068CC _text$mn        segment para public 'CODE' use32
.text$mn:000068CC                 assume cs:_text$mn
.text$mn:000068CC                 ;org 68CCh
.text$mn:000068CC ; COMDAT (pick any)
.text$mn:000068CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000068CC
.text$mn:000068CC ; =============== S U B R O U T I N E =======================================
.text$mn:000068CC
.text$mn:000068CC ; Attributes: bp-based frame
.text$mn:000068CC
.text$mn:000068CC ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000068CC                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:000068CC ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:000068CC                                         ; CODE XREF: std::_Deque_val<std::_Deque_simple_types<uint>>::_Deque_val<std::_Deque_simple_types<uint>>(void)+29p
.text$mn:000068CC                                         ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p ...
.text$mn:000068CC
.text$mn:000068CC var_4           = dword ptr -4
.text$mn:000068CC
.text$mn:000068CC                 push    ebp
.text$mn:000068CD                 mov     ebp, esp
.text$mn:000068CF                 push    ecx
.text$mn:000068D0                 mov     [ebp+var_4], ecx
.text$mn:000068D3                 mov     eax, [ebp+var_4]
.text$mn:000068D6                 mov     dword ptr [eax], 0
.text$mn:000068DC                 mov     eax, [ebp+var_4]
.text$mn:000068DF                 mov     esp, ebp
.text$mn:000068E1                 pop     ebp
.text$mn:000068E2                 retn
.text$mn:000068E2 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:000068E2
.text$mn:000068E2 ; ---------------------------------------------------------------------------
.text$mn:000068E3                 align 4
.text$mn:000068E3 _text$mn        ends
.text$mn:000068E3
.text$mn:000068E4 ; ===========================================================================
.text$mn:000068E4
.text$mn:000068E4 ; Segment type: Pure code
.text$mn:000068E4 ; Segment permissions: Read/Execute
.text$mn:000068E4 _text$mn        segment para public 'CODE' use32
.text$mn:000068E4                 assume cs:_text$mn
.text$mn:000068E4                 ;org 68E4h
.text$mn:000068E4 ; COMDAT (pick any)
.text$mn:000068E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000068E4
.text$mn:000068E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000068E4
.text$mn:000068E4 ; Attributes: bp-based frame
.text$mn:000068E4
.text$mn:000068E4 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:000068E4                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:000068E4 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:000068E4                                         ; CODE XREF: std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Alloc_proxy(void)+23p
.text$mn:000068E4                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p ...
.text$mn:000068E4
.text$mn:000068E4 var_4           = dword ptr -4
.text$mn:000068E4
.text$mn:000068E4                 push    ebp
.text$mn:000068E5                 mov     ebp, esp
.text$mn:000068E7                 push    ecx
.text$mn:000068E8                 mov     [ebp+var_4], ecx
.text$mn:000068EB                 mov     eax, [ebp+var_4]
.text$mn:000068EE                 mov     dword ptr [eax], 0
.text$mn:000068F4                 mov     ecx, [ebp+var_4]
.text$mn:000068F7                 mov     dword ptr [ecx+4], 0
.text$mn:000068FE                 mov     eax, [ebp+var_4]
.text$mn:00006901                 mov     esp, ebp
.text$mn:00006903                 pop     ebp
.text$mn:00006904                 retn
.text$mn:00006904 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00006904
.text$mn:00006904 ; ---------------------------------------------------------------------------
.text$mn:00006905                 align 4
.text$mn:00006905 _text$mn        ends
.text$mn:00006905
.text$mn:00006908 ; ===========================================================================
.text$mn:00006908
.text$mn:00006908 ; Segment type: Pure code
.text$mn:00006908 ; Segment permissions: Read/Execute
.text$mn:00006908 _text$mn        segment para public 'CODE' use32
.text$mn:00006908                 assume cs:_text$mn
.text$mn:00006908                 ;org 6908h
.text$mn:00006908 ; COMDAT (pick any)
.text$mn:00006908                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006908
.text$mn:00006908 ; =============== S U B R O U T I N E =======================================
.text$mn:00006908
.text$mn:00006908 ; Attributes: bp-based frame
.text$mn:00006908
.text$mn:00006908 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00006908                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00006908 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00006908                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00006908                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00006908
.text$mn:00006908 var_10          = dword ptr -10h
.text$mn:00006908 var_C           = dword ptr -0Ch
.text$mn:00006908 var_4           = dword ptr -4
.text$mn:00006908
.text$mn:00006908                 push    ebp
.text$mn:00006909                 mov     ebp, esp
.text$mn:0000690B                 push    0FFFFFFFFh
.text$mn:0000690D                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00006912                 mov     eax, large fs:0
.text$mn:00006918                 push    eax
.text$mn:00006919                 push    ecx
.text$mn:0000691A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000691F                 xor     eax, ebp
.text$mn:00006921                 push    eax
.text$mn:00006922                 lea     eax, [ebp+var_C]
.text$mn:00006925                 mov     large fs:0, eax
.text$mn:0000692B                 mov     [ebp+var_10], ecx
.text$mn:0000692E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006931                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00006936                 mov     [ebp+var_4], 0
.text$mn:0000693D                 mov     eax, [ebp+var_10]
.text$mn:00006940                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00006946                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000694D                 mov     eax, [ebp+var_10]
.text$mn:00006950                 mov     ecx, [ebp+var_C]
.text$mn:00006953                 mov     large fs:0, ecx
.text$mn:0000695A                 pop     ecx
.text$mn:0000695B                 mov     esp, ebp
.text$mn:0000695D                 pop     ebp
.text$mn:0000695E                 retn
.text$mn:0000695E ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:0000695E
.text$mn:0000695E ; ---------------------------------------------------------------------------
.text$mn:0000695F                 align 10h
.text$mn:0000695F _text$mn        ends
.text$mn:0000695F
.text$x:00006960 ; ===========================================================================
.text$x:00006960
.text$x:00006960 ; Segment type: Pure code
.text$x:00006960 ; Segment permissions: Read/Execute
.text$x:00006960 _text$x         segment para public 'CODE' use32
.text$x:00006960                 assume cs:_text$x
.text$x:00006960                 ;org 6960h
.text$x:00006960 ; COMDAT (pick associative to section at 6908)
.text$x:00006960                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006960
.text$x:00006960 ; =============== S U B R O U T I N E =======================================
.text$x:00006960
.text$x:00006960
.text$x:00006960 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00006960                                         ; DATA XREF: .xdata$x:0000B6A8o
.text$x:00006960                 mov     ecx, [ebp-10h]  ; this
.text$x:00006963                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00006963 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00006963
.text$x:00006968
.text$x:00006968 ; =============== S U B R O U T I N E =======================================
.text$x:00006968
.text$x:00006968
.text$x:00006968 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00006968                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00006968
.text$x:00006968 arg_4           = dword ptr  8
.text$x:00006968
.text$x:00006968                 mov     edx, [esp+arg_4]
.text$x:0000696C                 lea     eax, [edx+0Ch]
.text$x:0000696F                 mov     ecx, [edx-8]
.text$x:00006972                 xor     ecx, eax
.text$x:00006974                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006979                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:0000697E                 jmp     ___CxxFrameHandler3
.text$x:0000697E __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:0000697E
.text$x:0000697E ; ---------------------------------------------------------------------------
.text$x:00006983                 align 4
.text$x:00006983 _text$x         ends
.text$x:00006983
.text$mn:00006984 ; ===========================================================================
.text$mn:00006984
.text$mn:00006984 ; Segment type: Pure code
.text$mn:00006984 ; Segment permissions: Read/Execute
.text$mn:00006984 _text$mn        segment para public 'CODE' use32
.text$mn:00006984                 assume cs:_text$mn
.text$mn:00006984                 ;org 6984h
.text$mn:00006984 ; COMDAT (pick any)
.text$mn:00006984                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006984
.text$mn:00006984 ; =============== S U B R O U T I N E =======================================
.text$mn:00006984
.text$mn:00006984 ; Attributes: bp-based frame
.text$mn:00006984
.text$mn:00006984 ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:00006984                 public ??0_Ignore@std@@QAE@XZ
.text$mn:00006984 ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:00006984
.text$mn:00006984 var_4           = dword ptr -4
.text$mn:00006984
.text$mn:00006984                 push    ebp
.text$mn:00006985                 mov     ebp, esp
.text$mn:00006987                 push    ecx
.text$mn:00006988                 mov     [ebp+var_4], ecx
.text$mn:0000698B                 mov     eax, [ebp+var_4]
.text$mn:0000698E                 mov     esp, ebp
.text$mn:00006990                 pop     ebp
.text$mn:00006991                 retn
.text$mn:00006991 ??0_Ignore@std@@QAE@XZ endp
.text$mn:00006991
.text$mn:00006991 ; ---------------------------------------------------------------------------
.text$mn:00006992                 align 4
.text$mn:00006992 _text$mn        ends
.text$mn:00006992
.text$mn:00006994 ; ===========================================================================
.text$mn:00006994
.text$mn:00006994 ; Segment type: Pure code
.text$mn:00006994 ; Segment permissions: Read/Execute
.text$mn:00006994 _text$mn        segment para public 'CODE' use32
.text$mn:00006994                 assume cs:_text$mn
.text$mn:00006994                 ;org 6994h
.text$mn:00006994 ; COMDAT (pick any)
.text$mn:00006994                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006994
.text$mn:00006994 ; =============== S U B R O U T I N E =======================================
.text$mn:00006994
.text$mn:00006994 ; Attributes: bp-based frame
.text$mn:00006994
.text$mn:00006994 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00006994                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00006994 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00006994                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00006994
.text$mn:00006994 var_10          = dword ptr -10h
.text$mn:00006994 var_C           = dword ptr -0Ch
.text$mn:00006994 var_4           = dword ptr -4
.text$mn:00006994
.text$mn:00006994                 push    ebp
.text$mn:00006995                 mov     ebp, esp
.text$mn:00006997                 push    0FFFFFFFFh
.text$mn:00006999                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:0000699E                 mov     eax, large fs:0
.text$mn:000069A4                 push    eax
.text$mn:000069A5                 push    ecx
.text$mn:000069A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000069AB                 xor     eax, ebp
.text$mn:000069AD                 push    eax
.text$mn:000069AE                 lea     eax, [ebp+var_C]
.text$mn:000069B1                 mov     large fs:0, eax
.text$mn:000069B7                 mov     [ebp+var_10], ecx
.text$mn:000069BA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000069BD                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000069C2                 mov     [ebp+var_4], 0
.text$mn:000069C9                 mov     eax, [ebp+var_10]
.text$mn:000069CC                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:000069D2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000069D9                 mov     eax, [ebp+var_10]
.text$mn:000069DC                 mov     ecx, [ebp+var_C]
.text$mn:000069DF                 mov     large fs:0, ecx
.text$mn:000069E6                 pop     ecx
.text$mn:000069E7                 mov     esp, ebp
.text$mn:000069E9                 pop     ebp
.text$mn:000069EA                 retn
.text$mn:000069EA ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:000069EA
.text$mn:000069EA ; ---------------------------------------------------------------------------
.text$mn:000069EB                 align 4
.text$mn:000069EB _text$mn        ends
.text$mn:000069EB
.text$x:000069EC ; ===========================================================================
.text$x:000069EC
.text$x:000069EC ; Segment type: Pure code
.text$x:000069EC ; Segment permissions: Read/Execute
.text$x:000069EC _text$x         segment para public 'CODE' use32
.text$x:000069EC                 assume cs:_text$x
.text$x:000069EC                 ;org 69ECh
.text$x:000069EC ; COMDAT (pick associative to section at 6994)
.text$x:000069EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000069EC
.text$x:000069EC ; =============== S U B R O U T I N E =======================================
.text$x:000069EC
.text$x:000069EC
.text$x:000069EC __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:000069EC                                         ; DATA XREF: .xdata$x:0000B72Co
.text$x:000069EC                 mov     ecx, [ebp-10h]  ; this
.text$x:000069EF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000069EF __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:000069EF
.text$x:000069F4
.text$x:000069F4 ; =============== S U B R O U T I N E =======================================
.text$x:000069F4
.text$x:000069F4
.text$x:000069F4 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:000069F4                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:000069F4
.text$x:000069F4 arg_4           = dword ptr  8
.text$x:000069F4
.text$x:000069F4                 mov     edx, [esp+arg_4]
.text$x:000069F8                 lea     eax, [edx+0Ch]
.text$x:000069FB                 mov     ecx, [edx-8]
.text$x:000069FE                 xor     ecx, eax
.text$x:00006A00                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006A05                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00006A0A                 jmp     ___CxxFrameHandler3
.text$x:00006A0A __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00006A0A
.text$x:00006A0A ; ---------------------------------------------------------------------------
.text$x:00006A0F                 align 10h
.text$x:00006A0F _text$x         ends
.text$x:00006A0F
.text$mn:00006A10 ; ===========================================================================
.text$mn:00006A10
.text$mn:00006A10 ; Segment type: Pure code
.text$mn:00006A10 ; Segment permissions: Read/Execute
.text$mn:00006A10 _text$mn        segment para public 'CODE' use32
.text$mn:00006A10                 assume cs:_text$mn
.text$mn:00006A10                 ;org 6A10h
.text$mn:00006A10 ; COMDAT (pick any)
.text$mn:00006A10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006A10
.text$mn:00006A10 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A10
.text$mn:00006A10 ; Attributes: bp-based frame
.text$mn:00006A10
.text$mn:00006A10 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:00006A10                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:00006A10 ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:00006A10                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>> const &)+2Dp
.text$mn:00006A10
.text$mn:00006A10 var_4           = dword ptr -4
.text$mn:00006A10 arg_0           = dword ptr  8
.text$mn:00006A10
.text$mn:00006A10                 push    ebp
.text$mn:00006A11                 mov     ebp, esp
.text$mn:00006A13                 push    ecx
.text$mn:00006A14                 mov     [ebp+var_4], ecx
.text$mn:00006A17                 mov     eax, [ebp+var_4]
.text$mn:00006A1A                 mov     dword ptr [eax], 0
.text$mn:00006A20                 mov     ecx, [ebp+var_4]
.text$mn:00006A23                 mov     dword ptr [ecx+4], 0
.text$mn:00006A2A                 mov     edx, [ebp+arg_0]
.text$mn:00006A2D                 push    edx
.text$mn:00006A2E                 mov     ecx, [ebp+var_4]
.text$mn:00006A31                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:00006A36                 mov     eax, [ebp+var_4]
.text$mn:00006A39                 mov     esp, ebp
.text$mn:00006A3B                 pop     ebp
.text$mn:00006A3C                 retn    4
.text$mn:00006A3C ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:00006A3C
.text$mn:00006A3C ; ---------------------------------------------------------------------------
.text$mn:00006A3F                 align 10h
.text$mn:00006A3F _text$mn        ends
.text$mn:00006A3F
.text$mn:00006A40 ; ===========================================================================
.text$mn:00006A40
.text$mn:00006A40 ; Segment type: Pure code
.text$mn:00006A40 ; Segment permissions: Read/Execute
.text$mn:00006A40 _text$mn        segment para public 'CODE' use32
.text$mn:00006A40                 assume cs:_text$mn
.text$mn:00006A40                 ;org 6A40h
.text$mn:00006A40 ; COMDAT (pick any)
.text$mn:00006A40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006A40
.text$mn:00006A40 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A40
.text$mn:00006A40 ; Attributes: bp-based frame
.text$mn:00006A40
.text$mn:00006A40 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00006A40                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:00006A40 ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00006A40                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(uint,std::_Container_base12 const *)+29p
.text$mn:00006A40
.text$mn:00006A40 var_4           = dword ptr -4
.text$mn:00006A40
.text$mn:00006A40                 push    ebp
.text$mn:00006A41                 mov     ebp, esp
.text$mn:00006A43                 push    ecx
.text$mn:00006A44                 mov     [ebp+var_4], ecx
.text$mn:00006A47                 mov     eax, [ebp+var_4]
.text$mn:00006A4A                 mov     dword ptr [eax], 0
.text$mn:00006A50                 mov     ecx, [ebp+var_4]
.text$mn:00006A53                 mov     dword ptr [ecx+4], 0
.text$mn:00006A5A                 mov     eax, [ebp+var_4]
.text$mn:00006A5D                 mov     esp, ebp
.text$mn:00006A5F                 pop     ebp
.text$mn:00006A60                 retn
.text$mn:00006A60 ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:00006A60
.text$mn:00006A60 ; ---------------------------------------------------------------------------
.text$mn:00006A61                 align 4
.text$mn:00006A61 _text$mn        ends
.text$mn:00006A61
.text$mn:00006A64 ; ===========================================================================
.text$mn:00006A64
.text$mn:00006A64 ; Segment type: Pure code
.text$mn:00006A64 ; Segment permissions: Read/Execute
.text$mn:00006A64 _text$mn        segment para public 'CODE' use32
.text$mn:00006A64                 assume cs:_text$mn
.text$mn:00006A64                 ;org 6A64h
.text$mn:00006A64 ; COMDAT (pick any)
.text$mn:00006A64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006A64
.text$mn:00006A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A64
.text$mn:00006A64 ; Attributes: bp-based frame
.text$mn:00006A64
.text$mn:00006A64 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00006A64                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00006A64 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00006A64                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00006A64
.text$mn:00006A64 var_10          = dword ptr -10h
.text$mn:00006A64 var_C           = dword ptr -0Ch
.text$mn:00006A64 var_4           = dword ptr -4
.text$mn:00006A64
.text$mn:00006A64                 push    ebp
.text$mn:00006A65                 mov     ebp, esp
.text$mn:00006A67                 push    0FFFFFFFFh
.text$mn:00006A69                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00006A6E                 mov     eax, large fs:0
.text$mn:00006A74                 push    eax
.text$mn:00006A75                 push    ecx
.text$mn:00006A76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006A7B                 xor     eax, ebp
.text$mn:00006A7D                 push    eax
.text$mn:00006A7E                 lea     eax, [ebp+var_C]
.text$mn:00006A81                 mov     large fs:0, eax
.text$mn:00006A87                 mov     [ebp+var_10], ecx
.text$mn:00006A8A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006A8D                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00006A92                 mov     [ebp+var_4], 0
.text$mn:00006A99                 mov     eax, [ebp+var_10]
.text$mn:00006A9C                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00006AA2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006AA9                 mov     eax, [ebp+var_10]
.text$mn:00006AAC                 mov     ecx, [ebp+var_C]
.text$mn:00006AAF                 mov     large fs:0, ecx
.text$mn:00006AB6                 pop     ecx
.text$mn:00006AB7                 mov     esp, ebp
.text$mn:00006AB9                 pop     ebp
.text$mn:00006ABA                 retn
.text$mn:00006ABA ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00006ABA
.text$mn:00006ABA ; ---------------------------------------------------------------------------
.text$mn:00006ABB                 align 4
.text$mn:00006ABB _text$mn        ends
.text$mn:00006ABB
.text$x:00006ABC ; ===========================================================================
.text$x:00006ABC
.text$x:00006ABC ; Segment type: Pure code
.text$x:00006ABC ; Segment permissions: Read/Execute
.text$x:00006ABC _text$x         segment para public 'CODE' use32
.text$x:00006ABC                 assume cs:_text$x
.text$x:00006ABC                 ;org 6ABCh
.text$x:00006ABC ; COMDAT (pick associative to section at 6A64)
.text$x:00006ABC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006ABC
.text$x:00006ABC ; =============== S U B R O U T I N E =======================================
.text$x:00006ABC
.text$x:00006ABC
.text$x:00006ABC __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00006ABC                                         ; DATA XREF: .xdata$x:0000B7B0o
.text$x:00006ABC                 mov     ecx, [ebp-10h]  ; this
.text$x:00006ABF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00006ABF __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00006ABF
.text$x:00006AC4
.text$x:00006AC4 ; =============== S U B R O U T I N E =======================================
.text$x:00006AC4
.text$x:00006AC4
.text$x:00006AC4 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00006AC4                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00006AC4
.text$x:00006AC4 arg_4           = dword ptr  8
.text$x:00006AC4
.text$x:00006AC4                 mov     edx, [esp+arg_4]
.text$x:00006AC8                 lea     eax, [edx+0Ch]
.text$x:00006ACB                 mov     ecx, [edx-8]
.text$x:00006ACE                 xor     ecx, eax
.text$x:00006AD0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006AD5                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00006ADA                 jmp     ___CxxFrameHandler3
.text$x:00006ADA __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00006ADA
.text$x:00006ADA ; ---------------------------------------------------------------------------
.text$x:00006ADF                 align 10h
.text$x:00006ADF _text$x         ends
.text$x:00006ADF
.text$mn:00006AE0 ; ===========================================================================
.text$mn:00006AE0
.text$mn:00006AE0 ; Segment type: Pure code
.text$mn:00006AE0 ; Segment permissions: Read/Execute
.text$mn:00006AE0 _text$mn        segment para public 'CODE' use32
.text$mn:00006AE0                 assume cs:_text$mn
.text$mn:00006AE0                 ;org 6AE0h
.text$mn:00006AE0 ; COMDAT (pick any)
.text$mn:00006AE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006AE0
.text$mn:00006AE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006AE0
.text$mn:00006AE0 ; Attributes: bp-based frame
.text$mn:00006AE0
.text$mn:00006AE0 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00006AE0                 public ??0error_category@std@@QAE@XZ
.text$mn:00006AE0 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00006AE0
.text$mn:00006AE0 var_4           = dword ptr -4
.text$mn:00006AE0
.text$mn:00006AE0                 push    ebp
.text$mn:00006AE1                 mov     ebp, esp
.text$mn:00006AE3                 push    ecx
.text$mn:00006AE4                 mov     [ebp+var_4], ecx
.text$mn:00006AE7                 mov     eax, [ebp+var_4]
.text$mn:00006AEA                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00006AF0                 mov     eax, [ebp+var_4]
.text$mn:00006AF3                 mov     esp, ebp
.text$mn:00006AF5                 pop     ebp
.text$mn:00006AF6                 retn
.text$mn:00006AF6 ??0error_category@std@@QAE@XZ endp
.text$mn:00006AF6
.text$mn:00006AF6 ; ---------------------------------------------------------------------------
.text$mn:00006AF7                 align 4
.text$mn:00006AF7 _text$mn        ends
.text$mn:00006AF7
.text$mn:00006AF8 ; ===========================================================================
.text$mn:00006AF8
.text$mn:00006AF8 ; Segment type: Pure code
.text$mn:00006AF8 ; Segment permissions: Read/Execute
.text$mn:00006AF8 _text$mn        segment para public 'CODE' use32
.text$mn:00006AF8                 assume cs:_text$mn
.text$mn:00006AF8                 ;org 6AF8h
.text$mn:00006AF8 ; COMDAT (pick any)
.text$mn:00006AF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006AF8
.text$mn:00006AF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006AF8
.text$mn:00006AF8 ; Attributes: bp-based frame
.text$mn:00006AF8
.text$mn:00006AF8 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00006AF8                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00006AF8 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00006AF8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00006AF8                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00006AF8
.text$mn:00006AF8 var_4           = dword ptr -4
.text$mn:00006AF8 arg_0           = dword ptr  8
.text$mn:00006AF8 arg_4           = dword ptr  0Ch
.text$mn:00006AF8
.text$mn:00006AF8                 push    ebp
.text$mn:00006AF9                 mov     ebp, esp
.text$mn:00006AFB                 push    ecx
.text$mn:00006AFC                 mov     [ebp+var_4], ecx
.text$mn:00006AFF                 mov     eax, [ebp+var_4]
.text$mn:00006B02                 mov     ecx, [ebp+arg_0]
.text$mn:00006B05                 mov     [eax], ecx
.text$mn:00006B07                 mov     edx, [ebp+var_4]
.text$mn:00006B0A                 mov     eax, [ebp+arg_4]
.text$mn:00006B0D                 mov     [edx+4], eax
.text$mn:00006B10                 mov     eax, [ebp+var_4]
.text$mn:00006B13                 mov     esp, ebp
.text$mn:00006B15                 pop     ebp
.text$mn:00006B16                 retn    8
.text$mn:00006B16 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00006B16
.text$mn:00006B16 ; ---------------------------------------------------------------------------
.text$mn:00006B19                 align 4
.text$mn:00006B19 _text$mn        ends
.text$mn:00006B19
.text$mn:00006B1C ; ===========================================================================
.text$mn:00006B1C
.text$mn:00006B1C ; Segment type: Pure code
.text$mn:00006B1C ; Segment permissions: Read/Execute
.text$mn:00006B1C _text$mn        segment para public 'CODE' use32
.text$mn:00006B1C                 assume cs:_text$mn
.text$mn:00006B1C                 ;org 6B1Ch
.text$mn:00006B1C ; COMDAT (pick any)
.text$mn:00006B1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006B1C
.text$mn:00006B1C ; =============== S U B R O U T I N E =======================================
.text$mn:00006B1C
.text$mn:00006B1C ; Attributes: bp-based frame
.text$mn:00006B1C
.text$mn:00006B1C ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00006B1C                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00006B1C ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00006B1C                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00006B1C
.text$mn:00006B1C var_4           = dword ptr -4
.text$mn:00006B1C arg_0           = dword ptr  8
.text$mn:00006B1C
.text$mn:00006B1C                 push    ebp
.text$mn:00006B1D                 mov     ebp, esp
.text$mn:00006B1F                 push    ecx
.text$mn:00006B20                 mov     [ebp+var_4], ecx
.text$mn:00006B23                 mov     eax, [ebp+var_4]
.text$mn:00006B26                 mov     ecx, [ebp+arg_0]
.text$mn:00006B29                 mov     [eax], ecx
.text$mn:00006B2B                 mov     eax, [ebp+var_4]
.text$mn:00006B2E                 mov     esp, ebp
.text$mn:00006B30                 pop     ebp
.text$mn:00006B31                 retn    4
.text$mn:00006B31 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00006B31
.text$mn:00006B31 _text$mn        ends
.text$mn:00006B31
.text$mn:00006B34 ; ===========================================================================
.text$mn:00006B34
.text$mn:00006B34 ; Segment type: Pure code
.text$mn:00006B34 ; Segment permissions: Read/Execute
.text$mn:00006B34 _text$mn        segment para public 'CODE' use32
.text$mn:00006B34                 assume cs:_text$mn
.text$mn:00006B34                 ;org 6B34h
.text$mn:00006B34 ; COMDAT (pick any)
.text$mn:00006B34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006B34
.text$mn:00006B34 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B34
.text$mn:00006B34 ; Attributes: bp-based frame
.text$mn:00006B34
.text$mn:00006B34 ; public: __thiscall recordedMacroStep::recordedMacroStep(struct recordedMacroStep const &)
.text$mn:00006B34                 public ??0recordedMacroStep@@QAE@ABU0@@Z
.text$mn:00006B34 ??0recordedMacroStep@@QAE@ABU0@@Z proc near
.text$mn:00006B34                                         ; CODE XREF: std::allocator<recordedMacroStep>::construct<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep &&)+56p
.text$mn:00006B34
.text$mn:00006B34 var_10          = dword ptr -10h
.text$mn:00006B34 var_C           = dword ptr -0Ch
.text$mn:00006B34 var_4           = dword ptr -4
.text$mn:00006B34 arg_0           = dword ptr  8
.text$mn:00006B34
.text$mn:00006B34                 push    ebp
.text$mn:00006B35                 mov     ebp, esp
.text$mn:00006B37                 push    0FFFFFFFFh
.text$mn:00006B39                 push    offset __ehhandler$??0recordedMacroStep@@QAE@ABU0@@Z
.text$mn:00006B3E                 mov     eax, large fs:0
.text$mn:00006B44                 push    eax
.text$mn:00006B45                 push    ecx
.text$mn:00006B46                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006B4B                 xor     eax, ebp
.text$mn:00006B4D                 push    eax
.text$mn:00006B4E                 lea     eax, [ebp+var_C]
.text$mn:00006B51                 mov     large fs:0, eax
.text$mn:00006B57                 mov     [ebp+var_10], ecx
.text$mn:00006B5A                 mov     eax, [ebp+var_10]
.text$mn:00006B5D                 mov     ecx, [ebp+arg_0]
.text$mn:00006B60                 mov     edx, [ecx]
.text$mn:00006B62                 mov     [eax], edx
.text$mn:00006B64                 mov     eax, [ebp+var_10]
.text$mn:00006B67                 mov     ecx, [ebp+arg_0]
.text$mn:00006B6A                 mov     edx, [ecx+4]
.text$mn:00006B6D                 mov     [eax+4], edx
.text$mn:00006B70                 mov     eax, [ebp+var_10]
.text$mn:00006B73                 mov     ecx, [ebp+arg_0]
.text$mn:00006B76                 mov     edx, [ecx+8]
.text$mn:00006B79                 mov     [eax+8], edx
.text$mn:00006B7C                 mov     eax, [ebp+arg_0]
.text$mn:00006B7F                 add     eax, 0Ch
.text$mn:00006B82                 push    eax
.text$mn:00006B83                 mov     ecx, [ebp+var_10]
.text$mn:00006B86                 add     ecx, 0Ch
.text$mn:00006B89                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00006B8E                 mov     [ebp+var_4], 0
.text$mn:00006B95                 mov     ecx, [ebp+var_10]
.text$mn:00006B98                 mov     edx, [ebp+arg_0]
.text$mn:00006B9B                 mov     eax, [edx+28h]
.text$mn:00006B9E                 mov     [ecx+28h], eax
.text$mn:00006BA1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006BA8                 mov     eax, [ebp+var_10]
.text$mn:00006BAB                 mov     ecx, [ebp+var_C]
.text$mn:00006BAE                 mov     large fs:0, ecx
.text$mn:00006BB5                 pop     ecx
.text$mn:00006BB6                 mov     esp, ebp
.text$mn:00006BB8                 pop     ebp
.text$mn:00006BB9                 retn    4
.text$mn:00006BB9 ??0recordedMacroStep@@QAE@ABU0@@Z endp
.text$mn:00006BB9
.text$mn:00006BB9 _text$mn        ends
.text$mn:00006BB9
.text$x:00006BBC ; ===========================================================================
.text$x:00006BBC
.text$x:00006BBC ; Segment type: Pure code
.text$x:00006BBC ; Segment permissions: Read/Execute
.text$x:00006BBC _text$x         segment para public 'CODE' use32
.text$x:00006BBC                 assume cs:_text$x
.text$x:00006BBC                 ;org 6BBCh
.text$x:00006BBC ; COMDAT (pick associative to section at 6B34)
.text$x:00006BBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006BBC
.text$x:00006BBC ; =============== S U B R O U T I N E =======================================
.text$x:00006BBC
.text$x:00006BBC
.text$x:00006BBC __unwindfunclet$??0recordedMacroStep@@QAE@ABU0@@Z$0 proc near
.text$x:00006BBC                                         ; DATA XREF: .xdata$x:0000BA4Co
.text$x:00006BBC                 mov     ecx, [ebp-10h]
.text$x:00006BBF                 add     ecx, 0Ch
.text$x:00006BC2                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00006BC2 __unwindfunclet$??0recordedMacroStep@@QAE@ABU0@@Z$0 endp
.text$x:00006BC2
.text$x:00006BC7
.text$x:00006BC7 ; =============== S U B R O U T I N E =======================================
.text$x:00006BC7
.text$x:00006BC7
.text$x:00006BC7 __ehhandler$??0recordedMacroStep@@QAE@ABU0@@Z proc near
.text$x:00006BC7                                         ; DATA XREF: recordedMacroStep::recordedMacroStep(recordedMacroStep const &)+5o
.text$x:00006BC7
.text$x:00006BC7 arg_4           = dword ptr  8
.text$x:00006BC7
.text$x:00006BC7                 mov     edx, [esp+arg_4]
.text$x:00006BCB                 lea     eax, [edx+0Ch]
.text$x:00006BCE                 mov     ecx, [edx-8]
.text$x:00006BD1                 xor     ecx, eax
.text$x:00006BD3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006BD8                 mov     eax, offset __ehfuncinfo$??0recordedMacroStep@@QAE@ABU0@@Z
.text$x:00006BDD                 jmp     ___CxxFrameHandler3
.text$x:00006BDD __ehhandler$??0recordedMacroStep@@QAE@ABU0@@Z endp
.text$x:00006BDD
.text$x:00006BDD ; ---------------------------------------------------------------------------
.text$x:00006BE2                 align 4
.text$x:00006BE2 _text$x         ends
.text$x:00006BE2
.text$mn:00006BE4 ; ===========================================================================
.text$mn:00006BE4
.text$mn:00006BE4 ; Segment type: Pure code
.text$mn:00006BE4 ; Segment permissions: Read/Execute
.text$mn:00006BE4 _text$mn        segment para public 'CODE' use32
.text$mn:00006BE4                 assume cs:_text$mn
.text$mn:00006BE4                 ;org 6BE4h
.text$mn:00006BE4 ; COMDAT (pick any)
.text$mn:00006BE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006BE4
.text$mn:00006BE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BE4
.text$mn:00006BE4 ; Attributes: bp-based frame
.text$mn:00006BE4
.text$mn:00006BE4 ; public: __thiscall std::_Deque_alloc<0, struct std::_Deque_base_types<unsigned int, class std::allocator<unsigned int>>>::~_Deque_alloc<0, struct std::_Deque_base_types<unsigned int, class std::allocator<unsigned int>>>(void)
.text$mn:00006BE4                 public ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$mn:00006BE4 ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006BE4                                         ; CODE XREF: __unwindfunclet$??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ$0+3j
.text$mn:00006BE4                                         ; std::deque<uint,std::allocator<uint>>::~deque<uint,std::allocator<uint>>(void)+3Fp ...
.text$mn:00006BE4
.text$mn:00006BE4 var_10          = dword ptr -10h
.text$mn:00006BE4 var_C           = dword ptr -0Ch
.text$mn:00006BE4 var_4           = dword ptr -4
.text$mn:00006BE4
.text$mn:00006BE4                 push    ebp
.text$mn:00006BE5                 mov     ebp, esp
.text$mn:00006BE7                 push    0FFFFFFFFh
.text$mn:00006BE9                 push    offset __ehhandler$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$mn:00006BEE                 mov     eax, large fs:0
.text$mn:00006BF4                 push    eax
.text$mn:00006BF5                 push    ecx
.text$mn:00006BF6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006BFB                 xor     eax, ebp
.text$mn:00006BFD                 push    eax
.text$mn:00006BFE                 lea     eax, [ebp+var_C]
.text$mn:00006C01                 mov     large fs:0, eax
.text$mn:00006C07                 mov     [ebp+var_10], ecx
.text$mn:00006C0A                 mov     [ebp+var_4], 0
.text$mn:00006C11                 mov     ecx, [ebp+var_10]
.text$mn:00006C14                 call    ?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Free_proxy(void)
.text$mn:00006C19                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006C20                 mov     ecx, [ebp+var_10]
.text$mn:00006C23                 call    ??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<uint>>::~_Deque_val<std::_Deque_simple_types<uint>>(void)
.text$mn:00006C28                 mov     ecx, [ebp+var_C]
.text$mn:00006C2B                 mov     large fs:0, ecx
.text$mn:00006C32                 pop     ecx
.text$mn:00006C33                 mov     esp, ebp
.text$mn:00006C35                 pop     ebp
.text$mn:00006C36                 retn
.text$mn:00006C36 ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006C36
.text$mn:00006C36 ; ---------------------------------------------------------------------------
.text$mn:00006C37                 align 4
.text$mn:00006C37 _text$mn        ends
.text$mn:00006C37
.text$x:00006C38 ; ===========================================================================
.text$x:00006C38
.text$x:00006C38 ; Segment type: Pure code
.text$x:00006C38 ; Segment permissions: Read/Execute
.text$x:00006C38 _text$x         segment para public 'CODE' use32
.text$x:00006C38                 assume cs:_text$x
.text$x:00006C38                 ;org 6C38h
.text$x:00006C38 ; COMDAT (pick associative to section at 6BE4)
.text$x:00006C38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006C38
.text$x:00006C38 ; =============== S U B R O U T I N E =======================================
.text$x:00006C38
.text$x:00006C38
.text$x:00006C38 __unwindfunclet$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006C38                                         ; DATA XREF: .xdata$x:0000BF04o
.text$x:00006C38                 mov     ecx, [ebp-10h]
.text$x:00006C3B                 jmp     ??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<uint>>::~_Deque_val<std::_Deque_simple_types<uint>>(void)
.text$x:00006C3B __unwindfunclet$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006C3B
.text$x:00006C40
.text$x:00006C40 ; =============== S U B R O U T I N E =======================================
.text$x:00006C40
.text$x:00006C40
.text$x:00006C40 __ehhandler$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006C40                                         ; DATA XREF: std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::~_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>(void)+5o
.text$x:00006C40
.text$x:00006C40 arg_4           = dword ptr  8
.text$x:00006C40
.text$x:00006C40                 mov     edx, [esp+arg_4]
.text$x:00006C44                 lea     eax, [edx+0Ch]
.text$x:00006C47                 mov     ecx, [edx-8]
.text$x:00006C4A                 xor     ecx, eax
.text$x:00006C4C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006C51                 mov     eax, offset __ehfuncinfo$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$x:00006C56                 jmp     ___CxxFrameHandler3
.text$x:00006C56 __ehhandler$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ endp
.text$x:00006C56
.text$x:00006C56 ; ---------------------------------------------------------------------------
.text$x:00006C5B                 align 4
.text$x:00006C5B _text$x         ends
.text$x:00006C5B
.text$mn:00006C5C ; ===========================================================================
.text$mn:00006C5C
.text$mn:00006C5C ; Segment type: Pure code
.text$mn:00006C5C ; Segment permissions: Read/Execute
.text$mn:00006C5C _text$mn        segment para public 'CODE' use32
.text$mn:00006C5C                 assume cs:_text$mn
.text$mn:00006C5C                 ;org 6C5Ch
.text$mn:00006C5C ; COMDAT (pick any)
.text$mn:00006C5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006C5C
.text$mn:00006C5C ; =============== S U B R O U T I N E =======================================
.text$mn:00006C5C
.text$mn:00006C5C ; Attributes: bp-based frame
.text$mn:00006C5C
.text$mn:00006C5C ; public: __thiscall std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>>::~_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>>(void)
.text$mn:00006C5C                 public ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ
.text$mn:00006C5C ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006C5C                                         ; CODE XREF: __unwindfunclet$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00006C5C                                         ; __unwindfunclet$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0+3j ...
.text$mn:00006C5C
.text$mn:00006C5C var_10          = dword ptr -10h
.text$mn:00006C5C var_C           = dword ptr -0Ch
.text$mn:00006C5C var_4           = dword ptr -4
.text$mn:00006C5C
.text$mn:00006C5C                 push    ebp
.text$mn:00006C5D                 mov     ebp, esp
.text$mn:00006C5F                 push    0FFFFFFFFh
.text$mn:00006C61                 push    offset __ehhandler$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ
.text$mn:00006C66                 mov     eax, large fs:0
.text$mn:00006C6C                 push    eax
.text$mn:00006C6D                 push    ecx
.text$mn:00006C6E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006C73                 xor     eax, ebp
.text$mn:00006C75                 push    eax
.text$mn:00006C76                 lea     eax, [ebp+var_C]
.text$mn:00006C79                 mov     large fs:0, eax
.text$mn:00006C7F                 mov     [ebp+var_10], ecx
.text$mn:00006C82                 mov     [ebp+var_4], 0
.text$mn:00006C89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006C90                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006C93                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00006C98                 mov     ecx, [ebp+var_C]
.text$mn:00006C9B                 mov     large fs:0, ecx
.text$mn:00006CA2                 pop     ecx
.text$mn:00006CA3                 mov     esp, ebp
.text$mn:00006CA5                 pop     ebp
.text$mn:00006CA6                 retn
.text$mn:00006CA6 ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006CA6
.text$mn:00006CA6 ; ---------------------------------------------------------------------------
.text$mn:00006CA7                 align 4
.text$mn:00006CA7 _text$mn        ends
.text$mn:00006CA7
.text$x:00006CA8 ; ===========================================================================
.text$x:00006CA8
.text$x:00006CA8 ; Segment type: Pure code
.text$x:00006CA8 ; Segment permissions: Read/Execute
.text$x:00006CA8 _text$x         segment para public 'CODE' use32
.text$x:00006CA8                 assume cs:_text$x
.text$x:00006CA8                 ;org 6CA8h
.text$x:00006CA8 ; COMDAT (pick associative to section at 6C5C)
.text$x:00006CA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006CA8
.text$x:00006CA8 ; =============== S U B R O U T I N E =======================================
.text$x:00006CA8
.text$x:00006CA8
.text$x:00006CA8 __unwindfunclet$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006CA8                                         ; DATA XREF: .xdata$x:0000C098o
.text$x:00006CA8                 mov     ecx, [ebp-10h]  ; this
.text$x:00006CAB                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00006CAB __unwindfunclet$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006CAB
.text$x:00006CB0
.text$x:00006CB0 ; =============== S U B R O U T I N E =======================================
.text$x:00006CB0
.text$x:00006CB0
.text$x:00006CB0 __ehhandler$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006CB0                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(void)+5o
.text$x:00006CB0
.text$x:00006CB0 arg_4           = dword ptr  8
.text$x:00006CB0
.text$x:00006CB0                 mov     edx, [esp+arg_4]
.text$x:00006CB4                 lea     eax, [edx+0Ch]
.text$x:00006CB7                 mov     ecx, [edx-8]
.text$x:00006CBA                 xor     ecx, eax
.text$x:00006CBC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006CC1                 mov     eax, offset __ehfuncinfo$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ
.text$x:00006CC6                 jmp     ___CxxFrameHandler3
.text$x:00006CC6 __ehhandler$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ endp
.text$x:00006CC6
.text$x:00006CC6 ; ---------------------------------------------------------------------------
.text$x:00006CCB                 align 4
.text$x:00006CCB _text$x         ends
.text$x:00006CCB
.text$mn:00006CCC ; ===========================================================================
.text$mn:00006CCC
.text$mn:00006CCC ; Segment type: Pure code
.text$mn:00006CCC ; Segment permissions: Read/Execute
.text$mn:00006CCC _text$mn        segment para public 'CODE' use32
.text$mn:00006CCC                 assume cs:_text$mn
.text$mn:00006CCC                 ;org 6CCCh
.text$mn:00006CCC ; COMDAT (pick any)
.text$mn:00006CCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006CCC
.text$mn:00006CCC ; =============== S U B R O U T I N E =======================================
.text$mn:00006CCC
.text$mn:00006CCC ; Attributes: bp-based frame
.text$mn:00006CCC
.text$mn:00006CCC ; public: __thiscall std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>>::~_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>>(void)
.text$mn:00006CCC                 public ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ
.text$mn:00006CCC ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006CCC                                         ; CODE XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator-(int)+67p
.text$mn:00006CCC                                         ; __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z$0+3j ...
.text$mn:00006CCC
.text$mn:00006CCC var_10          = dword ptr -10h
.text$mn:00006CCC var_C           = dword ptr -0Ch
.text$mn:00006CCC var_4           = dword ptr -4
.text$mn:00006CCC
.text$mn:00006CCC                 push    ebp
.text$mn:00006CCD                 mov     ebp, esp
.text$mn:00006CCF                 push    0FFFFFFFFh
.text$mn:00006CD1                 push    offset __ehhandler$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ
.text$mn:00006CD6                 mov     eax, large fs:0
.text$mn:00006CDC                 push    eax
.text$mn:00006CDD                 push    ecx
.text$mn:00006CDE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006CE3                 xor     eax, ebp
.text$mn:00006CE5                 push    eax
.text$mn:00006CE6                 lea     eax, [ebp+var_C]
.text$mn:00006CE9                 mov     large fs:0, eax
.text$mn:00006CEF                 mov     [ebp+var_10], ecx
.text$mn:00006CF2                 mov     [ebp+var_4], 0
.text$mn:00006CF9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006D00                 mov     ecx, [ebp+var_10]
.text$mn:00006D03                 call    ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(void)
.text$mn:00006D08                 mov     ecx, [ebp+var_C]
.text$mn:00006D0B                 mov     large fs:0, ecx
.text$mn:00006D12                 pop     ecx
.text$mn:00006D13                 mov     esp, ebp
.text$mn:00006D15                 pop     ebp
.text$mn:00006D16                 retn
.text$mn:00006D16 ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006D16
.text$mn:00006D16 ; ---------------------------------------------------------------------------
.text$mn:00006D17                 align 4
.text$mn:00006D17 _text$mn        ends
.text$mn:00006D17
.text$x:00006D18 ; ===========================================================================
.text$x:00006D18
.text$x:00006D18 ; Segment type: Pure code
.text$x:00006D18 ; Segment permissions: Read/Execute
.text$x:00006D18 _text$x         segment para public 'CODE' use32
.text$x:00006D18                 assume cs:_text$x
.text$x:00006D18                 ;org 6D18h
.text$x:00006D18 ; COMDAT (pick associative to section at 6CCC)
.text$x:00006D18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006D18
.text$x:00006D18 ; =============== S U B R O U T I N E =======================================
.text$x:00006D18
.text$x:00006D18
.text$x:00006D18 __unwindfunclet$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006D18                                         ; DATA XREF: .xdata$x:0000C150o
.text$x:00006D18                 mov     ecx, [ebp-10h]
.text$x:00006D1B                 jmp     ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(void)
.text$x:00006D1B __unwindfunclet$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006D1B
.text$x:00006D20
.text$x:00006D20 ; =============== S U B R O U T I N E =======================================
.text$x:00006D20
.text$x:00006D20
.text$x:00006D20 __ehhandler$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006D20                                         ; DATA XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(void)+5o
.text$x:00006D20
.text$x:00006D20 arg_4           = dword ptr  8
.text$x:00006D20
.text$x:00006D20                 mov     edx, [esp+arg_4]
.text$x:00006D24                 lea     eax, [edx+0Ch]
.text$x:00006D27                 mov     ecx, [edx-8]
.text$x:00006D2A                 xor     ecx, eax
.text$x:00006D2C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006D31                 mov     eax, offset __ehfuncinfo$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ
.text$x:00006D36                 jmp     ___CxxFrameHandler3
.text$x:00006D36 __ehhandler$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ endp
.text$x:00006D36
.text$x:00006D36 ; ---------------------------------------------------------------------------
.text$x:00006D3B                 align 4
.text$x:00006D3B _text$x         ends
.text$x:00006D3B
.text$mn:00006D3C ; ===========================================================================
.text$mn:00006D3C
.text$mn:00006D3C ; Segment type: Pure code
.text$mn:00006D3C ; Segment permissions: Read/Execute
.text$mn:00006D3C _text$mn        segment para public 'CODE' use32
.text$mn:00006D3C                 assume cs:_text$mn
.text$mn:00006D3C                 ;org 6D3Ch
.text$mn:00006D3C ; COMDAT (pick any)
.text$mn:00006D3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006D3C
.text$mn:00006D3C ; =============== S U B R O U T I N E =======================================
.text$mn:00006D3C
.text$mn:00006D3C ; Attributes: bp-based frame
.text$mn:00006D3C
.text$mn:00006D3C ; public: __thiscall std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>::~_Deque_val<struct std::_Deque_simple_types<unsigned int>>(void)
.text$mn:00006D3C                 public ??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ
.text$mn:00006D3C ??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ proc near
.text$mn:00006D3C                                         ; CODE XREF: __unwindfunclet$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z$0+3j
.text$mn:00006D3C                                         ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::~_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>(void)+3Fp ...
.text$mn:00006D3C
.text$mn:00006D3C var_10          = dword ptr -10h
.text$mn:00006D3C var_C           = dword ptr -0Ch
.text$mn:00006D3C var_4           = dword ptr -4
.text$mn:00006D3C
.text$mn:00006D3C                 push    ebp
.text$mn:00006D3D                 mov     ebp, esp
.text$mn:00006D3F                 push    0FFFFFFFFh
.text$mn:00006D41                 push    offset __ehhandler$??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ
.text$mn:00006D46                 mov     eax, large fs:0
.text$mn:00006D4C                 push    eax
.text$mn:00006D4D                 push    ecx
.text$mn:00006D4E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006D53                 xor     eax, ebp
.text$mn:00006D55                 push    eax
.text$mn:00006D56                 lea     eax, [ebp+var_C]
.text$mn:00006D59                 mov     large fs:0, eax
.text$mn:00006D5F                 mov     [ebp+var_10], ecx
.text$mn:00006D62                 mov     [ebp+var_4], 0
.text$mn:00006D69                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006D70                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006D73                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00006D78                 mov     ecx, [ebp+var_C]
.text$mn:00006D7B                 mov     large fs:0, ecx
.text$mn:00006D82                 pop     ecx
.text$mn:00006D83                 mov     esp, ebp
.text$mn:00006D85                 pop     ebp
.text$mn:00006D86                 retn
.text$mn:00006D86 ??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ endp
.text$mn:00006D86
.text$mn:00006D86 ; ---------------------------------------------------------------------------
.text$mn:00006D87                 align 4
.text$mn:00006D87 _text$mn        ends
.text$mn:00006D87
.text$x:00006D88 ; ===========================================================================
.text$x:00006D88
.text$x:00006D88 ; Segment type: Pure code
.text$x:00006D88 ; Segment permissions: Read/Execute
.text$x:00006D88 _text$x         segment para public 'CODE' use32
.text$x:00006D88                 assume cs:_text$x
.text$x:00006D88                 ;org 6D88h
.text$x:00006D88 ; COMDAT (pick associative to section at 6D3C)
.text$x:00006D88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006D88
.text$x:00006D88 ; =============== S U B R O U T I N E =======================================
.text$x:00006D88
.text$x:00006D88
.text$x:00006D88 __unwindfunclet$??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ$0 proc near
.text$x:00006D88                                         ; DATA XREF: .xdata$x:0000BEACo
.text$x:00006D88                 mov     ecx, [ebp-10h]  ; this
.text$x:00006D8B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00006D8B __unwindfunclet$??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ$0 endp
.text$x:00006D8B
.text$x:00006D90
.text$x:00006D90 ; =============== S U B R O U T I N E =======================================
.text$x:00006D90
.text$x:00006D90
.text$x:00006D90 __ehhandler$??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ proc near
.text$x:00006D90                                         ; DATA XREF: std::_Deque_val<std::_Deque_simple_types<uint>>::~_Deque_val<std::_Deque_simple_types<uint>>(void)+5o
.text$x:00006D90
.text$x:00006D90 arg_4           = dword ptr  8
.text$x:00006D90
.text$x:00006D90                 mov     edx, [esp+arg_4]
.text$x:00006D94                 lea     eax, [edx+0Ch]
.text$x:00006D97                 mov     ecx, [edx-8]
.text$x:00006D9A                 xor     ecx, eax
.text$x:00006D9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006DA1                 mov     eax, offset __ehfuncinfo$??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ
.text$x:00006DA6                 jmp     ___CxxFrameHandler3
.text$x:00006DA6 __ehhandler$??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ endp
.text$x:00006DA6
.text$x:00006DA6 ; ---------------------------------------------------------------------------
.text$x:00006DAB                 align 4
.text$x:00006DAB _text$x         ends
.text$x:00006DAB
.text$mn:00006DAC ; ===========================================================================
.text$mn:00006DAC
.text$mn:00006DAC ; Segment type: Pure code
.text$mn:00006DAC ; Segment permissions: Read/Execute
.text$mn:00006DAC _text$mn        segment para public 'CODE' use32
.text$mn:00006DAC                 assume cs:_text$mn
.text$mn:00006DAC                 ;org 6DACh
.text$mn:00006DAC ; COMDAT (pick any)
.text$mn:00006DAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006DAC
.text$mn:00006DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00006DAC
.text$mn:00006DAC ; Attributes: bp-based frame
.text$mn:00006DAC
.text$mn:00006DAC ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00006DAC                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00006DAC ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006DAC                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00006DAC                                         ; __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0+3j ...
.text$mn:00006DAC
.text$mn:00006DAC var_10          = dword ptr -10h
.text$mn:00006DAC var_C           = dword ptr -0Ch
.text$mn:00006DAC var_4           = dword ptr -4
.text$mn:00006DAC
.text$mn:00006DAC                 push    ebp
.text$mn:00006DAD                 mov     ebp, esp
.text$mn:00006DAF                 push    0FFFFFFFFh
.text$mn:00006DB1                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00006DB6                 mov     eax, large fs:0
.text$mn:00006DBC                 push    eax
.text$mn:00006DBD                 push    ecx
.text$mn:00006DBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006DC3                 xor     eax, ebp
.text$mn:00006DC5                 push    eax
.text$mn:00006DC6                 lea     eax, [ebp+var_C]
.text$mn:00006DC9                 mov     large fs:0, eax
.text$mn:00006DCF                 mov     [ebp+var_10], ecx
.text$mn:00006DD2                 mov     [ebp+var_4], 0
.text$mn:00006DD9                 mov     ecx, [ebp+var_10]
.text$mn:00006DDC                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00006DE1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006DE8                 mov     ecx, [ebp+var_10]
.text$mn:00006DEB                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00006DF0                 mov     ecx, [ebp+var_C]
.text$mn:00006DF3                 mov     large fs:0, ecx
.text$mn:00006DFA                 pop     ecx
.text$mn:00006DFB                 mov     esp, ebp
.text$mn:00006DFD                 pop     ebp
.text$mn:00006DFE                 retn
.text$mn:00006DFE ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006DFE
.text$mn:00006DFE ; ---------------------------------------------------------------------------
.text$mn:00006DFF                 align 10h
.text$mn:00006DFF _text$mn        ends
.text$mn:00006DFF
.text$x:00006E00 ; ===========================================================================
.text$x:00006E00
.text$x:00006E00 ; Segment type: Pure code
.text$x:00006E00 ; Segment permissions: Read/Execute
.text$x:00006E00 _text$x         segment para public 'CODE' use32
.text$x:00006E00                 assume cs:_text$x
.text$x:00006E00                 ;org 6E00h
.text$x:00006E00 ; COMDAT (pick associative to section at 6DAC)
.text$x:00006E00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006E00
.text$x:00006E00 ; =============== S U B R O U T I N E =======================================
.text$x:00006E00
.text$x:00006E00
.text$x:00006E00 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006E00                                         ; DATA XREF: .xdata$x:0000B56Co
.text$x:00006E00                 mov     ecx, [ebp-10h]
.text$x:00006E03                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00006E03 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006E03
.text$x:00006E08
.text$x:00006E08 ; =============== S U B R O U T I N E =======================================
.text$x:00006E08
.text$x:00006E08
.text$x:00006E08 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006E08                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00006E08
.text$x:00006E08 arg_4           = dword ptr  8
.text$x:00006E08
.text$x:00006E08                 mov     edx, [esp+arg_4]
.text$x:00006E0C                 lea     eax, [edx+0Ch]
.text$x:00006E0F                 mov     ecx, [edx-8]
.text$x:00006E12                 xor     ecx, eax
.text$x:00006E14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006E19                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00006E1E                 jmp     ___CxxFrameHandler3
.text$x:00006E1E __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00006E1E
.text$x:00006E1E ; ---------------------------------------------------------------------------
.text$x:00006E23                 align 4
.text$x:00006E23 _text$x         ends
.text$x:00006E23
.text$mn:00006E24 ; ===========================================================================
.text$mn:00006E24
.text$mn:00006E24 ; Segment type: Pure code
.text$mn:00006E24 ; Segment permissions: Read/Execute
.text$mn:00006E24 _text$mn        segment para public 'CODE' use32
.text$mn:00006E24                 assume cs:_text$mn
.text$mn:00006E24                 ;org 6E24h
.text$mn:00006E24 ; COMDAT (pick any)
.text$mn:00006E24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006E24
.text$mn:00006E24 ; =============== S U B R O U T I N E =======================================
.text$mn:00006E24
.text$mn:00006E24 ; Attributes: bp-based frame
.text$mn:00006E24
.text$mn:00006E24 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:00006E24                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00006E24 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006E24                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00006E24                                         ; __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0+3j ...
.text$mn:00006E24
.text$mn:00006E24 var_10          = dword ptr -10h
.text$mn:00006E24 var_C           = dword ptr -0Ch
.text$mn:00006E24 var_4           = dword ptr -4
.text$mn:00006E24
.text$mn:00006E24                 push    ebp
.text$mn:00006E25                 mov     ebp, esp
.text$mn:00006E27                 push    0FFFFFFFFh
.text$mn:00006E29                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00006E2E                 mov     eax, large fs:0
.text$mn:00006E34                 push    eax
.text$mn:00006E35                 push    ecx
.text$mn:00006E36                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006E3B                 xor     eax, ebp
.text$mn:00006E3D                 push    eax
.text$mn:00006E3E                 lea     eax, [ebp+var_C]
.text$mn:00006E41                 mov     large fs:0, eax
.text$mn:00006E47                 mov     [ebp+var_10], ecx
.text$mn:00006E4A                 mov     [ebp+var_4], 0
.text$mn:00006E51                 mov     ecx, [ebp+var_10]
.text$mn:00006E54                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00006E59                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006E60                 mov     ecx, [ebp+var_10]
.text$mn:00006E63                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00006E68                 mov     ecx, [ebp+var_C]
.text$mn:00006E6B                 mov     large fs:0, ecx
.text$mn:00006E72                 pop     ecx
.text$mn:00006E73                 mov     esp, ebp
.text$mn:00006E75                 pop     ebp
.text$mn:00006E76                 retn
.text$mn:00006E76 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006E76
.text$mn:00006E76 ; ---------------------------------------------------------------------------
.text$mn:00006E77                 align 4
.text$mn:00006E77 _text$mn        ends
.text$mn:00006E77
.text$x:00006E78 ; ===========================================================================
.text$x:00006E78
.text$x:00006E78 ; Segment type: Pure code
.text$x:00006E78 ; Segment permissions: Read/Execute
.text$x:00006E78 _text$x         segment para public 'CODE' use32
.text$x:00006E78                 assume cs:_text$x
.text$x:00006E78                 ;org 6E78h
.text$x:00006E78 ; COMDAT (pick associative to section at 6E24)
.text$x:00006E78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006E78
.text$x:00006E78 ; =============== S U B R O U T I N E =======================================
.text$x:00006E78
.text$x:00006E78
.text$x:00006E78 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006E78                                         ; DATA XREF: .xdata$x:0000B8B8o
.text$x:00006E78                 mov     ecx, [ebp-10h]
.text$x:00006E7B                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00006E7B __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006E7B
.text$x:00006E80
.text$x:00006E80 ; =============== S U B R O U T I N E =======================================
.text$x:00006E80
.text$x:00006E80
.text$x:00006E80 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006E80                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:00006E80
.text$x:00006E80 arg_4           = dword ptr  8
.text$x:00006E80
.text$x:00006E80                 mov     edx, [esp+arg_4]
.text$x:00006E84                 lea     eax, [edx+0Ch]
.text$x:00006E87                 mov     ecx, [edx-8]
.text$x:00006E8A                 xor     ecx, eax
.text$x:00006E8C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006E91                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:00006E96                 jmp     ___CxxFrameHandler3
.text$x:00006E96 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:00006E96
.text$x:00006E96 ; ---------------------------------------------------------------------------
.text$x:00006E9B                 align 4
.text$x:00006E9B _text$x         ends
.text$x:00006E9B
.text$mn:00006E9C ; ===========================================================================
.text$mn:00006E9C
.text$mn:00006E9C ; Segment type: Pure code
.text$mn:00006E9C ; Segment permissions: Read/Execute
.text$mn:00006E9C _text$mn        segment para public 'CODE' use32
.text$mn:00006E9C                 assume cs:_text$mn
.text$mn:00006E9C                 ;org 6E9Ch
.text$mn:00006E9C ; COMDAT (pick any)
.text$mn:00006E9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006E9C
.text$mn:00006E9C ; =============== S U B R O U T I N E =======================================
.text$mn:00006E9C
.text$mn:00006E9C ; Attributes: bp-based frame
.text$mn:00006E9C
.text$mn:00006E9C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00006E9C                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00006E9C ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00006E9C                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00006E9C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00006E9C
.text$mn:00006E9C var_10          = dword ptr -10h
.text$mn:00006E9C var_C           = dword ptr -0Ch
.text$mn:00006E9C var_4           = dword ptr -4
.text$mn:00006E9C
.text$mn:00006E9C                 push    ebp
.text$mn:00006E9D                 mov     ebp, esp
.text$mn:00006E9F                 push    0FFFFFFFFh
.text$mn:00006EA1                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00006EA6                 mov     eax, large fs:0
.text$mn:00006EAC                 push    eax
.text$mn:00006EAD                 push    ecx
.text$mn:00006EAE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006EB3                 xor     eax, ebp
.text$mn:00006EB5                 push    eax
.text$mn:00006EB6                 lea     eax, [ebp+var_C]
.text$mn:00006EB9                 mov     large fs:0, eax
.text$mn:00006EBF                 mov     [ebp+var_10], ecx
.text$mn:00006EC2                 mov     [ebp+var_4], 0
.text$mn:00006EC9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006ED0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006ED3                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00006ED8                 mov     ecx, [ebp+var_C]
.text$mn:00006EDB                 mov     large fs:0, ecx
.text$mn:00006EE2                 pop     ecx
.text$mn:00006EE3                 mov     esp, ebp
.text$mn:00006EE5                 pop     ebp
.text$mn:00006EE6                 retn
.text$mn:00006EE6 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00006EE6
.text$mn:00006EE6 ; ---------------------------------------------------------------------------
.text$mn:00006EE7                 align 4
.text$mn:00006EE7 _text$mn        ends
.text$mn:00006EE7
.text$x:00006EE8 ; ===========================================================================
.text$x:00006EE8
.text$x:00006EE8 ; Segment type: Pure code
.text$x:00006EE8 ; Segment permissions: Read/Execute
.text$x:00006EE8 _text$x         segment para public 'CODE' use32
.text$x:00006EE8                 assume cs:_text$x
.text$x:00006EE8                 ;org 6EE8h
.text$x:00006EE8 ; COMDAT (pick associative to section at 6E9C)
.text$x:00006EE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006EE8
.text$x:00006EE8 ; =============== S U B R O U T I N E =======================================
.text$x:00006EE8
.text$x:00006EE8
.text$x:00006EE8 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00006EE8                                         ; DATA XREF: .xdata$x:0000B514o
.text$x:00006EE8                 mov     ecx, [ebp-10h]  ; this
.text$x:00006EEB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00006EEB __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00006EEB
.text$x:00006EF0
.text$x:00006EF0 ; =============== S U B R O U T I N E =======================================
.text$x:00006EF0
.text$x:00006EF0
.text$x:00006EF0 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00006EF0                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00006EF0
.text$x:00006EF0 arg_4           = dword ptr  8
.text$x:00006EF0
.text$x:00006EF0                 mov     edx, [esp+arg_4]
.text$x:00006EF4                 lea     eax, [edx+0Ch]
.text$x:00006EF7                 mov     ecx, [edx-8]
.text$x:00006EFA                 xor     ecx, eax
.text$x:00006EFC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006F01                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00006F06                 jmp     ___CxxFrameHandler3
.text$x:00006F06 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00006F06
.text$x:00006F06 ; ---------------------------------------------------------------------------
.text$x:00006F0B                 align 4
.text$x:00006F0B _text$x         ends
.text$x:00006F0B
.text$mn:00006F0C ; ===========================================================================
.text$mn:00006F0C
.text$mn:00006F0C ; Segment type: Pure code
.text$mn:00006F0C ; Segment permissions: Read/Execute
.text$mn:00006F0C _text$mn        segment para public 'CODE' use32
.text$mn:00006F0C                 assume cs:_text$mn
.text$mn:00006F0C                 ;org 6F0Ch
.text$mn:00006F0C ; COMDAT (pick any)
.text$mn:00006F0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006F0C
.text$mn:00006F0C ; =============== S U B R O U T I N E =======================================
.text$mn:00006F0C
.text$mn:00006F0C ; Attributes: bp-based frame
.text$mn:00006F0C
.text$mn:00006F0C ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00006F0C                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00006F0C ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00006F0C                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:00006F0C                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:00006F0C
.text$mn:00006F0C var_10          = dword ptr -10h
.text$mn:00006F0C var_C           = dword ptr -0Ch
.text$mn:00006F0C var_4           = dword ptr -4
.text$mn:00006F0C
.text$mn:00006F0C                 push    ebp
.text$mn:00006F0D                 mov     ebp, esp
.text$mn:00006F0F                 push    0FFFFFFFFh
.text$mn:00006F11                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00006F16                 mov     eax, large fs:0
.text$mn:00006F1C                 push    eax
.text$mn:00006F1D                 push    ecx
.text$mn:00006F1E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006F23                 xor     eax, ebp
.text$mn:00006F25                 push    eax
.text$mn:00006F26                 lea     eax, [ebp+var_C]
.text$mn:00006F29                 mov     large fs:0, eax
.text$mn:00006F2F                 mov     [ebp+var_10], ecx
.text$mn:00006F32                 mov     [ebp+var_4], 0
.text$mn:00006F39                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006F40                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006F43                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00006F48                 mov     ecx, [ebp+var_C]
.text$mn:00006F4B                 mov     large fs:0, ecx
.text$mn:00006F52                 pop     ecx
.text$mn:00006F53                 mov     esp, ebp
.text$mn:00006F55                 pop     ebp
.text$mn:00006F56                 retn
.text$mn:00006F56 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00006F56
.text$mn:00006F56 ; ---------------------------------------------------------------------------
.text$mn:00006F57                 align 4
.text$mn:00006F57 _text$mn        ends
.text$mn:00006F57
.text$x:00006F58 ; ===========================================================================
.text$x:00006F58
.text$x:00006F58 ; Segment type: Pure code
.text$x:00006F58 ; Segment permissions: Read/Execute
.text$x:00006F58 _text$x         segment para public 'CODE' use32
.text$x:00006F58                 assume cs:_text$x
.text$x:00006F58                 ;org 6F58h
.text$x:00006F58 ; COMDAT (pick associative to section at 6F0C)
.text$x:00006F58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006F58
.text$x:00006F58 ; =============== S U B R O U T I N E =======================================
.text$x:00006F58
.text$x:00006F58
.text$x:00006F58 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00006F58                                         ; DATA XREF: .xdata$x:0000B860o
.text$x:00006F58                 mov     ecx, [ebp-10h]  ; this
.text$x:00006F5B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00006F5B __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00006F5B
.text$x:00006F60
.text$x:00006F60 ; =============== S U B R O U T I N E =======================================
.text$x:00006F60
.text$x:00006F60
.text$x:00006F60 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00006F60                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00006F60
.text$x:00006F60 arg_4           = dword ptr  8
.text$x:00006F60
.text$x:00006F60                 mov     edx, [esp+arg_4]
.text$x:00006F64                 lea     eax, [edx+0Ch]
.text$x:00006F67                 mov     ecx, [edx-8]
.text$x:00006F6A                 xor     ecx, eax
.text$x:00006F6C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006F71                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00006F76                 jmp     ___CxxFrameHandler3
.text$x:00006F76 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00006F76
.text$x:00006F76 ; ---------------------------------------------------------------------------
.text$x:00006F7B                 align 4
.text$x:00006F7B _text$x         ends
.text$x:00006F7B
.text$mn:00006F7C ; ===========================================================================
.text$mn:00006F7C
.text$mn:00006F7C ; Segment type: Pure code
.text$mn:00006F7C ; Segment permissions: Read/Execute
.text$mn:00006F7C _text$mn        segment para public 'CODE' use32
.text$mn:00006F7C                 assume cs:_text$mn
.text$mn:00006F7C                 ;org 6F7Ch
.text$mn:00006F7C ; COMDAT (pick any)
.text$mn:00006F7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006F7C
.text$mn:00006F7C ; =============== S U B R O U T I N E =======================================
.text$mn:00006F7C
.text$mn:00006F7C ; Attributes: bp-based frame
.text$mn:00006F7C
.text$mn:00006F7C ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>>::~_Vector_alloc<0, struct std::_Vec_base_types<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>>(void)
.text$mn:00006F7C                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ
.text$mn:00006F7C ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00006F7C                                         ; CODE XREF: __unwindfunclet$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ$0+3j
.text$mn:00006F7C                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::~vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)+3Fp ...
.text$mn:00006F7C
.text$mn:00006F7C var_10          = dword ptr -10h
.text$mn:00006F7C var_C           = dword ptr -0Ch
.text$mn:00006F7C var_4           = dword ptr -4
.text$mn:00006F7C
.text$mn:00006F7C                 push    ebp
.text$mn:00006F7D                 mov     ebp, esp
.text$mn:00006F7F                 push    0FFFFFFFFh
.text$mn:00006F81                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ
.text$mn:00006F86                 mov     eax, large fs:0
.text$mn:00006F8C                 push    eax
.text$mn:00006F8D                 push    ecx
.text$mn:00006F8E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006F93                 xor     eax, ebp
.text$mn:00006F95                 push    eax
.text$mn:00006F96                 lea     eax, [ebp+var_C]
.text$mn:00006F99                 mov     large fs:0, eax
.text$mn:00006F9F                 mov     [ebp+var_10], ecx
.text$mn:00006FA2                 mov     [ebp+var_4], 0
.text$mn:00006FA9                 mov     ecx, [ebp+var_10]
.text$mn:00006FAC                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Free_proxy(void)
.text$mn:00006FB1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006FB8                 mov     ecx, [ebp+var_10]
.text$mn:00006FBB                 call    ??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<MenuItemUnit>>::~_Vector_val<std::_Simple_types<MenuItemUnit>>(void)
.text$mn:00006FC0                 mov     ecx, [ebp+var_C]
.text$mn:00006FC3                 mov     large fs:0, ecx
.text$mn:00006FCA                 pop     ecx
.text$mn:00006FCB                 mov     esp, ebp
.text$mn:00006FCD                 pop     ebp
.text$mn:00006FCE                 retn
.text$mn:00006FCE ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00006FCE
.text$mn:00006FCE ; ---------------------------------------------------------------------------
.text$mn:00006FCF                 align 10h
.text$mn:00006FCF _text$mn        ends
.text$mn:00006FCF
.text$x:00006FD0 ; ===========================================================================
.text$x:00006FD0
.text$x:00006FD0 ; Segment type: Pure code
.text$x:00006FD0 ; Segment permissions: Read/Execute
.text$x:00006FD0 _text$x         segment para public 'CODE' use32
.text$x:00006FD0                 assume cs:_text$x
.text$x:00006FD0                 ;org 6FD0h
.text$x:00006FD0 ; COMDAT (pick associative to section at 6F7C)
.text$x:00006FD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00006FD0
.text$x:00006FD0 ; =============== S U B R O U T I N E =======================================
.text$x:00006FD0
.text$x:00006FD0
.text$x:00006FD0 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00006FD0                                         ; DATA XREF: .xdata$x:0000BBE8o
.text$x:00006FD0                 mov     ecx, [ebp-10h]
.text$x:00006FD3                 jmp     ??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<MenuItemUnit>>::~_Vector_val<std::_Simple_types<MenuItemUnit>>(void)
.text$x:00006FD3 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00006FD3
.text$x:00006FD8
.text$x:00006FD8 ; =============== S U B R O U T I N E =======================================
.text$x:00006FD8
.text$x:00006FD8
.text$x:00006FD8 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00006FD8                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::~_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(void)+5o
.text$x:00006FD8
.text$x:00006FD8 arg_4           = dword ptr  8
.text$x:00006FD8
.text$x:00006FD8                 mov     edx, [esp+arg_4]
.text$x:00006FDC                 lea     eax, [edx+0Ch]
.text$x:00006FDF                 mov     ecx, [edx-8]
.text$x:00006FE2                 xor     ecx, eax
.text$x:00006FE4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006FE9                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ
.text$x:00006FEE                 jmp     ___CxxFrameHandler3
.text$x:00006FEE __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00006FEE
.text$x:00006FEE ; ---------------------------------------------------------------------------
.text$x:00006FF3                 align 4
.text$x:00006FF3 _text$x         ends
.text$x:00006FF3
.text$mn:00006FF4 ; ===========================================================================
.text$mn:00006FF4
.text$mn:00006FF4 ; Segment type: Pure code
.text$mn:00006FF4 ; Segment permissions: Read/Execute
.text$mn:00006FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00006FF4                 assume cs:_text$mn
.text$mn:00006FF4                 ;org 6FF4h
.text$mn:00006FF4 ; COMDAT (pick any)
.text$mn:00006FF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00006FF4
.text$mn:00006FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FF4
.text$mn:00006FF4 ; Attributes: bp-based frame
.text$mn:00006FF4
.text$mn:00006FF4 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<struct MenuItemUnit>>::~_Vector_val<struct std::_Simple_types<struct MenuItemUnit>>(void)
.text$mn:00006FF4                 public ??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:00006FF4 ??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$mn:00006FF4                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z$0+3j
.text$mn:00006FF4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::~_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(void)+3Fp ...
.text$mn:00006FF4
.text$mn:00006FF4 var_10          = dword ptr -10h
.text$mn:00006FF4 var_C           = dword ptr -0Ch
.text$mn:00006FF4 var_4           = dword ptr -4
.text$mn:00006FF4
.text$mn:00006FF4                 push    ebp
.text$mn:00006FF5                 mov     ebp, esp
.text$mn:00006FF7                 push    0FFFFFFFFh
.text$mn:00006FF9                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:00006FFE                 mov     eax, large fs:0
.text$mn:00007004                 push    eax
.text$mn:00007005                 push    ecx
.text$mn:00007006                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000700B                 xor     eax, ebp
.text$mn:0000700D                 push    eax
.text$mn:0000700E                 lea     eax, [ebp+var_C]
.text$mn:00007011                 mov     large fs:0, eax
.text$mn:00007017                 mov     [ebp+var_10], ecx
.text$mn:0000701A                 mov     [ebp+var_4], 0
.text$mn:00007021                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007028                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000702B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00007030                 mov     ecx, [ebp+var_C]
.text$mn:00007033                 mov     large fs:0, ecx
.text$mn:0000703A                 pop     ecx
.text$mn:0000703B                 mov     esp, ebp
.text$mn:0000703D                 pop     ebp
.text$mn:0000703E                 retn
.text$mn:0000703E ??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$mn:0000703E
.text$mn:0000703E ; ---------------------------------------------------------------------------
.text$mn:0000703F                 align 10h
.text$mn:0000703F _text$mn        ends
.text$mn:0000703F
.text$x:00007040 ; ===========================================================================
.text$x:00007040
.text$x:00007040 ; Segment type: Pure code
.text$x:00007040 ; Segment permissions: Read/Execute
.text$x:00007040 _text$x         segment para public 'CODE' use32
.text$x:00007040                 assume cs:_text$x
.text$x:00007040                 ;org 7040h
.text$x:00007040 ; COMDAT (pick associative to section at 6FF4)
.text$x:00007040                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007040
.text$x:00007040 ; =============== S U B R O U T I N E =======================================
.text$x:00007040
.text$x:00007040
.text$x:00007040 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007040                                         ; DATA XREF: .xdata$x:0000BB90o
.text$x:00007040                 mov     ecx, [ebp-10h]  ; this
.text$x:00007043                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00007043 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007043
.text$x:00007048
.text$x:00007048 ; =============== S U B R O U T I N E =======================================
.text$x:00007048
.text$x:00007048
.text$x:00007048 __ehhandler$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$x:00007048                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<MenuItemUnit>>::~_Vector_val<std::_Simple_types<MenuItemUnit>>(void)+5o
.text$x:00007048
.text$x:00007048 arg_4           = dword ptr  8
.text$x:00007048
.text$x:00007048                 mov     edx, [esp+arg_4]
.text$x:0000704C                 lea     eax, [edx+0Ch]
.text$x:0000704F                 mov     ecx, [edx-8]
.text$x:00007052                 xor     ecx, eax
.text$x:00007054                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007059                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$x:0000705E                 jmp     ___CxxFrameHandler3
.text$x:0000705E __ehhandler$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$x:0000705E
.text$x:0000705E ; ---------------------------------------------------------------------------
.text$x:00007063                 align 4
.text$x:00007063 _text$x         ends
.text$x:00007063
.text$mn:00007064 ; ===========================================================================
.text$mn:00007064
.text$mn:00007064 ; Segment type: Pure code
.text$mn:00007064 ; Segment permissions: Read/Execute
.text$mn:00007064 _text$mn        segment para public 'CODE' use32
.text$mn:00007064                 assume cs:_text$mn
.text$mn:00007064                 ;org 7064h
.text$mn:00007064 ; COMDAT (pick any)
.text$mn:00007064                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007064
.text$mn:00007064 ; =============== S U B R O U T I N E =======================================
.text$mn:00007064
.text$mn:00007064 ; Attributes: bp-based frame
.text$mn:00007064
.text$mn:00007064 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00007064                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00007064 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00007064                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+245Cp
.text$mn:00007064                                         ; Notepad_plus::notify(SCNotification *)+2758p ...
.text$mn:00007064
.text$mn:00007064 var_10          = dword ptr -10h
.text$mn:00007064 var_C           = dword ptr -0Ch
.text$mn:00007064 var_4           = dword ptr -4
.text$mn:00007064
.text$mn:00007064                 push    ebp
.text$mn:00007065                 mov     ebp, esp
.text$mn:00007067                 push    0FFFFFFFFh
.text$mn:00007069                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000706E                 mov     eax, large fs:0
.text$mn:00007074                 push    eax
.text$mn:00007075                 push    ecx
.text$mn:00007076                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000707B                 xor     eax, ebp
.text$mn:0000707D                 push    eax
.text$mn:0000707E                 lea     eax, [ebp+var_C]
.text$mn:00007081                 mov     large fs:0, eax
.text$mn:00007087                 mov     [ebp+var_10], ecx
.text$mn:0000708A                 mov     [ebp+var_4], 0
.text$mn:00007091                 push    0               ; Size
.text$mn:00007093                 push    1               ; char
.text$mn:00007095                 mov     ecx, [ebp+var_10]
.text$mn:00007098                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000709D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000070A4                 mov     ecx, [ebp+var_10]
.text$mn:000070A7                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:000070AC                 mov     ecx, [ebp+var_C]
.text$mn:000070AF                 mov     large fs:0, ecx
.text$mn:000070B6                 pop     ecx
.text$mn:000070B7                 mov     esp, ebp
.text$mn:000070B9                 pop     ebp
.text$mn:000070BA                 retn
.text$mn:000070BA ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:000070BA
.text$mn:000070BA ; ---------------------------------------------------------------------------
.text$mn:000070BB                 align 4
.text$mn:000070BB _text$mn        ends
.text$mn:000070BB
.text$x:000070BC ; ===========================================================================
.text$x:000070BC
.text$x:000070BC ; Segment type: Pure code
.text$x:000070BC ; Segment permissions: Read/Execute
.text$x:000070BC _text$x         segment para public 'CODE' use32
.text$x:000070BC                 assume cs:_text$x
.text$x:000070BC                 ;org 70BCh
.text$x:000070BC ; COMDAT (pick associative to section at 7064)
.text$x:000070BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000070BC
.text$x:000070BC ; =============== S U B R O U T I N E =======================================
.text$x:000070BC
.text$x:000070BC
.text$x:000070BC __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:000070BC                                         ; DATA XREF: .xdata$x:0000B5F0o
.text$x:000070BC                 mov     ecx, [ebp-10h]
.text$x:000070BF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000070BF __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:000070BF
.text$x:000070C4
.text$x:000070C4 ; =============== S U B R O U T I N E =======================================
.text$x:000070C4
.text$x:000070C4
.text$x:000070C4 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:000070C4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:000070C4
.text$x:000070C4 arg_4           = dword ptr  8
.text$x:000070C4
.text$x:000070C4                 mov     edx, [esp+arg_4]
.text$x:000070C8                 lea     eax, [edx+0Ch]
.text$x:000070CB                 mov     ecx, [edx-8]
.text$x:000070CE                 xor     ecx, eax
.text$x:000070D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000070D5                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:000070DA                 jmp     ___CxxFrameHandler3
.text$x:000070DA __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:000070DA
.text$x:000070DA ; ---------------------------------------------------------------------------
.text$x:000070DF                 align 10h
.text$x:000070DF _text$x         ends
.text$x:000070DF
.text$mn:000070E0 ; ===========================================================================
.text$mn:000070E0
.text$mn:000070E0 ; Segment type: Pure code
.text$mn:000070E0 ; Segment permissions: Read/Execute
.text$mn:000070E0 _text$mn        segment para public 'CODE' use32
.text$mn:000070E0                 assume cs:_text$mn
.text$mn:000070E0                 ;org 70E0h
.text$mn:000070E0 ; COMDAT (pick any)
.text$mn:000070E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000070E0
.text$mn:000070E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000070E0
.text$mn:000070E0 ; Attributes: bp-based frame
.text$mn:000070E0
.text$mn:000070E0 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:000070E0                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:000070E0 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:000070E0                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+A7Cp
.text$mn:000070E0                                         ; Notepad_plus::notify(SCNotification *)+A8Bp ...
.text$mn:000070E0
.text$mn:000070E0 var_10          = dword ptr -10h
.text$mn:000070E0 var_C           = dword ptr -0Ch
.text$mn:000070E0 var_4           = dword ptr -4
.text$mn:000070E0
.text$mn:000070E0                 push    ebp
.text$mn:000070E1                 mov     ebp, esp
.text$mn:000070E3                 push    0FFFFFFFFh
.text$mn:000070E5                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:000070EA                 mov     eax, large fs:0
.text$mn:000070F0                 push    eax
.text$mn:000070F1                 push    ecx
.text$mn:000070F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000070F7                 xor     eax, ebp
.text$mn:000070F9                 push    eax
.text$mn:000070FA                 lea     eax, [ebp+var_C]
.text$mn:000070FD                 mov     large fs:0, eax
.text$mn:00007103                 mov     [ebp+var_10], ecx
.text$mn:00007106                 mov     [ebp+var_4], 0
.text$mn:0000710D                 push    0
.text$mn:0000710F                 push    1
.text$mn:00007111                 mov     ecx, [ebp+var_10]
.text$mn:00007114                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00007119                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007120                 mov     ecx, [ebp+var_10]
.text$mn:00007123                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00007128                 mov     ecx, [ebp+var_C]
.text$mn:0000712B                 mov     large fs:0, ecx
.text$mn:00007132                 pop     ecx
.text$mn:00007133                 mov     esp, ebp
.text$mn:00007135                 pop     ebp
.text$mn:00007136                 retn
.text$mn:00007136 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00007136
.text$mn:00007136 ; ---------------------------------------------------------------------------
.text$mn:00007137                 align 4
.text$mn:00007137 _text$mn        ends
.text$mn:00007137
.text$x:00007138 ; ===========================================================================
.text$x:00007138
.text$x:00007138 ; Segment type: Pure code
.text$x:00007138 ; Segment permissions: Read/Execute
.text$x:00007138 _text$x         segment para public 'CODE' use32
.text$x:00007138                 assume cs:_text$x
.text$x:00007138                 ;org 7138h
.text$x:00007138 ; COMDAT (pick associative to section at 70E0)
.text$x:00007138                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007138
.text$x:00007138 ; =============== S U B R O U T I N E =======================================
.text$x:00007138
.text$x:00007138
.text$x:00007138 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:00007138                                         ; DATA XREF: .xdata$x:0000B968o
.text$x:00007138                 mov     ecx, [ebp-10h]
.text$x:0000713B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000713B __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:0000713B
.text$x:00007140
.text$x:00007140 ; =============== S U B R O U T I N E =======================================
.text$x:00007140
.text$x:00007140
.text$x:00007140 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:00007140                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:00007140
.text$x:00007140 arg_4           = dword ptr  8
.text$x:00007140
.text$x:00007140                 mov     edx, [esp+arg_4]
.text$x:00007144                 lea     eax, [edx+0Ch]
.text$x:00007147                 mov     ecx, [edx-8]
.text$x:0000714A                 xor     ecx, eax
.text$x:0000714C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007151                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00007156                 jmp     ___CxxFrameHandler3
.text$x:00007156 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00007156
.text$x:00007156 ; ---------------------------------------------------------------------------
.text$x:0000715B                 align 4
.text$x:0000715B _text$x         ends
.text$x:0000715B
.text$mn:0000715C ; ===========================================================================
.text$mn:0000715C
.text$mn:0000715C ; Segment type: Pure code
.text$mn:0000715C ; Segment permissions: Read/Execute
.text$mn:0000715C _text$mn        segment para public 'CODE' use32
.text$mn:0000715C                 assume cs:_text$mn
.text$mn:0000715C                 ;org 715Ch
.text$mn:0000715C ; COMDAT (pick any)
.text$mn:0000715C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000715C
.text$mn:0000715C ; =============== S U B R O U T I N E =======================================
.text$mn:0000715C
.text$mn:0000715C ; Attributes: bp-based frame
.text$mn:0000715C
.text$mn:0000715C ; public: __thiscall std::deque<unsigned int, class std::allocator<unsigned int>>::~deque<unsigned int, class std::allocator<unsigned int>>(void)
.text$mn:0000715C                 public ??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ
.text$mn:0000715C ??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ proc near
.text$mn:0000715C                                         ; CODE XREF: __unwindfunclet$??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0+3j
.text$mn:0000715C                                         ; std::stack<uint,std::deque<uint,std::allocator<uint>>>::~stack<uint,std::deque<uint,std::allocator<uint>>>(void)+37p ...
.text$mn:0000715C
.text$mn:0000715C var_10          = dword ptr -10h
.text$mn:0000715C var_C           = dword ptr -0Ch
.text$mn:0000715C var_4           = dword ptr -4
.text$mn:0000715C
.text$mn:0000715C                 push    ebp
.text$mn:0000715D                 mov     ebp, esp
.text$mn:0000715F                 push    0FFFFFFFFh
.text$mn:00007161                 push    offset __ehhandler$??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ
.text$mn:00007166                 mov     eax, large fs:0
.text$mn:0000716C                 push    eax
.text$mn:0000716D                 push    ecx
.text$mn:0000716E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007173                 xor     eax, ebp
.text$mn:00007175                 push    eax
.text$mn:00007176                 lea     eax, [ebp+var_C]
.text$mn:00007179                 mov     large fs:0, eax
.text$mn:0000717F                 mov     [ebp+var_10], ecx
.text$mn:00007182                 mov     [ebp+var_4], 0
.text$mn:00007189                 mov     ecx, [ebp+var_10]
.text$mn:0000718C                 call    ?_Tidy@?$deque@IV?$allocator@I@std@@@std@@IAEXXZ ; std::deque<uint,std::allocator<uint>>::_Tidy(void)
.text$mn:00007191                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007198                 mov     ecx, [ebp+var_10]
.text$mn:0000719B                 call    ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::~_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>(void)
.text$mn:000071A0                 mov     ecx, [ebp+var_C]
.text$mn:000071A3                 mov     large fs:0, ecx
.text$mn:000071AA                 pop     ecx
.text$mn:000071AB                 mov     esp, ebp
.text$mn:000071AD                 pop     ebp
.text$mn:000071AE                 retn
.text$mn:000071AE ??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ endp
.text$mn:000071AE
.text$mn:000071AE ; ---------------------------------------------------------------------------
.text$mn:000071AF                 align 10h
.text$mn:000071AF _text$mn        ends
.text$mn:000071AF
.text$x:000071B0 ; ===========================================================================
.text$x:000071B0
.text$x:000071B0 ; Segment type: Pure code
.text$x:000071B0 ; Segment permissions: Read/Execute
.text$x:000071B0 _text$x         segment para public 'CODE' use32
.text$x:000071B0                 assume cs:_text$x
.text$x:000071B0                 ;org 71B0h
.text$x:000071B0 ; COMDAT (pick associative to section at 715C)
.text$x:000071B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000071B0
.text$x:000071B0 ; =============== S U B R O U T I N E =======================================
.text$x:000071B0
.text$x:000071B0
.text$x:000071B0 __unwindfunclet$??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ$0 proc near
.text$x:000071B0                                         ; DATA XREF: .xdata$x:0000BF5Co
.text$x:000071B0                 mov     ecx, [ebp-10h]
.text$x:000071B3                 jmp     ??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::~_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>(void)
.text$x:000071B3 __unwindfunclet$??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ$0 endp
.text$x:000071B3
.text$x:000071B8
.text$x:000071B8 ; =============== S U B R O U T I N E =======================================
.text$x:000071B8
.text$x:000071B8
.text$x:000071B8 __ehhandler$??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ proc near
.text$x:000071B8                                         ; DATA XREF: std::deque<uint,std::allocator<uint>>::~deque<uint,std::allocator<uint>>(void)+5o
.text$x:000071B8
.text$x:000071B8 arg_4           = dword ptr  8
.text$x:000071B8
.text$x:000071B8                 mov     edx, [esp+arg_4]
.text$x:000071BC                 lea     eax, [edx+0Ch]
.text$x:000071BF                 mov     ecx, [edx-8]
.text$x:000071C2                 xor     ecx, eax
.text$x:000071C4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000071C9                 mov     eax, offset __ehfuncinfo$??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ
.text$x:000071CE                 jmp     ___CxxFrameHandler3
.text$x:000071CE __ehhandler$??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ endp
.text$x:000071CE
.text$x:000071CE ; ---------------------------------------------------------------------------
.text$x:000071D3                 align 4
.text$x:000071D3 _text$x         ends
.text$x:000071D3
.text$mn:000071D4 ; ===========================================================================
.text$mn:000071D4
.text$mn:000071D4 ; Segment type: Pure code
.text$mn:000071D4 ; Segment permissions: Read/Execute
.text$mn:000071D4 _text$mn        segment para public 'CODE' use32
.text$mn:000071D4                 assume cs:_text$mn
.text$mn:000071D4                 ;org 71D4h
.text$mn:000071D4 ; COMDAT (pick any)
.text$mn:000071D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000071D4
.text$mn:000071D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000071D4
.text$mn:000071D4 ; Attributes: bp-based frame
.text$mn:000071D4
.text$mn:000071D4 ; public: __thiscall std::stack<unsigned int, class std::deque<unsigned int, class std::allocator<unsigned int>>>::~stack<unsigned int, class std::deque<unsigned int, class std::allocator<unsigned int>>>(void)
.text$mn:000071D4                 public ??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$mn:000071D4 ??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000071D4                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2681p
.text$mn:000071D4                                         ; __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$38+6j
.text$mn:000071D4
.text$mn:000071D4 var_10          = dword ptr -10h
.text$mn:000071D4 var_C           = dword ptr -0Ch
.text$mn:000071D4 var_4           = dword ptr -4
.text$mn:000071D4
.text$mn:000071D4                 push    ebp
.text$mn:000071D5                 mov     ebp, esp
.text$mn:000071D7                 push    0FFFFFFFFh
.text$mn:000071D9                 push    offset __ehhandler$??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$mn:000071DE                 mov     eax, large fs:0
.text$mn:000071E4                 push    eax
.text$mn:000071E5                 push    ecx
.text$mn:000071E6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000071EB                 xor     eax, ebp
.text$mn:000071ED                 push    eax
.text$mn:000071EE                 lea     eax, [ebp+var_C]
.text$mn:000071F1                 mov     large fs:0, eax
.text$mn:000071F7                 mov     [ebp+var_10], ecx
.text$mn:000071FA                 mov     [ebp+var_4], 0
.text$mn:00007201                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007208                 mov     ecx, [ebp+var_10]
.text$mn:0000720B                 call    ??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ ; std::deque<uint,std::allocator<uint>>::~deque<uint,std::allocator<uint>>(void)
.text$mn:00007210                 mov     ecx, [ebp+var_C]
.text$mn:00007213                 mov     large fs:0, ecx
.text$mn:0000721A                 pop     ecx
.text$mn:0000721B                 mov     esp, ebp
.text$mn:0000721D                 pop     ebp
.text$mn:0000721E                 retn
.text$mn:0000721E ??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000721E
.text$mn:0000721E ; ---------------------------------------------------------------------------
.text$mn:0000721F                 align 10h
.text$mn:0000721F _text$mn        ends
.text$mn:0000721F
.text$x:00007220 ; ===========================================================================
.text$x:00007220
.text$x:00007220 ; Segment type: Pure code
.text$x:00007220 ; Segment permissions: Read/Execute
.text$x:00007220 _text$x         segment para public 'CODE' use32
.text$x:00007220                 assume cs:_text$x
.text$x:00007220                 ;org 7220h
.text$x:00007220 ; COMDAT (pick associative to section at 71D4)
.text$x:00007220                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007220
.text$x:00007220 ; =============== S U B R O U T I N E =======================================
.text$x:00007220
.text$x:00007220
.text$x:00007220 __unwindfunclet$??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007220                                         ; DATA XREF: .xdata$x:0000C040o
.text$x:00007220                 mov     ecx, [ebp-10h]
.text$x:00007223                 jmp     ??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ ; std::deque<uint,std::allocator<uint>>::~deque<uint,std::allocator<uint>>(void)
.text$x:00007223 __unwindfunclet$??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00007223
.text$x:00007228
.text$x:00007228 ; =============== S U B R O U T I N E =======================================
.text$x:00007228
.text$x:00007228
.text$x:00007228 __ehhandler$??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ proc near
.text$x:00007228                                         ; DATA XREF: std::stack<uint,std::deque<uint,std::allocator<uint>>>::~stack<uint,std::deque<uint,std::allocator<uint>>>(void)+5o
.text$x:00007228
.text$x:00007228 arg_4           = dword ptr  8
.text$x:00007228
.text$x:00007228                 mov     edx, [esp+arg_4]
.text$x:0000722C                 lea     eax, [edx+0Ch]
.text$x:0000722F                 mov     ecx, [edx-8]
.text$x:00007232                 xor     ecx, eax
.text$x:00007234                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007239                 mov     eax, offset __ehfuncinfo$??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.text$x:0000723E                 jmp     ___CxxFrameHandler3
.text$x:0000723E __ehhandler$??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ endp
.text$x:0000723E
.text$x:0000723E ; ---------------------------------------------------------------------------
.text$x:00007243                 align 4
.text$x:00007243 _text$x         ends
.text$x:00007243
.text$mn:00007244 ; ===========================================================================
.text$mn:00007244
.text$mn:00007244 ; Segment type: Pure code
.text$mn:00007244 ; Segment permissions: Read/Execute
.text$mn:00007244 _text$mn        segment para public 'CODE' use32
.text$mn:00007244                 assume cs:_text$mn
.text$mn:00007244                 ;org 7244h
.text$mn:00007244 ; COMDAT (pick any)
.text$mn:00007244                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007244
.text$mn:00007244 ; =============== S U B R O U T I N E =======================================
.text$mn:00007244
.text$mn:00007244 ; Attributes: bp-based frame
.text$mn:00007244
.text$mn:00007244 ; public: __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::~vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>(void)
.text$mn:00007244                 public ??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:00007244 ??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$mn:00007244                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+79Bp
.text$mn:00007244                                         ; Notepad_plus::notify(SCNotification *)+1434p ...
.text$mn:00007244
.text$mn:00007244 var_10          = dword ptr -10h
.text$mn:00007244 var_C           = dword ptr -0Ch
.text$mn:00007244 var_4           = dword ptr -4
.text$mn:00007244
.text$mn:00007244                 push    ebp
.text$mn:00007245                 mov     ebp, esp
.text$mn:00007247                 push    0FFFFFFFFh
.text$mn:00007249                 push    offset __ehhandler$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$mn:0000724E                 mov     eax, large fs:0
.text$mn:00007254                 push    eax
.text$mn:00007255                 push    ecx
.text$mn:00007256                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000725B                 xor     eax, ebp
.text$mn:0000725D                 push    eax
.text$mn:0000725E                 lea     eax, [ebp+var_C]
.text$mn:00007261                 mov     large fs:0, eax
.text$mn:00007267                 mov     [ebp+var_10], ecx
.text$mn:0000726A                 mov     [ebp+var_4], 0
.text$mn:00007271                 mov     ecx, [ebp+var_10]
.text$mn:00007274                 call    ?_Tidy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Tidy(void)
.text$mn:00007279                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007280                 mov     ecx, [ebp+var_10]
.text$mn:00007283                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::~_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(void)
.text$mn:00007288                 mov     ecx, [ebp+var_C]
.text$mn:0000728B                 mov     large fs:0, ecx
.text$mn:00007292                 pop     ecx
.text$mn:00007293                 mov     esp, ebp
.text$mn:00007295                 pop     ebp
.text$mn:00007296                 retn
.text$mn:00007296 ??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$mn:00007296
.text$mn:00007296 ; ---------------------------------------------------------------------------
.text$mn:00007297                 align 4
.text$mn:00007297 _text$mn        ends
.text$mn:00007297
.text$x:00007298 ; ===========================================================================
.text$x:00007298
.text$x:00007298 ; Segment type: Pure code
.text$x:00007298 ; Segment permissions: Read/Execute
.text$x:00007298 _text$x         segment para public 'CODE' use32
.text$x:00007298                 assume cs:_text$x
.text$x:00007298                 ;org 7298h
.text$x:00007298 ; COMDAT (pick associative to section at 7244)
.text$x:00007298                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007298
.text$x:00007298 ; =============== S U B R O U T I N E =======================================
.text$x:00007298
.text$x:00007298
.text$x:00007298 __unwindfunclet$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00007298                                         ; DATA XREF: .xdata$x:0000BC40o
.text$x:00007298                 mov     ecx, [ebp-10h]
.text$x:0000729B                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::~_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(void)
.text$x:0000729B __unwindfunclet$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000729B
.text$x:000072A0
.text$x:000072A0 ; =============== S U B R O U T I N E =======================================
.text$x:000072A0
.text$x:000072A0
.text$x:000072A0 __ehhandler$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ proc near
.text$x:000072A0                                         ; DATA XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::~vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)+5o
.text$x:000072A0
.text$x:000072A0 arg_4           = dword ptr  8
.text$x:000072A0
.text$x:000072A0                 mov     edx, [esp+arg_4]
.text$x:000072A4                 lea     eax, [edx+0Ch]
.text$x:000072A7                 mov     ecx, [edx-8]
.text$x:000072AA                 xor     ecx, eax
.text$x:000072AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000072B1                 mov     eax, offset __ehfuncinfo$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.text$x:000072B6                 jmp     ___CxxFrameHandler3
.text$x:000072B6 __ehhandler$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ endp
.text$x:000072B6
.text$x:000072B6 ; ---------------------------------------------------------------------------
.text$x:000072BB                 align 4
.text$x:000072BB _text$x         ends
.text$x:000072BB
.text$mn:000072BC ; ===========================================================================
.text$mn:000072BC
.text$mn:000072BC ; Segment type: Pure code
.text$mn:000072BC ; Segment permissions: Read/Execute
.text$mn:000072BC _text$mn        segment para public 'CODE' use32
.text$mn:000072BC                 assume cs:_text$mn
.text$mn:000072BC                 ;org 72BCh
.text$mn:000072BC ; COMDAT (pick any)
.text$mn:000072BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000072BC
.text$mn:000072BC ; =============== S U B R O U T I N E =======================================
.text$mn:000072BC
.text$mn:000072BC ; Attributes: bp-based frame
.text$mn:000072BC
.text$mn:000072BC ; _DWORD __thiscall MenuItemUnit::~MenuItemUnit(MenuItemUnit *__hidden this)
.text$mn:000072BC                 public ??1MenuItemUnit@@QAE@XZ
.text$mn:000072BC ??1MenuItemUnit@@QAE@XZ proc near       ; CODE XREF: Notepad_plus::notify(SCNotification *)+6E2p
.text$mn:000072BC                                         ; Notepad_plus::notify(SCNotification *)+732p ...
.text$mn:000072BC
.text$mn:000072BC var_10          = dword ptr -10h
.text$mn:000072BC var_C           = dword ptr -0Ch
.text$mn:000072BC var_4           = dword ptr -4
.text$mn:000072BC
.text$mn:000072BC                 push    ebp
.text$mn:000072BD                 mov     ebp, esp
.text$mn:000072BF                 push    0FFFFFFFFh
.text$mn:000072C1                 push    offset __ehhandler$??1MenuItemUnit@@QAE@XZ
.text$mn:000072C6                 mov     eax, large fs:0
.text$mn:000072CC                 push    eax
.text$mn:000072CD                 push    ecx
.text$mn:000072CE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000072D3                 xor     eax, ebp
.text$mn:000072D5                 push    eax
.text$mn:000072D6                 lea     eax, [ebp+var_C]
.text$mn:000072D9                 mov     large fs:0, eax
.text$mn:000072DF                 mov     [ebp+var_10], ecx
.text$mn:000072E2                 mov     [ebp+var_4], 1
.text$mn:000072E9                 mov     byte ptr [ebp+var_4], 0
.text$mn:000072ED                 mov     ecx, [ebp+var_10]
.text$mn:000072F0                 add     ecx, 20h ; ' '
.text$mn:000072F3                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000072F8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000072FF                 mov     ecx, [ebp+var_10]
.text$mn:00007302                 add     ecx, 4
.text$mn:00007305                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000730A                 mov     ecx, [ebp+var_C]
.text$mn:0000730D                 mov     large fs:0, ecx
.text$mn:00007314                 pop     ecx
.text$mn:00007315                 mov     esp, ebp
.text$mn:00007317                 pop     ebp
.text$mn:00007318                 retn
.text$mn:00007318 ??1MenuItemUnit@@QAE@XZ endp
.text$mn:00007318
.text$mn:00007318 ; ---------------------------------------------------------------------------
.text$mn:00007319                 align 4
.text$mn:00007319 _text$mn        ends
.text$mn:00007319
.text$x:0000731C ; ===========================================================================
.text$x:0000731C
.text$x:0000731C ; Segment type: Pure code
.text$x:0000731C ; Segment permissions: Read/Execute
.text$x:0000731C _text$x         segment para public 'CODE' use32
.text$x:0000731C                 assume cs:_text$x
.text$x:0000731C                 ;org 731Ch
.text$x:0000731C ; COMDAT (pick associative to section at 72BC)
.text$x:0000731C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000731C
.text$x:0000731C ; =============== S U B R O U T I N E =======================================
.text$x:0000731C
.text$x:0000731C
.text$x:0000731C __unwindfunclet$??1MenuItemUnit@@QAE@XZ$0 proc near
.text$x:0000731C                                         ; DATA XREF: .xdata$x:0000BAFCo
.text$x:0000731C                 mov     ecx, [ebp-10h]
.text$x:0000731F                 add     ecx, 4
.text$x:00007322                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00007322 __unwindfunclet$??1MenuItemUnit@@QAE@XZ$0 endp
.text$x:00007322
.text$x:00007327
.text$x:00007327 ; =============== S U B R O U T I N E =======================================
.text$x:00007327
.text$x:00007327
.text$x:00007327 __unwindfunclet$??1MenuItemUnit@@QAE@XZ$1 proc near
.text$x:00007327                                         ; DATA XREF: .xdata$x:0000BB04o
.text$x:00007327                 mov     ecx, [ebp-10h]
.text$x:0000732A                 add     ecx, 20h ; ' '
.text$x:0000732D                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000732D __unwindfunclet$??1MenuItemUnit@@QAE@XZ$1 endp
.text$x:0000732D
.text$x:00007332
.text$x:00007332 ; =============== S U B R O U T I N E =======================================
.text$x:00007332
.text$x:00007332
.text$x:00007332 __ehhandler$??1MenuItemUnit@@QAE@XZ proc near
.text$x:00007332                                         ; DATA XREF: MenuItemUnit::~MenuItemUnit(void)+5o
.text$x:00007332
.text$x:00007332 arg_4           = dword ptr  8
.text$x:00007332
.text$x:00007332                 mov     edx, [esp+arg_4]
.text$x:00007336                 lea     eax, [edx+0Ch]
.text$x:00007339                 mov     ecx, [edx-8]
.text$x:0000733C                 xor     ecx, eax
.text$x:0000733E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007343                 mov     eax, offset __ehfuncinfo$??1MenuItemUnit@@QAE@XZ
.text$x:00007348                 jmp     ___CxxFrameHandler3
.text$x:00007348 __ehhandler$??1MenuItemUnit@@QAE@XZ endp
.text$x:00007348
.text$x:00007348 ; ---------------------------------------------------------------------------
.text$x:0000734D                 align 10h
.text$x:0000734D _text$x         ends
.text$x:0000734D
.text$mn:00007350 ; ===========================================================================
.text$mn:00007350
.text$mn:00007350 ; Segment type: Pure code
.text$mn:00007350 ; Segment permissions: Read/Execute
.text$mn:00007350 _text$mn        segment para public 'CODE' use32
.text$mn:00007350                 assume cs:_text$mn
.text$mn:00007350                 ;org 7350h
.text$mn:00007350 ; COMDAT (pick any)
.text$mn:00007350                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007350
.text$mn:00007350 ; =============== S U B R O U T I N E =======================================
.text$mn:00007350
.text$mn:00007350 ; Attributes: bp-based frame
.text$mn:00007350
.text$mn:00007350 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00007350                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00007350 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00007350                                         ; CODE XREF: __unwindfunclet$??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ$0+3j
.text$mn:00007350                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00007350
.text$mn:00007350 var_4           = dword ptr -4
.text$mn:00007350
.text$mn:00007350                 push    ebp
.text$mn:00007351                 mov     ebp, esp
.text$mn:00007353                 push    ecx
.text$mn:00007354                 mov     [ebp+var_4], ecx
.text$mn:00007357                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000735A                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000735F                 mov     esp, ebp
.text$mn:00007361                 pop     ebp
.text$mn:00007362                 retn
.text$mn:00007362 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00007362
.text$mn:00007362 ; ---------------------------------------------------------------------------
.text$mn:00007363                 align 4
.text$mn:00007363 _text$mn        ends
.text$mn:00007363
.text$mn:00007364 ; ===========================================================================
.text$mn:00007364
.text$mn:00007364 ; Segment type: Pure code
.text$mn:00007364 ; Segment permissions: Read/Execute
.text$mn:00007364 _text$mn        segment para public 'CODE' use32
.text$mn:00007364                 assume cs:_text$mn
.text$mn:00007364                 ;org 7364h
.text$mn:00007364 ; COMDAT (pick any)
.text$mn:00007364                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007364
.text$mn:00007364 ; =============== S U B R O U T I N E =======================================
.text$mn:00007364
.text$mn:00007364 ; Attributes: bp-based frame
.text$mn:00007364
.text$mn:00007364 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00007364                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00007364 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00007364                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00007364                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00007364
.text$mn:00007364 var_10          = dword ptr -10h
.text$mn:00007364 var_C           = dword ptr -0Ch
.text$mn:00007364 var_4           = dword ptr -4
.text$mn:00007364
.text$mn:00007364                 push    ebp
.text$mn:00007365                 mov     ebp, esp
.text$mn:00007367                 push    0FFFFFFFFh
.text$mn:00007369                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000736E                 mov     eax, large fs:0
.text$mn:00007374                 push    eax
.text$mn:00007375                 push    ecx
.text$mn:00007376                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000737B                 xor     eax, ebp
.text$mn:0000737D                 push    eax
.text$mn:0000737E                 lea     eax, [ebp+var_C]
.text$mn:00007381                 mov     large fs:0, eax
.text$mn:00007387                 mov     [ebp+var_10], ecx
.text$mn:0000738A                 mov     [ebp+var_4], 0
.text$mn:00007391                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007398                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000739B                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000073A0                 mov     ecx, [ebp+var_C]
.text$mn:000073A3                 mov     large fs:0, ecx
.text$mn:000073AA                 pop     ecx
.text$mn:000073AB                 mov     esp, ebp
.text$mn:000073AD                 pop     ebp
.text$mn:000073AE                 retn
.text$mn:000073AE ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:000073AE
.text$mn:000073AE ; ---------------------------------------------------------------------------
.text$mn:000073AF                 align 10h
.text$mn:000073AF _text$mn        ends
.text$mn:000073AF
.text$x:000073B0 ; ===========================================================================
.text$x:000073B0
.text$x:000073B0 ; Segment type: Pure code
.text$x:000073B0 ; Segment permissions: Read/Execute
.text$x:000073B0 _text$x         segment para public 'CODE' use32
.text$x:000073B0                 assume cs:_text$x
.text$x:000073B0                 ;org 73B0h
.text$x:000073B0 ; COMDAT (pick associative to section at 7364)
.text$x:000073B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000073B0
.text$x:000073B0 ; =============== S U B R O U T I N E =======================================
.text$x:000073B0
.text$x:000073B0
.text$x:000073B0 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:000073B0                                         ; DATA XREF: .xdata$x:0000B700o
.text$x:000073B0                 mov     ecx, [ebp-10h]  ; this
.text$x:000073B3                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000073B3 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:000073B3
.text$x:000073B8
.text$x:000073B8 ; =============== S U B R O U T I N E =======================================
.text$x:000073B8
.text$x:000073B8
.text$x:000073B8 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:000073B8                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:000073B8
.text$x:000073B8 arg_4           = dword ptr  8
.text$x:000073B8
.text$x:000073B8                 mov     edx, [esp+arg_4]
.text$x:000073BC                 lea     eax, [edx+0Ch]
.text$x:000073BF                 mov     ecx, [edx-8]
.text$x:000073C2                 xor     ecx, eax
.text$x:000073C4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000073C9                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:000073CE                 jmp     ___CxxFrameHandler3
.text$x:000073CE __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:000073CE
.text$x:000073CE ; ---------------------------------------------------------------------------
.text$x:000073D3                 align 4
.text$x:000073D3 _text$x         ends
.text$x:000073D3
.text$mn:000073D4 ; ===========================================================================
.text$mn:000073D4
.text$mn:000073D4 ; Segment type: Pure code
.text$mn:000073D4 ; Segment permissions: Read/Execute
.text$mn:000073D4 _text$mn        segment para public 'CODE' use32
.text$mn:000073D4                 assume cs:_text$mn
.text$mn:000073D4                 ;org 73D4h
.text$mn:000073D4 ; COMDAT (pick any)
.text$mn:000073D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000073D4
.text$mn:000073D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000073D4
.text$mn:000073D4 ; Attributes: bp-based frame
.text$mn:000073D4
.text$mn:000073D4 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000073D4                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000073D4 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:000073D4                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000073D4                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000073D4
.text$mn:000073D4 var_10          = dword ptr -10h
.text$mn:000073D4 var_C           = dword ptr -0Ch
.text$mn:000073D4 var_4           = dword ptr -4
.text$mn:000073D4
.text$mn:000073D4                 push    ebp
.text$mn:000073D5                 mov     ebp, esp
.text$mn:000073D7                 push    0FFFFFFFFh
.text$mn:000073D9                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000073DE                 mov     eax, large fs:0
.text$mn:000073E4                 push    eax
.text$mn:000073E5                 push    ecx
.text$mn:000073E6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000073EB                 xor     eax, ebp
.text$mn:000073ED                 push    eax
.text$mn:000073EE                 lea     eax, [ebp+var_C]
.text$mn:000073F1                 mov     large fs:0, eax
.text$mn:000073F7                 mov     [ebp+var_10], ecx
.text$mn:000073FA                 mov     [ebp+var_4], 0
.text$mn:00007401                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007408                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000740B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00007410                 mov     ecx, [ebp+var_C]
.text$mn:00007413                 mov     large fs:0, ecx
.text$mn:0000741A                 pop     ecx
.text$mn:0000741B                 mov     esp, ebp
.text$mn:0000741D                 pop     ebp
.text$mn:0000741E                 retn
.text$mn:0000741E ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:0000741E
.text$mn:0000741E ; ---------------------------------------------------------------------------
.text$mn:0000741F                 align 10h
.text$mn:0000741F _text$mn        ends
.text$mn:0000741F
.text$x:00007420 ; ===========================================================================
.text$x:00007420
.text$x:00007420 ; Segment type: Pure code
.text$x:00007420 ; Segment permissions: Read/Execute
.text$x:00007420 _text$x         segment para public 'CODE' use32
.text$x:00007420                 assume cs:_text$x
.text$x:00007420                 ;org 7420h
.text$x:00007420 ; COMDAT (pick associative to section at 73D4)
.text$x:00007420                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007420
.text$x:00007420 ; =============== S U B R O U T I N E =======================================
.text$x:00007420
.text$x:00007420
.text$x:00007420 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00007420                                         ; DATA XREF: .xdata$x:0000B784o
.text$x:00007420                 mov     ecx, [ebp-10h]  ; this
.text$x:00007423                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00007423 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00007423
.text$x:00007428
.text$x:00007428 ; =============== S U B R O U T I N E =======================================
.text$x:00007428
.text$x:00007428
.text$x:00007428 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00007428                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00007428
.text$x:00007428 arg_4           = dword ptr  8
.text$x:00007428
.text$x:00007428                 mov     edx, [esp+arg_4]
.text$x:0000742C                 lea     eax, [edx+0Ch]
.text$x:0000742F                 mov     ecx, [edx-8]
.text$x:00007432                 xor     ecx, eax
.text$x:00007434                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007439                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:0000743E                 jmp     ___CxxFrameHandler3
.text$x:0000743E __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:0000743E
.text$x:0000743E ; ---------------------------------------------------------------------------
.text$x:00007443                 align 4
.text$x:00007443 _text$x         ends
.text$x:00007443
.text$mn:00007444 ; ===========================================================================
.text$mn:00007444
.text$mn:00007444 ; Segment type: Pure code
.text$mn:00007444 ; Segment permissions: Read/Execute
.text$mn:00007444 _text$mn        segment para public 'CODE' use32
.text$mn:00007444                 assume cs:_text$mn
.text$mn:00007444                 ;org 7444h
.text$mn:00007444 ; COMDAT (pick any)
.text$mn:00007444                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007444
.text$mn:00007444 ; =============== S U B R O U T I N E =======================================
.text$mn:00007444
.text$mn:00007444 ; Attributes: bp-based frame
.text$mn:00007444
.text$mn:00007444 ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00007444                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:00007444 ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00007444                                         ; CODE XREF: __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00007444                                         ; __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0+3j ...
.text$mn:00007444
.text$mn:00007444 var_14          = byte ptr -14h
.text$mn:00007444 var_10          = dword ptr -10h
.text$mn:00007444 var_C           = dword ptr -0Ch
.text$mn:00007444 var_4           = dword ptr -4
.text$mn:00007444
.text$mn:00007444                 push    ebp
.text$mn:00007445                 mov     ebp, esp
.text$mn:00007447                 push    0FFFFFFFFh
.text$mn:00007449                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:0000744E                 mov     eax, large fs:0
.text$mn:00007454                 push    eax
.text$mn:00007455                 sub     esp, 8
.text$mn:00007458                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000745D                 xor     eax, ebp
.text$mn:0000745F                 push    eax
.text$mn:00007460                 lea     eax, [ebp+var_C]
.text$mn:00007463                 mov     large fs:0, eax
.text$mn:00007469                 mov     [ebp+var_10], ecx
.text$mn:0000746C                 push    3               ; int
.text$mn:0000746E                 lea     ecx, [ebp+var_14] ; this
.text$mn:00007471                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00007476                 mov     [ebp+var_4], 0
.text$mn:0000747D                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007480                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00007485                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000748C                 lea     ecx, [ebp+var_14] ; this
.text$mn:0000748F                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00007494                 mov     ecx, [ebp+var_C]
.text$mn:00007497                 mov     large fs:0, ecx
.text$mn:0000749E                 pop     ecx
.text$mn:0000749F                 mov     esp, ebp
.text$mn:000074A1                 pop     ebp
.text$mn:000074A2                 retn
.text$mn:000074A2 ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:000074A2
.text$mn:000074A2 ; ---------------------------------------------------------------------------
.text$mn:000074A3                 align 4
.text$mn:000074A3 _text$mn        ends
.text$mn:000074A3
.text$x:000074A4 ; ===========================================================================
.text$x:000074A4
.text$x:000074A4 ; Segment type: Pure code
.text$x:000074A4 ; Segment permissions: Read/Execute
.text$x:000074A4 _text$x         segment para public 'CODE' use32
.text$x:000074A4                 assume cs:_text$x
.text$x:000074A4                 ;org 74A4h
.text$x:000074A4 ; COMDAT (pick associative to section at 7444)
.text$x:000074A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000074A4
.text$x:000074A4 ; =============== S U B R O U T I N E =======================================
.text$x:000074A4
.text$x:000074A4
.text$x:000074A4 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:000074A4                                         ; DATA XREF: .xdata$x:0000B488o
.text$x:000074A4                 lea     ecx, [ebp-14h]  ; this
.text$x:000074A7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000074A7 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:000074A7
.text$x:000074AC
.text$x:000074AC ; =============== S U B R O U T I N E =======================================
.text$x:000074AC
.text$x:000074AC
.text$x:000074AC __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:000074AC                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:000074AC
.text$x:000074AC arg_4           = dword ptr  8
.text$x:000074AC
.text$x:000074AC                 mov     edx, [esp+arg_4]
.text$x:000074B0                 lea     eax, [edx+0Ch]
.text$x:000074B3                 mov     ecx, [edx-0Ch]
.text$x:000074B6                 xor     ecx, eax
.text$x:000074B8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000074BD                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:000074C2                 jmp     ___CxxFrameHandler3
.text$x:000074C2 __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:000074C2
.text$x:000074C2 ; ---------------------------------------------------------------------------
.text$x:000074C7                 align 4
.text$x:000074C7 _text$x         ends
.text$x:000074C7
.text$mn:000074C8 ; ===========================================================================
.text$mn:000074C8
.text$mn:000074C8 ; Segment type: Pure code
.text$mn:000074C8 ; Segment permissions: Read/Execute
.text$mn:000074C8 _text$mn        segment para public 'CODE' use32
.text$mn:000074C8                 assume cs:_text$mn
.text$mn:000074C8                 ;org 74C8h
.text$mn:000074C8 ; COMDAT (pick any)
.text$mn:000074C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000074C8
.text$mn:000074C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000074C8
.text$mn:000074C8 ; Attributes: bp-based frame
.text$mn:000074C8
.text$mn:000074C8 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000074C8                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:000074C8 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:000074C8                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000074C8                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000074C8
.text$mn:000074C8 var_10          = dword ptr -10h
.text$mn:000074C8 var_C           = dword ptr -0Ch
.text$mn:000074C8 var_4           = dword ptr -4
.text$mn:000074C8
.text$mn:000074C8                 push    ebp
.text$mn:000074C9                 mov     ebp, esp
.text$mn:000074CB                 push    0FFFFFFFFh
.text$mn:000074CD                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:000074D2                 mov     eax, large fs:0
.text$mn:000074D8                 push    eax
.text$mn:000074D9                 push    ecx
.text$mn:000074DA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000074DF                 xor     eax, ebp
.text$mn:000074E1                 push    eax
.text$mn:000074E2                 lea     eax, [ebp+var_C]
.text$mn:000074E5                 mov     large fs:0, eax
.text$mn:000074EB                 mov     [ebp+var_10], ecx
.text$mn:000074EE                 mov     [ebp+var_4], 0
.text$mn:000074F5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000074FC                 mov     ecx, [ebp+var_10] ; this
.text$mn:000074FF                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00007504                 mov     ecx, [ebp+var_C]
.text$mn:00007507                 mov     large fs:0, ecx
.text$mn:0000750E                 pop     ecx
.text$mn:0000750F                 mov     esp, ebp
.text$mn:00007511                 pop     ebp
.text$mn:00007512                 retn
.text$mn:00007512 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00007512
.text$mn:00007512 ; ---------------------------------------------------------------------------
.text$mn:00007513                 align 4
.text$mn:00007513 _text$mn        ends
.text$mn:00007513
.text$x:00007514 ; ===========================================================================
.text$x:00007514
.text$x:00007514 ; Segment type: Pure code
.text$x:00007514 ; Segment permissions: Read/Execute
.text$x:00007514 _text$x         segment para public 'CODE' use32
.text$x:00007514                 assume cs:_text$x
.text$x:00007514                 ;org 7514h
.text$x:00007514 ; COMDAT (pick associative to section at 74C8)
.text$x:00007514                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007514
.text$x:00007514 ; =============== S U B R O U T I N E =======================================
.text$x:00007514
.text$x:00007514
.text$x:00007514 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00007514                                         ; DATA XREF: .xdata$x:0000B808o
.text$x:00007514                 mov     ecx, [ebp-10h]  ; this
.text$x:00007517                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00007517 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00007517
.text$x:0000751C
.text$x:0000751C ; =============== S U B R O U T I N E =======================================
.text$x:0000751C
.text$x:0000751C
.text$x:0000751C __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:0000751C                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:0000751C
.text$x:0000751C arg_4           = dword ptr  8
.text$x:0000751C
.text$x:0000751C                 mov     edx, [esp+arg_4]
.text$x:00007520                 lea     eax, [edx+0Ch]
.text$x:00007523                 mov     ecx, [edx-8]
.text$x:00007526                 xor     ecx, eax
.text$x:00007528                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000752D                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00007532                 jmp     ___CxxFrameHandler3
.text$x:00007532 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00007532
.text$x:00007532 ; ---------------------------------------------------------------------------
.text$x:00007537                 align 4
.text$x:00007537 _text$x         ends
.text$x:00007537
.text$mn:00007538 ; ===========================================================================
.text$mn:00007538
.text$mn:00007538 ; Segment type: Pure code
.text$mn:00007538 ; Segment permissions: Read/Execute
.text$mn:00007538 _text$mn        segment para public 'CODE' use32
.text$mn:00007538                 assume cs:_text$mn
.text$mn:00007538                 ;org 7538h
.text$mn:00007538 ; COMDAT (pick any)
.text$mn:00007538                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007538
.text$mn:00007538 ; =============== S U B R O U T I N E =======================================
.text$mn:00007538
.text$mn:00007538 ; Attributes: bp-based frame
.text$mn:00007538
.text$mn:00007538 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00007538                 public ??1error_category@std@@UAE@XZ
.text$mn:00007538 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00007538                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00007538
.text$mn:00007538 var_4           = dword ptr -4
.text$mn:00007538
.text$mn:00007538                 push    ebp
.text$mn:00007539                 mov     ebp, esp
.text$mn:0000753B                 push    ecx
.text$mn:0000753C                 mov     [ebp+var_4], ecx
.text$mn:0000753F                 mov     eax, [ebp+var_4]
.text$mn:00007542                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00007548                 mov     esp, ebp
.text$mn:0000754A                 pop     ebp
.text$mn:0000754B                 retn
.text$mn:0000754B ??1error_category@std@@UAE@XZ endp
.text$mn:0000754B
.text$mn:0000754B _text$mn        ends
.text$mn:0000754B
.text$mn:0000754C ; ===========================================================================
.text$mn:0000754C
.text$mn:0000754C ; Segment type: Pure code
.text$mn:0000754C ; Segment permissions: Read/Execute
.text$mn:0000754C _text$mn        segment para public 'CODE' use32
.text$mn:0000754C                 assume cs:_text$mn
.text$mn:0000754C                 ;org 754Ch
.text$mn:0000754C ; COMDAT (pick any)
.text$mn:0000754C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000754C
.text$mn:0000754C ; =============== S U B R O U T I N E =======================================
.text$mn:0000754C
.text$mn:0000754C ; Attributes: bp-based frame
.text$mn:0000754C
.text$mn:0000754C ; _DWORD __thiscall recordedMacroStep::~recordedMacroStep(recordedMacroStep *__hidden this)
.text$mn:0000754C                 public ??1recordedMacroStep@@QAE@XZ
.text$mn:0000754C ??1recordedMacroStep@@QAE@XZ proc near  ; CODE XREF: Notepad_plus::notify(SCNotification *)+2D59p
.text$mn:0000754C                                         ; __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$40+6j ...
.text$mn:0000754C
.text$mn:0000754C var_10          = dword ptr -10h
.text$mn:0000754C var_C           = dword ptr -0Ch
.text$mn:0000754C var_4           = dword ptr -4
.text$mn:0000754C
.text$mn:0000754C                 push    ebp
.text$mn:0000754D                 mov     ebp, esp
.text$mn:0000754F                 push    0FFFFFFFFh
.text$mn:00007551                 push    offset __ehhandler$??1recordedMacroStep@@QAE@XZ
.text$mn:00007556                 mov     eax, large fs:0
.text$mn:0000755C                 push    eax
.text$mn:0000755D                 push    ecx
.text$mn:0000755E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007563                 xor     eax, ebp
.text$mn:00007565                 push    eax
.text$mn:00007566                 lea     eax, [ebp+var_C]
.text$mn:00007569                 mov     large fs:0, eax
.text$mn:0000756F                 mov     [ebp+var_10], ecx
.text$mn:00007572                 mov     [ebp+var_4], 0
.text$mn:00007579                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007580                 mov     ecx, [ebp+var_10]
.text$mn:00007583                 add     ecx, 0Ch
.text$mn:00007586                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000758B                 mov     ecx, [ebp+var_C]
.text$mn:0000758E                 mov     large fs:0, ecx
.text$mn:00007595                 pop     ecx
.text$mn:00007596                 mov     esp, ebp
.text$mn:00007598                 pop     ebp
.text$mn:00007599                 retn
.text$mn:00007599 ??1recordedMacroStep@@QAE@XZ endp
.text$mn:00007599
.text$mn:00007599 ; ---------------------------------------------------------------------------
.text$mn:0000759A                 align 4
.text$mn:0000759A _text$mn        ends
.text$mn:0000759A
.text$x:0000759C ; ===========================================================================
.text$x:0000759C
.text$x:0000759C ; Segment type: Pure code
.text$x:0000759C ; Segment permissions: Read/Execute
.text$x:0000759C _text$x         segment para public 'CODE' use32
.text$x:0000759C                 assume cs:_text$x
.text$x:0000759C                 ;org 759Ch
.text$x:0000759C ; COMDAT (pick associative to section at 754C)
.text$x:0000759C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000759C
.text$x:0000759C ; =============== S U B R O U T I N E =======================================
.text$x:0000759C
.text$x:0000759C
.text$x:0000759C __unwindfunclet$??1recordedMacroStep@@QAE@XZ$0 proc near
.text$x:0000759C                                         ; DATA XREF: .xdata$x:0000BA20o
.text$x:0000759C                 mov     ecx, [ebp-10h]
.text$x:0000759F                 add     ecx, 0Ch
.text$x:000075A2                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000075A2 __unwindfunclet$??1recordedMacroStep@@QAE@XZ$0 endp
.text$x:000075A2
.text$x:000075A7
.text$x:000075A7 ; =============== S U B R O U T I N E =======================================
.text$x:000075A7
.text$x:000075A7
.text$x:000075A7 __ehhandler$??1recordedMacroStep@@QAE@XZ proc near
.text$x:000075A7                                         ; DATA XREF: recordedMacroStep::~recordedMacroStep(void)+5o
.text$x:000075A7
.text$x:000075A7 arg_4           = dword ptr  8
.text$x:000075A7
.text$x:000075A7                 mov     edx, [esp+arg_4]
.text$x:000075AB                 lea     eax, [edx+0Ch]
.text$x:000075AE                 mov     ecx, [edx-8]
.text$x:000075B1                 xor     ecx, eax
.text$x:000075B3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000075B8                 mov     eax, offset __ehfuncinfo$??1recordedMacroStep@@QAE@XZ
.text$x:000075BD                 jmp     ___CxxFrameHandler3
.text$x:000075BD __ehhandler$??1recordedMacroStep@@QAE@XZ endp
.text$x:000075BD
.text$x:000075BD ; ---------------------------------------------------------------------------
.text$x:000075C2                 align 4
.text$x:000075C2 _text$x         ends
.text$x:000075C2
.text$mn:000075C4 ; ===========================================================================
.text$mn:000075C4
.text$mn:000075C4 ; Segment type: Pure code
.text$mn:000075C4 ; Segment permissions: Read/Execute
.text$mn:000075C4 _text$mn        segment para public 'CODE' use32
.text$mn:000075C4                 assume cs:_text$mn
.text$mn:000075C4                 ;org 75C4h
.text$mn:000075C4 ; COMDAT (pick any)
.text$mn:000075C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000075C4
.text$mn:000075C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000075C4
.text$mn:000075C4 ; Attributes: bp-based frame
.text$mn:000075C4
.text$mn:000075C4 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:000075C4                 public ??2@YAPAXIPAX@Z
.text$mn:000075C4 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:000075C4                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+2Ep ...
.text$mn:000075C4
.text$mn:000075C4 arg_4           = dword ptr  0Ch
.text$mn:000075C4
.text$mn:000075C4                 push    ebp
.text$mn:000075C5                 mov     ebp, esp
.text$mn:000075C7                 mov     eax, [ebp+arg_4]
.text$mn:000075CA                 pop     ebp
.text$mn:000075CB                 retn
.text$mn:000075CB ??2@YAPAXIPAX@Z endp
.text$mn:000075CB
.text$mn:000075CB _text$mn        ends
.text$mn:000075CB
.text$mn:000075CC ; ===========================================================================
.text$mn:000075CC
.text$mn:000075CC ; Segment type: Pure code
.text$mn:000075CC ; Segment permissions: Read/Execute
.text$mn:000075CC _text$mn        segment para public 'CODE' use32
.text$mn:000075CC                 assume cs:_text$mn
.text$mn:000075CC                 ;org 75CCh
.text$mn:000075CC ; COMDAT (pick any)
.text$mn:000075CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000075CC
.text$mn:000075CC ; =============== S U B R O U T I N E =======================================
.text$mn:000075CC
.text$mn:000075CC ; Attributes: bp-based frame
.text$mn:000075CC
.text$mn:000075CC ; void __cdecl operator delete(void *)
.text$mn:000075CC                 public ??3@YAXPAX0@Z
.text$mn:000075CC ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:000075CC                                         ; __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0+8p ...
.text$mn:000075CC                 push    ebp
.text$mn:000075CD                 mov     ebp, esp
.text$mn:000075CF                 pop     ebp
.text$mn:000075D0                 retn
.text$mn:000075D0 ??3@YAXPAX0@Z   endp
.text$mn:000075D0
.text$mn:000075D0 ; ---------------------------------------------------------------------------
.text$mn:000075D1                 align 4
.text$mn:000075D1 _text$mn        ends
.text$mn:000075D1
.text$mn:000075D4 ; ===========================================================================
.text$mn:000075D4
.text$mn:000075D4 ; Segment type: Pure code
.text$mn:000075D4 ; Segment permissions: Read/Execute
.text$mn:000075D4 _text$mn        segment para public 'CODE' use32
.text$mn:000075D4                 assume cs:_text$mn
.text$mn:000075D4                 ;org 75D4h
.text$mn:000075D4 ; COMDAT (pick any)
.text$mn:000075D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000075D4
.text$mn:000075D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000075D4
.text$mn:000075D4 ; Attributes: bp-based frame
.text$mn:000075D4
.text$mn:000075D4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char *Str)
.text$mn:000075D4                 public ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
.text$mn:000075D4 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z proc near
.text$mn:000075D4                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2355p
.text$mn:000075D4
.text$mn:000075D4 var_4           = dword ptr -4
.text$mn:000075D4 Str             = dword ptr  8
.text$mn:000075D4
.text$mn:000075D4                 push    ebp
.text$mn:000075D5                 mov     ebp, esp
.text$mn:000075D7                 push    ecx
.text$mn:000075D8                 mov     [ebp+var_4], ecx
.text$mn:000075DB                 mov     eax, [ebp+Str]
.text$mn:000075DE                 push    eax             ; Str
.text$mn:000075DF                 mov     ecx, [ebp+var_4]
.text$mn:000075E2                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000075E7                 mov     esp, ebp
.text$mn:000075E9                 pop     ebp
.text$mn:000075EA                 retn    4
.text$mn:000075EA ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z endp
.text$mn:000075EA
.text$mn:000075EA ; ---------------------------------------------------------------------------
.text$mn:000075ED                 align 10h
.text$mn:000075ED _text$mn        ends
.text$mn:000075ED
.text$mn:000075F0 ; ===========================================================================
.text$mn:000075F0
.text$mn:000075F0 ; Segment type: Pure code
.text$mn:000075F0 ; Segment permissions: Read/Execute
.text$mn:000075F0 _text$mn        segment para public 'CODE' use32
.text$mn:000075F0                 assume cs:_text$mn
.text$mn:000075F0                 ;org 75F0h
.text$mn:000075F0 ; COMDAT (pick any)
.text$mn:000075F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000075F0
.text$mn:000075F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000075F0
.text$mn:000075F0 ; Attributes: bp-based frame
.text$mn:000075F0
.text$mn:000075F0 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t *Str)
.text$mn:000075F0                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:000075F0 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:000075F0                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2B18p
.text$mn:000075F0                                         ; Notepad_plus::notify(SCNotification *)+2C06p
.text$mn:000075F0
.text$mn:000075F0 var_4           = dword ptr -4
.text$mn:000075F0 Str             = dword ptr  8
.text$mn:000075F0
.text$mn:000075F0                 push    ebp
.text$mn:000075F1                 mov     ebp, esp
.text$mn:000075F3                 push    ecx
.text$mn:000075F4                 mov     [ebp+var_4], ecx
.text$mn:000075F7                 mov     eax, [ebp+Str]
.text$mn:000075FA                 push    eax             ; Str
.text$mn:000075FB                 mov     ecx, [ebp+var_4]
.text$mn:000075FE                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00007603                 mov     esp, ebp
.text$mn:00007605                 pop     ebp
.text$mn:00007606                 retn    4
.text$mn:00007606 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:00007606
.text$mn:00007606 ; ---------------------------------------------------------------------------
.text$mn:00007609                 align 4
.text$mn:00007609 _text$mn        ends
.text$mn:00007609
.text$mn:0000760C ; ===========================================================================
.text$mn:0000760C
.text$mn:0000760C ; Segment type: Pure code
.text$mn:0000760C ; Segment permissions: Read/Execute
.text$mn:0000760C _text$mn        segment para public 'CODE' use32
.text$mn:0000760C                 assume cs:_text$mn
.text$mn:0000760C                 ;org 760Ch
.text$mn:0000760C ; COMDAT (pick any)
.text$mn:0000760C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000760C
.text$mn:0000760C ; =============== S U B R O U T I N E =======================================
.text$mn:0000760C
.text$mn:0000760C ; Attributes: bp-based frame
.text$mn:0000760C
.text$mn:0000760C ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:0000760C                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:0000760C ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:0000760C                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:0000760C
.text$mn:0000760C var_14          = byte ptr -14h
.text$mn:0000760C var_10          = dword ptr -10h
.text$mn:0000760C var_C           = dword ptr -0Ch
.text$mn:0000760C var_4           = dword ptr -4
.text$mn:0000760C arg_0           = dword ptr  8
.text$mn:0000760C
.text$mn:0000760C                 push    ebp
.text$mn:0000760D                 mov     ebp, esp
.text$mn:0000760F                 push    0FFFFFFFFh
.text$mn:00007611                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00007616                 mov     eax, large fs:0
.text$mn:0000761C                 push    eax
.text$mn:0000761D                 sub     esp, 8
.text$mn:00007620                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007625                 xor     eax, ebp
.text$mn:00007627                 push    eax
.text$mn:00007628                 lea     eax, [ebp+var_C]
.text$mn:0000762B                 mov     large fs:0, eax
.text$mn:00007631                 mov     [ebp+var_10], ecx
.text$mn:00007634                 mov     eax, [ebp+var_10]
.text$mn:00007637                 mov     ecx, [ebp+arg_0]
.text$mn:0000763A                 mov     edx, [eax]
.text$mn:0000763C                 cmp     edx, [ecx]
.text$mn:0000763E                 jnz     short loc_7642
.text$mn:00007640                 jmp     short loc_7684
.text$mn:00007642 ; ---------------------------------------------------------------------------
.text$mn:00007642
.text$mn:00007642 loc_7642:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:00007642                 mov     eax, [ebp+arg_0]
.text$mn:00007645                 cmp     dword ptr [eax], 0
.text$mn:00007648                 jz      short loc_765C
.text$mn:0000764A                 mov     ecx, [ebp+arg_0]
.text$mn:0000764D                 mov     edx, [ecx]
.text$mn:0000764F                 mov     eax, [edx]
.text$mn:00007651                 push    eax             ; struct std::_Container_base12 *
.text$mn:00007652                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007655                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:0000765A                 jmp     short loc_7684
.text$mn:0000765C ; ---------------------------------------------------------------------------
.text$mn:0000765C
.text$mn:0000765C loc_765C:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:0000765C                 push    3               ; int
.text$mn:0000765E                 lea     ecx, [ebp+var_14] ; this
.text$mn:00007661                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00007666                 mov     [ebp+var_4], 0
.text$mn:0000766D                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007670                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00007675                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000767C                 lea     ecx, [ebp+var_14] ; this
.text$mn:0000767F                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00007684
.text$mn:00007684 loc_7684:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:00007684                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:00007684                 mov     eax, [ebp+var_10]
.text$mn:00007687                 mov     ecx, [ebp+var_C]
.text$mn:0000768A                 mov     large fs:0, ecx
.text$mn:00007691                 pop     ecx
.text$mn:00007692                 mov     esp, ebp
.text$mn:00007694                 pop     ebp
.text$mn:00007695                 retn    4
.text$mn:00007695 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:00007695
.text$mn:00007695 _text$mn        ends
.text$mn:00007695
.text$x:00007698 ; ===========================================================================
.text$x:00007698
.text$x:00007698 ; Segment type: Pure code
.text$x:00007698 ; Segment permissions: Read/Execute
.text$x:00007698 _text$x         segment para public 'CODE' use32
.text$x:00007698                 assume cs:_text$x
.text$x:00007698                 ;org 7698h
.text$x:00007698 ; COMDAT (pick associative to section at 760C)
.text$x:00007698                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007698
.text$x:00007698 ; =============== S U B R O U T I N E =======================================
.text$x:00007698
.text$x:00007698
.text$x:00007698 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:00007698                                         ; DATA XREF: .xdata$x:0000B45Co
.text$x:00007698                 lea     ecx, [ebp-14h]  ; this
.text$x:0000769B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000769B __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:0000769B
.text$x:000076A0
.text$x:000076A0 ; =============== S U B R O U T I N E =======================================
.text$x:000076A0
.text$x:000076A0
.text$x:000076A0 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:000076A0                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:000076A0
.text$x:000076A0 arg_4           = dword ptr  8
.text$x:000076A0
.text$x:000076A0                 mov     edx, [esp+arg_4]
.text$x:000076A4                 lea     eax, [edx+0Ch]
.text$x:000076A7                 mov     ecx, [edx-0Ch]
.text$x:000076AA                 xor     ecx, eax
.text$x:000076AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000076B1                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:000076B6                 jmp     ___CxxFrameHandler3
.text$x:000076B6 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:000076B6
.text$x:000076B6 ; ---------------------------------------------------------------------------
.text$x:000076BB                 align 4
.text$x:000076BB _text$x         ends
.text$x:000076BB
.text$mn:000076BC ; ===========================================================================
.text$mn:000076BC
.text$mn:000076BC ; Segment type: Pure code
.text$mn:000076BC ; Segment permissions: Read/Execute
.text$mn:000076BC _text$mn        segment para public 'CODE' use32
.text$mn:000076BC                 assume cs:_text$mn
.text$mn:000076BC                 ;org 76BCh
.text$mn:000076BC ; COMDAT (pick any)
.text$mn:000076BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000076BC
.text$mn:000076BC ; =============== S U B R O U T I N E =======================================
.text$mn:000076BC
.text$mn:000076BC ; Attributes: bp-based frame
.text$mn:000076BC
.text$mn:000076BC ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:000076BC                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:000076BC ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:000076BC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:000076BC                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:000076BC
.text$mn:000076BC var_8           = dword ptr -8
.text$mn:000076BC var_4           = dword ptr -4
.text$mn:000076BC arg_0           = dword ptr  8
.text$mn:000076BC
.text$mn:000076BC                 push    ebp
.text$mn:000076BD                 mov     ebp, esp
.text$mn:000076BF                 sub     esp, 8
.text$mn:000076C2                 mov     [ebp+var_8], ecx
.text$mn:000076C5                 mov     eax, [ebp+var_8]
.text$mn:000076C8                 cmp     eax, [ebp+arg_0]
.text$mn:000076CB                 jnz     short loc_76D6
.text$mn:000076CD                 mov     [ebp+var_4], 1
.text$mn:000076D4                 jmp     short loc_76DD
.text$mn:000076D6 ; ---------------------------------------------------------------------------
.text$mn:000076D6
.text$mn:000076D6 loc_76D6:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:000076D6                 mov     [ebp+var_4], 0
.text$mn:000076DD
.text$mn:000076DD loc_76DD:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:000076DD                 mov     al, byte ptr [ebp+var_4]
.text$mn:000076E0                 mov     esp, ebp
.text$mn:000076E2                 pop     ebp
.text$mn:000076E3                 retn    4
.text$mn:000076E3 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:000076E3
.text$mn:000076E3 ; ---------------------------------------------------------------------------
.text$mn:000076E6                 align 4
.text$mn:000076E6 _text$mn        ends
.text$mn:000076E6
.text$mn:000076E8 ; ===========================================================================
.text$mn:000076E8
.text$mn:000076E8 ; Segment type: Pure code
.text$mn:000076E8 ; Segment permissions: Read/Execute
.text$mn:000076E8 _text$mn        segment para public 'CODE' use32
.text$mn:000076E8                 assume cs:_text$mn
.text$mn:000076E8                 ;org 76E8h
.text$mn:000076E8 ; COMDAT (pick any)
.text$mn:000076E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000076E8
.text$mn:000076E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000076E8
.text$mn:000076E8 ; Attributes: bp-based frame
.text$mn:000076E8
.text$mn:000076E8 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:000076E8                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:000076E8 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:000076E8                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:000076E8
.text$mn:000076E8 var_8           = dword ptr -8
.text$mn:000076E8 var_4           = dword ptr -4
.text$mn:000076E8 arg_0           = dword ptr  8
.text$mn:000076E8
.text$mn:000076E8                 push    ebp
.text$mn:000076E9                 mov     ebp, esp
.text$mn:000076EB                 sub     esp, 8
.text$mn:000076EE                 push    esi
.text$mn:000076EF                 mov     [ebp+var_4], ecx
.text$mn:000076F2                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000076F5                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000076FA                 push    eax
.text$mn:000076FB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000076FE                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00007703                 mov     ecx, eax
.text$mn:00007705                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000770A                 movzx   eax, al
.text$mn:0000770D                 test    eax, eax
.text$mn:0000770F                 jz      short loc_7730
.text$mn:00007711                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007714                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00007719                 mov     esi, eax
.text$mn:0000771B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000771E                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00007723                 cmp     esi, eax
.text$mn:00007725                 jnz     short loc_7730
.text$mn:00007727                 mov     [ebp+var_8], 1
.text$mn:0000772E                 jmp     short loc_7737
.text$mn:00007730 ; ---------------------------------------------------------------------------
.text$mn:00007730
.text$mn:00007730 loc_7730:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00007730                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00007730                 mov     [ebp+var_8], 0
.text$mn:00007737
.text$mn:00007737 loc_7737:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00007737                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000773A                 pop     esi
.text$mn:0000773B                 mov     esp, ebp
.text$mn:0000773D                 pop     ebp
.text$mn:0000773E                 retn    4
.text$mn:0000773E ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:0000773E
.text$mn:0000773E ; ---------------------------------------------------------------------------
.text$mn:00007741                 align 4
.text$mn:00007741 _text$mn        ends
.text$mn:00007741
.text$mn:00007744 ; ===========================================================================
.text$mn:00007744
.text$mn:00007744 ; Segment type: Pure code
.text$mn:00007744 ; Segment permissions: Read/Execute
.text$mn:00007744 _text$mn        segment para public 'CODE' use32
.text$mn:00007744                 assume cs:_text$mn
.text$mn:00007744                 ;org 7744h
.text$mn:00007744 ; COMDAT (pick any)
.text$mn:00007744                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007744
.text$mn:00007744 ; =============== S U B R O U T I N E =======================================
.text$mn:00007744
.text$mn:00007744 ; Attributes: bp-based frame
.text$mn:00007744
.text$mn:00007744 ; public: unsigned int const & __thiscall std::_Deque_const_iterator<class std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>>::operator*(void)const
.text$mn:00007744                 public ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBEABIXZ
.text$mn:00007744 ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBEABIXZ proc near
.text$mn:00007744                                         ; CODE XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+Ap
.text$mn:00007744
.text$mn:00007744 var_10          = dword ptr -10h
.text$mn:00007744 var_C           = dword ptr -0Ch
.text$mn:00007744 var_8           = dword ptr -8
.text$mn:00007744 var_4           = dword ptr -4
.text$mn:00007744
.text$mn:00007744                 push    ebp
.text$mn:00007745                 mov     ebp, esp
.text$mn:00007747                 sub     esp, 10h
.text$mn:0000774A                 mov     [ebp+var_8], ecx
.text$mn:0000774D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00007750                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00007755                 mov     [ebp+var_4], eax
.text$mn:00007758                 cmp     [ebp+var_4], 0
.text$mn:0000775C                 jz      short loc_7780
.text$mn:0000775E                 mov     eax, [ebp+var_8]
.text$mn:00007761                 mov     ecx, [ebp+var_4]
.text$mn:00007764                 mov     edx, [eax+8]
.text$mn:00007767                 cmp     edx, [ecx+0Ch]
.text$mn:0000776A                 jb      short loc_7780
.text$mn:0000776C                 mov     eax, [ebp+var_4]
.text$mn:0000776F                 mov     ecx, [eax+0Ch]
.text$mn:00007772                 mov     edx, [ebp+var_4]
.text$mn:00007775                 add     ecx, [edx+10h]
.text$mn:00007778                 mov     eax, [ebp+var_8]
.text$mn:0000777B                 cmp     ecx, [eax+8]
.text$mn:0000777E                 ja      short loc_77E8
.text$mn:00007780
.text$mn:00007780 loc_7780:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+18j
.text$mn:00007780                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+26j
.text$mn:00007780                 push    14Ah            ; unsigned int
.text$mn:00007785                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000778A                 push    offset ??_C@_1EE@INPCGGNP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl@ ; "deque iterator not dereferencable"
.text$mn:0000778F                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00007794                 add     esp, 0Ch
.text$mn:00007797                 mov     ecx, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000779C                 test    ecx, ecx
.text$mn:0000779E                 jz      short loc_77A4
.text$mn:000077A0                 xor     edx, edx
.text$mn:000077A2                 jnz     short loc_77CA
.text$mn:000077A4
.text$mn:000077A4 loc_77A4:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+5Aj
.text$mn:000077A4                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:000077A9                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:000077AE                 push    0
.text$mn:000077B0                 push    14Bh
.text$mn:000077B5                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000077BA                 push    2
.text$mn:000077BC                 call    __CrtDbgReportW
.text$mn:000077C1                 add     esp, 18h
.text$mn:000077C4                 cmp     eax, 1
.text$mn:000077C7                 jnz     short loc_77CA
.text$mn:000077C9                 int     3               ; Trap to Debugger
.text$mn:000077CA
.text$mn:000077CA loc_77CA:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+5Ej
.text$mn:000077CA                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+83j
.text$mn:000077CA                 push    0
.text$mn:000077CC                 push    14Bh
.text$mn:000077D1                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000077D6                 push    offset ??_C@_1NO@MNBGKAMN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@ ; "std::_Deque_const_iterator<class std::_"...
.text$mn:000077DB                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000077E0                 call    __invalid_parameter
.text$mn:000077E5                 add     esp, 14h
.text$mn:000077E8
.text$mn:000077E8 loc_77E8:                               ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+3Aj
.text$mn:000077E8                 mov     ecx, [ebp+var_8]
.text$mn:000077EB                 mov     edx, [ecx+8]
.text$mn:000077EE                 push    edx
.text$mn:000077EF                 mov     ecx, [ebp+var_4]
.text$mn:000077F2                 call    ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<uint>>::_Getblock(uint)
.text$mn:000077F7                 mov     [ebp+var_C], eax
.text$mn:000077FA                 mov     eax, [ebp+var_8]
.text$mn:000077FD                 mov     eax, [eax+8]
.text$mn:00007800                 xor     edx, edx
.text$mn:00007802                 mov     ecx, 4
.text$mn:00007807                 div     ecx
.text$mn:00007809                 mov     [ebp+var_10], edx
.text$mn:0000780C                 mov     edx, [ebp+var_4]
.text$mn:0000780F                 mov     eax, [edx+4]
.text$mn:00007812                 mov     ecx, [ebp+var_C]
.text$mn:00007815                 mov     edx, [eax+ecx*4]
.text$mn:00007818                 mov     eax, [ebp+var_10]
.text$mn:0000781B                 lea     eax, [edx+eax*4]
.text$mn:0000781E                 mov     esp, ebp
.text$mn:00007820                 pop     ebp
.text$mn:00007821                 retn
.text$mn:00007821 ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBEABIXZ endp
.text$mn:00007821
.text$mn:00007821 ; ---------------------------------------------------------------------------
.text$mn:00007822                 align 4
.text$mn:00007822 _text$mn        ends
.text$mn:00007822
.text$mn:00007824 ; ===========================================================================
.text$mn:00007824
.text$mn:00007824 ; Segment type: Pure code
.text$mn:00007824 ; Segment permissions: Read/Execute
.text$mn:00007824 _text$mn        segment para public 'CODE' use32
.text$mn:00007824                 assume cs:_text$mn
.text$mn:00007824                 ;org 7824h
.text$mn:00007824 ; COMDAT (pick any)
.text$mn:00007824                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007824
.text$mn:00007824 ; =============== S U B R O U T I N E =======================================
.text$mn:00007824
.text$mn:00007824 ; Attributes: bp-based frame
.text$mn:00007824
.text$mn:00007824 ; public: unsigned int & __thiscall std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>>::operator*(void)const
.text$mn:00007824                 public ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBEAAIXZ
.text$mn:00007824 ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBEAAIXZ proc near
.text$mn:00007824                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::back(void)+62p
.text$mn:00007824
.text$mn:00007824 var_4           = dword ptr -4
.text$mn:00007824
.text$mn:00007824                 push    ebp
.text$mn:00007825                 mov     ebp, esp
.text$mn:00007827                 push    ecx
.text$mn:00007828                 mov     [ebp+var_4], ecx
.text$mn:0000782B                 mov     ecx, [ebp+var_4]
.text$mn:0000782E                 call    ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBEABIXZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)
.text$mn:00007833                 mov     esp, ebp
.text$mn:00007835                 pop     ebp
.text$mn:00007836                 retn
.text$mn:00007836 ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBEAAIXZ endp
.text$mn:00007836
.text$mn:00007836 ; ---------------------------------------------------------------------------
.text$mn:00007837                 align 4
.text$mn:00007837 _text$mn        ends
.text$mn:00007837
.text$mn:00007838 ; ===========================================================================
.text$mn:00007838
.text$mn:00007838 ; Segment type: Pure code
.text$mn:00007838 ; Segment permissions: Read/Execute
.text$mn:00007838 _text$mn        segment para public 'CODE' use32
.text$mn:00007838                 assume cs:_text$mn
.text$mn:00007838                 ;org 7838h
.text$mn:00007838 ; COMDAT (pick any)
.text$mn:00007838                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007838
.text$mn:00007838 ; =============== S U B R O U T I N E =======================================
.text$mn:00007838
.text$mn:00007838 ; Attributes: bp-based frame
.text$mn:00007838
.text$mn:00007838 ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>> __thiscall std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>>::operator-(int)const
.text$mn:00007838                 public ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00007838 ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:00007838                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::back(void)+4Dp
.text$mn:00007838
.text$mn:00007838 var_20          = byte ptr -20h
.text$mn:00007838 var_14          = dword ptr -14h
.text$mn:00007838 var_10          = dword ptr -10h
.text$mn:00007838 var_C           = dword ptr -0Ch
.text$mn:00007838 var_4           = dword ptr -4
.text$mn:00007838 arg_0           = dword ptr  8
.text$mn:00007838 arg_4           = dword ptr  0Ch
.text$mn:00007838
.text$mn:00007838                 push    ebp
.text$mn:00007839                 mov     ebp, esp
.text$mn:0000783B                 push    0FFFFFFFFh
.text$mn:0000783D                 push    offset __ehhandler$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00007842                 mov     eax, large fs:0
.text$mn:00007848                 push    eax
.text$mn:00007849                 sub     esp, 14h
.text$mn:0000784C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007851                 xor     eax, ebp
.text$mn:00007853                 push    eax
.text$mn:00007854                 lea     eax, [ebp+var_C]
.text$mn:00007857                 mov     large fs:0, eax
.text$mn:0000785D                 mov     [ebp+var_14], ecx
.text$mn:00007860                 mov     [ebp+var_10], 0
.text$mn:00007867                 mov     eax, [ebp+var_14]
.text$mn:0000786A                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000786B                 lea     ecx, [ebp+var_20]
.text$mn:0000786E                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>> const &)
.text$mn:00007873                 mov     [ebp+var_4], 1
.text$mn:0000787A                 mov     ecx, [ebp+arg_4]
.text$mn:0000787D                 push    ecx
.text$mn:0000787E                 lea     ecx, [ebp+var_20]
.text$mn:00007881                 call    ??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator-=(int)
.text$mn:00007886                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00007887                 mov     ecx, [ebp+arg_0]
.text$mn:0000788A                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>> const &)
.text$mn:0000788F                 mov     edx, [ebp+var_10]
.text$mn:00007892                 or      edx, 1
.text$mn:00007895                 mov     [ebp+var_10], edx
.text$mn:00007898                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000789C                 lea     ecx, [ebp+var_20]
.text$mn:0000789F                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(void)
.text$mn:000078A4                 mov     eax, [ebp+arg_0]
.text$mn:000078A7                 mov     ecx, [ebp+var_C]
.text$mn:000078AA                 mov     large fs:0, ecx
.text$mn:000078B1                 pop     ecx
.text$mn:000078B2                 mov     esp, ebp
.text$mn:000078B4                 pop     ebp
.text$mn:000078B5                 retn    8
.text$mn:000078B5 ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:000078B5
.text$mn:000078B5 _text$mn        ends
.text$mn:000078B5
.text$x:000078B8 ; ===========================================================================
.text$x:000078B8
.text$x:000078B8 ; Segment type: Pure code
.text$x:000078B8 ; Segment permissions: Read/Execute
.text$x:000078B8 _text$x         segment para public 'CODE' use32
.text$x:000078B8                 assume cs:_text$x
.text$x:000078B8                 ;org 78B8h
.text$x:000078B8 ; COMDAT (pick associative to section at 7838)
.text$x:000078B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000078B8
.text$x:000078B8 ; =============== S U B R O U T I N E =======================================
.text$x:000078B8
.text$x:000078B8
.text$x:000078B8 __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:000078B8                                         ; DATA XREF: .xdata$x:0000C124o
.text$x:000078B8                 lea     ecx, [ebp-20h]
.text$x:000078BB                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(void)
.text$x:000078BB __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:000078BB
.text$x:000078C0
.text$x:000078C0 ; =============== S U B R O U T I N E =======================================
.text$x:000078C0
.text$x:000078C0
.text$x:000078C0 __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:000078C0                                         ; DATA XREF: .xdata$x:0000C11Co
.text$x:000078C0                 mov     eax, [ebp-10h]
.text$x:000078C3                 and     eax, 1
.text$x:000078C6                 jz      $LN5
.text$x:000078CC                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000078D0                 mov     ecx, [ebp+8]
.text$x:000078D3                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(void)
.text$x:000078D8 ; ---------------------------------------------------------------------------
.text$x:000078D8
.text$x:000078D8 $LN5:                                   ; CODE XREF: __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:000078D8                 retn
.text$x:000078D8 __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:000078D8
.text$x:000078D9
.text$x:000078D9 ; =============== S U B R O U T I N E =======================================
.text$x:000078D9
.text$x:000078D9
.text$x:000078D9 __ehhandler$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:000078D9                                         ; DATA XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator-(int)+5o
.text$x:000078D9
.text$x:000078D9 arg_4           = dword ptr  8
.text$x:000078D9
.text$x:000078D9                 mov     edx, [esp+arg_4]
.text$x:000078DD                 lea     eax, [edx+0Ch]
.text$x:000078E0                 mov     ecx, [edx-18h]
.text$x:000078E3                 xor     ecx, eax
.text$x:000078E5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000078EA                 mov     eax, offset __ehfuncinfo$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:000078EF                 jmp     ___CxxFrameHandler3
.text$x:000078EF __ehhandler$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:000078EF
.text$x:000078EF _text$x         ends
.text$x:000078EF
.text$mn:000078F4 ; ===========================================================================
.text$mn:000078F4
.text$mn:000078F4 ; Segment type: Pure code
.text$mn:000078F4 ; Segment permissions: Read/Execute
.text$mn:000078F4 _text$mn        segment para public 'CODE' use32
.text$mn:000078F4                 assume cs:_text$mn
.text$mn:000078F4                 ;org 78F4h
.text$mn:000078F4 ; COMDAT (pick any)
.text$mn:000078F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000078F4
.text$mn:000078F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000078F4
.text$mn:000078F4 ; Attributes: bp-based frame
.text$mn:000078F4
.text$mn:000078F4 ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>> & __thiscall std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>>::operator+=(int)
.text$mn:000078F4                 public ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:000078F4 ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:000078F4                                         ; CODE XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator-=(int)+10p
.text$mn:000078F4
.text$mn:000078F4 var_4           = dword ptr -4
.text$mn:000078F4 arg_0           = dword ptr  8
.text$mn:000078F4
.text$mn:000078F4                 push    ebp
.text$mn:000078F5                 mov     ebp, esp
.text$mn:000078F7                 push    ecx
.text$mn:000078F8                 mov     [ebp+var_4], ecx
.text$mn:000078FB                 mov     eax, [ebp+var_4]
.text$mn:000078FE                 mov     ecx, [eax+8]
.text$mn:00007901                 add     ecx, [ebp+arg_0]
.text$mn:00007904                 mov     edx, [ebp+var_4]
.text$mn:00007907                 mov     [edx+8], ecx
.text$mn:0000790A                 mov     eax, [ebp+var_4]
.text$mn:0000790D                 mov     esp, ebp
.text$mn:0000790F                 pop     ebp
.text$mn:00007910                 retn    4
.text$mn:00007910 ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00007910
.text$mn:00007910 ; ---------------------------------------------------------------------------
.text$mn:00007913                 align 4
.text$mn:00007913 _text$mn        ends
.text$mn:00007913
.text$mn:00007914 ; ===========================================================================
.text$mn:00007914
.text$mn:00007914 ; Segment type: Pure code
.text$mn:00007914 ; Segment permissions: Read/Execute
.text$mn:00007914 _text$mn        segment para public 'CODE' use32
.text$mn:00007914                 assume cs:_text$mn
.text$mn:00007914                 ;org 7914h
.text$mn:00007914 ; COMDAT (pick any)
.text$mn:00007914                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007914
.text$mn:00007914 ; =============== S U B R O U T I N E =======================================
.text$mn:00007914
.text$mn:00007914 ; Attributes: bp-based frame
.text$mn:00007914
.text$mn:00007914 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t *Str)
.text$mn:00007914                 public ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:00007914 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:00007914                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+8E8p
.text$mn:00007914                                         ; Notepad_plus::notify(SCNotification *)+8F8p
.text$mn:00007914
.text$mn:00007914 var_4           = dword ptr -4
.text$mn:00007914 Str             = dword ptr  8
.text$mn:00007914
.text$mn:00007914                 push    ebp
.text$mn:00007915                 mov     ebp, esp
.text$mn:00007917                 push    ecx
.text$mn:00007918                 mov     [ebp+var_4], ecx
.text$mn:0000791B                 mov     eax, [ebp+Str]
.text$mn:0000791E                 push    eax             ; Str
.text$mn:0000791F                 mov     ecx, [ebp+var_4]
.text$mn:00007922                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:00007927                 mov     esp, ebp
.text$mn:00007929                 pop     ebp
.text$mn:0000792A                 retn    4
.text$mn:0000792A ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:0000792A
.text$mn:0000792A ; ---------------------------------------------------------------------------
.text$mn:0000792D                 align 10h
.text$mn:0000792D _text$mn        ends
.text$mn:0000792D
.text$mn:00007930 ; ===========================================================================
.text$mn:00007930
.text$mn:00007930 ; Segment type: Pure code
.text$mn:00007930 ; Segment permissions: Read/Execute
.text$mn:00007930 _text$mn        segment para public 'CODE' use32
.text$mn:00007930                 assume cs:_text$mn
.text$mn:00007930                 ;org 7930h
.text$mn:00007930 ; COMDAT (pick any)
.text$mn:00007930                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007930
.text$mn:00007930 ; =============== S U B R O U T I N E =======================================
.text$mn:00007930
.text$mn:00007930 ; Attributes: bp-based frame
.text$mn:00007930
.text$mn:00007930 ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>> & __thiscall std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>>::operator-=(int)
.text$mn:00007930                 public ??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00007930 ??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00007930                                         ; CODE XREF: std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator-(int)+49p
.text$mn:00007930
.text$mn:00007930 var_4           = dword ptr -4
.text$mn:00007930 arg_0           = dword ptr  8
.text$mn:00007930
.text$mn:00007930                 push    ebp
.text$mn:00007931                 mov     ebp, esp
.text$mn:00007933                 push    ecx
.text$mn:00007934                 mov     [ebp+var_4], ecx
.text$mn:00007937                 mov     eax, [ebp+arg_0]
.text$mn:0000793A                 neg     eax
.text$mn:0000793C                 push    eax
.text$mn:0000793D                 mov     ecx, [ebp+var_4]
.text$mn:00007940                 call    ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator+=(int)
.text$mn:00007945                 mov     esp, ebp
.text$mn:00007947                 pop     ebp
.text$mn:00007948                 retn    4
.text$mn:00007948 ??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00007948
.text$mn:00007948 ; ---------------------------------------------------------------------------
.text$mn:0000794B                 align 4
.text$mn:0000794B _text$mn        ends
.text$mn:0000794B
.text$mn:0000794C ; ===========================================================================
.text$mn:0000794C
.text$mn:0000794C ; Segment type: Pure code
.text$mn:0000794C ; Segment permissions: Read/Execute
.text$mn:0000794C _text$mn        segment para public 'CODE' use32
.text$mn:0000794C                 assume cs:_text$mn
.text$mn:0000794C                 ;org 794Ch
.text$mn:0000794C ; COMDAT (pick any)
.text$mn:0000794C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000794C
.text$mn:0000794C ; =============== S U B R O U T I N E =======================================
.text$mn:0000794C
.text$mn:0000794C ; Attributes: bp-based frame
.text$mn:0000794C
.text$mn:0000794C ; public: void * __thiscall MenuItemUnit::`scalar deleting destructor'(unsigned int)
.text$mn:0000794C                 public ??_GMenuItemUnit@@QAEPAXI@Z
.text$mn:0000794C ??_GMenuItemUnit@@QAEPAXI@Z proc near   ; CODE XREF: std::allocator<MenuItemUnit>::destroy<MenuItemUnit>(MenuItemUnit *)+Cp
.text$mn:0000794C
.text$mn:0000794C var_4           = dword ptr -4
.text$mn:0000794C arg_0           = dword ptr  8
.text$mn:0000794C
.text$mn:0000794C                 push    ebp
.text$mn:0000794D                 mov     ebp, esp
.text$mn:0000794F                 push    ecx
.text$mn:00007950                 mov     [ebp+var_4], ecx
.text$mn:00007953                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007956                 call    ??1MenuItemUnit@@QAE@XZ ; MenuItemUnit::~MenuItemUnit(void)
.text$mn:0000795B                 mov     eax, [ebp+arg_0]
.text$mn:0000795E                 and     eax, 1
.text$mn:00007961                 jz      short loc_796F
.text$mn:00007963                 mov     ecx, [ebp+var_4]
.text$mn:00007966                 push    ecx             ; void *
.text$mn:00007967                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000796C                 add     esp, 4
.text$mn:0000796F
.text$mn:0000796F loc_796F:                               ; CODE XREF: MenuItemUnit::`scalar deleting destructor'(uint)+15j
.text$mn:0000796F                 mov     eax, [ebp+var_4]
.text$mn:00007972                 mov     esp, ebp
.text$mn:00007974                 pop     ebp
.text$mn:00007975                 retn    4
.text$mn:00007975 ??_GMenuItemUnit@@QAEPAXI@Z endp
.text$mn:00007975
.text$mn:00007975 _text$mn        ends
.text$mn:00007975
.text$mn:00007978 ; ===========================================================================
.text$mn:00007978
.text$mn:00007978 ; Segment type: Pure code
.text$mn:00007978 ; Segment permissions: Read/Execute
.text$mn:00007978 _text$mn        segment para public 'CODE' use32
.text$mn:00007978                 assume cs:_text$mn
.text$mn:00007978                 ;org 7978h
.text$mn:00007978 ; COMDAT (pick any)
.text$mn:00007978                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007978
.text$mn:00007978 ; =============== S U B R O U T I N E =======================================
.text$mn:00007978
.text$mn:00007978 ; Attributes: bp-based frame
.text$mn:00007978
.text$mn:00007978 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00007978                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00007978 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00007978
.text$mn:00007978 var_4           = dword ptr -4
.text$mn:00007978 arg_0           = dword ptr  8
.text$mn:00007978
.text$mn:00007978                 push    ebp
.text$mn:00007979                 mov     ebp, esp
.text$mn:0000797B                 push    ecx
.text$mn:0000797C                 mov     [ebp+var_4], ecx
.text$mn:0000797F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007982                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00007987                 mov     eax, [ebp+arg_0]
.text$mn:0000798A                 and     eax, 1
.text$mn:0000798D                 jz      short loc_799B
.text$mn:0000798F                 mov     ecx, [ebp+var_4]
.text$mn:00007992                 push    ecx             ; void *
.text$mn:00007993                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007998                 add     esp, 4
.text$mn:0000799B
.text$mn:0000799B loc_799B:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000799B                 mov     eax, [ebp+var_4]
.text$mn:0000799E                 mov     esp, ebp
.text$mn:000079A0                 pop     ebp
.text$mn:000079A1                 retn    4
.text$mn:000079A1 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:000079A1
.text$mn:000079A1 _text$mn        ends
.text$mn:000079A1
.text$mn:000079A4 ; ===========================================================================
.text$mn:000079A4
.text$mn:000079A4 ; Segment type: Pure code
.text$mn:000079A4 ; Segment permissions: Read/Execute
.text$mn:000079A4 _text$mn        segment para public 'CODE' use32
.text$mn:000079A4                 assume cs:_text$mn
.text$mn:000079A4                 ;org 79A4h
.text$mn:000079A4 ; COMDAT (pick any)
.text$mn:000079A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000079A4
.text$mn:000079A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000079A4
.text$mn:000079A4 ; Attributes: bp-based frame
.text$mn:000079A4
.text$mn:000079A4 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000079A4                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:000079A4 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:000079A4
.text$mn:000079A4 var_4           = dword ptr -4
.text$mn:000079A4 arg_0           = dword ptr  8
.text$mn:000079A4
.text$mn:000079A4                 push    ebp
.text$mn:000079A5                 mov     ebp, esp
.text$mn:000079A7                 push    ecx
.text$mn:000079A8                 mov     [ebp+var_4], ecx
.text$mn:000079AB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000079AE                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:000079B3                 mov     eax, [ebp+arg_0]
.text$mn:000079B6                 and     eax, 1
.text$mn:000079B9                 jz      short loc_79C7
.text$mn:000079BB                 mov     ecx, [ebp+var_4]
.text$mn:000079BE                 push    ecx             ; void *
.text$mn:000079BF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000079C4                 add     esp, 4
.text$mn:000079C7
.text$mn:000079C7 loc_79C7:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000079C7                 mov     eax, [ebp+var_4]
.text$mn:000079CA                 mov     esp, ebp
.text$mn:000079CC                 pop     ebp
.text$mn:000079CD                 retn    4
.text$mn:000079CD ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:000079CD
.text$mn:000079CD _text$mn        ends
.text$mn:000079CD
.text$mn:000079D0 ; ===========================================================================
.text$mn:000079D0
.text$mn:000079D0 ; Segment type: Pure code
.text$mn:000079D0 ; Segment permissions: Read/Execute
.text$mn:000079D0 _text$mn        segment para public 'CODE' use32
.text$mn:000079D0                 assume cs:_text$mn
.text$mn:000079D0                 ;org 79D0h
.text$mn:000079D0 ; COMDAT (pick any)
.text$mn:000079D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000079D0
.text$mn:000079D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000079D0
.text$mn:000079D0 ; Attributes: bp-based frame
.text$mn:000079D0
.text$mn:000079D0 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000079D0                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:000079D0 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:000079D0
.text$mn:000079D0 var_4           = dword ptr -4
.text$mn:000079D0 arg_0           = dword ptr  8
.text$mn:000079D0
.text$mn:000079D0                 push    ebp
.text$mn:000079D1                 mov     ebp, esp
.text$mn:000079D3                 push    ecx
.text$mn:000079D4                 mov     [ebp+var_4], ecx
.text$mn:000079D7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000079DA                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:000079DF                 mov     eax, [ebp+arg_0]
.text$mn:000079E2                 and     eax, 1
.text$mn:000079E5                 jz      short loc_79F3
.text$mn:000079E7                 mov     ecx, [ebp+var_4]
.text$mn:000079EA                 push    ecx             ; void *
.text$mn:000079EB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000079F0                 add     esp, 4
.text$mn:000079F3
.text$mn:000079F3 loc_79F3:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000079F3                 mov     eax, [ebp+var_4]
.text$mn:000079F6                 mov     esp, ebp
.text$mn:000079F8                 pop     ebp
.text$mn:000079F9                 retn    4
.text$mn:000079F9 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:000079F9
.text$mn:000079F9 _text$mn        ends
.text$mn:000079F9
.text$mn:000079FC ; ===========================================================================
.text$mn:000079FC
.text$mn:000079FC ; Segment type: Pure code
.text$mn:000079FC ; Segment permissions: Read/Execute
.text$mn:000079FC _text$mn        segment para public 'CODE' use32
.text$mn:000079FC                 assume cs:_text$mn
.text$mn:000079FC                 ;org 79FCh
.text$mn:000079FC ; COMDAT (pick any)
.text$mn:000079FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000079FC
.text$mn:000079FC ; =============== S U B R O U T I N E =======================================
.text$mn:000079FC
.text$mn:000079FC ; Attributes: bp-based frame
.text$mn:000079FC
.text$mn:000079FC ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000079FC                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:000079FC ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:000079FC
.text$mn:000079FC var_4           = dword ptr -4
.text$mn:000079FC arg_0           = dword ptr  8
.text$mn:000079FC
.text$mn:000079FC                 push    ebp
.text$mn:000079FD                 mov     ebp, esp
.text$mn:000079FF                 push    ecx
.text$mn:00007A00                 mov     [ebp+var_4], ecx
.text$mn:00007A03                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007A06                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00007A0B                 mov     eax, [ebp+arg_0]
.text$mn:00007A0E                 and     eax, 1
.text$mn:00007A11                 jz      short loc_7A1F
.text$mn:00007A13                 mov     ecx, [ebp+var_4]
.text$mn:00007A16                 push    ecx             ; void *
.text$mn:00007A17                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007A1C                 add     esp, 4
.text$mn:00007A1F
.text$mn:00007A1F loc_7A1F:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00007A1F                 mov     eax, [ebp+var_4]
.text$mn:00007A22                 mov     esp, ebp
.text$mn:00007A24                 pop     ebp
.text$mn:00007A25                 retn    4
.text$mn:00007A25 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00007A25
.text$mn:00007A25 _text$mn        ends
.text$mn:00007A25
.text$mn:00007A28 ; ===========================================================================
.text$mn:00007A28
.text$mn:00007A28 ; Segment type: Pure code
.text$mn:00007A28 ; Segment permissions: Read/Execute
.text$mn:00007A28 _text$mn        segment para public 'CODE' use32
.text$mn:00007A28                 assume cs:_text$mn
.text$mn:00007A28                 ;org 7A28h
.text$mn:00007A28 ; COMDAT (pick any)
.text$mn:00007A28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007A28
.text$mn:00007A28 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A28
.text$mn:00007A28 ; Attributes: bp-based frame
.text$mn:00007A28
.text$mn:00007A28 ; public: void * __thiscall recordedMacroStep::`scalar deleting destructor'(unsigned int)
.text$mn:00007A28                 public ??_GrecordedMacroStep@@QAEPAXI@Z
.text$mn:00007A28 ??_GrecordedMacroStep@@QAEPAXI@Z proc near
.text$mn:00007A28                                         ; CODE XREF: std::allocator<recordedMacroStep>::destroy<recordedMacroStep>(recordedMacroStep *)+Cp
.text$mn:00007A28
.text$mn:00007A28 var_4           = dword ptr -4
.text$mn:00007A28 arg_0           = dword ptr  8
.text$mn:00007A28
.text$mn:00007A28                 push    ebp
.text$mn:00007A29                 mov     ebp, esp
.text$mn:00007A2B                 push    ecx
.text$mn:00007A2C                 mov     [ebp+var_4], ecx
.text$mn:00007A2F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00007A32                 call    ??1recordedMacroStep@@QAE@XZ ; recordedMacroStep::~recordedMacroStep(void)
.text$mn:00007A37                 mov     eax, [ebp+arg_0]
.text$mn:00007A3A                 and     eax, 1
.text$mn:00007A3D                 jz      short loc_7A4B
.text$mn:00007A3F                 mov     ecx, [ebp+var_4]
.text$mn:00007A42                 push    ecx             ; void *
.text$mn:00007A43                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00007A48                 add     esp, 4
.text$mn:00007A4B
.text$mn:00007A4B loc_7A4B:                               ; CODE XREF: recordedMacroStep::`scalar deleting destructor'(uint)+15j
.text$mn:00007A4B                 mov     eax, [ebp+var_4]
.text$mn:00007A4E                 mov     esp, ebp
.text$mn:00007A50                 pop     ebp
.text$mn:00007A51                 retn    4
.text$mn:00007A51 ??_GrecordedMacroStep@@QAEPAXI@Z endp
.text$mn:00007A51
.text$mn:00007A51 _text$mn        ends
.text$mn:00007A51
.text$di:00007A54 ; ===========================================================================
.text$di:00007A54
.text$di:00007A54 ; Segment type: Pure code
.text$di:00007A54 ; Segment permissions: Read/Execute
.text$di:00007A54 _text$di        segment para public 'CODE' use32
.text$di:00007A54                 assume cs:_text$di
.text$di:00007A54                 ;org 7A54h
.text$di:00007A54 ; COMDAT (pick any)
.text$di:00007A54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007A54
.text$di:00007A54 ; =============== S U B R O U T I N E =======================================
.text$di:00007A54
.text$di:00007A54 ; Attributes: bp-based frame
.text$di:00007A54
.text$di:00007A54 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00007A54 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00007A54                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00007A54                 push    ebp
.text$di:00007A55                 mov     ebp, esp
.text$di:00007A57                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00007A5C                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00007A61                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00007A66                 call    _atexit
.text$di:00007A6B                 add     esp, 4
.text$di:00007A6E                 pop     ebp
.text$di:00007A6F                 retn
.text$di:00007A6F ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00007A6F
.text$di:00007A6F _text$di        ends
.text$di:00007A6F
.text$di:00007A70 ; ===========================================================================
.text$di:00007A70
.text$di:00007A70 ; Segment type: Pure code
.text$di:00007A70 ; Segment permissions: Read/Execute
.text$di:00007A70 _text$di        segment para public 'CODE' use32
.text$di:00007A70                 assume cs:_text$di
.text$di:00007A70                 ;org 7A70h
.text$di:00007A70 ; COMDAT (pick any)
.text$di:00007A70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007A70
.text$di:00007A70 ; =============== S U B R O U T I N E =======================================
.text$di:00007A70
.text$di:00007A70 ; Attributes: bp-based frame
.text$di:00007A70
.text$di:00007A70 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00007A70 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00007A70                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00007A70                 push    ebp
.text$di:00007A71                 mov     ebp, esp
.text$di:00007A73                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00007A78                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00007A7D                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00007A82                 call    _atexit
.text$di:00007A87                 add     esp, 4
.text$di:00007A8A                 pop     ebp
.text$di:00007A8B                 retn
.text$di:00007A8B ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00007A8B
.text$di:00007A8B _text$di        ends
.text$di:00007A8B
.text$di:00007A8C ; ===========================================================================
.text$di:00007A8C
.text$di:00007A8C ; Segment type: Pure code
.text$di:00007A8C ; Segment permissions: Read/Execute
.text$di:00007A8C _text$di        segment para public 'CODE' use32
.text$di:00007A8C                 assume cs:_text$di
.text$di:00007A8C                 ;org 7A8Ch
.text$di:00007A8C ; COMDAT (pick any)
.text$di:00007A8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007A8C
.text$di:00007A8C ; =============== S U B R O U T I N E =======================================
.text$di:00007A8C
.text$di:00007A8C ; Attributes: bp-based frame
.text$di:00007A8C
.text$di:00007A8C ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00007A8C ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00007A8C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00007A8C                 push    ebp
.text$di:00007A8D                 mov     ebp, esp
.text$di:00007A8F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00007A94                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00007A99                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00007A9E                 call    _atexit
.text$di:00007AA3                 add     esp, 4
.text$di:00007AA6                 pop     ebp
.text$di:00007AA7                 retn
.text$di:00007AA7 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00007AA7
.text$di:00007AA7 _text$di        ends
.text$di:00007AA7
.text$di:00007AA8 ; ===========================================================================
.text$di:00007AA8
.text$di:00007AA8 ; Segment type: Pure code
.text$di:00007AA8 ; Segment permissions: Read/Execute
.text$di:00007AA8 _text$di        segment para public 'CODE' use32
.text$di:00007AA8                 assume cs:_text$di
.text$di:00007AA8                 ;org 7AA8h
.text$di:00007AA8 ; COMDAT (pick any)
.text$di:00007AA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007AA8
.text$di:00007AA8 ; =============== S U B R O U T I N E =======================================
.text$di:00007AA8
.text$di:00007AA8 ; Attributes: bp-based frame
.text$di:00007AA8
.text$di:00007AA8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00007AA8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00007AA8                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00007AA8                 push    ebp
.text$di:00007AA9                 mov     ebp, esp
.text$di:00007AAB                 push    0               ; unsigned int
.text$di:00007AAD                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00007AB2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00007AB7                 pop     ebp
.text$di:00007AB8                 retn
.text$di:00007AB8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00007AB8
.text$di:00007AB8 ; ---------------------------------------------------------------------------
.text$di:00007AB9                 align 4
.text$di:00007AB9 _text$di        ends
.text$di:00007AB9
.text$di:00007ABC ; ===========================================================================
.text$di:00007ABC
.text$di:00007ABC ; Segment type: Pure code
.text$di:00007ABC ; Segment permissions: Read/Execute
.text$di:00007ABC _text$di        segment para public 'CODE' use32
.text$di:00007ABC                 assume cs:_text$di
.text$di:00007ABC                 ;org 7ABCh
.text$di:00007ABC ; COMDAT (pick any)
.text$di:00007ABC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007ABC
.text$di:00007ABC ; =============== S U B R O U T I N E =======================================
.text$di:00007ABC
.text$di:00007ABC ; Attributes: bp-based frame
.text$di:00007ABC
.text$di:00007ABC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00007ABC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00007ABC                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00007ABC                 push    ebp
.text$di:00007ABD                 mov     ebp, esp
.text$di:00007ABF                 push    0               ; unsigned int
.text$di:00007AC1                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00007AC6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00007ACB                 pop     ebp
.text$di:00007ACC                 retn
.text$di:00007ACC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00007ACC
.text$di:00007ACC ; ---------------------------------------------------------------------------
.text$di:00007ACD                 align 10h
.text$di:00007ACD _text$di        ends
.text$di:00007ACD
.text$di:00007AD0 ; ===========================================================================
.text$di:00007AD0
.text$di:00007AD0 ; Segment type: Pure code
.text$di:00007AD0 ; Segment permissions: Read/Execute
.text$di:00007AD0 _text$di        segment para public 'CODE' use32
.text$di:00007AD0                 assume cs:_text$di
.text$di:00007AD0                 ;org 7AD0h
.text$di:00007AD0 ; COMDAT (pick any)
.text$di:00007AD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007AD0
.text$di:00007AD0 ; =============== S U B R O U T I N E =======================================
.text$di:00007AD0
.text$di:00007AD0 ; Attributes: bp-based frame
.text$di:00007AD0
.text$di:00007AD0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00007AD0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00007AD0                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00007AD0                 push    ebp
.text$di:00007AD1                 mov     ebp, esp
.text$di:00007AD3                 push    0               ; unsigned int
.text$di:00007AD5                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00007ADA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00007ADF                 pop     ebp
.text$di:00007AE0                 retn
.text$di:00007AE0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00007AE0
.text$di:00007AE0 ; ---------------------------------------------------------------------------
.text$di:00007AE1                 align 4
.text$di:00007AE1 _text$di        ends
.text$di:00007AE1
.text$di:00007AE4 ; ===========================================================================
.text$di:00007AE4
.text$di:00007AE4 ; Segment type: Pure code
.text$di:00007AE4 ; Segment permissions: Read/Execute
.text$di:00007AE4 _text$di        segment para public 'CODE' use32
.text$di:00007AE4                 assume cs:_text$di
.text$di:00007AE4                 ;org 7AE4h
.text$di:00007AE4 ; COMDAT (pick any)
.text$di:00007AE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007AE4
.text$di:00007AE4 ; =============== S U B R O U T I N E =======================================
.text$di:00007AE4
.text$di:00007AE4 ; Attributes: bp-based frame
.text$di:00007AE4
.text$di:00007AE4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00007AE4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00007AE4                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00007AE4                 push    ebp
.text$di:00007AE5                 mov     ebp, esp
.text$di:00007AE7                 push    0               ; unsigned int
.text$di:00007AE9                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00007AEE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00007AF3                 pop     ebp
.text$di:00007AF4                 retn
.text$di:00007AF4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00007AF4
.text$di:00007AF4 ; ---------------------------------------------------------------------------
.text$di:00007AF5                 align 4
.text$di:00007AF5 _text$di        ends
.text$di:00007AF5
.text$di:00007AF8 ; ===========================================================================
.text$di:00007AF8
.text$di:00007AF8 ; Segment type: Pure code
.text$di:00007AF8 ; Segment permissions: Read/Execute
.text$di:00007AF8 _text$di        segment para public 'CODE' use32
.text$di:00007AF8                 assume cs:_text$di
.text$di:00007AF8                 ;org 7AF8h
.text$di:00007AF8 ; COMDAT (pick any)
.text$di:00007AF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007AF8
.text$di:00007AF8 ; =============== S U B R O U T I N E =======================================
.text$di:00007AF8
.text$di:00007AF8 ; Attributes: bp-based frame
.text$di:00007AF8
.text$di:00007AF8 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00007AF8 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00007AF8
.text$di:00007AF8 var_1           = byte ptr -1
.text$di:00007AF8
.text$di:00007AF8                 push    ebp
.text$di:00007AF9                 mov     ebp, esp
.text$di:00007AFB                 push    ecx
.text$di:00007AFC                 xor     eax, eax
.text$di:00007AFE                 mov     [ebp+var_1], al
.text$di:00007B01                 mov     esp, ebp
.text$di:00007B03                 pop     ebp
.text$di:00007B04                 retn
.text$di:00007B04 ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:00007B04
.text$di:00007B04 ; ---------------------------------------------------------------------------
.text$di:00007B05                 align 4
.text$di:00007B05 _text$di        ends
.text$di:00007B05
.text$di:00007B08 ; ===========================================================================
.text$di:00007B08
.text$di:00007B08 ; Segment type: Pure code
.text$di:00007B08 ; Segment permissions: Read/Execute
.text$di:00007B08 _text$di        segment para public 'CODE' use32
.text$di:00007B08                 assume cs:_text$di
.text$di:00007B08                 ;org 7B08h
.text$di:00007B08 ; COMDAT (pick any)
.text$di:00007B08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007B08
.text$di:00007B08 ; =============== S U B R O U T I N E =======================================
.text$di:00007B08
.text$di:00007B08 ; Attributes: bp-based frame
.text$di:00007B08
.text$di:00007B08 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00007B08 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00007B08
.text$di:00007B08 var_1           = byte ptr -1
.text$di:00007B08
.text$di:00007B08                 push    ebp
.text$di:00007B09                 mov     ebp, esp
.text$di:00007B0B                 push    ecx
.text$di:00007B0C                 xor     eax, eax
.text$di:00007B0E                 mov     [ebp+var_1], al
.text$di:00007B11                 mov     esp, ebp
.text$di:00007B13                 pop     ebp
.text$di:00007B14                 retn
.text$di:00007B14 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00007B14
.text$di:00007B14 ; ---------------------------------------------------------------------------
.text$di:00007B15                 align 4
.text$di:00007B15 _text$di        ends
.text$di:00007B15
.text$di:00007B18 ; ===========================================================================
.text$di:00007B18
.text$di:00007B18 ; Segment type: Pure code
.text$di:00007B18 ; Segment permissions: Read/Execute
.text$di:00007B18 _text$di        segment para public 'CODE' use32
.text$di:00007B18                 assume cs:_text$di
.text$di:00007B18                 ;org 7B18h
.text$di:00007B18 ; COMDAT (pick any)
.text$di:00007B18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007B18
.text$di:00007B18 ; =============== S U B R O U T I N E =======================================
.text$di:00007B18
.text$di:00007B18 ; Attributes: bp-based frame
.text$di:00007B18
.text$di:00007B18 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00007B18 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00007B18                 push    ebp
.text$di:00007B19                 mov     ebp, esp
.text$di:00007B1B                 mov     ecx, offset _ignore ; this
.text$di:00007B20                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:00007B25                 pop     ebp
.text$di:00007B26                 retn
.text$di:00007B26 ??__Eignore@std@@YAXXZ endp
.text$di:00007B26
.text$di:00007B26 ; ---------------------------------------------------------------------------
.text$di:00007B27                 align 4
.text$di:00007B27 _text$di        ends
.text$di:00007B27
.text$di:00007B28 ; ===========================================================================
.text$di:00007B28
.text$di:00007B28 ; Segment type: Pure code
.text$di:00007B28 ; Segment permissions: Read/Execute
.text$di:00007B28 _text$di        segment para public 'CODE' use32
.text$di:00007B28                 assume cs:_text$di
.text$di:00007B28                 ;org 7B28h
.text$di:00007B28 ; COMDAT (pick any)
.text$di:00007B28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00007B28
.text$di:00007B28 ; =============== S U B R O U T I N E =======================================
.text$di:00007B28
.text$di:00007B28 ; Attributes: bp-based frame
.text$di:00007B28
.text$di:00007B28 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00007B28 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00007B28                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00007B28
.text$di:00007B28 var_1           = byte ptr -1
.text$di:00007B28
.text$di:00007B28                 push    ebp
.text$di:00007B29                 mov     ebp, esp
.text$di:00007B2B                 push    ecx
.text$di:00007B2C                 xor     eax, eax
.text$di:00007B2E                 mov     [ebp+var_1], al
.text$di:00007B31                 mov     esp, ebp
.text$di:00007B33                 pop     ebp
.text$di:00007B34                 retn
.text$di:00007B34 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00007B34
.text$di:00007B34 ; ---------------------------------------------------------------------------
.text$di:00007B35                 align 4
.text$di:00007B35 _text$di        ends
.text$di:00007B35
.text$yd:00007B38 ; ===========================================================================
.text$yd:00007B38
.text$yd:00007B38 ; Segment type: Pure code
.text$yd:00007B38 ; Segment permissions: Read/Execute
.text$yd:00007B38 _text$yd        segment para public 'CODE' use32
.text$yd:00007B38                 assume cs:_text$yd
.text$yd:00007B38                 ;org 7B38h
.text$yd:00007B38 ; COMDAT (pick any)
.text$yd:00007B38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00007B38
.text$yd:00007B38 ; =============== S U B R O U T I N E =======================================
.text$yd:00007B38
.text$yd:00007B38 ; Attributes: bp-based frame
.text$yd:00007B38
.text$yd:00007B38 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00007B38 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00007B38                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00007B38                 push    ebp
.text$yd:00007B39                 mov     ebp, esp
.text$yd:00007B3B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00007B40                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00007B45                 pop     ebp
.text$yd:00007B46                 retn
.text$yd:00007B46 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00007B46
.text$yd:00007B46 ; ---------------------------------------------------------------------------
.text$yd:00007B47                 align 4
.text$yd:00007B47 _text$yd        ends
.text$yd:00007B47
.text$yd:00007B48 ; ===========================================================================
.text$yd:00007B48
.text$yd:00007B48 ; Segment type: Pure code
.text$yd:00007B48 ; Segment permissions: Read/Execute
.text$yd:00007B48 _text$yd        segment para public 'CODE' use32
.text$yd:00007B48                 assume cs:_text$yd
.text$yd:00007B48                 ;org 7B48h
.text$yd:00007B48 ; COMDAT (pick any)
.text$yd:00007B48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00007B48
.text$yd:00007B48 ; =============== S U B R O U T I N E =======================================
.text$yd:00007B48
.text$yd:00007B48 ; Attributes: bp-based frame
.text$yd:00007B48
.text$yd:00007B48 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00007B48 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00007B48                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00007B48                 push    ebp
.text$yd:00007B49                 mov     ebp, esp
.text$yd:00007B4B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00007B50                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00007B55                 pop     ebp
.text$yd:00007B56                 retn
.text$yd:00007B56 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00007B56
.text$yd:00007B56 ; ---------------------------------------------------------------------------
.text$yd:00007B57                 align 4
.text$yd:00007B57 _text$yd        ends
.text$yd:00007B57
.text$yd:00007B58 ; ===========================================================================
.text$yd:00007B58
.text$yd:00007B58 ; Segment type: Pure code
.text$yd:00007B58 ; Segment permissions: Read/Execute
.text$yd:00007B58 _text$yd        segment para public 'CODE' use32
.text$yd:00007B58                 assume cs:_text$yd
.text$yd:00007B58                 ;org 7B58h
.text$yd:00007B58 ; COMDAT (pick any)
.text$yd:00007B58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00007B58
.text$yd:00007B58 ; =============== S U B R O U T I N E =======================================
.text$yd:00007B58
.text$yd:00007B58 ; Attributes: bp-based frame
.text$yd:00007B58
.text$yd:00007B58 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00007B58 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00007B58                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00007B58                 push    ebp
.text$yd:00007B59                 mov     ebp, esp
.text$yd:00007B5B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00007B60                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00007B65                 pop     ebp
.text$yd:00007B66                 retn
.text$yd:00007B66 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00007B66
.text$yd:00007B66 ; ---------------------------------------------------------------------------
.text$yd:00007B67                 align 4
.text$yd:00007B67 _text$yd        ends
.text$yd:00007B67
.text$mn:00007B68 ; ===========================================================================
.text$mn:00007B68
.text$mn:00007B68 ; Segment type: Pure code
.text$mn:00007B68 ; Segment permissions: Read/Execute
.text$mn:00007B68 _text$mn        segment para public 'CODE' use32
.text$mn:00007B68                 assume cs:_text$mn
.text$mn:00007B68                 ;org 7B68h
.text$mn:00007B68 ; COMDAT (pick any)
.text$mn:00007B68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007B68
.text$mn:00007B68 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B68
.text$mn:00007B68 ; Attributes: bp-based frame
.text$mn:00007B68
.text$mn:00007B68 ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:00007B68                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00007B68 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:00007B68                                         ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+49p
.text$mn:00007B68                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Setcont(std::_Deque_val<std::_Deque_simple_types<uint>> const *)+Ep
.text$mn:00007B68
.text$mn:00007B68 var_1C          = byte ptr -1Ch
.text$mn:00007B68 var_18          = byte ptr -18h
.text$mn:00007B68 var_14          = dword ptr -14h
.text$mn:00007B68 var_10          = dword ptr -10h
.text$mn:00007B68 var_C           = dword ptr -0Ch
.text$mn:00007B68 var_4           = dword ptr -4
.text$mn:00007B68 arg_0           = dword ptr  8
.text$mn:00007B68
.text$mn:00007B68                 push    ebp
.text$mn:00007B69                 mov     ebp, esp
.text$mn:00007B6B                 push    0FFFFFFFFh
.text$mn:00007B6D                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00007B72                 mov     eax, large fs:0
.text$mn:00007B78                 push    eax
.text$mn:00007B79                 sub     esp, 10h
.text$mn:00007B7C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007B81                 xor     eax, ebp
.text$mn:00007B83                 push    eax
.text$mn:00007B84                 lea     eax, [ebp+var_C]
.text$mn:00007B87                 mov     large fs:0, eax
.text$mn:00007B8D                 mov     [ebp+var_10], ecx
.text$mn:00007B90                 cmp     [ebp+arg_0], 0
.text$mn:00007B94                 jnz     short loc_7BC0
.text$mn:00007B96                 push    3               ; int
.text$mn:00007B98                 lea     ecx, [ebp+var_18] ; this
.text$mn:00007B9B                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00007BA0                 mov     [ebp+var_4], 0
.text$mn:00007BA7                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007BAA                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00007BAF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007BB6                 lea     ecx, [ebp+var_18] ; this
.text$mn:00007BB9                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00007BBE                 jmp     short loc_7C17
.text$mn:00007BC0 ; ---------------------------------------------------------------------------
.text$mn:00007BC0
.text$mn:00007BC0 loc_7BC0:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:00007BC0                 mov     eax, [ebp+arg_0]
.text$mn:00007BC3                 mov     ecx, [eax]
.text$mn:00007BC5                 mov     [ebp+var_14], ecx
.text$mn:00007BC8                 mov     edx, [ebp+var_10]
.text$mn:00007BCB                 mov     eax, [edx]
.text$mn:00007BCD                 cmp     eax, [ebp+var_14]
.text$mn:00007BD0                 jz      short loc_7C17
.text$mn:00007BD2                 push    3               ; int
.text$mn:00007BD4                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00007BD7                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00007BDC                 mov     [ebp+var_4], 1
.text$mn:00007BE3                 mov     ecx, [ebp+var_10] ; this
.text$mn:00007BE6                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00007BEB                 mov     ecx, [ebp+var_10]
.text$mn:00007BEE                 mov     edx, [ebp+var_14]
.text$mn:00007BF1                 mov     eax, [edx+4]
.text$mn:00007BF4                 mov     [ecx+4], eax
.text$mn:00007BF7                 mov     ecx, [ebp+var_14]
.text$mn:00007BFA                 mov     edx, [ebp+var_10]
.text$mn:00007BFD                 mov     [ecx+4], edx
.text$mn:00007C00                 mov     eax, [ebp+var_10]
.text$mn:00007C03                 mov     ecx, [ebp+var_14]
.text$mn:00007C06                 mov     [eax], ecx
.text$mn:00007C08                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007C0F                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00007C12                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00007C17
.text$mn:00007C17 loc_7C17:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:00007C17                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:00007C17                 mov     ecx, [ebp+var_C]
.text$mn:00007C1A                 mov     large fs:0, ecx
.text$mn:00007C21                 pop     ecx
.text$mn:00007C22                 mov     esp, ebp
.text$mn:00007C24                 pop     ebp
.text$mn:00007C25                 retn    4
.text$mn:00007C25 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00007C25
.text$mn:00007C25 _text$mn        ends
.text$mn:00007C25
.text$x:00007C28 ; ===========================================================================
.text$x:00007C28
.text$x:00007C28 ; Segment type: Pure code
.text$x:00007C28 ; Segment permissions: Read/Execute
.text$x:00007C28 _text$x         segment para public 'CODE' use32
.text$x:00007C28                 assume cs:_text$x
.text$x:00007C28                 ;org 7C28h
.text$x:00007C28 ; COMDAT (pick associative to section at 7B68)
.text$x:00007C28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007C28
.text$x:00007C28 ; =============== S U B R O U T I N E =======================================
.text$x:00007C28
.text$x:00007C28
.text$x:00007C28 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:00007C28                                         ; DATA XREF: .xdata$x:0000B4B4o
.text$x:00007C28                 lea     ecx, [ebp-18h]  ; this
.text$x:00007C2B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00007C2B __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:00007C2B
.text$x:00007C30
.text$x:00007C30 ; =============== S U B R O U T I N E =======================================
.text$x:00007C30
.text$x:00007C30
.text$x:00007C30 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:00007C30                                         ; DATA XREF: .xdata$x:0000B4BCo
.text$x:00007C30                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00007C33                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00007C33 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:00007C33
.text$x:00007C38
.text$x:00007C38 ; =============== S U B R O U T I N E =======================================
.text$x:00007C38
.text$x:00007C38
.text$x:00007C38 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:00007C38                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:00007C38
.text$x:00007C38 arg_4           = dword ptr  8
.text$x:00007C38
.text$x:00007C38                 mov     edx, [esp+arg_4]
.text$x:00007C3C                 lea     eax, [edx+0Ch]
.text$x:00007C3F                 mov     ecx, [edx-14h]
.text$x:00007C42                 xor     ecx, eax
.text$x:00007C44                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007C49                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:00007C4E                 jmp     ___CxxFrameHandler3
.text$x:00007C4E __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:00007C4E
.text$x:00007C4E ; ---------------------------------------------------------------------------
.text$x:00007C53                 align 4
.text$x:00007C53 _text$x         ends
.text$x:00007C53
.text$mn:00007C54 ; ===========================================================================
.text$mn:00007C54
.text$mn:00007C54 ; Segment type: Pure code
.text$mn:00007C54 ; Segment permissions: Read/Execute
.text$mn:00007C54 _text$mn        segment para public 'CODE' use32
.text$mn:00007C54                 assume cs:_text$mn
.text$mn:00007C54                 ;org 7C54h
.text$mn:00007C54 ; COMDAT (pick any)
.text$mn:00007C54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007C54
.text$mn:00007C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C54
.text$mn:00007C54 ; Attributes: bp-based frame
.text$mn:00007C54
.text$mn:00007C54 ; public: void __thiscall std::_Deque_alloc<0, struct std::_Deque_base_types<unsigned int, class std::allocator<unsigned int>>>::_Alloc_proxy(void)
.text$mn:00007C54                 public ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ
.text$mn:00007C54 ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00007C54                                         ; CODE XREF: std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>(std::allocator<uint> const &)+38p
.text$mn:00007C54
.text$mn:00007C54 var_10          = byte ptr -10h
.text$mn:00007C54 var_8           = dword ptr -8
.text$mn:00007C54 var_1           = byte ptr -1
.text$mn:00007C54
.text$mn:00007C54                 push    ebp
.text$mn:00007C55                 mov     ebp, esp
.text$mn:00007C57                 sub     esp, 10h
.text$mn:00007C5A                 mov     [ebp+var_8], ecx
.text$mn:00007C5D                 lea     ecx, [ebp+var_1]
.text$mn:00007C60                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00007C65                 push    1
.text$mn:00007C67                 lea     ecx, [ebp+var_1]
.text$mn:00007C6A                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00007C6F                 mov     ecx, [ebp+var_8]
.text$mn:00007C72                 mov     [ecx], eax
.text$mn:00007C74                 lea     ecx, [ebp+var_10] ; this
.text$mn:00007C77                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00007C7C                 push    eax             ; int
.text$mn:00007C7D                 mov     edx, [ebp+var_8]
.text$mn:00007C80                 mov     eax, [edx]
.text$mn:00007C82                 push    eax             ; void *
.text$mn:00007C83                 lea     ecx, [ebp+var_1]
.text$mn:00007C86                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00007C8B                 mov     ecx, [ebp+var_8]
.text$mn:00007C8E                 mov     edx, [ecx]
.text$mn:00007C90                 mov     eax, [ebp+var_8]
.text$mn:00007C93                 mov     [edx], eax
.text$mn:00007C95                 mov     esp, ebp
.text$mn:00007C97                 pop     ebp
.text$mn:00007C98                 retn
.text$mn:00007C98 ?_Alloc_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ endp
.text$mn:00007C98
.text$mn:00007C98 ; ---------------------------------------------------------------------------
.text$mn:00007C99                 align 4
.text$mn:00007C99 _text$mn        ends
.text$mn:00007C99
.text$mn:00007C9C ; ===========================================================================
.text$mn:00007C9C
.text$mn:00007C9C ; Segment type: Pure code
.text$mn:00007C9C ; Segment permissions: Read/Execute
.text$mn:00007C9C _text$mn        segment para public 'CODE' use32
.text$mn:00007C9C                 assume cs:_text$mn
.text$mn:00007C9C                 ;org 7C9Ch
.text$mn:00007C9C ; COMDAT (pick any)
.text$mn:00007C9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007C9C
.text$mn:00007C9C ; =============== S U B R O U T I N E =======================================
.text$mn:00007C9C
.text$mn:00007C9C ; Attributes: bp-based frame
.text$mn:00007C9C
.text$mn:00007C9C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00007C9C                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00007C9C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00007C9C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00007C9C
.text$mn:00007C9C var_10          = byte ptr -10h
.text$mn:00007C9C var_8           = dword ptr -8
.text$mn:00007C9C var_1           = byte ptr -1
.text$mn:00007C9C
.text$mn:00007C9C                 push    ebp
.text$mn:00007C9D                 mov     ebp, esp
.text$mn:00007C9F                 sub     esp, 10h
.text$mn:00007CA2                 mov     [ebp+var_8], ecx
.text$mn:00007CA5                 lea     ecx, [ebp+var_1]
.text$mn:00007CA8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00007CAD                 push    1
.text$mn:00007CAF                 lea     ecx, [ebp+var_1]
.text$mn:00007CB2                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00007CB7                 mov     ecx, [ebp+var_8]
.text$mn:00007CBA                 mov     [ecx], eax
.text$mn:00007CBC                 lea     ecx, [ebp+var_10] ; this
.text$mn:00007CBF                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00007CC4                 push    eax             ; int
.text$mn:00007CC5                 mov     edx, [ebp+var_8]
.text$mn:00007CC8                 mov     eax, [edx]
.text$mn:00007CCA                 push    eax             ; void *
.text$mn:00007CCB                 lea     ecx, [ebp+var_1]
.text$mn:00007CCE                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00007CD3                 mov     ecx, [ebp+var_8]
.text$mn:00007CD6                 mov     edx, [ecx]
.text$mn:00007CD8                 mov     eax, [ebp+var_8]
.text$mn:00007CDB                 mov     [edx], eax
.text$mn:00007CDD                 mov     esp, ebp
.text$mn:00007CDF                 pop     ebp
.text$mn:00007CE0                 retn
.text$mn:00007CE0 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00007CE0
.text$mn:00007CE0 ; ---------------------------------------------------------------------------
.text$mn:00007CE1                 align 4
.text$mn:00007CE1 _text$mn        ends
.text$mn:00007CE1
.text$mn:00007CE4 ; ===========================================================================
.text$mn:00007CE4
.text$mn:00007CE4 ; Segment type: Pure code
.text$mn:00007CE4 ; Segment permissions: Read/Execute
.text$mn:00007CE4 _text$mn        segment para public 'CODE' use32
.text$mn:00007CE4                 assume cs:_text$mn
.text$mn:00007CE4                 ;org 7CE4h
.text$mn:00007CE4 ; COMDAT (pick any)
.text$mn:00007CE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007CE4
.text$mn:00007CE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CE4
.text$mn:00007CE4 ; Attributes: bp-based frame
.text$mn:00007CE4
.text$mn:00007CE4 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00007CE4                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00007CE4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00007CE4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:00007CE4
.text$mn:00007CE4 var_10          = byte ptr -10h
.text$mn:00007CE4 var_8           = dword ptr -8
.text$mn:00007CE4 var_1           = byte ptr -1
.text$mn:00007CE4
.text$mn:00007CE4                 push    ebp
.text$mn:00007CE5                 mov     ebp, esp
.text$mn:00007CE7                 sub     esp, 10h
.text$mn:00007CEA                 mov     [ebp+var_8], ecx
.text$mn:00007CED                 lea     ecx, [ebp+var_1]
.text$mn:00007CF0                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00007CF5                 push    1
.text$mn:00007CF7                 lea     ecx, [ebp+var_1]
.text$mn:00007CFA                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00007CFF                 mov     ecx, [ebp+var_8]
.text$mn:00007D02                 mov     [ecx], eax
.text$mn:00007D04                 lea     ecx, [ebp+var_10] ; this
.text$mn:00007D07                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00007D0C                 push    eax             ; int
.text$mn:00007D0D                 mov     edx, [ebp+var_8]
.text$mn:00007D10                 mov     eax, [edx]
.text$mn:00007D12                 push    eax             ; void *
.text$mn:00007D13                 lea     ecx, [ebp+var_1]
.text$mn:00007D16                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00007D1B                 mov     ecx, [ebp+var_8]
.text$mn:00007D1E                 mov     edx, [ecx]
.text$mn:00007D20                 mov     eax, [ebp+var_8]
.text$mn:00007D23                 mov     [edx], eax
.text$mn:00007D25                 mov     esp, ebp
.text$mn:00007D27                 pop     ebp
.text$mn:00007D28                 retn
.text$mn:00007D28 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00007D28
.text$mn:00007D28 ; ---------------------------------------------------------------------------
.text$mn:00007D29                 align 4
.text$mn:00007D29 _text$mn        ends
.text$mn:00007D29
.text$mn:00007D2C ; ===========================================================================
.text$mn:00007D2C
.text$mn:00007D2C ; Segment type: Pure code
.text$mn:00007D2C ; Segment permissions: Read/Execute
.text$mn:00007D2C _text$mn        segment para public 'CODE' use32
.text$mn:00007D2C                 assume cs:_text$mn
.text$mn:00007D2C                 ;org 7D2Ch
.text$mn:00007D2C ; COMDAT (pick any)
.text$mn:00007D2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007D2C
.text$mn:00007D2C ; =============== S U B R O U T I N E =======================================
.text$mn:00007D2C
.text$mn:00007D2C ; Attributes: bp-based frame
.text$mn:00007D2C
.text$mn:00007D2C ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>>::_Alloc_proxy(void)
.text$mn:00007D2C                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ
.text$mn:00007D2C ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00007D2C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(std::allocator<MenuItemUnit> const &)+38p
.text$mn:00007D2C
.text$mn:00007D2C var_10          = byte ptr -10h
.text$mn:00007D2C var_8           = dword ptr -8
.text$mn:00007D2C var_1           = byte ptr -1
.text$mn:00007D2C
.text$mn:00007D2C                 push    ebp
.text$mn:00007D2D                 mov     ebp, esp
.text$mn:00007D2F                 sub     esp, 10h
.text$mn:00007D32                 mov     [ebp+var_8], ecx
.text$mn:00007D35                 lea     ecx, [ebp+var_1]
.text$mn:00007D38                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00007D3D                 push    1
.text$mn:00007D3F                 lea     ecx, [ebp+var_1]
.text$mn:00007D42                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00007D47                 mov     ecx, [ebp+var_8]
.text$mn:00007D4A                 mov     [ecx], eax
.text$mn:00007D4C                 lea     ecx, [ebp+var_10] ; this
.text$mn:00007D4F                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00007D54                 push    eax             ; int
.text$mn:00007D55                 mov     edx, [ebp+var_8]
.text$mn:00007D58                 mov     eax, [edx]
.text$mn:00007D5A                 push    eax             ; void *
.text$mn:00007D5B                 lea     ecx, [ebp+var_1]
.text$mn:00007D5E                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00007D63                 mov     ecx, [ebp+var_8]
.text$mn:00007D66                 mov     edx, [ecx]
.text$mn:00007D68                 mov     eax, [ebp+var_8]
.text$mn:00007D6B                 mov     [edx], eax
.text$mn:00007D6D                 mov     esp, ebp
.text$mn:00007D6F                 pop     ebp
.text$mn:00007D70                 retn
.text$mn:00007D70 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00007D70
.text$mn:00007D70 ; ---------------------------------------------------------------------------
.text$mn:00007D71                 align 4
.text$mn:00007D71 _text$mn        ends
.text$mn:00007D71
.text$mn:00007D74 ; ===========================================================================
.text$mn:00007D74
.text$mn:00007D74 ; Segment type: Pure code
.text$mn:00007D74 ; Segment permissions: Read/Execute
.text$mn:00007D74 _text$mn        segment para public 'CODE' use32
.text$mn:00007D74                 assume cs:_text$mn
.text$mn:00007D74                 ;org 7D74h
.text$mn:00007D74 ; COMDAT (pick any)
.text$mn:00007D74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007D74
.text$mn:00007D74 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D74
.text$mn:00007D74 ; Attributes: bp-based frame
.text$mn:00007D74
.text$mn:00007D74 ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:00007D74                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:00007D74 ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00007D74                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Orphan_off(uint)+BDp
.text$mn:00007D74                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+80p ...
.text$mn:00007D74
.text$mn:00007D74 var_4           = dword ptr -4
.text$mn:00007D74
.text$mn:00007D74                 push    ebp
.text$mn:00007D75                 mov     ebp, esp
.text$mn:00007D77                 push    ecx
.text$mn:00007D78                 mov     [ebp+var_4], ecx
.text$mn:00007D7B                 mov     eax, [ebp+var_4]
.text$mn:00007D7E                 mov     dword ptr [eax], 0
.text$mn:00007D84                 mov     esp, ebp
.text$mn:00007D86                 pop     ebp
.text$mn:00007D87                 retn
.text$mn:00007D87 ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00007D87
.text$mn:00007D87 _text$mn        ends
.text$mn:00007D87
.text$mn:00007D88 ; ===========================================================================
.text$mn:00007D88
.text$mn:00007D88 ; Segment type: Pure code
.text$mn:00007D88 ; Segment permissions: Read/Execute
.text$mn:00007D88 _text$mn        segment para public 'CODE' use32
.text$mn:00007D88                 assume cs:_text$mn
.text$mn:00007D88                 ;org 7D88h
.text$mn:00007D88 ; COMDAT (pick any)
.text$mn:00007D88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007D88
.text$mn:00007D88 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D88
.text$mn:00007D88 ; Attributes: bp-based frame
.text$mn:00007D88
.text$mn:00007D88 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00007D88                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00007D88 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00007D88                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00007D88
.text$mn:00007D88 var_20          = dword ptr -20h
.text$mn:00007D88 var_1C          = dword ptr -1Ch
.text$mn:00007D88 var_18          = dword ptr -18h
.text$mn:00007D88 var_11          = byte ptr -11h
.text$mn:00007D88 var_10          = dword ptr -10h
.text$mn:00007D88 var_C           = byte ptr -0Ch
.text$mn:00007D88 var_4           = dword ptr -4
.text$mn:00007D88 arg_0           = dword ptr  8
.text$mn:00007D88
.text$mn:00007D88 ; FUNCTION CHUNK AT .text$mn:00007EAA SIZE 00000009 BYTES
.text$mn:00007D88
.text$mn:00007D88                 push    ebp
.text$mn:00007D89                 mov     ebp, esp
.text$mn:00007D8B                 push    0FFFFFFFFh
.text$mn:00007D8D                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00007D92                 mov     eax, large fs:0
.text$mn:00007D98                 push    eax
.text$mn:00007D99                 push    ecx
.text$mn:00007D9A                 sub     esp, 10h
.text$mn:00007D9D                 push    ebx
.text$mn:00007D9E                 push    esi
.text$mn:00007D9F                 push    edi
.text$mn:00007DA0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007DA5                 xor     eax, ebp
.text$mn:00007DA7                 push    eax
.text$mn:00007DA8                 lea     eax, [ebp+var_C]
.text$mn:00007DAB                 mov     large fs:0, eax
.text$mn:00007DB1                 mov     [ebp+var_10], esp
.text$mn:00007DB4                 mov     [ebp+var_18], ecx
.text$mn:00007DB7                 mov     eax, [ebp+arg_0]
.text$mn:00007DBA                 or      eax, 0Fh
.text$mn:00007DBD                 mov     [ebp+var_1C], eax
.text$mn:00007DC0                 mov     ecx, [ebp+var_18]
.text$mn:00007DC3                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00007DC8                 cmp     eax, [ebp+var_1C]
.text$mn:00007DCB                 jnb     short loc_7DD5
.text$mn:00007DCD                 mov     ecx, [ebp+arg_0]
.text$mn:00007DD0                 mov     [ebp+var_1C], ecx
.text$mn:00007DD3                 jmp     short loc_7E27
.text$mn:00007DD5 ; ---------------------------------------------------------------------------
.text$mn:00007DD5
.text$mn:00007DD5 loc_7DD5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00007DD5                 mov     edx, [ebp+var_18]
.text$mn:00007DD8                 mov     ecx, [edx+18h]
.text$mn:00007DDB                 shr     ecx, 1
.text$mn:00007DDD                 mov     eax, [ebp+var_1C]
.text$mn:00007DE0                 xor     edx, edx
.text$mn:00007DE2                 mov     esi, 3
.text$mn:00007DE7                 div     esi
.text$mn:00007DE9                 cmp     ecx, eax
.text$mn:00007DEB                 ja      short loc_7DEF
.text$mn:00007DED                 jmp     short loc_7E27
.text$mn:00007DEF ; ---------------------------------------------------------------------------
.text$mn:00007DEF
.text$mn:00007DEF loc_7DEF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00007DEF                 mov     ecx, [ebp+var_18]
.text$mn:00007DF2                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00007DF7                 mov     edx, [ebp+var_18]
.text$mn:00007DFA                 mov     ecx, [edx+18h]
.text$mn:00007DFD                 shr     ecx, 1
.text$mn:00007DFF                 sub     eax, ecx
.text$mn:00007E01                 mov     edx, [ebp+var_18]
.text$mn:00007E04                 cmp     [edx+18h], eax
.text$mn:00007E07                 ja      short loc_7E1C
.text$mn:00007E09                 mov     eax, [ebp+var_18]
.text$mn:00007E0C                 mov     ecx, [eax+18h]
.text$mn:00007E0F                 shr     ecx, 1
.text$mn:00007E11                 mov     edx, [ebp+var_18]
.text$mn:00007E14                 add     ecx, [edx+18h]
.text$mn:00007E17                 mov     [ebp+var_1C], ecx
.text$mn:00007E1A                 jmp     short loc_7E27
.text$mn:00007E1C ; ---------------------------------------------------------------------------
.text$mn:00007E1C
.text$mn:00007E1C loc_7E1C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00007E1C                 mov     ecx, [ebp+var_18]
.text$mn:00007E1F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00007E24                 mov     [ebp+var_1C], eax
.text$mn:00007E27
.text$mn:00007E27 loc_7E27:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00007E27                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00007E27                 mov     [ebp+var_4], 0
.text$mn:00007E2E                 mov     eax, [ebp+var_1C]
.text$mn:00007E31                 add     eax, 1
.text$mn:00007E34                 push    eax
.text$mn:00007E35                 lea     ecx, [ebp+var_11]
.text$mn:00007E38                 push    ecx
.text$mn:00007E39                 mov     ecx, [ebp+var_18]
.text$mn:00007E3C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00007E41                 mov     ecx, eax
.text$mn:00007E43                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00007E48                 mov     [ebp+var_20], eax
.text$mn:00007E4B                 jmp     short loc_7EAA
.text$mn:00007E4B ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00007E4B
.text$mn:00007E4D
.text$mn:00007E4D ; =============== S U B R O U T I N E =======================================
.text$mn:00007E4D
.text$mn:00007E4D
.text$mn:00007E4D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00007E4D                                         ; DATA XREF: .xdata$x:0000B624o
.text$mn:00007E4D
.text$mn:00007E4D ; FUNCTION CHUNK AT .text$mn:00007E94 SIZE 00000009 BYTES
.text$mn:00007E4D ; FUNCTION CHUNK AT .text$mn:00007EA4 SIZE 00000006 BYTES
.text$mn:00007E4D
.text$mn:00007E4D                 mov     [ebp-10h], esp
.text$mn:00007E50                 mov     edx, [ebp+8]
.text$mn:00007E53                 mov     [ebp-1Ch], edx
.text$mn:00007E56                 mov     byte ptr [ebp-4], 2
.text$mn:00007E5A                 mov     eax, [ebp-1Ch]
.text$mn:00007E5D                 add     eax, 1
.text$mn:00007E60                 push    eax
.text$mn:00007E61                 lea     ecx, [ebp-12h]
.text$mn:00007E64                 push    ecx
.text$mn:00007E65                 mov     ecx, [ebp-18h]
.text$mn:00007E68                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00007E6D                 mov     ecx, eax
.text$mn:00007E6F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00007E74                 mov     [ebp-20h], eax
.text$mn:00007E77                 jmp     short loc_7E94
.text$mn:00007E77 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00007E77
.text$mn:00007E79
.text$mn:00007E79 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E79
.text$mn:00007E79 ; Attributes: noreturn
.text$mn:00007E79
.text$mn:00007E79 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00007E79                                         ; DATA XREF: .xdata$x:0000B634o
.text$mn:00007E79                 push    0               ; Size
.text$mn:00007E7B                 push    1               ; char
.text$mn:00007E7D                 mov     ecx, [ebp-18h]
.text$mn:00007E80                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00007E85                 push    0
.text$mn:00007E87                 push    0
.text$mn:00007E89                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00007E89 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00007E89
.text$mn:00007E8E ; ---------------------------------------------------------------------------
.text$mn:00007E8E                 mov     eax, offset $LN17
.text$mn:00007E93                 retn
.text$mn:00007E94 ; ---------------------------------------------------------------------------
.text$mn:00007E94 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00007E94
.text$mn:00007E94 loc_7E94:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00007E94                 mov     dword ptr [ebp-4], 1
.text$mn:00007E9B                 jmp     short loc_7EA4
.text$mn:00007E9B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00007E9D
.text$mn:00007E9D ; =============== S U B R O U T I N E =======================================
.text$mn:00007E9D
.text$mn:00007E9D
.text$mn:00007E9D $LN17           proc near               ; DATA XREF: .text$mn:00007E8Eo
.text$mn:00007E9D                 mov     dword ptr [ebp-4], 1
.text$mn:00007E9D $LN17           endp ; sp-analysis failed
.text$mn:00007E9D
.text$mn:00007EA4 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00007EA4
.text$mn:00007EA4 loc_7EA4:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00007EA4                 mov     eax, offset $LN19
.text$mn:00007EA9                 retn
.text$mn:00007EA9 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00007EAA ; ---------------------------------------------------------------------------
.text$mn:00007EAA ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00007EAA
.text$mn:00007EAA loc_7EAA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00007EAA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007EB1                 jmp     short loc_7EBA
.text$mn:00007EB1 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00007EB3
.text$mn:00007EB3 ; =============== S U B R O U T I N E =======================================
.text$mn:00007EB3
.text$mn:00007EB3
.text$mn:00007EB3 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_7EA4o
.text$mn:00007EB3                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00007EBA
.text$mn:00007EBA loc_7EBA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00007EBA                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00007EBE                 jbe     short loc_7ED9
.text$mn:00007EC0                 mov     edx, [ebp+0Ch]
.text$mn:00007EC3                 push    edx             ; Size
.text$mn:00007EC4                 mov     ecx, [ebp-18h]
.text$mn:00007EC7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007ECC                 push    eax             ; Src
.text$mn:00007ECD                 mov     eax, [ebp-20h]
.text$mn:00007ED0                 push    eax             ; Dst
.text$mn:00007ED1                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00007ED6                 add     esp, 0Ch
.text$mn:00007ED9
.text$mn:00007ED9 loc_7ED9:                               ; CODE XREF: $LN19+Bj
.text$mn:00007ED9                 push    0               ; Size
.text$mn:00007EDB                 push    1               ; char
.text$mn:00007EDD                 mov     ecx, [ebp-18h]
.text$mn:00007EE0                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00007EE5                 lea     ecx, [ebp-20h]
.text$mn:00007EE8                 push    ecx             ; int
.text$mn:00007EE9                 mov     edx, [ebp-18h]
.text$mn:00007EEC                 add     edx, 4
.text$mn:00007EEF                 push    edx             ; void *
.text$mn:00007EF0                 lea     eax, [ebp-13h]
.text$mn:00007EF3                 push    eax
.text$mn:00007EF4                 mov     ecx, [ebp-18h]
.text$mn:00007EF7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00007EFC                 mov     ecx, eax
.text$mn:00007EFE                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00007F03                 mov     ecx, [ebp-18h]
.text$mn:00007F06                 mov     edx, [ebp-1Ch]
.text$mn:00007F09                 mov     [ecx+18h], edx
.text$mn:00007F0C                 mov     eax, [ebp+0Ch]
.text$mn:00007F0F                 push    eax
.text$mn:00007F10                 mov     ecx, [ebp-18h]
.text$mn:00007F13                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007F18                 mov     ecx, [ebp-0Ch]
.text$mn:00007F1B                 mov     large fs:0, ecx
.text$mn:00007F22                 pop     ecx
.text$mn:00007F23                 pop     edi
.text$mn:00007F24                 pop     esi
.text$mn:00007F25                 pop     ebx
.text$mn:00007F26                 mov     esp, ebp
.text$mn:00007F28                 pop     ebp
.text$mn:00007F29                 retn    8
.text$mn:00007F29 $LN19           endp ; sp-analysis failed
.text$mn:00007F29
.text$mn:00007F29 _text$mn        ends
.text$mn:00007F29
.text$x:00007F2C ; ===========================================================================
.text$x:00007F2C
.text$x:00007F2C ; Segment type: Pure code
.text$x:00007F2C ; Segment permissions: Read/Execute
.text$x:00007F2C _text$x         segment para public 'CODE' use32
.text$x:00007F2C                 assume cs:_text$x
.text$x:00007F2C                 ;org 7F2Ch
.text$x:00007F2C ; COMDAT (pick associative to section at 7D88)
.text$x:00007F2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00007F2C
.text$x:00007F2C ; =============== S U B R O U T I N E =======================================
.text$x:00007F2C
.text$x:00007F2C
.text$x:00007F2C __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00007F2C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00007F2C
.text$x:00007F2C arg_4           = dword ptr  8
.text$x:00007F2C
.text$x:00007F2C                 mov     edx, [esp+arg_4]
.text$x:00007F30                 lea     eax, [edx+0Ch]
.text$x:00007F33                 mov     ecx, [edx-24h]
.text$x:00007F36                 xor     ecx, eax
.text$x:00007F38                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007F3D                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00007F42                 jmp     ___CxxFrameHandler3
.text$x:00007F42 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00007F42
.text$x:00007F42 ; ---------------------------------------------------------------------------
.text$x:00007F47                 align 4
.text$x:00007F47 _text$x         ends
.text$x:00007F47
.text$mn:00007F48 ; ===========================================================================
.text$mn:00007F48
.text$mn:00007F48 ; Segment type: Pure code
.text$mn:00007F48 ; Segment permissions: Read/Execute
.text$mn:00007F48 _text$mn        segment para public 'CODE' use32
.text$mn:00007F48                 assume cs:_text$mn
.text$mn:00007F48                 ;org 7F48h
.text$mn:00007F48 ; COMDAT (pick any)
.text$mn:00007F48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00007F48
.text$mn:00007F48 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F48
.text$mn:00007F48 ; Attributes: bp-based frame
.text$mn:00007F48
.text$mn:00007F48 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:00007F48                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00007F48 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:00007F48                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:00007F48
.text$mn:00007F48 var_20          = dword ptr -20h
.text$mn:00007F48 var_1C          = dword ptr -1Ch
.text$mn:00007F48 var_18          = dword ptr -18h
.text$mn:00007F48 var_11          = byte ptr -11h
.text$mn:00007F48 var_10          = dword ptr -10h
.text$mn:00007F48 var_C           = byte ptr -0Ch
.text$mn:00007F48 var_4           = dword ptr -4
.text$mn:00007F48 arg_0           = dword ptr  8
.text$mn:00007F48
.text$mn:00007F48 ; FUNCTION CHUNK AT .text$mn:0000806A SIZE 00000009 BYTES
.text$mn:00007F48
.text$mn:00007F48                 push    ebp
.text$mn:00007F49                 mov     ebp, esp
.text$mn:00007F4B                 push    0FFFFFFFFh
.text$mn:00007F4D                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00007F52                 mov     eax, large fs:0
.text$mn:00007F58                 push    eax
.text$mn:00007F59                 push    ecx
.text$mn:00007F5A                 sub     esp, 10h
.text$mn:00007F5D                 push    ebx
.text$mn:00007F5E                 push    esi
.text$mn:00007F5F                 push    edi
.text$mn:00007F60                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007F65                 xor     eax, ebp
.text$mn:00007F67                 push    eax
.text$mn:00007F68                 lea     eax, [ebp+var_C]
.text$mn:00007F6B                 mov     large fs:0, eax
.text$mn:00007F71                 mov     [ebp+var_10], esp
.text$mn:00007F74                 mov     [ebp+var_18], ecx
.text$mn:00007F77                 mov     eax, [ebp+arg_0]
.text$mn:00007F7A                 or      eax, 7
.text$mn:00007F7D                 mov     [ebp+var_1C], eax
.text$mn:00007F80                 mov     ecx, [ebp+var_18]
.text$mn:00007F83                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00007F88                 cmp     eax, [ebp+var_1C]
.text$mn:00007F8B                 jnb     short loc_7F95
.text$mn:00007F8D                 mov     ecx, [ebp+arg_0]
.text$mn:00007F90                 mov     [ebp+var_1C], ecx
.text$mn:00007F93                 jmp     short loc_7FE7
.text$mn:00007F95 ; ---------------------------------------------------------------------------
.text$mn:00007F95
.text$mn:00007F95 loc_7F95:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:00007F95                 mov     edx, [ebp+var_18]
.text$mn:00007F98                 mov     ecx, [edx+18h]
.text$mn:00007F9B                 shr     ecx, 1
.text$mn:00007F9D                 mov     eax, [ebp+var_1C]
.text$mn:00007FA0                 xor     edx, edx
.text$mn:00007FA2                 mov     esi, 3
.text$mn:00007FA7                 div     esi
.text$mn:00007FA9                 cmp     ecx, eax
.text$mn:00007FAB                 ja      short loc_7FAF
.text$mn:00007FAD                 jmp     short loc_7FE7
.text$mn:00007FAF ; ---------------------------------------------------------------------------
.text$mn:00007FAF
.text$mn:00007FAF loc_7FAF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:00007FAF                 mov     ecx, [ebp+var_18]
.text$mn:00007FB2                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00007FB7                 mov     edx, [ebp+var_18]
.text$mn:00007FBA                 mov     ecx, [edx+18h]
.text$mn:00007FBD                 shr     ecx, 1
.text$mn:00007FBF                 sub     eax, ecx
.text$mn:00007FC1                 mov     edx, [ebp+var_18]
.text$mn:00007FC4                 cmp     [edx+18h], eax
.text$mn:00007FC7                 ja      short loc_7FDC
.text$mn:00007FC9                 mov     eax, [ebp+var_18]
.text$mn:00007FCC                 mov     ecx, [eax+18h]
.text$mn:00007FCF                 shr     ecx, 1
.text$mn:00007FD1                 mov     edx, [ebp+var_18]
.text$mn:00007FD4                 add     ecx, [edx+18h]
.text$mn:00007FD7                 mov     [ebp+var_1C], ecx
.text$mn:00007FDA                 jmp     short loc_7FE7
.text$mn:00007FDC ; ---------------------------------------------------------------------------
.text$mn:00007FDC
.text$mn:00007FDC loc_7FDC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:00007FDC                 mov     ecx, [ebp+var_18]
.text$mn:00007FDF                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00007FE4                 mov     [ebp+var_1C], eax
.text$mn:00007FE7
.text$mn:00007FE7 loc_7FE7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:00007FE7                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:00007FE7                 mov     [ebp+var_4], 0
.text$mn:00007FEE                 mov     eax, [ebp+var_1C]
.text$mn:00007FF1                 add     eax, 1
.text$mn:00007FF4                 push    eax
.text$mn:00007FF5                 lea     ecx, [ebp+var_11]
.text$mn:00007FF8                 push    ecx
.text$mn:00007FF9                 mov     ecx, [ebp+var_18]
.text$mn:00007FFC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00008001                 mov     ecx, eax
.text$mn:00008003                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00008008                 mov     [ebp+var_20], eax
.text$mn:0000800B                 jmp     short loc_806A
.text$mn:0000800B ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:0000800B
.text$mn:0000800D
.text$mn:0000800D ; =============== S U B R O U T I N E =======================================
.text$mn:0000800D
.text$mn:0000800D
.text$mn:0000800D __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:0000800D                                         ; DATA XREF: .xdata$x:0000B99Co
.text$mn:0000800D
.text$mn:0000800D ; FUNCTION CHUNK AT .text$mn:00008054 SIZE 00000009 BYTES
.text$mn:0000800D ; FUNCTION CHUNK AT .text$mn:00008064 SIZE 00000006 BYTES
.text$mn:0000800D
.text$mn:0000800D                 mov     [ebp-10h], esp
.text$mn:00008010                 mov     edx, [ebp+8]
.text$mn:00008013                 mov     [ebp-1Ch], edx
.text$mn:00008016                 mov     byte ptr [ebp-4], 2
.text$mn:0000801A                 mov     eax, [ebp-1Ch]
.text$mn:0000801D                 add     eax, 1
.text$mn:00008020                 push    eax
.text$mn:00008021                 lea     ecx, [ebp-12h]
.text$mn:00008024                 push    ecx
.text$mn:00008025                 mov     ecx, [ebp-18h]
.text$mn:00008028                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000802D                 mov     ecx, eax
.text$mn:0000802F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00008034                 mov     [ebp-20h], eax
.text$mn:00008037                 jmp     short loc_8054
.text$mn:00008037 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:00008037
.text$mn:00008039
.text$mn:00008039 ; =============== S U B R O U T I N E =======================================
.text$mn:00008039
.text$mn:00008039 ; Attributes: noreturn
.text$mn:00008039
.text$mn:00008039 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:00008039                                         ; DATA XREF: .xdata$x:0000B9ACo
.text$mn:00008039                 push    0
.text$mn:0000803B                 push    1
.text$mn:0000803D                 mov     ecx, [ebp-18h]
.text$mn:00008040                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00008045                 push    0
.text$mn:00008047                 push    0
.text$mn:00008049                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00008049 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:00008049
.text$mn:0000804E ; ---------------------------------------------------------------------------
.text$mn:0000804E                 mov     eax, offset $LN17_0
.text$mn:00008053                 retn
.text$mn:00008054 ; ---------------------------------------------------------------------------
.text$mn:00008054 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00008054
.text$mn:00008054 loc_8054:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00008054                 mov     dword ptr [ebp-4], 1
.text$mn:0000805B                 jmp     short loc_8064
.text$mn:0000805B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000805D
.text$mn:0000805D ; =============== S U B R O U T I N E =======================================
.text$mn:0000805D
.text$mn:0000805D
.text$mn:0000805D $LN17_0         proc near               ; DATA XREF: .text$mn:0000804Eo
.text$mn:0000805D                 mov     dword ptr [ebp-4], 1
.text$mn:0000805D $LN17_0         endp ; sp-analysis failed
.text$mn:0000805D
.text$mn:00008064 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00008064
.text$mn:00008064 loc_8064:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00008064                 mov     eax, offset $LN19_0
.text$mn:00008069                 retn
.text$mn:00008069 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:0000806A ; ---------------------------------------------------------------------------
.text$mn:0000806A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000806A
.text$mn:0000806A loc_806A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:0000806A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008071                 jmp     short loc_807A
.text$mn:00008071 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00008073
.text$mn:00008073 ; =============== S U B R O U T I N E =======================================
.text$mn:00008073
.text$mn:00008073
.text$mn:00008073 $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_8064o
.text$mn:00008073                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000807A
.text$mn:0000807A loc_807A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:0000807A                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000807E                 jbe     short loc_8099
.text$mn:00008080                 mov     edx, [ebp+0Ch]
.text$mn:00008083                 push    edx             ; int
.text$mn:00008084                 mov     ecx, [ebp-18h]
.text$mn:00008087                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000808C                 push    eax             ; Src
.text$mn:0000808D                 mov     eax, [ebp-20h]
.text$mn:00008090                 push    eax             ; Dst
.text$mn:00008091                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00008096                 add     esp, 0Ch
.text$mn:00008099
.text$mn:00008099 loc_8099:                               ; CODE XREF: $LN19_0+Bj
.text$mn:00008099                 push    0
.text$mn:0000809B                 push    1
.text$mn:0000809D                 mov     ecx, [ebp-18h]
.text$mn:000080A0                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000080A5                 lea     ecx, [ebp-20h]
.text$mn:000080A8                 push    ecx             ; int
.text$mn:000080A9                 mov     edx, [ebp-18h]
.text$mn:000080AC                 add     edx, 4
.text$mn:000080AF                 push    edx             ; void *
.text$mn:000080B0                 lea     eax, [ebp-13h]
.text$mn:000080B3                 push    eax
.text$mn:000080B4                 mov     ecx, [ebp-18h]
.text$mn:000080B7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000080BC                 mov     ecx, eax
.text$mn:000080BE                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:000080C3                 mov     ecx, [ebp-18h]
.text$mn:000080C6                 mov     edx, [ebp-1Ch]
.text$mn:000080C9                 mov     [ecx+18h], edx
.text$mn:000080CC                 mov     eax, [ebp+0Ch]
.text$mn:000080CF                 push    eax
.text$mn:000080D0                 mov     ecx, [ebp-18h]
.text$mn:000080D3                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000080D8                 mov     ecx, [ebp-0Ch]
.text$mn:000080DB                 mov     large fs:0, ecx
.text$mn:000080E2                 pop     ecx
.text$mn:000080E3                 pop     edi
.text$mn:000080E4                 pop     esi
.text$mn:000080E5                 pop     ebx
.text$mn:000080E6                 mov     esp, ebp
.text$mn:000080E8                 pop     ebp
.text$mn:000080E9                 retn    8
.text$mn:000080E9 $LN19_0         endp ; sp-analysis failed
.text$mn:000080E9
.text$mn:000080E9 _text$mn        ends
.text$mn:000080E9
.text$x:000080EC ; ===========================================================================
.text$x:000080EC
.text$x:000080EC ; Segment type: Pure code
.text$x:000080EC ; Segment permissions: Read/Execute
.text$x:000080EC _text$x         segment para public 'CODE' use32
.text$x:000080EC                 assume cs:_text$x
.text$x:000080EC                 ;org 80ECh
.text$x:000080EC ; COMDAT (pick associative to section at 7F48)
.text$x:000080EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000080EC
.text$x:000080EC ; =============== S U B R O U T I N E =======================================
.text$x:000080EC
.text$x:000080EC
.text$x:000080EC __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:000080EC                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:000080EC
.text$x:000080EC arg_4           = dword ptr  8
.text$x:000080EC
.text$x:000080EC                 mov     edx, [esp+arg_4]
.text$x:000080F0                 lea     eax, [edx+0Ch]
.text$x:000080F3                 mov     ecx, [edx-24h]
.text$x:000080F6                 xor     ecx, eax
.text$x:000080F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000080FD                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:00008102                 jmp     ___CxxFrameHandler3
.text$x:00008102 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:00008102
.text$x:00008102 ; ---------------------------------------------------------------------------
.text$x:00008107                 align 4
.text$x:00008107 _text$x         ends
.text$x:00008107
.text$mn:00008108 ; ===========================================================================
.text$mn:00008108
.text$mn:00008108 ; Segment type: Pure code
.text$mn:00008108 ; Segment permissions: Read/Execute
.text$mn:00008108 _text$mn        segment para public 'CODE' use32
.text$mn:00008108                 assume cs:_text$mn
.text$mn:00008108                 ;org 8108h
.text$mn:00008108 ; COMDAT (pick any)
.text$mn:00008108                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008108
.text$mn:00008108 ; =============== S U B R O U T I N E =======================================
.text$mn:00008108
.text$mn:00008108 ; Attributes: bp-based frame
.text$mn:00008108
.text$mn:00008108 ; protected: void __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Destroy(struct MenuItemUnit *, struct MenuItemUnit *)
.text$mn:00008108                 public ?_Destroy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXPAUMenuItemUnit@@0@Z
.text$mn:00008108 ?_Destroy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXPAUMenuItemUnit@@0@Z proc near
.text$mn:00008108                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+CBp
.text$mn:00008108                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Tidy(void)+2Bp
.text$mn:00008108
.text$mn:00008108 var_8           = dword ptr -8
.text$mn:00008108 var_1           = byte ptr -1
.text$mn:00008108 arg_0           = dword ptr  8
.text$mn:00008108 arg_4           = dword ptr  0Ch
.text$mn:00008108
.text$mn:00008108                 push    ebp
.text$mn:00008109                 mov     ebp, esp
.text$mn:0000810B                 sub     esp, 8
.text$mn:0000810E                 mov     [ebp+var_8], ecx
.text$mn:00008111                 lea     eax, [ebp+var_1]
.text$mn:00008114                 push    eax
.text$mn:00008115                 mov     ecx, [ebp+var_8]
.text$mn:00008118                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:0000811D                 lea     ecx, [ebp+var_1]
.text$mn:00008120                 push    ecx
.text$mn:00008121                 mov     edx, [ebp+arg_4]
.text$mn:00008124                 push    edx
.text$mn:00008125                 mov     eax, [ebp+arg_0]
.text$mn:00008128                 push    eax
.text$mn:00008129                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@YAXPAUMenuItemUnit@@0AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<MenuItemUnit>>>(MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &)
.text$mn:0000812E                 add     esp, 0Ch
.text$mn:00008131                 mov     esp, ebp
.text$mn:00008133                 pop     ebp
.text$mn:00008134                 retn    8
.text$mn:00008134 ?_Destroy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXPAUMenuItemUnit@@0@Z endp
.text$mn:00008134
.text$mn:00008134 ; ---------------------------------------------------------------------------
.text$mn:00008137                 align 4
.text$mn:00008137 _text$mn        ends
.text$mn:00008137
.text$mn:00008138 ; ===========================================================================
.text$mn:00008138
.text$mn:00008138 ; Segment type: Pure code
.text$mn:00008138 ; Segment permissions: Read/Execute
.text$mn:00008138 _text$mn        segment para public 'CODE' use32
.text$mn:00008138                 assume cs:_text$mn
.text$mn:00008138                 ;org 8138h
.text$mn:00008138 ; COMDAT (pick any)
.text$mn:00008138                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008138
.text$mn:00008138 ; =============== S U B R O U T I N E =======================================
.text$mn:00008138
.text$mn:00008138 ; Attributes: bp-based frame
.text$mn:00008138
.text$mn:00008138 ; protected: void __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Destroy(struct recordedMacroStep *, struct recordedMacroStep *)
.text$mn:00008138                 public ?_Destroy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXPAUrecordedMacroStep@@0@Z
.text$mn:00008138 ?_Destroy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXPAUrecordedMacroStep@@0@Z proc near
.text$mn:00008138                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reallocate(uint)+CBp
.text$mn:00008138
.text$mn:00008138 var_8           = dword ptr -8
.text$mn:00008138 var_1           = byte ptr -1
.text$mn:00008138 arg_0           = dword ptr  8
.text$mn:00008138 arg_4           = dword ptr  0Ch
.text$mn:00008138
.text$mn:00008138                 push    ebp
.text$mn:00008139                 mov     ebp, esp
.text$mn:0000813B                 sub     esp, 8
.text$mn:0000813E                 mov     [ebp+var_8], ecx
.text$mn:00008141                 lea     eax, [ebp+var_1]
.text$mn:00008144                 push    eax
.text$mn:00008145                 mov     ecx, [ebp+var_8]
.text$mn:00008148                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:0000814D                 lea     ecx, [ebp+var_1]
.text$mn:00008150                 push    ecx
.text$mn:00008151                 mov     edx, [ebp+arg_4]
.text$mn:00008154                 push    edx
.text$mn:00008155                 mov     eax, [ebp+arg_0]
.text$mn:00008158                 push    eax
.text$mn:00008159                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@YAXPAUrecordedMacroStep@@0AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<recordedMacroStep>>>(recordedMacroStep *,recordedMacroStep *,std::_Wrap_alloc<std::allocator<recordedMacroStep>> &)
.text$mn:0000815E                 add     esp, 0Ch
.text$mn:00008161                 mov     esp, ebp
.text$mn:00008163                 pop     ebp
.text$mn:00008164                 retn    8
.text$mn:00008164 ?_Destroy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXPAUrecordedMacroStep@@0@Z endp
.text$mn:00008164
.text$mn:00008164 ; ---------------------------------------------------------------------------
.text$mn:00008167                 align 4
.text$mn:00008167 _text$mn        ends
.text$mn:00008167
.text$mn:00008168 ; ===========================================================================
.text$mn:00008168
.text$mn:00008168 ; Segment type: Pure code
.text$mn:00008168 ; Segment permissions: Read/Execute
.text$mn:00008168 _text$mn        segment para public 'CODE' use32
.text$mn:00008168                 assume cs:_text$mn
.text$mn:00008168                 ;org 8168h
.text$mn:00008168 ; COMDAT (pick any)
.text$mn:00008168                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008168
.text$mn:00008168 ; =============== S U B R O U T I N E =======================================
.text$mn:00008168
.text$mn:00008168 ; Attributes: bp-based frame
.text$mn:00008168
.text$mn:00008168 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00008168                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00008168 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00008168                                         ; CODE XREF: $LN19+60p
.text$mn:00008168                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00008168
.text$mn:00008168 var_8           = dword ptr -8
.text$mn:00008168 var_1           = byte ptr -1
.text$mn:00008168 arg_0           = dword ptr  8
.text$mn:00008168
.text$mn:00008168                 push    ebp
.text$mn:00008169                 mov     ebp, esp
.text$mn:0000816B                 sub     esp, 8
.text$mn:0000816E                 mov     [ebp+var_8], ecx
.text$mn:00008171                 mov     [ebp+var_1], 0
.text$mn:00008175                 mov     eax, [ebp+var_8]
.text$mn:00008178                 mov     ecx, [ebp+arg_0]
.text$mn:0000817B                 mov     [eax+14h], ecx
.text$mn:0000817E                 lea     edx, [ebp+var_1]
.text$mn:00008181                 push    edx
.text$mn:00008182                 mov     ecx, [ebp+var_8]
.text$mn:00008185                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000818A                 add     eax, [ebp+arg_0]
.text$mn:0000818D                 push    eax
.text$mn:0000818E                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00008193                 add     esp, 8
.text$mn:00008196                 mov     esp, ebp
.text$mn:00008198                 pop     ebp
.text$mn:00008199                 retn    4
.text$mn:00008199 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00008199
.text$mn:00008199 _text$mn        ends
.text$mn:00008199
.text$mn:0000819C ; ===========================================================================
.text$mn:0000819C
.text$mn:0000819C ; Segment type: Pure code
.text$mn:0000819C ; Segment permissions: Read/Execute
.text$mn:0000819C _text$mn        segment para public 'CODE' use32
.text$mn:0000819C                 assume cs:_text$mn
.text$mn:0000819C                 ;org 819Ch
.text$mn:0000819C ; COMDAT (pick any)
.text$mn:0000819C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000819C
.text$mn:0000819C ; =============== S U B R O U T I N E =======================================
.text$mn:0000819C
.text$mn:0000819C ; Attributes: bp-based frame
.text$mn:0000819C
.text$mn:0000819C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:0000819C                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:0000819C ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:0000819C                                         ; CODE XREF: $LN19_0+60p
.text$mn:0000819C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:0000819C
.text$mn:0000819C var_8           = dword ptr -8
.text$mn:0000819C var_2           = word ptr -2
.text$mn:0000819C arg_0           = dword ptr  8
.text$mn:0000819C
.text$mn:0000819C                 push    ebp
.text$mn:0000819D                 mov     ebp, esp
.text$mn:0000819F                 sub     esp, 8
.text$mn:000081A2                 mov     [ebp+var_8], ecx
.text$mn:000081A5                 xor     eax, eax
.text$mn:000081A7                 mov     [ebp+var_2], ax
.text$mn:000081AB                 mov     ecx, [ebp+var_8]
.text$mn:000081AE                 mov     edx, [ebp+arg_0]
.text$mn:000081B1                 mov     [ecx+14h], edx
.text$mn:000081B4                 lea     eax, [ebp+var_2]
.text$mn:000081B7                 push    eax
.text$mn:000081B8                 mov     ecx, [ebp+var_8]
.text$mn:000081BB                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000081C0                 mov     ecx, [ebp+arg_0]
.text$mn:000081C3                 lea     edx, [eax+ecx*2]
.text$mn:000081C6                 push    edx
.text$mn:000081C7                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:000081CC                 add     esp, 8
.text$mn:000081CF                 mov     esp, ebp
.text$mn:000081D1                 pop     ebp
.text$mn:000081D2                 retn    4
.text$mn:000081D2 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:000081D2
.text$mn:000081D2 ; ---------------------------------------------------------------------------
.text$mn:000081D5                 align 4
.text$mn:000081D5 _text$mn        ends
.text$mn:000081D5
.text$mn:000081D8 ; ===========================================================================
.text$mn:000081D8
.text$mn:000081D8 ; Segment type: Pure code
.text$mn:000081D8 ; Segment permissions: Read/Execute
.text$mn:000081D8 _text$mn        segment para public 'CODE' use32
.text$mn:000081D8                 assume cs:_text$mn
.text$mn:000081D8                 ;org 81D8h
.text$mn:000081D8 ; COMDAT (pick any)
.text$mn:000081D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000081D8
.text$mn:000081D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000081D8
.text$mn:000081D8 ; Attributes: bp-based frame
.text$mn:000081D8
.text$mn:000081D8 ; public: void __thiscall std::_Deque_alloc<0, struct std::_Deque_base_types<unsigned int, class std::allocator<unsigned int>>>::_Free_proxy(void)
.text$mn:000081D8                 public ?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ
.text$mn:000081D8 ?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000081D8                                         ; CODE XREF: std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::~_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>(void)+30p
.text$mn:000081D8
.text$mn:000081D8 var_8           = dword ptr -8
.text$mn:000081D8 var_1           = byte ptr -1
.text$mn:000081D8
.text$mn:000081D8                 push    ebp
.text$mn:000081D9                 mov     ebp, esp
.text$mn:000081DB                 sub     esp, 8
.text$mn:000081DE                 mov     [ebp+var_8], ecx
.text$mn:000081E1                 lea     ecx, [ebp+var_1]
.text$mn:000081E4                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000081E9                 mov     ecx, [ebp+var_8] ; this
.text$mn:000081EC                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000081F1                 mov     eax, [ebp+var_8]
.text$mn:000081F4                 mov     ecx, [eax]
.text$mn:000081F6                 push    ecx
.text$mn:000081F7                 lea     ecx, [ebp+var_1]
.text$mn:000081FA                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000081FF                 push    1               ; int
.text$mn:00008201                 mov     edx, [ebp+var_8]
.text$mn:00008204                 mov     eax, [edx]
.text$mn:00008206                 push    eax             ; void *
.text$mn:00008207                 lea     ecx, [ebp+var_1]
.text$mn:0000820A                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000820F                 mov     ecx, [ebp+var_8]
.text$mn:00008212                 mov     dword ptr [ecx], 0
.text$mn:00008218                 mov     esp, ebp
.text$mn:0000821A                 pop     ebp
.text$mn:0000821B                 retn
.text$mn:0000821B ?_Free_proxy@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000821B
.text$mn:0000821B _text$mn        ends
.text$mn:0000821B
.text$mn:0000821C ; ===========================================================================
.text$mn:0000821C
.text$mn:0000821C ; Segment type: Pure code
.text$mn:0000821C ; Segment permissions: Read/Execute
.text$mn:0000821C _text$mn        segment para public 'CODE' use32
.text$mn:0000821C                 assume cs:_text$mn
.text$mn:0000821C                 ;org 821Ch
.text$mn:0000821C ; COMDAT (pick any)
.text$mn:0000821C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000821C
.text$mn:0000821C ; =============== S U B R O U T I N E =======================================
.text$mn:0000821C
.text$mn:0000821C ; Attributes: bp-based frame
.text$mn:0000821C
.text$mn:0000821C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:0000821C                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:0000821C ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000821C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:0000821C
.text$mn:0000821C var_8           = dword ptr -8
.text$mn:0000821C var_1           = byte ptr -1
.text$mn:0000821C
.text$mn:0000821C                 push    ebp
.text$mn:0000821D                 mov     ebp, esp
.text$mn:0000821F                 sub     esp, 8
.text$mn:00008222                 mov     [ebp+var_8], ecx
.text$mn:00008225                 lea     ecx, [ebp+var_1]
.text$mn:00008228                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000822D                 mov     ecx, [ebp+var_8] ; this
.text$mn:00008230                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00008235                 mov     eax, [ebp+var_8]
.text$mn:00008238                 mov     ecx, [eax]
.text$mn:0000823A                 push    ecx
.text$mn:0000823B                 lea     ecx, [ebp+var_1]
.text$mn:0000823E                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00008243                 push    1               ; int
.text$mn:00008245                 mov     edx, [ebp+var_8]
.text$mn:00008248                 mov     eax, [edx]
.text$mn:0000824A                 push    eax             ; void *
.text$mn:0000824B                 lea     ecx, [ebp+var_1]
.text$mn:0000824E                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00008253                 mov     ecx, [ebp+var_8]
.text$mn:00008256                 mov     dword ptr [ecx], 0
.text$mn:0000825C                 mov     esp, ebp
.text$mn:0000825E                 pop     ebp
.text$mn:0000825F                 retn
.text$mn:0000825F ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000825F
.text$mn:0000825F _text$mn        ends
.text$mn:0000825F
.text$mn:00008260 ; ===========================================================================
.text$mn:00008260
.text$mn:00008260 ; Segment type: Pure code
.text$mn:00008260 ; Segment permissions: Read/Execute
.text$mn:00008260 _text$mn        segment para public 'CODE' use32
.text$mn:00008260                 assume cs:_text$mn
.text$mn:00008260                 ;org 8260h
.text$mn:00008260 ; COMDAT (pick any)
.text$mn:00008260                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008260
.text$mn:00008260 ; =============== S U B R O U T I N E =======================================
.text$mn:00008260
.text$mn:00008260 ; Attributes: bp-based frame
.text$mn:00008260
.text$mn:00008260 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00008260                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00008260 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00008260                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00008260
.text$mn:00008260 var_8           = dword ptr -8
.text$mn:00008260 var_1           = byte ptr -1
.text$mn:00008260
.text$mn:00008260                 push    ebp
.text$mn:00008261                 mov     ebp, esp
.text$mn:00008263                 sub     esp, 8
.text$mn:00008266                 mov     [ebp+var_8], ecx
.text$mn:00008269                 lea     ecx, [ebp+var_1]
.text$mn:0000826C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00008271                 mov     ecx, [ebp+var_8] ; this
.text$mn:00008274                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00008279                 mov     eax, [ebp+var_8]
.text$mn:0000827C                 mov     ecx, [eax]
.text$mn:0000827E                 push    ecx
.text$mn:0000827F                 lea     ecx, [ebp+var_1]
.text$mn:00008282                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00008287                 push    1               ; int
.text$mn:00008289                 mov     edx, [ebp+var_8]
.text$mn:0000828C                 mov     eax, [edx]
.text$mn:0000828E                 push    eax             ; void *
.text$mn:0000828F                 lea     ecx, [ebp+var_1]
.text$mn:00008292                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00008297                 mov     ecx, [ebp+var_8]
.text$mn:0000829A                 mov     dword ptr [ecx], 0
.text$mn:000082A0                 mov     esp, ebp
.text$mn:000082A2                 pop     ebp
.text$mn:000082A3                 retn
.text$mn:000082A3 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:000082A3
.text$mn:000082A3 _text$mn        ends
.text$mn:000082A3
.text$mn:000082A4 ; ===========================================================================
.text$mn:000082A4
.text$mn:000082A4 ; Segment type: Pure code
.text$mn:000082A4 ; Segment permissions: Read/Execute
.text$mn:000082A4 _text$mn        segment para public 'CODE' use32
.text$mn:000082A4                 assume cs:_text$mn
.text$mn:000082A4                 ;org 82A4h
.text$mn:000082A4 ; COMDAT (pick any)
.text$mn:000082A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000082A4
.text$mn:000082A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000082A4
.text$mn:000082A4 ; Attributes: bp-based frame
.text$mn:000082A4
.text$mn:000082A4 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>>::_Free_proxy(void)
.text$mn:000082A4                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ
.text$mn:000082A4 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000082A4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::~_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>(void)+30p
.text$mn:000082A4
.text$mn:000082A4 var_8           = dword ptr -8
.text$mn:000082A4 var_1           = byte ptr -1
.text$mn:000082A4
.text$mn:000082A4                 push    ebp
.text$mn:000082A5                 mov     ebp, esp
.text$mn:000082A7                 sub     esp, 8
.text$mn:000082AA                 mov     [ebp+var_8], ecx
.text$mn:000082AD                 lea     ecx, [ebp+var_1]
.text$mn:000082B0                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000082B5                 mov     ecx, [ebp+var_8] ; this
.text$mn:000082B8                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000082BD                 mov     eax, [ebp+var_8]
.text$mn:000082C0                 mov     ecx, [eax]
.text$mn:000082C2                 push    ecx
.text$mn:000082C3                 lea     ecx, [ebp+var_1]
.text$mn:000082C6                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000082CB                 push    1               ; int
.text$mn:000082CD                 mov     edx, [ebp+var_8]
.text$mn:000082D0                 mov     eax, [edx]
.text$mn:000082D2                 push    eax             ; void *
.text$mn:000082D3                 lea     ecx, [ebp+var_1]
.text$mn:000082D6                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:000082DB                 mov     ecx, [ebp+var_8]
.text$mn:000082DE                 mov     dword ptr [ecx], 0
.text$mn:000082E4                 mov     esp, ebp
.text$mn:000082E6                 pop     ebp
.text$mn:000082E7                 retn
.text$mn:000082E7 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:000082E7
.text$mn:000082E7 _text$mn        ends
.text$mn:000082E7
.text$mn:000082E8 ; ===========================================================================
.text$mn:000082E8
.text$mn:000082E8 ; Segment type: Pure code
.text$mn:000082E8 ; Segment permissions: Read/Execute
.text$mn:000082E8 _text$mn        segment para public 'CODE' use32
.text$mn:000082E8                 assume cs:_text$mn
.text$mn:000082E8                 ;org 82E8h
.text$mn:000082E8 ; COMDAT (pick any)
.text$mn:000082E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000082E8
.text$mn:000082E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000082E8
.text$mn:000082E8 ; Attributes: bp-based frame
.text$mn:000082E8
.text$mn:000082E8 ; public: struct std::_Wrap_alloc<class std::allocator<unsigned int>> __thiscall std::_Deque_alloc<0, struct std::_Deque_base_types<unsigned int, class std::allocator<unsigned int>>>::_Getal(void)const
.text$mn:000082E8                 public ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ
.text$mn:000082E8 ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ proc near
.text$mn:000082E8                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+10p
.text$mn:000082E8                                         ; std::deque<uint,std::allocator<uint>>::_Tidy(void)+10p ...
.text$mn:000082E8
.text$mn:000082E8 var_4           = dword ptr -4
.text$mn:000082E8 arg_0           = dword ptr  8
.text$mn:000082E8
.text$mn:000082E8                 push    ebp
.text$mn:000082E9                 mov     ebp, esp
.text$mn:000082EB                 push    ecx
.text$mn:000082EC                 mov     [ebp+var_4], ecx
.text$mn:000082EF                 mov     ecx, [ebp+arg_0]
.text$mn:000082F2                 call    ??0?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<uint>>::_Wrap_alloc<std::allocator<uint>>(void)
.text$mn:000082F7                 mov     eax, [ebp+arg_0]
.text$mn:000082FA                 mov     esp, ebp
.text$mn:000082FC                 pop     ebp
.text$mn:000082FD                 retn    4
.text$mn:000082FD ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ endp
.text$mn:000082FD
.text$mn:000082FD _text$mn        ends
.text$mn:000082FD
.text$mn:00008300 ; ===========================================================================
.text$mn:00008300
.text$mn:00008300 ; Segment type: Pure code
.text$mn:00008300 ; Segment permissions: Read/Execute
.text$mn:00008300 _text$mn        segment para public 'CODE' use32
.text$mn:00008300                 assume cs:_text$mn
.text$mn:00008300                 ;org 8300h
.text$mn:00008300 ; COMDAT (pick any)
.text$mn:00008300                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008300
.text$mn:00008300 ; =============== S U B R O U T I N E =======================================
.text$mn:00008300
.text$mn:00008300 ; Attributes: bp-based frame
.text$mn:00008300
.text$mn:00008300 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00008300                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00008300 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00008300                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00008300                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00008300
.text$mn:00008300 var_4           = dword ptr -4
.text$mn:00008300 arg_0           = dword ptr  8
.text$mn:00008300
.text$mn:00008300                 push    ebp
.text$mn:00008301                 mov     ebp, esp
.text$mn:00008303                 push    ecx
.text$mn:00008304                 mov     [ebp+var_4], ecx
.text$mn:00008307                 mov     ecx, [ebp+arg_0]
.text$mn:0000830A                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:0000830F                 mov     eax, [ebp+arg_0]
.text$mn:00008312                 mov     esp, ebp
.text$mn:00008314                 pop     ebp
.text$mn:00008315                 retn    4
.text$mn:00008315 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00008315
.text$mn:00008315 _text$mn        ends
.text$mn:00008315
.text$mn:00008318 ; ===========================================================================
.text$mn:00008318
.text$mn:00008318 ; Segment type: Pure code
.text$mn:00008318 ; Segment permissions: Read/Execute
.text$mn:00008318 _text$mn        segment para public 'CODE' use32
.text$mn:00008318                 assume cs:_text$mn
.text$mn:00008318                 ;org 8318h
.text$mn:00008318 ; COMDAT (pick any)
.text$mn:00008318                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008318
.text$mn:00008318 ; =============== S U B R O U T I N E =======================================
.text$mn:00008318
.text$mn:00008318 ; Attributes: bp-based frame
.text$mn:00008318
.text$mn:00008318 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00008318                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00008318 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00008318                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+33p
.text$mn:00008318                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+B4p ...
.text$mn:00008318
.text$mn:00008318 var_4           = dword ptr -4
.text$mn:00008318 arg_0           = dword ptr  8
.text$mn:00008318
.text$mn:00008318                 push    ebp
.text$mn:00008319                 mov     ebp, esp
.text$mn:0000831B                 push    ecx
.text$mn:0000831C                 mov     [ebp+var_4], ecx
.text$mn:0000831F                 mov     ecx, [ebp+arg_0]
.text$mn:00008322                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:00008327                 mov     eax, [ebp+arg_0]
.text$mn:0000832A                 mov     esp, ebp
.text$mn:0000832C                 pop     ebp
.text$mn:0000832D                 retn    4
.text$mn:0000832D ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:0000832D
.text$mn:0000832D _text$mn        ends
.text$mn:0000832D
.text$mn:00008330 ; ===========================================================================
.text$mn:00008330
.text$mn:00008330 ; Segment type: Pure code
.text$mn:00008330 ; Segment permissions: Read/Execute
.text$mn:00008330 _text$mn        segment para public 'CODE' use32
.text$mn:00008330                 assume cs:_text$mn
.text$mn:00008330                 ;org 8330h
.text$mn:00008330 ; COMDAT (pick any)
.text$mn:00008330                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008330
.text$mn:00008330 ; =============== S U B R O U T I N E =======================================
.text$mn:00008330
.text$mn:00008330 ; Attributes: bp-based frame
.text$mn:00008330
.text$mn:00008330 ; public: struct std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>>::_Getal(void)const
.text$mn:00008330                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ
.text$mn:00008330 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ proc near
.text$mn:00008330                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Umove<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *)+10p
.text$mn:00008330                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Destroy(MenuItemUnit *,MenuItemUnit *)+10p ...
.text$mn:00008330
.text$mn:00008330 var_4           = dword ptr -4
.text$mn:00008330 arg_0           = dword ptr  8
.text$mn:00008330
.text$mn:00008330                 push    ebp
.text$mn:00008331                 mov     ebp, esp
.text$mn:00008333                 push    ecx
.text$mn:00008334                 mov     [ebp+var_4], ecx
.text$mn:00008337                 mov     ecx, [ebp+arg_0]
.text$mn:0000833A                 call    ??0?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::_Wrap_alloc<std::allocator<MenuItemUnit>>(void)
.text$mn:0000833F                 mov     eax, [ebp+arg_0]
.text$mn:00008342                 mov     esp, ebp
.text$mn:00008344                 pop     ebp
.text$mn:00008345                 retn    4
.text$mn:00008345 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ endp
.text$mn:00008345
.text$mn:00008345 _text$mn        ends
.text$mn:00008345
.text$mn:00008348 ; ===========================================================================
.text$mn:00008348
.text$mn:00008348 ; Segment type: Pure code
.text$mn:00008348 ; Segment permissions: Read/Execute
.text$mn:00008348 _text$mn        segment para public 'CODE' use32
.text$mn:00008348                 assume cs:_text$mn
.text$mn:00008348                 ;org 8348h
.text$mn:00008348 ; COMDAT (pick any)
.text$mn:00008348                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008348
.text$mn:00008348 ; =============== S U B R O U T I N E =======================================
.text$mn:00008348
.text$mn:00008348 ; Attributes: bp-based frame
.text$mn:00008348
.text$mn:00008348 ; public: struct std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>>::_Getal(void)const
.text$mn:00008348                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ
.text$mn:00008348 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ proc near
.text$mn:00008348                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Umove<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *)+10p
.text$mn:00008348                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Destroy(recordedMacroStep *,recordedMacroStep *)+10p ...
.text$mn:00008348
.text$mn:00008348 var_4           = dword ptr -4
.text$mn:00008348 arg_0           = dword ptr  8
.text$mn:00008348
.text$mn:00008348                 push    ebp
.text$mn:00008349                 mov     ebp, esp
.text$mn:0000834B                 push    ecx
.text$mn:0000834C                 mov     [ebp+var_4], ecx
.text$mn:0000834F                 mov     ecx, [ebp+arg_0]
.text$mn:00008352                 call    ??0?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::_Wrap_alloc<std::allocator<recordedMacroStep>>(void)
.text$mn:00008357                 mov     eax, [ebp+arg_0]
.text$mn:0000835A                 mov     esp, ebp
.text$mn:0000835C                 pop     ebp
.text$mn:0000835D                 retn    4
.text$mn:0000835D ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ endp
.text$mn:0000835D
.text$mn:0000835D _text$mn        ends
.text$mn:0000835D
.text$mn:00008360 ; ===========================================================================
.text$mn:00008360
.text$mn:00008360 ; Segment type: Pure code
.text$mn:00008360 ; Segment permissions: Read/Execute
.text$mn:00008360 _text$mn        segment para public 'CODE' use32
.text$mn:00008360                 assume cs:_text$mn
.text$mn:00008360                 ;org 8360h
.text$mn:00008360 ; COMDAT (pick any)
.text$mn:00008360                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008360
.text$mn:00008360 ; =============== S U B R O U T I N E =======================================
.text$mn:00008360
.text$mn:00008360 ; Attributes: bp-based frame
.text$mn:00008360
.text$mn:00008360 ; public: unsigned int __thiscall std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>::_Getblock(unsigned int)const
.text$mn:00008360                 public ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QBEII@Z
.text$mn:00008360 ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QBEII@Z proc near
.text$mn:00008360                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+AEp
.text$mn:00008360                                         ; std::deque<uint,std::allocator<uint>>::pop_back(void)+5Bp ...
.text$mn:00008360
.text$mn:00008360 var_4           = dword ptr -4
.text$mn:00008360 arg_0           = dword ptr  8
.text$mn:00008360
.text$mn:00008360                 push    ebp
.text$mn:00008361                 mov     ebp, esp
.text$mn:00008363                 push    ecx
.text$mn:00008364                 mov     [ebp+var_4], ecx
.text$mn:00008367                 mov     eax, [ebp+arg_0]
.text$mn:0000836A                 shr     eax, 2
.text$mn:0000836D                 mov     ecx, [ebp+var_4]
.text$mn:00008370                 mov     edx, [ecx+8]
.text$mn:00008373                 sub     edx, 1
.text$mn:00008376                 and     eax, edx
.text$mn:00008378                 mov     esp, ebp
.text$mn:0000837A                 pop     ebp
.text$mn:0000837B                 retn    4
.text$mn:0000837B ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QBEII@Z endp
.text$mn:0000837B
.text$mn:0000837B ; ---------------------------------------------------------------------------
.text$mn:0000837E                 align 10h
.text$mn:0000837E _text$mn        ends
.text$mn:0000837E
.text$mn:00008380 ; ===========================================================================
.text$mn:00008380
.text$mn:00008380 ; Segment type: Pure code
.text$mn:00008380 ; Segment permissions: Read/Execute
.text$mn:00008380 _text$mn        segment para public 'CODE' use32
.text$mn:00008380                 assume cs:_text$mn
.text$mn:00008380                 ;org 8380h
.text$mn:00008380 ; COMDAT (pick any)
.text$mn:00008380                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008380
.text$mn:00008380 ; =============== S U B R O U T I N E =======================================
.text$mn:00008380
.text$mn:00008380 ; Attributes: bp-based frame
.text$mn:00008380
.text$mn:00008380 ; const struct std::_Container_base12 *__thiscall std::_Iterator_base12::_Getcont(std::_Iterator_base12 *__hidden this)
.text$mn:00008380                 public ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
.text$mn:00008380 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ proc near
.text$mn:00008380                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+Cp
.text$mn:00008380
.text$mn:00008380 var_8           = dword ptr -8
.text$mn:00008380 var_4           = dword ptr -4
.text$mn:00008380
.text$mn:00008380                 push    ebp
.text$mn:00008381                 mov     ebp, esp
.text$mn:00008383                 sub     esp, 8
.text$mn:00008386                 mov     [ebp+var_4], ecx
.text$mn:00008389                 mov     eax, [ebp+var_4]
.text$mn:0000838C                 cmp     dword ptr [eax], 0
.text$mn:0000838F                 jnz     short loc_839A
.text$mn:00008391                 mov     [ebp+var_8], 0
.text$mn:00008398                 jmp     short loc_83A4
.text$mn:0000839A ; ---------------------------------------------------------------------------
.text$mn:0000839A
.text$mn:0000839A loc_839A:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+Fj
.text$mn:0000839A                 mov     ecx, [ebp+var_4]
.text$mn:0000839D                 mov     edx, [ecx]
.text$mn:0000839F                 mov     eax, [edx]
.text$mn:000083A1                 mov     [ebp+var_8], eax
.text$mn:000083A4
.text$mn:000083A4 loc_83A4:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+18j
.text$mn:000083A4                 mov     eax, [ebp+var_8]
.text$mn:000083A7                 mov     esp, ebp
.text$mn:000083A9                 pop     ebp
.text$mn:000083AA                 retn
.text$mn:000083AA ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ endp
.text$mn:000083AA
.text$mn:000083AA ; ---------------------------------------------------------------------------
.text$mn:000083AB                 align 4
.text$mn:000083AB _text$mn        ends
.text$mn:000083AB
.text$mn:000083AC ; ===========================================================================
.text$mn:000083AC
.text$mn:000083AC ; Segment type: Pure code
.text$mn:000083AC ; Segment permissions: Read/Execute
.text$mn:000083AC _text$mn        segment para public 'CODE' use32
.text$mn:000083AC                 assume cs:_text$mn
.text$mn:000083AC                 ;org 83ACh
.text$mn:000083AC ; COMDAT (pick any)
.text$mn:000083AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000083AC
.text$mn:000083AC ; =============== S U B R O U T I N E =======================================
.text$mn:000083AC
.text$mn:000083AC ; Attributes: bp-based frame
.text$mn:000083AC
.text$mn:000083AC ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:000083AC                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:000083AC ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:000083AC                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Orphan_off(uint)+79p
.text$mn:000083AC                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+3Cp ...
.text$mn:000083AC
.text$mn:000083AC var_8           = dword ptr -8
.text$mn:000083AC var_4           = dword ptr -4
.text$mn:000083AC
.text$mn:000083AC                 push    ebp
.text$mn:000083AD                 mov     ebp, esp
.text$mn:000083AF                 sub     esp, 8
.text$mn:000083B2                 mov     [ebp+var_4], ecx
.text$mn:000083B5                 mov     eax, [ebp+var_4]
.text$mn:000083B8                 cmp     dword ptr [eax], 0
.text$mn:000083BB                 jnz     short loc_83C6
.text$mn:000083BD                 mov     [ebp+var_8], 0
.text$mn:000083C4                 jmp     short loc_83D1
.text$mn:000083C6 ; ---------------------------------------------------------------------------
.text$mn:000083C6
.text$mn:000083C6 loc_83C6:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:000083C6                 mov     ecx, [ebp+var_4]
.text$mn:000083C9                 mov     edx, [ecx]
.text$mn:000083CB                 add     edx, 4
.text$mn:000083CE                 mov     [ebp+var_8], edx
.text$mn:000083D1
.text$mn:000083D1 loc_83D1:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:000083D1                 mov     eax, [ebp+var_8]
.text$mn:000083D4                 mov     esp, ebp
.text$mn:000083D6                 pop     ebp
.text$mn:000083D7                 retn
.text$mn:000083D7 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:000083D7
.text$mn:000083D7 _text$mn        ends
.text$mn:000083D7
.text$mn:000083D8 ; ===========================================================================
.text$mn:000083D8
.text$mn:000083D8 ; Segment type: Pure code
.text$mn:000083D8 ; Segment permissions: Read/Execute
.text$mn:000083D8 _text$mn        segment para public 'CODE' use32
.text$mn:000083D8                 assume cs:_text$mn
.text$mn:000083D8                 ;org 83D8h
.text$mn:000083D8 ; COMDAT (pick any)
.text$mn:000083D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000083D8
.text$mn:000083D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000083D8
.text$mn:000083D8 ; Attributes: bp-based frame
.text$mn:000083D8
.text$mn:000083D8 ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:000083D8                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:000083D8 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:000083D8                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Orphan_off(uint)+AEp
.text$mn:000083D8                                         ; std::deque<uint,std::allocator<uint>>::_Orphan_off(uint)+C7p ...
.text$mn:000083D8
.text$mn:000083D8 var_4           = dword ptr -4
.text$mn:000083D8
.text$mn:000083D8                 push    ebp
.text$mn:000083D9                 mov     ebp, esp
.text$mn:000083DB                 push    ecx
.text$mn:000083DC                 mov     [ebp+var_4], ecx
.text$mn:000083DF                 mov     eax, [ebp+var_4]
.text$mn:000083E2                 add     eax, 4
.text$mn:000083E5                 mov     esp, ebp
.text$mn:000083E7                 pop     ebp
.text$mn:000083E8                 retn
.text$mn:000083E8 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:000083E8
.text$mn:000083E8 ; ---------------------------------------------------------------------------
.text$mn:000083E9                 align 4
.text$mn:000083E9 _text$mn        ends
.text$mn:000083E9
.text$mn:000083EC ; ===========================================================================
.text$mn:000083EC
.text$mn:000083EC ; Segment type: Pure code
.text$mn:000083EC ; Segment permissions: Read/Execute
.text$mn:000083EC _text$mn        segment para public 'CODE' use32
.text$mn:000083EC                 assume cs:_text$mn
.text$mn:000083EC                 ;org 83ECh
.text$mn:000083EC ; COMDAT (pick any)
.text$mn:000083EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000083EC
.text$mn:000083EC ; =============== S U B R O U T I N E =======================================
.text$mn:000083EC
.text$mn:000083EC ; Attributes: bp-based frame
.text$mn:000083EC
.text$mn:000083EC ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000083EC                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000083EC ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000083EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:000083EC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:000083EC
.text$mn:000083EC var_C           = dword ptr -0Ch
.text$mn:000083EC Size            = dword ptr -8
.text$mn:000083EC var_4           = dword ptr -4
.text$mn:000083EC arg_0           = dword ptr  8
.text$mn:000083EC arg_4           = byte ptr  0Ch
.text$mn:000083EC
.text$mn:000083EC                 push    ebp
.text$mn:000083ED                 mov     ebp, esp
.text$mn:000083EF                 sub     esp, 0Ch
.text$mn:000083F2                 mov     [ebp+var_4], ecx
.text$mn:000083F5                 mov     ecx, [ebp+var_4]
.text$mn:000083F8                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000083FD                 cmp     eax, [ebp+arg_0]
.text$mn:00008400                 jnb     short loc_840A
.text$mn:00008402                 mov     ecx, [ebp+var_4]
.text$mn:00008405                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000840A
.text$mn:0000840A loc_840A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:0000840A                 mov     eax, [ebp+var_4]
.text$mn:0000840D                 mov     ecx, [eax+18h]
.text$mn:00008410                 cmp     ecx, [ebp+arg_0]
.text$mn:00008413                 jnb     short loc_842A
.text$mn:00008415                 mov     edx, [ebp+var_4]
.text$mn:00008418                 mov     eax, [edx+14h]
.text$mn:0000841B                 push    eax
.text$mn:0000841C                 mov     ecx, [ebp+arg_0]
.text$mn:0000841F                 push    ecx
.text$mn:00008420                 mov     ecx, [ebp+var_4]
.text$mn:00008423                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00008428                 jmp     short loc_8474
.text$mn:0000842A ; ---------------------------------------------------------------------------
.text$mn:0000842A
.text$mn:0000842A loc_842A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:0000842A                 movzx   edx, [ebp+arg_4]
.text$mn:0000842E                 test    edx, edx
.text$mn:00008430                 jz      short loc_8464
.text$mn:00008432                 cmp     [ebp+arg_0], 10h
.text$mn:00008436                 jnb     short loc_8464
.text$mn:00008438                 mov     eax, [ebp+var_4]
.text$mn:0000843B                 mov     ecx, [ebp+arg_0]
.text$mn:0000843E                 cmp     ecx, [eax+14h]
.text$mn:00008441                 jnb     short loc_844B
.text$mn:00008443                 mov     edx, [ebp+arg_0]
.text$mn:00008446                 mov     [ebp+Size], edx
.text$mn:00008449                 jmp     short loc_8454
.text$mn:0000844B ; ---------------------------------------------------------------------------
.text$mn:0000844B
.text$mn:0000844B loc_844B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:0000844B                 mov     eax, [ebp+var_4]
.text$mn:0000844E                 mov     ecx, [eax+14h]
.text$mn:00008451                 mov     [ebp+Size], ecx
.text$mn:00008454
.text$mn:00008454 loc_8454:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00008454                 mov     edx, [ebp+Size]
.text$mn:00008457                 push    edx             ; Size
.text$mn:00008458                 push    1               ; char
.text$mn:0000845A                 mov     ecx, [ebp+var_4]
.text$mn:0000845D                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00008462                 jmp     short loc_8474
.text$mn:00008464 ; ---------------------------------------------------------------------------
.text$mn:00008464
.text$mn:00008464 loc_8464:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00008464                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00008464                 cmp     [ebp+arg_0], 0
.text$mn:00008468                 jnz     short loc_8474
.text$mn:0000846A                 push    0
.text$mn:0000846C                 mov     ecx, [ebp+var_4]
.text$mn:0000846F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00008474
.text$mn:00008474 loc_8474:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00008474                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00008474                 cmp     [ebp+arg_0], 0
.text$mn:00008478                 jbe     short loc_8483
.text$mn:0000847A                 mov     [ebp+var_C], 1
.text$mn:00008481                 jmp     short loc_848A
.text$mn:00008483 ; ---------------------------------------------------------------------------
.text$mn:00008483
.text$mn:00008483 loc_8483:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00008483                 mov     [ebp+var_C], 0
.text$mn:0000848A
.text$mn:0000848A loc_848A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:0000848A                 mov     al, byte ptr [ebp+var_C]
.text$mn:0000848D                 mov     esp, ebp
.text$mn:0000848F                 pop     ebp
.text$mn:00008490                 retn    8
.text$mn:00008490 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00008490
.text$mn:00008490 ; ---------------------------------------------------------------------------
.text$mn:00008493                 align 4
.text$mn:00008493 _text$mn        ends
.text$mn:00008493
.text$mn:00008494 ; ===========================================================================
.text$mn:00008494
.text$mn:00008494 ; Segment type: Pure code
.text$mn:00008494 ; Segment permissions: Read/Execute
.text$mn:00008494 _text$mn        segment para public 'CODE' use32
.text$mn:00008494                 assume cs:_text$mn
.text$mn:00008494                 ;org 8494h
.text$mn:00008494 ; COMDAT (pick any)
.text$mn:00008494                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008494
.text$mn:00008494 ; =============== S U B R O U T I N E =======================================
.text$mn:00008494
.text$mn:00008494 ; Attributes: bp-based frame
.text$mn:00008494
.text$mn:00008494 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:00008494                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:00008494 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:00008494                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Dp
.text$mn:00008494                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+8Ep ...
.text$mn:00008494
.text$mn:00008494 var_C           = dword ptr -0Ch
.text$mn:00008494 var_8           = dword ptr -8
.text$mn:00008494 var_4           = dword ptr -4
.text$mn:00008494 arg_0           = dword ptr  8
.text$mn:00008494 arg_4           = byte ptr  0Ch
.text$mn:00008494
.text$mn:00008494                 push    ebp
.text$mn:00008495                 mov     ebp, esp
.text$mn:00008497                 sub     esp, 0Ch
.text$mn:0000849A                 mov     [ebp+var_4], ecx
.text$mn:0000849D                 mov     ecx, [ebp+var_4]
.text$mn:000084A0                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000084A5                 cmp     eax, [ebp+arg_0]
.text$mn:000084A8                 jnb     short loc_84B2
.text$mn:000084AA                 mov     ecx, [ebp+var_4]
.text$mn:000084AD                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:000084B2
.text$mn:000084B2 loc_84B2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:000084B2                 mov     eax, [ebp+var_4]
.text$mn:000084B5                 mov     ecx, [eax+18h]
.text$mn:000084B8                 cmp     ecx, [ebp+arg_0]
.text$mn:000084BB                 jnb     short loc_84D2
.text$mn:000084BD                 mov     edx, [ebp+var_4]
.text$mn:000084C0                 mov     eax, [edx+14h]
.text$mn:000084C3                 push    eax
.text$mn:000084C4                 mov     ecx, [ebp+arg_0]
.text$mn:000084C7                 push    ecx
.text$mn:000084C8                 mov     ecx, [ebp+var_4]
.text$mn:000084CB                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:000084D0                 jmp     short loc_851C
.text$mn:000084D2 ; ---------------------------------------------------------------------------
.text$mn:000084D2
.text$mn:000084D2 loc_84D2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:000084D2                 movzx   edx, [ebp+arg_4]
.text$mn:000084D6                 test    edx, edx
.text$mn:000084D8                 jz      short loc_850C
.text$mn:000084DA                 cmp     [ebp+arg_0], 8
.text$mn:000084DE                 jnb     short loc_850C
.text$mn:000084E0                 mov     eax, [ebp+var_4]
.text$mn:000084E3                 mov     ecx, [ebp+arg_0]
.text$mn:000084E6                 cmp     ecx, [eax+14h]
.text$mn:000084E9                 jnb     short loc_84F3
.text$mn:000084EB                 mov     edx, [ebp+arg_0]
.text$mn:000084EE                 mov     [ebp+var_8], edx
.text$mn:000084F1                 jmp     short loc_84FC
.text$mn:000084F3 ; ---------------------------------------------------------------------------
.text$mn:000084F3
.text$mn:000084F3 loc_84F3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:000084F3                 mov     eax, [ebp+var_4]
.text$mn:000084F6                 mov     ecx, [eax+14h]
.text$mn:000084F9                 mov     [ebp+var_8], ecx
.text$mn:000084FC
.text$mn:000084FC loc_84FC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:000084FC                 mov     edx, [ebp+var_8]
.text$mn:000084FF                 push    edx
.text$mn:00008500                 push    1
.text$mn:00008502                 mov     ecx, [ebp+var_4]
.text$mn:00008505                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000850A                 jmp     short loc_851C
.text$mn:0000850C ; ---------------------------------------------------------------------------
.text$mn:0000850C
.text$mn:0000850C loc_850C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:0000850C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:0000850C                 cmp     [ebp+arg_0], 0
.text$mn:00008510                 jnz     short loc_851C
.text$mn:00008512                 push    0
.text$mn:00008514                 mov     ecx, [ebp+var_4]
.text$mn:00008517                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000851C
.text$mn:0000851C loc_851C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:0000851C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:0000851C                 cmp     [ebp+arg_0], 0
.text$mn:00008520                 jbe     short loc_852B
.text$mn:00008522                 mov     [ebp+var_C], 1
.text$mn:00008529                 jmp     short loc_8532
.text$mn:0000852B ; ---------------------------------------------------------------------------
.text$mn:0000852B
.text$mn:0000852B loc_852B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:0000852B                 mov     [ebp+var_C], 0
.text$mn:00008532
.text$mn:00008532 loc_8532:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:00008532                 mov     al, byte ptr [ebp+var_C]
.text$mn:00008535                 mov     esp, ebp
.text$mn:00008537                 pop     ebp
.text$mn:00008538                 retn    8
.text$mn:00008538 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:00008538
.text$mn:00008538 ; ---------------------------------------------------------------------------
.text$mn:0000853B                 align 4
.text$mn:0000853B _text$mn        ends
.text$mn:0000853B
.text$mn:0000853C ; ===========================================================================
.text$mn:0000853C
.text$mn:0000853C ; Segment type: Pure code
.text$mn:0000853C ; Segment permissions: Read/Execute
.text$mn:0000853C _text$mn        segment para public 'CODE' use32
.text$mn:0000853C                 assume cs:_text$mn
.text$mn:0000853C                 ;org 853Ch
.text$mn:0000853C ; COMDAT (pick any)
.text$mn:0000853C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000853C
.text$mn:0000853C ; =============== S U B R O U T I N E =======================================
.text$mn:0000853C
.text$mn:0000853C ; Attributes: bp-based frame
.text$mn:0000853C
.text$mn:0000853C ; protected: unsigned int __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Grow_to(unsigned int)const
.text$mn:0000853C                 public ?_Grow_to@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEII@Z
.text$mn:0000853C ?_Grow_to@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEII@Z proc near
.text$mn:0000853C                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+45p
.text$mn:0000853C
.text$mn:0000853C var_C           = dword ptr -0Ch
.text$mn:0000853C var_8           = dword ptr -8
.text$mn:0000853C var_4           = dword ptr -4
.text$mn:0000853C arg_0           = dword ptr  8
.text$mn:0000853C
.text$mn:0000853C                 push    ebp
.text$mn:0000853D                 mov     ebp, esp
.text$mn:0000853F                 sub     esp, 0Ch
.text$mn:00008542                 mov     [ebp+var_8], ecx
.text$mn:00008545                 mov     ecx, [ebp+var_8]
.text$mn:00008548                 call    ?capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::capacity(void)
.text$mn:0000854D                 mov     [ebp+var_4], eax
.text$mn:00008550                 mov     ecx, [ebp+var_8]
.text$mn:00008553                 call    ?max_size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::max_size(void)
.text$mn:00008558                 mov     ecx, [ebp+var_4]
.text$mn:0000855B                 shr     ecx, 1
.text$mn:0000855D                 sub     eax, ecx
.text$mn:0000855F                 cmp     eax, [ebp+var_4]
.text$mn:00008562                 jnb     short loc_856D
.text$mn:00008564                 mov     [ebp+var_C], 0
.text$mn:0000856B                 jmp     short loc_8578
.text$mn:0000856D ; ---------------------------------------------------------------------------
.text$mn:0000856D
.text$mn:0000856D loc_856D:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Grow_to(uint)+26j
.text$mn:0000856D                 mov     edx, [ebp+var_4]
.text$mn:00008570                 shr     edx, 1
.text$mn:00008572                 add     edx, [ebp+var_4]
.text$mn:00008575                 mov     [ebp+var_C], edx
.text$mn:00008578
.text$mn:00008578 loc_8578:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Grow_to(uint)+2Fj
.text$mn:00008578                 mov     eax, [ebp+var_C]
.text$mn:0000857B                 mov     [ebp+var_4], eax
.text$mn:0000857E                 mov     ecx, [ebp+var_4]
.text$mn:00008581                 cmp     ecx, [ebp+arg_0]
.text$mn:00008584                 jnb     short loc_858C
.text$mn:00008586                 mov     edx, [ebp+arg_0]
.text$mn:00008589                 mov     [ebp+var_4], edx
.text$mn:0000858C
.text$mn:0000858C loc_858C:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Grow_to(uint)+48j
.text$mn:0000858C                 mov     eax, [ebp+var_4]
.text$mn:0000858F                 mov     esp, ebp
.text$mn:00008591                 pop     ebp
.text$mn:00008592                 retn    4
.text$mn:00008592 ?_Grow_to@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEII@Z endp
.text$mn:00008592
.text$mn:00008592 ; ---------------------------------------------------------------------------
.text$mn:00008595                 align 4
.text$mn:00008595 _text$mn        ends
.text$mn:00008595
.text$mn:00008598 ; ===========================================================================
.text$mn:00008598
.text$mn:00008598 ; Segment type: Pure code
.text$mn:00008598 ; Segment permissions: Read/Execute
.text$mn:00008598 _text$mn        segment para public 'CODE' use32
.text$mn:00008598                 assume cs:_text$mn
.text$mn:00008598                 ;org 8598h
.text$mn:00008598 ; COMDAT (pick any)
.text$mn:00008598                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008598
.text$mn:00008598 ; =============== S U B R O U T I N E =======================================
.text$mn:00008598
.text$mn:00008598 ; Attributes: bp-based frame
.text$mn:00008598
.text$mn:00008598 ; protected: unsigned int __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Grow_to(unsigned int)const
.text$mn:00008598                 public ?_Grow_to@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEII@Z
.text$mn:00008598 ?_Grow_to@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEII@Z proc near
.text$mn:00008598                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reserve(uint)+45p
.text$mn:00008598
.text$mn:00008598 var_C           = dword ptr -0Ch
.text$mn:00008598 var_8           = dword ptr -8
.text$mn:00008598 var_4           = dword ptr -4
.text$mn:00008598 arg_0           = dword ptr  8
.text$mn:00008598
.text$mn:00008598                 push    ebp
.text$mn:00008599                 mov     ebp, esp
.text$mn:0000859B                 sub     esp, 0Ch
.text$mn:0000859E                 mov     [ebp+var_8], ecx
.text$mn:000085A1                 mov     ecx, [ebp+var_8]
.text$mn:000085A4                 call    ?capacity@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::capacity(void)
.text$mn:000085A9                 mov     [ebp+var_4], eax
.text$mn:000085AC                 mov     ecx, [ebp+var_8]
.text$mn:000085AF                 call    ?max_size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::max_size(void)
.text$mn:000085B4                 mov     ecx, [ebp+var_4]
.text$mn:000085B7                 shr     ecx, 1
.text$mn:000085B9                 sub     eax, ecx
.text$mn:000085BB                 cmp     eax, [ebp+var_4]
.text$mn:000085BE                 jnb     short loc_85C9
.text$mn:000085C0                 mov     [ebp+var_C], 0
.text$mn:000085C7                 jmp     short loc_85D4
.text$mn:000085C9 ; ---------------------------------------------------------------------------
.text$mn:000085C9
.text$mn:000085C9 loc_85C9:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Grow_to(uint)+26j
.text$mn:000085C9                 mov     edx, [ebp+var_4]
.text$mn:000085CC                 shr     edx, 1
.text$mn:000085CE                 add     edx, [ebp+var_4]
.text$mn:000085D1                 mov     [ebp+var_C], edx
.text$mn:000085D4
.text$mn:000085D4 loc_85D4:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Grow_to(uint)+2Fj
.text$mn:000085D4                 mov     eax, [ebp+var_C]
.text$mn:000085D7                 mov     [ebp+var_4], eax
.text$mn:000085DA                 mov     ecx, [ebp+var_4]
.text$mn:000085DD                 cmp     ecx, [ebp+arg_0]
.text$mn:000085E0                 jnb     short loc_85E8
.text$mn:000085E2                 mov     edx, [ebp+arg_0]
.text$mn:000085E5                 mov     [ebp+var_4], edx
.text$mn:000085E8
.text$mn:000085E8 loc_85E8:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Grow_to(uint)+48j
.text$mn:000085E8                 mov     eax, [ebp+var_4]
.text$mn:000085EB                 mov     esp, ebp
.text$mn:000085ED                 pop     ebp
.text$mn:000085EE                 retn    4
.text$mn:000085EE ?_Grow_to@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEII@Z endp
.text$mn:000085EE
.text$mn:000085EE ; ---------------------------------------------------------------------------
.text$mn:000085F1                 align 4
.text$mn:000085F1 _text$mn        ends
.text$mn:000085F1
.text$mn:000085F4 ; ===========================================================================
.text$mn:000085F4
.text$mn:000085F4 ; Segment type: Pure code
.text$mn:000085F4 ; Segment permissions: Read/Execute
.text$mn:000085F4 _text$mn        segment para public 'CODE' use32
.text$mn:000085F4                 assume cs:_text$mn
.text$mn:000085F4                 ;org 85F4h
.text$mn:000085F4 ; COMDAT (pick any)
.text$mn:000085F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000085F4
.text$mn:000085F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000085F4
.text$mn:000085F4 ; Attributes: bp-based frame
.text$mn:000085F4
.text$mn:000085F4 ; protected: void __thiscall std::deque<unsigned int, class std::allocator<unsigned int>>::_Growmap(unsigned int)
.text$mn:000085F4                 public ?_Growmap@?$deque@IV?$allocator@I@std@@@std@@IAEXI@Z
.text$mn:000085F4 ?_Growmap@?$deque@IV?$allocator@I@std@@@std@@IAEXI@Z proc near
.text$mn:000085F4                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::push_back(uint const &)+44p
.text$mn:000085F4
.text$mn:000085F4 var_1C          = dword ptr -1Ch
.text$mn:000085F4 var_18          = dword ptr -18h
.text$mn:000085F4 var_14          = dword ptr -14h
.text$mn:000085F4 var_10          = dword ptr -10h
.text$mn:000085F4 var_C           = dword ptr -0Ch
.text$mn:000085F4 var_8           = dword ptr -8
.text$mn:000085F4 var_2           = byte ptr -2
.text$mn:000085F4 var_1           = byte ptr -1
.text$mn:000085F4 arg_0           = dword ptr  8
.text$mn:000085F4
.text$mn:000085F4                 push    ebp
.text$mn:000085F5                 mov     ebp, esp
.text$mn:000085F7                 sub     esp, 1Ch
.text$mn:000085FA                 mov     [ebp+var_8], ecx
.text$mn:000085FD                 lea     eax, [ebp+var_2]
.text$mn:00008600                 push    eax
.text$mn:00008601                 mov     ecx, [ebp+var_8]
.text$mn:00008604                 call    ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:00008609                 push    eax
.text$mn:0000860A                 lea     ecx, [ebp+var_1]
.text$mn:0000860D                 call    ??$?0U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@I@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<uint *>>::_Wrap_alloc<std::allocator<uint *>>(std::_Wrap_alloc<std::allocator<uint>> const &)
.text$mn:00008612                 mov     ecx, [ebp+var_8]
.text$mn:00008615                 cmp     dword ptr [ecx+8], 0
.text$mn:00008619                 jbe     short loc_8626
.text$mn:0000861B                 mov     edx, [ebp+var_8]
.text$mn:0000861E                 mov     eax, [edx+8]
.text$mn:00008621                 mov     [ebp+var_1C], eax
.text$mn:00008624                 jmp     short loc_862D
.text$mn:00008626 ; ---------------------------------------------------------------------------
.text$mn:00008626
.text$mn:00008626 loc_8626:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+25j
.text$mn:00008626                 mov     [ebp+var_1C], 1
.text$mn:0000862D
.text$mn:0000862D loc_862D:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+30j
.text$mn:0000862D                 mov     ecx, [ebp+var_1C]
.text$mn:00008630                 mov     [ebp+var_14], ecx
.text$mn:00008633
.text$mn:00008633 loc_8633:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+76j
.text$mn:00008633                 mov     edx, [ebp+var_8]
.text$mn:00008636                 mov     eax, [ebp+var_14]
.text$mn:00008639                 sub     eax, [edx+8]
.text$mn:0000863C                 cmp     eax, [ebp+arg_0]
.text$mn:0000863F                 jb      short loc_8647
.text$mn:00008641                 cmp     [ebp+var_14], 8
.text$mn:00008645                 jnb     short loc_866C
.text$mn:00008647
.text$mn:00008647 loc_8647:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+4Bj
.text$mn:00008647                 mov     ecx, [ebp+var_8]
.text$mn:0000864A                 call    ?max_size@?$deque@IV?$allocator@I@std@@@std@@QBEIXZ ; std::deque<uint,std::allocator<uint>>::max_size(void)
.text$mn:0000864F                 shr     eax, 2
.text$mn:00008652                 sub     eax, [ebp+var_14]
.text$mn:00008655                 cmp     eax, [ebp+var_14]
.text$mn:00008658                 jnb     short loc_8662
.text$mn:0000865A                 mov     ecx, [ebp+var_8]
.text$mn:0000865D                 call    ?_Xlen@?$deque@IV?$allocator@I@std@@@std@@IBEXXZ ; std::deque<uint,std::allocator<uint>>::_Xlen(void)
.text$mn:00008662
.text$mn:00008662 loc_8662:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+64j
.text$mn:00008662                 mov     ecx, [ebp+var_14]
.text$mn:00008665                 shl     ecx, 1
.text$mn:00008667                 mov     [ebp+var_14], ecx
.text$mn:0000866A                 jmp     short loc_8633
.text$mn:0000866C ; ---------------------------------------------------------------------------
.text$mn:0000866C
.text$mn:0000866C loc_866C:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+51j
.text$mn:0000866C                 mov     edx, [ebp+var_8]
.text$mn:0000866F                 mov     eax, [ebp+var_14]
.text$mn:00008672                 sub     eax, [edx+8]
.text$mn:00008675                 mov     [ebp+arg_0], eax
.text$mn:00008678                 mov     ecx, [ebp+var_8]
.text$mn:0000867B                 mov     edx, [ecx+0Ch]
.text$mn:0000867E                 shr     edx, 2
.text$mn:00008681                 mov     [ebp+var_10], edx
.text$mn:00008684                 mov     eax, [ebp+var_8]
.text$mn:00008687                 mov     ecx, [eax+8]
.text$mn:0000868A                 add     ecx, [ebp+arg_0]
.text$mn:0000868D                 push    ecx
.text$mn:0000868E                 lea     ecx, [ebp+var_1]
.text$mn:00008691                 call    ?allocate@?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@QAEPAPAII@Z ; std::_Wrap_alloc<std::allocator<uint *>>::allocate(uint)
.text$mn:00008696                 mov     [ebp+var_18], eax
.text$mn:00008699                 mov     edx, [ebp+var_10]
.text$mn:0000869C                 mov     eax, [ebp+var_18]
.text$mn:0000869F                 lea     ecx, [eax+edx*4]
.text$mn:000086A2                 mov     [ebp+var_C], ecx
.text$mn:000086A5                 lea     edx, [ebp+var_1]
.text$mn:000086A8                 push    edx
.text$mn:000086A9                 mov     eax, [ebp+var_C]
.text$mn:000086AC                 push    eax
.text$mn:000086AD                 mov     ecx, [ebp+var_8]
.text$mn:000086B0                 mov     edx, [ecx+8]
.text$mn:000086B3                 mov     eax, [ebp+var_8]
.text$mn:000086B6                 mov     ecx, [eax+4]
.text$mn:000086B9                 lea     edx, [ecx+edx*4]
.text$mn:000086BC                 push    edx
.text$mn:000086BD                 mov     eax, [ebp+var_8]
.text$mn:000086C0                 mov     ecx, [eax+4]
.text$mn:000086C3                 mov     edx, [ebp+var_10]
.text$mn:000086C6                 lea     eax, [ecx+edx*4]
.text$mn:000086C9                 push    eax
.text$mn:000086CA                 call    ??$_Uninitialized_copy@PAPAIPAPAIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z ; std::_Uninitialized_copy<uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &)
.text$mn:000086CF                 add     esp, 10h
.text$mn:000086D2                 mov     [ebp+var_C], eax
.text$mn:000086D5                 mov     ecx, [ebp+var_10]
.text$mn:000086D8                 cmp     ecx, [ebp+arg_0]
.text$mn:000086DB                 ja      short loc_8731
.text$mn:000086DD                 lea     edx, [ebp+var_1]
.text$mn:000086E0                 push    edx
.text$mn:000086E1                 mov     eax, [ebp+var_C]
.text$mn:000086E4                 push    eax
.text$mn:000086E5                 mov     ecx, [ebp+var_8]
.text$mn:000086E8                 mov     edx, [ecx+4]
.text$mn:000086EB                 mov     eax, [ebp+var_10]
.text$mn:000086EE                 lea     ecx, [edx+eax*4]
.text$mn:000086F1                 push    ecx
.text$mn:000086F2                 mov     edx, [ebp+var_8]
.text$mn:000086F5                 mov     eax, [edx+4]
.text$mn:000086F8                 push    eax
.text$mn:000086F9                 call    ??$_Uninitialized_copy@PAPAIPAPAIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z ; std::_Uninitialized_copy<uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &)
.text$mn:000086FE                 add     esp, 10h
.text$mn:00008701                 mov     [ebp+var_C], eax
.text$mn:00008704                 lea     ecx, [ebp+var_1]
.text$mn:00008707                 push    ecx
.text$mn:00008708                 mov     edx, [ebp+arg_0]
.text$mn:0000870B                 sub     edx, [ebp+var_10]
.text$mn:0000870E                 push    edx
.text$mn:0000870F                 mov     eax, [ebp+var_C]
.text$mn:00008712                 push    eax
.text$mn:00008713                 call    ??$_Uninitialized_default_fill_n@PAPAIIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAXPAPAIIAAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z ; std::_Uninitialized_default_fill_n<uint * *,uint,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint,std::_Wrap_alloc<std::allocator<uint *>> &)
.text$mn:00008718                 add     esp, 0Ch
.text$mn:0000871B                 lea     ecx, [ebp+var_1]
.text$mn:0000871E                 push    ecx
.text$mn:0000871F                 mov     edx, [ebp+var_10]
.text$mn:00008722                 push    edx
.text$mn:00008723                 mov     eax, [ebp+var_18]
.text$mn:00008726                 push    eax
.text$mn:00008727                 call    ??$_Uninitialized_default_fill_n@PAPAIIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAXPAPAIIAAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z ; std::_Uninitialized_default_fill_n<uint * *,uint,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint,std::_Wrap_alloc<std::allocator<uint *>> &)
.text$mn:0000872C                 add     esp, 0Ch
.text$mn:0000872F                 jmp     short loc_8796
.text$mn:00008731 ; ---------------------------------------------------------------------------
.text$mn:00008731
.text$mn:00008731 loc_8731:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+E7j
.text$mn:00008731                 lea     ecx, [ebp+var_1]
.text$mn:00008734                 push    ecx
.text$mn:00008735                 mov     edx, [ebp+var_C]
.text$mn:00008738                 push    edx
.text$mn:00008739                 mov     eax, [ebp+var_8]
.text$mn:0000873C                 mov     ecx, [eax+4]
.text$mn:0000873F                 mov     edx, [ebp+arg_0]
.text$mn:00008742                 lea     eax, [ecx+edx*4]
.text$mn:00008745                 push    eax
.text$mn:00008746                 mov     ecx, [ebp+var_8]
.text$mn:00008749                 mov     edx, [ecx+4]
.text$mn:0000874C                 push    edx
.text$mn:0000874D                 call    ??$_Uninitialized_copy@PAPAIPAPAIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z ; std::_Uninitialized_copy<uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &)
.text$mn:00008752                 add     esp, 10h
.text$mn:00008755                 lea     eax, [ebp+var_1]
.text$mn:00008758                 push    eax
.text$mn:00008759                 mov     ecx, [ebp+var_18]
.text$mn:0000875C                 push    ecx
.text$mn:0000875D                 mov     edx, [ebp+var_8]
.text$mn:00008760                 mov     eax, [edx+4]
.text$mn:00008763                 mov     ecx, [ebp+var_10]
.text$mn:00008766                 lea     edx, [eax+ecx*4]
.text$mn:00008769                 push    edx
.text$mn:0000876A                 mov     eax, [ebp+var_8]
.text$mn:0000876D                 mov     ecx, [eax+4]
.text$mn:00008770                 mov     edx, [ebp+arg_0]
.text$mn:00008773                 lea     eax, [ecx+edx*4]
.text$mn:00008776                 push    eax
.text$mn:00008777                 call    ??$_Uninitialized_copy@PAPAIPAPAIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAPAPAIPAPAI00AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z ; std::_Uninitialized_copy<uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &)
.text$mn:0000877C                 add     esp, 10h
.text$mn:0000877F                 mov     [ebp+var_C], eax
.text$mn:00008782                 lea     ecx, [ebp+var_1]
.text$mn:00008785                 push    ecx
.text$mn:00008786                 mov     edx, [ebp+arg_0]
.text$mn:00008789                 push    edx
.text$mn:0000878A                 mov     eax, [ebp+var_C]
.text$mn:0000878D                 push    eax
.text$mn:0000878E                 call    ??$_Uninitialized_default_fill_n@PAPAIIU?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAXPAPAIIAAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z ; std::_Uninitialized_default_fill_n<uint * *,uint,std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint,std::_Wrap_alloc<std::allocator<uint *>> &)
.text$mn:00008793                 add     esp, 0Ch
.text$mn:00008796
.text$mn:00008796 loc_8796:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+13Bj
.text$mn:00008796                 lea     ecx, [ebp+var_1]
.text$mn:00008799                 push    ecx
.text$mn:0000879A                 mov     edx, [ebp+var_8]
.text$mn:0000879D                 mov     eax, [edx+8]
.text$mn:000087A0                 mov     ecx, [ebp+var_8]
.text$mn:000087A3                 mov     edx, [ecx+4]
.text$mn:000087A6                 lea     eax, [edx+eax*4]
.text$mn:000087A9                 push    eax
.text$mn:000087AA                 mov     ecx, [ebp+var_8]
.text$mn:000087AD                 mov     edx, [ecx+4]
.text$mn:000087B0                 mov     eax, [ebp+var_10]
.text$mn:000087B3                 lea     ecx, [edx+eax*4]
.text$mn:000087B6                 push    ecx
.text$mn:000087B7                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@@std@@YAXPAPAI0AAU?$_Wrap_alloc@V?$allocator@PAI@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<uint *>>>(uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &)
.text$mn:000087BC                 add     esp, 0Ch
.text$mn:000087BF                 mov     edx, [ebp+var_8]
.text$mn:000087C2                 cmp     dword ptr [edx+4], 0
.text$mn:000087C6                 jz      short loc_87DE
.text$mn:000087C8                 mov     eax, [ebp+var_8]
.text$mn:000087CB                 mov     ecx, [eax+8]
.text$mn:000087CE                 push    ecx             ; int
.text$mn:000087CF                 mov     edx, [ebp+var_8]
.text$mn:000087D2                 mov     eax, [edx+4]
.text$mn:000087D5                 push    eax             ; void *
.text$mn:000087D6                 lea     ecx, [ebp+var_1]
.text$mn:000087D9                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@QAEXPAPAII@Z ; std::_Wrap_alloc<std::allocator<uint *>>::deallocate(uint * *,uint)
.text$mn:000087DE
.text$mn:000087DE loc_87DE:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+1D2j
.text$mn:000087DE                 mov     ecx, [ebp+var_8]
.text$mn:000087E1                 mov     edx, [ebp+var_18]
.text$mn:000087E4                 mov     [ecx+4], edx
.text$mn:000087E7                 mov     eax, [ebp+var_8]
.text$mn:000087EA                 mov     ecx, [eax+8]
.text$mn:000087ED                 add     ecx, [ebp+arg_0]
.text$mn:000087F0                 mov     edx, [ebp+var_8]
.text$mn:000087F3                 mov     [edx+8], ecx
.text$mn:000087F6                 mov     esp, ebp
.text$mn:000087F8                 pop     ebp
.text$mn:000087F9                 retn    4
.text$mn:000087F9 ?_Growmap@?$deque@IV?$allocator@I@std@@@std@@IAEXI@Z endp
.text$mn:000087F9
.text$mn:000087F9 _text$mn        ends
.text$mn:000087F9
.text$mn:000087FC ; ===========================================================================
.text$mn:000087FC
.text$mn:000087FC ; Segment type: Pure code
.text$mn:000087FC ; Segment permissions: Read/Execute
.text$mn:000087FC _text$mn        segment para public 'CODE' use32
.text$mn:000087FC                 assume cs:_text$mn
.text$mn:000087FC                 ;org 87FCh
.text$mn:000087FC ; COMDAT (pick any)
.text$mn:000087FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000087FC
.text$mn:000087FC ; =============== S U B R O U T I N E =======================================
.text$mn:000087FC
.text$mn:000087FC ; Attributes: bp-based frame
.text$mn:000087FC
.text$mn:000087FC ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000087FC                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000087FC ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000087FC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000087FC
.text$mn:000087FC var_4           = dword ptr -4
.text$mn:000087FC arg_0           = dword ptr  8
.text$mn:000087FC
.text$mn:000087FC                 push    ebp
.text$mn:000087FD                 mov     ebp, esp
.text$mn:000087FF                 push    ecx
.text$mn:00008800                 mov     [ebp+var_4], ecx
.text$mn:00008803                 cmp     [ebp+arg_0], 0
.text$mn:00008807                 jz      short loc_8829
.text$mn:00008809                 mov     ecx, [ebp+var_4]
.text$mn:0000880C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00008811                 cmp     [ebp+arg_0], eax
.text$mn:00008814                 jb      short loc_8829
.text$mn:00008816                 mov     ecx, [ebp+var_4]
.text$mn:00008819                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000881E                 mov     ecx, [ebp+var_4]
.text$mn:00008821                 add     eax, [ecx+14h]
.text$mn:00008824                 cmp     eax, [ebp+arg_0]
.text$mn:00008827                 ja      short loc_882F
.text$mn:00008829
.text$mn:00008829 loc_8829:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00008829                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00008829                 xor     al, al
.text$mn:0000882B                 jmp     short loc_8831
.text$mn:0000882D ; ---------------------------------------------------------------------------
.text$mn:0000882D                 jmp     short loc_8831
.text$mn:0000882F ; ---------------------------------------------------------------------------
.text$mn:0000882F
.text$mn:0000882F loc_882F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000882F                 mov     al, 1
.text$mn:00008831
.text$mn:00008831 loc_8831:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00008831                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00008831                 mov     esp, ebp
.text$mn:00008833                 pop     ebp
.text$mn:00008834                 retn    4
.text$mn:00008834 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00008834
.text$mn:00008834 ; ---------------------------------------------------------------------------
.text$mn:00008837                 align 4
.text$mn:00008837 _text$mn        ends
.text$mn:00008837
.text$mn:00008838 ; ===========================================================================
.text$mn:00008838
.text$mn:00008838 ; Segment type: Pure code
.text$mn:00008838 ; Segment permissions: Read/Execute
.text$mn:00008838 _text$mn        segment para public 'CODE' use32
.text$mn:00008838                 assume cs:_text$mn
.text$mn:00008838                 ;org 8838h
.text$mn:00008838 ; COMDAT (pick any)
.text$mn:00008838                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008838
.text$mn:00008838 ; =============== S U B R O U T I N E =======================================
.text$mn:00008838
.text$mn:00008838 ; Attributes: bp-based frame
.text$mn:00008838
.text$mn:00008838 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00008838                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:00008838 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:00008838                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+2Cp
.text$mn:00008838                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:00008838
.text$mn:00008838 var_4           = dword ptr -4
.text$mn:00008838 arg_0           = dword ptr  8
.text$mn:00008838
.text$mn:00008838                 push    ebp
.text$mn:00008839                 mov     ebp, esp
.text$mn:0000883B                 push    ecx
.text$mn:0000883C                 mov     [ebp+var_4], ecx
.text$mn:0000883F                 cmp     [ebp+arg_0], 0
.text$mn:00008843                 jz      short loc_8868
.text$mn:00008845                 mov     ecx, [ebp+var_4]
.text$mn:00008848                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000884D                 cmp     [ebp+arg_0], eax
.text$mn:00008850                 jb      short loc_8868
.text$mn:00008852                 mov     ecx, [ebp+var_4]
.text$mn:00008855                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000885A                 mov     ecx, [ebp+var_4]
.text$mn:0000885D                 mov     edx, [ecx+14h]
.text$mn:00008860                 lea     eax, [eax+edx*2]
.text$mn:00008863                 cmp     eax, [ebp+arg_0]
.text$mn:00008866                 ja      short loc_886E
.text$mn:00008868
.text$mn:00008868 loc_8868:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:00008868                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:00008868                 xor     al, al
.text$mn:0000886A                 jmp     short loc_8870
.text$mn:0000886C ; ---------------------------------------------------------------------------
.text$mn:0000886C                 jmp     short loc_8870
.text$mn:0000886E ; ---------------------------------------------------------------------------
.text$mn:0000886E
.text$mn:0000886E loc_886E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:0000886E                 mov     al, 1
.text$mn:00008870
.text$mn:00008870 loc_8870:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:00008870                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:00008870                 mov     esp, ebp
.text$mn:00008872                 pop     ebp
.text$mn:00008873                 retn    4
.text$mn:00008873 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:00008873
.text$mn:00008873 ; ---------------------------------------------------------------------------
.text$mn:00008876                 align 4
.text$mn:00008876 _text$mn        ends
.text$mn:00008876
.text$mn:00008878 ; ===========================================================================
.text$mn:00008878
.text$mn:00008878 ; Segment type: Pure code
.text$mn:00008878 ; Segment permissions: Read/Execute
.text$mn:00008878 _text$mn        segment para public 'CODE' use32
.text$mn:00008878                 assume cs:_text$mn
.text$mn:00008878                 ;org 8878h
.text$mn:00008878 ; COMDAT (pick any)
.text$mn:00008878                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008878
.text$mn:00008878 ; =============== S U B R O U T I N E =======================================
.text$mn:00008878
.text$mn:00008878 ; Attributes: bp-based frame
.text$mn:00008878
.text$mn:00008878 ; protected: bool __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Inside(struct MenuItemUnit const *)const
.text$mn:00008878                 public ?_Inside@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBE_NPBUMenuItemUnit@@@Z
.text$mn:00008878 ?_Inside@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBE_NPBUMenuItemUnit@@@Z proc near
.text$mn:00008878                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+19p
.text$mn:00008878
.text$mn:00008878 var_8           = dword ptr -8
.text$mn:00008878 var_4           = dword ptr -4
.text$mn:00008878 arg_0           = dword ptr  8
.text$mn:00008878
.text$mn:00008878                 push    ebp
.text$mn:00008879                 mov     ebp, esp
.text$mn:0000887B                 sub     esp, 8
.text$mn:0000887E                 mov     [ebp+var_4], ecx
.text$mn:00008881                 mov     eax, [ebp+var_4]
.text$mn:00008884                 mov     ecx, [ebp+arg_0]
.text$mn:00008887                 cmp     ecx, [eax+8]
.text$mn:0000888A                 jnb     short loc_88A0
.text$mn:0000888C                 mov     edx, [ebp+var_4]
.text$mn:0000888F                 mov     eax, [edx+4]
.text$mn:00008892                 cmp     eax, [ebp+arg_0]
.text$mn:00008895                 ja      short loc_88A0
.text$mn:00008897                 mov     [ebp+var_8], 1
.text$mn:0000889E                 jmp     short loc_88A7
.text$mn:000088A0 ; ---------------------------------------------------------------------------
.text$mn:000088A0
.text$mn:000088A0 loc_88A0:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Inside(MenuItemUnit const *)+12j
.text$mn:000088A0                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Inside(MenuItemUnit const *)+1Dj
.text$mn:000088A0                 mov     [ebp+var_8], 0
.text$mn:000088A7
.text$mn:000088A7 loc_88A7:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Inside(MenuItemUnit const *)+26j
.text$mn:000088A7                 mov     al, byte ptr [ebp+var_8]
.text$mn:000088AA                 mov     esp, ebp
.text$mn:000088AC                 pop     ebp
.text$mn:000088AD                 retn    4
.text$mn:000088AD ?_Inside@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBE_NPBUMenuItemUnit@@@Z endp
.text$mn:000088AD
.text$mn:000088AD _text$mn        ends
.text$mn:000088AD
.text$mn:000088B0 ; ===========================================================================
.text$mn:000088B0
.text$mn:000088B0 ; Segment type: Pure code
.text$mn:000088B0 ; Segment permissions: Read/Execute
.text$mn:000088B0 _text$mn        segment para public 'CODE' use32
.text$mn:000088B0                 assume cs:_text$mn
.text$mn:000088B0                 ;org 88B0h
.text$mn:000088B0 ; COMDAT (pick any)
.text$mn:000088B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000088B0
.text$mn:000088B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000088B0
.text$mn:000088B0 ; Attributes: bp-based frame
.text$mn:000088B0
.text$mn:000088B0 ; protected: bool __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Inside(struct recordedMacroStep const *)const
.text$mn:000088B0                 public ?_Inside@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBE_NPBUrecordedMacroStep@@@Z
.text$mn:000088B0 ?_Inside@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBE_NPBUrecordedMacroStep@@@Z proc near
.text$mn:000088B0                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::push_back(recordedMacroStep &&)+19p
.text$mn:000088B0
.text$mn:000088B0 var_8           = dword ptr -8
.text$mn:000088B0 var_4           = dword ptr -4
.text$mn:000088B0 arg_0           = dword ptr  8
.text$mn:000088B0
.text$mn:000088B0                 push    ebp
.text$mn:000088B1                 mov     ebp, esp
.text$mn:000088B3                 sub     esp, 8
.text$mn:000088B6                 mov     [ebp+var_4], ecx
.text$mn:000088B9                 mov     eax, [ebp+var_4]
.text$mn:000088BC                 mov     ecx, [ebp+arg_0]
.text$mn:000088BF                 cmp     ecx, [eax+8]
.text$mn:000088C2                 jnb     short loc_88D8
.text$mn:000088C4                 mov     edx, [ebp+var_4]
.text$mn:000088C7                 mov     eax, [edx+4]
.text$mn:000088CA                 cmp     eax, [ebp+arg_0]
.text$mn:000088CD                 ja      short loc_88D8
.text$mn:000088CF                 mov     [ebp+var_8], 1
.text$mn:000088D6                 jmp     short loc_88DF
.text$mn:000088D8 ; ---------------------------------------------------------------------------
.text$mn:000088D8
.text$mn:000088D8 loc_88D8:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Inside(recordedMacroStep const *)+12j
.text$mn:000088D8                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Inside(recordedMacroStep const *)+1Dj
.text$mn:000088D8                 mov     [ebp+var_8], 0
.text$mn:000088DF
.text$mn:000088DF loc_88DF:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Inside(recordedMacroStep const *)+26j
.text$mn:000088DF                 mov     al, byte ptr [ebp+var_8]
.text$mn:000088E2                 mov     esp, ebp
.text$mn:000088E4                 pop     ebp
.text$mn:000088E5                 retn    4
.text$mn:000088E5 ?_Inside@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBE_NPBUrecordedMacroStep@@@Z endp
.text$mn:000088E5
.text$mn:000088E5 _text$mn        ends
.text$mn:000088E5
.text$mn:000088E8 ; ===========================================================================
.text$mn:000088E8
.text$mn:000088E8 ; Segment type: Pure code
.text$mn:000088E8 ; Segment permissions: Read/Execute
.text$mn:000088E8 _text$mn        segment para public 'CODE' use32
.text$mn:000088E8                 assume cs:_text$mn
.text$mn:000088E8                 ;org 88E8h
.text$mn:000088E8 ; COMDAT (pick any)
.text$mn:000088E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000088E8
.text$mn:000088E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000088E8
.text$mn:000088E8 ; Attributes: bp-based frame
.text$mn:000088E8
.text$mn:000088E8 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:000088E8                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:000088E8 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:000088E8                                         ; CODE XREF: $LN19+14p
.text$mn:000088E8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:000088E8
.text$mn:000088E8 var_8           = dword ptr -8
.text$mn:000088E8 var_4           = dword ptr -4
.text$mn:000088E8
.text$mn:000088E8                 push    ebp
.text$mn:000088E9                 mov     ebp, esp
.text$mn:000088EB                 sub     esp, 8
.text$mn:000088EE                 mov     [ebp+var_4], ecx
.text$mn:000088F1                 mov     eax, [ebp+var_4]
.text$mn:000088F4                 cmp     dword ptr [eax+18h], 10h
.text$mn:000088F8                 jb      short loc_890E
.text$mn:000088FA                 mov     ecx, [ebp+var_4]
.text$mn:000088FD                 mov     edx, [ecx+4]
.text$mn:00008900                 push    edx
.text$mn:00008901                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00008906                 add     esp, 4
.text$mn:00008909                 mov     [ebp+var_8], eax
.text$mn:0000890C                 jmp     short loc_8917
.text$mn:0000890E ; ---------------------------------------------------------------------------
.text$mn:0000890E
.text$mn:0000890E loc_890E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000890E                 mov     eax, [ebp+var_4]
.text$mn:00008911                 add     eax, 4
.text$mn:00008914                 mov     [ebp+var_8], eax
.text$mn:00008917
.text$mn:00008917 loc_8917:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00008917                 mov     eax, [ebp+var_8]
.text$mn:0000891A                 mov     esp, ebp
.text$mn:0000891C                 pop     ebp
.text$mn:0000891D                 retn
.text$mn:0000891D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:0000891D
.text$mn:0000891D ; ---------------------------------------------------------------------------
.text$mn:0000891E                 align 10h
.text$mn:0000891E _text$mn        ends
.text$mn:0000891E
.text$mn:00008920 ; ===========================================================================
.text$mn:00008920
.text$mn:00008920 ; Segment type: Pure code
.text$mn:00008920 ; Segment permissions: Read/Execute
.text$mn:00008920 _text$mn        segment para public 'CODE' use32
.text$mn:00008920                 assume cs:_text$mn
.text$mn:00008920                 ;org 8920h
.text$mn:00008920 ; COMDAT (pick any)
.text$mn:00008920                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008920
.text$mn:00008920 ; =============== S U B R O U T I N E =======================================
.text$mn:00008920
.text$mn:00008920 ; Attributes: bp-based frame
.text$mn:00008920
.text$mn:00008920 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00008920                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00008920 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00008920                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00008920
.text$mn:00008920 var_8           = dword ptr -8
.text$mn:00008920 var_4           = dword ptr -4
.text$mn:00008920
.text$mn:00008920                 push    ebp
.text$mn:00008921                 mov     ebp, esp
.text$mn:00008923                 sub     esp, 8
.text$mn:00008926                 mov     [ebp+var_4], ecx
.text$mn:00008929                 mov     eax, [ebp+var_4]
.text$mn:0000892C                 cmp     dword ptr [eax+18h], 10h
.text$mn:00008930                 jb      short loc_8946
.text$mn:00008932                 mov     ecx, [ebp+var_4]
.text$mn:00008935                 mov     edx, [ecx+4]
.text$mn:00008938                 push    edx
.text$mn:00008939                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000893E                 add     esp, 4
.text$mn:00008941                 mov     [ebp+var_8], eax
.text$mn:00008944                 jmp     short loc_894F
.text$mn:00008946 ; ---------------------------------------------------------------------------
.text$mn:00008946
.text$mn:00008946 loc_8946:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00008946                 mov     eax, [ebp+var_4]
.text$mn:00008949                 add     eax, 4
.text$mn:0000894C                 mov     [ebp+var_8], eax
.text$mn:0000894F
.text$mn:0000894F loc_894F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000894F                 mov     eax, [ebp+var_8]
.text$mn:00008952                 mov     esp, ebp
.text$mn:00008954                 pop     ebp
.text$mn:00008955                 retn
.text$mn:00008955 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00008955
.text$mn:00008955 ; ---------------------------------------------------------------------------
.text$mn:00008956                 align 4
.text$mn:00008956 _text$mn        ends
.text$mn:00008956
.text$mn:00008958 ; ===========================================================================
.text$mn:00008958
.text$mn:00008958 ; Segment type: Pure code
.text$mn:00008958 ; Segment permissions: Read/Execute
.text$mn:00008958 _text$mn        segment para public 'CODE' use32
.text$mn:00008958                 assume cs:_text$mn
.text$mn:00008958                 ;org 8958h
.text$mn:00008958 ; COMDAT (pick any)
.text$mn:00008958                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008958
.text$mn:00008958 ; =============== S U B R O U T I N E =======================================
.text$mn:00008958
.text$mn:00008958 ; Attributes: bp-based frame
.text$mn:00008958
.text$mn:00008958 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00008958                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:00008958 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:00008958                                         ; CODE XREF: $LN19_0+14p
.text$mn:00008958                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:00008958
.text$mn:00008958 var_8           = dword ptr -8
.text$mn:00008958 var_4           = dword ptr -4
.text$mn:00008958
.text$mn:00008958                 push    ebp
.text$mn:00008959                 mov     ebp, esp
.text$mn:0000895B                 sub     esp, 8
.text$mn:0000895E                 mov     [ebp+var_4], ecx
.text$mn:00008961                 mov     eax, [ebp+var_4]
.text$mn:00008964                 cmp     dword ptr [eax+18h], 8
.text$mn:00008968                 jb      short loc_897E
.text$mn:0000896A                 mov     ecx, [ebp+var_4]
.text$mn:0000896D                 mov     edx, [ecx+4]
.text$mn:00008970                 push    edx
.text$mn:00008971                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00008976                 add     esp, 4
.text$mn:00008979                 mov     [ebp+var_8], eax
.text$mn:0000897C                 jmp     short loc_8987
.text$mn:0000897E ; ---------------------------------------------------------------------------
.text$mn:0000897E
.text$mn:0000897E loc_897E:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000897E                 mov     eax, [ebp+var_4]
.text$mn:00008981                 add     eax, 4
.text$mn:00008984                 mov     [ebp+var_8], eax
.text$mn:00008987
.text$mn:00008987 loc_8987:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00008987                 mov     eax, [ebp+var_8]
.text$mn:0000898A                 mov     esp, ebp
.text$mn:0000898C                 pop     ebp
.text$mn:0000898D                 retn
.text$mn:0000898D ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:0000898D
.text$mn:0000898D ; ---------------------------------------------------------------------------
.text$mn:0000898E                 align 10h
.text$mn:0000898E _text$mn        ends
.text$mn:0000898E
.text$mn:00008990 ; ===========================================================================
.text$mn:00008990
.text$mn:00008990 ; Segment type: Pure code
.text$mn:00008990 ; Segment permissions: Read/Execute
.text$mn:00008990 _text$mn        segment para public 'CODE' use32
.text$mn:00008990                 assume cs:_text$mn
.text$mn:00008990                 ;org 8990h
.text$mn:00008990 ; COMDAT (pick any)
.text$mn:00008990                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008990
.text$mn:00008990 ; =============== S U B R O U T I N E =======================================
.text$mn:00008990
.text$mn:00008990 ; Attributes: bp-based frame
.text$mn:00008990
.text$mn:00008990 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00008990                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00008990 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00008990                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+80p
.text$mn:00008990                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp ...
.text$mn:00008990
.text$mn:00008990 var_8           = dword ptr -8
.text$mn:00008990 var_4           = dword ptr -4
.text$mn:00008990
.text$mn:00008990                 push    ebp
.text$mn:00008991                 mov     ebp, esp
.text$mn:00008993                 sub     esp, 8
.text$mn:00008996                 mov     [ebp+var_4], ecx
.text$mn:00008999                 mov     eax, [ebp+var_4]
.text$mn:0000899C                 cmp     dword ptr [eax+18h], 8
.text$mn:000089A0                 jb      short loc_89B6
.text$mn:000089A2                 mov     ecx, [ebp+var_4]
.text$mn:000089A5                 mov     edx, [ecx+4]
.text$mn:000089A8                 push    edx
.text$mn:000089A9                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000089AE                 add     esp, 4
.text$mn:000089B1                 mov     [ebp+var_8], eax
.text$mn:000089B4                 jmp     short loc_89BF
.text$mn:000089B6 ; ---------------------------------------------------------------------------
.text$mn:000089B6
.text$mn:000089B6 loc_89B6:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:000089B6                 mov     eax, [ebp+var_4]
.text$mn:000089B9                 add     eax, 4
.text$mn:000089BC                 mov     [ebp+var_8], eax
.text$mn:000089BF
.text$mn:000089BF loc_89BF:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:000089BF                 mov     eax, [ebp+var_8]
.text$mn:000089C2                 mov     esp, ebp
.text$mn:000089C4                 pop     ebp
.text$mn:000089C5                 retn
.text$mn:000089C5 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:000089C5
.text$mn:000089C5 ; ---------------------------------------------------------------------------
.text$mn:000089C6                 align 4
.text$mn:000089C6 _text$mn        ends
.text$mn:000089C6
.text$mn:000089C8 ; ===========================================================================
.text$mn:000089C8
.text$mn:000089C8 ; Segment type: Pure code
.text$mn:000089C8 ; Segment permissions: Read/Execute
.text$mn:000089C8 _text$mn        segment para public 'CODE' use32
.text$mn:000089C8                 assume cs:_text$mn
.text$mn:000089C8                 ;org 89C8h
.text$mn:000089C8 ; COMDAT (pick any)
.text$mn:000089C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000089C8
.text$mn:000089C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000089C8
.text$mn:000089C8 ; Attributes: bp-based frame
.text$mn:000089C8
.text$mn:000089C8 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:000089C8                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000089C8 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:000089C8                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:000089C8                                         ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Free_proxy(void)+14p ...
.text$mn:000089C8
.text$mn:000089C8 var_18          = byte ptr -18h
.text$mn:000089C8 var_14          = dword ptr -14h
.text$mn:000089C8 var_10          = dword ptr -10h
.text$mn:000089C8 var_C           = dword ptr -0Ch
.text$mn:000089C8 var_4           = dword ptr -4
.text$mn:000089C8
.text$mn:000089C8                 push    ebp
.text$mn:000089C9                 mov     ebp, esp
.text$mn:000089CB                 push    0FFFFFFFFh
.text$mn:000089CD                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000089D2                 mov     eax, large fs:0
.text$mn:000089D8                 push    eax
.text$mn:000089D9                 sub     esp, 0Ch
.text$mn:000089DC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000089E1                 xor     eax, ebp
.text$mn:000089E3                 push    eax
.text$mn:000089E4                 lea     eax, [ebp+var_C]
.text$mn:000089E7                 mov     large fs:0, eax
.text$mn:000089ED                 mov     [ebp+var_14], ecx
.text$mn:000089F0                 mov     eax, [ebp+var_14]
.text$mn:000089F3                 cmp     dword ptr [eax], 0
.text$mn:000089F6                 jz      short loc_8A53
.text$mn:000089F8                 push    3               ; int
.text$mn:000089FA                 lea     ecx, [ebp+var_18] ; this
.text$mn:000089FD                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00008A02                 mov     [ebp+var_4], 0
.text$mn:00008A09                 mov     ecx, [ebp+var_14]
.text$mn:00008A0C                 mov     edx, [ecx]
.text$mn:00008A0E                 add     edx, 4
.text$mn:00008A11                 mov     [ebp+var_10], edx
.text$mn:00008A14                 jmp     short loc_8A23
.text$mn:00008A16 ; ---------------------------------------------------------------------------
.text$mn:00008A16
.text$mn:00008A16 loc_8A16:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00008A16                 mov     eax, [ebp+var_10]
.text$mn:00008A19                 mov     ecx, [eax]
.text$mn:00008A1B                 mov     edx, [ebp+var_10]
.text$mn:00008A1E                 mov     eax, [ecx+4]
.text$mn:00008A21                 mov     [edx], eax
.text$mn:00008A23
.text$mn:00008A23 loc_8A23:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00008A23                 mov     ecx, [ebp+var_10]
.text$mn:00008A26                 cmp     dword ptr [ecx], 0
.text$mn:00008A29                 jz      short loc_8A38
.text$mn:00008A2B                 mov     edx, [ebp+var_10]
.text$mn:00008A2E                 mov     eax, [edx]
.text$mn:00008A30                 mov     dword ptr [eax], 0
.text$mn:00008A36                 jmp     short loc_8A16
.text$mn:00008A38 ; ---------------------------------------------------------------------------
.text$mn:00008A38
.text$mn:00008A38 loc_8A38:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00008A38                 mov     ecx, [ebp+var_14]
.text$mn:00008A3B                 mov     edx, [ecx]
.text$mn:00008A3D                 mov     dword ptr [edx+4], 0
.text$mn:00008A44                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008A4B                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008A4E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008A53
.text$mn:00008A53 loc_8A53:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00008A53                 mov     ecx, [ebp+var_C]
.text$mn:00008A56                 mov     large fs:0, ecx
.text$mn:00008A5D                 pop     ecx
.text$mn:00008A5E                 mov     esp, ebp
.text$mn:00008A60                 pop     ebp
.text$mn:00008A61                 retn
.text$mn:00008A61 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00008A61
.text$mn:00008A61 ; ---------------------------------------------------------------------------
.text$mn:00008A62                 align 4
.text$mn:00008A62 _text$mn        ends
.text$mn:00008A62
.text$x:00008A64 ; ===========================================================================
.text$x:00008A64
.text$x:00008A64 ; Segment type: Pure code
.text$x:00008A64 ; Segment permissions: Read/Execute
.text$x:00008A64 _text$x         segment para public 'CODE' use32
.text$x:00008A64                 assume cs:_text$x
.text$x:00008A64                 ;org 8A64h
.text$x:00008A64 ; COMDAT (pick associative to section at 89C8)
.text$x:00008A64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008A64
.text$x:00008A64 ; =============== S U B R O U T I N E =======================================
.text$x:00008A64
.text$x:00008A64
.text$x:00008A64 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00008A64                                         ; DATA XREF: .xdata$x:0000B430o
.text$x:00008A64                 lea     ecx, [ebp-18h]  ; this
.text$x:00008A67                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008A67 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00008A67
.text$x:00008A6C
.text$x:00008A6C ; =============== S U B R O U T I N E =======================================
.text$x:00008A6C
.text$x:00008A6C
.text$x:00008A6C __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00008A6C                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00008A6C
.text$x:00008A6C arg_4           = dword ptr  8
.text$x:00008A6C
.text$x:00008A6C                 mov     edx, [esp+arg_4]
.text$x:00008A70                 lea     eax, [edx+0Ch]
.text$x:00008A73                 mov     ecx, [edx-10h]
.text$x:00008A76                 xor     ecx, eax
.text$x:00008A78                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008A7D                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00008A82                 jmp     ___CxxFrameHandler3
.text$x:00008A82 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00008A82
.text$x:00008A82 ; ---------------------------------------------------------------------------
.text$x:00008A87                 align 4
.text$x:00008A87 _text$x         ends
.text$x:00008A87
.text$mn:00008A88 ; ===========================================================================
.text$mn:00008A88
.text$mn:00008A88 ; Segment type: Pure code
.text$mn:00008A88 ; Segment permissions: Read/Execute
.text$mn:00008A88 _text$mn        segment para public 'CODE' use32
.text$mn:00008A88                 assume cs:_text$mn
.text$mn:00008A88                 ;org 8A88h
.text$mn:00008A88 ; COMDAT (pick any)
.text$mn:00008A88                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008A88
.text$mn:00008A88 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A88
.text$mn:00008A88 ; Attributes: bp-based frame
.text$mn:00008A88
.text$mn:00008A88 ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:00008A88                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:00008A88 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00008A88                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:00008A88                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:00008A88
.text$mn:00008A88 var_8           = dword ptr -8
.text$mn:00008A88 var_4           = dword ptr -4
.text$mn:00008A88
.text$mn:00008A88                 push    ebp
.text$mn:00008A89                 mov     ebp, esp
.text$mn:00008A8B                 sub     esp, 8
.text$mn:00008A8E                 mov     [ebp+var_8], ecx
.text$mn:00008A91                 mov     eax, [ebp+var_8]
.text$mn:00008A94                 cmp     dword ptr [eax], 0
.text$mn:00008A97                 jz      short loc_8AF6
.text$mn:00008A99                 mov     ecx, [ebp+var_8]
.text$mn:00008A9C                 mov     edx, [ecx]
.text$mn:00008A9E                 add     edx, 4
.text$mn:00008AA1                 mov     [ebp+var_4], edx
.text$mn:00008AA4
.text$mn:00008AA4 loc_8AA4:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:00008AA4                 mov     eax, [ebp+var_4]
.text$mn:00008AA7                 cmp     dword ptr [eax], 0
.text$mn:00008AAA                 jz      short loc_8AC3
.text$mn:00008AAC                 mov     ecx, [ebp+var_4]
.text$mn:00008AAF                 mov     edx, [ecx]
.text$mn:00008AB1                 cmp     edx, [ebp+var_8]
.text$mn:00008AB4                 jz      short loc_8AC3
.text$mn:00008AB6                 mov     eax, [ebp+var_4]
.text$mn:00008AB9                 mov     ecx, [eax]
.text$mn:00008ABB                 add     ecx, 4
.text$mn:00008ABE                 mov     [ebp+var_4], ecx
.text$mn:00008AC1                 jmp     short loc_8AA4
.text$mn:00008AC3 ; ---------------------------------------------------------------------------
.text$mn:00008AC3
.text$mn:00008AC3 loc_8AC3:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:00008AC3                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:00008AC3                 mov     edx, [ebp+var_4]
.text$mn:00008AC6                 cmp     dword ptr [edx], 0
.text$mn:00008AC9                 jnz     short loc_8AE2
.text$mn:00008ACB                 push    0C9h ; '+'      ; unsigned int
.text$mn:00008AD0                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008AD5                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:00008ADA                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00008ADF                 add     esp, 0Ch
.text$mn:00008AE2
.text$mn:00008AE2 loc_8AE2:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:00008AE2                 mov     eax, [ebp+var_4]
.text$mn:00008AE5                 mov     ecx, [ebp+var_8]
.text$mn:00008AE8                 mov     edx, [ecx+4]
.text$mn:00008AEB                 mov     [eax], edx
.text$mn:00008AED                 mov     eax, [ebp+var_8]
.text$mn:00008AF0                 mov     dword ptr [eax], 0
.text$mn:00008AF6
.text$mn:00008AF6 loc_8AF6:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:00008AF6                 mov     esp, ebp
.text$mn:00008AF8                 pop     ebp
.text$mn:00008AF9                 retn
.text$mn:00008AF9 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00008AF9
.text$mn:00008AF9 ; ---------------------------------------------------------------------------
.text$mn:00008AFA                 align 4
.text$mn:00008AFA _text$mn        ends
.text$mn:00008AFA
.text$mn:00008AFC ; ===========================================================================
.text$mn:00008AFC
.text$mn:00008AFC ; Segment type: Pure code
.text$mn:00008AFC ; Segment permissions: Read/Execute
.text$mn:00008AFC _text$mn        segment para public 'CODE' use32
.text$mn:00008AFC                 assume cs:_text$mn
.text$mn:00008AFC                 ;org 8AFCh
.text$mn:00008AFC ; COMDAT (pick any)
.text$mn:00008AFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008AFC
.text$mn:00008AFC ; =============== S U B R O U T I N E =======================================
.text$mn:00008AFC
.text$mn:00008AFC ; Attributes: bp-based frame
.text$mn:00008AFC
.text$mn:00008AFC ; protected: void __thiscall std::deque<unsigned int, class std::allocator<unsigned int>>::_Orphan_off(unsigned int)const
.text$mn:00008AFC                 public ?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z
.text$mn:00008AFC ?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z proc near
.text$mn:00008AFC                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::pop_back(void)+4Fp
.text$mn:00008AFC
.text$mn:00008AFC var_20          = byte ptr -20h
.text$mn:00008AFC var_1C          = dword ptr -1Ch
.text$mn:00008AFC var_18          = dword ptr -18h
.text$mn:00008AFC var_14          = dword ptr -14h
.text$mn:00008AFC var_10          = dword ptr -10h
.text$mn:00008AFC var_C           = dword ptr -0Ch
.text$mn:00008AFC var_4           = dword ptr -4
.text$mn:00008AFC arg_0           = dword ptr  8
.text$mn:00008AFC
.text$mn:00008AFC                 push    ebp
.text$mn:00008AFD                 mov     ebp, esp
.text$mn:00008AFF                 push    0FFFFFFFFh
.text$mn:00008B01                 push    offset __ehhandler$?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z
.text$mn:00008B06                 mov     eax, large fs:0
.text$mn:00008B0C                 push    eax
.text$mn:00008B0D                 sub     esp, 14h
.text$mn:00008B10                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008B15                 xor     eax, ebp
.text$mn:00008B17                 push    eax
.text$mn:00008B18                 lea     eax, [ebp+var_C]
.text$mn:00008B1B                 mov     large fs:0, eax
.text$mn:00008B21                 mov     [ebp+var_14], ecx
.text$mn:00008B24                 mov     eax, [ebp+var_14]
.text$mn:00008B27                 mov     ecx, [eax+0Ch]
.text$mn:00008B2A                 mov     edx, [ebp+var_14]
.text$mn:00008B2D                 add     ecx, [edx+10h]
.text$mn:00008B30                 mov     eax, [ebp+arg_0]
.text$mn:00008B33                 add     eax, 1
.text$mn:00008B36                 cmp     ecx, eax
.text$mn:00008B38                 ja      short loc_8B43
.text$mn:00008B3A                 mov     [ebp+var_18], 0FFFFFFFFh
.text$mn:00008B41                 jmp     short loc_8B49
.text$mn:00008B43 ; ---------------------------------------------------------------------------
.text$mn:00008B43
.text$mn:00008B43 loc_8B43:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Orphan_off(uint)+3Cj
.text$mn:00008B43                 mov     ecx, [ebp+arg_0]
.text$mn:00008B46                 mov     [ebp+var_18], ecx
.text$mn:00008B49
.text$mn:00008B49 loc_8B49:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Orphan_off(uint)+45j
.text$mn:00008B49                 mov     edx, [ebp+var_18]
.text$mn:00008B4C                 mov     [ebp+var_1C], edx
.text$mn:00008B4F                 mov     eax, [ebp+var_14]
.text$mn:00008B52                 mov     ecx, [ebp+arg_0]
.text$mn:00008B55                 cmp     ecx, [eax+0Ch]
.text$mn:00008B58                 jnz     short loc_8B61
.text$mn:00008B5A                 mov     [ebp+arg_0], 0
.text$mn:00008B61
.text$mn:00008B61 loc_8B61:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Orphan_off(uint)+5Cj
.text$mn:00008B61                 push    3               ; int
.text$mn:00008B63                 lea     ecx, [ebp+var_20] ; this
.text$mn:00008B66                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00008B6B                 mov     [ebp+var_4], 0
.text$mn:00008B72                 mov     ecx, [ebp+var_14] ; this
.text$mn:00008B75                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00008B7A                 mov     [ebp+var_10], eax
.text$mn:00008B7D                 cmp     [ebp+var_10], 0
.text$mn:00008B81                 jz      short loc_8BD1
.text$mn:00008B83
.text$mn:00008B83 loc_8B83:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Orphan_off(uint):loc_8BCFj
.text$mn:00008B83                 mov     edx, [ebp+var_10]
.text$mn:00008B86                 cmp     dword ptr [edx], 0
.text$mn:00008B89                 jz      short loc_8BD1
.text$mn:00008B8B                 mov     eax, [ebp+var_10]
.text$mn:00008B8E                 mov     ecx, [eax]
.text$mn:00008B90                 mov     edx, [ecx+8]
.text$mn:00008B93                 cmp     edx, [ebp+arg_0]
.text$mn:00008B96                 jb      short loc_8BA5
.text$mn:00008B98                 mov     eax, [ebp+var_10]
.text$mn:00008B9B                 mov     ecx, [eax]
.text$mn:00008B9D                 mov     edx, [ebp+var_1C]
.text$mn:00008BA0                 cmp     edx, [ecx+8]
.text$mn:00008BA3                 jnb     short loc_8BB4
.text$mn:00008BA5
.text$mn:00008BA5 loc_8BA5:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Orphan_off(uint)+9Aj
.text$mn:00008BA5                 mov     eax, [ebp+var_10]
.text$mn:00008BA8                 mov     ecx, [eax]      ; this
.text$mn:00008BAA                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008BAF                 mov     [ebp+var_10], eax
.text$mn:00008BB2                 jmp     short loc_8BCF
.text$mn:00008BB4 ; ---------------------------------------------------------------------------
.text$mn:00008BB4
.text$mn:00008BB4 loc_8BB4:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Orphan_off(uint)+A7j
.text$mn:00008BB4                 mov     ecx, [ebp+var_10]
.text$mn:00008BB7                 mov     ecx, [ecx]      ; this
.text$mn:00008BB9                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00008BBE                 mov     edx, [ebp+var_10]
.text$mn:00008BC1                 mov     ecx, [edx]      ; this
.text$mn:00008BC3                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008BC8                 mov     ecx, [ebp+var_10]
.text$mn:00008BCB                 mov     edx, [eax]
.text$mn:00008BCD                 mov     [ecx], edx
.text$mn:00008BCF
.text$mn:00008BCF loc_8BCF:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Orphan_off(uint)+B6j
.text$mn:00008BCF                 jmp     short loc_8B83
.text$mn:00008BD1 ; ---------------------------------------------------------------------------
.text$mn:00008BD1
.text$mn:00008BD1 loc_8BD1:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Orphan_off(uint)+85j
.text$mn:00008BD1                                         ; std::deque<uint,std::allocator<uint>>::_Orphan_off(uint)+8Dj
.text$mn:00008BD1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008BD8                 lea     ecx, [ebp+var_20] ; this
.text$mn:00008BDB                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008BE0                 mov     ecx, [ebp+var_C]
.text$mn:00008BE3                 mov     large fs:0, ecx
.text$mn:00008BEA                 pop     ecx
.text$mn:00008BEB                 mov     esp, ebp
.text$mn:00008BED                 pop     ebp
.text$mn:00008BEE                 retn    4
.text$mn:00008BEE ?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z endp
.text$mn:00008BEE
.text$mn:00008BEE ; ---------------------------------------------------------------------------
.text$mn:00008BF1                 align 4
.text$mn:00008BF1 _text$mn        ends
.text$mn:00008BF1
.text$x:00008BF4 ; ===========================================================================
.text$x:00008BF4
.text$x:00008BF4 ; Segment type: Pure code
.text$x:00008BF4 ; Segment permissions: Read/Execute
.text$x:00008BF4 _text$x         segment para public 'CODE' use32
.text$x:00008BF4                 assume cs:_text$x
.text$x:00008BF4                 ;org 8BF4h
.text$x:00008BF4 ; COMDAT (pick associative to section at 8AFC)
.text$x:00008BF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008BF4
.text$x:00008BF4 ; =============== S U B R O U T I N E =======================================
.text$x:00008BF4
.text$x:00008BF4
.text$x:00008BF4 __unwindfunclet$?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z$0 proc near
.text$x:00008BF4                                         ; DATA XREF: .xdata$x:0000BFE8o
.text$x:00008BF4                 lea     ecx, [ebp-20h]  ; this
.text$x:00008BF7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008BF7 __unwindfunclet$?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z$0 endp
.text$x:00008BF7
.text$x:00008BFC
.text$x:00008BFC ; =============== S U B R O U T I N E =======================================
.text$x:00008BFC
.text$x:00008BFC
.text$x:00008BFC __ehhandler$?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z proc near
.text$x:00008BFC                                         ; DATA XREF: std::deque<uint,std::allocator<uint>>::_Orphan_off(uint)+5o
.text$x:00008BFC
.text$x:00008BFC arg_4           = dword ptr  8
.text$x:00008BFC
.text$x:00008BFC                 mov     edx, [esp+arg_4]
.text$x:00008C00                 lea     eax, [edx+0Ch]
.text$x:00008C03                 mov     ecx, [edx-18h]
.text$x:00008C06                 xor     ecx, eax
.text$x:00008C08                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008C0D                 mov     eax, offset __ehfuncinfo$?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z
.text$x:00008C12                 jmp     ___CxxFrameHandler3
.text$x:00008C12 __ehhandler$?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z endp
.text$x:00008C12
.text$x:00008C12 ; ---------------------------------------------------------------------------
.text$x:00008C17                 align 4
.text$x:00008C17 _text$x         ends
.text$x:00008C17
.text$mn:00008C18 ; ===========================================================================
.text$mn:00008C18
.text$mn:00008C18 ; Segment type: Pure code
.text$mn:00008C18 ; Segment permissions: Read/Execute
.text$mn:00008C18 _text$mn        segment para public 'CODE' use32
.text$mn:00008C18                 assume cs:_text$mn
.text$mn:00008C18                 ;org 8C18h
.text$mn:00008C18 ; COMDAT (pick any)
.text$mn:00008C18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008C18
.text$mn:00008C18 ; =============== S U B R O U T I N E =======================================
.text$mn:00008C18
.text$mn:00008C18 ; Attributes: bp-based frame
.text$mn:00008C18
.text$mn:00008C18 ; protected: void __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Orphan_range(struct MenuItemUnit *, struct MenuItemUnit *)const
.text$mn:00008C18                 public ?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z
.text$mn:00008C18 ?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z proc near
.text$mn:00008C18                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+6Fp
.text$mn:00008C18                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+DCp
.text$mn:00008C18
.text$mn:00008C18 var_18          = byte ptr -18h
.text$mn:00008C18 var_14          = dword ptr -14h
.text$mn:00008C18 var_10          = dword ptr -10h
.text$mn:00008C18 var_C           = dword ptr -0Ch
.text$mn:00008C18 var_4           = dword ptr -4
.text$mn:00008C18 arg_0           = dword ptr  8
.text$mn:00008C18 arg_4           = dword ptr  0Ch
.text$mn:00008C18
.text$mn:00008C18                 push    ebp
.text$mn:00008C19                 mov     ebp, esp
.text$mn:00008C1B                 push    0FFFFFFFFh
.text$mn:00008C1D                 push    offset __ehhandler$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z
.text$mn:00008C22                 mov     eax, large fs:0
.text$mn:00008C28                 push    eax
.text$mn:00008C29                 sub     esp, 0Ch
.text$mn:00008C2C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008C31                 xor     eax, ebp
.text$mn:00008C33                 push    eax
.text$mn:00008C34                 lea     eax, [ebp+var_C]
.text$mn:00008C37                 mov     large fs:0, eax
.text$mn:00008C3D                 mov     [ebp+var_14], ecx
.text$mn:00008C40                 push    3               ; int
.text$mn:00008C42                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008C45                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00008C4A                 mov     [ebp+var_4], 0
.text$mn:00008C51                 mov     ecx, [ebp+var_14] ; this
.text$mn:00008C54                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00008C59                 mov     [ebp+var_10], eax
.text$mn:00008C5C                 cmp     [ebp+var_10], 0
.text$mn:00008C60                 jz      short loc_8CB0
.text$mn:00008C62
.text$mn:00008C62 loc_8C62:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *):loc_8CAEj
.text$mn:00008C62                 mov     eax, [ebp+var_10]
.text$mn:00008C65                 cmp     dword ptr [eax], 0
.text$mn:00008C68                 jz      short loc_8CB0
.text$mn:00008C6A                 mov     ecx, [ebp+var_10]
.text$mn:00008C6D                 mov     edx, [ecx]
.text$mn:00008C6F                 mov     eax, [edx+8]
.text$mn:00008C72                 cmp     eax, [ebp+arg_0]
.text$mn:00008C75                 jb      short loc_8C84
.text$mn:00008C77                 mov     ecx, [ebp+var_10]
.text$mn:00008C7A                 mov     edx, [ecx]
.text$mn:00008C7C                 mov     eax, [ebp+arg_4]
.text$mn:00008C7F                 cmp     eax, [edx+8]
.text$mn:00008C82                 jnb     short loc_8C93
.text$mn:00008C84
.text$mn:00008C84 loc_8C84:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+5Dj
.text$mn:00008C84                 mov     ecx, [ebp+var_10]
.text$mn:00008C87                 mov     ecx, [ecx]      ; this
.text$mn:00008C89                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008C8E                 mov     [ebp+var_10], eax
.text$mn:00008C91                 jmp     short loc_8CAE
.text$mn:00008C93 ; ---------------------------------------------------------------------------
.text$mn:00008C93
.text$mn:00008C93 loc_8C93:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+6Aj
.text$mn:00008C93                 mov     edx, [ebp+var_10]
.text$mn:00008C96                 mov     ecx, [edx]      ; this
.text$mn:00008C98                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00008C9D                 mov     eax, [ebp+var_10]
.text$mn:00008CA0                 mov     ecx, [eax]      ; this
.text$mn:00008CA2                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008CA7                 mov     ecx, [ebp+var_10]
.text$mn:00008CAA                 mov     edx, [eax]
.text$mn:00008CAC                 mov     [ecx], edx
.text$mn:00008CAE
.text$mn:00008CAE loc_8CAE:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+79j
.text$mn:00008CAE                 jmp     short loc_8C62
.text$mn:00008CB0 ; ---------------------------------------------------------------------------
.text$mn:00008CB0
.text$mn:00008CB0 loc_8CB0:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+48j
.text$mn:00008CB0                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+50j
.text$mn:00008CB0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008CB7                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008CBA                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008CBF                 mov     ecx, [ebp+var_C]
.text$mn:00008CC2                 mov     large fs:0, ecx
.text$mn:00008CC9                 pop     ecx
.text$mn:00008CCA                 mov     esp, ebp
.text$mn:00008CCC                 pop     ebp
.text$mn:00008CCD                 retn    8
.text$mn:00008CCD ?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z endp
.text$mn:00008CCD
.text$mn:00008CCD _text$mn        ends
.text$mn:00008CCD
.text$x:00008CD0 ; ===========================================================================
.text$x:00008CD0
.text$x:00008CD0 ; Segment type: Pure code
.text$x:00008CD0 ; Segment permissions: Read/Execute
.text$x:00008CD0 _text$x         segment para public 'CODE' use32
.text$x:00008CD0                 assume cs:_text$x
.text$x:00008CD0                 ;org 8CD0h
.text$x:00008CD0 ; COMDAT (pick associative to section at 8C18)
.text$x:00008CD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008CD0
.text$x:00008CD0 ; =============== S U B R O U T I N E =======================================
.text$x:00008CD0
.text$x:00008CD0
.text$x:00008CD0 __unwindfunclet$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z$0 proc near
.text$x:00008CD0                                         ; DATA XREF: .xdata$x:0000BCC4o
.text$x:00008CD0                 lea     ecx, [ebp-18h]  ; this
.text$x:00008CD3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008CD3 __unwindfunclet$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z$0 endp
.text$x:00008CD3
.text$x:00008CD8
.text$x:00008CD8 ; =============== S U B R O U T I N E =======================================
.text$x:00008CD8
.text$x:00008CD8
.text$x:00008CD8 __ehhandler$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z proc near
.text$x:00008CD8                                         ; DATA XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)+5o
.text$x:00008CD8
.text$x:00008CD8 arg_4           = dword ptr  8
.text$x:00008CD8
.text$x:00008CD8                 mov     edx, [esp+arg_4]
.text$x:00008CDC                 lea     eax, [edx+0Ch]
.text$x:00008CDF                 mov     ecx, [edx-10h]
.text$x:00008CE2                 xor     ecx, eax
.text$x:00008CE4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008CE9                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z
.text$x:00008CEE                 jmp     ___CxxFrameHandler3
.text$x:00008CEE __ehhandler$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z endp
.text$x:00008CEE
.text$x:00008CEE ; ---------------------------------------------------------------------------
.text$x:00008CF3                 align 4
.text$x:00008CF3 _text$x         ends
.text$x:00008CF3
.text$mn:00008CF4 ; ===========================================================================
.text$mn:00008CF4
.text$mn:00008CF4 ; Segment type: Pure code
.text$mn:00008CF4 ; Segment permissions: Read/Execute
.text$mn:00008CF4 _text$mn        segment para public 'CODE' use32
.text$mn:00008CF4                 assume cs:_text$mn
.text$mn:00008CF4                 ;org 8CF4h
.text$mn:00008CF4 ; COMDAT (pick any)
.text$mn:00008CF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008CF4
.text$mn:00008CF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008CF4
.text$mn:00008CF4 ; Attributes: bp-based frame
.text$mn:00008CF4
.text$mn:00008CF4 ; protected: void __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Orphan_range(struct recordedMacroStep *, struct recordedMacroStep *)const
.text$mn:00008CF4                 public ?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z
.text$mn:00008CF4 ?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z proc near
.text$mn:00008CF4                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::push_back(recordedMacroStep &&)+6Fp
.text$mn:00008CF4                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::push_back(recordedMacroStep &&)+DCp
.text$mn:00008CF4
.text$mn:00008CF4 var_18          = byte ptr -18h
.text$mn:00008CF4 var_14          = dword ptr -14h
.text$mn:00008CF4 var_10          = dword ptr -10h
.text$mn:00008CF4 var_C           = dword ptr -0Ch
.text$mn:00008CF4 var_4           = dword ptr -4
.text$mn:00008CF4 arg_0           = dword ptr  8
.text$mn:00008CF4 arg_4           = dword ptr  0Ch
.text$mn:00008CF4
.text$mn:00008CF4                 push    ebp
.text$mn:00008CF5                 mov     ebp, esp
.text$mn:00008CF7                 push    0FFFFFFFFh
.text$mn:00008CF9                 push    offset __ehhandler$?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z
.text$mn:00008CFE                 mov     eax, large fs:0
.text$mn:00008D04                 push    eax
.text$mn:00008D05                 sub     esp, 0Ch
.text$mn:00008D08                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008D0D                 xor     eax, ebp
.text$mn:00008D0F                 push    eax
.text$mn:00008D10                 lea     eax, [ebp+var_C]
.text$mn:00008D13                 mov     large fs:0, eax
.text$mn:00008D19                 mov     [ebp+var_14], ecx
.text$mn:00008D1C                 push    3               ; int
.text$mn:00008D1E                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008D21                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00008D26                 mov     [ebp+var_4], 0
.text$mn:00008D2D                 mov     ecx, [ebp+var_14] ; this
.text$mn:00008D30                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00008D35                 mov     [ebp+var_10], eax
.text$mn:00008D38                 cmp     [ebp+var_10], 0
.text$mn:00008D3C                 jz      short loc_8D8C
.text$mn:00008D3E
.text$mn:00008D3E loc_8D3E:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Orphan_range(recordedMacroStep *,recordedMacroStep *):loc_8D8Aj
.text$mn:00008D3E                 mov     eax, [ebp+var_10]
.text$mn:00008D41                 cmp     dword ptr [eax], 0
.text$mn:00008D44                 jz      short loc_8D8C
.text$mn:00008D46                 mov     ecx, [ebp+var_10]
.text$mn:00008D49                 mov     edx, [ecx]
.text$mn:00008D4B                 mov     eax, [edx+8]
.text$mn:00008D4E                 cmp     eax, [ebp+arg_0]
.text$mn:00008D51                 jb      short loc_8D60
.text$mn:00008D53                 mov     ecx, [ebp+var_10]
.text$mn:00008D56                 mov     edx, [ecx]
.text$mn:00008D58                 mov     eax, [ebp+arg_4]
.text$mn:00008D5B                 cmp     eax, [edx+8]
.text$mn:00008D5E                 jnb     short loc_8D6F
.text$mn:00008D60
.text$mn:00008D60 loc_8D60:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Orphan_range(recordedMacroStep *,recordedMacroStep *)+5Dj
.text$mn:00008D60                 mov     ecx, [ebp+var_10]
.text$mn:00008D63                 mov     ecx, [ecx]      ; this
.text$mn:00008D65                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008D6A                 mov     [ebp+var_10], eax
.text$mn:00008D6D                 jmp     short loc_8D8A
.text$mn:00008D6F ; ---------------------------------------------------------------------------
.text$mn:00008D6F
.text$mn:00008D6F loc_8D6F:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Orphan_range(recordedMacroStep *,recordedMacroStep *)+6Aj
.text$mn:00008D6F                 mov     edx, [ebp+var_10]
.text$mn:00008D72                 mov     ecx, [edx]      ; this
.text$mn:00008D74                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00008D79                 mov     eax, [ebp+var_10]
.text$mn:00008D7C                 mov     ecx, [eax]      ; this
.text$mn:00008D7E                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00008D83                 mov     ecx, [ebp+var_10]
.text$mn:00008D86                 mov     edx, [eax]
.text$mn:00008D88                 mov     [ecx], edx
.text$mn:00008D8A
.text$mn:00008D8A loc_8D8A:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Orphan_range(recordedMacroStep *,recordedMacroStep *)+79j
.text$mn:00008D8A                 jmp     short loc_8D3E
.text$mn:00008D8C ; ---------------------------------------------------------------------------
.text$mn:00008D8C
.text$mn:00008D8C loc_8D8C:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Orphan_range(recordedMacroStep *,recordedMacroStep *)+48j
.text$mn:00008D8C                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Orphan_range(recordedMacroStep *,recordedMacroStep *)+50j
.text$mn:00008D8C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008D93                 lea     ecx, [ebp+var_18] ; this
.text$mn:00008D96                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00008D9B                 mov     ecx, [ebp+var_C]
.text$mn:00008D9E                 mov     large fs:0, ecx
.text$mn:00008DA5                 pop     ecx
.text$mn:00008DA6                 mov     esp, ebp
.text$mn:00008DA8                 pop     ebp
.text$mn:00008DA9                 retn    8
.text$mn:00008DA9 ?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z endp
.text$mn:00008DA9
.text$mn:00008DA9 _text$mn        ends
.text$mn:00008DA9
.text$x:00008DAC ; ===========================================================================
.text$x:00008DAC
.text$x:00008DAC ; Segment type: Pure code
.text$x:00008DAC ; Segment permissions: Read/Execute
.text$x:00008DAC _text$x         segment para public 'CODE' use32
.text$x:00008DAC                 assume cs:_text$x
.text$x:00008DAC                 ;org 8DACh
.text$x:00008DAC ; COMDAT (pick associative to section at 8CF4)
.text$x:00008DAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008DAC
.text$x:00008DAC ; =============== S U B R O U T I N E =======================================
.text$x:00008DAC
.text$x:00008DAC
.text$x:00008DAC __unwindfunclet$?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z$0 proc near
.text$x:00008DAC                                         ; DATA XREF: .xdata$x:0000BAD0o
.text$x:00008DAC                 lea     ecx, [ebp-18h]  ; this
.text$x:00008DAF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00008DAF __unwindfunclet$?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z$0 endp
.text$x:00008DAF
.text$x:00008DB4
.text$x:00008DB4 ; =============== S U B R O U T I N E =======================================
.text$x:00008DB4
.text$x:00008DB4
.text$x:00008DB4 __ehhandler$?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z proc near
.text$x:00008DB4                                         ; DATA XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Orphan_range(recordedMacroStep *,recordedMacroStep *)+5o
.text$x:00008DB4
.text$x:00008DB4 arg_4           = dword ptr  8
.text$x:00008DB4
.text$x:00008DB4                 mov     edx, [esp+arg_4]
.text$x:00008DB8                 lea     eax, [edx+0Ch]
.text$x:00008DBB                 mov     ecx, [edx-10h]
.text$x:00008DBE                 xor     ecx, eax
.text$x:00008DC0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008DC5                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z
.text$x:00008DCA                 jmp     ___CxxFrameHandler3
.text$x:00008DCA __ehhandler$?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z endp
.text$x:00008DCA
.text$x:00008DCA ; ---------------------------------------------------------------------------
.text$x:00008DCF                 align 10h
.text$x:00008DCF _text$x         ends
.text$x:00008DCF
.text$mn:00008DD0 ; ===========================================================================
.text$mn:00008DD0
.text$mn:00008DD0 ; Segment type: Pure code
.text$mn:00008DD0 ; Segment permissions: Read/Execute
.text$mn:00008DD0 _text$mn        segment para public 'CODE' use32
.text$mn:00008DD0                 assume cs:_text$mn
.text$mn:00008DD0                 ;org 8DD0h
.text$mn:00008DD0 ; COMDAT (pick any)
.text$mn:00008DD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008DD0
.text$mn:00008DD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00008DD0
.text$mn:00008DD0 ; Attributes: bp-based frame
.text$mn:00008DD0
.text$mn:00008DD0 ; protected: void __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Reallocate(unsigned int)
.text$mn:00008DD0                 public ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$mn:00008DD0 ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z proc near
.text$mn:00008DD0                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+4Ep
.text$mn:00008DD0
.text$mn:00008DD0 var_20          = dword ptr -20h
.text$mn:00008DD0 var_1C          = dword ptr -1Ch
.text$mn:00008DD0 var_18          = dword ptr -18h
.text$mn:00008DD0 var_13          = byte ptr -13h
.text$mn:00008DD0 var_11          = byte ptr -11h
.text$mn:00008DD0 var_10          = dword ptr -10h
.text$mn:00008DD0 var_C           = dword ptr -0Ch
.text$mn:00008DD0 var_4           = dword ptr -4
.text$mn:00008DD0 arg_0           = dword ptr  8
.text$mn:00008DD0
.text$mn:00008DD0 ; FUNCTION CHUNK AT .text$mn:00008E66 SIZE 00000009 BYTES
.text$mn:00008DD0 ; FUNCTION CHUNK AT .text$mn:00008E76 SIZE 00000098 BYTES
.text$mn:00008DD0
.text$mn:00008DD0                 push    ebp
.text$mn:00008DD1                 mov     ebp, esp
.text$mn:00008DD3                 push    0FFFFFFFFh
.text$mn:00008DD5                 push    offset __ehhandler$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$mn:00008DDA                 mov     eax, large fs:0
.text$mn:00008DE0                 push    eax
.text$mn:00008DE1                 push    ecx
.text$mn:00008DE2                 sub     esp, 10h
.text$mn:00008DE5                 push    ebx
.text$mn:00008DE6                 push    esi
.text$mn:00008DE7                 push    edi
.text$mn:00008DE8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008DED                 xor     eax, ebp
.text$mn:00008DEF                 push    eax
.text$mn:00008DF0                 lea     eax, [ebp+var_C]
.text$mn:00008DF3                 mov     large fs:0, eax
.text$mn:00008DF9                 mov     [ebp+var_10], esp
.text$mn:00008DFC                 mov     [ebp+var_18], ecx
.text$mn:00008DFF                 mov     eax, [ebp+arg_0]
.text$mn:00008E02                 push    eax
.text$mn:00008E03                 lea     ecx, [ebp+var_11]
.text$mn:00008E06                 push    ecx
.text$mn:00008E07                 mov     ecx, [ebp+var_18]
.text$mn:00008E0A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:00008E0F                 mov     ecx, eax
.text$mn:00008E11                 call    ?allocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEPAUMenuItemUnit@@I@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::allocate(uint)
.text$mn:00008E16                 mov     [ebp+var_1C], eax
.text$mn:00008E19                 mov     [ebp+var_4], 0
.text$mn:00008E20                 mov     edx, [ebp+var_1C]
.text$mn:00008E23                 push    edx
.text$mn:00008E24                 mov     eax, [ebp+var_18]
.text$mn:00008E27                 mov     ecx, [eax+8]
.text$mn:00008E2A                 push    ecx
.text$mn:00008E2B                 mov     edx, [ebp+var_18]
.text$mn:00008E2E                 mov     eax, [edx+4]
.text$mn:00008E31                 push    eax
.text$mn:00008E32                 mov     ecx, [ebp+var_18]
.text$mn:00008E35                 call    ??$_Umove@PAUMenuItemUnit@@@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEPAUMenuItemUnit@@PAU2@00@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Umove<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *)
.text$mn:00008E3A                 jmp     short loc_8E66
.text$mn:00008E3A ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z endp
.text$mn:00008E3A
.text$mn:00008E3C
.text$mn:00008E3C ; =============== S U B R O U T I N E =======================================
.text$mn:00008E3C
.text$mn:00008E3C ; Attributes: noreturn
.text$mn:00008E3C
.text$mn:00008E3C __catch$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00008E3C                                         ; DATA XREF: .xdata$x:0000BC74o
.text$mn:00008E3C                 mov     ecx, [ebp+8]
.text$mn:00008E3F                 push    ecx             ; int
.text$mn:00008E40                 mov     edx, [ebp-1Ch]
.text$mn:00008E43                 push    edx             ; void *
.text$mn:00008E44                 lea     eax, [ebp-12h]
.text$mn:00008E47                 push    eax
.text$mn:00008E48                 mov     ecx, [ebp-18h]
.text$mn:00008E4B                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:00008E50                 mov     ecx, eax
.text$mn:00008E52                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@I@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::deallocate(MenuItemUnit *,uint)
.text$mn:00008E57                 push    0
.text$mn:00008E59                 push    0
.text$mn:00008E5B                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00008E5B __catch$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:00008E5B
.text$mn:00008E60 ; ---------------------------------------------------------------------------
.text$mn:00008E60                 mov     eax, offset $LN8_0
.text$mn:00008E65                 retn
.text$mn:00008E66 ; ---------------------------------------------------------------------------
.text$mn:00008E66 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$mn:00008E66
.text$mn:00008E66 loc_8E66:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+6Aj
.text$mn:00008E66                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008E6D                 jmp     short loc_8E76
.text$mn:00008E6D ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$mn:00008E6F
.text$mn:00008E6F ; =============== S U B R O U T I N E =======================================
.text$mn:00008E6F
.text$mn:00008E6F
.text$mn:00008E6F $LN8_0          proc near               ; DATA XREF: .text$mn:00008E60o
.text$mn:00008E6F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00008E6F $LN8_0          endp ; sp-analysis failed
.text$mn:00008E6F
.text$mn:00008E76 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$mn:00008E76
.text$mn:00008E76 loc_8E76:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+9Dj
.text$mn:00008E76                 mov     ecx, [ebp+var_18]
.text$mn:00008E79                 call    ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::size(void)
.text$mn:00008E7E                 mov     [ebp+var_20], eax
.text$mn:00008E81                 mov     ecx, [ebp+var_18]
.text$mn:00008E84                 cmp     dword ptr [ecx+4], 0
.text$mn:00008E88                 jz      short loc_8ECF
.text$mn:00008E8A                 mov     edx, [ebp+var_18]
.text$mn:00008E8D                 mov     eax, [edx+8]
.text$mn:00008E90                 push    eax
.text$mn:00008E91                 mov     ecx, [ebp+var_18]
.text$mn:00008E94                 mov     edx, [ecx+4]
.text$mn:00008E97                 push    edx
.text$mn:00008E98                 mov     ecx, [ebp+var_18]
.text$mn:00008E9B                 call    ?_Destroy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXPAUMenuItemUnit@@0@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Destroy(MenuItemUnit *,MenuItemUnit *)
.text$mn:00008EA0                 mov     eax, [ebp+var_18]
.text$mn:00008EA3                 mov     ecx, [ebp+var_18]
.text$mn:00008EA6                 mov     eax, [eax+0Ch]
.text$mn:00008EA9                 sub     eax, [ecx+4]
.text$mn:00008EAC                 cdq
.text$mn:00008EAD                 mov     ecx, 3Ch ; '<'
.text$mn:00008EB2                 idiv    ecx
.text$mn:00008EB4                 push    eax             ; int
.text$mn:00008EB5                 mov     edx, [ebp+var_18]
.text$mn:00008EB8                 mov     eax, [edx+4]
.text$mn:00008EBB                 push    eax             ; void *
.text$mn:00008EBC                 lea     ecx, [ebp+var_13]
.text$mn:00008EBF                 push    ecx
.text$mn:00008EC0                 mov     ecx, [ebp+var_18]
.text$mn:00008EC3                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:00008EC8                 mov     ecx, eax
.text$mn:00008ECA                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@I@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::deallocate(MenuItemUnit *,uint)
.text$mn:00008ECF
.text$mn:00008ECF loc_8ECF:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+B8j
.text$mn:00008ECF                 mov     ecx, [ebp+var_18] ; this
.text$mn:00008ED2                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00008ED7                 imul    edx, [ebp+arg_0], 3Ch
.text$mn:00008EDB                 add     edx, [ebp+var_1C]
.text$mn:00008EDE                 mov     eax, [ebp+var_18]
.text$mn:00008EE1                 mov     [eax+0Ch], edx
.text$mn:00008EE4                 imul    ecx, [ebp+var_20], 3Ch
.text$mn:00008EE8                 add     ecx, [ebp+var_1C]
.text$mn:00008EEB                 mov     edx, [ebp+var_18]
.text$mn:00008EEE                 mov     [edx+8], ecx
.text$mn:00008EF1                 mov     eax, [ebp+var_18]
.text$mn:00008EF4                 mov     ecx, [ebp+var_1C]
.text$mn:00008EF7                 mov     [eax+4], ecx
.text$mn:00008EFA                 mov     ecx, [ebp+var_C]
.text$mn:00008EFD                 mov     large fs:0, ecx
.text$mn:00008F04                 pop     ecx
.text$mn:00008F05                 pop     edi
.text$mn:00008F06                 pop     esi
.text$mn:00008F07                 pop     ebx
.text$mn:00008F08                 mov     esp, ebp
.text$mn:00008F0A                 pop     ebp
.text$mn:00008F0B                 retn    4
.text$mn:00008F0B ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$mn:00008F0B ; ---------------------------------------------------------------------------
.text$mn:00008F0E                 align 10h
.text$mn:00008F0E _text$mn        ends
.text$mn:00008F0E
.text$x:00008F10 ; ===========================================================================
.text$x:00008F10
.text$x:00008F10 ; Segment type: Pure code
.text$x:00008F10 ; Segment permissions: Read/Execute
.text$x:00008F10 _text$x         segment para public 'CODE' use32
.text$x:00008F10                 assume cs:_text$x
.text$x:00008F10                 ;org 8F10h
.text$x:00008F10 ; COMDAT (pick associative to section at 8DD0)
.text$x:00008F10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00008F10
.text$x:00008F10 ; =============== S U B R O U T I N E =======================================
.text$x:00008F10
.text$x:00008F10
.text$x:00008F10 __ehhandler$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z proc near
.text$x:00008F10                                         ; DATA XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+5o
.text$x:00008F10
.text$x:00008F10 arg_4           = dword ptr  8
.text$x:00008F10
.text$x:00008F10                 mov     edx, [esp+arg_4]
.text$x:00008F14                 lea     eax, [edx+0Ch]
.text$x:00008F17                 mov     ecx, [edx-24h]
.text$x:00008F1A                 xor     ecx, eax
.text$x:00008F1C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008F21                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$x:00008F26                 jmp     ___CxxFrameHandler3
.text$x:00008F26 __ehhandler$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z endp
.text$x:00008F26
.text$x:00008F26 ; ---------------------------------------------------------------------------
.text$x:00008F2B                 align 4
.text$x:00008F2B _text$x         ends
.text$x:00008F2B
.text$mn:00008F2C ; ===========================================================================
.text$mn:00008F2C
.text$mn:00008F2C ; Segment type: Pure code
.text$mn:00008F2C ; Segment permissions: Read/Execute
.text$mn:00008F2C _text$mn        segment para public 'CODE' use32
.text$mn:00008F2C                 assume cs:_text$mn
.text$mn:00008F2C                 ;org 8F2Ch
.text$mn:00008F2C ; COMDAT (pick any)
.text$mn:00008F2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00008F2C
.text$mn:00008F2C ; =============== S U B R O U T I N E =======================================
.text$mn:00008F2C
.text$mn:00008F2C ; Attributes: bp-based frame
.text$mn:00008F2C
.text$mn:00008F2C ; protected: void __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Reallocate(unsigned int)
.text$mn:00008F2C                 public ?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z
.text$mn:00008F2C ?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z proc near
.text$mn:00008F2C                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reserve(uint)+4Ep
.text$mn:00008F2C
.text$mn:00008F2C var_20          = dword ptr -20h
.text$mn:00008F2C var_1C          = dword ptr -1Ch
.text$mn:00008F2C var_18          = dword ptr -18h
.text$mn:00008F2C var_13          = byte ptr -13h
.text$mn:00008F2C var_11          = byte ptr -11h
.text$mn:00008F2C var_10          = dword ptr -10h
.text$mn:00008F2C var_C           = dword ptr -0Ch
.text$mn:00008F2C var_4           = dword ptr -4
.text$mn:00008F2C arg_0           = dword ptr  8
.text$mn:00008F2C
.text$mn:00008F2C ; FUNCTION CHUNK AT .text$mn:00008FC2 SIZE 00000009 BYTES
.text$mn:00008F2C ; FUNCTION CHUNK AT .text$mn:00008FD2 SIZE 00000098 BYTES
.text$mn:00008F2C
.text$mn:00008F2C                 push    ebp
.text$mn:00008F2D                 mov     ebp, esp
.text$mn:00008F2F                 push    0FFFFFFFFh
.text$mn:00008F31                 push    offset __ehhandler$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z
.text$mn:00008F36                 mov     eax, large fs:0
.text$mn:00008F3C                 push    eax
.text$mn:00008F3D                 push    ecx
.text$mn:00008F3E                 sub     esp, 10h
.text$mn:00008F41                 push    ebx
.text$mn:00008F42                 push    esi
.text$mn:00008F43                 push    edi
.text$mn:00008F44                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008F49                 xor     eax, ebp
.text$mn:00008F4B                 push    eax
.text$mn:00008F4C                 lea     eax, [ebp+var_C]
.text$mn:00008F4F                 mov     large fs:0, eax
.text$mn:00008F55                 mov     [ebp+var_10], esp
.text$mn:00008F58                 mov     [ebp+var_18], ecx
.text$mn:00008F5B                 mov     eax, [ebp+arg_0]
.text$mn:00008F5E                 push    eax
.text$mn:00008F5F                 lea     ecx, [ebp+var_11]
.text$mn:00008F62                 push    ecx
.text$mn:00008F63                 mov     ecx, [ebp+var_18]
.text$mn:00008F66                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:00008F6B                 mov     ecx, eax
.text$mn:00008F6D                 call    ?allocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEPAUrecordedMacroStep@@I@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::allocate(uint)
.text$mn:00008F72                 mov     [ebp+var_1C], eax
.text$mn:00008F75                 mov     [ebp+var_4], 0
.text$mn:00008F7C                 mov     edx, [ebp+var_1C]
.text$mn:00008F7F                 push    edx
.text$mn:00008F80                 mov     eax, [ebp+var_18]
.text$mn:00008F83                 mov     ecx, [eax+8]
.text$mn:00008F86                 push    ecx
.text$mn:00008F87                 mov     edx, [ebp+var_18]
.text$mn:00008F8A                 mov     eax, [edx+4]
.text$mn:00008F8D                 push    eax
.text$mn:00008F8E                 mov     ecx, [ebp+var_18]
.text$mn:00008F91                 call    ??$_Umove@PAUrecordedMacroStep@@@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEPAUrecordedMacroStep@@PAU2@00@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Umove<recordedMacroStep *>(recordedMacroStep *,recordedMacroStep *,recordedMacroStep *)
.text$mn:00008F96                 jmp     short loc_8FC2
.text$mn:00008F96 ?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z endp
.text$mn:00008F96
.text$mn:00008F98
.text$mn:00008F98 ; =============== S U B R O U T I N E =======================================
.text$mn:00008F98
.text$mn:00008F98 ; Attributes: noreturn
.text$mn:00008F98
.text$mn:00008F98 __catch$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00008F98                                         ; DATA XREF: .xdata$x:0000BA80o
.text$mn:00008F98                 mov     ecx, [ebp+8]
.text$mn:00008F9B                 push    ecx             ; int
.text$mn:00008F9C                 mov     edx, [ebp-1Ch]
.text$mn:00008F9F                 push    edx             ; void *
.text$mn:00008FA0                 lea     eax, [ebp-12h]
.text$mn:00008FA3                 push    eax
.text$mn:00008FA4                 mov     ecx, [ebp-18h]
.text$mn:00008FA7                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:00008FAC                 mov     ecx, eax
.text$mn:00008FAE                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@I@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::deallocate(recordedMacroStep *,uint)
.text$mn:00008FB3                 push    0
.text$mn:00008FB5                 push    0
.text$mn:00008FB7                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00008FB7 __catch$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:00008FB7
.text$mn:00008FBC ; ---------------------------------------------------------------------------
.text$mn:00008FBC                 mov     eax, offset $LN8
.text$mn:00008FC1                 retn
.text$mn:00008FC2 ; ---------------------------------------------------------------------------
.text$mn:00008FC2 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z
.text$mn:00008FC2
.text$mn:00008FC2 loc_8FC2:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reallocate(uint)+6Aj
.text$mn:00008FC2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00008FC9                 jmp     short loc_8FD2
.text$mn:00008FC9 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z
.text$mn:00008FCB
.text$mn:00008FCB ; =============== S U B R O U T I N E =======================================
.text$mn:00008FCB
.text$mn:00008FCB
.text$mn:00008FCB $LN8            proc near               ; DATA XREF: .text$mn:00008FBCo
.text$mn:00008FCB                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00008FCB $LN8            endp ; sp-analysis failed
.text$mn:00008FCB
.text$mn:00008FD2 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z
.text$mn:00008FD2
.text$mn:00008FD2 loc_8FD2:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reallocate(uint)+9Dj
.text$mn:00008FD2                 mov     ecx, [ebp+var_18]
.text$mn:00008FD5                 call    ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::size(void)
.text$mn:00008FDA                 mov     [ebp+var_20], eax
.text$mn:00008FDD                 mov     ecx, [ebp+var_18]
.text$mn:00008FE0                 cmp     dword ptr [ecx+4], 0
.text$mn:00008FE4                 jz      short loc_902B
.text$mn:00008FE6                 mov     edx, [ebp+var_18]
.text$mn:00008FE9                 mov     eax, [edx+8]
.text$mn:00008FEC                 push    eax
.text$mn:00008FED                 mov     ecx, [ebp+var_18]
.text$mn:00008FF0                 mov     edx, [ecx+4]
.text$mn:00008FF3                 push    edx
.text$mn:00008FF4                 mov     ecx, [ebp+var_18]
.text$mn:00008FF7                 call    ?_Destroy@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXPAUrecordedMacroStep@@0@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Destroy(recordedMacroStep *,recordedMacroStep *)
.text$mn:00008FFC                 mov     eax, [ebp+var_18]
.text$mn:00008FFF                 mov     ecx, [ebp+var_18]
.text$mn:00009002                 mov     eax, [eax+0Ch]
.text$mn:00009005                 sub     eax, [ecx+4]
.text$mn:00009008                 cdq
.text$mn:00009009                 mov     ecx, 2Ch ; ','
.text$mn:0000900E                 idiv    ecx
.text$mn:00009010                 push    eax             ; int
.text$mn:00009011                 mov     edx, [ebp+var_18]
.text$mn:00009014                 mov     eax, [edx+4]
.text$mn:00009017                 push    eax             ; void *
.text$mn:00009018                 lea     ecx, [ebp+var_13]
.text$mn:0000901B                 push    ecx
.text$mn:0000901C                 mov     ecx, [ebp+var_18]
.text$mn:0000901F                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:00009024                 mov     ecx, eax
.text$mn:00009026                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@I@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::deallocate(recordedMacroStep *,uint)
.text$mn:0000902B
.text$mn:0000902B loc_902B:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reallocate(uint)+B8j
.text$mn:0000902B                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000902E                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00009033                 imul    edx, [ebp+arg_0], 2Ch
.text$mn:00009037                 add     edx, [ebp+var_1C]
.text$mn:0000903A                 mov     eax, [ebp+var_18]
.text$mn:0000903D                 mov     [eax+0Ch], edx
.text$mn:00009040                 imul    ecx, [ebp+var_20], 2Ch
.text$mn:00009044                 add     ecx, [ebp+var_1C]
.text$mn:00009047                 mov     edx, [ebp+var_18]
.text$mn:0000904A                 mov     [edx+8], ecx
.text$mn:0000904D                 mov     eax, [ebp+var_18]
.text$mn:00009050                 mov     ecx, [ebp+var_1C]
.text$mn:00009053                 mov     [eax+4], ecx
.text$mn:00009056                 mov     ecx, [ebp+var_C]
.text$mn:00009059                 mov     large fs:0, ecx
.text$mn:00009060                 pop     ecx
.text$mn:00009061                 pop     edi
.text$mn:00009062                 pop     esi
.text$mn:00009063                 pop     ebx
.text$mn:00009064                 mov     esp, ebp
.text$mn:00009066                 pop     ebp
.text$mn:00009067                 retn    4
.text$mn:00009067 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z
.text$mn:00009067 ; ---------------------------------------------------------------------------
.text$mn:0000906A                 align 4
.text$mn:0000906A _text$mn        ends
.text$mn:0000906A
.text$x:0000906C ; ===========================================================================
.text$x:0000906C
.text$x:0000906C ; Segment type: Pure code
.text$x:0000906C ; Segment permissions: Read/Execute
.text$x:0000906C _text$x         segment para public 'CODE' use32
.text$x:0000906C                 assume cs:_text$x
.text$x:0000906C                 ;org 906Ch
.text$x:0000906C ; COMDAT (pick associative to section at 8F2C)
.text$x:0000906C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000906C
.text$x:0000906C ; =============== S U B R O U T I N E =======================================
.text$x:0000906C
.text$x:0000906C
.text$x:0000906C __ehhandler$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z proc near
.text$x:0000906C                                         ; DATA XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reallocate(uint)+5o
.text$x:0000906C
.text$x:0000906C arg_4           = dword ptr  8
.text$x:0000906C
.text$x:0000906C                 mov     edx, [esp+arg_4]
.text$x:00009070                 lea     eax, [edx+0Ch]
.text$x:00009073                 mov     ecx, [edx-24h]
.text$x:00009076                 xor     ecx, eax
.text$x:00009078                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000907D                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z
.text$x:00009082                 jmp     ___CxxFrameHandler3
.text$x:00009082 __ehhandler$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z endp
.text$x:00009082
.text$x:00009082 ; ---------------------------------------------------------------------------
.text$x:00009087                 align 4
.text$x:00009087 _text$x         ends
.text$x:00009087
.text$mn:00009088 ; ===========================================================================
.text$mn:00009088
.text$mn:00009088 ; Segment type: Pure code
.text$mn:00009088 ; Segment permissions: Read/Execute
.text$mn:00009088 _text$mn        segment para public 'CODE' use32
.text$mn:00009088                 assume cs:_text$mn
.text$mn:00009088                 ;org 9088h
.text$mn:00009088 ; COMDAT (pick any)
.text$mn:00009088                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009088
.text$mn:00009088 ; =============== S U B R O U T I N E =======================================
.text$mn:00009088
.text$mn:00009088 ; Attributes: bp-based frame
.text$mn:00009088
.text$mn:00009088 ; protected: void __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Reserve(unsigned int)
.text$mn:00009088                 public ?_Reserve@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.text$mn:00009088 ?_Reserve@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z proc near
.text$mn:00009088                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+59p
.text$mn:00009088                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+C6p
.text$mn:00009088
.text$mn:00009088 var_4           = dword ptr -4
.text$mn:00009088 arg_0           = dword ptr  8
.text$mn:00009088
.text$mn:00009088                 push    ebp
.text$mn:00009089                 mov     ebp, esp
.text$mn:0000908B                 push    ecx
.text$mn:0000908C                 push    esi
.text$mn:0000908D                 mov     [ebp+var_4], ecx
.text$mn:00009090                 mov     ecx, [ebp+var_4]
.text$mn:00009093                 call    ?_Unused_capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Unused_capacity(void)
.text$mn:00009098                 cmp     eax, [ebp+arg_0]
.text$mn:0000909B                 jnb     short loc_90DB
.text$mn:0000909D                 mov     ecx, [ebp+var_4]
.text$mn:000090A0                 call    ?max_size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::max_size(void)
.text$mn:000090A5                 mov     esi, eax
.text$mn:000090A7                 mov     ecx, [ebp+var_4]
.text$mn:000090AA                 call    ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::size(void)
.text$mn:000090AF                 sub     esi, eax
.text$mn:000090B1                 cmp     esi, [ebp+arg_0]
.text$mn:000090B4                 jnb     short loc_90BE
.text$mn:000090B6                 mov     ecx, [ebp+var_4]
.text$mn:000090B9                 call    ?_Xlen@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Xlen(void)
.text$mn:000090BE
.text$mn:000090BE loc_90BE:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+2Cj
.text$mn:000090BE                 mov     ecx, [ebp+var_4]
.text$mn:000090C1                 call    ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::size(void)
.text$mn:000090C6                 add     eax, [ebp+arg_0]
.text$mn:000090C9                 push    eax
.text$mn:000090CA                 mov     ecx, [ebp+var_4]
.text$mn:000090CD                 call    ?_Grow_to@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEII@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Grow_to(uint)
.text$mn:000090D2                 push    eax
.text$mn:000090D3                 mov     ecx, [ebp+var_4]
.text$mn:000090D6                 call    ?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)
.text$mn:000090DB
.text$mn:000090DB loc_90DB:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+13j
.text$mn:000090DB                 pop     esi
.text$mn:000090DC                 mov     esp, ebp
.text$mn:000090DE                 pop     ebp
.text$mn:000090DF                 retn    4
.text$mn:000090DF ?_Reserve@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z endp
.text$mn:000090DF
.text$mn:000090DF ; ---------------------------------------------------------------------------
.text$mn:000090E2                 align 4
.text$mn:000090E2 _text$mn        ends
.text$mn:000090E2
.text$mn:000090E4 ; ===========================================================================
.text$mn:000090E4
.text$mn:000090E4 ; Segment type: Pure code
.text$mn:000090E4 ; Segment permissions: Read/Execute
.text$mn:000090E4 _text$mn        segment para public 'CODE' use32
.text$mn:000090E4                 assume cs:_text$mn
.text$mn:000090E4                 ;org 90E4h
.text$mn:000090E4 ; COMDAT (pick any)
.text$mn:000090E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000090E4
.text$mn:000090E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000090E4
.text$mn:000090E4 ; Attributes: bp-based frame
.text$mn:000090E4
.text$mn:000090E4 ; protected: void __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Reserve(unsigned int)
.text$mn:000090E4                 public ?_Reserve@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z
.text$mn:000090E4 ?_Reserve@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z proc near
.text$mn:000090E4                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::push_back(recordedMacroStep &&)+59p
.text$mn:000090E4                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::push_back(recordedMacroStep &&)+C6p
.text$mn:000090E4
.text$mn:000090E4 var_4           = dword ptr -4
.text$mn:000090E4 arg_0           = dword ptr  8
.text$mn:000090E4
.text$mn:000090E4                 push    ebp
.text$mn:000090E5                 mov     ebp, esp
.text$mn:000090E7                 push    ecx
.text$mn:000090E8                 push    esi
.text$mn:000090E9                 mov     [ebp+var_4], ecx
.text$mn:000090EC                 mov     ecx, [ebp+var_4]
.text$mn:000090EF                 call    ?_Unused_capacity@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Unused_capacity(void)
.text$mn:000090F4                 cmp     eax, [ebp+arg_0]
.text$mn:000090F7                 jnb     short loc_9137
.text$mn:000090F9                 mov     ecx, [ebp+var_4]
.text$mn:000090FC                 call    ?max_size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::max_size(void)
.text$mn:00009101                 mov     esi, eax
.text$mn:00009103                 mov     ecx, [ebp+var_4]
.text$mn:00009106                 call    ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::size(void)
.text$mn:0000910B                 sub     esi, eax
.text$mn:0000910D                 cmp     esi, [ebp+arg_0]
.text$mn:00009110                 jnb     short loc_911A
.text$mn:00009112                 mov     ecx, [ebp+var_4]
.text$mn:00009115                 call    ?_Xlen@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Xlen(void)
.text$mn:0000911A
.text$mn:0000911A loc_911A:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reserve(uint)+2Cj
.text$mn:0000911A                 mov     ecx, [ebp+var_4]
.text$mn:0000911D                 call    ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::size(void)
.text$mn:00009122                 add     eax, [ebp+arg_0]
.text$mn:00009125                 push    eax
.text$mn:00009126                 mov     ecx, [ebp+var_4]
.text$mn:00009129                 call    ?_Grow_to@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEII@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Grow_to(uint)
.text$mn:0000912E                 push    eax
.text$mn:0000912F                 mov     ecx, [ebp+var_4]
.text$mn:00009132                 call    ?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reallocate(uint)
.text$mn:00009137
.text$mn:00009137 loc_9137:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reserve(uint)+13j
.text$mn:00009137                 pop     esi
.text$mn:00009138                 mov     esp, ebp
.text$mn:0000913A                 pop     ebp
.text$mn:0000913B                 retn    4
.text$mn:0000913B ?_Reserve@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z endp
.text$mn:0000913B
.text$mn:0000913B ; ---------------------------------------------------------------------------
.text$mn:0000913E                 align 10h
.text$mn:0000913E _text$mn        ends
.text$mn:0000913E
.text$mn:00009140 ; ===========================================================================
.text$mn:00009140
.text$mn:00009140 ; Segment type: Pure code
.text$mn:00009140 ; Segment permissions: Read/Execute
.text$mn:00009140 _text$mn        segment para public 'CODE' use32
.text$mn:00009140                 assume cs:_text$mn
.text$mn:00009140                 ;org 9140h
.text$mn:00009140 ; COMDAT (pick any)
.text$mn:00009140                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009140
.text$mn:00009140 ; =============== S U B R O U T I N E =======================================
.text$mn:00009140
.text$mn:00009140 ; Attributes: bp-based frame
.text$mn:00009140
.text$mn:00009140 ; int __stdcall std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned int>>>::_Setcont(struct std::_Container_base12 *)
.text$mn:00009140                 public ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@I@std@@@2@@Z
.text$mn:00009140 ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@I@std@@@2@@Z proc near
.text$mn:00009140                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(uint,std::_Container_base12 const *)+3Cp
.text$mn:00009140
.text$mn:00009140 var_4           = dword ptr -4
.text$mn:00009140 arg_0           = dword ptr  8
.text$mn:00009140
.text$mn:00009140                 push    ebp
.text$mn:00009141                 mov     ebp, esp
.text$mn:00009143                 push    ecx
.text$mn:00009144                 mov     [ebp+var_4], ecx
.text$mn:00009147                 mov     eax, [ebp+arg_0]
.text$mn:0000914A                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000914B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000914E                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00009153                 mov     esp, ebp
.text$mn:00009155                 pop     ebp
.text$mn:00009156                 retn    4
.text$mn:00009156 ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@I@std@@@2@@Z endp
.text$mn:00009156
.text$mn:00009156 ; ---------------------------------------------------------------------------
.text$mn:00009159                 align 4
.text$mn:00009159 _text$mn        ends
.text$mn:00009159
.text$mn:0000915C ; ===========================================================================
.text$mn:0000915C
.text$mn:0000915C ; Segment type: Pure code
.text$mn:0000915C ; Segment permissions: Read/Execute
.text$mn:0000915C _text$mn        segment para public 'CODE' use32
.text$mn:0000915C                 assume cs:_text$mn
.text$mn:0000915C                 ;org 915Ch
.text$mn:0000915C ; COMDAT (pick any)
.text$mn:0000915C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000915C
.text$mn:0000915C ; =============== S U B R O U T I N E =======================================
.text$mn:0000915C
.text$mn:0000915C ; Attributes: bp-based frame
.text$mn:0000915C
.text$mn:0000915C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:0000915C                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:0000915C ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:0000915C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:0000915C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+47p ...
.text$mn:0000915C
.text$mn:0000915C var_C           = dword ptr -0Ch
.text$mn:0000915C var_8           = dword ptr -8
.text$mn:0000915C var_2           = byte ptr -2
.text$mn:0000915C var_1           = byte ptr -1
.text$mn:0000915C arg_0           = byte ptr  8
.text$mn:0000915C Size            = dword ptr  0Ch
.text$mn:0000915C
.text$mn:0000915C                 push    ebp
.text$mn:0000915D                 mov     ebp, esp
.text$mn:0000915F                 sub     esp, 0Ch
.text$mn:00009162                 mov     [ebp+var_8], ecx
.text$mn:00009165                 movzx   eax, [ebp+arg_0]
.text$mn:00009169                 test    eax, eax
.text$mn:0000916B                 jnz     short loc_916F
.text$mn:0000916D                 jmp     short loc_91E2
.text$mn:0000916F ; ---------------------------------------------------------------------------
.text$mn:0000916F
.text$mn:0000916F loc_916F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000916F                 mov     ecx, [ebp+var_8]
.text$mn:00009172                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00009176                 jb      short loc_91E2
.text$mn:00009178                 mov     edx, [ebp+var_8]
.text$mn:0000917B                 mov     eax, [edx+4]
.text$mn:0000917E                 mov     [ebp+var_C], eax
.text$mn:00009181                 mov     ecx, [ebp+var_8]
.text$mn:00009184                 add     ecx, 4
.text$mn:00009187                 push    ecx
.text$mn:00009188                 lea     edx, [ebp+var_1]
.text$mn:0000918B                 push    edx
.text$mn:0000918C                 mov     ecx, [ebp+var_8]
.text$mn:0000918F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00009194                 mov     ecx, eax
.text$mn:00009196                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000919B                 cmp     [ebp+Size], 0
.text$mn:0000919F                 jbe     short loc_91C1
.text$mn:000091A1                 mov     eax, [ebp+Size]
.text$mn:000091A4                 push    eax             ; Size
.text$mn:000091A5                 mov     ecx, [ebp+var_C]
.text$mn:000091A8                 push    ecx
.text$mn:000091A9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000091AE                 add     esp, 4
.text$mn:000091B1                 push    eax             ; Src
.text$mn:000091B2                 mov     edx, [ebp+var_8]
.text$mn:000091B5                 add     edx, 4
.text$mn:000091B8                 push    edx             ; Dst
.text$mn:000091B9                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000091BE                 add     esp, 0Ch
.text$mn:000091C1
.text$mn:000091C1 loc_91C1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:000091C1                 mov     eax, [ebp+var_8]
.text$mn:000091C4                 mov     ecx, [eax+18h]
.text$mn:000091C7                 add     ecx, 1
.text$mn:000091CA                 push    ecx             ; int
.text$mn:000091CB                 mov     edx, [ebp+var_C]
.text$mn:000091CE                 push    edx             ; void *
.text$mn:000091CF                 lea     eax, [ebp+var_2]
.text$mn:000091D2                 push    eax
.text$mn:000091D3                 mov     ecx, [ebp+var_8]
.text$mn:000091D6                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000091DB                 mov     ecx, eax
.text$mn:000091DD                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000091E2
.text$mn:000091E2 loc_91E2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000091E2                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000091E2                 mov     ecx, [ebp+var_8]
.text$mn:000091E5                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:000091EC                 mov     edx, [ebp+Size]
.text$mn:000091EF                 push    edx
.text$mn:000091F0                 mov     ecx, [ebp+var_8]
.text$mn:000091F3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000091F8                 mov     esp, ebp
.text$mn:000091FA                 pop     ebp
.text$mn:000091FB                 retn    8
.text$mn:000091FB ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:000091FB
.text$mn:000091FB ; ---------------------------------------------------------------------------
.text$mn:000091FE                 align 10h
.text$mn:000091FE _text$mn        ends
.text$mn:000091FE
.text$mn:00009200 ; ===========================================================================
.text$mn:00009200
.text$mn:00009200 ; Segment type: Pure code
.text$mn:00009200 ; Segment permissions: Read/Execute
.text$mn:00009200 _text$mn        segment para public 'CODE' use32
.text$mn:00009200                 assume cs:_text$mn
.text$mn:00009200                 ;org 9200h
.text$mn:00009200 ; COMDAT (pick any)
.text$mn:00009200                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009200
.text$mn:00009200 ; =============== S U B R O U T I N E =======================================
.text$mn:00009200
.text$mn:00009200 ; Attributes: bp-based frame
.text$mn:00009200
.text$mn:00009200 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00009200                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00009200 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00009200                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+56p
.text$mn:00009200                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+47p ...
.text$mn:00009200
.text$mn:00009200 var_C           = dword ptr -0Ch
.text$mn:00009200 var_8           = dword ptr -8
.text$mn:00009200 var_2           = byte ptr -2
.text$mn:00009200 var_1           = byte ptr -1
.text$mn:00009200 arg_0           = byte ptr  8
.text$mn:00009200 arg_4           = dword ptr  0Ch
.text$mn:00009200
.text$mn:00009200                 push    ebp
.text$mn:00009201                 mov     ebp, esp
.text$mn:00009203                 sub     esp, 0Ch
.text$mn:00009206                 mov     [ebp+var_8], ecx
.text$mn:00009209                 movzx   eax, [ebp+arg_0]
.text$mn:0000920D                 test    eax, eax
.text$mn:0000920F                 jnz     short loc_9213
.text$mn:00009211                 jmp     short loc_9286
.text$mn:00009213 ; ---------------------------------------------------------------------------
.text$mn:00009213
.text$mn:00009213 loc_9213:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:00009213                 mov     ecx, [ebp+var_8]
.text$mn:00009216                 cmp     dword ptr [ecx+18h], 8
.text$mn:0000921A                 jb      short loc_9286
.text$mn:0000921C                 mov     edx, [ebp+var_8]
.text$mn:0000921F                 mov     eax, [edx+4]
.text$mn:00009222                 mov     [ebp+var_C], eax
.text$mn:00009225                 mov     ecx, [ebp+var_8]
.text$mn:00009228                 add     ecx, 4
.text$mn:0000922B                 push    ecx
.text$mn:0000922C                 lea     edx, [ebp+var_1]
.text$mn:0000922F                 push    edx
.text$mn:00009230                 mov     ecx, [ebp+var_8]
.text$mn:00009233                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00009238                 mov     ecx, eax
.text$mn:0000923A                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:0000923F                 cmp     [ebp+arg_4], 0
.text$mn:00009243                 jbe     short loc_9265
.text$mn:00009245                 mov     eax, [ebp+arg_4]
.text$mn:00009248                 push    eax             ; int
.text$mn:00009249                 mov     ecx, [ebp+var_C]
.text$mn:0000924C                 push    ecx
.text$mn:0000924D                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00009252                 add     esp, 4
.text$mn:00009255                 push    eax             ; Src
.text$mn:00009256                 mov     edx, [ebp+var_8]
.text$mn:00009259                 add     edx, 4
.text$mn:0000925C                 push    edx             ; Dst
.text$mn:0000925D                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00009262                 add     esp, 0Ch
.text$mn:00009265
.text$mn:00009265 loc_9265:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:00009265                 mov     eax, [ebp+var_8]
.text$mn:00009268                 mov     ecx, [eax+18h]
.text$mn:0000926B                 add     ecx, 1
.text$mn:0000926E                 push    ecx             ; int
.text$mn:0000926F                 mov     edx, [ebp+var_C]
.text$mn:00009272                 push    edx             ; void *
.text$mn:00009273                 lea     eax, [ebp+var_2]
.text$mn:00009276                 push    eax
.text$mn:00009277                 mov     ecx, [ebp+var_8]
.text$mn:0000927A                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000927F                 mov     ecx, eax
.text$mn:00009281                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:00009286
.text$mn:00009286 loc_9286:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:00009286                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:00009286                 mov     ecx, [ebp+var_8]
.text$mn:00009289                 mov     dword ptr [ecx+18h], 7
.text$mn:00009290                 mov     edx, [ebp+arg_4]
.text$mn:00009293                 push    edx
.text$mn:00009294                 mov     ecx, [ebp+var_8]
.text$mn:00009297                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000929C                 mov     esp, ebp
.text$mn:0000929E                 pop     ebp
.text$mn:0000929F                 retn    8
.text$mn:0000929F ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:0000929F
.text$mn:0000929F ; ---------------------------------------------------------------------------
.text$mn:000092A2                 align 4
.text$mn:000092A2 _text$mn        ends
.text$mn:000092A2
.text$mn:000092A4 ; ===========================================================================
.text$mn:000092A4
.text$mn:000092A4 ; Segment type: Pure code
.text$mn:000092A4 ; Segment permissions: Read/Execute
.text$mn:000092A4 _text$mn        segment para public 'CODE' use32
.text$mn:000092A4                 assume cs:_text$mn
.text$mn:000092A4                 ;org 92A4h
.text$mn:000092A4 ; COMDAT (pick any)
.text$mn:000092A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000092A4
.text$mn:000092A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000092A4
.text$mn:000092A4 ; Attributes: bp-based frame
.text$mn:000092A4
.text$mn:000092A4 ; protected: void __thiscall std::deque<unsigned int, class std::allocator<unsigned int>>::_Tidy(void)
.text$mn:000092A4                 public ?_Tidy@?$deque@IV?$allocator@I@std@@@std@@IAEXXZ
.text$mn:000092A4 ?_Tidy@?$deque@IV?$allocator@I@std@@@std@@IAEXXZ proc near
.text$mn:000092A4                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::~deque<uint,std::allocator<uint>>(void)+30p
.text$mn:000092A4
.text$mn:000092A4 var_C           = dword ptr -0Ch
.text$mn:000092A4 var_8           = dword ptr -8
.text$mn:000092A4 var_4           = byte ptr -4
.text$mn:000092A4 var_3           = byte ptr -3
.text$mn:000092A4 var_2           = byte ptr -2
.text$mn:000092A4 var_1           = byte ptr -1
.text$mn:000092A4
.text$mn:000092A4                 push    ebp
.text$mn:000092A5                 mov     ebp, esp
.text$mn:000092A7                 sub     esp, 0Ch
.text$mn:000092AA                 mov     [ebp+var_8], ecx
.text$mn:000092AD                 lea     eax, [ebp+var_2]
.text$mn:000092B0                 push    eax
.text$mn:000092B1                 mov     ecx, [ebp+var_8]
.text$mn:000092B4                 call    ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:000092B9                 push    eax
.text$mn:000092BA                 lea     ecx, [ebp+var_1]
.text$mn:000092BD                 call    ??$?0U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@I@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<uint *>>::_Wrap_alloc<std::allocator<uint *>>(std::_Wrap_alloc<std::allocator<uint>> const &)
.text$mn:000092C2
.text$mn:000092C2 loc_92C2:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Tidy(void)+35j
.text$mn:000092C2                 mov     ecx, [ebp+var_8]
.text$mn:000092C5                 call    ?empty@?$deque@IV?$allocator@I@std@@@std@@QBE_NXZ ; std::deque<uint,std::allocator<uint>>::empty(void)
.text$mn:000092CA                 movzx   ecx, al
.text$mn:000092CD                 test    ecx, ecx
.text$mn:000092CF                 jnz     short loc_92DB
.text$mn:000092D1                 mov     ecx, [ebp+var_8]
.text$mn:000092D4                 call    ?pop_back@?$deque@IV?$allocator@I@std@@@std@@QAEXXZ ; std::deque<uint,std::allocator<uint>>::pop_back(void)
.text$mn:000092D9                 jmp     short loc_92C2
.text$mn:000092DB ; ---------------------------------------------------------------------------
.text$mn:000092DB
.text$mn:000092DB loc_92DB:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Tidy(void)+2Bj
.text$mn:000092DB                 mov     edx, [ebp+var_8]
.text$mn:000092DE                 mov     eax, [edx+8]
.text$mn:000092E1                 mov     [ebp+var_C], eax
.text$mn:000092E4
.text$mn:000092E4 loc_92E4:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Tidy(void):loc_9344j
.text$mn:000092E4                 cmp     [ebp+var_C], 0
.text$mn:000092E8                 jbe     short loc_9346
.text$mn:000092EA                 mov     ecx, [ebp+var_C]
.text$mn:000092ED                 sub     ecx, 1
.text$mn:000092F0                 mov     [ebp+var_C], ecx
.text$mn:000092F3                 mov     edx, [ebp+var_8]
.text$mn:000092F6                 mov     eax, [edx+4]
.text$mn:000092F9                 mov     ecx, [ebp+var_C]
.text$mn:000092FC                 cmp     dword ptr [eax+ecx*4], 0
.text$mn:00009300                 jz      short loc_9344
.text$mn:00009302                 push    4               ; int
.text$mn:00009304                 mov     edx, [ebp+var_8]
.text$mn:00009307                 mov     eax, [edx+4]
.text$mn:0000930A                 mov     ecx, [ebp+var_C]
.text$mn:0000930D                 mov     edx, [eax+ecx*4]
.text$mn:00009310                 push    edx             ; void *
.text$mn:00009311                 lea     eax, [ebp+var_3]
.text$mn:00009314                 push    eax
.text$mn:00009315                 mov     ecx, [ebp+var_8]
.text$mn:00009318                 call    ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000931D                 mov     ecx, eax
.text$mn:0000931F                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z ; std::_Wrap_alloc<std::allocator<uint>>::deallocate(uint *,uint)
.text$mn:00009324                 mov     ecx, [ebp+var_8]
.text$mn:00009327                 mov     edx, [ecx+4]
.text$mn:0000932A                 mov     eax, [ebp+var_C]
.text$mn:0000932D                 lea     ecx, [edx+eax*4]
.text$mn:00009330                 push    ecx
.text$mn:00009331                 lea     edx, [ebp+var_4]
.text$mn:00009334                 push    edx
.text$mn:00009335                 mov     ecx, [ebp+var_8]
.text$mn:00009338                 call    ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000933D                 mov     ecx, eax
.text$mn:0000933F                 call    ??$destroy@PAI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAPAI@Z ; std::_Wrap_alloc<std::allocator<uint>>::destroy<uint *>(uint * *)
.text$mn:00009344
.text$mn:00009344 loc_9344:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Tidy(void)+5Cj
.text$mn:00009344                 jmp     short loc_92E4
.text$mn:00009346 ; ---------------------------------------------------------------------------
.text$mn:00009346
.text$mn:00009346 loc_9346:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Tidy(void)+44j
.text$mn:00009346                 mov     eax, [ebp+var_8]
.text$mn:00009349                 cmp     dword ptr [eax+4], 0
.text$mn:0000934D                 jz      short loc_9365
.text$mn:0000934F                 mov     ecx, [ebp+var_8]
.text$mn:00009352                 mov     edx, [ecx+8]
.text$mn:00009355                 push    edx             ; int
.text$mn:00009356                 mov     eax, [ebp+var_8]
.text$mn:00009359                 mov     ecx, [eax+4]
.text$mn:0000935C                 push    ecx             ; void *
.text$mn:0000935D                 lea     ecx, [ebp+var_1]
.text$mn:00009360                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@QAEXPAPAII@Z ; std::_Wrap_alloc<std::allocator<uint *>>::deallocate(uint * *,uint)
.text$mn:00009365
.text$mn:00009365 loc_9365:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Tidy(void)+A9j
.text$mn:00009365                 mov     edx, [ebp+var_8]
.text$mn:00009368                 mov     dword ptr [edx+8], 0
.text$mn:0000936F                 mov     eax, [ebp+var_8]
.text$mn:00009372                 mov     dword ptr [eax+4], 0
.text$mn:00009379                 mov     esp, ebp
.text$mn:0000937B                 pop     ebp
.text$mn:0000937C                 retn
.text$mn:0000937C ?_Tidy@?$deque@IV?$allocator@I@std@@@std@@IAEXXZ endp
.text$mn:0000937C
.text$mn:0000937C ; ---------------------------------------------------------------------------
.text$mn:0000937D                 align 10h
.text$mn:0000937D _text$mn        ends
.text$mn:0000937D
.text$mn:00009380 ; ===========================================================================
.text$mn:00009380
.text$mn:00009380 ; Segment type: Pure code
.text$mn:00009380 ; Segment permissions: Read/Execute
.text$mn:00009380 _text$mn        segment para public 'CODE' use32
.text$mn:00009380                 assume cs:_text$mn
.text$mn:00009380                 ;org 9380h
.text$mn:00009380 ; COMDAT (pick any)
.text$mn:00009380                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009380
.text$mn:00009380 ; =============== S U B R O U T I N E =======================================
.text$mn:00009380
.text$mn:00009380 ; Attributes: bp-based frame
.text$mn:00009380
.text$mn:00009380 ; protected: void __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Tidy(void)
.text$mn:00009380                 public ?_Tidy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXXZ
.text$mn:00009380 ?_Tidy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXXZ proc near
.text$mn:00009380                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::~vector<MenuItemUnit,std::allocator<MenuItemUnit>>(void)+30p
.text$mn:00009380
.text$mn:00009380 var_8           = dword ptr -8
.text$mn:00009380 var_1           = byte ptr -1
.text$mn:00009380
.text$mn:00009380                 push    ebp
.text$mn:00009381                 mov     ebp, esp
.text$mn:00009383                 sub     esp, 8
.text$mn:00009386                 mov     [ebp+var_8], ecx
.text$mn:00009389                 mov     eax, [ebp+var_8]
.text$mn:0000938C                 cmp     dword ptr [eax+4], 0
.text$mn:00009390                 jz      short loc_93FF
.text$mn:00009392                 mov     ecx, [ebp+var_8] ; this
.text$mn:00009395                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000939A                 mov     ecx, [ebp+var_8]
.text$mn:0000939D                 mov     edx, [ecx+8]
.text$mn:000093A0                 push    edx
.text$mn:000093A1                 mov     eax, [ebp+var_8]
.text$mn:000093A4                 mov     ecx, [eax+4]
.text$mn:000093A7                 push    ecx
.text$mn:000093A8                 mov     ecx, [ebp+var_8]
.text$mn:000093AB                 call    ?_Destroy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXPAUMenuItemUnit@@0@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Destroy(MenuItemUnit *,MenuItemUnit *)
.text$mn:000093B0                 mov     edx, [ebp+var_8]
.text$mn:000093B3                 mov     eax, [ebp+var_8]
.text$mn:000093B6                 mov     ecx, [edx+0Ch]
.text$mn:000093B9                 sub     ecx, [eax+4]
.text$mn:000093BC                 mov     eax, ecx
.text$mn:000093BE                 cdq
.text$mn:000093BF                 mov     ecx, 3Ch ; '<'
.text$mn:000093C4                 idiv    ecx
.text$mn:000093C6                 push    eax             ; int
.text$mn:000093C7                 mov     edx, [ebp+var_8]
.text$mn:000093CA                 mov     eax, [edx+4]
.text$mn:000093CD                 push    eax             ; void *
.text$mn:000093CE                 lea     ecx, [ebp+var_1]
.text$mn:000093D1                 push    ecx
.text$mn:000093D2                 mov     ecx, [ebp+var_8]
.text$mn:000093D5                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:000093DA                 mov     ecx, eax
.text$mn:000093DC                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@I@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::deallocate(MenuItemUnit *,uint)
.text$mn:000093E1                 mov     edx, [ebp+var_8]
.text$mn:000093E4                 mov     dword ptr [edx+4], 0
.text$mn:000093EB                 mov     eax, [ebp+var_8]
.text$mn:000093EE                 mov     dword ptr [eax+8], 0
.text$mn:000093F5                 mov     ecx, [ebp+var_8]
.text$mn:000093F8                 mov     dword ptr [ecx+0Ch], 0
.text$mn:000093FF
.text$mn:000093FF loc_93FF:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Tidy(void)+10j
.text$mn:000093FF                 mov     esp, ebp
.text$mn:00009401                 pop     ebp
.text$mn:00009402                 retn
.text$mn:00009402 ?_Tidy@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXXZ endp
.text$mn:00009402
.text$mn:00009402 ; ---------------------------------------------------------------------------
.text$mn:00009403                 align 4
.text$mn:00009403 _text$mn        ends
.text$mn:00009403
.text$mn:00009404 ; ===========================================================================
.text$mn:00009404
.text$mn:00009404 ; Segment type: Pure code
.text$mn:00009404 ; Segment permissions: Read/Execute
.text$mn:00009404 _text$mn        segment para public 'CODE' use32
.text$mn:00009404                 assume cs:_text$mn
.text$mn:00009404                 ;org 9404h
.text$mn:00009404 ; COMDAT (pick any)
.text$mn:00009404                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009404
.text$mn:00009404 ; =============== S U B R O U T I N E =======================================
.text$mn:00009404
.text$mn:00009404 ; Attributes: bp-based frame
.text$mn:00009404
.text$mn:00009404 ; public: unsigned int __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Unused_capacity(void)const
.text$mn:00009404                 public ?_Unused_capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ
.text$mn:00009404 ?_Unused_capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ proc near
.text$mn:00009404                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+Bp
.text$mn:00009404
.text$mn:00009404 var_4           = dword ptr -4
.text$mn:00009404
.text$mn:00009404                 push    ebp
.text$mn:00009405                 mov     ebp, esp
.text$mn:00009407                 push    ecx
.text$mn:00009408                 mov     [ebp+var_4], ecx
.text$mn:0000940B                 mov     eax, [ebp+var_4]
.text$mn:0000940E                 mov     ecx, [ebp+var_4]
.text$mn:00009411                 mov     eax, [eax+0Ch]
.text$mn:00009414                 sub     eax, [ecx+8]
.text$mn:00009417                 cdq
.text$mn:00009418                 mov     ecx, 3Ch ; '<'
.text$mn:0000941D                 idiv    ecx
.text$mn:0000941F                 mov     esp, ebp
.text$mn:00009421                 pop     ebp
.text$mn:00009422                 retn
.text$mn:00009422 ?_Unused_capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ endp
.text$mn:00009422
.text$mn:00009422 ; ---------------------------------------------------------------------------
.text$mn:00009423                 align 4
.text$mn:00009423 _text$mn        ends
.text$mn:00009423
.text$mn:00009424 ; ===========================================================================
.text$mn:00009424
.text$mn:00009424 ; Segment type: Pure code
.text$mn:00009424 ; Segment permissions: Read/Execute
.text$mn:00009424 _text$mn        segment para public 'CODE' use32
.text$mn:00009424                 assume cs:_text$mn
.text$mn:00009424                 ;org 9424h
.text$mn:00009424 ; COMDAT (pick any)
.text$mn:00009424                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009424
.text$mn:00009424 ; =============== S U B R O U T I N E =======================================
.text$mn:00009424
.text$mn:00009424 ; Attributes: bp-based frame
.text$mn:00009424
.text$mn:00009424 ; public: unsigned int __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Unused_capacity(void)const
.text$mn:00009424                 public ?_Unused_capacity@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ
.text$mn:00009424 ?_Unused_capacity@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ proc near
.text$mn:00009424                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reserve(uint)+Bp
.text$mn:00009424
.text$mn:00009424 var_4           = dword ptr -4
.text$mn:00009424
.text$mn:00009424                 push    ebp
.text$mn:00009425                 mov     ebp, esp
.text$mn:00009427                 push    ecx
.text$mn:00009428                 mov     [ebp+var_4], ecx
.text$mn:0000942B                 mov     eax, [ebp+var_4]
.text$mn:0000942E                 mov     ecx, [ebp+var_4]
.text$mn:00009431                 mov     eax, [eax+0Ch]
.text$mn:00009434                 sub     eax, [ecx+8]
.text$mn:00009437                 cdq
.text$mn:00009438                 mov     ecx, 2Ch ; ','
.text$mn:0000943D                 idiv    ecx
.text$mn:0000943F                 mov     esp, ebp
.text$mn:00009441                 pop     ebp
.text$mn:00009442                 retn
.text$mn:00009442 ?_Unused_capacity@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ endp
.text$mn:00009442
.text$mn:00009442 ; ---------------------------------------------------------------------------
.text$mn:00009443                 align 4
.text$mn:00009443 _text$mn        ends
.text$mn:00009443
.text$mn:00009444 ; ===========================================================================
.text$mn:00009444
.text$mn:00009444 ; Segment type: Pure code
.text$mn:00009444 ; Segment permissions: Read/Execute
.text$mn:00009444 _text$mn        segment para public 'CODE' use32
.text$mn:00009444                 assume cs:_text$mn
.text$mn:00009444                 ;org 9444h
.text$mn:00009444 ; COMDAT (pick any)
.text$mn:00009444                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009444
.text$mn:00009444 ; =============== S U B R O U T I N E =======================================
.text$mn:00009444
.text$mn:00009444 ; Attributes: bp-based frame
.text$mn:00009444
.text$mn:00009444 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00009444                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00009444 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00009444                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00009444
.text$mn:00009444 var_4           = dword ptr -4
.text$mn:00009444
.text$mn:00009444                 push    ebp
.text$mn:00009445                 mov     ebp, esp
.text$mn:00009447                 push    ecx
.text$mn:00009448                 mov     [ebp+var_4], ecx
.text$mn:0000944B                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00009450                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00009455                 mov     esp, ebp
.text$mn:00009457                 pop     ebp
.text$mn:00009458                 retn
.text$mn:00009458 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00009458
.text$mn:00009458 ; ---------------------------------------------------------------------------
.text$mn:00009459                 align 4
.text$mn:00009459 _text$mn        ends
.text$mn:00009459
.text$mn:0000945C ; ===========================================================================
.text$mn:0000945C
.text$mn:0000945C ; Segment type: Pure code
.text$mn:0000945C ; Segment permissions: Read/Execute
.text$mn:0000945C _text$mn        segment para public 'CODE' use32
.text$mn:0000945C                 assume cs:_text$mn
.text$mn:0000945C                 ;org 945Ch
.text$mn:0000945C ; COMDAT (pick any)
.text$mn:0000945C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000945C
.text$mn:0000945C ; =============== S U B R O U T I N E =======================================
.text$mn:0000945C
.text$mn:0000945C ; Attributes: bp-based frame
.text$mn:0000945C
.text$mn:0000945C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:0000945C                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:0000945C ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:0000945C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:0000945C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Dp ...
.text$mn:0000945C
.text$mn:0000945C var_4           = dword ptr -4
.text$mn:0000945C
.text$mn:0000945C                 push    ebp
.text$mn:0000945D                 mov     ebp, esp
.text$mn:0000945F                 push    ecx
.text$mn:00009460                 mov     [ebp+var_4], ecx
.text$mn:00009463                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00009468                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000946D                 mov     esp, ebp
.text$mn:0000946F                 pop     ebp
.text$mn:00009470                 retn
.text$mn:00009470 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00009470
.text$mn:00009470 ; ---------------------------------------------------------------------------
.text$mn:00009471                 align 4
.text$mn:00009471 _text$mn        ends
.text$mn:00009471
.text$mn:00009474 ; ===========================================================================
.text$mn:00009474
.text$mn:00009474 ; Segment type: Pure code
.text$mn:00009474 ; Segment permissions: Read/Execute
.text$mn:00009474 _text$mn        segment para public 'CODE' use32
.text$mn:00009474                 assume cs:_text$mn
.text$mn:00009474                 ;org 9474h
.text$mn:00009474 ; COMDAT (pick any)
.text$mn:00009474                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009474
.text$mn:00009474 ; =============== S U B R O U T I N E =======================================
.text$mn:00009474
.text$mn:00009474 ; Attributes: bp-based frame
.text$mn:00009474
.text$mn:00009474 ; protected: void __thiscall std::deque<unsigned int, class std::allocator<unsigned int>>::_Xlen(void)const
.text$mn:00009474                 public ?_Xlen@?$deque@IV?$allocator@I@std@@@std@@IBEXXZ
.text$mn:00009474 ?_Xlen@?$deque@IV?$allocator@I@std@@@std@@IBEXXZ proc near
.text$mn:00009474                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+69p
.text$mn:00009474
.text$mn:00009474 var_4           = dword ptr -4
.text$mn:00009474
.text$mn:00009474                 push    ebp
.text$mn:00009475                 mov     ebp, esp
.text$mn:00009477                 push    ecx
.text$mn:00009478                 mov     [ebp+var_4], ecx
.text$mn:0000947B                 push    offset ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; "deque<T> too long"
.text$mn:00009480                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00009485                 mov     esp, ebp
.text$mn:00009487                 pop     ebp
.text$mn:00009488                 retn
.text$mn:00009488 ?_Xlen@?$deque@IV?$allocator@I@std@@@std@@IBEXXZ endp
.text$mn:00009488
.text$mn:00009488 ; ---------------------------------------------------------------------------
.text$mn:00009489                 align 4
.text$mn:00009489 _text$mn        ends
.text$mn:00009489
.text$mn:0000948C ; ===========================================================================
.text$mn:0000948C
.text$mn:0000948C ; Segment type: Pure code
.text$mn:0000948C ; Segment permissions: Read/Execute
.text$mn:0000948C _text$mn        segment para public 'CODE' use32
.text$mn:0000948C                 assume cs:_text$mn
.text$mn:0000948C                 ;org 948Ch
.text$mn:0000948C ; COMDAT (pick any)
.text$mn:0000948C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000948C
.text$mn:0000948C ; =============== S U B R O U T I N E =======================================
.text$mn:0000948C
.text$mn:0000948C ; Attributes: bp-based frame
.text$mn:0000948C
.text$mn:0000948C ; protected: void __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::_Xlen(void)const
.text$mn:0000948C                 public ?_Xlen@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXXZ
.text$mn:0000948C ?_Xlen@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXXZ proc near
.text$mn:0000948C                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+31p
.text$mn:0000948C
.text$mn:0000948C var_4           = dword ptr -4
.text$mn:0000948C
.text$mn:0000948C                 push    ebp
.text$mn:0000948D                 mov     ebp, esp
.text$mn:0000948F                 push    ecx
.text$mn:00009490                 mov     [ebp+var_4], ecx
.text$mn:00009493                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00009498                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000949D                 mov     esp, ebp
.text$mn:0000949F                 pop     ebp
.text$mn:000094A0                 retn
.text$mn:000094A0 ?_Xlen@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXXZ endp
.text$mn:000094A0
.text$mn:000094A0 ; ---------------------------------------------------------------------------
.text$mn:000094A1                 align 4
.text$mn:000094A1 _text$mn        ends
.text$mn:000094A1
.text$mn:000094A4 ; ===========================================================================
.text$mn:000094A4
.text$mn:000094A4 ; Segment type: Pure code
.text$mn:000094A4 ; Segment permissions: Read/Execute
.text$mn:000094A4 _text$mn        segment para public 'CODE' use32
.text$mn:000094A4                 assume cs:_text$mn
.text$mn:000094A4                 ;org 94A4h
.text$mn:000094A4 ; COMDAT (pick any)
.text$mn:000094A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000094A4
.text$mn:000094A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000094A4
.text$mn:000094A4 ; Attributes: bp-based frame
.text$mn:000094A4
.text$mn:000094A4 ; protected: void __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::_Xlen(void)const
.text$mn:000094A4                 public ?_Xlen@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXXZ
.text$mn:000094A4 ?_Xlen@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXXZ proc near
.text$mn:000094A4                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reserve(uint)+31p
.text$mn:000094A4
.text$mn:000094A4 var_4           = dword ptr -4
.text$mn:000094A4
.text$mn:000094A4                 push    ebp
.text$mn:000094A5                 mov     ebp, esp
.text$mn:000094A7                 push    ecx
.text$mn:000094A8                 mov     [ebp+var_4], ecx
.text$mn:000094AB                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:000094B0                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000094B5                 mov     esp, ebp
.text$mn:000094B7                 pop     ebp
.text$mn:000094B8                 retn
.text$mn:000094B8 ?_Xlen@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXXZ endp
.text$mn:000094B8
.text$mn:000094B8 ; ---------------------------------------------------------------------------
.text$mn:000094B9                 align 4
.text$mn:000094B9 _text$mn        ends
.text$mn:000094B9
.text$mn:000094BC ; ===========================================================================
.text$mn:000094BC
.text$mn:000094BC ; Segment type: Pure code
.text$mn:000094BC ; Segment permissions: Read/Execute
.text$mn:000094BC _text$mn        segment para public 'CODE' use32
.text$mn:000094BC                 assume cs:_text$mn
.text$mn:000094BC                 ;org 94BCh
.text$mn:000094BC ; COMDAT (pick any)
.text$mn:000094BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000094BC
.text$mn:000094BC ; =============== S U B R O U T I N E =======================================
.text$mn:000094BC
.text$mn:000094BC ; Attributes: bp-based frame
.text$mn:000094BC
.text$mn:000094BC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000094BC                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000094BC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000094BC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000094BC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::at(uint)+15p ...
.text$mn:000094BC
.text$mn:000094BC var_4           = dword ptr -4
.text$mn:000094BC
.text$mn:000094BC                 push    ebp
.text$mn:000094BD                 mov     ebp, esp
.text$mn:000094BF                 push    ecx
.text$mn:000094C0                 mov     [ebp+var_4], ecx
.text$mn:000094C3                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000094C8                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000094CD                 mov     esp, ebp
.text$mn:000094CF                 pop     ebp
.text$mn:000094D0                 retn
.text$mn:000094D0 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000094D0
.text$mn:000094D0 ; ---------------------------------------------------------------------------
.text$mn:000094D1                 align 4
.text$mn:000094D1 _text$mn        ends
.text$mn:000094D1
.text$mn:000094D4 ; ===========================================================================
.text$mn:000094D4
.text$mn:000094D4 ; Segment type: Pure code
.text$mn:000094D4 ; Segment permissions: Read/Execute
.text$mn:000094D4 _text$mn        segment para public 'CODE' use32
.text$mn:000094D4                 assume cs:_text$mn
.text$mn:000094D4                 ;org 94D4h
.text$mn:000094D4 ; COMDAT (pick any)
.text$mn:000094D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000094D4
.text$mn:000094D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000094D4
.text$mn:000094D4 ; Attributes: bp-based frame
.text$mn:000094D4
.text$mn:000094D4 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:000094D4                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:000094D4 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:000094D4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:000094D4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p ...
.text$mn:000094D4
.text$mn:000094D4 var_4           = dword ptr -4
.text$mn:000094D4
.text$mn:000094D4                 push    ebp
.text$mn:000094D5                 mov     ebp, esp
.text$mn:000094D7                 push    ecx
.text$mn:000094D8                 mov     [ebp+var_4], ecx
.text$mn:000094DB                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000094E0                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000094E5                 mov     esp, ebp
.text$mn:000094E7                 pop     ebp
.text$mn:000094E8                 retn
.text$mn:000094E8 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:000094E8
.text$mn:000094E8 ; ---------------------------------------------------------------------------
.text$mn:000094E9                 align 4
.text$mn:000094E9 _text$mn        ends
.text$mn:000094E9
.text$mn:000094EC ; ===========================================================================
.text$mn:000094EC
.text$mn:000094EC ; Segment type: Pure code
.text$mn:000094EC ; Segment permissions: Read/Execute
.text$mn:000094EC _text$mn        segment para public 'CODE' use32
.text$mn:000094EC                 assume cs:_text$mn
.text$mn:000094EC                 ;org 94ECh
.text$mn:000094EC ; COMDAT (pick any)
.text$mn:000094EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000094EC
.text$mn:000094EC ; =============== S U B R O U T I N E =======================================
.text$mn:000094EC
.text$mn:000094EC ; Attributes: bp-based frame
.text$mn:000094EC
.text$mn:000094EC ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:000094EC                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:000094EC ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:000094EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:000094EC                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:000094EC
.text$mn:000094EC var_4           = dword ptr -4
.text$mn:000094EC arg_0           = dword ptr  8
.text$mn:000094EC
.text$mn:000094EC                 push    ebp
.text$mn:000094ED                 mov     ebp, esp
.text$mn:000094EF                 push    ecx
.text$mn:000094F0                 mov     [ebp+var_4], ecx
.text$mn:000094F3                 mov     eax, [ebp+arg_0]
.text$mn:000094F6                 push    eax
.text$mn:000094F7                 mov     ecx, [ebp+var_4]
.text$mn:000094FA                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:000094FF                 mov     esp, ebp
.text$mn:00009501                 pop     ebp
.text$mn:00009502                 retn    4
.text$mn:00009502 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00009502
.text$mn:00009502 ; ---------------------------------------------------------------------------
.text$mn:00009505                 align 4
.text$mn:00009505 _text$mn        ends
.text$mn:00009505
.text$mn:00009508 ; ===========================================================================
.text$mn:00009508
.text$mn:00009508 ; Segment type: Pure code
.text$mn:00009508 ; Segment permissions: Read/Execute
.text$mn:00009508 _text$mn        segment para public 'CODE' use32
.text$mn:00009508                 assume cs:_text$mn
.text$mn:00009508                 ;org 9508h
.text$mn:00009508 ; COMDAT (pick any)
.text$mn:00009508                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009508
.text$mn:00009508 ; =============== S U B R O U T I N E =======================================
.text$mn:00009508
.text$mn:00009508 ; Attributes: bp-based frame
.text$mn:00009508
.text$mn:00009508 ; public: unsigned int * __thiscall std::_Wrap_alloc<class std::allocator<unsigned int>>::allocate(unsigned int)
.text$mn:00009508                 public ?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z
.text$mn:00009508 ?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z proc near
.text$mn:00009508                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::push_back(uint const &)+9Fp
.text$mn:00009508
.text$mn:00009508 var_4           = dword ptr -4
.text$mn:00009508 arg_0           = dword ptr  8
.text$mn:00009508
.text$mn:00009508                 push    ebp
.text$mn:00009509                 mov     ebp, esp
.text$mn:0000950B                 push    ecx
.text$mn:0000950C                 mov     [ebp+var_4], ecx
.text$mn:0000950F                 mov     eax, [ebp+arg_0]
.text$mn:00009512                 push    eax
.text$mn:00009513                 mov     ecx, [ebp+var_4]
.text$mn:00009516                 call    ?allocate@?$allocator@I@std@@QAEPAII@Z ; std::allocator<uint>::allocate(uint)
.text$mn:0000951B                 mov     esp, ebp
.text$mn:0000951D                 pop     ebp
.text$mn:0000951E                 retn    4
.text$mn:0000951E ?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z endp
.text$mn:0000951E
.text$mn:0000951E ; ---------------------------------------------------------------------------
.text$mn:00009521                 align 4
.text$mn:00009521 _text$mn        ends
.text$mn:00009521
.text$mn:00009524 ; ===========================================================================
.text$mn:00009524
.text$mn:00009524 ; Segment type: Pure code
.text$mn:00009524 ; Segment permissions: Read/Execute
.text$mn:00009524 _text$mn        segment para public 'CODE' use32
.text$mn:00009524                 assume cs:_text$mn
.text$mn:00009524                 ;org 9524h
.text$mn:00009524 ; COMDAT (pick any)
.text$mn:00009524                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009524
.text$mn:00009524 ; =============== S U B R O U T I N E =======================================
.text$mn:00009524
.text$mn:00009524 ; Attributes: bp-based frame
.text$mn:00009524
.text$mn:00009524 ; public: unsigned int * * __thiscall std::_Wrap_alloc<class std::allocator<unsigned int *>>::allocate(unsigned int)
.text$mn:00009524                 public ?allocate@?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@QAEPAPAII@Z
.text$mn:00009524 ?allocate@?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@QAEPAPAII@Z proc near
.text$mn:00009524                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+9Dp
.text$mn:00009524
.text$mn:00009524 var_4           = dword ptr -4
.text$mn:00009524 arg_0           = dword ptr  8
.text$mn:00009524
.text$mn:00009524                 push    ebp
.text$mn:00009525                 mov     ebp, esp
.text$mn:00009527                 push    ecx
.text$mn:00009528                 mov     [ebp+var_4], ecx
.text$mn:0000952B                 mov     eax, [ebp+arg_0]
.text$mn:0000952E                 push    eax
.text$mn:0000952F                 mov     ecx, [ebp+var_4]
.text$mn:00009532                 call    ?allocate@?$allocator@PAI@std@@QAEPAPAII@Z ; std::allocator<uint *>::allocate(uint)
.text$mn:00009537                 mov     esp, ebp
.text$mn:00009539                 pop     ebp
.text$mn:0000953A                 retn    4
.text$mn:0000953A ?allocate@?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@QAEPAPAII@Z endp
.text$mn:0000953A
.text$mn:0000953A ; ---------------------------------------------------------------------------
.text$mn:0000953D                 align 10h
.text$mn:0000953D _text$mn        ends
.text$mn:0000953D
.text$mn:00009540 ; ===========================================================================
.text$mn:00009540
.text$mn:00009540 ; Segment type: Pure code
.text$mn:00009540 ; Segment permissions: Read/Execute
.text$mn:00009540 _text$mn        segment para public 'CODE' use32
.text$mn:00009540                 assume cs:_text$mn
.text$mn:00009540                 ;org 9540h
.text$mn:00009540 ; COMDAT (pick any)
.text$mn:00009540                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009540
.text$mn:00009540 ; =============== S U B R O U T I N E =======================================
.text$mn:00009540
.text$mn:00009540 ; Attributes: bp-based frame
.text$mn:00009540
.text$mn:00009540 ; public: struct MenuItemUnit * __thiscall std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>::allocate(unsigned int)
.text$mn:00009540                 public ?allocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEPAUMenuItemUnit@@I@Z
.text$mn:00009540 ?allocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEPAUMenuItemUnit@@I@Z proc near
.text$mn:00009540                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+41p
.text$mn:00009540
.text$mn:00009540 var_4           = dword ptr -4
.text$mn:00009540 arg_0           = dword ptr  8
.text$mn:00009540
.text$mn:00009540                 push    ebp
.text$mn:00009541                 mov     ebp, esp
.text$mn:00009543                 push    ecx
.text$mn:00009544                 mov     [ebp+var_4], ecx
.text$mn:00009547                 mov     eax, [ebp+arg_0]
.text$mn:0000954A                 push    eax
.text$mn:0000954B                 mov     ecx, [ebp+var_4]
.text$mn:0000954E                 call    ?allocate@?$allocator@UMenuItemUnit@@@std@@QAEPAUMenuItemUnit@@I@Z ; std::allocator<MenuItemUnit>::allocate(uint)
.text$mn:00009553                 mov     esp, ebp
.text$mn:00009555                 pop     ebp
.text$mn:00009556                 retn    4
.text$mn:00009556 ?allocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEPAUMenuItemUnit@@I@Z endp
.text$mn:00009556
.text$mn:00009556 ; ---------------------------------------------------------------------------
.text$mn:00009559                 align 4
.text$mn:00009559 _text$mn        ends
.text$mn:00009559
.text$mn:0000955C ; ===========================================================================
.text$mn:0000955C
.text$mn:0000955C ; Segment type: Pure code
.text$mn:0000955C ; Segment permissions: Read/Execute
.text$mn:0000955C _text$mn        segment para public 'CODE' use32
.text$mn:0000955C                 assume cs:_text$mn
.text$mn:0000955C                 ;org 955Ch
.text$mn:0000955C ; COMDAT (pick any)
.text$mn:0000955C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000955C
.text$mn:0000955C ; =============== S U B R O U T I N E =======================================
.text$mn:0000955C
.text$mn:0000955C ; Attributes: bp-based frame
.text$mn:0000955C
.text$mn:0000955C ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:0000955C                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000955C ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000955C                                         ; CODE XREF: std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Alloc_proxy(void)+16p
.text$mn:0000955C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Alloc_proxy(void)+16p
.text$mn:0000955C
.text$mn:0000955C var_4           = dword ptr -4
.text$mn:0000955C arg_0           = dword ptr  8
.text$mn:0000955C
.text$mn:0000955C                 push    ebp
.text$mn:0000955D                 mov     ebp, esp
.text$mn:0000955F                 push    ecx
.text$mn:00009560                 mov     [ebp+var_4], ecx
.text$mn:00009563                 mov     eax, [ebp+arg_0]
.text$mn:00009566                 push    eax
.text$mn:00009567                 mov     ecx, [ebp+var_4]
.text$mn:0000956A                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:0000956F                 mov     esp, ebp
.text$mn:00009571                 pop     ebp
.text$mn:00009572                 retn    4
.text$mn:00009572 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00009572
.text$mn:00009572 ; ---------------------------------------------------------------------------
.text$mn:00009575                 align 4
.text$mn:00009575 _text$mn        ends
.text$mn:00009575
.text$mn:00009578 ; ===========================================================================
.text$mn:00009578
.text$mn:00009578 ; Segment type: Pure code
.text$mn:00009578 ; Segment permissions: Read/Execute
.text$mn:00009578 _text$mn        segment para public 'CODE' use32
.text$mn:00009578                 assume cs:_text$mn
.text$mn:00009578                 ;org 9578h
.text$mn:00009578 ; COMDAT (pick any)
.text$mn:00009578                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009578
.text$mn:00009578 ; =============== S U B R O U T I N E =======================================
.text$mn:00009578
.text$mn:00009578 ; Attributes: bp-based frame
.text$mn:00009578
.text$mn:00009578 ; public: struct recordedMacroStep * __thiscall std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>::allocate(unsigned int)
.text$mn:00009578                 public ?allocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEPAUrecordedMacroStep@@I@Z
.text$mn:00009578 ?allocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEPAUrecordedMacroStep@@I@Z proc near
.text$mn:00009578                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reallocate(uint)+41p
.text$mn:00009578
.text$mn:00009578 var_4           = dword ptr -4
.text$mn:00009578 arg_0           = dword ptr  8
.text$mn:00009578
.text$mn:00009578                 push    ebp
.text$mn:00009579                 mov     ebp, esp
.text$mn:0000957B                 push    ecx
.text$mn:0000957C                 mov     [ebp+var_4], ecx
.text$mn:0000957F                 mov     eax, [ebp+arg_0]
.text$mn:00009582                 push    eax
.text$mn:00009583                 mov     ecx, [ebp+var_4]
.text$mn:00009586                 call    ?allocate@?$allocator@UrecordedMacroStep@@@std@@QAEPAUrecordedMacroStep@@I@Z ; std::allocator<recordedMacroStep>::allocate(uint)
.text$mn:0000958B                 mov     esp, ebp
.text$mn:0000958D                 pop     ebp
.text$mn:0000958E                 retn    4
.text$mn:0000958E ?allocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEPAUrecordedMacroStep@@I@Z endp
.text$mn:0000958E
.text$mn:0000958E ; ---------------------------------------------------------------------------
.text$mn:00009591                 align 4
.text$mn:00009591 _text$mn        ends
.text$mn:00009591
.text$mn:00009594 ; ===========================================================================
.text$mn:00009594
.text$mn:00009594 ; Segment type: Pure code
.text$mn:00009594 ; Segment permissions: Read/Execute
.text$mn:00009594 _text$mn        segment para public 'CODE' use32
.text$mn:00009594                 assume cs:_text$mn
.text$mn:00009594                 ;org 9594h
.text$mn:00009594 ; COMDAT (pick any)
.text$mn:00009594                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009594
.text$mn:00009594 ; =============== S U B R O U T I N E =======================================
.text$mn:00009594
.text$mn:00009594 ; Attributes: bp-based frame
.text$mn:00009594
.text$mn:00009594 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:00009594                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:00009594 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:00009594                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:00009594                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:00009594
.text$mn:00009594 var_4           = dword ptr -4
.text$mn:00009594 arg_0           = dword ptr  8
.text$mn:00009594
.text$mn:00009594                 push    ebp
.text$mn:00009595                 mov     ebp, esp
.text$mn:00009597                 push    ecx
.text$mn:00009598                 mov     [ebp+var_4], ecx
.text$mn:0000959B                 mov     eax, [ebp+arg_0]
.text$mn:0000959E                 push    eax
.text$mn:0000959F                 mov     ecx, [ebp+var_4]
.text$mn:000095A2                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:000095A7                 mov     esp, ebp
.text$mn:000095A9                 pop     ebp
.text$mn:000095AA                 retn    4
.text$mn:000095AA ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:000095AA
.text$mn:000095AA ; ---------------------------------------------------------------------------
.text$mn:000095AD                 align 10h
.text$mn:000095AD _text$mn        ends
.text$mn:000095AD
.text$mn:000095B0 ; ===========================================================================
.text$mn:000095B0
.text$mn:000095B0 ; Segment type: Pure code
.text$mn:000095B0 ; Segment permissions: Read/Execute
.text$mn:000095B0 _text$mn        segment para public 'CODE' use32
.text$mn:000095B0                 assume cs:_text$mn
.text$mn:000095B0                 ;org 95B0h
.text$mn:000095B0 ; COMDAT (pick any)
.text$mn:000095B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000095B0
.text$mn:000095B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000095B0
.text$mn:000095B0 ; Attributes: bp-based frame
.text$mn:000095B0
.text$mn:000095B0 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:000095B0                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:000095B0 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:000095B0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:000095B0
.text$mn:000095B0 var_4           = dword ptr -4
.text$mn:000095B0 arg_0           = dword ptr  8
.text$mn:000095B0
.text$mn:000095B0                 push    ebp
.text$mn:000095B1                 mov     ebp, esp
.text$mn:000095B3                 push    ecx
.text$mn:000095B4                 mov     [ebp+var_4], ecx
.text$mn:000095B7                 push    0
.text$mn:000095B9                 mov     eax, [ebp+arg_0]
.text$mn:000095BC                 push    eax
.text$mn:000095BD                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:000095C2                 add     esp, 8
.text$mn:000095C5                 mov     esp, ebp
.text$mn:000095C7                 pop     ebp
.text$mn:000095C8                 retn    4
.text$mn:000095C8 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:000095C8
.text$mn:000095C8 ; ---------------------------------------------------------------------------
.text$mn:000095CB                 align 4
.text$mn:000095CB _text$mn        ends
.text$mn:000095CB
.text$mn:000095CC ; ===========================================================================
.text$mn:000095CC
.text$mn:000095CC ; Segment type: Pure code
.text$mn:000095CC ; Segment permissions: Read/Execute
.text$mn:000095CC _text$mn        segment para public 'CODE' use32
.text$mn:000095CC                 assume cs:_text$mn
.text$mn:000095CC                 ;org 95CCh
.text$mn:000095CC ; COMDAT (pick any)
.text$mn:000095CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000095CC
.text$mn:000095CC ; =============== S U B R O U T I N E =======================================
.text$mn:000095CC
.text$mn:000095CC ; Attributes: bp-based frame
.text$mn:000095CC
.text$mn:000095CC ; public: unsigned int * __thiscall std::allocator<unsigned int>::allocate(unsigned int)
.text$mn:000095CC                 public ?allocate@?$allocator@I@std@@QAEPAII@Z
.text$mn:000095CC ?allocate@?$allocator@I@std@@QAEPAII@Z proc near
.text$mn:000095CC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::allocate(uint)+Ep
.text$mn:000095CC
.text$mn:000095CC var_4           = dword ptr -4
.text$mn:000095CC arg_0           = dword ptr  8
.text$mn:000095CC
.text$mn:000095CC                 push    ebp
.text$mn:000095CD                 mov     ebp, esp
.text$mn:000095CF                 push    ecx
.text$mn:000095D0                 mov     [ebp+var_4], ecx
.text$mn:000095D3                 push    0
.text$mn:000095D5                 mov     eax, [ebp+arg_0]
.text$mn:000095D8                 push    eax
.text$mn:000095D9                 call    ??$_Allocate@I@std@@YAPAIIPAI@Z ; std::_Allocate<uint>(uint,uint *)
.text$mn:000095DE                 add     esp, 8
.text$mn:000095E1                 mov     esp, ebp
.text$mn:000095E3                 pop     ebp
.text$mn:000095E4                 retn    4
.text$mn:000095E4 ?allocate@?$allocator@I@std@@QAEPAII@Z endp
.text$mn:000095E4
.text$mn:000095E4 ; ---------------------------------------------------------------------------
.text$mn:000095E7                 align 4
.text$mn:000095E7 _text$mn        ends
.text$mn:000095E7
.text$mn:000095E8 ; ===========================================================================
.text$mn:000095E8
.text$mn:000095E8 ; Segment type: Pure code
.text$mn:000095E8 ; Segment permissions: Read/Execute
.text$mn:000095E8 _text$mn        segment para public 'CODE' use32
.text$mn:000095E8                 assume cs:_text$mn
.text$mn:000095E8                 ;org 95E8h
.text$mn:000095E8 ; COMDAT (pick any)
.text$mn:000095E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000095E8
.text$mn:000095E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000095E8
.text$mn:000095E8 ; Attributes: bp-based frame
.text$mn:000095E8
.text$mn:000095E8 ; public: unsigned int * * __thiscall std::allocator<unsigned int *>::allocate(unsigned int)
.text$mn:000095E8                 public ?allocate@?$allocator@PAI@std@@QAEPAPAII@Z
.text$mn:000095E8 ?allocate@?$allocator@PAI@std@@QAEPAPAII@Z proc near
.text$mn:000095E8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint *>>::allocate(uint)+Ep
.text$mn:000095E8
.text$mn:000095E8 var_4           = dword ptr -4
.text$mn:000095E8 arg_0           = dword ptr  8
.text$mn:000095E8
.text$mn:000095E8                 push    ebp
.text$mn:000095E9                 mov     ebp, esp
.text$mn:000095EB                 push    ecx
.text$mn:000095EC                 mov     [ebp+var_4], ecx
.text$mn:000095EF                 push    0
.text$mn:000095F1                 mov     eax, [ebp+arg_0]
.text$mn:000095F4                 push    eax
.text$mn:000095F5                 call    ??$_Allocate@PAI@std@@YAPAPAIIPAPAI@Z ; std::_Allocate<uint *>(uint,uint * *)
.text$mn:000095FA                 add     esp, 8
.text$mn:000095FD                 mov     esp, ebp
.text$mn:000095FF                 pop     ebp
.text$mn:00009600                 retn    4
.text$mn:00009600 ?allocate@?$allocator@PAI@std@@QAEPAPAII@Z endp
.text$mn:00009600
.text$mn:00009600 ; ---------------------------------------------------------------------------
.text$mn:00009603                 align 4
.text$mn:00009603 _text$mn        ends
.text$mn:00009603
.text$mn:00009604 ; ===========================================================================
.text$mn:00009604
.text$mn:00009604 ; Segment type: Pure code
.text$mn:00009604 ; Segment permissions: Read/Execute
.text$mn:00009604 _text$mn        segment para public 'CODE' use32
.text$mn:00009604                 assume cs:_text$mn
.text$mn:00009604                 ;org 9604h
.text$mn:00009604 ; COMDAT (pick any)
.text$mn:00009604                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009604
.text$mn:00009604 ; =============== S U B R O U T I N E =======================================
.text$mn:00009604
.text$mn:00009604 ; Attributes: bp-based frame
.text$mn:00009604
.text$mn:00009604 ; public: struct MenuItemUnit * __thiscall std::allocator<struct MenuItemUnit>::allocate(unsigned int)
.text$mn:00009604                 public ?allocate@?$allocator@UMenuItemUnit@@@std@@QAEPAUMenuItemUnit@@I@Z
.text$mn:00009604 ?allocate@?$allocator@UMenuItemUnit@@@std@@QAEPAUMenuItemUnit@@I@Z proc near
.text$mn:00009604                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MenuItemUnit>>::allocate(uint)+Ep
.text$mn:00009604
.text$mn:00009604 var_4           = dword ptr -4
.text$mn:00009604 arg_0           = dword ptr  8
.text$mn:00009604
.text$mn:00009604                 push    ebp
.text$mn:00009605                 mov     ebp, esp
.text$mn:00009607                 push    ecx
.text$mn:00009608                 mov     [ebp+var_4], ecx
.text$mn:0000960B                 push    0
.text$mn:0000960D                 mov     eax, [ebp+arg_0]
.text$mn:00009610                 push    eax
.text$mn:00009611                 call    ??$_Allocate@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@IPAU1@@Z ; std::_Allocate<MenuItemUnit>(uint,MenuItemUnit *)
.text$mn:00009616                 add     esp, 8
.text$mn:00009619                 mov     esp, ebp
.text$mn:0000961B                 pop     ebp
.text$mn:0000961C                 retn    4
.text$mn:0000961C ?allocate@?$allocator@UMenuItemUnit@@@std@@QAEPAUMenuItemUnit@@I@Z endp
.text$mn:0000961C
.text$mn:0000961C ; ---------------------------------------------------------------------------
.text$mn:0000961F                 align 10h
.text$mn:0000961F _text$mn        ends
.text$mn:0000961F
.text$mn:00009620 ; ===========================================================================
.text$mn:00009620
.text$mn:00009620 ; Segment type: Pure code
.text$mn:00009620 ; Segment permissions: Read/Execute
.text$mn:00009620 _text$mn        segment para public 'CODE' use32
.text$mn:00009620                 assume cs:_text$mn
.text$mn:00009620                 ;org 9620h
.text$mn:00009620 ; COMDAT (pick any)
.text$mn:00009620                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009620
.text$mn:00009620 ; =============== S U B R O U T I N E =======================================
.text$mn:00009620
.text$mn:00009620 ; Attributes: bp-based frame
.text$mn:00009620
.text$mn:00009620 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00009620                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00009620 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00009620                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00009620                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p ...
.text$mn:00009620
.text$mn:00009620 var_4           = dword ptr -4
.text$mn:00009620 arg_0           = dword ptr  8
.text$mn:00009620
.text$mn:00009620                 push    ebp
.text$mn:00009621                 mov     ebp, esp
.text$mn:00009623                 push    ecx
.text$mn:00009624                 mov     [ebp+var_4], ecx
.text$mn:00009627                 push    0
.text$mn:00009629                 mov     eax, [ebp+arg_0]
.text$mn:0000962C                 push    eax
.text$mn:0000962D                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00009632                 add     esp, 8
.text$mn:00009635                 mov     esp, ebp
.text$mn:00009637                 pop     ebp
.text$mn:00009638                 retn    4
.text$mn:00009638 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00009638
.text$mn:00009638 ; ---------------------------------------------------------------------------
.text$mn:0000963B                 align 4
.text$mn:0000963B _text$mn        ends
.text$mn:0000963B
.text$mn:0000963C ; ===========================================================================
.text$mn:0000963C
.text$mn:0000963C ; Segment type: Pure code
.text$mn:0000963C ; Segment permissions: Read/Execute
.text$mn:0000963C _text$mn        segment para public 'CODE' use32
.text$mn:0000963C                 assume cs:_text$mn
.text$mn:0000963C                 ;org 963Ch
.text$mn:0000963C ; COMDAT (pick any)
.text$mn:0000963C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000963C
.text$mn:0000963C ; =============== S U B R O U T I N E =======================================
.text$mn:0000963C
.text$mn:0000963C ; Attributes: bp-based frame
.text$mn:0000963C
.text$mn:0000963C ; public: struct recordedMacroStep * __thiscall std::allocator<struct recordedMacroStep>::allocate(unsigned int)
.text$mn:0000963C                 public ?allocate@?$allocator@UrecordedMacroStep@@@std@@QAEPAUrecordedMacroStep@@I@Z
.text$mn:0000963C ?allocate@?$allocator@UrecordedMacroStep@@@std@@QAEPAUrecordedMacroStep@@I@Z proc near
.text$mn:0000963C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::allocate(uint)+Ep
.text$mn:0000963C
.text$mn:0000963C var_4           = dword ptr -4
.text$mn:0000963C arg_0           = dword ptr  8
.text$mn:0000963C
.text$mn:0000963C                 push    ebp
.text$mn:0000963D                 mov     ebp, esp
.text$mn:0000963F                 push    ecx
.text$mn:00009640                 mov     [ebp+var_4], ecx
.text$mn:00009643                 push    0
.text$mn:00009645                 mov     eax, [ebp+arg_0]
.text$mn:00009648                 push    eax
.text$mn:00009649                 call    ??$_Allocate@UrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@IPAU1@@Z ; std::_Allocate<recordedMacroStep>(uint,recordedMacroStep *)
.text$mn:0000964E                 add     esp, 8
.text$mn:00009651                 mov     esp, ebp
.text$mn:00009653                 pop     ebp
.text$mn:00009654                 retn    4
.text$mn:00009654 ?allocate@?$allocator@UrecordedMacroStep@@@std@@QAEPAUrecordedMacroStep@@I@Z endp
.text$mn:00009654
.text$mn:00009654 ; ---------------------------------------------------------------------------
.text$mn:00009657                 align 4
.text$mn:00009657 _text$mn        ends
.text$mn:00009657
.text$mn:00009658 ; ===========================================================================
.text$mn:00009658
.text$mn:00009658 ; Segment type: Pure code
.text$mn:00009658 ; Segment permissions: Read/Execute
.text$mn:00009658 _text$mn        segment para public 'CODE' use32
.text$mn:00009658                 assume cs:_text$mn
.text$mn:00009658                 ;org 9658h
.text$mn:00009658 ; COMDAT (pick any)
.text$mn:00009658                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009658
.text$mn:00009658 ; =============== S U B R O U T I N E =======================================
.text$mn:00009658
.text$mn:00009658 ; Attributes: bp-based frame
.text$mn:00009658
.text$mn:00009658 ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:00009658                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:00009658 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:00009658                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:00009658
.text$mn:00009658 var_4           = dword ptr -4
.text$mn:00009658 arg_0           = dword ptr  8
.text$mn:00009658
.text$mn:00009658                 push    ebp
.text$mn:00009659                 mov     ebp, esp
.text$mn:0000965B                 push    ecx
.text$mn:0000965C                 mov     [ebp+var_4], ecx
.text$mn:0000965F                 push    0
.text$mn:00009661                 mov     eax, [ebp+arg_0]
.text$mn:00009664                 push    eax
.text$mn:00009665                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:0000966A                 add     esp, 8
.text$mn:0000966D                 mov     esp, ebp
.text$mn:0000966F                 pop     ebp
.text$mn:00009670                 retn    4
.text$mn:00009670 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:00009670
.text$mn:00009670 ; ---------------------------------------------------------------------------
.text$mn:00009673                 align 4
.text$mn:00009673 _text$mn        ends
.text$mn:00009673
.text$mn:00009674 ; ===========================================================================
.text$mn:00009674
.text$mn:00009674 ; Segment type: Pure code
.text$mn:00009674 ; Segment permissions: Read/Execute
.text$mn:00009674 _text$mn        segment para public 'CODE' use32
.text$mn:00009674                 assume cs:_text$mn
.text$mn:00009674                 ;org 9674h
.text$mn:00009674 ; COMDAT (pick any)
.text$mn:00009674                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009674
.text$mn:00009674 ; =============== S U B R O U T I N E =======================================
.text$mn:00009674
.text$mn:00009674 ; Attributes: bp-based frame
.text$mn:00009674
.text$mn:00009674 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:00009674                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00009674 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00009674                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+53p
.text$mn:00009674
.text$mn:00009674 var_8           = dword ptr -8
.text$mn:00009674 var_4           = dword ptr -4
.text$mn:00009674 arg_0           = dword ptr  8
.text$mn:00009674 arg_4           = dword ptr  0Ch
.text$mn:00009674 arg_8           = dword ptr  10h
.text$mn:00009674
.text$mn:00009674                 push    ebp
.text$mn:00009675                 mov     ebp, esp
.text$mn:00009677                 sub     esp, 8
.text$mn:0000967A                 mov     [ebp+var_4], ecx
.text$mn:0000967D                 mov     ecx, [ebp+arg_0]
.text$mn:00009680                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00009685                 cmp     eax, [ebp+arg_4]
.text$mn:00009688                 jnb     short loc_9692
.text$mn:0000968A                 mov     ecx, [ebp+var_4]
.text$mn:0000968D                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00009692
.text$mn:00009692 loc_9692:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:00009692                 mov     ecx, [ebp+arg_0]
.text$mn:00009695                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000969A                 sub     eax, [ebp+arg_4]
.text$mn:0000969D                 mov     [ebp+var_8], eax
.text$mn:000096A0                 mov     eax, [ebp+var_8]
.text$mn:000096A3                 cmp     eax, [ebp+arg_8]
.text$mn:000096A6                 jnb     short loc_96AE
.text$mn:000096A8                 mov     ecx, [ebp+var_8]
.text$mn:000096AB                 mov     [ebp+arg_8], ecx
.text$mn:000096AE
.text$mn:000096AE loc_96AE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:000096AE                 mov     edx, [ebp+var_4]
.text$mn:000096B1                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:000096B6                 sub     eax, [edx+14h]
.text$mn:000096B9                 cmp     eax, [ebp+arg_8]
.text$mn:000096BC                 ja      short loc_96C6
.text$mn:000096BE                 mov     ecx, [ebp+var_4]
.text$mn:000096C1                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:000096C6
.text$mn:000096C6 loc_96C6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+48j
.text$mn:000096C6                 cmp     [ebp+arg_8], 0
.text$mn:000096CA                 jbe     short loc_9726
.text$mn:000096CC                 mov     ecx, [ebp+var_4]
.text$mn:000096CF                 mov     edx, [ecx+14h]
.text$mn:000096D2                 add     edx, [ebp+arg_8]
.text$mn:000096D5                 mov     [ebp+var_8], edx
.text$mn:000096D8                 push    0
.text$mn:000096DA                 mov     eax, [ebp+var_8]
.text$mn:000096DD                 push    eax
.text$mn:000096DE                 mov     ecx, [ebp+var_4]
.text$mn:000096E1                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:000096E6                 movzx   ecx, al
.text$mn:000096E9                 test    ecx, ecx
.text$mn:000096EB                 jz      short loc_9726
.text$mn:000096ED                 mov     edx, [ebp+arg_8]
.text$mn:000096F0                 push    edx             ; int
.text$mn:000096F1                 mov     ecx, [ebp+arg_0]
.text$mn:000096F4                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000096F9                 mov     ecx, [ebp+arg_4]
.text$mn:000096FC                 lea     edx, [eax+ecx*2]
.text$mn:000096FF                 push    edx             ; Src
.text$mn:00009700                 mov     ecx, [ebp+var_4]
.text$mn:00009703                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009708                 mov     ecx, [ebp+var_4]
.text$mn:0000970B                 mov     edx, [ecx+14h]
.text$mn:0000970E                 lea     eax, [eax+edx*2]
.text$mn:00009711                 push    eax             ; Dst
.text$mn:00009712                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00009717                 add     esp, 0Ch
.text$mn:0000971A                 mov     ecx, [ebp+var_8]
.text$mn:0000971D                 push    ecx
.text$mn:0000971E                 mov     ecx, [ebp+var_4]
.text$mn:00009721                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00009726
.text$mn:00009726 loc_9726:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+56j
.text$mn:00009726                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+77j
.text$mn:00009726                 mov     eax, [ebp+var_4]
.text$mn:00009729                 mov     esp, ebp
.text$mn:0000972B                 pop     ebp
.text$mn:0000972C                 retn    0Ch
.text$mn:0000972C ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000972C
.text$mn:0000972C ; ---------------------------------------------------------------------------
.text$mn:0000972F                 align 10h
.text$mn:0000972F _text$mn        ends
.text$mn:0000972F
.text$mn:00009730 ; ===========================================================================
.text$mn:00009730
.text$mn:00009730 ; Segment type: Pure code
.text$mn:00009730 ; Segment permissions: Read/Execute
.text$mn:00009730 _text$mn        segment para public 'CODE' use32
.text$mn:00009730                 assume cs:_text$mn
.text$mn:00009730                 ;org 9730h
.text$mn:00009730 ; COMDAT (pick any)
.text$mn:00009730                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009730
.text$mn:00009730 ; =============== S U B R O U T I N E =======================================
.text$mn:00009730
.text$mn:00009730 ; Attributes: bp-based frame
.text$mn:00009730
.text$mn:00009730 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t *Str)
.text$mn:00009730                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:00009730 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:00009730                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)+Ep
.text$mn:00009730
.text$mn:00009730 var_4           = dword ptr -4
.text$mn:00009730 Str             = dword ptr  8
.text$mn:00009730
.text$mn:00009730                 push    ebp
.text$mn:00009731                 mov     ebp, esp
.text$mn:00009733                 push    ecx
.text$mn:00009734                 mov     [ebp+var_4], ecx
.text$mn:00009737                 push    43Eh            ; unsigned int
.text$mn:0000973C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00009741                 mov     eax, [ebp+Str]
.text$mn:00009744                 push    eax             ; int
.text$mn:00009745                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000974A                 add     esp, 0Ch
.text$mn:0000974D                 mov     ecx, [ebp+Str]
.text$mn:00009750                 push    ecx             ; Str
.text$mn:00009751                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:00009756                 add     esp, 4
.text$mn:00009759                 push    eax             ; int
.text$mn:0000975A                 mov     edx, [ebp+Str]
.text$mn:0000975D                 push    edx             ; Src
.text$mn:0000975E                 mov     ecx, [ebp+var_4]
.text$mn:00009761                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)
.text$mn:00009766                 mov     esp, ebp
.text$mn:00009768                 pop     ebp
.text$mn:00009769                 retn    4
.text$mn:00009769 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:00009769
.text$mn:00009769 _text$mn        ends
.text$mn:00009769
.text$mn:0000976C ; ===========================================================================
.text$mn:0000976C
.text$mn:0000976C ; Segment type: Pure code
.text$mn:0000976C ; Segment permissions: Read/Execute
.text$mn:0000976C _text$mn        segment para public 'CODE' use32
.text$mn:0000976C                 assume cs:_text$mn
.text$mn:0000976C                 ;org 976Ch
.text$mn:0000976C ; COMDAT (pick any)
.text$mn:0000976C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000976C
.text$mn:0000976C ; =============== S U B R O U T I N E =======================================
.text$mn:0000976C
.text$mn:0000976C ; Attributes: bp-based frame
.text$mn:0000976C
.text$mn:0000976C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(void *Src, int)
.text$mn:0000976C                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:0000976C ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:0000976C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+31p
.text$mn:0000976C
.text$mn:0000976C var_8           = dword ptr -8
.text$mn:0000976C var_4           = dword ptr -4
.text$mn:0000976C Src             = dword ptr  8
.text$mn:0000976C arg_4           = dword ptr  0Ch
.text$mn:0000976C
.text$mn:0000976C                 push    ebp
.text$mn:0000976D                 mov     ebp, esp
.text$mn:0000976F                 sub     esp, 8
.text$mn:00009772                 mov     [ebp+var_4], ecx
.text$mn:00009775                 cmp     [ebp+arg_4], 0
.text$mn:00009779                 jz      short loc_9791
.text$mn:0000977B                 push    42Ah            ; unsigned int
.text$mn:00009780                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00009785                 mov     eax, [ebp+Src]
.text$mn:00009788                 push    eax             ; int
.text$mn:00009789                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000978E                 add     esp, 0Ch
.text$mn:00009791
.text$mn:00009791 loc_9791:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+Dj
.text$mn:00009791                 mov     ecx, [ebp+Src]
.text$mn:00009794                 push    ecx
.text$mn:00009795                 mov     ecx, [ebp+var_4]
.text$mn:00009798                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:0000979D                 movzx   edx, al
.text$mn:000097A0                 test    edx, edx
.text$mn:000097A2                 jz      short loc_97C6
.text$mn:000097A4                 mov     eax, [ebp+arg_4]
.text$mn:000097A7                 push    eax
.text$mn:000097A8                 mov     ecx, [ebp+var_4]
.text$mn:000097AB                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000097B0                 mov     ecx, [ebp+Src]
.text$mn:000097B3                 sub     ecx, eax
.text$mn:000097B5                 sar     ecx, 1
.text$mn:000097B7                 push    ecx
.text$mn:000097B8                 mov     edx, [ebp+var_4]
.text$mn:000097BB                 push    edx
.text$mn:000097BC                 mov     ecx, [ebp+var_4]
.text$mn:000097BF                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:000097C4                 jmp     short loc_9837
.text$mn:000097C6 ; ---------------------------------------------------------------------------
.text$mn:000097C6
.text$mn:000097C6 loc_97C6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+36j
.text$mn:000097C6                 mov     eax, [ebp+var_4]
.text$mn:000097C9                 mov     ecx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:000097CF                 sub     ecx, [eax+14h]
.text$mn:000097D2                 cmp     ecx, [ebp+arg_4]
.text$mn:000097D5                 ja      short loc_97DF
.text$mn:000097D7                 mov     ecx, [ebp+var_4]
.text$mn:000097DA                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:000097DF
.text$mn:000097DF loc_97DF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+69j
.text$mn:000097DF                 cmp     [ebp+arg_4], 0
.text$mn:000097E3                 jbe     short loc_9834
.text$mn:000097E5                 mov     edx, [ebp+var_4]
.text$mn:000097E8                 mov     eax, [edx+14h]
.text$mn:000097EB                 add     eax, [ebp+arg_4]
.text$mn:000097EE                 mov     [ebp+var_8], eax
.text$mn:000097F1                 push    0
.text$mn:000097F3                 mov     ecx, [ebp+var_8]
.text$mn:000097F6                 push    ecx
.text$mn:000097F7                 mov     ecx, [ebp+var_4]
.text$mn:000097FA                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:000097FF                 movzx   edx, al
.text$mn:00009802                 test    edx, edx
.text$mn:00009804                 jz      short loc_9834
.text$mn:00009806                 mov     eax, [ebp+arg_4]
.text$mn:00009809                 push    eax             ; int
.text$mn:0000980A                 mov     ecx, [ebp+Src]
.text$mn:0000980D                 push    ecx             ; Src
.text$mn:0000980E                 mov     ecx, [ebp+var_4]
.text$mn:00009811                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009816                 mov     edx, [ebp+var_4]
.text$mn:00009819                 mov     ecx, [edx+14h]
.text$mn:0000981C                 lea     edx, [eax+ecx*2]
.text$mn:0000981F                 push    edx             ; Dst
.text$mn:00009820                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00009825                 add     esp, 0Ch
.text$mn:00009828                 mov     eax, [ebp+var_8]
.text$mn:0000982B                 push    eax
.text$mn:0000982C                 mov     ecx, [ebp+var_4]
.text$mn:0000982F                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00009834
.text$mn:00009834 loc_9834:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+77j
.text$mn:00009834                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+98j
.text$mn:00009834                 mov     eax, [ebp+var_4]
.text$mn:00009837
.text$mn:00009837 loc_9837:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+58j
.text$mn:00009837                 mov     esp, ebp
.text$mn:00009839                 pop     ebp
.text$mn:0000983A                 retn    8
.text$mn:0000983A ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:0000983A
.text$mn:0000983A ; ---------------------------------------------------------------------------
.text$mn:0000983D                 align 10h
.text$mn:0000983D _text$mn        ends
.text$mn:0000983D
.text$mn:00009840 ; ===========================================================================
.text$mn:00009840
.text$mn:00009840 ; Segment type: Pure code
.text$mn:00009840 ; Segment permissions: Read/Execute
.text$mn:00009840 _text$mn        segment para public 'CODE' use32
.text$mn:00009840                 assume cs:_text$mn
.text$mn:00009840                 ;org 9840h
.text$mn:00009840 ; COMDAT (pick any)
.text$mn:00009840                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009840
.text$mn:00009840 ; =============== S U B R O U T I N E =======================================
.text$mn:00009840
.text$mn:00009840 ; Attributes: bp-based frame
.text$mn:00009840
.text$mn:00009840 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00009840                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00009840 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00009840                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00009840
.text$mn:00009840 Size            = dword ptr -8
.text$mn:00009840 var_4           = dword ptr -4
.text$mn:00009840 arg_0           = dword ptr  8
.text$mn:00009840 arg_4           = dword ptr  0Ch
.text$mn:00009840 arg_8           = dword ptr  10h
.text$mn:00009840
.text$mn:00009840                 push    ebp
.text$mn:00009841                 mov     ebp, esp
.text$mn:00009843                 sub     esp, 8
.text$mn:00009846                 mov     [ebp+var_4], ecx
.text$mn:00009849                 mov     ecx, [ebp+arg_0]
.text$mn:0000984C                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00009851                 cmp     eax, [ebp+arg_4]
.text$mn:00009854                 jnb     short loc_985E
.text$mn:00009856                 mov     ecx, [ebp+var_4]
.text$mn:00009859                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000985E
.text$mn:0000985E loc_985E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000985E                 mov     ecx, [ebp+arg_0]
.text$mn:00009861                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00009866                 sub     eax, [ebp+arg_4]
.text$mn:00009869                 mov     [ebp+Size], eax
.text$mn:0000986C                 mov     eax, [ebp+arg_8]
.text$mn:0000986F                 cmp     eax, [ebp+Size]
.text$mn:00009872                 jnb     short loc_987A
.text$mn:00009874                 mov     ecx, [ebp+arg_8]
.text$mn:00009877                 mov     [ebp+Size], ecx
.text$mn:0000987A
.text$mn:0000987A loc_987A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000987A                 mov     edx, [ebp+var_4]
.text$mn:0000987D                 cmp     edx, [ebp+arg_0]
.text$mn:00009880                 jnz     short loc_98A1
.text$mn:00009882                 mov     eax, [ebp+arg_4]
.text$mn:00009885                 add     eax, [ebp+Size]
.text$mn:00009888                 push    eax
.text$mn:00009889                 mov     ecx, [ebp+var_4]
.text$mn:0000988C                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00009891                 mov     ecx, [ebp+arg_4]
.text$mn:00009894                 push    ecx
.text$mn:00009895                 push    0
.text$mn:00009897                 mov     ecx, [ebp+var_4]
.text$mn:0000989A                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:0000989F                 jmp     short loc_98E3
.text$mn:000098A1 ; ---------------------------------------------------------------------------
.text$mn:000098A1
.text$mn:000098A1 loc_98A1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000098A1                 push    0
.text$mn:000098A3                 mov     edx, [ebp+Size]
.text$mn:000098A6                 push    edx
.text$mn:000098A7                 mov     ecx, [ebp+var_4]
.text$mn:000098AA                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000098AF                 movzx   eax, al
.text$mn:000098B2                 test    eax, eax
.text$mn:000098B4                 jz      short loc_98E3
.text$mn:000098B6                 mov     ecx, [ebp+Size]
.text$mn:000098B9                 push    ecx             ; Size
.text$mn:000098BA                 mov     ecx, [ebp+arg_0]
.text$mn:000098BD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000098C2                 add     eax, [ebp+arg_4]
.text$mn:000098C5                 push    eax             ; Src
.text$mn:000098C6                 mov     ecx, [ebp+var_4]
.text$mn:000098C9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000098CE                 push    eax             ; Dst
.text$mn:000098CF                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000098D4                 add     esp, 0Ch
.text$mn:000098D7                 mov     edx, [ebp+Size]
.text$mn:000098DA                 push    edx
.text$mn:000098DB                 mov     ecx, [ebp+var_4]
.text$mn:000098DE                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000098E3
.text$mn:000098E3 loc_98E3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000098E3                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000098E3                 mov     eax, [ebp+var_4]
.text$mn:000098E6                 mov     esp, ebp
.text$mn:000098E8                 pop     ebp
.text$mn:000098E9                 retn    0Ch
.text$mn:000098E9 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000098E9
.text$mn:000098E9 _text$mn        ends
.text$mn:000098E9
.text$mn:000098EC ; ===========================================================================
.text$mn:000098EC
.text$mn:000098EC ; Segment type: Pure code
.text$mn:000098EC ; Segment permissions: Read/Execute
.text$mn:000098EC _text$mn        segment para public 'CODE' use32
.text$mn:000098EC                 assume cs:_text$mn
.text$mn:000098EC                 ;org 98ECh
.text$mn:000098EC ; COMDAT (pick any)
.text$mn:000098EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000098EC
.text$mn:000098EC ; =============== S U B R O U T I N E =======================================
.text$mn:000098EC
.text$mn:000098EC ; Attributes: bp-based frame
.text$mn:000098EC
.text$mn:000098EC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:000098EC                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:000098EC ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:000098EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:000098EC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)+Ep
.text$mn:000098EC
.text$mn:000098EC var_4           = dword ptr -4
.text$mn:000098EC Str             = dword ptr  8
.text$mn:000098EC
.text$mn:000098EC                 push    ebp
.text$mn:000098ED                 mov     ebp, esp
.text$mn:000098EF                 push    ecx
.text$mn:000098F0                 mov     [ebp+var_4], ecx
.text$mn:000098F3                 push    490h            ; unsigned int
.text$mn:000098F8                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000098FD                 mov     eax, [ebp+Str]
.text$mn:00009900                 push    eax             ; int
.text$mn:00009901                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00009906                 add     esp, 0Ch
.text$mn:00009909                 mov     ecx, [ebp+Str]
.text$mn:0000990C                 push    ecx             ; Str
.text$mn:0000990D                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00009912                 add     esp, 4
.text$mn:00009915                 push    eax             ; Size
.text$mn:00009916                 mov     edx, [ebp+Str]
.text$mn:00009919                 push    edx             ; Src
.text$mn:0000991A                 mov     ecx, [ebp+var_4]
.text$mn:0000991D                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00009922                 mov     esp, ebp
.text$mn:00009924                 pop     ebp
.text$mn:00009925                 retn    4
.text$mn:00009925 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00009925
.text$mn:00009925 _text$mn        ends
.text$mn:00009925
.text$mn:00009928 ; ===========================================================================
.text$mn:00009928
.text$mn:00009928 ; Segment type: Pure code
.text$mn:00009928 ; Segment permissions: Read/Execute
.text$mn:00009928 _text$mn        segment para public 'CODE' use32
.text$mn:00009928                 assume cs:_text$mn
.text$mn:00009928                 ;org 9928h
.text$mn:00009928 ; COMDAT (pick any)
.text$mn:00009928                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009928
.text$mn:00009928 ; =============== S U B R O U T I N E =======================================
.text$mn:00009928
.text$mn:00009928 ; Attributes: bp-based frame
.text$mn:00009928
.text$mn:00009928 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00009928                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00009928 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00009928                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00009928
.text$mn:00009928 var_4           = dword ptr -4
.text$mn:00009928 Src             = dword ptr  8
.text$mn:00009928 Size            = dword ptr  0Ch
.text$mn:00009928
.text$mn:00009928                 push    ebp
.text$mn:00009929                 mov     ebp, esp
.text$mn:0000992B                 push    ecx
.text$mn:0000992C                 mov     [ebp+var_4], ecx
.text$mn:0000992F                 cmp     [ebp+Size], 0
.text$mn:00009933                 jz      short loc_994B
.text$mn:00009935                 push    47Fh            ; unsigned int
.text$mn:0000993A                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000993F                 mov     eax, [ebp+Src]
.text$mn:00009942                 push    eax             ; int
.text$mn:00009943                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00009948                 add     esp, 0Ch
.text$mn:0000994B
.text$mn:0000994B loc_994B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000994B                 mov     ecx, [ebp+Src]
.text$mn:0000994E                 push    ecx
.text$mn:0000994F                 mov     ecx, [ebp+var_4]
.text$mn:00009952                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00009957                 movzx   edx, al
.text$mn:0000995A                 test    edx, edx
.text$mn:0000995C                 jz      short loc_997E
.text$mn:0000995E                 mov     eax, [ebp+Size]
.text$mn:00009961                 push    eax
.text$mn:00009962                 mov     ecx, [ebp+var_4]
.text$mn:00009965                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000996A                 mov     ecx, [ebp+Src]
.text$mn:0000996D                 sub     ecx, eax
.text$mn:0000996F                 push    ecx
.text$mn:00009970                 mov     edx, [ebp+var_4]
.text$mn:00009973                 push    edx
.text$mn:00009974                 mov     ecx, [ebp+var_4]
.text$mn:00009977                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:0000997C                 jmp     short loc_99BB
.text$mn:0000997E ; ---------------------------------------------------------------------------
.text$mn:0000997E
.text$mn:0000997E loc_997E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:0000997E                 push    0
.text$mn:00009980                 mov     eax, [ebp+Size]
.text$mn:00009983                 push    eax
.text$mn:00009984                 mov     ecx, [ebp+var_4]
.text$mn:00009987                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000998C                 movzx   ecx, al
.text$mn:0000998F                 test    ecx, ecx
.text$mn:00009991                 jz      short loc_99B8
.text$mn:00009993                 mov     edx, [ebp+Size]
.text$mn:00009996                 push    edx             ; Size
.text$mn:00009997                 mov     eax, [ebp+Src]
.text$mn:0000999A                 push    eax             ; Src
.text$mn:0000999B                 mov     ecx, [ebp+var_4]
.text$mn:0000999E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000099A3                 push    eax             ; Dst
.text$mn:000099A4                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000099A9                 add     esp, 0Ch
.text$mn:000099AC                 mov     ecx, [ebp+Size]
.text$mn:000099AF                 push    ecx
.text$mn:000099B0                 mov     ecx, [ebp+var_4]
.text$mn:000099B3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000099B8
.text$mn:000099B8 loc_99B8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:000099B8                 mov     eax, [ebp+var_4]
.text$mn:000099BB
.text$mn:000099BB loc_99BB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:000099BB                 mov     esp, ebp
.text$mn:000099BD                 pop     ebp
.text$mn:000099BE                 retn    8
.text$mn:000099BE ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:000099BE
.text$mn:000099BE ; ---------------------------------------------------------------------------
.text$mn:000099C1                 align 4
.text$mn:000099C1 _text$mn        ends
.text$mn:000099C1
.text$mn:000099C4 ; ===========================================================================
.text$mn:000099C4
.text$mn:000099C4 ; Segment type: Pure code
.text$mn:000099C4 ; Segment permissions: Read/Execute
.text$mn:000099C4 _text$mn        segment para public 'CODE' use32
.text$mn:000099C4                 assume cs:_text$mn
.text$mn:000099C4                 ;org 99C4h
.text$mn:000099C4 ; COMDAT (pick any)
.text$mn:000099C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000099C4
.text$mn:000099C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000099C4
.text$mn:000099C4 ; Attributes: bp-based frame
.text$mn:000099C4
.text$mn:000099C4 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:000099C4                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:000099C4 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:000099C4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Bp
.text$mn:000099C4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+51p
.text$mn:000099C4
.text$mn:000099C4 var_8           = dword ptr -8
.text$mn:000099C4 var_4           = dword ptr -4
.text$mn:000099C4 arg_0           = dword ptr  8
.text$mn:000099C4 arg_4           = dword ptr  0Ch
.text$mn:000099C4 arg_8           = dword ptr  10h
.text$mn:000099C4
.text$mn:000099C4                 push    ebp
.text$mn:000099C5                 mov     ebp, esp
.text$mn:000099C7                 sub     esp, 8
.text$mn:000099CA                 mov     [ebp+var_4], ecx
.text$mn:000099CD                 mov     ecx, [ebp+arg_0]
.text$mn:000099D0                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:000099D5                 cmp     eax, [ebp+arg_4]
.text$mn:000099D8                 jnb     short loc_99E2
.text$mn:000099DA                 mov     ecx, [ebp+var_4]
.text$mn:000099DD                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:000099E2
.text$mn:000099E2 loc_99E2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:000099E2                 mov     ecx, [ebp+arg_0]
.text$mn:000099E5                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:000099EA                 sub     eax, [ebp+arg_4]
.text$mn:000099ED                 mov     [ebp+var_8], eax
.text$mn:000099F0                 mov     eax, [ebp+arg_8]
.text$mn:000099F3                 cmp     eax, [ebp+var_8]
.text$mn:000099F6                 jnb     short loc_99FE
.text$mn:000099F8                 mov     ecx, [ebp+arg_8]
.text$mn:000099FB                 mov     [ebp+var_8], ecx
.text$mn:000099FE
.text$mn:000099FE loc_99FE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:000099FE                 mov     edx, [ebp+var_4]
.text$mn:00009A01                 cmp     edx, [ebp+arg_0]
.text$mn:00009A04                 jnz     short loc_9A25
.text$mn:00009A06                 mov     eax, [ebp+arg_4]
.text$mn:00009A09                 add     eax, [ebp+var_8]
.text$mn:00009A0C                 push    eax
.text$mn:00009A0D                 mov     ecx, [ebp+var_4]
.text$mn:00009A10                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00009A15                 mov     ecx, [ebp+arg_4]
.text$mn:00009A18                 push    ecx
.text$mn:00009A19                 push    0
.text$mn:00009A1B                 mov     ecx, [ebp+var_4]
.text$mn:00009A1E                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:00009A23                 jmp     short loc_9A6A
.text$mn:00009A25 ; ---------------------------------------------------------------------------
.text$mn:00009A25
.text$mn:00009A25 loc_9A25:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:00009A25                 push    0
.text$mn:00009A27                 mov     edx, [ebp+var_8]
.text$mn:00009A2A                 push    edx
.text$mn:00009A2B                 mov     ecx, [ebp+var_4]
.text$mn:00009A2E                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00009A33                 movzx   eax, al
.text$mn:00009A36                 test    eax, eax
.text$mn:00009A38                 jz      short loc_9A6A
.text$mn:00009A3A                 mov     ecx, [ebp+var_8]
.text$mn:00009A3D                 push    ecx             ; int
.text$mn:00009A3E                 mov     ecx, [ebp+arg_0]
.text$mn:00009A41                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009A46                 mov     edx, [ebp+arg_4]
.text$mn:00009A49                 lea     eax, [eax+edx*2]
.text$mn:00009A4C                 push    eax             ; Src
.text$mn:00009A4D                 mov     ecx, [ebp+var_4]
.text$mn:00009A50                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009A55                 push    eax             ; Dst
.text$mn:00009A56                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00009A5B                 add     esp, 0Ch
.text$mn:00009A5E                 mov     ecx, [ebp+var_8]
.text$mn:00009A61                 push    ecx
.text$mn:00009A62                 mov     ecx, [ebp+var_4]
.text$mn:00009A65                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00009A6A
.text$mn:00009A6A loc_9A6A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:00009A6A                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:00009A6A                 mov     eax, [ebp+var_4]
.text$mn:00009A6D                 mov     esp, ebp
.text$mn:00009A6F                 pop     ebp
.text$mn:00009A70                 retn    0Ch
.text$mn:00009A70 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00009A70
.text$mn:00009A70 ; ---------------------------------------------------------------------------
.text$mn:00009A73                 align 4
.text$mn:00009A73 _text$mn        ends
.text$mn:00009A73
.text$mn:00009A74 ; ===========================================================================
.text$mn:00009A74
.text$mn:00009A74 ; Segment type: Pure code
.text$mn:00009A74 ; Segment permissions: Read/Execute
.text$mn:00009A74 _text$mn        segment para public 'CODE' use32
.text$mn:00009A74                 assume cs:_text$mn
.text$mn:00009A74                 ;org 9A74h
.text$mn:00009A74 ; COMDAT (pick any)
.text$mn:00009A74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009A74
.text$mn:00009A74 ; =============== S U B R O U T I N E =======================================
.text$mn:00009A74
.text$mn:00009A74 ; Attributes: bp-based frame
.text$mn:00009A74
.text$mn:00009A74 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:00009A74                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:00009A74 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:00009A74                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:00009A74                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)+Ep
.text$mn:00009A74
.text$mn:00009A74 var_4           = dword ptr -4
.text$mn:00009A74 Str             = dword ptr  8
.text$mn:00009A74
.text$mn:00009A74                 push    ebp
.text$mn:00009A75                 mov     ebp, esp
.text$mn:00009A77                 push    ecx
.text$mn:00009A78                 mov     [ebp+var_4], ecx
.text$mn:00009A7B                 push    490h            ; unsigned int
.text$mn:00009A80                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00009A85                 mov     eax, [ebp+Str]
.text$mn:00009A88                 push    eax             ; int
.text$mn:00009A89                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00009A8E                 add     esp, 0Ch
.text$mn:00009A91                 mov     ecx, [ebp+Str]
.text$mn:00009A94                 push    ecx             ; Str
.text$mn:00009A95                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:00009A9A                 add     esp, 4
.text$mn:00009A9D                 push    eax             ; int
.text$mn:00009A9E                 mov     edx, [ebp+Str]
.text$mn:00009AA1                 push    edx             ; Src
.text$mn:00009AA2                 mov     ecx, [ebp+var_4]
.text$mn:00009AA5                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:00009AAA                 mov     esp, ebp
.text$mn:00009AAC                 pop     ebp
.text$mn:00009AAD                 retn    4
.text$mn:00009AAD ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:00009AAD
.text$mn:00009AAD _text$mn        ends
.text$mn:00009AAD
.text$mn:00009AB0 ; ===========================================================================
.text$mn:00009AB0
.text$mn:00009AB0 ; Segment type: Pure code
.text$mn:00009AB0 ; Segment permissions: Read/Execute
.text$mn:00009AB0 _text$mn        segment para public 'CODE' use32
.text$mn:00009AB0                 assume cs:_text$mn
.text$mn:00009AB0                 ;org 9AB0h
.text$mn:00009AB0 ; COMDAT (pick any)
.text$mn:00009AB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009AB0
.text$mn:00009AB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00009AB0
.text$mn:00009AB0 ; Attributes: bp-based frame
.text$mn:00009AB0
.text$mn:00009AB0 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:00009AB0                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:00009AB0 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:00009AB0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:00009AB0
.text$mn:00009AB0 var_4           = dword ptr -4
.text$mn:00009AB0 Src             = dword ptr  8
.text$mn:00009AB0 arg_4           = dword ptr  0Ch
.text$mn:00009AB0
.text$mn:00009AB0                 push    ebp
.text$mn:00009AB1                 mov     ebp, esp
.text$mn:00009AB3                 push    ecx
.text$mn:00009AB4                 mov     [ebp+var_4], ecx
.text$mn:00009AB7                 cmp     [ebp+arg_4], 0
.text$mn:00009ABB                 jz      short loc_9AD3
.text$mn:00009ABD                 push    47Fh            ; unsigned int
.text$mn:00009AC2                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00009AC7                 mov     eax, [ebp+Src]
.text$mn:00009ACA                 push    eax             ; int
.text$mn:00009ACB                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00009AD0                 add     esp, 0Ch
.text$mn:00009AD3
.text$mn:00009AD3 loc_9AD3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:00009AD3                 mov     ecx, [ebp+Src]
.text$mn:00009AD6                 push    ecx
.text$mn:00009AD7                 mov     ecx, [ebp+var_4]
.text$mn:00009ADA                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00009ADF                 movzx   edx, al
.text$mn:00009AE2                 test    edx, edx
.text$mn:00009AE4                 jz      short loc_9B08
.text$mn:00009AE6                 mov     eax, [ebp+arg_4]
.text$mn:00009AE9                 push    eax
.text$mn:00009AEA                 mov     ecx, [ebp+var_4]
.text$mn:00009AED                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009AF2                 mov     ecx, [ebp+Src]
.text$mn:00009AF5                 sub     ecx, eax
.text$mn:00009AF7                 sar     ecx, 1
.text$mn:00009AF9                 push    ecx
.text$mn:00009AFA                 mov     edx, [ebp+var_4]
.text$mn:00009AFD                 push    edx
.text$mn:00009AFE                 mov     ecx, [ebp+var_4]
.text$mn:00009B01                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00009B06                 jmp     short loc_9B45
.text$mn:00009B08 ; ---------------------------------------------------------------------------
.text$mn:00009B08
.text$mn:00009B08 loc_9B08:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:00009B08                 push    0
.text$mn:00009B0A                 mov     eax, [ebp+arg_4]
.text$mn:00009B0D                 push    eax
.text$mn:00009B0E                 mov     ecx, [ebp+var_4]
.text$mn:00009B11                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00009B16                 movzx   ecx, al
.text$mn:00009B19                 test    ecx, ecx
.text$mn:00009B1B                 jz      short loc_9B42
.text$mn:00009B1D                 mov     edx, [ebp+arg_4]
.text$mn:00009B20                 push    edx             ; int
.text$mn:00009B21                 mov     eax, [ebp+Src]
.text$mn:00009B24                 push    eax             ; Src
.text$mn:00009B25                 mov     ecx, [ebp+var_4]
.text$mn:00009B28                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009B2D                 push    eax             ; Dst
.text$mn:00009B2E                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00009B33                 add     esp, 0Ch
.text$mn:00009B36                 mov     ecx, [ebp+arg_4]
.text$mn:00009B39                 push    ecx
.text$mn:00009B3A                 mov     ecx, [ebp+var_4]
.text$mn:00009B3D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00009B42
.text$mn:00009B42 loc_9B42:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:00009B42                 mov     eax, [ebp+var_4]
.text$mn:00009B45
.text$mn:00009B45 loc_9B45:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:00009B45                 mov     esp, ebp
.text$mn:00009B47                 pop     ebp
.text$mn:00009B48                 retn    8
.text$mn:00009B48 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:00009B48
.text$mn:00009B48 ; ---------------------------------------------------------------------------
.text$mn:00009B4B                 align 4
.text$mn:00009B4B _text$mn        ends
.text$mn:00009B4B
.text$mn:00009B4C ; ===========================================================================
.text$mn:00009B4C
.text$mn:00009B4C ; Segment type: Pure code
.text$mn:00009B4C ; Segment permissions: Read/Execute
.text$mn:00009B4C _text$mn        segment para public 'CODE' use32
.text$mn:00009B4C                 assume cs:_text$mn
.text$mn:00009B4C                 ;org 9B4Ch
.text$mn:00009B4C ; COMDAT (pick any)
.text$mn:00009B4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009B4C
.text$mn:00009B4C ; =============== S U B R O U T I N E =======================================
.text$mn:00009B4C
.text$mn:00009B4C ; Attributes: bp-based frame
.text$mn:00009B4C
.text$mn:00009B4C ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00009B4C                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00009B4C ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00009B4C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00009B4C
.text$mn:00009B4C arg_0           = dword ptr  8
.text$mn:00009B4C arg_4           = dword ptr  0Ch
.text$mn:00009B4C
.text$mn:00009B4C                 push    ebp
.text$mn:00009B4D                 mov     ebp, esp
.text$mn:00009B4F                 mov     eax, [ebp+arg_0]
.text$mn:00009B52                 mov     ecx, [ebp+arg_4]
.text$mn:00009B55                 mov     dl, [ecx]
.text$mn:00009B57                 mov     [eax], dl
.text$mn:00009B59                 pop     ebp
.text$mn:00009B5A                 retn
.text$mn:00009B5A ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00009B5A
.text$mn:00009B5A ; ---------------------------------------------------------------------------
.text$mn:00009B5B                 align 4
.text$mn:00009B5B _text$mn        ends
.text$mn:00009B5B
.text$mn:00009B5C ; ===========================================================================
.text$mn:00009B5C
.text$mn:00009B5C ; Segment type: Pure code
.text$mn:00009B5C ; Segment permissions: Read/Execute
.text$mn:00009B5C _text$mn        segment para public 'CODE' use32
.text$mn:00009B5C                 assume cs:_text$mn
.text$mn:00009B5C                 ;org 9B5Ch
.text$mn:00009B5C ; COMDAT (pick any)
.text$mn:00009B5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009B5C
.text$mn:00009B5C ; =============== S U B R O U T I N E =======================================
.text$mn:00009B5C
.text$mn:00009B5C ; Attributes: bp-based frame
.text$mn:00009B5C
.text$mn:00009B5C ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:00009B5C                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:00009B5C ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:00009B5C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:00009B5C
.text$mn:00009B5C arg_0           = dword ptr  8
.text$mn:00009B5C arg_4           = dword ptr  0Ch
.text$mn:00009B5C
.text$mn:00009B5C                 push    ebp
.text$mn:00009B5D                 mov     ebp, esp
.text$mn:00009B5F                 mov     eax, [ebp+arg_0]
.text$mn:00009B62                 mov     ecx, [ebp+arg_4]
.text$mn:00009B65                 mov     dx, [ecx]
.text$mn:00009B68                 mov     [eax], dx
.text$mn:00009B6B                 pop     ebp
.text$mn:00009B6C                 retn
.text$mn:00009B6C ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:00009B6C
.text$mn:00009B6C ; ---------------------------------------------------------------------------
.text$mn:00009B6D                 align 10h
.text$mn:00009B6D _text$mn        ends
.text$mn:00009B6D
.text$mn:00009B70 ; ===========================================================================
.text$mn:00009B70
.text$mn:00009B70 ; Segment type: Pure code
.text$mn:00009B70 ; Segment permissions: Read/Execute
.text$mn:00009B70 _text$mn        segment para public 'CODE' use32
.text$mn:00009B70                 assume cs:_text$mn
.text$mn:00009B70                 ;org 9B70h
.text$mn:00009B70 ; COMDAT (pick any)
.text$mn:00009B70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009B70
.text$mn:00009B70 ; =============== S U B R O U T I N E =======================================
.text$mn:00009B70
.text$mn:00009B70 ; Attributes: bp-based frame
.text$mn:00009B70
.text$mn:00009B70 ; public: char & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::at(unsigned int)
.text$mn:00009B70                 public ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
.text$mn:00009B70 ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z proc near
.text$mn:00009B70                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+23D8p
.text$mn:00009B70                                         ; Notepad_plus::notify(SCNotification *)+2416p ...
.text$mn:00009B70
.text$mn:00009B70 var_4           = dword ptr -4
.text$mn:00009B70 arg_0           = dword ptr  8
.text$mn:00009B70
.text$mn:00009B70                 push    ebp
.text$mn:00009B71                 mov     ebp, esp
.text$mn:00009B73                 push    ecx
.text$mn:00009B74                 mov     [ebp+var_4], ecx
.text$mn:00009B77                 mov     eax, [ebp+var_4]
.text$mn:00009B7A                 mov     ecx, [eax+14h]
.text$mn:00009B7D                 cmp     ecx, [ebp+arg_0]
.text$mn:00009B80                 ja      short loc_9B8A
.text$mn:00009B82                 mov     ecx, [ebp+var_4]
.text$mn:00009B85                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00009B8A
.text$mn:00009B8A loc_9B8A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::at(uint)+10j
.text$mn:00009B8A                 mov     ecx, [ebp+var_4]
.text$mn:00009B8D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00009B92                 add     eax, [ebp+arg_0]
.text$mn:00009B95                 mov     esp, ebp
.text$mn:00009B97                 pop     ebp
.text$mn:00009B98                 retn    4
.text$mn:00009B98 ?at@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z endp
.text$mn:00009B98
.text$mn:00009B98 ; ---------------------------------------------------------------------------
.text$mn:00009B9B                 align 4
.text$mn:00009B9B _text$mn        ends
.text$mn:00009B9B
.text$mn:00009B9C ; ===========================================================================
.text$mn:00009B9C
.text$mn:00009B9C ; Segment type: Pure code
.text$mn:00009B9C ; Segment permissions: Read/Execute
.text$mn:00009B9C _text$mn        segment para public 'CODE' use32
.text$mn:00009B9C                 assume cs:_text$mn
.text$mn:00009B9C                 ;org 9B9Ch
.text$mn:00009B9C ; COMDAT (pick any)
.text$mn:00009B9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009B9C
.text$mn:00009B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00009B9C
.text$mn:00009B9C ; Attributes: bp-based frame
.text$mn:00009B9C
.text$mn:00009B9C ; public: unsigned int & __thiscall std::deque<unsigned int, class std::allocator<unsigned int>>::back(void)
.text$mn:00009B9C                 public ?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ
.text$mn:00009B9C ?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ proc near
.text$mn:00009B9C                                         ; CODE XREF: std::stack<uint,std::deque<uint,std::allocator<uint>>>::top(void)+Ap
.text$mn:00009B9C
.text$mn:00009B9C var_3C          = byte ptr -3Ch
.text$mn:00009B9C var_30          = byte ptr -30h
.text$mn:00009B9C var_24          = dword ptr -24h
.text$mn:00009B9C var_20          = dword ptr -20h
.text$mn:00009B9C var_1C          = dword ptr -1Ch
.text$mn:00009B9C var_18          = dword ptr -18h
.text$mn:00009B9C var_14          = dword ptr -14h
.text$mn:00009B9C var_10          = dword ptr -10h
.text$mn:00009B9C var_C           = dword ptr -0Ch
.text$mn:00009B9C var_4           = dword ptr -4
.text$mn:00009B9C
.text$mn:00009B9C                 push    ebp
.text$mn:00009B9D                 mov     ebp, esp
.text$mn:00009B9F                 push    0FFFFFFFFh
.text$mn:00009BA1                 push    offset __ehhandler$?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ
.text$mn:00009BA6                 mov     eax, large fs:0
.text$mn:00009BAC                 push    eax
.text$mn:00009BAD                 sub     esp, 30h
.text$mn:00009BB0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00009BB5                 xor     eax, ebp
.text$mn:00009BB7                 push    eax
.text$mn:00009BB8                 lea     eax, [ebp+var_C]
.text$mn:00009BBB                 mov     large fs:0, eax
.text$mn:00009BC1                 mov     [ebp+var_10], ecx
.text$mn:00009BC4                 push    1
.text$mn:00009BC6                 lea     eax, [ebp+var_30]
.text$mn:00009BC9                 push    eax
.text$mn:00009BCA                 lea     ecx, [ebp+var_3C]
.text$mn:00009BCD                 push    ecx
.text$mn:00009BCE                 mov     ecx, [ebp+var_10]
.text$mn:00009BD1                 call    ?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ ; std::deque<uint,std::allocator<uint>>::end(void)
.text$mn:00009BD6                 mov     [ebp+var_14], eax
.text$mn:00009BD9                 mov     edx, [ebp+var_14]
.text$mn:00009BDC                 mov     [ebp+var_18], edx
.text$mn:00009BDF                 mov     [ebp+var_4], 0
.text$mn:00009BE6                 mov     ecx, [ebp+var_18]
.text$mn:00009BE9                 call    ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator-(int)
.text$mn:00009BEE                 mov     [ebp+var_1C], eax
.text$mn:00009BF1                 mov     eax, [ebp+var_1C]
.text$mn:00009BF4                 mov     [ebp+var_20], eax
.text$mn:00009BF7                 mov     byte ptr [ebp+var_4], 1
.text$mn:00009BFB                 mov     ecx, [ebp+var_20]
.text$mn:00009BFE                 call    ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBEAAIXZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)
.text$mn:00009C03                 mov     [ebp+var_24], eax
.text$mn:00009C06                 mov     byte ptr [ebp+var_4], 0
.text$mn:00009C0A                 lea     ecx, [ebp+var_30]
.text$mn:00009C0D                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(void)
.text$mn:00009C12                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00009C19                 lea     ecx, [ebp+var_3C]
.text$mn:00009C1C                 call    ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(void)
.text$mn:00009C21                 mov     eax, [ebp+var_24]
.text$mn:00009C24                 mov     ecx, [ebp+var_C]
.text$mn:00009C27                 mov     large fs:0, ecx
.text$mn:00009C2E                 pop     ecx
.text$mn:00009C2F                 mov     esp, ebp
.text$mn:00009C31                 pop     ebp
.text$mn:00009C32                 retn
.text$mn:00009C32 ?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ endp
.text$mn:00009C32
.text$mn:00009C32 ; ---------------------------------------------------------------------------
.text$mn:00009C33                 align 4
.text$mn:00009C33 _text$mn        ends
.text$mn:00009C33
.text$x:00009C34 ; ===========================================================================
.text$x:00009C34
.text$x:00009C34 ; Segment type: Pure code
.text$x:00009C34 ; Segment permissions: Read/Execute
.text$x:00009C34 _text$x         segment para public 'CODE' use32
.text$x:00009C34                 assume cs:_text$x
.text$x:00009C34                 ;org 9C34h
.text$x:00009C34 ; COMDAT (pick associative to section at 9B9C)
.text$x:00009C34                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00009C34
.text$x:00009C34 ; =============== S U B R O U T I N E =======================================
.text$x:00009C34
.text$x:00009C34
.text$x:00009C34 __unwindfunclet$?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ$0 proc near
.text$x:00009C34                                         ; DATA XREF: .xdata$x:0000BFB4o
.text$x:00009C34                 lea     ecx, [ebp-3Ch]
.text$x:00009C37                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(void)
.text$x:00009C37 __unwindfunclet$?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ$0 endp
.text$x:00009C37
.text$x:00009C3C
.text$x:00009C3C ; =============== S U B R O U T I N E =======================================
.text$x:00009C3C
.text$x:00009C3C
.text$x:00009C3C __unwindfunclet$?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ$1 proc near
.text$x:00009C3C                                         ; DATA XREF: .xdata$x:0000BFBCo
.text$x:00009C3C                 lea     ecx, [ebp-30h]
.text$x:00009C3F                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(void)
.text$x:00009C3F __unwindfunclet$?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ$1 endp
.text$x:00009C3F
.text$x:00009C44
.text$x:00009C44 ; =============== S U B R O U T I N E =======================================
.text$x:00009C44
.text$x:00009C44
.text$x:00009C44 __ehhandler$?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ proc near
.text$x:00009C44                                         ; DATA XREF: std::deque<uint,std::allocator<uint>>::back(void)+5o
.text$x:00009C44
.text$x:00009C44 arg_4           = dword ptr  8
.text$x:00009C44
.text$x:00009C44                 mov     edx, [esp+arg_4]
.text$x:00009C48                 lea     eax, [edx+0Ch]
.text$x:00009C4B                 mov     ecx, [edx-34h]
.text$x:00009C4E                 xor     ecx, eax
.text$x:00009C50                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00009C55                 mov     eax, offset __ehfuncinfo$?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ
.text$x:00009C5A                 jmp     ___CxxFrameHandler3
.text$x:00009C5A __ehhandler$?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ endp
.text$x:00009C5A
.text$x:00009C5A ; ---------------------------------------------------------------------------
.text$x:00009C5F                 align 10h
.text$x:00009C5F _text$x         ends
.text$x:00009C5F
.text$mn:00009C60 ; ===========================================================================
.text$mn:00009C60
.text$mn:00009C60 ; Segment type: Pure code
.text$mn:00009C60 ; Segment permissions: Read/Execute
.text$mn:00009C60 _text$mn        segment para public 'CODE' use32
.text$mn:00009C60                 assume cs:_text$mn
.text$mn:00009C60                 ;org 9C60h
.text$mn:00009C60 ; COMDAT (pick any)
.text$mn:00009C60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009C60
.text$mn:00009C60 ; =============== S U B R O U T I N E =======================================
.text$mn:00009C60
.text$mn:00009C60 ; Attributes: bp-based frame
.text$mn:00009C60
.text$mn:00009C60 ; void __thiscall Notepad_plus::bookmarkAdd(Notepad_plus *this, int)
.text$mn:00009C60                 public ?bookmarkAdd@Notepad_plus@@ABEXH@Z
.text$mn:00009C60 ?bookmarkAdd@Notepad_plus@@ABEXH@Z proc near
.text$mn:00009C60                                         ; CODE XREF: Notepad_plus::bookmarkToggle(int)+46p
.text$mn:00009C60
.text$mn:00009C60 var_4           = dword ptr -4
.text$mn:00009C60 arg_0           = dword ptr  8
.text$mn:00009C60
.text$mn:00009C60                 push    ebp
.text$mn:00009C61                 mov     ebp, esp
.text$mn:00009C63                 push    ecx
.text$mn:00009C64                 mov     [ebp+var_4], ecx
.text$mn:00009C67                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00009C6B                 jnz     short loc_9C7E
.text$mn:00009C6D                 mov     eax, [ebp+var_4]
.text$mn:00009C70                 mov     ecx, [eax+5D4h] ; this
.text$mn:00009C76                 call    ?getCurrentLineNumber@ScintillaEditView@@QBEJXZ ; ScintillaEditView::getCurrentLineNumber(void)
.text$mn:00009C7B                 mov     [ebp+arg_0], eax
.text$mn:00009C7E
.text$mn:00009C7E loc_9C7E:                               ; CODE XREF: Notepad_plus::bookmarkAdd(int)+Bj
.text$mn:00009C7E                 mov     ecx, [ebp+arg_0]
.text$mn:00009C81                 push    ecx             ; int
.text$mn:00009C82                 mov     ecx, [ebp+var_4] ; this
.text$mn:00009C85                 call    ?bookmarkPresent@Notepad_plus@@ABE_NH@Z ; Notepad_plus::bookmarkPresent(int)
.text$mn:00009C8A                 movzx   edx, al
.text$mn:00009C8D                 test    edx, edx
.text$mn:00009C8F                 jnz     short loc_9CAA
.text$mn:00009C91                 push    18h             ; __int32
.text$mn:00009C93                 mov     eax, [ebp+arg_0]
.text$mn:00009C96                 push    eax             ; unsigned int
.text$mn:00009C97                 push    7FBh            ; unsigned int
.text$mn:00009C9C                 mov     ecx, [ebp+var_4]
.text$mn:00009C9F                 mov     ecx, [ecx+5D4h] ; this
.text$mn:00009CA5                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00009CAA
.text$mn:00009CAA loc_9CAA:                               ; CODE XREF: Notepad_plus::bookmarkAdd(int)+2Fj
.text$mn:00009CAA                 mov     esp, ebp
.text$mn:00009CAC                 pop     ebp
.text$mn:00009CAD                 retn    4
.text$mn:00009CAD ?bookmarkAdd@Notepad_plus@@ABEXH@Z endp
.text$mn:00009CAD
.text$mn:00009CAD _text$mn        ends
.text$mn:00009CAD
.text$mn:00009CB0 ; ===========================================================================
.text$mn:00009CB0
.text$mn:00009CB0 ; Segment type: Pure code
.text$mn:00009CB0 ; Segment permissions: Read/Execute
.text$mn:00009CB0 _text$mn        segment para public 'CODE' use32
.text$mn:00009CB0                 assume cs:_text$mn
.text$mn:00009CB0                 ;org 9CB0h
.text$mn:00009CB0 ; COMDAT (pick any)
.text$mn:00009CB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009CB0
.text$mn:00009CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00009CB0
.text$mn:00009CB0 ; Attributes: bp-based frame
.text$mn:00009CB0
.text$mn:00009CB0 ; void __thiscall Notepad_plus::bookmarkDelete(Notepad_plus *this, int)
.text$mn:00009CB0                 public ?bookmarkDelete@Notepad_plus@@ABEXH@Z
.text$mn:00009CB0 ?bookmarkDelete@Notepad_plus@@ABEXH@Z proc near
.text$mn:00009CB0                                         ; CODE XREF: Notepad_plus::bookmarkToggle(int)+38p
.text$mn:00009CB0
.text$mn:00009CB0 var_4           = dword ptr -4
.text$mn:00009CB0 arg_0           = dword ptr  8
.text$mn:00009CB0
.text$mn:00009CB0                 push    ebp
.text$mn:00009CB1                 mov     ebp, esp
.text$mn:00009CB3                 push    ecx
.text$mn:00009CB4                 mov     [ebp+var_4], ecx
.text$mn:00009CB7                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00009CBB                 jnz     short loc_9CCE
.text$mn:00009CBD                 mov     eax, [ebp+var_4]
.text$mn:00009CC0                 mov     ecx, [eax+5D4h] ; this
.text$mn:00009CC6                 call    ?getCurrentLineNumber@ScintillaEditView@@QBEJXZ ; ScintillaEditView::getCurrentLineNumber(void)
.text$mn:00009CCB                 mov     [ebp+arg_0], eax
.text$mn:00009CCE
.text$mn:00009CCE loc_9CCE:                               ; CODE XREF: Notepad_plus::bookmarkDelete(int)+Bj
.text$mn:00009CCE                 mov     ecx, [ebp+arg_0]
.text$mn:00009CD1                 push    ecx             ; int
.text$mn:00009CD2                 mov     ecx, [ebp+var_4] ; this
.text$mn:00009CD5                 call    ?bookmarkPresent@Notepad_plus@@ABE_NH@Z ; Notepad_plus::bookmarkPresent(int)
.text$mn:00009CDA                 movzx   edx, al
.text$mn:00009CDD                 test    edx, edx
.text$mn:00009CDF                 jz      short loc_9CFA
.text$mn:00009CE1                 push    18h             ; __int32
.text$mn:00009CE3                 mov     eax, [ebp+arg_0]
.text$mn:00009CE6                 push    eax             ; unsigned int
.text$mn:00009CE7                 push    7FCh            ; unsigned int
.text$mn:00009CEC                 mov     ecx, [ebp+var_4]
.text$mn:00009CEF                 mov     ecx, [ecx+5D4h] ; this
.text$mn:00009CF5                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00009CFA
.text$mn:00009CFA loc_9CFA:                               ; CODE XREF: Notepad_plus::bookmarkDelete(int)+2Fj
.text$mn:00009CFA                 mov     esp, ebp
.text$mn:00009CFC                 pop     ebp
.text$mn:00009CFD                 retn    4
.text$mn:00009CFD ?bookmarkDelete@Notepad_plus@@ABEXH@Z endp
.text$mn:00009CFD
.text$mn:00009CFD _text$mn        ends
.text$mn:00009CFD
.text$mn:00009D00 ; ===========================================================================
.text$mn:00009D00
.text$mn:00009D00 ; Segment type: Pure code
.text$mn:00009D00 ; Segment permissions: Read/Execute
.text$mn:00009D00 _text$mn        segment para public 'CODE' use32
.text$mn:00009D00                 assume cs:_text$mn
.text$mn:00009D00                 ;org 9D00h
.text$mn:00009D00 ; COMDAT (pick any)
.text$mn:00009D00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009D00
.text$mn:00009D00 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D00
.text$mn:00009D00 ; Attributes: bp-based frame
.text$mn:00009D00
.text$mn:00009D00 ; bool __thiscall Notepad_plus::bookmarkPresent(Notepad_plus *this, int)
.text$mn:00009D00                 public ?bookmarkPresent@Notepad_plus@@ABE_NH@Z
.text$mn:00009D00 ?bookmarkPresent@Notepad_plus@@ABE_NH@Z proc near
.text$mn:00009D00                                         ; CODE XREF: Notepad_plus::bookmarkAdd(int)+25p
.text$mn:00009D00                                         ; Notepad_plus::bookmarkDelete(int)+25p ...
.text$mn:00009D00
.text$mn:00009D00 var_C           = dword ptr -0Ch
.text$mn:00009D00 var_8           = dword ptr -8
.text$mn:00009D00 var_4           = dword ptr -4
.text$mn:00009D00 arg_0           = dword ptr  8
.text$mn:00009D00
.text$mn:00009D00                 push    ebp
.text$mn:00009D01                 mov     ebp, esp
.text$mn:00009D03                 sub     esp, 0Ch
.text$mn:00009D06                 mov     [ebp+var_4], ecx
.text$mn:00009D09                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00009D0D                 jnz     short loc_9D20
.text$mn:00009D0F                 mov     eax, [ebp+var_4]
.text$mn:00009D12                 mov     ecx, [eax+5D4h] ; this
.text$mn:00009D18                 call    ?getCurrentLineNumber@ScintillaEditView@@QBEJXZ ; ScintillaEditView::getCurrentLineNumber(void)
.text$mn:00009D1D                 mov     [ebp+arg_0], eax
.text$mn:00009D20
.text$mn:00009D20 loc_9D20:                               ; CODE XREF: Notepad_plus::bookmarkPresent(int)+Dj
.text$mn:00009D20                 push    0               ; __int32
.text$mn:00009D22                 mov     ecx, [ebp+arg_0]
.text$mn:00009D25                 push    ecx             ; unsigned int
.text$mn:00009D26                 push    7FEh            ; unsigned int
.text$mn:00009D2B                 mov     edx, [ebp+var_4]
.text$mn:00009D2E                 mov     ecx, [edx+5D4h] ; this
.text$mn:00009D34                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00009D39                 mov     [ebp+var_C], eax
.text$mn:00009D3C                 mov     eax, [ebp+var_C]
.text$mn:00009D3F                 and     eax, 1000000h
.text$mn:00009D44                 jz      short loc_9D4F
.text$mn:00009D46                 mov     [ebp+var_8], 1
.text$mn:00009D4D                 jmp     short loc_9D56
.text$mn:00009D4F ; ---------------------------------------------------------------------------
.text$mn:00009D4F
.text$mn:00009D4F loc_9D4F:                               ; CODE XREF: Notepad_plus::bookmarkPresent(int)+44j
.text$mn:00009D4F                 mov     [ebp+var_8], 0
.text$mn:00009D56
.text$mn:00009D56 loc_9D56:                               ; CODE XREF: Notepad_plus::bookmarkPresent(int)+4Dj
.text$mn:00009D56                 mov     al, byte ptr [ebp+var_8]
.text$mn:00009D59                 mov     esp, ebp
.text$mn:00009D5B                 pop     ebp
.text$mn:00009D5C                 retn    4
.text$mn:00009D5C ?bookmarkPresent@Notepad_plus@@ABE_NH@Z endp
.text$mn:00009D5C
.text$mn:00009D5C ; ---------------------------------------------------------------------------
.text$mn:00009D5F                 align 10h
.text$mn:00009D5F _text$mn        ends
.text$mn:00009D5F
.text$mn:00009D60 ; ===========================================================================
.text$mn:00009D60
.text$mn:00009D60 ; Segment type: Pure code
.text$mn:00009D60 ; Segment permissions: Read/Execute
.text$mn:00009D60 _text$mn        segment para public 'CODE' use32
.text$mn:00009D60                 assume cs:_text$mn
.text$mn:00009D60                 ;org 9D60h
.text$mn:00009D60 ; COMDAT (pick any)
.text$mn:00009D60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009D60
.text$mn:00009D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00009D60
.text$mn:00009D60 ; Attributes: bp-based frame
.text$mn:00009D60
.text$mn:00009D60 ; void __thiscall Notepad_plus::bookmarkToggle(Notepad_plus *this, int)
.text$mn:00009D60                 public ?bookmarkToggle@Notepad_plus@@ABEXH@Z
.text$mn:00009D60 ?bookmarkToggle@Notepad_plus@@ABEXH@Z proc near
.text$mn:00009D60                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+1FECp
.text$mn:00009D60
.text$mn:00009D60 var_4           = dword ptr -4
.text$mn:00009D60 arg_0           = dword ptr  8
.text$mn:00009D60
.text$mn:00009D60                 push    ebp
.text$mn:00009D61                 mov     ebp, esp
.text$mn:00009D63                 push    ecx
.text$mn:00009D64                 mov     [ebp+var_4], ecx
.text$mn:00009D67                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00009D6B                 jnz     short loc_9D7E
.text$mn:00009D6D                 mov     eax, [ebp+var_4]
.text$mn:00009D70                 mov     ecx, [eax+5D4h] ; this
.text$mn:00009D76                 call    ?getCurrentLineNumber@ScintillaEditView@@QBEJXZ ; ScintillaEditView::getCurrentLineNumber(void)
.text$mn:00009D7B                 mov     [ebp+arg_0], eax
.text$mn:00009D7E
.text$mn:00009D7E loc_9D7E:                               ; CODE XREF: Notepad_plus::bookmarkToggle(int)+Bj
.text$mn:00009D7E                 mov     ecx, [ebp+arg_0]
.text$mn:00009D81                 push    ecx             ; int
.text$mn:00009D82                 mov     ecx, [ebp+var_4] ; this
.text$mn:00009D85                 call    ?bookmarkPresent@Notepad_plus@@ABE_NH@Z ; Notepad_plus::bookmarkPresent(int)
.text$mn:00009D8A                 movzx   edx, al
.text$mn:00009D8D                 test    edx, edx
.text$mn:00009D8F                 jz      short loc_9D9F
.text$mn:00009D91                 mov     eax, [ebp+arg_0]
.text$mn:00009D94                 push    eax             ; int
.text$mn:00009D95                 mov     ecx, [ebp+var_4] ; this
.text$mn:00009D98                 call    ?bookmarkDelete@Notepad_plus@@ABEXH@Z ; Notepad_plus::bookmarkDelete(int)
.text$mn:00009D9D                 jmp     short loc_9DAB
.text$mn:00009D9F ; ---------------------------------------------------------------------------
.text$mn:00009D9F
.text$mn:00009D9F loc_9D9F:                               ; CODE XREF: Notepad_plus::bookmarkToggle(int)+2Fj
.text$mn:00009D9F                 mov     ecx, [ebp+arg_0]
.text$mn:00009DA2                 push    ecx             ; int
.text$mn:00009DA3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00009DA6                 call    ?bookmarkAdd@Notepad_plus@@ABEXH@Z ; Notepad_plus::bookmarkAdd(int)
.text$mn:00009DAB
.text$mn:00009DAB loc_9DAB:                               ; CODE XREF: Notepad_plus::bookmarkToggle(int)+3Dj
.text$mn:00009DAB                 mov     esp, ebp
.text$mn:00009DAD                 pop     ebp
.text$mn:00009DAE                 retn    4
.text$mn:00009DAE ?bookmarkToggle@Notepad_plus@@ABEXH@Z endp
.text$mn:00009DAE
.text$mn:00009DAE ; ---------------------------------------------------------------------------
.text$mn:00009DB1                 align 4
.text$mn:00009DB1 _text$mn        ends
.text$mn:00009DB1
.text$mn:00009DB4 ; ===========================================================================
.text$mn:00009DB4
.text$mn:00009DB4 ; Segment type: Pure code
.text$mn:00009DB4 ; Segment permissions: Read/Execute
.text$mn:00009DB4 _text$mn        segment para public 'CODE' use32
.text$mn:00009DB4                 assume cs:_text$mn
.text$mn:00009DB4                 ;org 9DB4h
.text$mn:00009DB4 ; COMDAT (pick any)
.text$mn:00009DB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009DB4
.text$mn:00009DB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00009DB4
.text$mn:00009DB4 ; Attributes: bp-based frame
.text$mn:00009DB4
.text$mn:00009DB4 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:00009DB4                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:00009DB4 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:00009DB4                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+90Dp
.text$mn:00009DB4                                         ; Notepad_plus::notify(SCNotification *)+2A73p ...
.text$mn:00009DB4
.text$mn:00009DB4 var_4           = dword ptr -4
.text$mn:00009DB4
.text$mn:00009DB4                 push    ebp
.text$mn:00009DB5                 mov     ebp, esp
.text$mn:00009DB7                 push    ecx
.text$mn:00009DB8                 mov     [ebp+var_4], ecx
.text$mn:00009DBB                 mov     ecx, [ebp+var_4]
.text$mn:00009DBE                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00009DC3                 mov     esp, ebp
.text$mn:00009DC5                 pop     ebp
.text$mn:00009DC6                 retn
.text$mn:00009DC6 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:00009DC6
.text$mn:00009DC6 ; ---------------------------------------------------------------------------
.text$mn:00009DC7                 align 4
.text$mn:00009DC7 _text$mn        ends
.text$mn:00009DC7
.text$mn:00009DC8 ; ===========================================================================
.text$mn:00009DC8
.text$mn:00009DC8 ; Segment type: Pure code
.text$mn:00009DC8 ; Segment permissions: Read/Execute
.text$mn:00009DC8 _text$mn        segment para public 'CODE' use32
.text$mn:00009DC8                 assume cs:_text$mn
.text$mn:00009DC8                 ;org 9DC8h
.text$mn:00009DC8 ; COMDAT (pick any)
.text$mn:00009DC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009DC8
.text$mn:00009DC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00009DC8
.text$mn:00009DC8 ; Attributes: bp-based frame
.text$mn:00009DC8
.text$mn:00009DC8 ; public: unsigned int __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::capacity(void)const
.text$mn:00009DC8                 public ?capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ
.text$mn:00009DC8 ?capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ proc near
.text$mn:00009DC8                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Grow_to(uint)+Cp
.text$mn:00009DC8
.text$mn:00009DC8 var_4           = dword ptr -4
.text$mn:00009DC8
.text$mn:00009DC8                 push    ebp
.text$mn:00009DC9                 mov     ebp, esp
.text$mn:00009DCB                 push    ecx
.text$mn:00009DCC                 mov     [ebp+var_4], ecx
.text$mn:00009DCF                 mov     eax, [ebp+var_4]
.text$mn:00009DD2                 mov     ecx, [ebp+var_4]
.text$mn:00009DD5                 mov     eax, [eax+0Ch]
.text$mn:00009DD8                 sub     eax, [ecx+4]
.text$mn:00009DDB                 cdq
.text$mn:00009DDC                 mov     ecx, 3Ch ; '<'
.text$mn:00009DE1                 idiv    ecx
.text$mn:00009DE3                 mov     esp, ebp
.text$mn:00009DE5                 pop     ebp
.text$mn:00009DE6                 retn
.text$mn:00009DE6 ?capacity@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ endp
.text$mn:00009DE6
.text$mn:00009DE6 ; ---------------------------------------------------------------------------
.text$mn:00009DE7                 align 4
.text$mn:00009DE7 _text$mn        ends
.text$mn:00009DE7
.text$mn:00009DE8 ; ===========================================================================
.text$mn:00009DE8
.text$mn:00009DE8 ; Segment type: Pure code
.text$mn:00009DE8 ; Segment permissions: Read/Execute
.text$mn:00009DE8 _text$mn        segment para public 'CODE' use32
.text$mn:00009DE8                 assume cs:_text$mn
.text$mn:00009DE8                 ;org 9DE8h
.text$mn:00009DE8 ; COMDAT (pick any)
.text$mn:00009DE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009DE8
.text$mn:00009DE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00009DE8
.text$mn:00009DE8 ; Attributes: bp-based frame
.text$mn:00009DE8
.text$mn:00009DE8 ; public: unsigned int __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::capacity(void)const
.text$mn:00009DE8                 public ?capacity@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ
.text$mn:00009DE8 ?capacity@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ proc near
.text$mn:00009DE8                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Grow_to(uint)+Cp
.text$mn:00009DE8
.text$mn:00009DE8 var_4           = dword ptr -4
.text$mn:00009DE8
.text$mn:00009DE8                 push    ebp
.text$mn:00009DE9                 mov     ebp, esp
.text$mn:00009DEB                 push    ecx
.text$mn:00009DEC                 mov     [ebp+var_4], ecx
.text$mn:00009DEF                 mov     eax, [ebp+var_4]
.text$mn:00009DF2                 mov     ecx, [ebp+var_4]
.text$mn:00009DF5                 mov     eax, [eax+0Ch]
.text$mn:00009DF8                 sub     eax, [ecx+4]
.text$mn:00009DFB                 cdq
.text$mn:00009DFC                 mov     ecx, 2Ch ; ','
.text$mn:00009E01                 idiv    ecx
.text$mn:00009E03                 mov     esp, ebp
.text$mn:00009E05                 pop     ebp
.text$mn:00009E06                 retn
.text$mn:00009E06 ?capacity@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ endp
.text$mn:00009E06
.text$mn:00009E06 ; ---------------------------------------------------------------------------
.text$mn:00009E07                 align 4
.text$mn:00009E07 _text$mn        ends
.text$mn:00009E07
.text$mn:00009E08 ; ===========================================================================
.text$mn:00009E08
.text$mn:00009E08 ; Segment type: Pure code
.text$mn:00009E08 ; Segment permissions: Read/Execute
.text$mn:00009E08 _text$mn        segment para public 'CODE' use32
.text$mn:00009E08                 assume cs:_text$mn
.text$mn:00009E08                 ;org 9E08h
.text$mn:00009E08 ; COMDAT (pick any)
.text$mn:00009E08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009E08
.text$mn:00009E08 ; =============== S U B R O U T I N E =======================================
.text$mn:00009E08
.text$mn:00009E08 ; Attributes: bp-based frame
.text$mn:00009E08
.text$mn:00009E08 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00009E08                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00009E08 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00009E08                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00009E08
.text$mn:00009E08 var_4           = dword ptr -4
.text$mn:00009E08
.text$mn:00009E08                 push    ebp
.text$mn:00009E09                 mov     ebp, esp
.text$mn:00009E0B                 push    ecx
.text$mn:00009E0C                 mov     [ebp+var_4], ecx
.text$mn:00009E0F                 mov     eax, [ebp+var_4]
.text$mn:00009E12                 mov     eax, [eax+4]
.text$mn:00009E15                 mov     esp, ebp
.text$mn:00009E17                 pop     ebp
.text$mn:00009E18                 retn
.text$mn:00009E18 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00009E18
.text$mn:00009E18 ; ---------------------------------------------------------------------------
.text$mn:00009E19                 align 4
.text$mn:00009E19 _text$mn        ends
.text$mn:00009E19
.text$mn:00009E1C ; ===========================================================================
.text$mn:00009E1C
.text$mn:00009E1C ; Segment type: Pure code
.text$mn:00009E1C ; Segment permissions: Read/Execute
.text$mn:00009E1C _text$mn        segment para public 'CODE' use32
.text$mn:00009E1C                 assume cs:_text$mn
.text$mn:00009E1C                 ;org 9E1Ch
.text$mn:00009E1C ; COMDAT (pick any)
.text$mn:00009E1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009E1C
.text$mn:00009E1C ; =============== S U B R O U T I N E =======================================
.text$mn:00009E1C
.text$mn:00009E1C ; Attributes: bp-based frame
.text$mn:00009E1C
.text$mn:00009E1C ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00009E1C                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00009E1C ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00009E1C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00009E1C                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00009E1C
.text$mn:00009E1C var_4           = dword ptr -4
.text$mn:00009E1C
.text$mn:00009E1C                 push    ebp
.text$mn:00009E1D                 mov     ebp, esp
.text$mn:00009E1F                 push    ecx
.text$mn:00009E20                 mov     [ebp+var_4], ecx
.text$mn:00009E23                 mov     eax, [ebp+var_4]
.text$mn:00009E26                 mov     eax, [eax+4]
.text$mn:00009E29                 mov     esp, ebp
.text$mn:00009E2B                 pop     ebp
.text$mn:00009E2C                 retn
.text$mn:00009E2C ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00009E2C
.text$mn:00009E2C ; ---------------------------------------------------------------------------
.text$mn:00009E2D                 align 10h
.text$mn:00009E2D _text$mn        ends
.text$mn:00009E2D
.text$mn:00009E30 ; ===========================================================================
.text$mn:00009E30
.text$mn:00009E30 ; Segment type: Pure code
.text$mn:00009E30 ; Segment permissions: Read/Execute
.text$mn:00009E30 _text$mn        segment para public 'CODE' use32
.text$mn:00009E30                 assume cs:_text$mn
.text$mn:00009E30                 ;org 9E30h
.text$mn:00009E30 ; COMDAT (pick any)
.text$mn:00009E30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009E30
.text$mn:00009E30 ; =============== S U B R O U T I N E =======================================
.text$mn:00009E30
.text$mn:00009E30 ; Attributes: bp-based frame
.text$mn:00009E30
.text$mn:00009E30 ; void __thiscall ContextMenu::checkItem(ContextMenu *this, UINT uIDCheckItem, bool)
.text$mn:00009E30                 public ?checkItem@ContextMenu@@QBEXH_N@Z
.text$mn:00009E30 ?checkItem@ContextMenu@@QBEXH_N@Z proc near
.text$mn:00009E30                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+1D19p
.text$mn:00009E30
.text$mn:00009E30 var_8           = dword ptr -8
.text$mn:00009E30 uCheck          = dword ptr -4
.text$mn:00009E30 uIDCheckItem    = dword ptr  8
.text$mn:00009E30 arg_4           = byte ptr  0Ch
.text$mn:00009E30
.text$mn:00009E30                 push    ebp
.text$mn:00009E31                 mov     ebp, esp
.text$mn:00009E33                 sub     esp, 8
.text$mn:00009E36                 mov     [ebp+var_8], ecx
.text$mn:00009E39                 movzx   eax, [ebp+arg_4]
.text$mn:00009E3D                 test    eax, eax
.text$mn:00009E3F                 jz      short loc_9E4A
.text$mn:00009E41                 mov     [ebp+uCheck], 8
.text$mn:00009E48                 jmp     short loc_9E51
.text$mn:00009E4A ; ---------------------------------------------------------------------------
.text$mn:00009E4A
.text$mn:00009E4A loc_9E4A:                               ; CODE XREF: ContextMenu::checkItem(int,bool)+Fj
.text$mn:00009E4A                 mov     [ebp+uCheck], 0
.text$mn:00009E51
.text$mn:00009E51 loc_9E51:                               ; CODE XREF: ContextMenu::checkItem(int,bool)+18j
.text$mn:00009E51                 mov     ecx, [ebp+uCheck]
.text$mn:00009E54                 push    ecx             ; uCheck
.text$mn:00009E55                 mov     edx, [ebp+uIDCheckItem]
.text$mn:00009E58                 push    edx             ; uIDCheckItem
.text$mn:00009E59                 mov     eax, [ebp+var_8]
.text$mn:00009E5C                 mov     ecx, [eax+4]
.text$mn:00009E5F                 push    ecx             ; hMenu
.text$mn:00009E60                 call    dword ptr ds:__imp__CheckMenuItem@12 ; CheckMenuItem(x,x,x)
.text$mn:00009E66                 mov     esp, ebp
.text$mn:00009E68                 pop     ebp
.text$mn:00009E69                 retn    8
.text$mn:00009E69 ?checkItem@ContextMenu@@QBEXH_N@Z endp
.text$mn:00009E69
.text$mn:00009E69 _text$mn        ends
.text$mn:00009E69
.text$mn:00009E6C ; ===========================================================================
.text$mn:00009E6C
.text$mn:00009E6C ; Segment type: Pure code
.text$mn:00009E6C ; Segment permissions: Read/Execute
.text$mn:00009E6C _text$mn        segment para public 'CODE' use32
.text$mn:00009E6C                 assume cs:_text$mn
.text$mn:00009E6C                 ;org 9E6Ch
.text$mn:00009E6C ; COMDAT (pick any)
.text$mn:00009E6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009E6C
.text$mn:00009E6C ; =============== S U B R O U T I N E =======================================
.text$mn:00009E6C
.text$mn:00009E6C ; Attributes: bp-based frame
.text$mn:00009E6C
.text$mn:00009E6C ; int __stdcall std::allocator<unsigned int>::construct(void *, int)
.text$mn:00009E6C                 public ?construct@?$allocator@I@std@@QAEXPAIABI@Z
.text$mn:00009E6C ?construct@?$allocator@I@std@@QAEXPAIABI@Z proc near
.text$mn:00009E6C                                         ; CODE XREF: std::allocator_traits<std::allocator<uint>>::construct<uint,uint const &>(std::allocator<uint> &,uint *,uint const &)+17p
.text$mn:00009E6C
.text$mn:00009E6C var_C           = dword ptr -0Ch
.text$mn:00009E6C var_8           = dword ptr -8
.text$mn:00009E6C var_4           = dword ptr -4
.text$mn:00009E6C arg_0           = dword ptr  8
.text$mn:00009E6C arg_4           = dword ptr  0Ch
.text$mn:00009E6C
.text$mn:00009E6C                 push    ebp
.text$mn:00009E6D                 mov     ebp, esp
.text$mn:00009E6F                 sub     esp, 0Ch
.text$mn:00009E72                 mov     [ebp+var_C], ecx
.text$mn:00009E75                 mov     eax, [ebp+arg_0]
.text$mn:00009E78                 push    eax             ; void *
.text$mn:00009E79                 push    4               ; unsigned int
.text$mn:00009E7B                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00009E80                 add     esp, 8
.text$mn:00009E83                 mov     [ebp+var_4], eax
.text$mn:00009E86                 cmp     [ebp+var_4], 0
.text$mn:00009E8A                 jz      short loc_9E9E
.text$mn:00009E8C                 mov     ecx, [ebp+var_4]
.text$mn:00009E8F                 mov     edx, [ebp+arg_4]
.text$mn:00009E92                 mov     eax, [edx]
.text$mn:00009E94                 mov     [ecx], eax
.text$mn:00009E96                 mov     ecx, [ebp+var_4]
.text$mn:00009E99                 mov     [ebp+var_8], ecx
.text$mn:00009E9C                 jmp     short loc_9EA5
.text$mn:00009E9E ; ---------------------------------------------------------------------------
.text$mn:00009E9E
.text$mn:00009E9E loc_9E9E:                               ; CODE XREF: std::allocator<uint>::construct(uint *,uint const &)+1Ej
.text$mn:00009E9E                 mov     [ebp+var_8], 0
.text$mn:00009EA5
.text$mn:00009EA5 loc_9EA5:                               ; CODE XREF: std::allocator<uint>::construct(uint *,uint const &)+30j
.text$mn:00009EA5                 mov     esp, ebp
.text$mn:00009EA7                 pop     ebp
.text$mn:00009EA8                 retn    8
.text$mn:00009EA8 ?construct@?$allocator@I@std@@QAEXPAIABI@Z endp
.text$mn:00009EA8
.text$mn:00009EA8 ; ---------------------------------------------------------------------------
.text$mn:00009EAB                 align 4
.text$mn:00009EAB _text$mn        ends
.text$mn:00009EAB
.text$mn:00009EAC ; ===========================================================================
.text$mn:00009EAC
.text$mn:00009EAC ; Segment type: Pure code
.text$mn:00009EAC ; Segment permissions: Read/Execute
.text$mn:00009EAC _text$mn        segment para public 'CODE' use32
.text$mn:00009EAC                 assume cs:_text$mn
.text$mn:00009EAC                 ;org 9EACh
.text$mn:00009EAC ; COMDAT (pick any)
.text$mn:00009EAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009EAC
.text$mn:00009EAC ; =============== S U B R O U T I N E =======================================
.text$mn:00009EAC
.text$mn:00009EAC ; Attributes: bp-based frame
.text$mn:00009EAC
.text$mn:00009EAC ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00009EAC                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00009EAC ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00009EAC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00009EAC
.text$mn:00009EAC var_4           = dword ptr -4
.text$mn:00009EAC Dst             = dword ptr  8
.text$mn:00009EAC Src             = dword ptr  0Ch
.text$mn:00009EAC Size            = dword ptr  10h
.text$mn:00009EAC
.text$mn:00009EAC                 push    ebp
.text$mn:00009EAD                 mov     ebp, esp
.text$mn:00009EAF                 push    ecx
.text$mn:00009EB0                 cmp     [ebp+Size], 0
.text$mn:00009EB4                 jnz     short loc_9EBE
.text$mn:00009EB6                 mov     eax, [ebp+Dst]
.text$mn:00009EB9                 mov     [ebp+var_4], eax
.text$mn:00009EBC                 jmp     short loc_9ED5
.text$mn:00009EBE ; ---------------------------------------------------------------------------
.text$mn:00009EBE
.text$mn:00009EBE loc_9EBE:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00009EBE                 mov     ecx, [ebp+Size]
.text$mn:00009EC1                 push    ecx             ; Size
.text$mn:00009EC2                 mov     edx, [ebp+Src]
.text$mn:00009EC5                 push    edx             ; Src
.text$mn:00009EC6                 mov     eax, [ebp+Dst]
.text$mn:00009EC9                 push    eax             ; Dst
.text$mn:00009ECA                 call    _memcpy
.text$mn:00009ECF                 add     esp, 0Ch
.text$mn:00009ED2                 mov     [ebp+var_4], eax
.text$mn:00009ED5
.text$mn:00009ED5 loc_9ED5:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00009ED5                 mov     eax, [ebp+var_4]
.text$mn:00009ED8                 mov     esp, ebp
.text$mn:00009EDA                 pop     ebp
.text$mn:00009EDB                 retn
.text$mn:00009EDB ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00009EDB
.text$mn:00009EDB _text$mn        ends
.text$mn:00009EDB
.text$mn:00009EDC ; ===========================================================================
.text$mn:00009EDC
.text$mn:00009EDC ; Segment type: Pure code
.text$mn:00009EDC ; Segment permissions: Read/Execute
.text$mn:00009EDC _text$mn        segment para public 'CODE' use32
.text$mn:00009EDC                 assume cs:_text$mn
.text$mn:00009EDC                 ;org 9EDCh
.text$mn:00009EDC ; COMDAT (pick any)
.text$mn:00009EDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009EDC
.text$mn:00009EDC ; =============== S U B R O U T I N E =======================================
.text$mn:00009EDC
.text$mn:00009EDC ; Attributes: bp-based frame
.text$mn:00009EDC
.text$mn:00009EDC ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:00009EDC                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00009EDC ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00009EDC                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:00009EDC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00009EDC
.text$mn:00009EDC var_4           = dword ptr -4
.text$mn:00009EDC Dst             = dword ptr  8
.text$mn:00009EDC Src             = dword ptr  0Ch
.text$mn:00009EDC arg_8           = dword ptr  10h
.text$mn:00009EDC
.text$mn:00009EDC                 push    ebp
.text$mn:00009EDD                 mov     ebp, esp
.text$mn:00009EDF                 push    ecx
.text$mn:00009EE0                 cmp     [ebp+arg_8], 0
.text$mn:00009EE4                 jnz     short loc_9EEE
.text$mn:00009EE6                 mov     eax, [ebp+Dst]
.text$mn:00009EE9                 mov     [ebp+var_4], eax
.text$mn:00009EEC                 jmp     short loc_9F05
.text$mn:00009EEE ; ---------------------------------------------------------------------------
.text$mn:00009EEE
.text$mn:00009EEE loc_9EEE:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00009EEE                 mov     ecx, [ebp+arg_8]
.text$mn:00009EF1                 push    ecx             ; int
.text$mn:00009EF2                 mov     edx, [ebp+Src]
.text$mn:00009EF5                 push    edx             ; Src
.text$mn:00009EF6                 mov     eax, [ebp+Dst]
.text$mn:00009EF9                 push    eax             ; Dst
.text$mn:00009EFA                 call    _wmemcpy
.text$mn:00009EFF                 add     esp, 0Ch
.text$mn:00009F02                 mov     [ebp+var_4], eax
.text$mn:00009F05
.text$mn:00009F05 loc_9F05:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00009F05                 mov     eax, [ebp+var_4]
.text$mn:00009F08                 mov     esp, ebp
.text$mn:00009F0A                 pop     ebp
.text$mn:00009F0B                 retn
.text$mn:00009F0B ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00009F0B
.text$mn:00009F0B _text$mn        ends
.text$mn:00009F0B
.text$mn:00009F0C ; ===========================================================================
.text$mn:00009F0C
.text$mn:00009F0C ; Segment type: Pure code
.text$mn:00009F0C ; Segment permissions: Read/Execute
.text$mn:00009F0C _text$mn        segment para public 'CODE' use32
.text$mn:00009F0C                 assume cs:_text$mn
.text$mn:00009F0C                 ;org 9F0Ch
.text$mn:00009F0C ; COMDAT (pick any)
.text$mn:00009F0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009F0C
.text$mn:00009F0C ; =============== S U B R O U T I N E =======================================
.text$mn:00009F0C
.text$mn:00009F0C ; Attributes: bp-based frame
.text$mn:00009F0C
.text$mn:00009F0C ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00009F0C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00009F0C ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00009F0C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00009F0C
.text$mn:00009F0C var_4           = dword ptr -4
.text$mn:00009F0C arg_0           = dword ptr  8
.text$mn:00009F0C arg_4           = dword ptr  0Ch
.text$mn:00009F0C
.text$mn:00009F0C                 push    ebp
.text$mn:00009F0D                 mov     ebp, esp
.text$mn:00009F0F                 push    ecx
.text$mn:00009F10                 mov     [ebp+var_4], ecx
.text$mn:00009F13                 mov     eax, [ebp+arg_4]
.text$mn:00009F16                 push    eax             ; int
.text$mn:00009F17                 mov     ecx, [ebp+arg_0]
.text$mn:00009F1A                 push    ecx             ; void *
.text$mn:00009F1B                 mov     ecx, [ebp+var_4]
.text$mn:00009F1E                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00009F23                 mov     esp, ebp
.text$mn:00009F25                 pop     ebp
.text$mn:00009F26                 retn    8
.text$mn:00009F26 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00009F26
.text$mn:00009F26 ; ---------------------------------------------------------------------------
.text$mn:00009F29                 align 4
.text$mn:00009F29 _text$mn        ends
.text$mn:00009F29
.text$mn:00009F2C ; ===========================================================================
.text$mn:00009F2C
.text$mn:00009F2C ; Segment type: Pure code
.text$mn:00009F2C ; Segment permissions: Read/Execute
.text$mn:00009F2C _text$mn        segment para public 'CODE' use32
.text$mn:00009F2C                 assume cs:_text$mn
.text$mn:00009F2C                 ;org 9F2Ch
.text$mn:00009F2C ; COMDAT (pick any)
.text$mn:00009F2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009F2C
.text$mn:00009F2C ; =============== S U B R O U T I N E =======================================
.text$mn:00009F2C
.text$mn:00009F2C ; Attributes: bp-based frame
.text$mn:00009F2C
.text$mn:00009F2C ; int __stdcall std::_Wrap_alloc<std::allocator<unsigned int>>::deallocate(void *, int)
.text$mn:00009F2C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z
.text$mn:00009F2C ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z proc near
.text$mn:00009F2C                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Tidy(void)+7Bp
.text$mn:00009F2C
.text$mn:00009F2C var_4           = dword ptr -4
.text$mn:00009F2C arg_0           = dword ptr  8
.text$mn:00009F2C arg_4           = dword ptr  0Ch
.text$mn:00009F2C
.text$mn:00009F2C                 push    ebp
.text$mn:00009F2D                 mov     ebp, esp
.text$mn:00009F2F                 push    ecx
.text$mn:00009F30                 mov     [ebp+var_4], ecx
.text$mn:00009F33                 mov     eax, [ebp+arg_4]
.text$mn:00009F36                 push    eax             ; int
.text$mn:00009F37                 mov     ecx, [ebp+arg_0]
.text$mn:00009F3A                 push    ecx             ; void *
.text$mn:00009F3B                 mov     ecx, [ebp+var_4]
.text$mn:00009F3E                 call    ?deallocate@?$allocator@I@std@@QAEXPAII@Z ; std::allocator<uint>::deallocate(uint *,uint)
.text$mn:00009F43                 mov     esp, ebp
.text$mn:00009F45                 pop     ebp
.text$mn:00009F46                 retn    8
.text$mn:00009F46 ?deallocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAII@Z endp
.text$mn:00009F46
.text$mn:00009F46 ; ---------------------------------------------------------------------------
.text$mn:00009F49                 align 4
.text$mn:00009F49 _text$mn        ends
.text$mn:00009F49
.text$mn:00009F4C ; ===========================================================================
.text$mn:00009F4C
.text$mn:00009F4C ; Segment type: Pure code
.text$mn:00009F4C ; Segment permissions: Read/Execute
.text$mn:00009F4C _text$mn        segment para public 'CODE' use32
.text$mn:00009F4C                 assume cs:_text$mn
.text$mn:00009F4C                 ;org 9F4Ch
.text$mn:00009F4C ; COMDAT (pick any)
.text$mn:00009F4C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009F4C
.text$mn:00009F4C ; =============== S U B R O U T I N E =======================================
.text$mn:00009F4C
.text$mn:00009F4C ; Attributes: bp-based frame
.text$mn:00009F4C
.text$mn:00009F4C ; int __stdcall std::_Wrap_alloc<std::allocator<unsigned int *>>::deallocate(void *, int)
.text$mn:00009F4C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@QAEXPAPAII@Z
.text$mn:00009F4C ?deallocate@?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@QAEXPAPAII@Z proc near
.text$mn:00009F4C                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+1E5p
.text$mn:00009F4C                                         ; std::deque<uint,std::allocator<uint>>::_Tidy(void)+BCp
.text$mn:00009F4C
.text$mn:00009F4C var_4           = dword ptr -4
.text$mn:00009F4C arg_0           = dword ptr  8
.text$mn:00009F4C arg_4           = dword ptr  0Ch
.text$mn:00009F4C
.text$mn:00009F4C                 push    ebp
.text$mn:00009F4D                 mov     ebp, esp
.text$mn:00009F4F                 push    ecx
.text$mn:00009F50                 mov     [ebp+var_4], ecx
.text$mn:00009F53                 mov     eax, [ebp+arg_4]
.text$mn:00009F56                 push    eax             ; int
.text$mn:00009F57                 mov     ecx, [ebp+arg_0]
.text$mn:00009F5A                 push    ecx             ; void *
.text$mn:00009F5B                 mov     ecx, [ebp+var_4]
.text$mn:00009F5E                 call    ?deallocate@?$allocator@PAI@std@@QAEXPAPAII@Z ; std::allocator<uint *>::deallocate(uint * *,uint)
.text$mn:00009F63                 mov     esp, ebp
.text$mn:00009F65                 pop     ebp
.text$mn:00009F66                 retn    8
.text$mn:00009F66 ?deallocate@?$_Wrap_alloc@V?$allocator@PAI@std@@@std@@QAEXPAPAII@Z endp
.text$mn:00009F66
.text$mn:00009F66 ; ---------------------------------------------------------------------------
.text$mn:00009F69                 align 4
.text$mn:00009F69 _text$mn        ends
.text$mn:00009F69
.text$mn:00009F6C ; ===========================================================================
.text$mn:00009F6C
.text$mn:00009F6C ; Segment type: Pure code
.text$mn:00009F6C ; Segment permissions: Read/Execute
.text$mn:00009F6C _text$mn        segment para public 'CODE' use32
.text$mn:00009F6C                 assume cs:_text$mn
.text$mn:00009F6C                 ;org 9F6Ch
.text$mn:00009F6C ; COMDAT (pick any)
.text$mn:00009F6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009F6C
.text$mn:00009F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00009F6C
.text$mn:00009F6C ; Attributes: bp-based frame
.text$mn:00009F6C
.text$mn:00009F6C ; int __stdcall std::_Wrap_alloc<std::allocator<MenuItemUnit>>::deallocate(void *, int)
.text$mn:00009F6C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@I@Z
.text$mn:00009F6C ?deallocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@I@Z proc near
.text$mn:00009F6C                                         ; CODE XREF: __catch$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:00009F6C                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+FAp ...
.text$mn:00009F6C
.text$mn:00009F6C var_4           = dword ptr -4
.text$mn:00009F6C arg_0           = dword ptr  8
.text$mn:00009F6C arg_4           = dword ptr  0Ch
.text$mn:00009F6C
.text$mn:00009F6C                 push    ebp
.text$mn:00009F6D                 mov     ebp, esp
.text$mn:00009F6F                 push    ecx
.text$mn:00009F70                 mov     [ebp+var_4], ecx
.text$mn:00009F73                 mov     eax, [ebp+arg_4]
.text$mn:00009F76                 push    eax             ; int
.text$mn:00009F77                 mov     ecx, [ebp+arg_0]
.text$mn:00009F7A                 push    ecx             ; void *
.text$mn:00009F7B                 mov     ecx, [ebp+var_4]
.text$mn:00009F7E                 call    ?deallocate@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@I@Z ; std::allocator<MenuItemUnit>::deallocate(MenuItemUnit *,uint)
.text$mn:00009F83                 mov     esp, ebp
.text$mn:00009F85                 pop     ebp
.text$mn:00009F86                 retn    8
.text$mn:00009F86 ?deallocate@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@I@Z endp
.text$mn:00009F86
.text$mn:00009F86 ; ---------------------------------------------------------------------------
.text$mn:00009F89                 align 4
.text$mn:00009F89 _text$mn        ends
.text$mn:00009F89
.text$mn:00009F8C ; ===========================================================================
.text$mn:00009F8C
.text$mn:00009F8C ; Segment type: Pure code
.text$mn:00009F8C ; Segment permissions: Read/Execute
.text$mn:00009F8C _text$mn        segment para public 'CODE' use32
.text$mn:00009F8C                 assume cs:_text$mn
.text$mn:00009F8C                 ;org 9F8Ch
.text$mn:00009F8C ; COMDAT (pick any)
.text$mn:00009F8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009F8C
.text$mn:00009F8C ; =============== S U B R O U T I N E =======================================
.text$mn:00009F8C
.text$mn:00009F8C ; Attributes: bp-based frame
.text$mn:00009F8C
.text$mn:00009F8C ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:00009F8C                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00009F8C ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00009F8C                                         ; CODE XREF: std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Free_proxy(void)+32p
.text$mn:00009F8C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Free_proxy(void)+32p
.text$mn:00009F8C
.text$mn:00009F8C var_4           = dword ptr -4
.text$mn:00009F8C arg_0           = dword ptr  8
.text$mn:00009F8C arg_4           = dword ptr  0Ch
.text$mn:00009F8C
.text$mn:00009F8C                 push    ebp
.text$mn:00009F8D                 mov     ebp, esp
.text$mn:00009F8F                 push    ecx
.text$mn:00009F90                 mov     [ebp+var_4], ecx
.text$mn:00009F93                 mov     eax, [ebp+arg_4]
.text$mn:00009F96                 push    eax             ; int
.text$mn:00009F97                 mov     ecx, [ebp+arg_0]
.text$mn:00009F9A                 push    ecx             ; void *
.text$mn:00009F9B                 mov     ecx, [ebp+var_4]
.text$mn:00009F9E                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00009FA3                 mov     esp, ebp
.text$mn:00009FA5                 pop     ebp
.text$mn:00009FA6                 retn    8
.text$mn:00009FA6 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00009FA6
.text$mn:00009FA6 ; ---------------------------------------------------------------------------
.text$mn:00009FA9                 align 4
.text$mn:00009FA9 _text$mn        ends
.text$mn:00009FA9
.text$mn:00009FAC ; ===========================================================================
.text$mn:00009FAC
.text$mn:00009FAC ; Segment type: Pure code
.text$mn:00009FAC ; Segment permissions: Read/Execute
.text$mn:00009FAC _text$mn        segment para public 'CODE' use32
.text$mn:00009FAC                 assume cs:_text$mn
.text$mn:00009FAC                 ;org 9FACh
.text$mn:00009FAC ; COMDAT (pick any)
.text$mn:00009FAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009FAC
.text$mn:00009FAC ; =============== S U B R O U T I N E =======================================
.text$mn:00009FAC
.text$mn:00009FAC ; Attributes: bp-based frame
.text$mn:00009FAC
.text$mn:00009FAC ; int __stdcall std::_Wrap_alloc<std::allocator<recordedMacroStep>>::deallocate(void *, int)
.text$mn:00009FAC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@I@Z
.text$mn:00009FAC ?deallocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@I@Z proc near
.text$mn:00009FAC                                         ; CODE XREF: __catch$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:00009FAC                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reallocate(uint)+FAp
.text$mn:00009FAC
.text$mn:00009FAC var_4           = dword ptr -4
.text$mn:00009FAC arg_0           = dword ptr  8
.text$mn:00009FAC arg_4           = dword ptr  0Ch
.text$mn:00009FAC
.text$mn:00009FAC                 push    ebp
.text$mn:00009FAD                 mov     ebp, esp
.text$mn:00009FAF                 push    ecx
.text$mn:00009FB0                 mov     [ebp+var_4], ecx
.text$mn:00009FB3                 mov     eax, [ebp+arg_4]
.text$mn:00009FB6                 push    eax             ; int
.text$mn:00009FB7                 mov     ecx, [ebp+arg_0]
.text$mn:00009FBA                 push    ecx             ; void *
.text$mn:00009FBB                 mov     ecx, [ebp+var_4]
.text$mn:00009FBE                 call    ?deallocate@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@I@Z ; std::allocator<recordedMacroStep>::deallocate(recordedMacroStep *,uint)
.text$mn:00009FC3                 mov     esp, ebp
.text$mn:00009FC5                 pop     ebp
.text$mn:00009FC6                 retn    8
.text$mn:00009FC6 ?deallocate@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@I@Z endp
.text$mn:00009FC6
.text$mn:00009FC6 ; ---------------------------------------------------------------------------
.text$mn:00009FC9                 align 4
.text$mn:00009FC9 _text$mn        ends
.text$mn:00009FC9
.text$mn:00009FCC ; ===========================================================================
.text$mn:00009FCC
.text$mn:00009FCC ; Segment type: Pure code
.text$mn:00009FCC ; Segment permissions: Read/Execute
.text$mn:00009FCC _text$mn        segment para public 'CODE' use32
.text$mn:00009FCC                 assume cs:_text$mn
.text$mn:00009FCC                 ;org 9FCCh
.text$mn:00009FCC ; COMDAT (pick any)
.text$mn:00009FCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009FCC
.text$mn:00009FCC ; =============== S U B R O U T I N E =======================================
.text$mn:00009FCC
.text$mn:00009FCC ; Attributes: bp-based frame
.text$mn:00009FCC
.text$mn:00009FCC ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:00009FCC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:00009FCC ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:00009FCC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:00009FCC
.text$mn:00009FCC var_4           = dword ptr -4
.text$mn:00009FCC arg_0           = dword ptr  8
.text$mn:00009FCC arg_4           = dword ptr  0Ch
.text$mn:00009FCC
.text$mn:00009FCC                 push    ebp
.text$mn:00009FCD                 mov     ebp, esp
.text$mn:00009FCF                 push    ecx
.text$mn:00009FD0                 mov     [ebp+var_4], ecx
.text$mn:00009FD3                 mov     eax, [ebp+arg_4]
.text$mn:00009FD6                 push    eax             ; int
.text$mn:00009FD7                 mov     ecx, [ebp+arg_0]
.text$mn:00009FDA                 push    ecx             ; void *
.text$mn:00009FDB                 mov     ecx, [ebp+var_4]
.text$mn:00009FDE                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:00009FE3                 mov     esp, ebp
.text$mn:00009FE5                 pop     ebp
.text$mn:00009FE6                 retn    8
.text$mn:00009FE6 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:00009FE6
.text$mn:00009FE6 ; ---------------------------------------------------------------------------
.text$mn:00009FE9                 align 4
.text$mn:00009FE9 _text$mn        ends
.text$mn:00009FE9
.text$mn:00009FEC ; ===========================================================================
.text$mn:00009FEC
.text$mn:00009FEC ; Segment type: Pure code
.text$mn:00009FEC ; Segment permissions: Read/Execute
.text$mn:00009FEC _text$mn        segment para public 'CODE' use32
.text$mn:00009FEC                 assume cs:_text$mn
.text$mn:00009FEC                 ;org 9FECh
.text$mn:00009FEC ; COMDAT (pick any)
.text$mn:00009FEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00009FEC
.text$mn:00009FEC ; =============== S U B R O U T I N E =======================================
.text$mn:00009FEC
.text$mn:00009FEC ; Attributes: bp-based frame
.text$mn:00009FEC
.text$mn:00009FEC ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00009FEC                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00009FEC ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00009FEC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00009FEC
.text$mn:00009FEC var_4           = dword ptr -4
.text$mn:00009FEC arg_0           = dword ptr  8
.text$mn:00009FEC
.text$mn:00009FEC                 push    ebp
.text$mn:00009FED                 mov     ebp, esp
.text$mn:00009FEF                 push    ecx
.text$mn:00009FF0                 mov     [ebp+var_4], ecx
.text$mn:00009FF3                 mov     eax, [ebp+arg_0]
.text$mn:00009FF6                 push    eax             ; void *
.text$mn:00009FF7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00009FFC                 add     esp, 4
.text$mn:00009FFF                 mov     esp, ebp
.text$mn:0000A001                 pop     ebp
.text$mn:0000A002                 retn    8
.text$mn:0000A002 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000A002
.text$mn:0000A002 ; ---------------------------------------------------------------------------
.text$mn:0000A005                 align 4
.text$mn:0000A005 _text$mn        ends
.text$mn:0000A005
.text$mn:0000A008 ; ===========================================================================
.text$mn:0000A008
.text$mn:0000A008 ; Segment type: Pure code
.text$mn:0000A008 ; Segment permissions: Read/Execute
.text$mn:0000A008 _text$mn        segment para public 'CODE' use32
.text$mn:0000A008                 assume cs:_text$mn
.text$mn:0000A008                 ;org 0A008h
.text$mn:0000A008 ; COMDAT (pick any)
.text$mn:0000A008                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A008
.text$mn:0000A008 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A008
.text$mn:0000A008 ; Attributes: bp-based frame
.text$mn:0000A008
.text$mn:0000A008 ; int __stdcall std::allocator<unsigned int>::deallocate(void *, int)
.text$mn:0000A008                 public ?deallocate@?$allocator@I@std@@QAEXPAII@Z
.text$mn:0000A008 ?deallocate@?$allocator@I@std@@QAEXPAII@Z proc near
.text$mn:0000A008                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::deallocate(uint *,uint)+12p
.text$mn:0000A008
.text$mn:0000A008 var_4           = dword ptr -4
.text$mn:0000A008 arg_0           = dword ptr  8
.text$mn:0000A008
.text$mn:0000A008                 push    ebp
.text$mn:0000A009                 mov     ebp, esp
.text$mn:0000A00B                 push    ecx
.text$mn:0000A00C                 mov     [ebp+var_4], ecx
.text$mn:0000A00F                 mov     eax, [ebp+arg_0]
.text$mn:0000A012                 push    eax             ; void *
.text$mn:0000A013                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A018                 add     esp, 4
.text$mn:0000A01B                 mov     esp, ebp
.text$mn:0000A01D                 pop     ebp
.text$mn:0000A01E                 retn    8
.text$mn:0000A01E ?deallocate@?$allocator@I@std@@QAEXPAII@Z endp
.text$mn:0000A01E
.text$mn:0000A01E ; ---------------------------------------------------------------------------
.text$mn:0000A021                 align 4
.text$mn:0000A021 _text$mn        ends
.text$mn:0000A021
.text$mn:0000A024 ; ===========================================================================
.text$mn:0000A024
.text$mn:0000A024 ; Segment type: Pure code
.text$mn:0000A024 ; Segment permissions: Read/Execute
.text$mn:0000A024 _text$mn        segment para public 'CODE' use32
.text$mn:0000A024                 assume cs:_text$mn
.text$mn:0000A024                 ;org 0A024h
.text$mn:0000A024 ; COMDAT (pick any)
.text$mn:0000A024                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A024
.text$mn:0000A024 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A024
.text$mn:0000A024 ; Attributes: bp-based frame
.text$mn:0000A024
.text$mn:0000A024 ; int __stdcall std::allocator<unsigned int *>::deallocate(void *, int)
.text$mn:0000A024                 public ?deallocate@?$allocator@PAI@std@@QAEXPAPAII@Z
.text$mn:0000A024 ?deallocate@?$allocator@PAI@std@@QAEXPAPAII@Z proc near
.text$mn:0000A024                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint *>>::deallocate(uint * *,uint)+12p
.text$mn:0000A024
.text$mn:0000A024 var_4           = dword ptr -4
.text$mn:0000A024 arg_0           = dword ptr  8
.text$mn:0000A024
.text$mn:0000A024                 push    ebp
.text$mn:0000A025                 mov     ebp, esp
.text$mn:0000A027                 push    ecx
.text$mn:0000A028                 mov     [ebp+var_4], ecx
.text$mn:0000A02B                 mov     eax, [ebp+arg_0]
.text$mn:0000A02E                 push    eax             ; void *
.text$mn:0000A02F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A034                 add     esp, 4
.text$mn:0000A037                 mov     esp, ebp
.text$mn:0000A039                 pop     ebp
.text$mn:0000A03A                 retn    8
.text$mn:0000A03A ?deallocate@?$allocator@PAI@std@@QAEXPAPAII@Z endp
.text$mn:0000A03A
.text$mn:0000A03A ; ---------------------------------------------------------------------------
.text$mn:0000A03D                 align 10h
.text$mn:0000A03D _text$mn        ends
.text$mn:0000A03D
.text$mn:0000A040 ; ===========================================================================
.text$mn:0000A040
.text$mn:0000A040 ; Segment type: Pure code
.text$mn:0000A040 ; Segment permissions: Read/Execute
.text$mn:0000A040 _text$mn        segment para public 'CODE' use32
.text$mn:0000A040                 assume cs:_text$mn
.text$mn:0000A040                 ;org 0A040h
.text$mn:0000A040 ; COMDAT (pick any)
.text$mn:0000A040                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A040
.text$mn:0000A040 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A040
.text$mn:0000A040 ; Attributes: bp-based frame
.text$mn:0000A040
.text$mn:0000A040 ; int __stdcall std::allocator<MenuItemUnit>::deallocate(void *, int)
.text$mn:0000A040                 public ?deallocate@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@I@Z
.text$mn:0000A040 ?deallocate@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@I@Z proc near
.text$mn:0000A040                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MenuItemUnit>>::deallocate(MenuItemUnit *,uint)+12p
.text$mn:0000A040
.text$mn:0000A040 var_4           = dword ptr -4
.text$mn:0000A040 arg_0           = dword ptr  8
.text$mn:0000A040
.text$mn:0000A040                 push    ebp
.text$mn:0000A041                 mov     ebp, esp
.text$mn:0000A043                 push    ecx
.text$mn:0000A044                 mov     [ebp+var_4], ecx
.text$mn:0000A047                 mov     eax, [ebp+arg_0]
.text$mn:0000A04A                 push    eax             ; void *
.text$mn:0000A04B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A050                 add     esp, 4
.text$mn:0000A053                 mov     esp, ebp
.text$mn:0000A055                 pop     ebp
.text$mn:0000A056                 retn    8
.text$mn:0000A056 ?deallocate@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@I@Z endp
.text$mn:0000A056
.text$mn:0000A056 ; ---------------------------------------------------------------------------
.text$mn:0000A059                 align 4
.text$mn:0000A059 _text$mn        ends
.text$mn:0000A059
.text$mn:0000A05C ; ===========================================================================
.text$mn:0000A05C
.text$mn:0000A05C ; Segment type: Pure code
.text$mn:0000A05C ; Segment permissions: Read/Execute
.text$mn:0000A05C _text$mn        segment para public 'CODE' use32
.text$mn:0000A05C                 assume cs:_text$mn
.text$mn:0000A05C                 ;org 0A05Ch
.text$mn:0000A05C ; COMDAT (pick any)
.text$mn:0000A05C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A05C
.text$mn:0000A05C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A05C
.text$mn:0000A05C ; Attributes: bp-based frame
.text$mn:0000A05C
.text$mn:0000A05C ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:0000A05C                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000A05C ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000A05C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:0000A05C                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p ...
.text$mn:0000A05C
.text$mn:0000A05C var_4           = dword ptr -4
.text$mn:0000A05C arg_0           = dword ptr  8
.text$mn:0000A05C
.text$mn:0000A05C                 push    ebp
.text$mn:0000A05D                 mov     ebp, esp
.text$mn:0000A05F                 push    ecx
.text$mn:0000A060                 mov     [ebp+var_4], ecx
.text$mn:0000A063                 mov     eax, [ebp+arg_0]
.text$mn:0000A066                 push    eax             ; void *
.text$mn:0000A067                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A06C                 add     esp, 4
.text$mn:0000A06F                 mov     esp, ebp
.text$mn:0000A071                 pop     ebp
.text$mn:0000A072                 retn    8
.text$mn:0000A072 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000A072
.text$mn:0000A072 ; ---------------------------------------------------------------------------
.text$mn:0000A075                 align 4
.text$mn:0000A075 _text$mn        ends
.text$mn:0000A075
.text$mn:0000A078 ; ===========================================================================
.text$mn:0000A078
.text$mn:0000A078 ; Segment type: Pure code
.text$mn:0000A078 ; Segment permissions: Read/Execute
.text$mn:0000A078 _text$mn        segment para public 'CODE' use32
.text$mn:0000A078                 assume cs:_text$mn
.text$mn:0000A078                 ;org 0A078h
.text$mn:0000A078 ; COMDAT (pick any)
.text$mn:0000A078                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A078
.text$mn:0000A078 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A078
.text$mn:0000A078 ; Attributes: bp-based frame
.text$mn:0000A078
.text$mn:0000A078 ; int __stdcall std::allocator<recordedMacroStep>::deallocate(void *, int)
.text$mn:0000A078                 public ?deallocate@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@I@Z
.text$mn:0000A078 ?deallocate@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@I@Z proc near
.text$mn:0000A078                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::deallocate(recordedMacroStep *,uint)+12p
.text$mn:0000A078
.text$mn:0000A078 var_4           = dword ptr -4
.text$mn:0000A078 arg_0           = dword ptr  8
.text$mn:0000A078
.text$mn:0000A078                 push    ebp
.text$mn:0000A079                 mov     ebp, esp
.text$mn:0000A07B                 push    ecx
.text$mn:0000A07C                 mov     [ebp+var_4], ecx
.text$mn:0000A07F                 mov     eax, [ebp+arg_0]
.text$mn:0000A082                 push    eax             ; void *
.text$mn:0000A083                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A088                 add     esp, 4
.text$mn:0000A08B                 mov     esp, ebp
.text$mn:0000A08D                 pop     ebp
.text$mn:0000A08E                 retn    8
.text$mn:0000A08E ?deallocate@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@I@Z endp
.text$mn:0000A08E
.text$mn:0000A08E ; ---------------------------------------------------------------------------
.text$mn:0000A091                 align 4
.text$mn:0000A091 _text$mn        ends
.text$mn:0000A091
.text$mn:0000A094 ; ===========================================================================
.text$mn:0000A094
.text$mn:0000A094 ; Segment type: Pure code
.text$mn:0000A094 ; Segment permissions: Read/Execute
.text$mn:0000A094 _text$mn        segment para public 'CODE' use32
.text$mn:0000A094                 assume cs:_text$mn
.text$mn:0000A094                 ;org 0A094h
.text$mn:0000A094 ; COMDAT (pick any)
.text$mn:0000A094                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A094
.text$mn:0000A094 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A094
.text$mn:0000A094 ; Attributes: bp-based frame
.text$mn:0000A094
.text$mn:0000A094 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:0000A094                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:0000A094 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:0000A094                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:0000A094
.text$mn:0000A094 var_4           = dword ptr -4
.text$mn:0000A094 arg_0           = dword ptr  8
.text$mn:0000A094
.text$mn:0000A094                 push    ebp
.text$mn:0000A095                 mov     ebp, esp
.text$mn:0000A097                 push    ecx
.text$mn:0000A098                 mov     [ebp+var_4], ecx
.text$mn:0000A09B                 mov     eax, [ebp+arg_0]
.text$mn:0000A09E                 push    eax             ; void *
.text$mn:0000A09F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000A0A4                 add     esp, 4
.text$mn:0000A0A7                 mov     esp, ebp
.text$mn:0000A0A9                 pop     ebp
.text$mn:0000A0AA                 retn    8
.text$mn:0000A0AA ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:0000A0AA
.text$mn:0000A0AA ; ---------------------------------------------------------------------------
.text$mn:0000A0AD                 align 10h
.text$mn:0000A0AD _text$mn        ends
.text$mn:0000A0AD
.text$mn:0000A0B0 ; ===========================================================================
.text$mn:0000A0B0
.text$mn:0000A0B0 ; Segment type: Pure code
.text$mn:0000A0B0 ; Segment permissions: Read/Execute
.text$mn:0000A0B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A0B0                 assume cs:_text$mn
.text$mn:0000A0B0                 ;org 0A0B0h
.text$mn:0000A0B0 ; COMDAT (pick any)
.text$mn:0000A0B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A0B0
.text$mn:0000A0B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A0B0
.text$mn:0000A0B0 ; Attributes: bp-based frame
.text$mn:0000A0B0
.text$mn:0000A0B0 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:0000A0B0                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000A0B0 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000A0B0                                         ; DATA XREF: .rdata:0000C494o
.text$mn:0000A0B0
.text$mn:0000A0B0 var_4           = dword ptr -4
.text$mn:0000A0B0 arg_0           = dword ptr  8
.text$mn:0000A0B0 arg_4           = dword ptr  0Ch
.text$mn:0000A0B0
.text$mn:0000A0B0                 push    ebp
.text$mn:0000A0B1                 mov     ebp, esp
.text$mn:0000A0B3                 push    ecx
.text$mn:0000A0B4                 mov     [ebp+var_4], ecx
.text$mn:0000A0B7                 mov     eax, [ebp+arg_4]
.text$mn:0000A0BA                 push    eax             ; int
.text$mn:0000A0BB                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000A0C0                 add     esp, 4
.text$mn:0000A0C3                 test    eax, eax
.text$mn:0000A0C5                 jz      short loc_A0E0
.text$mn:0000A0C7                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:0000A0CC                 push    eax             ; struct std::error_category *
.text$mn:0000A0CD                 mov     ecx, [ebp+arg_4]
.text$mn:0000A0D0                 push    ecx             ; int
.text$mn:0000A0D1                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000A0D4                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000A0D9                 mov     eax, [ebp+arg_0]
.text$mn:0000A0DC                 jmp     short loc_A0F5
.text$mn:0000A0DE ; ---------------------------------------------------------------------------
.text$mn:0000A0DE                 jmp     short loc_A0F5
.text$mn:0000A0E0 ; ---------------------------------------------------------------------------
.text$mn:0000A0E0
.text$mn:0000A0E0 loc_A0E0:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:0000A0E0                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:0000A0E5                 push    eax             ; struct std::error_category *
.text$mn:0000A0E6                 mov     edx, [ebp+arg_4]
.text$mn:0000A0E9                 push    edx             ; int
.text$mn:0000A0EA                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000A0ED                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000A0F2                 mov     eax, [ebp+arg_0]
.text$mn:0000A0F5
.text$mn:0000A0F5 loc_A0F5:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:0000A0F5                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:0000A0F5                 mov     esp, ebp
.text$mn:0000A0F7                 pop     ebp
.text$mn:0000A0F8                 retn    8
.text$mn:0000A0F8 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000A0F8
.text$mn:0000A0F8 ; ---------------------------------------------------------------------------
.text$mn:0000A0FB                 align 4
.text$mn:0000A0FB _text$mn        ends
.text$mn:0000A0FB
.text$mn:0000A0FC ; ===========================================================================
.text$mn:0000A0FC
.text$mn:0000A0FC ; Segment type: Pure code
.text$mn:0000A0FC ; Segment permissions: Read/Execute
.text$mn:0000A0FC _text$mn        segment para public 'CODE' use32
.text$mn:0000A0FC                 assume cs:_text$mn
.text$mn:0000A0FC                 ;org 0A0FCh
.text$mn:0000A0FC ; COMDAT (pick any)
.text$mn:0000A0FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A0FC
.text$mn:0000A0FC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A0FC
.text$mn:0000A0FC ; Attributes: bp-based frame
.text$mn:0000A0FC
.text$mn:0000A0FC ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:0000A0FC                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000A0FC ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000A0FC                                         ; DATA XREF: .rdata:0000C404o
.text$mn:0000A0FC                                         ; .rdata:0000C420o ...
.text$mn:0000A0FC
.text$mn:0000A0FC var_4           = dword ptr -4
.text$mn:0000A0FC arg_0           = dword ptr  8
.text$mn:0000A0FC arg_4           = dword ptr  0Ch
.text$mn:0000A0FC
.text$mn:0000A0FC                 push    ebp
.text$mn:0000A0FD                 mov     ebp, esp
.text$mn:0000A0FF                 push    ecx
.text$mn:0000A100                 mov     [ebp+var_4], ecx
.text$mn:0000A103                 mov     eax, [ebp+var_4]
.text$mn:0000A106                 push    eax             ; struct std::error_category *
.text$mn:0000A107                 mov     ecx, [ebp+arg_4]
.text$mn:0000A10A                 push    ecx             ; int
.text$mn:0000A10B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000A10E                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000A113                 mov     eax, [ebp+arg_0]
.text$mn:0000A116                 mov     esp, ebp
.text$mn:0000A118                 pop     ebp
.text$mn:0000A119                 retn    8
.text$mn:0000A119 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000A119
.text$mn:0000A119 _text$mn        ends
.text$mn:0000A119
.text$mn:0000A11C ; ===========================================================================
.text$mn:0000A11C
.text$mn:0000A11C ; Segment type: Pure code
.text$mn:0000A11C ; Segment permissions: Read/Execute
.text$mn:0000A11C _text$mn        segment para public 'CODE' use32
.text$mn:0000A11C                 assume cs:_text$mn
.text$mn:0000A11C                 ;org 0A11Ch
.text$mn:0000A11C ; COMDAT (pick any)
.text$mn:0000A11C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A11C
.text$mn:0000A11C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A11C
.text$mn:0000A11C ; Attributes: bp-based frame
.text$mn:0000A11C
.text$mn:0000A11C ; void __thiscall ContextMenu::display(ContextMenu *this, const struct tagPOINT *)
.text$mn:0000A11C                 public ?display@ContextMenu@@QBEXABUtagPOINT@@@Z
.text$mn:0000A11C ?display@ContextMenu@@QBEXABUtagPOINT@@@Z proc near
.text$mn:0000A11C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+7B3p
.text$mn:0000A11C                                         ; Notepad_plus::notify(SCNotification *)+144Cp ...
.text$mn:0000A11C
.text$mn:0000A11C var_4           = dword ptr -4
.text$mn:0000A11C arg_0           = dword ptr  8
.text$mn:0000A11C
.text$mn:0000A11C                 push    ebp
.text$mn:0000A11D                 mov     ebp, esp
.text$mn:0000A11F                 push    ecx
.text$mn:0000A120                 mov     [ebp+var_4], ecx
.text$mn:0000A123                 push    0               ; prcRect
.text$mn:0000A125                 mov     eax, [ebp+var_4]
.text$mn:0000A128                 mov     ecx, [eax]
.text$mn:0000A12A                 push    ecx             ; hWnd
.text$mn:0000A12B                 push    0               ; nReserved
.text$mn:0000A12D                 mov     edx, [ebp+arg_0]
.text$mn:0000A130                 mov     eax, [edx+4]
.text$mn:0000A133                 push    eax             ; y
.text$mn:0000A134                 mov     ecx, [ebp+arg_0]
.text$mn:0000A137                 mov     edx, [ecx]
.text$mn:0000A139                 push    edx             ; x
.text$mn:0000A13A                 push    0               ; uFlags
.text$mn:0000A13C                 mov     eax, [ebp+var_4]
.text$mn:0000A13F                 mov     ecx, [eax+4]
.text$mn:0000A142                 push    ecx             ; hMenu
.text$mn:0000A143                 call    dword ptr ds:__imp__TrackPopupMenu@28 ; TrackPopupMenu(x,x,x,x,x,x,x)
.text$mn:0000A149                 mov     esp, ebp
.text$mn:0000A14B                 pop     ebp
.text$mn:0000A14C                 retn    4
.text$mn:0000A14C ?display@ContextMenu@@QBEXABUtagPOINT@@@Z endp
.text$mn:0000A14C
.text$mn:0000A14C ; ---------------------------------------------------------------------------
.text$mn:0000A14F                 align 10h
.text$mn:0000A14F _text$mn        ends
.text$mn:0000A14F
.text$mn:0000A150 ; ===========================================================================
.text$mn:0000A150
.text$mn:0000A150 ; Segment type: Pure code
.text$mn:0000A150 ; Segment permissions: Read/Execute
.text$mn:0000A150 _text$mn        segment para public 'CODE' use32
.text$mn:0000A150                 assume cs:_text$mn
.text$mn:0000A150                 ;org 0A150h
.text$mn:0000A150 ; COMDAT (pick any)
.text$mn:0000A150                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A150
.text$mn:0000A150 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A150
.text$mn:0000A150 ; Attributes: bp-based frame
.text$mn:0000A150
.text$mn:0000A150 ; void __thiscall GoToLineDlg::doDialog(GoToLineDlg *this, bool)
.text$mn:0000A150                 public ?doDialog@GoToLineDlg@@QAEX_N@Z
.text$mn:0000A150 ?doDialog@GoToLineDlg@@QAEX_N@Z proc near
.text$mn:0000A150                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+F72p
.text$mn:0000A150
.text$mn:0000A150 var_4           = dword ptr -4
.text$mn:0000A150 arg_0           = byte ptr  8
.text$mn:0000A150
.text$mn:0000A150                 push    ebp
.text$mn:0000A151                 mov     ebp, esp
.text$mn:0000A153                 push    ecx
.text$mn:0000A154                 mov     [ebp+var_4], ecx
.text$mn:0000A157                 mov     eax, [ebp+var_4]
.text$mn:0000A15A                 mov     edx, [eax]
.text$mn:0000A15C                 mov     ecx, [ebp+var_4]
.text$mn:0000A15F                 mov     eax, [edx+34h]
.text$mn:0000A162                 call    eax
.text$mn:0000A164                 movzx   ecx, al
.text$mn:0000A167                 test    ecx, ecx
.text$mn:0000A169                 jnz     short loc_A182
.text$mn:0000A16B                 movzx   edx, [ebp+arg_0]
.text$mn:0000A16F                 push    edx
.text$mn:0000A170                 push    7D0h
.text$mn:0000A175                 mov     eax, [ebp+var_4]
.text$mn:0000A178                 mov     edx, [eax]
.text$mn:0000A17A                 mov     ecx, [ebp+var_4]
.text$mn:0000A17D                 mov     eax, [edx+3Ch]
.text$mn:0000A180                 call    eax
.text$mn:0000A182
.text$mn:0000A182 loc_A182:                               ; CODE XREF: GoToLineDlg::doDialog(bool)+19j
.text$mn:0000A182                 push    1
.text$mn:0000A184                 mov     ecx, [ebp+var_4]
.text$mn:0000A187                 mov     edx, [ecx]
.text$mn:0000A189                 mov     ecx, [ebp+var_4]
.text$mn:0000A18C                 mov     eax, [edx+0Ch]
.text$mn:0000A18F                 call    eax
.text$mn:0000A191                 mov     esp, ebp
.text$mn:0000A193                 pop     ebp
.text$mn:0000A194                 retn    4
.text$mn:0000A194 ?doDialog@GoToLineDlg@@QAEX_N@Z endp
.text$mn:0000A194
.text$mn:0000A194 ; ---------------------------------------------------------------------------
.text$mn:0000A197                 align 4
.text$mn:0000A197 _text$mn        ends
.text$mn:0000A197
.text$mn:0000A198 ; ===========================================================================
.text$mn:0000A198
.text$mn:0000A198 ; Segment type: Pure code
.text$mn:0000A198 ; Segment permissions: Read/Execute
.text$mn:0000A198 _text$mn        segment para public 'CODE' use32
.text$mn:0000A198                 assume cs:_text$mn
.text$mn:0000A198                 ;org 0A198h
.text$mn:0000A198 ; COMDAT (pick any)
.text$mn:0000A198                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A198
.text$mn:0000A198 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A198
.text$mn:0000A198 ; Attributes: bp-based frame
.text$mn:0000A198
.text$mn:0000A198 ; void __thiscall Buffer::doNotify(Buffer *this, int)
.text$mn:0000A198                 public ?doNotify@Buffer@@AAEXH@Z
.text$mn:0000A198 ?doNotify@Buffer@@AAEXH@Z proc near     ; CODE XREF: Buffer::setDirty(bool)+15p
.text$mn:0000A198
.text$mn:0000A198 var_4           = dword ptr -4
.text$mn:0000A198 arg_0           = dword ptr  8
.text$mn:0000A198
.text$mn:0000A198                 push    ebp
.text$mn:0000A199                 mov     ebp, esp
.text$mn:0000A19B                 push    ecx
.text$mn:0000A19C                 mov     [ebp+var_4], ecx
.text$mn:0000A19F                 mov     eax, [ebp+var_4]
.text$mn:0000A1A2                 movzx   ecx, byte ptr [eax+4]
.text$mn:0000A1A6                 test    ecx, ecx
.text$mn:0000A1A8                 jz      short loc_A1BC
.text$mn:0000A1AA                 mov     edx, [ebp+arg_0]
.text$mn:0000A1AD                 push    edx             ; int
.text$mn:0000A1AE                 mov     eax, [ebp+var_4]
.text$mn:0000A1B1                 push    eax             ; struct Buffer *
.text$mn:0000A1B2                 mov     ecx, [ebp+var_4]
.text$mn:0000A1B5                 mov     ecx, [ecx]      ; this
.text$mn:0000A1B7                 call    ?beNotifiedOfBufferChange@FileManager@@QAEXPAVBuffer@@H@Z ; FileManager::beNotifiedOfBufferChange(Buffer *,int)
.text$mn:0000A1BC
.text$mn:0000A1BC loc_A1BC:                               ; CODE XREF: Buffer::doNotify(int)+10j
.text$mn:0000A1BC                 mov     esp, ebp
.text$mn:0000A1BE                 pop     ebp
.text$mn:0000A1BF                 retn    4
.text$mn:0000A1BF ?doNotify@Buffer@@AAEXH@Z endp
.text$mn:0000A1BF
.text$mn:0000A1BF ; ---------------------------------------------------------------------------
.text$mn:0000A1C2                 align 4
.text$mn:0000A1C2 _text$mn        ends
.text$mn:0000A1C2
.text$mn:0000A1C4 ; ===========================================================================
.text$mn:0000A1C4
.text$mn:0000A1C4 ; Segment type: Pure code
.text$mn:0000A1C4 ; Segment permissions: Read/Execute
.text$mn:0000A1C4 _text$mn        segment para public 'CODE' use32
.text$mn:0000A1C4                 assume cs:_text$mn
.text$mn:0000A1C4                 ;org 0A1C4h
.text$mn:0000A1C4 ; COMDAT (pick any)
.text$mn:0000A1C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A1C4
.text$mn:0000A1C4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A1C4
.text$mn:0000A1C4 ; Attributes: bp-based frame
.text$mn:0000A1C4
.text$mn:0000A1C4 ; bool __thiscall Notepad_plus::SyncInfo::doSync(Notepad_plus::SyncInfo *__hidden this)
.text$mn:0000A1C4                 public ?doSync@SyncInfo@Notepad_plus@@QBE_NXZ
.text$mn:0000A1C4 ?doSync@SyncInfo@Notepad_plus@@QBE_NXZ proc near
.text$mn:0000A1C4                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2DF2p
.text$mn:0000A1C4
.text$mn:0000A1C4 var_8           = dword ptr -8
.text$mn:0000A1C4 var_4           = dword ptr -4
.text$mn:0000A1C4
.text$mn:0000A1C4                 push    ebp
.text$mn:0000A1C5                 mov     ebp, esp
.text$mn:0000A1C7                 sub     esp, 8
.text$mn:0000A1CA                 mov     [ebp+var_4], ecx
.text$mn:0000A1CD                 mov     eax, [ebp+var_4]
.text$mn:0000A1D0                 movzx   ecx, byte ptr [eax+8]
.text$mn:0000A1D4                 test    ecx, ecx
.text$mn:0000A1D6                 jnz     short loc_A1EC
.text$mn:0000A1D8                 mov     edx, [ebp+var_4]
.text$mn:0000A1DB                 movzx   eax, byte ptr [edx+9]
.text$mn:0000A1DF                 test    eax, eax
.text$mn:0000A1E1                 jnz     short loc_A1EC
.text$mn:0000A1E3                 mov     [ebp+var_8], 0
.text$mn:0000A1EA                 jmp     short loc_A1F3
.text$mn:0000A1EC ; ---------------------------------------------------------------------------
.text$mn:0000A1EC
.text$mn:0000A1EC loc_A1EC:                               ; CODE XREF: Notepad_plus::SyncInfo::doSync(void)+12j
.text$mn:0000A1EC                                         ; Notepad_plus::SyncInfo::doSync(void)+1Dj
.text$mn:0000A1EC                 mov     [ebp+var_8], 1
.text$mn:0000A1F3
.text$mn:0000A1F3 loc_A1F3:                               ; CODE XREF: Notepad_plus::SyncInfo::doSync(void)+26j
.text$mn:0000A1F3                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000A1F6                 mov     esp, ebp
.text$mn:0000A1F8                 pop     ebp
.text$mn:0000A1F9                 retn
.text$mn:0000A1F9 ?doSync@SyncInfo@Notepad_plus@@QBE_NXZ endp
.text$mn:0000A1F9
.text$mn:0000A1F9 ; ---------------------------------------------------------------------------
.text$mn:0000A1FA                 align 4
.text$mn:0000A1FA _text$mn        ends
.text$mn:0000A1FA
.text$mn:0000A1FC ; ===========================================================================
.text$mn:0000A1FC
.text$mn:0000A1FC ; Segment type: Pure code
.text$mn:0000A1FC ; Segment permissions: Read/Execute
.text$mn:0000A1FC _text$mn        segment para public 'CODE' use32
.text$mn:0000A1FC                 assume cs:_text$mn
.text$mn:0000A1FC                 ;org 0A1FCh
.text$mn:0000A1FC ; COMDAT (pick any)
.text$mn:0000A1FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A1FC
.text$mn:0000A1FC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A1FC
.text$mn:0000A1FC ; Attributes: bp-based frame
.text$mn:0000A1FC
.text$mn:0000A1FC ; public: bool __thiscall std::deque<unsigned int, class std::allocator<unsigned int>>::empty(void)const
.text$mn:0000A1FC                 public ?empty@?$deque@IV?$allocator@I@std@@@std@@QBE_NXZ
.text$mn:0000A1FC ?empty@?$deque@IV?$allocator@I@std@@@std@@QBE_NXZ proc near
.text$mn:0000A1FC                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Tidy(void)+21p
.text$mn:0000A1FC                                         ; std::stack<uint,std::deque<uint,std::allocator<uint>>>::empty(void)+Ap ...
.text$mn:0000A1FC
.text$mn:0000A1FC var_8           = dword ptr -8
.text$mn:0000A1FC var_4           = dword ptr -4
.text$mn:0000A1FC
.text$mn:0000A1FC                 push    ebp
.text$mn:0000A1FD                 mov     ebp, esp
.text$mn:0000A1FF                 sub     esp, 8
.text$mn:0000A202                 mov     [ebp+var_8], ecx
.text$mn:0000A205                 mov     eax, [ebp+var_8]
.text$mn:0000A208                 cmp     dword ptr [eax+10h], 0
.text$mn:0000A20C                 jnz     short loc_A217
.text$mn:0000A20E                 mov     [ebp+var_4], 1
.text$mn:0000A215                 jmp     short loc_A21E
.text$mn:0000A217 ; ---------------------------------------------------------------------------
.text$mn:0000A217
.text$mn:0000A217 loc_A217:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::empty(void)+10j
.text$mn:0000A217                 mov     [ebp+var_4], 0
.text$mn:0000A21E
.text$mn:0000A21E loc_A21E:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::empty(void)+19j
.text$mn:0000A21E                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000A221                 mov     esp, ebp
.text$mn:0000A223                 pop     ebp
.text$mn:0000A224                 retn
.text$mn:0000A224 ?empty@?$deque@IV?$allocator@I@std@@@std@@QBE_NXZ endp
.text$mn:0000A224
.text$mn:0000A224 ; ---------------------------------------------------------------------------
.text$mn:0000A225                 align 4
.text$mn:0000A225 _text$mn        ends
.text$mn:0000A225
.text$mn:0000A228 ; ===========================================================================
.text$mn:0000A228
.text$mn:0000A228 ; Segment type: Pure code
.text$mn:0000A228 ; Segment permissions: Read/Execute
.text$mn:0000A228 _text$mn        segment para public 'CODE' use32
.text$mn:0000A228                 assume cs:_text$mn
.text$mn:0000A228                 ;org 0A228h
.text$mn:0000A228 ; COMDAT (pick any)
.text$mn:0000A228                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A228
.text$mn:0000A228 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A228
.text$mn:0000A228 ; Attributes: bp-based frame
.text$mn:0000A228
.text$mn:0000A228 ; public: bool __thiscall std::stack<unsigned int, class std::deque<unsigned int, class std::allocator<unsigned int>>>::empty(void)const
.text$mn:0000A228                 public ?empty@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QBE_NXZ
.text$mn:0000A228 ?empty@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QBE_NXZ proc near
.text$mn:0000A228                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+25BEp
.text$mn:0000A228
.text$mn:0000A228 var_4           = dword ptr -4
.text$mn:0000A228
.text$mn:0000A228                 push    ebp
.text$mn:0000A229                 mov     ebp, esp
.text$mn:0000A22B                 push    ecx
.text$mn:0000A22C                 mov     [ebp+var_4], ecx
.text$mn:0000A22F                 mov     ecx, [ebp+var_4]
.text$mn:0000A232                 call    ?empty@?$deque@IV?$allocator@I@std@@@std@@QBE_NXZ ; std::deque<uint,std::allocator<uint>>::empty(void)
.text$mn:0000A237                 mov     esp, ebp
.text$mn:0000A239                 pop     ebp
.text$mn:0000A23A                 retn
.text$mn:0000A23A ?empty@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QBE_NXZ endp
.text$mn:0000A23A
.text$mn:0000A23A ; ---------------------------------------------------------------------------
.text$mn:0000A23B                 align 4
.text$mn:0000A23B _text$mn        ends
.text$mn:0000A23B
.text$mn:0000A23C ; ===========================================================================
.text$mn:0000A23C
.text$mn:0000A23C ; Segment type: Pure code
.text$mn:0000A23C ; Segment permissions: Read/Execute
.text$mn:0000A23C _text$mn        segment para public 'CODE' use32
.text$mn:0000A23C                 assume cs:_text$mn
.text$mn:0000A23C                 ;org 0A23Ch
.text$mn:0000A23C ; COMDAT (pick any)
.text$mn:0000A23C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A23C
.text$mn:0000A23C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A23C
.text$mn:0000A23C ; Attributes: bp-based frame
.text$mn:0000A23C
.text$mn:0000A23C ; void __thiscall ContextMenu::enableItem(ContextMenu *this, UINT uIDEnableItem, bool)
.text$mn:0000A23C                 public ?enableItem@ContextMenu@@QBEXH_N@Z
.text$mn:0000A23C ?enableItem@ContextMenu@@QBEXH_N@Z proc near
.text$mn:0000A23C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+1CD3p
.text$mn:0000A23C                                         ; Notepad_plus::notify(SCNotification *)+1D63p ...
.text$mn:0000A23C
.text$mn:0000A23C var_C           = dword ptr -0Ch
.text$mn:0000A23C uEnable         = dword ptr -8
.text$mn:0000A23C var_4           = dword ptr -4
.text$mn:0000A23C uIDEnableItem   = dword ptr  8
.text$mn:0000A23C arg_4           = byte ptr  0Ch
.text$mn:0000A23C
.text$mn:0000A23C                 push    ebp
.text$mn:0000A23D                 mov     ebp, esp
.text$mn:0000A23F                 sub     esp, 0Ch
.text$mn:0000A242                 mov     [ebp+var_C], ecx
.text$mn:0000A245                 movzx   eax, [ebp+arg_4]
.text$mn:0000A249                 test    eax, eax
.text$mn:0000A24B                 jz      short loc_A256
.text$mn:0000A24D                 mov     [ebp+var_4], 0
.text$mn:0000A254                 jmp     short loc_A25D
.text$mn:0000A256 ; ---------------------------------------------------------------------------
.text$mn:0000A256
.text$mn:0000A256 loc_A256:                               ; CODE XREF: ContextMenu::enableItem(int,bool)+Fj
.text$mn:0000A256                 mov     [ebp+var_4], 3
.text$mn:0000A25D
.text$mn:0000A25D loc_A25D:                               ; CODE XREF: ContextMenu::enableItem(int,bool)+18j
.text$mn:0000A25D                 mov     ecx, [ebp+var_4]
.text$mn:0000A260                 mov     [ebp+uEnable], ecx
.text$mn:0000A263                 mov     edx, [ebp+uEnable]
.text$mn:0000A266                 push    edx             ; uEnable
.text$mn:0000A267                 mov     eax, [ebp+uIDEnableItem]
.text$mn:0000A26A                 push    eax             ; uIDEnableItem
.text$mn:0000A26B                 mov     ecx, [ebp+var_C]
.text$mn:0000A26E                 mov     edx, [ecx+4]
.text$mn:0000A271                 push    edx             ; hMenu
.text$mn:0000A272                 call    dword ptr ds:__imp__EnableMenuItem@12 ; EnableMenuItem(x,x,x)
.text$mn:0000A278                 mov     esp, ebp
.text$mn:0000A27A                 pop     ebp
.text$mn:0000A27B                 retn    8
.text$mn:0000A27B ?enableItem@ContextMenu@@QBEXH_N@Z endp
.text$mn:0000A27B
.text$mn:0000A27B ; ---------------------------------------------------------------------------
.text$mn:0000A27E                 align 10h
.text$mn:0000A27E _text$mn        ends
.text$mn:0000A27E
.text$mn:0000A280 ; ===========================================================================
.text$mn:0000A280
.text$mn:0000A280 ; Segment type: Pure code
.text$mn:0000A280 ; Segment permissions: Read/Execute
.text$mn:0000A280 _text$mn        segment para public 'CODE' use32
.text$mn:0000A280                 assume cs:_text$mn
.text$mn:0000A280                 ;org 0A280h
.text$mn:0000A280 ; COMDAT (pick any)
.text$mn:0000A280                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A280
.text$mn:0000A280 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A280
.text$mn:0000A280 ; Attributes: bp-based frame
.text$mn:0000A280
.text$mn:0000A280 ; public: class std::_Deque_iterator<class std::_Deque_val<struct std::_Deque_simple_types<unsigned int>>> __thiscall std::deque<unsigned int, class std::allocator<unsigned int>>::end(void)
.text$mn:0000A280                 public ?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ
.text$mn:0000A280 ?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ proc near
.text$mn:0000A280                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::back(void)+35p
.text$mn:0000A280
.text$mn:0000A280 var_14          = dword ptr -14h
.text$mn:0000A280 var_10          = dword ptr -10h
.text$mn:0000A280 var_C           = dword ptr -0Ch
.text$mn:0000A280 var_4           = dword ptr -4
.text$mn:0000A280 arg_0           = dword ptr  8
.text$mn:0000A280
.text$mn:0000A280                 push    ebp
.text$mn:0000A281                 mov     ebp, esp
.text$mn:0000A283                 push    0FFFFFFFFh
.text$mn:0000A285                 push    offset __ehhandler$?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ
.text$mn:0000A28A                 mov     eax, large fs:0
.text$mn:0000A290                 push    eax
.text$mn:0000A291                 sub     esp, 8
.text$mn:0000A294                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000A299                 xor     eax, ebp
.text$mn:0000A29B                 push    eax
.text$mn:0000A29C                 lea     eax, [ebp+var_C]
.text$mn:0000A29F                 mov     large fs:0, eax
.text$mn:0000A2A5                 mov     [ebp+var_10], ecx
.text$mn:0000A2A8                 mov     [ebp+var_14], 0
.text$mn:0000A2AF                 mov     eax, [ebp+var_10]
.text$mn:0000A2B2                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000A2B3                 mov     ecx, [ebp+var_10]
.text$mn:0000A2B6                 mov     edx, [ecx+0Ch]
.text$mn:0000A2B9                 mov     eax, [ebp+var_10]
.text$mn:0000A2BC                 add     edx, [eax+10h]
.text$mn:0000A2BF                 push    edx             ; int
.text$mn:0000A2C0                 mov     ecx, [ebp+arg_0]
.text$mn:0000A2C3                 call    ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(uint,std::_Container_base12 const *)
.text$mn:0000A2C8                 mov     [ebp+var_4], 0
.text$mn:0000A2CF                 mov     ecx, [ebp+var_14]
.text$mn:0000A2D2                 or      ecx, 1
.text$mn:0000A2D5                 mov     [ebp+var_14], ecx
.text$mn:0000A2D8                 mov     eax, [ebp+arg_0]
.text$mn:0000A2DB                 mov     ecx, [ebp+var_C]
.text$mn:0000A2DE                 mov     large fs:0, ecx
.text$mn:0000A2E5                 pop     ecx
.text$mn:0000A2E6                 mov     esp, ebp
.text$mn:0000A2E8                 pop     ebp
.text$mn:0000A2E9                 retn    4
.text$mn:0000A2E9 ?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ endp
.text$mn:0000A2E9
.text$mn:0000A2E9 _text$mn        ends
.text$mn:0000A2E9
.text$x:0000A2EC ; ===========================================================================
.text$x:0000A2EC
.text$x:0000A2EC ; Segment type: Pure code
.text$x:0000A2EC ; Segment permissions: Read/Execute
.text$x:0000A2EC _text$x         segment para public 'CODE' use32
.text$x:0000A2EC                 assume cs:_text$x
.text$x:0000A2EC                 ;org 0A2ECh
.text$x:0000A2EC ; COMDAT (pick associative to section at A280)
.text$x:0000A2EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000A2EC
.text$x:0000A2EC ; =============== S U B R O U T I N E =======================================
.text$x:0000A2EC
.text$x:0000A2EC
.text$x:0000A2EC __unwindfunclet$?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ$0 proc near
.text$x:0000A2EC                                         ; DATA XREF: .xdata$x:0000BF88o
.text$x:0000A2EC                 mov     eax, [ebp-14h]
.text$x:0000A2EF                 and     eax, 1
.text$x:0000A2F2                 jz      $LN4
.text$x:0000A2F8                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000A2FC                 mov     ecx, [ebp+8]
.text$x:0000A2FF                 jmp     ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>(void)
.text$x:0000A304 ; ---------------------------------------------------------------------------
.text$x:0000A304
.text$x:0000A304 $LN4:                                   ; CODE XREF: __unwindfunclet$?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ$0+6j
.text$x:0000A304                 retn
.text$x:0000A304 __unwindfunclet$?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ$0 endp
.text$x:0000A304
.text$x:0000A305
.text$x:0000A305 ; =============== S U B R O U T I N E =======================================
.text$x:0000A305
.text$x:0000A305
.text$x:0000A305 __ehhandler$?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ proc near
.text$x:0000A305                                         ; DATA XREF: std::deque<uint,std::allocator<uint>>::end(void)+5o
.text$x:0000A305
.text$x:0000A305 arg_4           = dword ptr  8
.text$x:0000A305
.text$x:0000A305                 mov     edx, [esp+arg_4]
.text$x:0000A309                 lea     eax, [edx+0Ch]
.text$x:0000A30C                 mov     ecx, [edx-0Ch]
.text$x:0000A30F                 xor     ecx, eax
.text$x:0000A311                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000A316                 mov     eax, offset __ehfuncinfo$?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ
.text$x:0000A31B                 jmp     ___CxxFrameHandler3
.text$x:0000A31B __ehhandler$?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ endp
.text$x:0000A31B
.text$x:0000A31B _text$x         ends
.text$x:0000A31B
.text$mn:0000A320 ; ===========================================================================
.text$mn:0000A320
.text$mn:0000A320 ; Segment type: Pure code
.text$mn:0000A320 ; Segment permissions: Read/Execute
.text$mn:0000A320 _text$mn        segment para public 'CODE' use32
.text$mn:0000A320                 assume cs:_text$mn
.text$mn:0000A320                 ;org 0A320h
.text$mn:0000A320 ; COMDAT (pick any)
.text$mn:0000A320                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A320
.text$mn:0000A320 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A320
.text$mn:0000A320 ; Attributes: bp-based frame
.text$mn:0000A320
.text$mn:0000A320 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:0000A320                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:0000A320 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:0000A320                                         ; DATA XREF: .rdata:0000C408o
.text$mn:0000A320                                         ; .rdata:0000C424o ...
.text$mn:0000A320
.text$mn:0000A320 var_8           = dword ptr -8
.text$mn:0000A320 var_4           = dword ptr -4
.text$mn:0000A320 arg_0           = dword ptr  8
.text$mn:0000A320 arg_4           = dword ptr  0Ch
.text$mn:0000A320
.text$mn:0000A320                 push    ebp
.text$mn:0000A321                 mov     ebp, esp
.text$mn:0000A323                 sub     esp, 8
.text$mn:0000A326                 mov     [ebp+var_8], ecx
.text$mn:0000A329                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000A32C                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:0000A331                 push    eax
.text$mn:0000A332                 mov     ecx, [ebp+var_8]
.text$mn:0000A335                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000A33A                 movzx   eax, al
.text$mn:0000A33D                 test    eax, eax
.text$mn:0000A33F                 jz      short loc_A357
.text$mn:0000A341                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000A344                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:0000A349                 cmp     eax, [ebp+arg_4]
.text$mn:0000A34C                 jnz     short loc_A357
.text$mn:0000A34E                 mov     [ebp+var_4], 1
.text$mn:0000A355                 jmp     short loc_A35E
.text$mn:0000A357 ; ---------------------------------------------------------------------------
.text$mn:0000A357
.text$mn:0000A357 loc_A357:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000A357                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000A357                 mov     [ebp+var_4], 0
.text$mn:0000A35E
.text$mn:0000A35E loc_A35E:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:0000A35E                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000A361                 mov     esp, ebp
.text$mn:0000A363                 pop     ebp
.text$mn:0000A364                 retn    8
.text$mn:0000A364 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:0000A364
.text$mn:0000A364 ; ---------------------------------------------------------------------------
.text$mn:0000A367                 align 4
.text$mn:0000A367 _text$mn        ends
.text$mn:0000A367
.text$mn:0000A368 ; ===========================================================================
.text$mn:0000A368
.text$mn:0000A368 ; Segment type: Pure code
.text$mn:0000A368 ; Segment permissions: Read/Execute
.text$mn:0000A368 _text$mn        segment para public 'CODE' use32
.text$mn:0000A368                 assume cs:_text$mn
.text$mn:0000A368                 ;org 0A368h
.text$mn:0000A368 ; COMDAT (pick any)
.text$mn:0000A368                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A368
.text$mn:0000A368 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A368
.text$mn:0000A368 ; Attributes: bp-based frame
.text$mn:0000A368
.text$mn:0000A368 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:0000A368                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:0000A368 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:0000A368                                         ; DATA XREF: .rdata:0000C40Co
.text$mn:0000A368                                         ; .rdata:0000C428o ...
.text$mn:0000A368
.text$mn:0000A368 var_C           = byte ptr -0Ch
.text$mn:0000A368 var_4           = dword ptr -4
.text$mn:0000A368 arg_0           = dword ptr  8
.text$mn:0000A368 arg_4           = dword ptr  0Ch
.text$mn:0000A368
.text$mn:0000A368                 push    ebp
.text$mn:0000A369                 mov     ebp, esp
.text$mn:0000A36B                 sub     esp, 0Ch
.text$mn:0000A36E                 mov     [ebp+var_4], ecx
.text$mn:0000A371                 mov     eax, [ebp+arg_4]
.text$mn:0000A374                 push    eax             ; std::error_condition *
.text$mn:0000A375                 mov     ecx, [ebp+arg_0]
.text$mn:0000A378                 push    ecx
.text$mn:0000A379                 lea     edx, [ebp+var_C]
.text$mn:0000A37C                 push    edx
.text$mn:0000A37D                 mov     eax, [ebp+var_4]
.text$mn:0000A380                 mov     edx, [eax]
.text$mn:0000A382                 mov     ecx, [ebp+var_4]
.text$mn:0000A385                 mov     eax, [edx+0Ch]
.text$mn:0000A388                 call    eax
.text$mn:0000A38A                 mov     ecx, eax
.text$mn:0000A38C                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:0000A391                 mov     esp, ebp
.text$mn:0000A393                 pop     ebp
.text$mn:0000A394                 retn    8
.text$mn:0000A394 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:0000A394
.text$mn:0000A394 ; ---------------------------------------------------------------------------
.text$mn:0000A397                 align 4
.text$mn:0000A397 _text$mn        ends
.text$mn:0000A397
.text$mn:0000A398 ; ===========================================================================
.text$mn:0000A398
.text$mn:0000A398 ; Segment type: Pure code
.text$mn:0000A398 ; Segment permissions: Read/Execute
.text$mn:0000A398 _text$mn        segment para public 'CODE' use32
.text$mn:0000A398                 assume cs:_text$mn
.text$mn:0000A398                 ;org 0A398h
.text$mn:0000A398 ; COMDAT (pick any)
.text$mn:0000A398                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A398
.text$mn:0000A398 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A398
.text$mn:0000A398 ; Attributes: bp-based frame
.text$mn:0000A398
.text$mn:0000A398 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:0000A398                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:0000A398 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000A398                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:0000A398
.text$mn:0000A398 var_4           = dword ptr -4
.text$mn:0000A398 arg_0           = dword ptr  8
.text$mn:0000A398
.text$mn:0000A398                 push    ebp
.text$mn:0000A399                 mov     ebp, esp
.text$mn:0000A39B                 push    ecx
.text$mn:0000A39C                 mov     [ebp+var_4], ecx
.text$mn:0000A39F                 mov     eax, [ebp+var_4]
.text$mn:0000A3A2                 mov     ecx, [eax+14h]
.text$mn:0000A3A5                 cmp     ecx, [ebp+arg_0]
.text$mn:0000A3A8                 jnb     short loc_A3B2
.text$mn:0000A3AA                 mov     ecx, [ebp+var_4]
.text$mn:0000A3AD                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000A3B2
.text$mn:0000A3B2 loc_A3B2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:0000A3B2                 mov     edx, [ebp+arg_0]
.text$mn:0000A3B5                 push    edx
.text$mn:0000A3B6                 mov     ecx, [ebp+var_4]
.text$mn:0000A3B9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000A3BE                 mov     eax, [ebp+var_4]
.text$mn:0000A3C1                 mov     esp, ebp
.text$mn:0000A3C3                 pop     ebp
.text$mn:0000A3C4                 retn    4
.text$mn:0000A3C4 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:0000A3C4
.text$mn:0000A3C4 ; ---------------------------------------------------------------------------
.text$mn:0000A3C7                 align 4
.text$mn:0000A3C7 _text$mn        ends
.text$mn:0000A3C7
.text$mn:0000A3C8 ; ===========================================================================
.text$mn:0000A3C8
.text$mn:0000A3C8 ; Segment type: Pure code
.text$mn:0000A3C8 ; Segment permissions: Read/Execute
.text$mn:0000A3C8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A3C8                 assume cs:_text$mn
.text$mn:0000A3C8                 ;org 0A3C8h
.text$mn:0000A3C8 ; COMDAT (pick any)
.text$mn:0000A3C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A3C8
.text$mn:0000A3C8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A3C8
.text$mn:0000A3C8 ; Attributes: bp-based frame
.text$mn:0000A3C8
.text$mn:0000A3C8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:0000A3C8                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:0000A3C8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000A3C8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:0000A3C8
.text$mn:0000A3C8 var_C           = dword ptr -0Ch
.text$mn:0000A3C8 Dst             = dword ptr -8
.text$mn:0000A3C8 var_4           = dword ptr -4
.text$mn:0000A3C8 arg_0           = dword ptr  8
.text$mn:0000A3C8 arg_4           = dword ptr  0Ch
.text$mn:0000A3C8
.text$mn:0000A3C8                 push    ebp
.text$mn:0000A3C9                 mov     ebp, esp
.text$mn:0000A3CB                 sub     esp, 0Ch
.text$mn:0000A3CE                 mov     [ebp+var_4], ecx
.text$mn:0000A3D1                 mov     eax, [ebp+var_4]
.text$mn:0000A3D4                 mov     ecx, [eax+14h]
.text$mn:0000A3D7                 cmp     ecx, [ebp+arg_0]
.text$mn:0000A3DA                 jnb     short loc_A3E4
.text$mn:0000A3DC                 mov     ecx, [ebp+var_4]
.text$mn:0000A3DF                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000A3E4
.text$mn:0000A3E4 loc_A3E4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:0000A3E4                 mov     edx, [ebp+var_4]
.text$mn:0000A3E7                 mov     eax, [edx+14h]
.text$mn:0000A3EA                 sub     eax, [ebp+arg_0]
.text$mn:0000A3ED                 cmp     eax, [ebp+arg_4]
.text$mn:0000A3F0                 ja      short loc_A400
.text$mn:0000A3F2                 mov     ecx, [ebp+arg_0]
.text$mn:0000A3F5                 push    ecx
.text$mn:0000A3F6                 mov     ecx, [ebp+var_4]
.text$mn:0000A3F9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000A3FE                 jmp     short loc_A446
.text$mn:0000A400 ; ---------------------------------------------------------------------------
.text$mn:0000A400
.text$mn:0000A400 loc_A400:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:0000A400                 cmp     [ebp+arg_4], 0
.text$mn:0000A404                 jbe     short loc_A446
.text$mn:0000A406                 mov     ecx, [ebp+var_4]
.text$mn:0000A409                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000A40E                 add     eax, [ebp+arg_0]
.text$mn:0000A411                 mov     [ebp+Dst], eax
.text$mn:0000A414                 mov     edx, [ebp+var_4]
.text$mn:0000A417                 mov     eax, [edx+14h]
.text$mn:0000A41A                 sub     eax, [ebp+arg_4]
.text$mn:0000A41D                 mov     [ebp+var_C], eax
.text$mn:0000A420                 mov     ecx, [ebp+var_C]
.text$mn:0000A423                 sub     ecx, [ebp+arg_0]
.text$mn:0000A426                 push    ecx             ; Size
.text$mn:0000A427                 mov     edx, [ebp+Dst]
.text$mn:0000A42A                 add     edx, [ebp+arg_4]
.text$mn:0000A42D                 push    edx             ; Src
.text$mn:0000A42E                 mov     eax, [ebp+Dst]
.text$mn:0000A431                 push    eax             ; Dst
.text$mn:0000A432                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000A437                 add     esp, 0Ch
.text$mn:0000A43A                 mov     ecx, [ebp+var_C]
.text$mn:0000A43D                 push    ecx
.text$mn:0000A43E                 mov     ecx, [ebp+var_4]
.text$mn:0000A441                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000A446
.text$mn:0000A446 loc_A446:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000A446                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000A446                 mov     eax, [ebp+var_4]
.text$mn:0000A449                 mov     esp, ebp
.text$mn:0000A44B                 pop     ebp
.text$mn:0000A44C                 retn    8
.text$mn:0000A44C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000A44C
.text$mn:0000A44C ; ---------------------------------------------------------------------------
.text$mn:0000A44F                 align 10h
.text$mn:0000A44F _text$mn        ends
.text$mn:0000A44F
.text$mn:0000A450 ; ===========================================================================
.text$mn:0000A450
.text$mn:0000A450 ; Segment type: Pure code
.text$mn:0000A450 ; Segment permissions: Read/Execute
.text$mn:0000A450 _text$mn        segment para public 'CODE' use32
.text$mn:0000A450                 assume cs:_text$mn
.text$mn:0000A450                 ;org 0A450h
.text$mn:0000A450 ; COMDAT (pick any)
.text$mn:0000A450                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A450
.text$mn:0000A450 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A450
.text$mn:0000A450 ; Attributes: bp-based frame
.text$mn:0000A450
.text$mn:0000A450 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:0000A450                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:0000A450 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000A450                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:0000A450
.text$mn:0000A450 var_4           = dword ptr -4
.text$mn:0000A450 arg_0           = dword ptr  8
.text$mn:0000A450
.text$mn:0000A450                 push    ebp
.text$mn:0000A451                 mov     ebp, esp
.text$mn:0000A453                 push    ecx
.text$mn:0000A454                 mov     [ebp+var_4], ecx
.text$mn:0000A457                 mov     eax, [ebp+var_4]
.text$mn:0000A45A                 mov     ecx, [eax+14h]
.text$mn:0000A45D                 cmp     ecx, [ebp+arg_0]
.text$mn:0000A460                 jnb     short loc_A46A
.text$mn:0000A462                 mov     ecx, [ebp+var_4]
.text$mn:0000A465                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000A46A
.text$mn:0000A46A loc_A46A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:0000A46A                 mov     edx, [ebp+arg_0]
.text$mn:0000A46D                 push    edx
.text$mn:0000A46E                 mov     ecx, [ebp+var_4]
.text$mn:0000A471                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000A476                 mov     eax, [ebp+var_4]
.text$mn:0000A479                 mov     esp, ebp
.text$mn:0000A47B                 pop     ebp
.text$mn:0000A47C                 retn    4
.text$mn:0000A47C ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:0000A47C
.text$mn:0000A47C ; ---------------------------------------------------------------------------
.text$mn:0000A47F                 align 10h
.text$mn:0000A47F _text$mn        ends
.text$mn:0000A47F
.text$mn:0000A480 ; ===========================================================================
.text$mn:0000A480
.text$mn:0000A480 ; Segment type: Pure code
.text$mn:0000A480 ; Segment permissions: Read/Execute
.text$mn:0000A480 _text$mn        segment para public 'CODE' use32
.text$mn:0000A480                 assume cs:_text$mn
.text$mn:0000A480                 ;org 0A480h
.text$mn:0000A480 ; COMDAT (pick any)
.text$mn:0000A480                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A480
.text$mn:0000A480 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A480
.text$mn:0000A480 ; Attributes: bp-based frame
.text$mn:0000A480
.text$mn:0000A480 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:0000A480                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:0000A480 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000A480                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:0000A480
.text$mn:0000A480 var_C           = dword ptr -0Ch
.text$mn:0000A480 Dst             = dword ptr -8
.text$mn:0000A480 var_4           = dword ptr -4
.text$mn:0000A480 arg_0           = dword ptr  8
.text$mn:0000A480 arg_4           = dword ptr  0Ch
.text$mn:0000A480
.text$mn:0000A480                 push    ebp
.text$mn:0000A481                 mov     ebp, esp
.text$mn:0000A483                 sub     esp, 0Ch
.text$mn:0000A486                 mov     [ebp+var_4], ecx
.text$mn:0000A489                 mov     eax, [ebp+var_4]
.text$mn:0000A48C                 mov     ecx, [eax+14h]
.text$mn:0000A48F                 cmp     ecx, [ebp+arg_0]
.text$mn:0000A492                 jnb     short loc_A49C
.text$mn:0000A494                 mov     ecx, [ebp+var_4]
.text$mn:0000A497                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000A49C
.text$mn:0000A49C loc_A49C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:0000A49C                 mov     edx, [ebp+var_4]
.text$mn:0000A49F                 mov     eax, [edx+14h]
.text$mn:0000A4A2                 sub     eax, [ebp+arg_0]
.text$mn:0000A4A5                 cmp     eax, [ebp+arg_4]
.text$mn:0000A4A8                 ja      short loc_A4B8
.text$mn:0000A4AA                 mov     ecx, [ebp+arg_0]
.text$mn:0000A4AD                 push    ecx
.text$mn:0000A4AE                 mov     ecx, [ebp+var_4]
.text$mn:0000A4B1                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000A4B6                 jmp     short loc_A504
.text$mn:0000A4B8 ; ---------------------------------------------------------------------------
.text$mn:0000A4B8
.text$mn:0000A4B8 loc_A4B8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:0000A4B8                 cmp     [ebp+arg_4], 0
.text$mn:0000A4BC                 jbe     short loc_A504
.text$mn:0000A4BE                 mov     ecx, [ebp+var_4]
.text$mn:0000A4C1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000A4C6                 mov     edx, [ebp+arg_0]
.text$mn:0000A4C9                 lea     eax, [eax+edx*2]
.text$mn:0000A4CC                 mov     [ebp+Dst], eax
.text$mn:0000A4CF                 mov     ecx, [ebp+var_4]
.text$mn:0000A4D2                 mov     edx, [ecx+14h]
.text$mn:0000A4D5                 sub     edx, [ebp+arg_4]
.text$mn:0000A4D8                 mov     [ebp+var_C], edx
.text$mn:0000A4DB                 mov     eax, [ebp+var_C]
.text$mn:0000A4DE                 sub     eax, [ebp+arg_0]
.text$mn:0000A4E1                 push    eax             ; int
.text$mn:0000A4E2                 mov     ecx, [ebp+arg_4]
.text$mn:0000A4E5                 mov     edx, [ebp+Dst]
.text$mn:0000A4E8                 lea     eax, [edx+ecx*2]
.text$mn:0000A4EB                 push    eax             ; Src
.text$mn:0000A4EC                 mov     ecx, [ebp+Dst]
.text$mn:0000A4EF                 push    ecx             ; Dst
.text$mn:0000A4F0                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000A4F5                 add     esp, 0Ch
.text$mn:0000A4F8                 mov     edx, [ebp+var_C]
.text$mn:0000A4FB                 push    edx
.text$mn:0000A4FC                 mov     ecx, [ebp+var_4]
.text$mn:0000A4FF                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000A504
.text$mn:0000A504 loc_A504:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:0000A504                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:0000A504                 mov     eax, [ebp+var_4]
.text$mn:0000A507                 mov     esp, ebp
.text$mn:0000A509                 pop     ebp
.text$mn:0000A50A                 retn    8
.text$mn:0000A50A ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000A50A
.text$mn:0000A50A ; ---------------------------------------------------------------------------
.text$mn:0000A50D                 align 10h
.text$mn:0000A50D _text$mn        ends
.text$mn:0000A50D
.text$mn:0000A510 ; ===========================================================================
.text$mn:0000A510
.text$mn:0000A510 ; Segment type: Pure code
.text$mn:0000A510 ; Segment permissions: Read/Execute
.text$mn:0000A510 _text$mn        segment para public 'CODE' use32
.text$mn:0000A510                 assume cs:_text$mn
.text$mn:0000A510                 ;org 0A510h
.text$mn:0000A510 ; COMDAT (pick any)
.text$mn:0000A510                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A510
.text$mn:0000A510 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A510
.text$mn:0000A510 ; Attributes: bp-based frame
.text$mn:0000A510
.text$mn:0000A510 ; __int32 __thiscall ScintillaEditView::execute(ScintillaEditView *this, unsigned int, unsigned int, __int32)
.text$mn:0000A510                 public ?execute@ScintillaEditView@@QBEJIIJ@Z
.text$mn:0000A510 ?execute@ScintillaEditView@@QBEJIIJ@Z proc near
.text$mn:0000A510                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+410p
.text$mn:0000A510                                         ; Notepad_plus::notify(SCNotification *)+457p ...
.text$mn:0000A510
.text$mn:0000A510 var_4           = dword ptr -4
.text$mn:0000A510 arg_0           = dword ptr  8
.text$mn:0000A510 arg_4           = dword ptr  0Ch
.text$mn:0000A510 arg_8           = dword ptr  10h
.text$mn:0000A510
.text$mn:0000A510                 push    ebp
.text$mn:0000A511                 mov     ebp, esp
.text$mn:0000A513                 push    ecx
.text$mn:0000A514                 mov     [ebp+var_4], ecx
.text$mn:0000A517                 mov     eax, [ebp+arg_8]
.text$mn:0000A51A                 push    eax
.text$mn:0000A51B                 mov     ecx, [ebp+arg_4]
.text$mn:0000A51E                 push    ecx
.text$mn:0000A51F                 mov     edx, [ebp+arg_0]
.text$mn:0000A522                 push    edx
.text$mn:0000A523                 mov     eax, [ebp+var_4]
.text$mn:0000A526                 mov     ecx, [eax+14h]
.text$mn:0000A529                 push    ecx
.text$mn:0000A52A                 mov     edx, [ebp+var_4]
.text$mn:0000A52D                 mov     eax, [edx+10h]
.text$mn:0000A530                 call    eax
.text$mn:0000A532                 add     esp, 10h
.text$mn:0000A535                 mov     esp, ebp
.text$mn:0000A537                 pop     ebp
.text$mn:0000A538                 retn    0Ch
.text$mn:0000A538 ?execute@ScintillaEditView@@QBEJIIJ@Z endp
.text$mn:0000A538
.text$mn:0000A538 ; ---------------------------------------------------------------------------
.text$mn:0000A53B                 align 4
.text$mn:0000A53B _text$mn        ends
.text$mn:0000A53B
.text$mn:0000A53C ; ===========================================================================
.text$mn:0000A53C
.text$mn:0000A53C ; Segment type: Pure code
.text$mn:0000A53C ; Segment permissions: Read/Execute
.text$mn:0000A53C _text$mn        segment para public 'CODE' use32
.text$mn:0000A53C                 assume cs:_text$mn
.text$mn:0000A53C                 ;org 0A53Ch
.text$mn:0000A53C ; COMDAT (pick any)
.text$mn:0000A53C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A53C
.text$mn:0000A53C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A53C
.text$mn:0000A53C ; Attributes: bp-based frame
.text$mn:0000A53C
.text$mn:0000A53C ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:0000A53C                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:0000A53C ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:0000A53C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:0000A53C                 push    ebp
.text$mn:0000A53D                 mov     ebp, esp
.text$mn:0000A53F                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:0000A544                 pop     ebp
.text$mn:0000A545                 retn
.text$mn:0000A545 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000A545
.text$mn:0000A545 ; ---------------------------------------------------------------------------
.text$mn:0000A546                 align 4
.text$mn:0000A546 _text$mn        ends
.text$mn:0000A546
.text$mn:0000A548 ; ===========================================================================
.text$mn:0000A548
.text$mn:0000A548 ; Segment type: Pure code
.text$mn:0000A548 ; Segment permissions: Read/Execute
.text$mn:0000A548 _text$mn        segment para public 'CODE' use32
.text$mn:0000A548                 assume cs:_text$mn
.text$mn:0000A548                 ;org 0A548h
.text$mn:0000A548 ; COMDAT (pick any)
.text$mn:0000A548                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A548
.text$mn:0000A548 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A548
.text$mn:0000A548 ; Attributes: bp-based frame
.text$mn:0000A548
.text$mn:0000A548 ; struct Buffer *__thiscall FileManager::getBufferByID(FileManager *this, struct Buffer *)
.text$mn:0000A548                 public ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z
.text$mn:0000A548 ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z proc near
.text$mn:0000A548                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+48Dp
.text$mn:0000A548                                         ; Notepad_plus::notify(SCNotification *)+9D5p ...
.text$mn:0000A548
.text$mn:0000A548 var_4           = dword ptr -4
.text$mn:0000A548 arg_0           = dword ptr  8
.text$mn:0000A548
.text$mn:0000A548                 push    ebp
.text$mn:0000A549                 mov     ebp, esp
.text$mn:0000A54B                 push    ecx
.text$mn:0000A54C                 mov     [ebp+var_4], ecx
.text$mn:0000A54F                 mov     eax, [ebp+arg_0]
.text$mn:0000A552                 mov     esp, ebp
.text$mn:0000A554                 pop     ebp
.text$mn:0000A555                 retn    4
.text$mn:0000A555 ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z endp
.text$mn:0000A555
.text$mn:0000A555 _text$mn        ends
.text$mn:0000A555
.text$mn:0000A558 ; ===========================================================================
.text$mn:0000A558
.text$mn:0000A558 ; Segment type: Pure code
.text$mn:0000A558 ; Segment permissions: Read/Execute
.text$mn:0000A558 _text$mn        segment para public 'CODE' use32
.text$mn:0000A558                 assume cs:_text$mn
.text$mn:0000A558                 ;org 0A558h
.text$mn:0000A558 ; COMDAT (pick any)
.text$mn:0000A558                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A558
.text$mn:0000A558 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A558
.text$mn:0000A558 ; Attributes: bp-based frame
.text$mn:0000A558
.text$mn:0000A558 ; const wchar_t *__cdecl Notepad_plus_Window::getClassName()
.text$mn:0000A558                 public ?getClassName@Notepad_plus_Window@@SAPB_WXZ
.text$mn:0000A558 ?getClassName@Notepad_plus_Window@@SAPB_WXZ proc near
.text$mn:0000A558                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+963p
.text$mn:0000A558                 push    ebp
.text$mn:0000A559                 mov     ebp, esp
.text$mn:0000A55B                 mov     eax, offset ?_className@Notepad_plus_Window@@0QB_WB ; wchar_t const * const Notepad_plus_Window::_className
.text$mn:0000A560                 pop     ebp
.text$mn:0000A561                 retn
.text$mn:0000A561 ?getClassName@Notepad_plus_Window@@SAPB_WXZ endp
.text$mn:0000A561
.text$mn:0000A561 ; ---------------------------------------------------------------------------
.text$mn:0000A562                 align 4
.text$mn:0000A562 _text$mn        ends
.text$mn:0000A562
.text$mn:0000A564 ; ===========================================================================
.text$mn:0000A564
.text$mn:0000A564 ; Segment type: Pure code
.text$mn:0000A564 ; Segment permissions: Read/Execute
.text$mn:0000A564 _text$mn        segment para public 'CODE' use32
.text$mn:0000A564                 assume cs:_text$mn
.text$mn:0000A564                 ;org 0A564h
.text$mn:0000A564 ; COMDAT (pick any)
.text$mn:0000A564                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A564
.text$mn:0000A564 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A564
.text$mn:0000A564 ; Attributes: bp-based frame
.text$mn:0000A564
.text$mn:0000A564 ; struct Buffer *__thiscall ScintillaEditView::getCurrentBuffer(ScintillaEditView *__hidden this)
.text$mn:0000A564                 public ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ
.text$mn:0000A564 ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ proc near
.text$mn:0000A564                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+31Fp
.text$mn:0000A564                                         ; Notepad_plus::notify(SCNotification *)+3A2p ...
.text$mn:0000A564
.text$mn:0000A564 var_4           = dword ptr -4
.text$mn:0000A564
.text$mn:0000A564                 push    ebp
.text$mn:0000A565                 mov     ebp, esp
.text$mn:0000A567                 push    ecx
.text$mn:0000A568                 mov     [ebp+var_4], ecx
.text$mn:0000A56B                 mov     eax, [ebp+var_4]
.text$mn:0000A56E                 mov     eax, [eax+20h]
.text$mn:0000A571                 mov     esp, ebp
.text$mn:0000A573                 pop     ebp
.text$mn:0000A574                 retn
.text$mn:0000A574 ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ endp
.text$mn:0000A574
.text$mn:0000A574 ; ---------------------------------------------------------------------------
.text$mn:0000A575                 align 4
.text$mn:0000A575 _text$mn        ends
.text$mn:0000A575
.text$mn:0000A578 ; ===========================================================================
.text$mn:0000A578
.text$mn:0000A578 ; Segment type: Pure code
.text$mn:0000A578 ; Segment permissions: Read/Execute
.text$mn:0000A578 _text$mn        segment para public 'CODE' use32
.text$mn:0000A578                 assume cs:_text$mn
.text$mn:0000A578                 ;org 0A578h
.text$mn:0000A578 ; COMDAT (pick any)
.text$mn:0000A578                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A578
.text$mn:0000A578 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A578
.text$mn:0000A578 ; Attributes: bp-based frame
.text$mn:0000A578
.text$mn:0000A578 ; __int32 __thiscall ScintillaEditView::getCurrentLineNumber(ScintillaEditView *__hidden this)
.text$mn:0000A578                 public ?getCurrentLineNumber@ScintillaEditView@@QBEJXZ
.text$mn:0000A578 ?getCurrentLineNumber@ScintillaEditView@@QBEJXZ proc near
.text$mn:0000A578                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+231Ap
.text$mn:0000A578                                         ; Notepad_plus::notify(SCNotification *)+26EDp ...
.text$mn:0000A578
.text$mn:0000A578 var_4           = dword ptr -4
.text$mn:0000A578
.text$mn:0000A578                 push    ebp
.text$mn:0000A579                 mov     ebp, esp
.text$mn:0000A57B                 push    ecx
.text$mn:0000A57C                 mov     [ebp+var_4], ecx
.text$mn:0000A57F                 push    0               ; __int32
.text$mn:0000A581                 push    0               ; __int32
.text$mn:0000A583                 push    0               ; unsigned int
.text$mn:0000A585                 push    7D8h            ; unsigned int
.text$mn:0000A58A                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000A58D                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000A592                 push    eax             ; unsigned int
.text$mn:0000A593                 push    876h            ; unsigned int
.text$mn:0000A598                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000A59B                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000A5A0                 mov     esp, ebp
.text$mn:0000A5A2                 pop     ebp
.text$mn:0000A5A3                 retn
.text$mn:0000A5A3 ?getCurrentLineNumber@ScintillaEditView@@QBEJXZ endp
.text$mn:0000A5A3
.text$mn:0000A5A3 _text$mn        ends
.text$mn:0000A5A3
.text$mn:0000A5A4 ; ===========================================================================
.text$mn:0000A5A4
.text$mn:0000A5A4 ; Segment type: Pure code
.text$mn:0000A5A4 ; Segment permissions: Read/Execute
.text$mn:0000A5A4 _text$mn        segment para public 'CODE' use32
.text$mn:0000A5A4                 assume cs:_text$mn
.text$mn:0000A5A4                 ;org 0A5A4h
.text$mn:0000A5A4 ; COMDAT (pick any)
.text$mn:0000A5A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A5A4
.text$mn:0000A5A4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A5A4
.text$mn:0000A5A4 ; Attributes: bp-based frame
.text$mn:0000A5A4
.text$mn:0000A5A4 ; int __thiscall TabBar::getCurrentTabIndex(TabBar *__hidden this)
.text$mn:0000A5A4                 public ?getCurrentTabIndex@TabBar@@QBEHXZ
.text$mn:0000A5A4 ?getCurrentTabIndex@TabBar@@QBEHXZ proc near
.text$mn:0000A5A4                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+9A4p
.text$mn:0000A5A4                                         ; Notepad_plus::notify(SCNotification *)+CBBp
.text$mn:0000A5A4
.text$mn:0000A5A4 var_4           = dword ptr -4
.text$mn:0000A5A4
.text$mn:0000A5A4                 push    ebp
.text$mn:0000A5A5                 mov     ebp, esp
.text$mn:0000A5A7                 push    ecx
.text$mn:0000A5A8                 mov     [ebp+var_4], ecx
.text$mn:0000A5AB                 push    0               ; lParam
.text$mn:0000A5AD                 push    0               ; wParam
.text$mn:0000A5AF                 push    130Bh           ; Msg
.text$mn:0000A5B4                 mov     eax, [ebp+var_4]
.text$mn:0000A5B7                 mov     ecx, [eax+0Ch]
.text$mn:0000A5BA                 push    ecx             ; hWnd
.text$mn:0000A5BB                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000A5C1                 mov     esp, ebp
.text$mn:0000A5C3                 pop     ebp
.text$mn:0000A5C4                 retn
.text$mn:0000A5C4 ?getCurrentTabIndex@TabBar@@QBEHXZ endp
.text$mn:0000A5C4
.text$mn:0000A5C4 ; ---------------------------------------------------------------------------
.text$mn:0000A5C5                 align 4
.text$mn:0000A5C5 _text$mn        ends
.text$mn:0000A5C5
.text$mn:0000A5C8 ; ===========================================================================
.text$mn:0000A5C8
.text$mn:0000A5C8 ; Segment type: Pure code
.text$mn:0000A5C8 ; Segment permissions: Read/Execute
.text$mn:0000A5C8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A5C8                 assume cs:_text$mn
.text$mn:0000A5C8                 ;org 0A5C8h
.text$mn:0000A5C8 ; COMDAT (pick any)
.text$mn:0000A5C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A5C8
.text$mn:0000A5C8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A5C8
.text$mn:0000A5C8 ; Attributes: bp-based frame
.text$mn:0000A5C8
.text$mn:0000A5C8 ; struct tagPOINT __thiscall TabBarPlus::getDraggingPoint(TabBarPlus *this)
.text$mn:0000A5C8                 public ?getDraggingPoint@TabBarPlus@@QBE?AUtagPOINT@@XZ
.text$mn:0000A5C8 ?getDraggingPoint@TabBarPlus@@QBE?AUtagPOINT@@XZ proc near
.text$mn:0000A5C8                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+5E1p
.text$mn:0000A5C8
.text$mn:0000A5C8 var_4           = dword ptr -4
.text$mn:0000A5C8 arg_0           = dword ptr  8
.text$mn:0000A5C8
.text$mn:0000A5C8                 push    ebp
.text$mn:0000A5C9                 mov     ebp, esp
.text$mn:0000A5CB                 push    ecx
.text$mn:0000A5CC                 mov     [ebp+var_4], ecx
.text$mn:0000A5CF                 mov     eax, [ebp+var_4]
.text$mn:0000A5D2                 mov     ecx, [eax+3Ch]
.text$mn:0000A5D5                 mov     edx, [eax+40h]
.text$mn:0000A5D8                 mov     eax, [ebp+arg_0]
.text$mn:0000A5DB                 mov     [eax], ecx
.text$mn:0000A5DD                 mov     [eax+4], edx
.text$mn:0000A5E0                 mov     eax, [ebp+arg_0]
.text$mn:0000A5E3                 mov     esp, ebp
.text$mn:0000A5E5                 pop     ebp
.text$mn:0000A5E6                 retn    4
.text$mn:0000A5E6 ?getDraggingPoint@TabBarPlus@@QBE?AUtagPOINT@@XZ endp
.text$mn:0000A5E6
.text$mn:0000A5E6 ; ---------------------------------------------------------------------------
.text$mn:0000A5E9                 align 4
.text$mn:0000A5E9 _text$mn        ends
.text$mn:0000A5E9
.text$mn:0000A5EC ; ===========================================================================
.text$mn:0000A5EC
.text$mn:0000A5EC ; Segment type: Pure code
.text$mn:0000A5EC ; Segment permissions: Read/Execute
.text$mn:0000A5EC _text$mn        segment para public 'CODE' use32
.text$mn:0000A5EC                 assume cs:_text$mn
.text$mn:0000A5EC                 ;org 0A5ECh
.text$mn:0000A5EC ; COMDAT (pick any)
.text$mn:0000A5EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A5EC
.text$mn:0000A5EC ; =============== S U B R O U T I N E =======================================
.text$mn:0000A5EC
.text$mn:0000A5EC ; Attributes: bp-based frame
.text$mn:0000A5EC
.text$mn:0000A5EC ; bool __thiscall Buffer::getFileReadOnly(Buffer *__hidden this)
.text$mn:0000A5EC                 public ?getFileReadOnly@Buffer@@QBE_NXZ
.text$mn:0000A5EC ?getFileReadOnly@Buffer@@QBE_NXZ proc near
.text$mn:0000A5EC                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+1D24p
.text$mn:0000A5EC
.text$mn:0000A5EC var_4           = dword ptr -4
.text$mn:0000A5EC
.text$mn:0000A5EC                 push    ebp
.text$mn:0000A5ED                 mov     ebp, esp
.text$mn:0000A5EF                 push    ecx
.text$mn:0000A5F0                 mov     [ebp+var_4], ecx
.text$mn:0000A5F3                 mov     eax, [ebp+var_4]
.text$mn:0000A5F6                 mov     al, [eax+88h]
.text$mn:0000A5FC                 mov     esp, ebp
.text$mn:0000A5FE                 pop     ebp
.text$mn:0000A5FF                 retn
.text$mn:0000A5FF ?getFileReadOnly@Buffer@@QBE_NXZ endp
.text$mn:0000A5FF
.text$mn:0000A5FF _text$mn        ends
.text$mn:0000A5FF
.text$mn:0000A600 ; ===========================================================================
.text$mn:0000A600
.text$mn:0000A600 ; Segment type: Pure code
.text$mn:0000A600 ; Segment permissions: Read/Execute
.text$mn:0000A600 _text$mn        segment para public 'CODE' use32
.text$mn:0000A600                 assume cs:_text$mn
.text$mn:0000A600                 ;org 0A600h
.text$mn:0000A600 ; COMDAT (pick any)
.text$mn:0000A600                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A600
.text$mn:0000A600 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A600
.text$mn:0000A600 ; Attributes: bp-based frame
.text$mn:0000A600
.text$mn:0000A600 ; const wchar_t *__thiscall Buffer::getFullPathName(Buffer *__hidden this)
.text$mn:0000A600                 public ?getFullPathName@Buffer@@QBEPB_WXZ
.text$mn:0000A600 ?getFullPathName@Buffer@@QBEPB_WXZ proc near
.text$mn:0000A600                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+8DCp
.text$mn:0000A600                                         ; Notepad_plus::notify(SCNotification *)+1D8Cp ...
.text$mn:0000A600
.text$mn:0000A600 var_4           = dword ptr -4
.text$mn:0000A600
.text$mn:0000A600                 push    ebp
.text$mn:0000A601                 mov     ebp, esp
.text$mn:0000A603                 push    ecx
.text$mn:0000A604                 mov     [ebp+var_4], ecx
.text$mn:0000A607                 mov     ecx, [ebp+var_4]
.text$mn:0000A60A                 add     ecx, 8Ch ; 'î'
.text$mn:0000A610                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000A615                 mov     esp, ebp
.text$mn:0000A617                 pop     ebp
.text$mn:0000A618                 retn
.text$mn:0000A618 ?getFullPathName@Buffer@@QBEPB_WXZ endp
.text$mn:0000A618
.text$mn:0000A618 ; ---------------------------------------------------------------------------
.text$mn:0000A619                 align 4
.text$mn:0000A619 _text$mn        ends
.text$mn:0000A619
.text$mn:0000A61C ; ===========================================================================
.text$mn:0000A61C
.text$mn:0000A61C ; Segment type: Pure code
.text$mn:0000A61C ; Segment permissions: Read/Execute
.text$mn:0000A61C _text$mn        segment para public 'CODE' use32
.text$mn:0000A61C                 assume cs:_text$mn
.text$mn:0000A61C                 ;org 0A61Ch
.text$mn:0000A61C ; COMDAT (pick any)
.text$mn:0000A61C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A61C
.text$mn:0000A61C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A61C
.text$mn:0000A61C ; Attributes: bp-based frame
.text$mn:0000A61C
.text$mn:0000A61C ; HWND __thiscall Window::getHSelf(Window *__hidden this)
.text$mn:0000A61C                 public ?getHSelf@Window@@QBEPAUHWND__@@XZ
.text$mn:0000A61C ?getHSelf@Window@@QBEPAUHWND__@@XZ proc near
.text$mn:0000A61C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+48p
.text$mn:0000A61C                                         ; Notepad_plus::notify(SCNotification *)+60p ...
.text$mn:0000A61C
.text$mn:0000A61C var_4           = dword ptr -4
.text$mn:0000A61C
.text$mn:0000A61C                 push    ebp
.text$mn:0000A61D                 mov     ebp, esp
.text$mn:0000A61F                 push    ecx
.text$mn:0000A620                 mov     [ebp+var_4], ecx
.text$mn:0000A623                 mov     eax, [ebp+var_4]
.text$mn:0000A626                 mov     eax, [eax+0Ch]
.text$mn:0000A629                 mov     esp, ebp
.text$mn:0000A62B                 pop     ebp
.text$mn:0000A62C                 retn
.text$mn:0000A62C ?getHSelf@Window@@QBEPAUHWND__@@XZ endp
.text$mn:0000A62C
.text$mn:0000A62C ; ---------------------------------------------------------------------------
.text$mn:0000A62D                 align 10h
.text$mn:0000A62D _text$mn        ends
.text$mn:0000A62D
.text$mn:0000A630 ; ===========================================================================
.text$mn:0000A630
.text$mn:0000A630 ; Segment type: Pure code
.text$mn:0000A630 ; Segment permissions: Read/Execute
.text$mn:0000A630 _text$mn        segment para public 'CODE' use32
.text$mn:0000A630                 assume cs:_text$mn
.text$mn:0000A630                 ;org 0A630h
.text$mn:0000A630 ; COMDAT (pick any)
.text$mn:0000A630                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A630
.text$mn:0000A630 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A630
.text$mn:0000A630 ; Attributes: bp-based frame
.text$mn:0000A630
.text$mn:0000A630 ; HINSTANCE __thiscall Window::getHinst(Window *__hidden this)
.text$mn:0000A630                 public ?getHinst@Window@@QBEPAUHINSTANCE__@@XZ
.text$mn:0000A630 ?getHinst@Window@@QBEPAUHINSTANCE__@@XZ proc near
.text$mn:0000A630                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+AC0p
.text$mn:0000A630
.text$mn:0000A630 var_4           = dword ptr -4
.text$mn:0000A630
.text$mn:0000A630                 push    ebp
.text$mn:0000A631                 mov     ebp, esp
.text$mn:0000A633                 push    ecx
.text$mn:0000A634                 mov     [ebp+var_4], ecx
.text$mn:0000A637                 mov     eax, [ebp+var_4]
.text$mn:0000A63A                 mov     eax, [eax+4]
.text$mn:0000A63D                 mov     esp, ebp
.text$mn:0000A63F                 pop     ebp
.text$mn:0000A640                 retn
.text$mn:0000A640 ?getHinst@Window@@QBEPAUHINSTANCE__@@XZ endp
.text$mn:0000A640
.text$mn:0000A640 ; ---------------------------------------------------------------------------
.text$mn:0000A641                 align 4
.text$mn:0000A641 _text$mn        ends
.text$mn:0000A641
.text$mn:0000A644 ; ===========================================================================
.text$mn:0000A644
.text$mn:0000A644 ; Segment type: Pure code
.text$mn:0000A644 ; Segment permissions: Read/Execute
.text$mn:0000A644 _text$mn        segment para public 'CODE' use32
.text$mn:0000A644                 assume cs:_text$mn
.text$mn:0000A644                 ;org 0A644h
.text$mn:0000A644 ; COMDAT (pick any)
.text$mn:0000A644                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A644
.text$mn:0000A644 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A644
.text$mn:0000A644 ; Attributes: bp-based frame
.text$mn:0000A644
.text$mn:0000A644 ; struct FileManager *__cdecl FileManager::getInstance()
.text$mn:0000A644                 public ?getInstance@FileManager@@SAPAV1@XZ
.text$mn:0000A644 ?getInstance@FileManager@@SAPAV1@XZ proc near
.text$mn:0000A644                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+416p
.text$mn:0000A644                                         ; Notepad_plus::notify(SCNotification *)+45Dp ...
.text$mn:0000A644                 push    ebp
.text$mn:0000A645                 mov     ebp, esp
.text$mn:0000A647                 mov     eax, dword ptr ds:?_pSelf@FileManager@@0PAV1@A ; FileManager * FileManager::_pSelf
.text$mn:0000A64C                 pop     ebp
.text$mn:0000A64D                 retn
.text$mn:0000A64D ?getInstance@FileManager@@SAPAV1@XZ endp
.text$mn:0000A64D
.text$mn:0000A64D ; ---------------------------------------------------------------------------
.text$mn:0000A64E                 align 10h
.text$mn:0000A64E _text$mn        ends
.text$mn:0000A64E
.text$mn:0000A650 ; ===========================================================================
.text$mn:0000A650
.text$mn:0000A650 ; Segment type: Pure code
.text$mn:0000A650 ; Segment permissions: Read/Execute
.text$mn:0000A650 _text$mn        segment para public 'CODE' use32
.text$mn:0000A650                 assume cs:_text$mn
.text$mn:0000A650                 ;org 0A650h
.text$mn:0000A650 ; COMDAT (pick any)
.text$mn:0000A650                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A650
.text$mn:0000A650 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A650
.text$mn:0000A650 ; Attributes: bp-based frame
.text$mn:0000A650
.text$mn:0000A650 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:0000A650                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:0000A650 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:0000A650                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+4CDp
.text$mn:0000A650                                         ; Notepad_plus::notify(SCNotification *)+E2Ep ...
.text$mn:0000A650                 push    ebp
.text$mn:0000A651                 mov     ebp, esp
.text$mn:0000A653                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:0000A658                 pop     ebp
.text$mn:0000A659                 retn
.text$mn:0000A659 ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:0000A659
.text$mn:0000A659 ; ---------------------------------------------------------------------------
.text$mn:0000A65A                 align 4
.text$mn:0000A65A _text$mn        ends
.text$mn:0000A65A
.text$mn:0000A65C ; ===========================================================================
.text$mn:0000A65C
.text$mn:0000A65C ; Segment type: Pure code
.text$mn:0000A65C ; Segment permissions: Read/Execute
.text$mn:0000A65C _text$mn        segment para public 'CODE' use32
.text$mn:0000A65C                 assume cs:_text$mn
.text$mn:0000A65C                 ;org 0A65Ch
.text$mn:0000A65C ; COMDAT (pick any)
.text$mn:0000A65C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A65C
.text$mn:0000A65C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A65C
.text$mn:0000A65C ; Attributes: bp-based frame
.text$mn:0000A65C
.text$mn:0000A65C ; HMENU __thiscall ContextMenu::getMenuHandle(ContextMenu *__hidden this)
.text$mn:0000A65C                 public ?getMenuHandle@ContextMenu@@QAEPAUHMENU__@@XZ
.text$mn:0000A65C ?getMenuHandle@ContextMenu@@QAEPAUHMENU__@@XZ proc near
.text$mn:0000A65C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+777p
.text$mn:0000A65C                                         ; Notepad_plus::notify(SCNotification *)+1410p ...
.text$mn:0000A65C
.text$mn:0000A65C var_4           = dword ptr -4
.text$mn:0000A65C
.text$mn:0000A65C                 push    ebp
.text$mn:0000A65D                 mov     ebp, esp
.text$mn:0000A65F                 push    ecx
.text$mn:0000A660                 mov     [ebp+var_4], ecx
.text$mn:0000A663                 mov     eax, [ebp+var_4]
.text$mn:0000A666                 mov     eax, [eax+4]
.text$mn:0000A669                 mov     esp, ebp
.text$mn:0000A66B                 pop     ebp
.text$mn:0000A66C                 retn
.text$mn:0000A66C ?getMenuHandle@ContextMenu@@QAEPAUHMENU__@@XZ endp
.text$mn:0000A66C
.text$mn:0000A66C ; ---------------------------------------------------------------------------
.text$mn:0000A66D                 align 10h
.text$mn:0000A66D _text$mn        ends
.text$mn:0000A66D
.text$mn:0000A670 ; ===========================================================================
.text$mn:0000A670
.text$mn:0000A670 ; Segment type: Pure code
.text$mn:0000A670 ; Segment permissions: Read/Execute
.text$mn:0000A670 _text$mn        segment para public 'CODE' use32
.text$mn:0000A670                 assume cs:_text$mn
.text$mn:0000A670                 ;org 0A670h
.text$mn:0000A670 ; COMDAT (pick any)
.text$mn:0000A670                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A670
.text$mn:0000A670 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A670
.text$mn:0000A670 ; Attributes: bp-based frame
.text$mn:0000A670
.text$mn:0000A670 ; const struct NppGUI *__thiscall NppParameters::getNppGUI(NppParameters *__hidden this)
.text$mn:0000A670                 public ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ
.text$mn:0000A670 ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ proc near
.text$mn:0000A670                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+4D4p
.text$mn:0000A670                                         ; Notepad_plus::notify(SCNotification *)+E35p ...
.text$mn:0000A670
.text$mn:0000A670 var_4           = dword ptr -4
.text$mn:0000A670
.text$mn:0000A670                 push    ebp
.text$mn:0000A671                 mov     ebp, esp
.text$mn:0000A673                 push    ecx
.text$mn:0000A674                 mov     [ebp+var_4], ecx
.text$mn:0000A677                 mov     eax, [ebp+var_4]
.text$mn:0000A67A                 add     eax, 118h
.text$mn:0000A67F                 mov     esp, ebp
.text$mn:0000A681                 pop     ebp
.text$mn:0000A682                 retn
.text$mn:0000A682 ?getNppGUI@NppParameters@@QBEABUNppGUI@@XZ endp
.text$mn:0000A682
.text$mn:0000A682 ; ---------------------------------------------------------------------------
.text$mn:0000A683                 align 4
.text$mn:0000A683 _text$mn        ends
.text$mn:0000A683
.text$mn:0000A684 ; ===========================================================================
.text$mn:0000A684
.text$mn:0000A684 ; Segment type: Pure code
.text$mn:0000A684 ; Segment permissions: Read/Execute
.text$mn:0000A684 _text$mn        segment para public 'CODE' use32
.text$mn:0000A684                 assume cs:_text$mn
.text$mn:0000A684                 ;org 0A684h
.text$mn:0000A684 ; COMDAT (pick any)
.text$mn:0000A684                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A684
.text$mn:0000A684 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A684
.text$mn:0000A684 ; Attributes: bp-based frame
.text$mn:0000A684
.text$mn:0000A684 ; bool __thiscall Buffer::getUserReadOnly(Buffer *__hidden this)
.text$mn:0000A684                 public ?getUserReadOnly@Buffer@@QBE_NXZ
.text$mn:0000A684 ?getUserReadOnly@Buffer@@QBE_NXZ proc near
.text$mn:0000A684                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+1CF5p
.text$mn:0000A684
.text$mn:0000A684 var_4           = dword ptr -4
.text$mn:0000A684
.text$mn:0000A684                 push    ebp
.text$mn:0000A685                 mov     ebp, esp
.text$mn:0000A687                 push    ecx
.text$mn:0000A688                 mov     [ebp+var_4], ecx
.text$mn:0000A68B                 mov     eax, [ebp+var_4]
.text$mn:0000A68E                 mov     al, [eax+44h]
.text$mn:0000A691                 mov     esp, ebp
.text$mn:0000A693                 pop     ebp
.text$mn:0000A694                 retn
.text$mn:0000A694 ?getUserReadOnly@Buffer@@QBE_NXZ endp
.text$mn:0000A694
.text$mn:0000A694 ; ---------------------------------------------------------------------------
.text$mn:0000A695                 align 4
.text$mn:0000A695 _text$mn        ends
.text$mn:0000A695
.text$mn:0000A698 ; ===========================================================================
.text$mn:0000A698
.text$mn:0000A698 ; Segment type: Pure code
.text$mn:0000A698 ; Segment permissions: Read/Execute
.text$mn:0000A698 _text$mn        segment para public 'CODE' use32
.text$mn:0000A698                 assume cs:_text$mn
.text$mn:0000A698                 ;org 0A698h
.text$mn:0000A698 ; COMDAT (pick any)
.text$mn:0000A698                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A698
.text$mn:0000A698 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A698
.text$mn:0000A698 ; Attributes: bp-based frame
.text$mn:0000A698
.text$mn:0000A698 ; bool __thiscall MatchedPairConf::hasAnyPairsPair(MatchedPairConf *__hidden this)
.text$mn:0000A698                 public ?hasAnyPairsPair@MatchedPairConf@@QBE_NXZ
.text$mn:0000A698 ?hasAnyPairsPair@MatchedPairConf@@QBE_NXZ proc near
.text$mn:0000A698                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+218Fp
.text$mn:0000A698
.text$mn:0000A698 var_8           = dword ptr -8
.text$mn:0000A698 var_4           = dword ptr -4
.text$mn:0000A698
.text$mn:0000A698                 push    ebp
.text$mn:0000A699                 mov     ebp, esp
.text$mn:0000A69B                 sub     esp, 8
.text$mn:0000A69E                 mov     [ebp+var_4], ecx
.text$mn:0000A6A1                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000A6A4                 call    ?hasUserDefinedPairs@MatchedPairConf@@QBE_NXZ ; MatchedPairConf::hasUserDefinedPairs(void)
.text$mn:0000A6A9                 movzx   eax, al
.text$mn:0000A6AC                 test    eax, eax
.text$mn:0000A6AE                 jnz     short loc_A6C8
.text$mn:0000A6B0                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000A6B3                 call    ?hasDefaultPairs@MatchedPairConf@@QBE_NXZ ; MatchedPairConf::hasDefaultPairs(void)
.text$mn:0000A6B8                 movzx   ecx, al
.text$mn:0000A6BB                 test    ecx, ecx
.text$mn:0000A6BD                 jnz     short loc_A6C8
.text$mn:0000A6BF                 mov     [ebp+var_8], 0
.text$mn:0000A6C6                 jmp     short loc_A6CF
.text$mn:0000A6C8 ; ---------------------------------------------------------------------------
.text$mn:0000A6C8
.text$mn:0000A6C8 loc_A6C8:                               ; CODE XREF: MatchedPairConf::hasAnyPairsPair(void)+16j
.text$mn:0000A6C8                                         ; MatchedPairConf::hasAnyPairsPair(void)+25j
.text$mn:0000A6C8                 mov     [ebp+var_8], 1
.text$mn:0000A6CF
.text$mn:0000A6CF loc_A6CF:                               ; CODE XREF: MatchedPairConf::hasAnyPairsPair(void)+2Ej
.text$mn:0000A6CF                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000A6D2                 mov     esp, ebp
.text$mn:0000A6D4                 pop     ebp
.text$mn:0000A6D5                 retn
.text$mn:0000A6D5 ?hasAnyPairsPair@MatchedPairConf@@QBE_NXZ endp
.text$mn:0000A6D5
.text$mn:0000A6D5 ; ---------------------------------------------------------------------------
.text$mn:0000A6D6                 align 4
.text$mn:0000A6D6 _text$mn        ends
.text$mn:0000A6D6
.text$mn:0000A6D8 ; ===========================================================================
.text$mn:0000A6D8
.text$mn:0000A6D8 ; Segment type: Pure code
.text$mn:0000A6D8 ; Segment permissions: Read/Execute
.text$mn:0000A6D8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A6D8                 assume cs:_text$mn
.text$mn:0000A6D8                 ;org 0A6D8h
.text$mn:0000A6D8 ; COMDAT (pick any)
.text$mn:0000A6D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A6D8
.text$mn:0000A6D8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A6D8
.text$mn:0000A6D8 ; Attributes: bp-based frame
.text$mn:0000A6D8
.text$mn:0000A6D8 ; bool __thiscall MatchedPairConf::hasDefaultPairs(MatchedPairConf *__hidden this)
.text$mn:0000A6D8                 public ?hasDefaultPairs@MatchedPairConf@@QBE_NXZ
.text$mn:0000A6D8 ?hasDefaultPairs@MatchedPairConf@@QBE_NXZ proc near
.text$mn:0000A6D8                                         ; CODE XREF: MatchedPairConf::hasAnyPairsPair(void)+1Bp
.text$mn:0000A6D8
.text$mn:0000A6D8 var_8           = dword ptr -8
.text$mn:0000A6D8 var_4           = dword ptr -4
.text$mn:0000A6D8
.text$mn:0000A6D8                 push    ebp
.text$mn:0000A6D9                 mov     ebp, esp
.text$mn:0000A6DB                 sub     esp, 8
.text$mn:0000A6DE                 mov     [ebp+var_4], ecx
.text$mn:0000A6E1                 mov     eax, [ebp+var_4]
.text$mn:0000A6E4                 movzx   ecx, byte ptr [eax+21h]
.text$mn:0000A6E8                 test    ecx, ecx
.text$mn:0000A6EA                 jnz     short loc_A72C
.text$mn:0000A6EC                 mov     edx, [ebp+var_4]
.text$mn:0000A6EF                 movzx   eax, byte ptr [edx+22h]
.text$mn:0000A6F3                 test    eax, eax
.text$mn:0000A6F5                 jnz     short loc_A72C
.text$mn:0000A6F7                 mov     ecx, [ebp+var_4]
.text$mn:0000A6FA                 movzx   edx, byte ptr [ecx+23h]
.text$mn:0000A6FE                 test    edx, edx
.text$mn:0000A700                 jnz     short loc_A72C
.text$mn:0000A702                 mov     eax, [ebp+var_4]
.text$mn:0000A705                 movzx   ecx, byte ptr [eax+24h]
.text$mn:0000A709                 test    ecx, ecx
.text$mn:0000A70B                 jnz     short loc_A72C
.text$mn:0000A70D                 mov     edx, [ebp+var_4]
.text$mn:0000A710                 movzx   eax, byte ptr [edx+25h]
.text$mn:0000A714                 test    eax, eax
.text$mn:0000A716                 jnz     short loc_A72C
.text$mn:0000A718                 mov     ecx, [ebp+var_4]
.text$mn:0000A71B                 movzx   edx, byte ptr [ecx+20h]
.text$mn:0000A71F                 test    edx, edx
.text$mn:0000A721                 jnz     short loc_A72C
.text$mn:0000A723                 mov     [ebp+var_8], 0
.text$mn:0000A72A                 jmp     short loc_A733
.text$mn:0000A72C ; ---------------------------------------------------------------------------
.text$mn:0000A72C
.text$mn:0000A72C loc_A72C:                               ; CODE XREF: MatchedPairConf::hasDefaultPairs(void)+12j
.text$mn:0000A72C                                         ; MatchedPairConf::hasDefaultPairs(void)+1Dj ...
.text$mn:0000A72C                 mov     [ebp+var_8], 1
.text$mn:0000A733
.text$mn:0000A733 loc_A733:                               ; CODE XREF: MatchedPairConf::hasDefaultPairs(void)+52j
.text$mn:0000A733                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000A736                 mov     esp, ebp
.text$mn:0000A738                 pop     ebp
.text$mn:0000A739                 retn
.text$mn:0000A739 ?hasDefaultPairs@MatchedPairConf@@QBE_NXZ endp
.text$mn:0000A739
.text$mn:0000A739 ; ---------------------------------------------------------------------------
.text$mn:0000A73A                 align 4
.text$mn:0000A73A _text$mn        ends
.text$mn:0000A73A
.text$mn:0000A73C ; ===========================================================================
.text$mn:0000A73C
.text$mn:0000A73C ; Segment type: Pure code
.text$mn:0000A73C ; Segment permissions: Read/Execute
.text$mn:0000A73C _text$mn        segment para public 'CODE' use32
.text$mn:0000A73C                 assume cs:_text$mn
.text$mn:0000A73C                 ;org 0A73Ch
.text$mn:0000A73C ; COMDAT (pick any)
.text$mn:0000A73C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A73C
.text$mn:0000A73C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A73C
.text$mn:0000A73C ; Attributes: bp-based frame
.text$mn:0000A73C
.text$mn:0000A73C ; bool __thiscall MatchedPairConf::hasUserDefinedPairs(MatchedPairConf *__hidden this)
.text$mn:0000A73C                 public ?hasUserDefinedPairs@MatchedPairConf@@QBE_NXZ
.text$mn:0000A73C ?hasUserDefinedPairs@MatchedPairConf@@QBE_NXZ proc near
.text$mn:0000A73C                                         ; CODE XREF: MatchedPairConf::hasAnyPairsPair(void)+Cp
.text$mn:0000A73C
.text$mn:0000A73C var_8           = dword ptr -8
.text$mn:0000A73C var_4           = dword ptr -4
.text$mn:0000A73C
.text$mn:0000A73C                 push    ebp
.text$mn:0000A73D                 mov     ebp, esp
.text$mn:0000A73F                 sub     esp, 8
.text$mn:0000A742                 mov     [ebp+var_8], ecx
.text$mn:0000A745                 mov     ecx, [ebp+var_8]
.text$mn:0000A748                 call    ?size@?$vector@U?$pair@DD@std@@V?$allocator@U?$pair@DD@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<char,char>,std::allocator<std::pair<char,char>>>::size(void)
.text$mn:0000A74D                 test    eax, eax
.text$mn:0000A74F                 jz      short loc_A75A
.text$mn:0000A751                 mov     [ebp+var_4], 1
.text$mn:0000A758                 jmp     short loc_A761
.text$mn:0000A75A ; ---------------------------------------------------------------------------
.text$mn:0000A75A
.text$mn:0000A75A loc_A75A:                               ; CODE XREF: MatchedPairConf::hasUserDefinedPairs(void)+13j
.text$mn:0000A75A                 mov     [ebp+var_4], 0
.text$mn:0000A761
.text$mn:0000A761 loc_A761:                               ; CODE XREF: MatchedPairConf::hasUserDefinedPairs(void)+1Cj
.text$mn:0000A761                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000A764                 mov     esp, ebp
.text$mn:0000A766                 pop     ebp
.text$mn:0000A767                 retn
.text$mn:0000A767 ?hasUserDefinedPairs@MatchedPairConf@@QBE_NXZ endp
.text$mn:0000A767
.text$mn:0000A767 _text$mn        ends
.text$mn:0000A767
.text$mn:0000A768 ; ===========================================================================
.text$mn:0000A768
.text$mn:0000A768 ; Segment type: Pure code
.text$mn:0000A768 ; Segment permissions: Read/Execute
.text$mn:0000A768 _text$mn        segment para public 'CODE' use32
.text$mn:0000A768                 assume cs:_text$mn
.text$mn:0000A768                 ;org 0A768h
.text$mn:0000A768 ; COMDAT (pick any)
.text$mn:0000A768                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A768
.text$mn:0000A768 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A768
.text$mn:0000A768 ; Attributes: bp-based frame
.text$mn:0000A768
.text$mn:0000A768 ; bool __thiscall ContextMenu::isCreated(ContextMenu *__hidden this)
.text$mn:0000A768                 public ?isCreated@ContextMenu@@QBE_NXZ
.text$mn:0000A768 ?isCreated@ContextMenu@@QBE_NXZ proc near
.text$mn:0000A768                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+629p
.text$mn:0000A768                                         ; Notepad_plus::notify(SCNotification *)+131Dp ...
.text$mn:0000A768
.text$mn:0000A768 var_8           = dword ptr -8
.text$mn:0000A768 var_4           = dword ptr -4
.text$mn:0000A768
.text$mn:0000A768                 push    ebp
.text$mn:0000A769                 mov     ebp, esp
.text$mn:0000A76B                 sub     esp, 8
.text$mn:0000A76E                 mov     [ebp+var_8], ecx
.text$mn:0000A771                 mov     eax, [ebp+var_8]
.text$mn:0000A774                 cmp     dword ptr [eax+4], 0
.text$mn:0000A778                 jz      short loc_A783
.text$mn:0000A77A                 mov     [ebp+var_4], 1
.text$mn:0000A781                 jmp     short loc_A78A
.text$mn:0000A783 ; ---------------------------------------------------------------------------
.text$mn:0000A783
.text$mn:0000A783 loc_A783:                               ; CODE XREF: ContextMenu::isCreated(void)+10j
.text$mn:0000A783                 mov     [ebp+var_4], 0
.text$mn:0000A78A
.text$mn:0000A78A loc_A78A:                               ; CODE XREF: ContextMenu::isCreated(void)+19j
.text$mn:0000A78A                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000A78D                 mov     esp, ebp
.text$mn:0000A78F                 pop     ebp
.text$mn:0000A790                 retn
.text$mn:0000A790 ?isCreated@ContextMenu@@QBE_NXZ endp
.text$mn:0000A790
.text$mn:0000A790 ; ---------------------------------------------------------------------------
.text$mn:0000A791                 align 4
.text$mn:0000A791 _text$mn        ends
.text$mn:0000A791
.text$mn:0000A794 ; ===========================================================================
.text$mn:0000A794
.text$mn:0000A794 ; Segment type: Pure code
.text$mn:0000A794 ; Segment permissions: Read/Execute
.text$mn:0000A794 _text$mn        segment para public 'CODE' use32
.text$mn:0000A794                 assume cs:_text$mn
.text$mn:0000A794                 ;org 0A794h
.text$mn:0000A794 ; COMDAT (pick any)
.text$mn:0000A794                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A794
.text$mn:0000A794 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A794
.text$mn:0000A794 ; Attributes: bp-based frame
.text$mn:0000A794
.text$mn:0000A794 ; bool __thiscall Buffer::isDirty(Buffer *__hidden this)
.text$mn:0000A794                 public ?isDirty@Buffer@@QBE_NXZ
.text$mn:0000A794 ?isDirty@Buffer@@QBE_NXZ proc near      ; CODE XREF: Notepad_plus::notify(SCNotification *)+A13p
.text$mn:0000A794                                         ; Notepad_plus::notify(SCNotification *)+C03p ...
.text$mn:0000A794
.text$mn:0000A794 var_4           = dword ptr -4
.text$mn:0000A794
.text$mn:0000A794                 push    ebp
.text$mn:0000A795                 mov     ebp, esp
.text$mn:0000A797                 push    ecx
.text$mn:0000A798                 mov     [ebp+var_4], ecx
.text$mn:0000A79B                 mov     eax, [ebp+var_4]
.text$mn:0000A79E                 mov     al, [eax+34h]
.text$mn:0000A7A1                 mov     esp, ebp
.text$mn:0000A7A3                 pop     ebp
.text$mn:0000A7A4                 retn
.text$mn:0000A7A4 ?isDirty@Buffer@@QBE_NXZ endp
.text$mn:0000A7A4
.text$mn:0000A7A4 ; ---------------------------------------------------------------------------
.text$mn:0000A7A5                 align 4
.text$mn:0000A7A5 _text$mn        ends
.text$mn:0000A7A5
.text$mn:0000A7A8 ; ===========================================================================
.text$mn:0000A7A8
.text$mn:0000A7A8 ; Segment type: Pure code
.text$mn:0000A7A8 ; Segment permissions: Read/Execute
.text$mn:0000A7A8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A7A8                 assume cs:_text$mn
.text$mn:0000A7A8                 ;org 0A7A8h
.text$mn:0000A7A8 ; COMDAT (pick any)
.text$mn:0000A7A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A7A8
.text$mn:0000A7A8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A7A8
.text$mn:0000A7A8 ; Attributes: bp-based frame
.text$mn:0000A7A8
.text$mn:0000A7A8 ; bool __thiscall ScintillaEditView::isFolded(ScintillaEditView *this, int)
.text$mn:0000A7A8                 public ?isFolded@ScintillaEditView@@QAE_NH@Z
.text$mn:0000A7A8 ?isFolded@ScintillaEditView@@QAE_NH@Z proc near
.text$mn:0000A7A8                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+1F86p
.text$mn:0000A7A8                                         ; Notepad_plus::notify(SCNotification *)+209Bp
.text$mn:0000A7A8
.text$mn:0000A7A8 var_8           = dword ptr -8
.text$mn:0000A7A8 var_4           = dword ptr -4
.text$mn:0000A7A8 arg_0           = dword ptr  8
.text$mn:0000A7A8
.text$mn:0000A7A8                 push    ebp
.text$mn:0000A7A9                 mov     ebp, esp
.text$mn:0000A7AB                 sub     esp, 8
.text$mn:0000A7AE                 mov     [ebp+var_8], ecx
.text$mn:0000A7B1                 push    0               ; __int32
.text$mn:0000A7B3                 mov     eax, [ebp+arg_0]
.text$mn:0000A7B6                 push    eax             ; unsigned int
.text$mn:0000A7B7                 push    8B6h            ; unsigned int
.text$mn:0000A7BC                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000A7BF                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:0000A7C4                 test    eax, eax
.text$mn:0000A7C6                 jz      short loc_A7D1
.text$mn:0000A7C8                 mov     [ebp+var_4], 1
.text$mn:0000A7CF                 jmp     short loc_A7D8
.text$mn:0000A7D1 ; ---------------------------------------------------------------------------
.text$mn:0000A7D1
.text$mn:0000A7D1 loc_A7D1:                               ; CODE XREF: ScintillaEditView::isFolded(int)+1Ej
.text$mn:0000A7D1                 mov     [ebp+var_4], 0
.text$mn:0000A7D8
.text$mn:0000A7D8 loc_A7D8:                               ; CODE XREF: ScintillaEditView::isFolded(int)+27j
.text$mn:0000A7D8                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000A7DB                 mov     esp, ebp
.text$mn:0000A7DD                 pop     ebp
.text$mn:0000A7DE                 retn    4
.text$mn:0000A7DE ?isFolded@ScintillaEditView@@QAE_NH@Z endp
.text$mn:0000A7DE
.text$mn:0000A7DE ; ---------------------------------------------------------------------------
.text$mn:0000A7E1                 align 4
.text$mn:0000A7E1 _text$mn        ends
.text$mn:0000A7E1
.text$mn:0000A7E4 ; ===========================================================================
.text$mn:0000A7E4
.text$mn:0000A7E4 ; Segment type: Pure code
.text$mn:0000A7E4 ; Segment permissions: Read/Execute
.text$mn:0000A7E4 _text$mn        segment para public 'CODE' use32
.text$mn:0000A7E4                 assume cs:_text$mn
.text$mn:0000A7E4                 ;org 0A7E4h
.text$mn:0000A7E4 ; COMDAT (pick any)
.text$mn:0000A7E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A7E4
.text$mn:0000A7E4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A7E4
.text$mn:0000A7E4 ; Attributes: bp-based frame
.text$mn:0000A7E4
.text$mn:0000A7E4 ; bool __thiscall Buffer::isLoadedDirty(Buffer *__hidden this)
.text$mn:0000A7E4                 public ?isLoadedDirty@Buffer@@QBE_NXZ
.text$mn:0000A7E4 ?isLoadedDirty@Buffer@@QBE_NXZ proc near
.text$mn:0000A7E4                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+54Ep
.text$mn:0000A7E4
.text$mn:0000A7E4 var_4           = dword ptr -4
.text$mn:0000A7E4
.text$mn:0000A7E4                 push    ebp
.text$mn:0000A7E5                 mov     ebp, esp
.text$mn:0000A7E7                 push    ecx
.text$mn:0000A7E8                 mov     [ebp+var_4], ecx
.text$mn:0000A7EB                 mov     eax, [ebp+var_4]
.text$mn:0000A7EE                 mov     al, [eax+0D1h]
.text$mn:0000A7F4                 mov     esp, ebp
.text$mn:0000A7F6                 pop     ebp
.text$mn:0000A7F7                 retn
.text$mn:0000A7F7 ?isLoadedDirty@Buffer@@QBE_NXZ endp
.text$mn:0000A7F7
.text$mn:0000A7F7 _text$mn        ends
.text$mn:0000A7F7
.text$mn:0000A7F8 ; ===========================================================================
.text$mn:0000A7F8
.text$mn:0000A7F8 ; Segment type: Pure code
.text$mn:0000A7F8 ; Segment permissions: Read/Execute
.text$mn:0000A7F8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A7F8                 assume cs:_text$mn
.text$mn:0000A7F8                 ;org 0A7F8h
.text$mn:0000A7F8 ; COMDAT (pick any)
.text$mn:0000A7F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A7F8
.text$mn:0000A7F8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A7F8
.text$mn:0000A7F8 ; Attributes: bp-based frame
.text$mn:0000A7F8
.text$mn:0000A7F8 ; bool __thiscall NativeLangSpeaker::isRTL(NativeLangSpeaker *__hidden this)
.text$mn:0000A7F8                 public ?isRTL@NativeLangSpeaker@@QBE_NXZ
.text$mn:0000A7F8 ?isRTL@NativeLangSpeaker@@QBE_NXZ proc near
.text$mn:0000A7F8                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+F5Dp
.text$mn:0000A7F8
.text$mn:0000A7F8 var_4           = dword ptr -4
.text$mn:0000A7F8
.text$mn:0000A7F8                 push    ebp
.text$mn:0000A7F9                 mov     ebp, esp
.text$mn:0000A7FB                 push    ecx
.text$mn:0000A7FC                 mov     [ebp+var_4], ecx
.text$mn:0000A7FF                 mov     eax, [ebp+var_4]
.text$mn:0000A802                 mov     al, [eax+8]
.text$mn:0000A805                 mov     esp, ebp
.text$mn:0000A807                 pop     ebp
.text$mn:0000A808                 retn
.text$mn:0000A808 ?isRTL@NativeLangSpeaker@@QBE_NXZ endp
.text$mn:0000A808
.text$mn:0000A808 ; ---------------------------------------------------------------------------
.text$mn:0000A809                 align 4
.text$mn:0000A809 _text$mn        ends
.text$mn:0000A809
.text$mn:0000A80C ; ===========================================================================
.text$mn:0000A80C
.text$mn:0000A80C ; Segment type: Pure code
.text$mn:0000A80C ; Segment permissions: Read/Execute
.text$mn:0000A80C _text$mn        segment para public 'CODE' use32
.text$mn:0000A80C                 assume cs:_text$mn
.text$mn:0000A80C                 ;org 0A80Ch
.text$mn:0000A80C ; COMDAT (pick any)
.text$mn:0000A80C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A80C
.text$mn:0000A80C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A80C
.text$mn:0000A80C ; Attributes: bp-based frame
.text$mn:0000A80C
.text$mn:0000A80C ; bool __thiscall NppGUI::isSnapshotMode(NppGUI *__hidden this)
.text$mn:0000A80C                 public ?isSnapshotMode@NppGUI@@QBE_NXZ
.text$mn:0000A80C ?isSnapshotMode@NppGUI@@QBE_NXZ proc near
.text$mn:0000A80C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+4DBp
.text$mn:0000A80C                                         ; Notepad_plus::notify(SCNotification *)+E3Cp ...
.text$mn:0000A80C
.text$mn:0000A80C var_8           = dword ptr -8
.text$mn:0000A80C var_4           = dword ptr -4
.text$mn:0000A80C
.text$mn:0000A80C                 push    ebp
.text$mn:0000A80D                 mov     ebp, esp
.text$mn:0000A80F                 sub     esp, 8
.text$mn:0000A812                 mov     [ebp+var_4], ecx
.text$mn:0000A815                 mov     eax, [ebp+var_4]
.text$mn:0000A818                 movzx   ecx, byte ptr [eax+695h]
.text$mn:0000A81F                 test    ecx, ecx
.text$mn:0000A821                 jz      short loc_A842
.text$mn:0000A823                 mov     edx, [ebp+var_4]
.text$mn:0000A826                 movzx   eax, byte ptr [edx+3Ah]
.text$mn:0000A82A                 test    eax, eax
.text$mn:0000A82C                 jz      short loc_A842
.text$mn:0000A82E                 mov     ecx, [ebp+var_4]
.text$mn:0000A831                 movzx   edx, byte ptr [ecx+3Bh]
.text$mn:0000A835                 test    edx, edx
.text$mn:0000A837                 jnz     short loc_A842
.text$mn:0000A839                 mov     [ebp+var_8], 1
.text$mn:0000A840                 jmp     short loc_A849
.text$mn:0000A842 ; ---------------------------------------------------------------------------
.text$mn:0000A842
.text$mn:0000A842 loc_A842:                               ; CODE XREF: NppGUI::isSnapshotMode(void)+15j
.text$mn:0000A842                                         ; NppGUI::isSnapshotMode(void)+20j ...
.text$mn:0000A842                 mov     [ebp+var_8], 0
.text$mn:0000A849
.text$mn:0000A849 loc_A849:                               ; CODE XREF: NppGUI::isSnapshotMode(void)+34j
.text$mn:0000A849                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000A84C                 mov     esp, ebp
.text$mn:0000A84E                 pop     ebp
.text$mn:0000A84F                 retn
.text$mn:0000A84F ?isSnapshotMode@NppGUI@@QBE_NXZ endp
.text$mn:0000A84F
.text$mn:0000A84F _text$mn        ends
.text$mn:0000A84F
.text$mn:0000A850 ; ===========================================================================
.text$mn:0000A850
.text$mn:0000A850 ; Segment type: Pure code
.text$mn:0000A850 ; Segment permissions: Read/Execute
.text$mn:0000A850 _text$mn        segment para public 'CODE' use32
.text$mn:0000A850                 assume cs:_text$mn
.text$mn:0000A850                 ;org 0A850h
.text$mn:0000A850 ; COMDAT (pick any)
.text$mn:0000A850                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A850
.text$mn:0000A850 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A850
.text$mn:0000A850 ; Attributes: bp-based frame
.text$mn:0000A850
.text$mn:0000A850 ; bool __thiscall Buffer::isUntitled(Buffer *__hidden this)
.text$mn:0000A850                 public ?isUntitled@Buffer@@QBE_NXZ
.text$mn:0000A850 ?isUntitled@Buffer@@QBE_NXZ proc near   ; CODE XREF: Notepad_plus::notify(SCNotification *)+1E11p
.text$mn:0000A850
.text$mn:0000A850 var_8           = dword ptr -8
.text$mn:0000A850 var_4           = dword ptr -4
.text$mn:0000A850
.text$mn:0000A850                 push    ebp
.text$mn:0000A851                 mov     ebp, esp
.text$mn:0000A853                 sub     esp, 8
.text$mn:0000A856                 mov     [ebp+var_8], ecx
.text$mn:0000A859                 mov     eax, [ebp+var_8]
.text$mn:0000A85C                 cmp     dword ptr [eax+78h], 2
.text$mn:0000A860                 jnz     short loc_A86B
.text$mn:0000A862                 mov     [ebp+var_4], 1
.text$mn:0000A869                 jmp     short loc_A872
.text$mn:0000A86B ; ---------------------------------------------------------------------------
.text$mn:0000A86B
.text$mn:0000A86B loc_A86B:                               ; CODE XREF: Buffer::isUntitled(void)+10j
.text$mn:0000A86B                 mov     [ebp+var_4], 0
.text$mn:0000A872
.text$mn:0000A872 loc_A872:                               ; CODE XREF: Buffer::isUntitled(void)+19j
.text$mn:0000A872                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000A875                 mov     esp, ebp
.text$mn:0000A877                 pop     ebp
.text$mn:0000A878                 retn
.text$mn:0000A878 ?isUntitled@Buffer@@QBE_NXZ endp
.text$mn:0000A878
.text$mn:0000A878 ; ---------------------------------------------------------------------------
.text$mn:0000A879                 align 4
.text$mn:0000A879 _text$mn        ends
.text$mn:0000A879
.text$mn:0000A87C ; ===========================================================================
.text$mn:0000A87C
.text$mn:0000A87C ; Segment type: Pure code
.text$mn:0000A87C ; Segment permissions: Read/Execute
.text$mn:0000A87C _text$mn        segment para public 'CODE' use32
.text$mn:0000A87C                 assume cs:_text$mn
.text$mn:0000A87C                 ;org 0A87Ch
.text$mn:0000A87C ; COMDAT (pick any)
.text$mn:0000A87C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A87C
.text$mn:0000A87C ; =============== S U B R O U T I N E =======================================
.text$mn:0000A87C
.text$mn:0000A87C ; Attributes: bp-based frame
.text$mn:0000A87C
.text$mn:0000A87C ; bool __thiscall ScintillaEditView::isWrapRestoreNeeded(ScintillaEditView *__hidden this)
.text$mn:0000A87C                 public ?isWrapRestoreNeeded@ScintillaEditView@@QBE_NXZ
.text$mn:0000A87C ?isWrapRestoreNeeded@ScintillaEditView@@QBE_NXZ proc near
.text$mn:0000A87C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2D6Fp
.text$mn:0000A87C                                         ; Notepad_plus::notify(SCNotification *)+2DABp
.text$mn:0000A87C
.text$mn:0000A87C var_4           = dword ptr -4
.text$mn:0000A87C
.text$mn:0000A87C                 push    ebp
.text$mn:0000A87D                 mov     ebp, esp
.text$mn:0000A87F                 push    ecx
.text$mn:0000A880                 mov     [ebp+var_4], ecx
.text$mn:0000A883                 mov     eax, [ebp+var_4]
.text$mn:0000A886                 mov     al, [eax+2Dh]
.text$mn:0000A889                 mov     esp, ebp
.text$mn:0000A88B                 pop     ebp
.text$mn:0000A88C                 retn
.text$mn:0000A88C ?isWrapRestoreNeeded@ScintillaEditView@@QBE_NXZ endp
.text$mn:0000A88C
.text$mn:0000A88C ; ---------------------------------------------------------------------------
.text$mn:0000A88D                 align 10h
.text$mn:0000A88D _text$mn        ends
.text$mn:0000A88D
.text$mn:0000A890 ; ===========================================================================
.text$mn:0000A890
.text$mn:0000A890 ; Segment type: Pure code
.text$mn:0000A890 ; Segment permissions: Read/Execute
.text$mn:0000A890 _text$mn        segment para public 'CODE' use32
.text$mn:0000A890                 assume cs:_text$mn
.text$mn:0000A890                 ;org 0A890h
.text$mn:0000A890 ; COMDAT (pick any)
.text$mn:0000A890                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A890
.text$mn:0000A890 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A890
.text$mn:0000A890 ; Attributes: bp-based frame
.text$mn:0000A890
.text$mn:0000A890 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::length(void)const
.text$mn:0000A890                 public ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000A890 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000A890                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2489p
.text$mn:0000A890                                         ; Notepad_plus::notify(SCNotification *)+2546p
.text$mn:0000A890
.text$mn:0000A890 var_4           = dword ptr -4
.text$mn:0000A890
.text$mn:0000A890                 push    ebp
.text$mn:0000A891                 mov     ebp, esp
.text$mn:0000A893                 push    ecx
.text$mn:0000A894                 mov     [ebp+var_4], ecx
.text$mn:0000A897                 mov     eax, [ebp+var_4]
.text$mn:0000A89A                 mov     eax, [eax+14h]
.text$mn:0000A89D                 mov     esp, ebp
.text$mn:0000A89F                 pop     ebp
.text$mn:0000A8A0                 retn
.text$mn:0000A8A0 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:0000A8A0
.text$mn:0000A8A0 ; ---------------------------------------------------------------------------
.text$mn:0000A8A1                 align 4
.text$mn:0000A8A1 _text$mn        ends
.text$mn:0000A8A1
.text$mn:0000A8A4 ; ===========================================================================
.text$mn:0000A8A4
.text$mn:0000A8A4 ; Segment type: Pure code
.text$mn:0000A8A4 ; Segment permissions: Read/Execute
.text$mn:0000A8A4 _text$mn        segment para public 'CODE' use32
.text$mn:0000A8A4                 assume cs:_text$mn
.text$mn:0000A8A4                 ;org 0A8A4h
.text$mn:0000A8A4 ; COMDAT (pick any)
.text$mn:0000A8A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A8A4
.text$mn:0000A8A4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A8A4
.text$mn:0000A8A4 ; Attributes: bp-based frame
.text$mn:0000A8A4
.text$mn:0000A8A4 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::length(void)const
.text$mn:0000A8A4                 public ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000A8A4 ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000A8A4                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+91Ep
.text$mn:0000A8A4                                         ; Notepad_plus::notify(SCNotification *)+2A3Fp ...
.text$mn:0000A8A4
.text$mn:0000A8A4 var_4           = dword ptr -4
.text$mn:0000A8A4
.text$mn:0000A8A4                 push    ebp
.text$mn:0000A8A5                 mov     ebp, esp
.text$mn:0000A8A7                 push    ecx
.text$mn:0000A8A8                 mov     [ebp+var_4], ecx
.text$mn:0000A8AB                 mov     eax, [ebp+var_4]
.text$mn:0000A8AE                 mov     eax, [eax+14h]
.text$mn:0000A8B1                 mov     esp, ebp
.text$mn:0000A8B3                 pop     ebp
.text$mn:0000A8B4                 retn
.text$mn:0000A8B4 ?length@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:0000A8B4
.text$mn:0000A8B4 ; ---------------------------------------------------------------------------
.text$mn:0000A8B5                 align 4
.text$mn:0000A8B5 _text$mn        ends
.text$mn:0000A8B5
.text$mn:0000A8B8 ; ===========================================================================
.text$mn:0000A8B8
.text$mn:0000A8B8 ; Segment type: Pure code
.text$mn:0000A8B8 ; Segment permissions: Read/Execute
.text$mn:0000A8B8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A8B8                 assume cs:_text$mn
.text$mn:0000A8B8                 ;org 0A8B8h
.text$mn:0000A8B8 ; COMDAT (pick any)
.text$mn:0000A8B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A8B8
.text$mn:0000A8B8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A8B8
.text$mn:0000A8B8 ; Attributes: bp-based frame
.text$mn:0000A8B8
.text$mn:0000A8B8 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:0000A8B8                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:0000A8B8 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:0000A8B8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:0000A8B8
.text$mn:0000A8B8 var_4           = dword ptr -4
.text$mn:0000A8B8 Str             = dword ptr  8
.text$mn:0000A8B8
.text$mn:0000A8B8                 push    ebp
.text$mn:0000A8B9                 mov     ebp, esp
.text$mn:0000A8BB                 push    ecx
.text$mn:0000A8BC                 mov     eax, [ebp+Str]
.text$mn:0000A8BF                 movsx   ecx, byte ptr [eax]
.text$mn:0000A8C2                 test    ecx, ecx
.text$mn:0000A8C4                 jnz     short loc_A8CF
.text$mn:0000A8C6                 mov     [ebp+var_4], 0
.text$mn:0000A8CD                 jmp     short loc_A8DE
.text$mn:0000A8CF ; ---------------------------------------------------------------------------
.text$mn:0000A8CF
.text$mn:0000A8CF loc_A8CF:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000A8CF                 mov     edx, [ebp+Str]
.text$mn:0000A8D2                 push    edx             ; Str
.text$mn:0000A8D3                 call    _strlen
.text$mn:0000A8D8                 add     esp, 4
.text$mn:0000A8DB                 mov     [ebp+var_4], eax
.text$mn:0000A8DE
.text$mn:0000A8DE loc_A8DE:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000A8DE                 mov     eax, [ebp+var_4]
.text$mn:0000A8E1                 mov     esp, ebp
.text$mn:0000A8E3                 pop     ebp
.text$mn:0000A8E4                 retn
.text$mn:0000A8E4 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:0000A8E4
.text$mn:0000A8E4 ; ---------------------------------------------------------------------------
.text$mn:0000A8E5                 align 4
.text$mn:0000A8E5 _text$mn        ends
.text$mn:0000A8E5
.text$mn:0000A8E8 ; ===========================================================================
.text$mn:0000A8E8
.text$mn:0000A8E8 ; Segment type: Pure code
.text$mn:0000A8E8 ; Segment permissions: Read/Execute
.text$mn:0000A8E8 _text$mn        segment para public 'CODE' use32
.text$mn:0000A8E8                 assume cs:_text$mn
.text$mn:0000A8E8                 ;org 0A8E8h
.text$mn:0000A8E8 ; COMDAT (pick any)
.text$mn:0000A8E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A8E8
.text$mn:0000A8E8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A8E8
.text$mn:0000A8E8 ; Attributes: bp-based frame
.text$mn:0000A8E8
.text$mn:0000A8E8 ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:0000A8E8                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:0000A8E8 ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:0000A8E8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+21p
.text$mn:0000A8E8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p
.text$mn:0000A8E8
.text$mn:0000A8E8 var_4           = dword ptr -4
.text$mn:0000A8E8 Str             = dword ptr  8
.text$mn:0000A8E8
.text$mn:0000A8E8                 push    ebp
.text$mn:0000A8E9                 mov     ebp, esp
.text$mn:0000A8EB                 push    ecx
.text$mn:0000A8EC                 mov     eax, [ebp+Str]
.text$mn:0000A8EF                 movzx   ecx, word ptr [eax]
.text$mn:0000A8F2                 test    ecx, ecx
.text$mn:0000A8F4                 jnz     short loc_A8FF
.text$mn:0000A8F6                 mov     [ebp+var_4], 0
.text$mn:0000A8FD                 jmp     short loc_A90E
.text$mn:0000A8FF ; ---------------------------------------------------------------------------
.text$mn:0000A8FF
.text$mn:0000A8FF loc_A8FF:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:0000A8FF                 mov     edx, [ebp+Str]
.text$mn:0000A902                 push    edx             ; Str
.text$mn:0000A903                 call    _wcslen
.text$mn:0000A908                 add     esp, 4
.text$mn:0000A90B                 mov     [ebp+var_4], eax
.text$mn:0000A90E
.text$mn:0000A90E loc_A90E:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:0000A90E                 mov     eax, [ebp+var_4]
.text$mn:0000A911                 mov     esp, ebp
.text$mn:0000A913                 pop     ebp
.text$mn:0000A914                 retn
.text$mn:0000A914 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:0000A914
.text$mn:0000A914 ; ---------------------------------------------------------------------------
.text$mn:0000A915                 align 4
.text$mn:0000A915 _text$mn        ends
.text$mn:0000A915
.text$mn:0000A918 ; ===========================================================================
.text$mn:0000A918
.text$mn:0000A918 ; Segment type: Pure code
.text$mn:0000A918 ; Segment permissions: Read/Execute
.text$mn:0000A918 _text$mn        segment para public 'CODE' use32
.text$mn:0000A918                 assume cs:_text$mn
.text$mn:0000A918                 ;org 0A918h
.text$mn:0000A918 ; COMDAT (pick any)
.text$mn:0000A918                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A918
.text$mn:0000A918 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A918
.text$mn:0000A918 ; Attributes: bp-based frame
.text$mn:0000A918
.text$mn:0000A918 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:0000A918                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:0000A918 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:0000A918                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:0000A918
.text$mn:0000A918 var_4           = dword ptr -4
.text$mn:0000A918
.text$mn:0000A918                 push    ebp
.text$mn:0000A919                 mov     ebp, esp
.text$mn:0000A91B                 push    ecx
.text$mn:0000A91C                 mov     [ebp+var_4], ecx
.text$mn:0000A91F                 mov     eax, [ebp+var_4]
.text$mn:0000A922                 push    eax
.text$mn:0000A923                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:0000A928                 add     esp, 4
.text$mn:0000A92B                 mov     esp, ebp
.text$mn:0000A92D                 pop     ebp
.text$mn:0000A92E                 retn
.text$mn:0000A92E ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000A92E
.text$mn:0000A92E ; ---------------------------------------------------------------------------
.text$mn:0000A92F                 align 10h
.text$mn:0000A92F _text$mn        ends
.text$mn:0000A92F
.text$mn:0000A930 ; ===========================================================================
.text$mn:0000A930
.text$mn:0000A930 ; Segment type: Pure code
.text$mn:0000A930 ; Segment permissions: Read/Execute
.text$mn:0000A930 _text$mn        segment para public 'CODE' use32
.text$mn:0000A930                 assume cs:_text$mn
.text$mn:0000A930                 ;org 0A930h
.text$mn:0000A930 ; COMDAT (pick any)
.text$mn:0000A930                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A930
.text$mn:0000A930 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A930
.text$mn:0000A930 ; Attributes: bp-based frame
.text$mn:0000A930
.text$mn:0000A930 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<unsigned int>>::max_size(void)const
.text$mn:0000A930                 public ?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIXZ
.text$mn:0000A930 ?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIXZ proc near
.text$mn:0000A930                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::max_size(void)+17p
.text$mn:0000A930
.text$mn:0000A930 var_4           = dword ptr -4
.text$mn:0000A930
.text$mn:0000A930                 push    ebp
.text$mn:0000A931                 mov     ebp, esp
.text$mn:0000A933                 push    ecx
.text$mn:0000A934                 mov     [ebp+var_4], ecx
.text$mn:0000A937                 mov     eax, [ebp+var_4]
.text$mn:0000A93A                 push    eax
.text$mn:0000A93B                 call    ?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z ; std::allocator_traits<std::allocator<uint>>::max_size(std::allocator<uint> const &)
.text$mn:0000A940                 add     esp, 4
.text$mn:0000A943                 mov     esp, ebp
.text$mn:0000A945                 pop     ebp
.text$mn:0000A946                 retn
.text$mn:0000A946 ?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIXZ endp
.text$mn:0000A946
.text$mn:0000A946 ; ---------------------------------------------------------------------------
.text$mn:0000A947                 align 4
.text$mn:0000A947 _text$mn        ends
.text$mn:0000A947
.text$mn:0000A948 ; ===========================================================================
.text$mn:0000A948
.text$mn:0000A948 ; Segment type: Pure code
.text$mn:0000A948 ; Segment permissions: Read/Execute
.text$mn:0000A948 _text$mn        segment para public 'CODE' use32
.text$mn:0000A948                 assume cs:_text$mn
.text$mn:0000A948                 ;org 0A948h
.text$mn:0000A948 ; COMDAT (pick any)
.text$mn:0000A948                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A948
.text$mn:0000A948 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A948
.text$mn:0000A948 ; Attributes: bp-based frame
.text$mn:0000A948
.text$mn:0000A948 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct MenuItemUnit>>::max_size(void)const
.text$mn:0000A948                 public ?max_size@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ
.text$mn:0000A948 ?max_size@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ proc near
.text$mn:0000A948                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::max_size(void)+17p
.text$mn:0000A948
.text$mn:0000A948 var_4           = dword ptr -4
.text$mn:0000A948
.text$mn:0000A948                 push    ebp
.text$mn:0000A949                 mov     ebp, esp
.text$mn:0000A94B                 push    ecx
.text$mn:0000A94C                 mov     [ebp+var_4], ecx
.text$mn:0000A94F                 mov     eax, [ebp+var_4]
.text$mn:0000A952                 push    eax
.text$mn:0000A953                 call    ?max_size@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAIABV?$allocator@UMenuItemUnit@@@2@@Z ; std::allocator_traits<std::allocator<MenuItemUnit>>::max_size(std::allocator<MenuItemUnit> const &)
.text$mn:0000A958                 add     esp, 4
.text$mn:0000A95B                 mov     esp, ebp
.text$mn:0000A95D                 pop     ebp
.text$mn:0000A95E                 retn
.text$mn:0000A95E ?max_size@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ endp
.text$mn:0000A95E
.text$mn:0000A95E ; ---------------------------------------------------------------------------
.text$mn:0000A95F                 align 10h
.text$mn:0000A95F _text$mn        ends
.text$mn:0000A95F
.text$mn:0000A960 ; ===========================================================================
.text$mn:0000A960
.text$mn:0000A960 ; Segment type: Pure code
.text$mn:0000A960 ; Segment permissions: Read/Execute
.text$mn:0000A960 _text$mn        segment para public 'CODE' use32
.text$mn:0000A960                 assume cs:_text$mn
.text$mn:0000A960                 ;org 0A960h
.text$mn:0000A960 ; COMDAT (pick any)
.text$mn:0000A960                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A960
.text$mn:0000A960 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A960
.text$mn:0000A960 ; Attributes: bp-based frame
.text$mn:0000A960
.text$mn:0000A960 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct recordedMacroStep>>::max_size(void)const
.text$mn:0000A960                 public ?max_size@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ
.text$mn:0000A960 ?max_size@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ proc near
.text$mn:0000A960                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::max_size(void)+17p
.text$mn:0000A960
.text$mn:0000A960 var_4           = dword ptr -4
.text$mn:0000A960
.text$mn:0000A960                 push    ebp
.text$mn:0000A961                 mov     ebp, esp
.text$mn:0000A963                 push    ecx
.text$mn:0000A964                 mov     [ebp+var_4], ecx
.text$mn:0000A967                 mov     eax, [ebp+var_4]
.text$mn:0000A96A                 push    eax
.text$mn:0000A96B                 call    ?max_size@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAIABV?$allocator@UrecordedMacroStep@@@2@@Z ; std::allocator_traits<std::allocator<recordedMacroStep>>::max_size(std::allocator<recordedMacroStep> const &)
.text$mn:0000A970                 add     esp, 4
.text$mn:0000A973                 mov     esp, ebp
.text$mn:0000A975                 pop     ebp
.text$mn:0000A976                 retn
.text$mn:0000A976 ?max_size@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ endp
.text$mn:0000A976
.text$mn:0000A976 ; ---------------------------------------------------------------------------
.text$mn:0000A977                 align 4
.text$mn:0000A977 _text$mn        ends
.text$mn:0000A977
.text$mn:0000A978 ; ===========================================================================
.text$mn:0000A978
.text$mn:0000A978 ; Segment type: Pure code
.text$mn:0000A978 ; Segment permissions: Read/Execute
.text$mn:0000A978 _text$mn        segment para public 'CODE' use32
.text$mn:0000A978                 assume cs:_text$mn
.text$mn:0000A978                 ;org 0A978h
.text$mn:0000A978 ; COMDAT (pick any)
.text$mn:0000A978                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A978
.text$mn:0000A978 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A978
.text$mn:0000A978 ; Attributes: bp-based frame
.text$mn:0000A978
.text$mn:0000A978 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000A978                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:0000A978 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:0000A978                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:0000A978
.text$mn:0000A978 var_4           = dword ptr -4
.text$mn:0000A978
.text$mn:0000A978                 push    ebp
.text$mn:0000A979                 mov     ebp, esp
.text$mn:0000A97B                 push    ecx
.text$mn:0000A97C                 mov     [ebp+var_4], ecx
.text$mn:0000A97F                 mov     eax, [ebp+var_4]
.text$mn:0000A982                 push    eax
.text$mn:0000A983                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:0000A988                 add     esp, 4
.text$mn:0000A98B                 mov     esp, ebp
.text$mn:0000A98D                 pop     ebp
.text$mn:0000A98E                 retn
.text$mn:0000A98E ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000A98E
.text$mn:0000A98E ; ---------------------------------------------------------------------------
.text$mn:0000A98F                 align 10h
.text$mn:0000A98F _text$mn        ends
.text$mn:0000A98F
.text$mn:0000A990 ; ===========================================================================
.text$mn:0000A990
.text$mn:0000A990 ; Segment type: Pure code
.text$mn:0000A990 ; Segment permissions: Read/Execute
.text$mn:0000A990 _text$mn        segment para public 'CODE' use32
.text$mn:0000A990                 assume cs:_text$mn
.text$mn:0000A990                 ;org 0A990h
.text$mn:0000A990 ; COMDAT (pick any)
.text$mn:0000A990                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A990
.text$mn:0000A990 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A990
.text$mn:0000A990 ; Attributes: bp-based frame
.text$mn:0000A990
.text$mn:0000A990 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:0000A990                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:0000A990 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:0000A990                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:0000A990
.text$mn:0000A990 var_4           = dword ptr -4
.text$mn:0000A990
.text$mn:0000A990                 push    ebp
.text$mn:0000A991                 mov     ebp, esp
.text$mn:0000A993                 push    ecx
.text$mn:0000A994                 mov     [ebp+var_4], ecx
.text$mn:0000A997                 or      eax, 0FFFFFFFFh
.text$mn:0000A99A                 mov     esp, ebp
.text$mn:0000A99C                 pop     ebp
.text$mn:0000A99D                 retn
.text$mn:0000A99D ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:0000A99D
.text$mn:0000A99D ; ---------------------------------------------------------------------------
.text$mn:0000A99E                 align 10h
.text$mn:0000A99E _text$mn        ends
.text$mn:0000A99E
.text$mn:0000A9A0 ; ===========================================================================
.text$mn:0000A9A0
.text$mn:0000A9A0 ; Segment type: Pure code
.text$mn:0000A9A0 ; Segment permissions: Read/Execute
.text$mn:0000A9A0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A9A0                 assume cs:_text$mn
.text$mn:0000A9A0                 ;org 0A9A0h
.text$mn:0000A9A0 ; COMDAT (pick any)
.text$mn:0000A9A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A9A0
.text$mn:0000A9A0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9A0
.text$mn:0000A9A0 ; Attributes: bp-based frame
.text$mn:0000A9A0
.text$mn:0000A9A0 ; public: unsigned int __thiscall std::allocator<unsigned int>::max_size(void)const
.text$mn:0000A9A0                 public ?max_size@?$allocator@I@std@@QBEIXZ
.text$mn:0000A9A0 ?max_size@?$allocator@I@std@@QBEIXZ proc near
.text$mn:0000A9A0                                         ; CODE XREF: std::allocator_traits<std::allocator<uint>>::max_size(std::allocator<uint> const &)+6p
.text$mn:0000A9A0
.text$mn:0000A9A0 var_4           = dword ptr -4
.text$mn:0000A9A0
.text$mn:0000A9A0                 push    ebp
.text$mn:0000A9A1                 mov     ebp, esp
.text$mn:0000A9A3                 push    ecx
.text$mn:0000A9A4                 mov     [ebp+var_4], ecx
.text$mn:0000A9A7                 mov     eax, 3FFFFFFFh
.text$mn:0000A9AC                 mov     esp, ebp
.text$mn:0000A9AE                 pop     ebp
.text$mn:0000A9AF                 retn
.text$mn:0000A9AF ?max_size@?$allocator@I@std@@QBEIXZ endp
.text$mn:0000A9AF
.text$mn:0000A9AF _text$mn        ends
.text$mn:0000A9AF
.text$mn:0000A9B0 ; ===========================================================================
.text$mn:0000A9B0
.text$mn:0000A9B0 ; Segment type: Pure code
.text$mn:0000A9B0 ; Segment permissions: Read/Execute
.text$mn:0000A9B0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A9B0                 assume cs:_text$mn
.text$mn:0000A9B0                 ;org 0A9B0h
.text$mn:0000A9B0 ; COMDAT (pick any)
.text$mn:0000A9B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A9B0
.text$mn:0000A9B0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9B0
.text$mn:0000A9B0 ; Attributes: bp-based frame
.text$mn:0000A9B0
.text$mn:0000A9B0 ; public: unsigned int __thiscall std::allocator<struct MenuItemUnit>::max_size(void)const
.text$mn:0000A9B0                 public ?max_size@?$allocator@UMenuItemUnit@@@std@@QBEIXZ
.text$mn:0000A9B0 ?max_size@?$allocator@UMenuItemUnit@@@std@@QBEIXZ proc near
.text$mn:0000A9B0                                         ; CODE XREF: std::allocator_traits<std::allocator<MenuItemUnit>>::max_size(std::allocator<MenuItemUnit> const &)+6p
.text$mn:0000A9B0
.text$mn:0000A9B0 var_4           = dword ptr -4
.text$mn:0000A9B0
.text$mn:0000A9B0                 push    ebp
.text$mn:0000A9B1                 mov     ebp, esp
.text$mn:0000A9B3                 push    ecx
.text$mn:0000A9B4                 mov     [ebp+var_4], ecx
.text$mn:0000A9B7                 mov     eax, 4444444h
.text$mn:0000A9BC                 mov     esp, ebp
.text$mn:0000A9BE                 pop     ebp
.text$mn:0000A9BF                 retn
.text$mn:0000A9BF ?max_size@?$allocator@UMenuItemUnit@@@std@@QBEIXZ endp
.text$mn:0000A9BF
.text$mn:0000A9BF _text$mn        ends
.text$mn:0000A9BF
.text$mn:0000A9C0 ; ===========================================================================
.text$mn:0000A9C0
.text$mn:0000A9C0 ; Segment type: Pure code
.text$mn:0000A9C0 ; Segment permissions: Read/Execute
.text$mn:0000A9C0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A9C0                 assume cs:_text$mn
.text$mn:0000A9C0                 ;org 0A9C0h
.text$mn:0000A9C0 ; COMDAT (pick any)
.text$mn:0000A9C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A9C0
.text$mn:0000A9C0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9C0
.text$mn:0000A9C0 ; Attributes: bp-based frame
.text$mn:0000A9C0
.text$mn:0000A9C0 ; public: unsigned int __thiscall std::allocator<struct recordedMacroStep>::max_size(void)const
.text$mn:0000A9C0                 public ?max_size@?$allocator@UrecordedMacroStep@@@std@@QBEIXZ
.text$mn:0000A9C0 ?max_size@?$allocator@UrecordedMacroStep@@@std@@QBEIXZ proc near
.text$mn:0000A9C0                                         ; CODE XREF: std::allocator_traits<std::allocator<recordedMacroStep>>::max_size(std::allocator<recordedMacroStep> const &)+6p
.text$mn:0000A9C0
.text$mn:0000A9C0 var_4           = dword ptr -4
.text$mn:0000A9C0
.text$mn:0000A9C0                 push    ebp
.text$mn:0000A9C1                 mov     ebp, esp
.text$mn:0000A9C3                 push    ecx
.text$mn:0000A9C4                 mov     [ebp+var_4], ecx
.text$mn:0000A9C7                 mov     eax, 5D1745Dh
.text$mn:0000A9CC                 mov     esp, ebp
.text$mn:0000A9CE                 pop     ebp
.text$mn:0000A9CF                 retn
.text$mn:0000A9CF ?max_size@?$allocator@UrecordedMacroStep@@@std@@QBEIXZ endp
.text$mn:0000A9CF
.text$mn:0000A9CF _text$mn        ends
.text$mn:0000A9CF
.text$mn:0000A9D0 ; ===========================================================================
.text$mn:0000A9D0
.text$mn:0000A9D0 ; Segment type: Pure code
.text$mn:0000A9D0 ; Segment permissions: Read/Execute
.text$mn:0000A9D0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A9D0                 assume cs:_text$mn
.text$mn:0000A9D0                 ;org 0A9D0h
.text$mn:0000A9D0 ; COMDAT (pick any)
.text$mn:0000A9D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A9D0
.text$mn:0000A9D0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9D0
.text$mn:0000A9D0 ; Attributes: bp-based frame
.text$mn:0000A9D0
.text$mn:0000A9D0 ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:0000A9D0                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:0000A9D0 ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:0000A9D0                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:0000A9D0
.text$mn:0000A9D0 var_4           = dword ptr -4
.text$mn:0000A9D0
.text$mn:0000A9D0                 push    ebp
.text$mn:0000A9D1                 mov     ebp, esp
.text$mn:0000A9D3                 push    ecx
.text$mn:0000A9D4                 mov     [ebp+var_4], ecx
.text$mn:0000A9D7                 mov     eax, 7FFFFFFFh
.text$mn:0000A9DC                 mov     esp, ebp
.text$mn:0000A9DE                 pop     ebp
.text$mn:0000A9DF                 retn
.text$mn:0000A9DF ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:0000A9DF
.text$mn:0000A9DF _text$mn        ends
.text$mn:0000A9DF
.text$mn:0000A9E0 ; ===========================================================================
.text$mn:0000A9E0
.text$mn:0000A9E0 ; Segment type: Pure code
.text$mn:0000A9E0 ; Segment permissions: Read/Execute
.text$mn:0000A9E0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A9E0                 assume cs:_text$mn
.text$mn:0000A9E0                 ;org 0A9E0h
.text$mn:0000A9E0 ; COMDAT (pick any)
.text$mn:0000A9E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A9E0
.text$mn:0000A9E0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9E0
.text$mn:0000A9E0 ; Attributes: bp-based frame
.text$mn:0000A9E0
.text$mn:0000A9E0 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:0000A9E0                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:0000A9E0 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:0000A9E0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:0000A9E0
.text$mn:0000A9E0 arg_0           = dword ptr  8
.text$mn:0000A9E0
.text$mn:0000A9E0                 push    ebp
.text$mn:0000A9E1                 mov     ebp, esp
.text$mn:0000A9E3                 mov     ecx, [ebp+arg_0]
.text$mn:0000A9E6                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:0000A9EB                 pop     ebp
.text$mn:0000A9EC                 retn
.text$mn:0000A9EC ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:0000A9EC
.text$mn:0000A9EC ; ---------------------------------------------------------------------------
.text$mn:0000A9ED                 align 10h
.text$mn:0000A9ED _text$mn        ends
.text$mn:0000A9ED
.text$mn:0000A9F0 ; ===========================================================================
.text$mn:0000A9F0
.text$mn:0000A9F0 ; Segment type: Pure code
.text$mn:0000A9F0 ; Segment permissions: Read/Execute
.text$mn:0000A9F0 _text$mn        segment para public 'CODE' use32
.text$mn:0000A9F0                 assume cs:_text$mn
.text$mn:0000A9F0                 ;org 0A9F0h
.text$mn:0000A9F0 ; COMDAT (pick any)
.text$mn:0000A9F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000A9F0
.text$mn:0000A9F0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000A9F0
.text$mn:0000A9F0 ; Attributes: bp-based frame
.text$mn:0000A9F0
.text$mn:0000A9F0 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<unsigned int>>::max_size(class std::allocator<unsigned int> const &)
.text$mn:0000A9F0                 public ?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z
.text$mn:0000A9F0 ?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z proc near
.text$mn:0000A9F0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uint>>::max_size(void)+Bp
.text$mn:0000A9F0
.text$mn:0000A9F0 arg_0           = dword ptr  8
.text$mn:0000A9F0
.text$mn:0000A9F0                 push    ebp
.text$mn:0000A9F1                 mov     ebp, esp
.text$mn:0000A9F3                 mov     ecx, [ebp+arg_0]
.text$mn:0000A9F6                 call    ?max_size@?$allocator@I@std@@QBEIXZ ; std::allocator<uint>::max_size(void)
.text$mn:0000A9FB                 pop     ebp
.text$mn:0000A9FC                 retn
.text$mn:0000A9FC ?max_size@?$allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z endp
.text$mn:0000A9FC
.text$mn:0000A9FC ; ---------------------------------------------------------------------------
.text$mn:0000A9FD                 align 10h
.text$mn:0000A9FD _text$mn        ends
.text$mn:0000A9FD
.text$mn:0000AA00 ; ===========================================================================
.text$mn:0000AA00
.text$mn:0000AA00 ; Segment type: Pure code
.text$mn:0000AA00 ; Segment permissions: Read/Execute
.text$mn:0000AA00 _text$mn        segment para public 'CODE' use32
.text$mn:0000AA00                 assume cs:_text$mn
.text$mn:0000AA00                 ;org 0AA00h
.text$mn:0000AA00 ; COMDAT (pick any)
.text$mn:0000AA00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AA00
.text$mn:0000AA00 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA00
.text$mn:0000AA00 ; Attributes: bp-based frame
.text$mn:0000AA00
.text$mn:0000AA00 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct MenuItemUnit>>::max_size(class std::allocator<struct MenuItemUnit> const &)
.text$mn:0000AA00                 public ?max_size@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAIABV?$allocator@UMenuItemUnit@@@2@@Z
.text$mn:0000AA00 ?max_size@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAIABV?$allocator@UMenuItemUnit@@@2@@Z proc near
.text$mn:0000AA00                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<MenuItemUnit>>::max_size(void)+Bp
.text$mn:0000AA00
.text$mn:0000AA00 arg_0           = dword ptr  8
.text$mn:0000AA00
.text$mn:0000AA00                 push    ebp
.text$mn:0000AA01                 mov     ebp, esp
.text$mn:0000AA03                 mov     ecx, [ebp+arg_0]
.text$mn:0000AA06                 call    ?max_size@?$allocator@UMenuItemUnit@@@std@@QBEIXZ ; std::allocator<MenuItemUnit>::max_size(void)
.text$mn:0000AA0B                 pop     ebp
.text$mn:0000AA0C                 retn
.text$mn:0000AA0C ?max_size@?$allocator_traits@V?$allocator@UMenuItemUnit@@@std@@@std@@SAIABV?$allocator@UMenuItemUnit@@@2@@Z endp
.text$mn:0000AA0C
.text$mn:0000AA0C ; ---------------------------------------------------------------------------
.text$mn:0000AA0D                 align 10h
.text$mn:0000AA0D _text$mn        ends
.text$mn:0000AA0D
.text$mn:0000AA10 ; ===========================================================================
.text$mn:0000AA10
.text$mn:0000AA10 ; Segment type: Pure code
.text$mn:0000AA10 ; Segment permissions: Read/Execute
.text$mn:0000AA10 _text$mn        segment para public 'CODE' use32
.text$mn:0000AA10                 assume cs:_text$mn
.text$mn:0000AA10                 ;org 0AA10h
.text$mn:0000AA10 ; COMDAT (pick any)
.text$mn:0000AA10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AA10
.text$mn:0000AA10 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA10
.text$mn:0000AA10 ; Attributes: bp-based frame
.text$mn:0000AA10
.text$mn:0000AA10 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct recordedMacroStep>>::max_size(class std::allocator<struct recordedMacroStep> const &)
.text$mn:0000AA10                 public ?max_size@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAIABV?$allocator@UrecordedMacroStep@@@2@@Z
.text$mn:0000AA10 ?max_size@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAIABV?$allocator@UrecordedMacroStep@@@2@@Z proc near
.text$mn:0000AA10                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<recordedMacroStep>>::max_size(void)+Bp
.text$mn:0000AA10
.text$mn:0000AA10 arg_0           = dword ptr  8
.text$mn:0000AA10
.text$mn:0000AA10                 push    ebp
.text$mn:0000AA11                 mov     ebp, esp
.text$mn:0000AA13                 mov     ecx, [ebp+arg_0]
.text$mn:0000AA16                 call    ?max_size@?$allocator@UrecordedMacroStep@@@std@@QBEIXZ ; std::allocator<recordedMacroStep>::max_size(void)
.text$mn:0000AA1B                 pop     ebp
.text$mn:0000AA1C                 retn
.text$mn:0000AA1C ?max_size@?$allocator_traits@V?$allocator@UrecordedMacroStep@@@std@@@std@@SAIABV?$allocator@UrecordedMacroStep@@@2@@Z endp
.text$mn:0000AA1C
.text$mn:0000AA1C ; ---------------------------------------------------------------------------
.text$mn:0000AA1D                 align 10h
.text$mn:0000AA1D _text$mn        ends
.text$mn:0000AA1D
.text$mn:0000AA20 ; ===========================================================================
.text$mn:0000AA20
.text$mn:0000AA20 ; Segment type: Pure code
.text$mn:0000AA20 ; Segment permissions: Read/Execute
.text$mn:0000AA20 _text$mn        segment para public 'CODE' use32
.text$mn:0000AA20                 assume cs:_text$mn
.text$mn:0000AA20                 ;org 0AA20h
.text$mn:0000AA20 ; COMDAT (pick any)
.text$mn:0000AA20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AA20
.text$mn:0000AA20 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA20
.text$mn:0000AA20 ; Attributes: bp-based frame
.text$mn:0000AA20
.text$mn:0000AA20 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:0000AA20                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:0000AA20 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:0000AA20                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:0000AA20
.text$mn:0000AA20 arg_0           = dword ptr  8
.text$mn:0000AA20
.text$mn:0000AA20                 push    ebp
.text$mn:0000AA21                 mov     ebp, esp
.text$mn:0000AA23                 mov     ecx, [ebp+arg_0]
.text$mn:0000AA26                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:0000AA2B                 pop     ebp
.text$mn:0000AA2C                 retn
.text$mn:0000AA2C ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:0000AA2C
.text$mn:0000AA2C ; ---------------------------------------------------------------------------
.text$mn:0000AA2D                 align 10h
.text$mn:0000AA2D _text$mn        ends
.text$mn:0000AA2D
.text$mn:0000AA30 ; ===========================================================================
.text$mn:0000AA30
.text$mn:0000AA30 ; Segment type: Pure code
.text$mn:0000AA30 ; Segment permissions: Read/Execute
.text$mn:0000AA30 _text$mn        segment para public 'CODE' use32
.text$mn:0000AA30                 assume cs:_text$mn
.text$mn:0000AA30                 ;org 0AA30h
.text$mn:0000AA30 ; COMDAT (pick any)
.text$mn:0000AA30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AA30
.text$mn:0000AA30 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA30
.text$mn:0000AA30 ; Attributes: bp-based frame
.text$mn:0000AA30
.text$mn:0000AA30 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:0000AA30                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000AA30 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000AA30                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:0000AA30                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000AA30
.text$mn:0000AA30 var_10          = dword ptr -10h
.text$mn:0000AA30 var_C           = dword ptr -0Ch
.text$mn:0000AA30 var_8           = dword ptr -8
.text$mn:0000AA30 var_1           = byte ptr -1
.text$mn:0000AA30
.text$mn:0000AA30                 push    ebp
.text$mn:0000AA31                 mov     ebp, esp
.text$mn:0000AA33                 sub     esp, 10h
.text$mn:0000AA36                 mov     [ebp+var_10], ecx
.text$mn:0000AA39                 lea     eax, [ebp+var_1]
.text$mn:0000AA3C                 push    eax
.text$mn:0000AA3D                 mov     ecx, [ebp+var_10]
.text$mn:0000AA40                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000AA45                 mov     ecx, eax
.text$mn:0000AA47                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:0000AA4C                 mov     [ebp+var_8], eax
.text$mn:0000AA4F                 cmp     [ebp+var_8], 1
.text$mn:0000AA53                 ja      short loc_AA5E
.text$mn:0000AA55                 mov     [ebp+var_C], 1
.text$mn:0000AA5C                 jmp     short loc_AA67
.text$mn:0000AA5E ; ---------------------------------------------------------------------------
.text$mn:0000AA5E
.text$mn:0000AA5E loc_AA5E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:0000AA5E                 mov     ecx, [ebp+var_8]
.text$mn:0000AA61                 sub     ecx, 1
.text$mn:0000AA64                 mov     [ebp+var_C], ecx
.text$mn:0000AA67
.text$mn:0000AA67 loc_AA67:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:0000AA67                 mov     eax, [ebp+var_C]
.text$mn:0000AA6A                 mov     esp, ebp
.text$mn:0000AA6C                 pop     ebp
.text$mn:0000AA6D                 retn
.text$mn:0000AA6D ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:0000AA6D
.text$mn:0000AA6D ; ---------------------------------------------------------------------------
.text$mn:0000AA6E                 align 10h
.text$mn:0000AA6E _text$mn        ends
.text$mn:0000AA6E
.text$mn:0000AA70 ; ===========================================================================
.text$mn:0000AA70
.text$mn:0000AA70 ; Segment type: Pure code
.text$mn:0000AA70 ; Segment permissions: Read/Execute
.text$mn:0000AA70 _text$mn        segment para public 'CODE' use32
.text$mn:0000AA70                 assume cs:_text$mn
.text$mn:0000AA70                 ;org 0AA70h
.text$mn:0000AA70 ; COMDAT (pick any)
.text$mn:0000AA70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AA70
.text$mn:0000AA70 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AA70
.text$mn:0000AA70 ; Attributes: bp-based frame
.text$mn:0000AA70
.text$mn:0000AA70 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000AA70                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000AA70 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000AA70                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:0000AA70                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000AA70
.text$mn:0000AA70 var_10          = dword ptr -10h
.text$mn:0000AA70 var_C           = dword ptr -0Ch
.text$mn:0000AA70 var_8           = dword ptr -8
.text$mn:0000AA70 var_1           = byte ptr -1
.text$mn:0000AA70
.text$mn:0000AA70                 push    ebp
.text$mn:0000AA71                 mov     ebp, esp
.text$mn:0000AA73                 sub     esp, 10h
.text$mn:0000AA76                 mov     [ebp+var_10], ecx
.text$mn:0000AA79                 lea     eax, [ebp+var_1]
.text$mn:0000AA7C                 push    eax
.text$mn:0000AA7D                 mov     ecx, [ebp+var_10]
.text$mn:0000AA80                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000AA85                 mov     ecx, eax
.text$mn:0000AA87                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:0000AA8C                 mov     [ebp+var_8], eax
.text$mn:0000AA8F                 cmp     [ebp+var_8], 1
.text$mn:0000AA93                 ja      short loc_AA9E
.text$mn:0000AA95                 mov     [ebp+var_C], 1
.text$mn:0000AA9C                 jmp     short loc_AAA7
.text$mn:0000AA9E ; ---------------------------------------------------------------------------
.text$mn:0000AA9E
.text$mn:0000AA9E loc_AA9E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:0000AA9E                 mov     ecx, [ebp+var_8]
.text$mn:0000AAA1                 sub     ecx, 1
.text$mn:0000AAA4                 mov     [ebp+var_C], ecx
.text$mn:0000AAA7
.text$mn:0000AAA7 loc_AAA7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:0000AAA7                 mov     eax, [ebp+var_C]
.text$mn:0000AAAA                 mov     esp, ebp
.text$mn:0000AAAC                 pop     ebp
.text$mn:0000AAAD                 retn
.text$mn:0000AAAD ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:0000AAAD
.text$mn:0000AAAD ; ---------------------------------------------------------------------------
.text$mn:0000AAAE                 align 10h
.text$mn:0000AAAE _text$mn        ends
.text$mn:0000AAAE
.text$mn:0000AAB0 ; ===========================================================================
.text$mn:0000AAB0
.text$mn:0000AAB0 ; Segment type: Pure code
.text$mn:0000AAB0 ; Segment permissions: Read/Execute
.text$mn:0000AAB0 _text$mn        segment para public 'CODE' use32
.text$mn:0000AAB0                 assume cs:_text$mn
.text$mn:0000AAB0                 ;org 0AAB0h
.text$mn:0000AAB0 ; COMDAT (pick any)
.text$mn:0000AAB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AAB0
.text$mn:0000AAB0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AAB0
.text$mn:0000AAB0 ; Attributes: bp-based frame
.text$mn:0000AAB0
.text$mn:0000AAB0 ; public: unsigned int __thiscall std::deque<unsigned int, class std::allocator<unsigned int>>::max_size(void)const
.text$mn:0000AAB0                 public ?max_size@?$deque@IV?$allocator@I@std@@@std@@QBEIXZ
.text$mn:0000AAB0 ?max_size@?$deque@IV?$allocator@I@std@@@std@@QBEIXZ proc near
.text$mn:0000AAB0                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Growmap(uint)+56p
.text$mn:0000AAB0
.text$mn:0000AAB0 var_8           = dword ptr -8
.text$mn:0000AAB0 var_1           = byte ptr -1
.text$mn:0000AAB0
.text$mn:0000AAB0                 push    ebp
.text$mn:0000AAB1                 mov     ebp, esp
.text$mn:0000AAB3                 sub     esp, 8
.text$mn:0000AAB6                 mov     [ebp+var_8], ecx
.text$mn:0000AAB9                 lea     eax, [ebp+var_1]
.text$mn:0000AABC                 push    eax
.text$mn:0000AABD                 mov     ecx, [ebp+var_8]
.text$mn:0000AAC0                 call    ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000AAC5                 mov     ecx, eax
.text$mn:0000AAC7                 call    ?max_size@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<uint>>::max_size(void)
.text$mn:0000AACC                 mov     esp, ebp
.text$mn:0000AACE                 pop     ebp
.text$mn:0000AACF                 retn
.text$mn:0000AACF ?max_size@?$deque@IV?$allocator@I@std@@@std@@QBEIXZ endp
.text$mn:0000AACF
.text$mn:0000AACF _text$mn        ends
.text$mn:0000AACF
.text$mn:0000AAD0 ; ===========================================================================
.text$mn:0000AAD0
.text$mn:0000AAD0 ; Segment type: Pure code
.text$mn:0000AAD0 ; Segment permissions: Read/Execute
.text$mn:0000AAD0 _text$mn        segment para public 'CODE' use32
.text$mn:0000AAD0                 assume cs:_text$mn
.text$mn:0000AAD0                 ;org 0AAD0h
.text$mn:0000AAD0 ; COMDAT (pick any)
.text$mn:0000AAD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AAD0
.text$mn:0000AAD0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AAD0
.text$mn:0000AAD0 ; Attributes: bp-based frame
.text$mn:0000AAD0
.text$mn:0000AAD0 ; public: unsigned int __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::max_size(void)const
.text$mn:0000AAD0                 public ?max_size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ
.text$mn:0000AAD0 ?max_size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ proc near
.text$mn:0000AAD0                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Grow_to(uint)+17p
.text$mn:0000AAD0                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+18p
.text$mn:0000AAD0
.text$mn:0000AAD0 var_8           = dword ptr -8
.text$mn:0000AAD0 var_1           = byte ptr -1
.text$mn:0000AAD0
.text$mn:0000AAD0                 push    ebp
.text$mn:0000AAD1                 mov     ebp, esp
.text$mn:0000AAD3                 sub     esp, 8
.text$mn:0000AAD6                 mov     [ebp+var_8], ecx
.text$mn:0000AAD9                 lea     eax, [ebp+var_1]
.text$mn:0000AADC                 push    eax
.text$mn:0000AADD                 mov     ecx, [ebp+var_8]
.text$mn:0000AAE0                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:0000AAE5                 mov     ecx, eax
.text$mn:0000AAE7                 call    ?max_size@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::max_size(void)
.text$mn:0000AAEC                 mov     esp, ebp
.text$mn:0000AAEE                 pop     ebp
.text$mn:0000AAEF                 retn
.text$mn:0000AAEF ?max_size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ endp
.text$mn:0000AAEF
.text$mn:0000AAEF _text$mn        ends
.text$mn:0000AAEF
.text$mn:0000AAF0 ; ===========================================================================
.text$mn:0000AAF0
.text$mn:0000AAF0 ; Segment type: Pure code
.text$mn:0000AAF0 ; Segment permissions: Read/Execute
.text$mn:0000AAF0 _text$mn        segment para public 'CODE' use32
.text$mn:0000AAF0                 assume cs:_text$mn
.text$mn:0000AAF0                 ;org 0AAF0h
.text$mn:0000AAF0 ; COMDAT (pick any)
.text$mn:0000AAF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AAF0
.text$mn:0000AAF0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AAF0
.text$mn:0000AAF0 ; Attributes: bp-based frame
.text$mn:0000AAF0
.text$mn:0000AAF0 ; public: unsigned int __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::max_size(void)const
.text$mn:0000AAF0                 public ?max_size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ
.text$mn:0000AAF0 ?max_size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ proc near
.text$mn:0000AAF0                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Grow_to(uint)+17p
.text$mn:0000AAF0                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reserve(uint)+18p
.text$mn:0000AAF0
.text$mn:0000AAF0 var_8           = dword ptr -8
.text$mn:0000AAF0 var_1           = byte ptr -1
.text$mn:0000AAF0
.text$mn:0000AAF0                 push    ebp
.text$mn:0000AAF1                 mov     ebp, esp
.text$mn:0000AAF3                 sub     esp, 8
.text$mn:0000AAF6                 mov     [ebp+var_8], ecx
.text$mn:0000AAF9                 lea     eax, [ebp+var_1]
.text$mn:0000AAFC                 push    eax
.text$mn:0000AAFD                 mov     ecx, [ebp+var_8]
.text$mn:0000AB00                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:0000AB05                 mov     ecx, eax
.text$mn:0000AB07                 call    ?max_size@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::max_size(void)
.text$mn:0000AB0C                 mov     esp, ebp
.text$mn:0000AB0E                 pop     ebp
.text$mn:0000AB0F                 retn
.text$mn:0000AB0F ?max_size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ endp
.text$mn:0000AB0F
.text$mn:0000AB0F _text$mn        ends
.text$mn:0000AB0F
.text$mn:0000AB10 ; ===========================================================================
.text$mn:0000AB10
.text$mn:0000AB10 ; Segment type: Pure code
.text$mn:0000AB10 ; Segment permissions: Read/Execute
.text$mn:0000AB10 _text$mn        segment para public 'CODE' use32
.text$mn:0000AB10                 assume cs:_text$mn
.text$mn:0000AB10                 ;org 0AB10h
.text$mn:0000AB10 ; COMDAT (pick any)
.text$mn:0000AB10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AB10
.text$mn:0000AB10 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AB10
.text$mn:0000AB10 ; Attributes: bp-based frame
.text$mn:0000AB10
.text$mn:0000AB10 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:0000AB10                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000AB10 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000AB10                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:0000AB10                                         ; DATA XREF: .rdata:0000C41Co
.text$mn:0000AB10
.text$mn:0000AB10 var_1C          = dword ptr -1Ch
.text$mn:0000AB10 var_18          = dword ptr -18h
.text$mn:0000AB10 Str             = dword ptr -14h
.text$mn:0000AB10 var_10          = dword ptr -10h
.text$mn:0000AB10 var_C           = dword ptr -0Ch
.text$mn:0000AB10 var_4           = dword ptr -4
.text$mn:0000AB10 arg_0           = dword ptr  8
.text$mn:0000AB10 arg_4           = dword ptr  0Ch
.text$mn:0000AB10
.text$mn:0000AB10                 push    ebp
.text$mn:0000AB11                 mov     ebp, esp
.text$mn:0000AB13                 push    0FFFFFFFFh
.text$mn:0000AB15                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000AB1A                 mov     eax, large fs:0
.text$mn:0000AB20                 push    eax
.text$mn:0000AB21                 sub     esp, 10h
.text$mn:0000AB24                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000AB29                 xor     eax, ebp
.text$mn:0000AB2B                 push    eax
.text$mn:0000AB2C                 lea     eax, [ebp+var_C]
.text$mn:0000AB2F                 mov     large fs:0, eax
.text$mn:0000AB35                 mov     [ebp+var_1C], ecx
.text$mn:0000AB38                 mov     [ebp+var_18], 0
.text$mn:0000AB3F                 mov     eax, [ebp+arg_4]
.text$mn:0000AB42                 push    eax             ; int
.text$mn:0000AB43                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:0000AB48                 add     esp, 4
.text$mn:0000AB4B                 mov     [ebp+var_10], eax
.text$mn:0000AB4E                 cmp     [ebp+var_10], 0
.text$mn:0000AB52                 jz      short loc_AB5C
.text$mn:0000AB54                 mov     ecx, [ebp+var_10]
.text$mn:0000AB57                 mov     [ebp+Str], ecx
.text$mn:0000AB5A                 jmp     short loc_AB63
.text$mn:0000AB5C ; ---------------------------------------------------------------------------
.text$mn:0000AB5C
.text$mn:0000AB5C loc_AB5C:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:0000AB5C                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000AB63
.text$mn:0000AB63 loc_AB63:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000AB63                 mov     edx, [ebp+Str]
.text$mn:0000AB66                 push    edx             ; Str
.text$mn:0000AB67                 mov     ecx, [ebp+arg_0]
.text$mn:0000AB6A                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000AB6F                 mov     [ebp+var_4], 0
.text$mn:0000AB76                 mov     eax, [ebp+var_18]
.text$mn:0000AB79                 or      eax, 1
.text$mn:0000AB7C                 mov     [ebp+var_18], eax
.text$mn:0000AB7F                 mov     eax, [ebp+arg_0]
.text$mn:0000AB82                 mov     ecx, [ebp+var_C]
.text$mn:0000AB85                 mov     large fs:0, ecx
.text$mn:0000AB8C                 pop     ecx
.text$mn:0000AB8D                 mov     esp, ebp
.text$mn:0000AB8F                 pop     ebp
.text$mn:0000AB90                 retn    8
.text$mn:0000AB90 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000AB90
.text$mn:0000AB90 ; ---------------------------------------------------------------------------
.text$mn:0000AB93                 align 4
.text$mn:0000AB93 _text$mn        ends
.text$mn:0000AB93
.text$x:0000AB94 ; ===========================================================================
.text$x:0000AB94
.text$x:0000AB94 ; Segment type: Pure code
.text$x:0000AB94 ; Segment permissions: Read/Execute
.text$x:0000AB94 _text$x         segment para public 'CODE' use32
.text$x:0000AB94                 assume cs:_text$x
.text$x:0000AB94                 ;org 0AB94h
.text$x:0000AB94 ; COMDAT (pick associative to section at AB10)
.text$x:0000AB94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000AB94
.text$x:0000AB94 ; =============== S U B R O U T I N E =======================================
.text$x:0000AB94
.text$x:0000AB94
.text$x:0000AB94 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000AB94                                         ; DATA XREF: .xdata$x:0000B6D4o
.text$x:0000AB94                 mov     eax, [ebp-18h]
.text$x:0000AB97                 and     eax, 1
.text$x:0000AB9A                 jz      $LN6
.text$x:0000ABA0                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000ABA4                 mov     ecx, [ebp+8]
.text$x:0000ABA7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000ABAC ; ---------------------------------------------------------------------------
.text$x:0000ABAC
.text$x:0000ABAC $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000ABAC                 retn
.text$x:0000ABAC __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000ABAC
.text$x:0000ABAD
.text$x:0000ABAD ; =============== S U B R O U T I N E =======================================
.text$x:0000ABAD
.text$x:0000ABAD
.text$x:0000ABAD __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000ABAD                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:0000ABAD
.text$x:0000ABAD arg_4           = dword ptr  8
.text$x:0000ABAD
.text$x:0000ABAD                 mov     edx, [esp+arg_4]
.text$x:0000ABB1                 lea     eax, [edx+0Ch]
.text$x:0000ABB4                 mov     ecx, [edx-14h]
.text$x:0000ABB7                 xor     ecx, eax
.text$x:0000ABB9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000ABBE                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000ABC3                 jmp     ___CxxFrameHandler3
.text$x:0000ABC3 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000ABC3
.text$x:0000ABC3 _text$x         ends
.text$x:0000ABC3
.text$mn:0000ABC8 ; ===========================================================================
.text$mn:0000ABC8
.text$mn:0000ABC8 ; Segment type: Pure code
.text$mn:0000ABC8 ; Segment permissions: Read/Execute
.text$mn:0000ABC8 _text$mn        segment para public 'CODE' use32
.text$mn:0000ABC8                 assume cs:_text$mn
.text$mn:0000ABC8                 ;org 0ABC8h
.text$mn:0000ABC8 ; COMDAT (pick any)
.text$mn:0000ABC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ABC8
.text$mn:0000ABC8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ABC8
.text$mn:0000ABC8 ; Attributes: bp-based frame
.text$mn:0000ABC8
.text$mn:0000ABC8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:0000ABC8                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000ABC8 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000ABC8                                         ; DATA XREF: .rdata:0000C450o
.text$mn:0000ABC8
.text$mn:0000ABC8 var_14          = dword ptr -14h
.text$mn:0000ABC8 var_10          = dword ptr -10h
.text$mn:0000ABC8 var_C           = dword ptr -0Ch
.text$mn:0000ABC8 var_4           = dword ptr -4
.text$mn:0000ABC8 arg_0           = dword ptr  8
.text$mn:0000ABC8 arg_4           = dword ptr  0Ch
.text$mn:0000ABC8
.text$mn:0000ABC8                 push    ebp
.text$mn:0000ABC9                 mov     ebp, esp
.text$mn:0000ABCB                 push    0FFFFFFFFh
.text$mn:0000ABCD                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000ABD2                 mov     eax, large fs:0
.text$mn:0000ABD8                 push    eax
.text$mn:0000ABD9                 sub     esp, 8
.text$mn:0000ABDC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000ABE1                 xor     eax, ebp
.text$mn:0000ABE3                 push    eax
.text$mn:0000ABE4                 lea     eax, [ebp+var_C]
.text$mn:0000ABE7                 mov     large fs:0, eax
.text$mn:0000ABED                 mov     [ebp+var_14], ecx
.text$mn:0000ABF0                 mov     [ebp+var_10], 0
.text$mn:0000ABF7                 cmp     [ebp+arg_4], 1
.text$mn:0000ABFB                 jnz     short loc_AC21
.text$mn:0000ABFD                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:0000AC02                 mov     ecx, [ebp+arg_0]
.text$mn:0000AC05                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000AC0A                 mov     [ebp+var_4], 0
.text$mn:0000AC11                 mov     eax, [ebp+var_10]
.text$mn:0000AC14                 or      eax, 1
.text$mn:0000AC17                 mov     [ebp+var_10], eax
.text$mn:0000AC1A                 mov     eax, [ebp+arg_0]
.text$mn:0000AC1D                 jmp     short loc_AC44
.text$mn:0000AC1F ; ---------------------------------------------------------------------------
.text$mn:0000AC1F                 jmp     short loc_AC44
.text$mn:0000AC21 ; ---------------------------------------------------------------------------
.text$mn:0000AC21
.text$mn:0000AC21 loc_AC21:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:0000AC21                 mov     ecx, [ebp+arg_4]
.text$mn:0000AC24                 push    ecx
.text$mn:0000AC25                 mov     edx, [ebp+arg_0]
.text$mn:0000AC28                 push    edx
.text$mn:0000AC29                 mov     ecx, [ebp+var_14]
.text$mn:0000AC2C                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:0000AC31                 mov     [ebp+var_4], 0
.text$mn:0000AC38                 mov     eax, [ebp+var_10]
.text$mn:0000AC3B                 or      eax, 1
.text$mn:0000AC3E                 mov     [ebp+var_10], eax
.text$mn:0000AC41                 mov     eax, [ebp+arg_0]
.text$mn:0000AC44
.text$mn:0000AC44 loc_AC44:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:0000AC44                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:0000AC44                 mov     ecx, [ebp+var_C]
.text$mn:0000AC47                 mov     large fs:0, ecx
.text$mn:0000AC4E                 pop     ecx
.text$mn:0000AC4F                 mov     esp, ebp
.text$mn:0000AC51                 pop     ebp
.text$mn:0000AC52                 retn    8
.text$mn:0000AC52 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000AC52
.text$mn:0000AC52 ; ---------------------------------------------------------------------------
.text$mn:0000AC55                 align 4
.text$mn:0000AC55 _text$mn        ends
.text$mn:0000AC55
.text$x:0000AC58 ; ===========================================================================
.text$x:0000AC58
.text$x:0000AC58 ; Segment type: Pure code
.text$x:0000AC58 ; Segment permissions: Read/Execute
.text$x:0000AC58 _text$x         segment para public 'CODE' use32
.text$x:0000AC58                 assume cs:_text$x
.text$x:0000AC58                 ;org 0AC58h
.text$x:0000AC58 ; COMDAT (pick associative to section at ABC8)
.text$x:0000AC58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000AC58
.text$x:0000AC58 ; =============== S U B R O U T I N E =======================================
.text$x:0000AC58
.text$x:0000AC58
.text$x:0000AC58 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000AC58                                         ; DATA XREF: .xdata$x:0000B758o
.text$x:0000AC58                 mov     eax, [ebp-10h]
.text$x:0000AC5B                 and     eax, 1
.text$x:0000AC5E                 jz      $LN6_0
.text$x:0000AC64                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000AC68                 mov     ecx, [ebp+8]
.text$x:0000AC6B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000AC70 ; ---------------------------------------------------------------------------
.text$x:0000AC70
.text$x:0000AC70 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000AC70                 retn
.text$x:0000AC70 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000AC70
.text$x:0000AC71
.text$x:0000AC71 ; =============== S U B R O U T I N E =======================================
.text$x:0000AC71
.text$x:0000AC71
.text$x:0000AC71 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000AC71                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:0000AC71
.text$x:0000AC71 arg_4           = dword ptr  8
.text$x:0000AC71
.text$x:0000AC71                 mov     edx, [esp+arg_4]
.text$x:0000AC75                 lea     eax, [edx+0Ch]
.text$x:0000AC78                 mov     ecx, [edx-0Ch]
.text$x:0000AC7B                 xor     ecx, eax
.text$x:0000AC7D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AC82                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000AC87                 jmp     ___CxxFrameHandler3
.text$x:0000AC87 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000AC87
.text$x:0000AC87 _text$x         ends
.text$x:0000AC87
.text$mn:0000AC8C ; ===========================================================================
.text$mn:0000AC8C
.text$mn:0000AC8C ; Segment type: Pure code
.text$mn:0000AC8C ; Segment permissions: Read/Execute
.text$mn:0000AC8C _text$mn        segment para public 'CODE' use32
.text$mn:0000AC8C                 assume cs:_text$mn
.text$mn:0000AC8C                 ;org 0AC8Ch
.text$mn:0000AC8C ; COMDAT (pick any)
.text$mn:0000AC8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AC8C
.text$mn:0000AC8C ; =============== S U B R O U T I N E =======================================
.text$mn:0000AC8C
.text$mn:0000AC8C ; Attributes: bp-based frame
.text$mn:0000AC8C
.text$mn:0000AC8C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:0000AC8C                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000AC8C ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000AC8C                                         ; DATA XREF: .rdata:0000C490o
.text$mn:0000AC8C
.text$mn:0000AC8C var_1C          = dword ptr -1Ch
.text$mn:0000AC8C var_18          = dword ptr -18h
.text$mn:0000AC8C Str             = dword ptr -14h
.text$mn:0000AC8C var_10          = dword ptr -10h
.text$mn:0000AC8C var_C           = dword ptr -0Ch
.text$mn:0000AC8C var_4           = dword ptr -4
.text$mn:0000AC8C arg_0           = dword ptr  8
.text$mn:0000AC8C arg_4           = dword ptr  0Ch
.text$mn:0000AC8C
.text$mn:0000AC8C                 push    ebp
.text$mn:0000AC8D                 mov     ebp, esp
.text$mn:0000AC8F                 push    0FFFFFFFFh
.text$mn:0000AC91                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000AC96                 mov     eax, large fs:0
.text$mn:0000AC9C                 push    eax
.text$mn:0000AC9D                 sub     esp, 10h
.text$mn:0000ACA0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000ACA5                 xor     eax, ebp
.text$mn:0000ACA7                 push    eax
.text$mn:0000ACA8                 lea     eax, [ebp+var_C]
.text$mn:0000ACAB                 mov     large fs:0, eax
.text$mn:0000ACB1                 mov     [ebp+var_1C], ecx
.text$mn:0000ACB4                 mov     [ebp+var_18], 0
.text$mn:0000ACBB                 mov     eax, [ebp+arg_4]
.text$mn:0000ACBE                 push    eax             ; int
.text$mn:0000ACBF                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:0000ACC4                 add     esp, 4
.text$mn:0000ACC7                 mov     [ebp+var_10], eax
.text$mn:0000ACCA                 cmp     [ebp+var_10], 0
.text$mn:0000ACCE                 jz      short loc_ACD8
.text$mn:0000ACD0                 mov     ecx, [ebp+var_10]
.text$mn:0000ACD3                 mov     [ebp+Str], ecx
.text$mn:0000ACD6                 jmp     short loc_ACDF
.text$mn:0000ACD8 ; ---------------------------------------------------------------------------
.text$mn:0000ACD8
.text$mn:0000ACD8 loc_ACD8:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:0000ACD8                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000ACDF
.text$mn:0000ACDF loc_ACDF:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:0000ACDF                 mov     edx, [ebp+Str]
.text$mn:0000ACE2                 push    edx             ; Str
.text$mn:0000ACE3                 mov     ecx, [ebp+arg_0]
.text$mn:0000ACE6                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000ACEB                 mov     [ebp+var_4], 0
.text$mn:0000ACF2                 mov     eax, [ebp+var_18]
.text$mn:0000ACF5                 or      eax, 1
.text$mn:0000ACF8                 mov     [ebp+var_18], eax
.text$mn:0000ACFB                 mov     eax, [ebp+arg_0]
.text$mn:0000ACFE                 mov     ecx, [ebp+var_C]
.text$mn:0000AD01                 mov     large fs:0, ecx
.text$mn:0000AD08                 pop     ecx
.text$mn:0000AD09                 mov     esp, ebp
.text$mn:0000AD0B                 pop     ebp
.text$mn:0000AD0C                 retn    8
.text$mn:0000AD0C ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000AD0C
.text$mn:0000AD0C ; ---------------------------------------------------------------------------
.text$mn:0000AD0F                 align 10h
.text$mn:0000AD0F _text$mn        ends
.text$mn:0000AD0F
.text$x:0000AD10 ; ===========================================================================
.text$x:0000AD10
.text$x:0000AD10 ; Segment type: Pure code
.text$x:0000AD10 ; Segment permissions: Read/Execute
.text$x:0000AD10 _text$x         segment para public 'CODE' use32
.text$x:0000AD10                 assume cs:_text$x
.text$x:0000AD10                 ;org 0AD10h
.text$x:0000AD10 ; COMDAT (pick associative to section at AC8C)
.text$x:0000AD10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000AD10
.text$x:0000AD10 ; =============== S U B R O U T I N E =======================================
.text$x:0000AD10
.text$x:0000AD10
.text$x:0000AD10 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000AD10                                         ; DATA XREF: .xdata$x:0000B7DCo
.text$x:0000AD10                 mov     eax, [ebp-18h]
.text$x:0000AD13                 and     eax, 1
.text$x:0000AD16                 jz      $LN6_1
.text$x:0000AD1C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000AD20                 mov     ecx, [ebp+8]
.text$x:0000AD23                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000AD28 ; ---------------------------------------------------------------------------
.text$x:0000AD28
.text$x:0000AD28 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000AD28                 retn
.text$x:0000AD28 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000AD28
.text$x:0000AD29
.text$x:0000AD29 ; =============== S U B R O U T I N E =======================================
.text$x:0000AD29
.text$x:0000AD29
.text$x:0000AD29 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000AD29                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:0000AD29
.text$x:0000AD29 arg_4           = dword ptr  8
.text$x:0000AD29
.text$x:0000AD29                 mov     edx, [esp+arg_4]
.text$x:0000AD2D                 lea     eax, [edx+0Ch]
.text$x:0000AD30                 mov     ecx, [edx-14h]
.text$x:0000AD33                 xor     ecx, eax
.text$x:0000AD35                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000AD3A                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000AD3F                 jmp     ___CxxFrameHandler3
.text$x:0000AD3F __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000AD3F
.text$x:0000AD3F _text$x         ends
.text$x:0000AD3F
.text$mn:0000AD44 ; ===========================================================================
.text$mn:0000AD44
.text$mn:0000AD44 ; Segment type: Pure code
.text$mn:0000AD44 ; Segment permissions: Read/Execute
.text$mn:0000AD44 _text$mn        segment para public 'CODE' use32
.text$mn:0000AD44                 assume cs:_text$mn
.text$mn:0000AD44                 ;org 0AD44h
.text$mn:0000AD44 ; COMDAT (pick any)
.text$mn:0000AD44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AD44
.text$mn:0000AD44 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AD44
.text$mn:0000AD44 ; Attributes: bp-based frame
.text$mn:0000AD44
.text$mn:0000AD44 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:0000AD44                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:0000AD44 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:0000AD44                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:0000AD44
.text$mn:0000AD44 var_4           = dword ptr -4
.text$mn:0000AD44 Dst             = dword ptr  8
.text$mn:0000AD44 Src             = dword ptr  0Ch
.text$mn:0000AD44 Size            = dword ptr  10h
.text$mn:0000AD44
.text$mn:0000AD44                 push    ebp
.text$mn:0000AD45                 mov     ebp, esp
.text$mn:0000AD47                 push    ecx
.text$mn:0000AD48                 cmp     [ebp+Size], 0
.text$mn:0000AD4C                 jnz     short loc_AD56
.text$mn:0000AD4E                 mov     eax, [ebp+Dst]
.text$mn:0000AD51                 mov     [ebp+var_4], eax
.text$mn:0000AD54                 jmp     short loc_AD6D
.text$mn:0000AD56 ; ---------------------------------------------------------------------------
.text$mn:0000AD56
.text$mn:0000AD56 loc_AD56:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:0000AD56                 mov     ecx, [ebp+Size]
.text$mn:0000AD59                 push    ecx             ; Size
.text$mn:0000AD5A                 mov     edx, [ebp+Src]
.text$mn:0000AD5D                 push    edx             ; Src
.text$mn:0000AD5E                 mov     eax, [ebp+Dst]
.text$mn:0000AD61                 push    eax             ; Dst
.text$mn:0000AD62                 call    _memmove
.text$mn:0000AD67                 add     esp, 0Ch
.text$mn:0000AD6A                 mov     [ebp+var_4], eax
.text$mn:0000AD6D
.text$mn:0000AD6D loc_AD6D:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:0000AD6D                 mov     eax, [ebp+var_4]
.text$mn:0000AD70                 mov     esp, ebp
.text$mn:0000AD72                 pop     ebp
.text$mn:0000AD73                 retn
.text$mn:0000AD73 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000AD73
.text$mn:0000AD73 _text$mn        ends
.text$mn:0000AD73
.text$mn:0000AD74 ; ===========================================================================
.text$mn:0000AD74
.text$mn:0000AD74 ; Segment type: Pure code
.text$mn:0000AD74 ; Segment permissions: Read/Execute
.text$mn:0000AD74 _text$mn        segment para public 'CODE' use32
.text$mn:0000AD74                 assume cs:_text$mn
.text$mn:0000AD74                 ;org 0AD74h
.text$mn:0000AD74 ; COMDAT (pick any)
.text$mn:0000AD74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AD74
.text$mn:0000AD74 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AD74
.text$mn:0000AD74 ; Attributes: bp-based frame
.text$mn:0000AD74
.text$mn:0000AD74 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:0000AD74                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:0000AD74 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:0000AD74                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:0000AD74
.text$mn:0000AD74 var_4           = dword ptr -4
.text$mn:0000AD74 Dst             = dword ptr  8
.text$mn:0000AD74 Src             = dword ptr  0Ch
.text$mn:0000AD74 arg_8           = dword ptr  10h
.text$mn:0000AD74
.text$mn:0000AD74                 push    ebp
.text$mn:0000AD75                 mov     ebp, esp
.text$mn:0000AD77                 push    ecx
.text$mn:0000AD78                 cmp     [ebp+arg_8], 0
.text$mn:0000AD7C                 jnz     short loc_AD86
.text$mn:0000AD7E                 mov     eax, [ebp+Dst]
.text$mn:0000AD81                 mov     [ebp+var_4], eax
.text$mn:0000AD84                 jmp     short loc_AD9D
.text$mn:0000AD86 ; ---------------------------------------------------------------------------
.text$mn:0000AD86
.text$mn:0000AD86 loc_AD86:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:0000AD86                 mov     ecx, [ebp+arg_8]
.text$mn:0000AD89                 push    ecx             ; int
.text$mn:0000AD8A                 mov     edx, [ebp+Src]
.text$mn:0000AD8D                 push    edx             ; Src
.text$mn:0000AD8E                 mov     eax, [ebp+Dst]
.text$mn:0000AD91                 push    eax             ; Dst
.text$mn:0000AD92                 call    _wmemmove
.text$mn:0000AD97                 add     esp, 0Ch
.text$mn:0000AD9A                 mov     [ebp+var_4], eax
.text$mn:0000AD9D
.text$mn:0000AD9D loc_AD9D:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000AD9D                 mov     eax, [ebp+var_4]
.text$mn:0000ADA0                 mov     esp, ebp
.text$mn:0000ADA2                 pop     ebp
.text$mn:0000ADA3                 retn
.text$mn:0000ADA3 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000ADA3
.text$mn:0000ADA3 _text$mn        ends
.text$mn:0000ADA3
.text$mn:0000ADA4 ; ===========================================================================
.text$mn:0000ADA4
.text$mn:0000ADA4 ; Segment type: Pure code
.text$mn:0000ADA4 ; Segment permissions: Read/Execute
.text$mn:0000ADA4 _text$mn        segment para public 'CODE' use32
.text$mn:0000ADA4                 assume cs:_text$mn
.text$mn:0000ADA4                 ;org 0ADA4h
.text$mn:0000ADA4 ; COMDAT (pick any)
.text$mn:0000ADA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ADA4
.text$mn:0000ADA4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ADA4
.text$mn:0000ADA4 ; Attributes: bp-based frame
.text$mn:0000ADA4
.text$mn:0000ADA4 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:0000ADA4                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:0000ADA4 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:0000ADA4                                         ; DATA XREF: .rdata:0000C418o
.text$mn:0000ADA4
.text$mn:0000ADA4 var_4           = dword ptr -4
.text$mn:0000ADA4
.text$mn:0000ADA4                 push    ebp
.text$mn:0000ADA5                 mov     ebp, esp
.text$mn:0000ADA7                 push    ecx
.text$mn:0000ADA8                 mov     [ebp+var_4], ecx
.text$mn:0000ADAB                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:0000ADB0                 mov     esp, ebp
.text$mn:0000ADB2                 pop     ebp
.text$mn:0000ADB3                 retn
.text$mn:0000ADB3 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000ADB3
.text$mn:0000ADB3 _text$mn        ends
.text$mn:0000ADB3
.text$mn:0000ADB4 ; ===========================================================================
.text$mn:0000ADB4
.text$mn:0000ADB4 ; Segment type: Pure code
.text$mn:0000ADB4 ; Segment permissions: Read/Execute
.text$mn:0000ADB4 _text$mn        segment para public 'CODE' use32
.text$mn:0000ADB4                 assume cs:_text$mn
.text$mn:0000ADB4                 ;org 0ADB4h
.text$mn:0000ADB4 ; COMDAT (pick any)
.text$mn:0000ADB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ADB4
.text$mn:0000ADB4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ADB4
.text$mn:0000ADB4 ; Attributes: bp-based frame
.text$mn:0000ADB4
.text$mn:0000ADB4 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:0000ADB4                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:0000ADB4 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:0000ADB4                                         ; DATA XREF: .rdata:0000C44Co
.text$mn:0000ADB4
.text$mn:0000ADB4 var_4           = dword ptr -4
.text$mn:0000ADB4
.text$mn:0000ADB4                 push    ebp
.text$mn:0000ADB5                 mov     ebp, esp
.text$mn:0000ADB7                 push    ecx
.text$mn:0000ADB8                 mov     [ebp+var_4], ecx
.text$mn:0000ADBB                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:0000ADC0                 mov     esp, ebp
.text$mn:0000ADC2                 pop     ebp
.text$mn:0000ADC3                 retn
.text$mn:0000ADC3 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000ADC3
.text$mn:0000ADC3 _text$mn        ends
.text$mn:0000ADC3
.text$mn:0000ADC4 ; ===========================================================================
.text$mn:0000ADC4
.text$mn:0000ADC4 ; Segment type: Pure code
.text$mn:0000ADC4 ; Segment permissions: Read/Execute
.text$mn:0000ADC4 _text$mn        segment para public 'CODE' use32
.text$mn:0000ADC4                 assume cs:_text$mn
.text$mn:0000ADC4                 ;org 0ADC4h
.text$mn:0000ADC4 ; COMDAT (pick any)
.text$mn:0000ADC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ADC4
.text$mn:0000ADC4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ADC4
.text$mn:0000ADC4 ; Attributes: bp-based frame
.text$mn:0000ADC4
.text$mn:0000ADC4 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:0000ADC4                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:0000ADC4 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:0000ADC4                                         ; DATA XREF: .rdata:0000C48Co
.text$mn:0000ADC4
.text$mn:0000ADC4 var_4           = dword ptr -4
.text$mn:0000ADC4
.text$mn:0000ADC4                 push    ebp
.text$mn:0000ADC5                 mov     ebp, esp
.text$mn:0000ADC7                 push    ecx
.text$mn:0000ADC8                 mov     [ebp+var_4], ecx
.text$mn:0000ADCB                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:0000ADD0                 mov     esp, ebp
.text$mn:0000ADD2                 pop     ebp
.text$mn:0000ADD3                 retn
.text$mn:0000ADD3 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000ADD3
.text$mn:0000ADD3 _text$mn        ends
.text$mn:0000ADD3
.text$mn:0000ADD4 ; ===========================================================================
.text$mn:0000ADD4
.text$mn:0000ADD4 ; Segment type: Pure code
.text$mn:0000ADD4 ; Segment permissions: Read/Execute
.text$mn:0000ADD4 _text$mn        segment para public 'CODE' use32
.text$mn:0000ADD4                 assume cs:_text$mn
.text$mn:0000ADD4                 ;org 0ADD4h
.text$mn:0000ADD4 ; COMDAT (pick any)
.text$mn:0000ADD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ADD4
.text$mn:0000ADD4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000ADD4
.text$mn:0000ADD4 ; Attributes: bp-based frame
.text$mn:0000ADD4
.text$mn:0000ADD4 ; int __thiscall VerticalFileSwitcher::nbSelectedFiles(VerticalFileSwitcher *__hidden this)
.text$mn:0000ADD4                 public ?nbSelectedFiles@VerticalFileSwitcher@@QBEHXZ
.text$mn:0000ADD4 ?nbSelectedFiles@VerticalFileSwitcher@@QBEHXZ proc near
.text$mn:0000ADD4                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+1303p
.text$mn:0000ADD4
.text$mn:0000ADD4 var_4           = dword ptr -4
.text$mn:0000ADD4
.text$mn:0000ADD4                 push    ebp
.text$mn:0000ADD5                 mov     ebp, esp
.text$mn:0000ADD7                 push    ecx
.text$mn:0000ADD8                 mov     [ebp+var_4], ecx
.text$mn:0000ADDB                 mov     ecx, [ebp+var_4]
.text$mn:0000ADDE                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:0000ADE1                 call    ?nbSelectedFiles@VerticalFileSwitcherListView@@QBEHXZ ; VerticalFileSwitcherListView::nbSelectedFiles(void)
.text$mn:0000ADE6                 mov     esp, ebp
.text$mn:0000ADE8                 pop     ebp
.text$mn:0000ADE9                 retn
.text$mn:0000ADE9 ?nbSelectedFiles@VerticalFileSwitcher@@QBEHXZ endp
.text$mn:0000ADE9
.text$mn:0000ADE9 ; ---------------------------------------------------------------------------
.text$mn:0000ADEA                 align 4
.text$mn:0000ADEA _text$mn        ends
.text$mn:0000ADEA
.text$mn:0000ADEC ; ===========================================================================
.text$mn:0000ADEC
.text$mn:0000ADEC ; Segment type: Pure code
.text$mn:0000ADEC ; Segment permissions: Read/Execute
.text$mn:0000ADEC _text$mn        segment para public 'CODE' use32
.text$mn:0000ADEC                 assume cs:_text$mn
.text$mn:0000ADEC                 ;org 0ADECh
.text$mn:0000ADEC ; COMDAT (pick any)
.text$mn:0000ADEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000ADEC
.text$mn:0000ADEC ; =============== S U B R O U T I N E =======================================
.text$mn:0000ADEC
.text$mn:0000ADEC ; Attributes: bp-based frame
.text$mn:0000ADEC
.text$mn:0000ADEC ; int __thiscall VerticalFileSwitcherListView::nbSelectedFiles(VerticalFileSwitcherListView *__hidden this)
.text$mn:0000ADEC                 public ?nbSelectedFiles@VerticalFileSwitcherListView@@QBEHXZ
.text$mn:0000ADEC ?nbSelectedFiles@VerticalFileSwitcherListView@@QBEHXZ proc near
.text$mn:0000ADEC                                         ; CODE XREF: VerticalFileSwitcher::nbSelectedFiles(void)+Dp
.text$mn:0000ADEC
.text$mn:0000ADEC var_4           = dword ptr -4
.text$mn:0000ADEC
.text$mn:0000ADEC                 push    ebp
.text$mn:0000ADED                 mov     ebp, esp
.text$mn:0000ADEF                 push    ecx
.text$mn:0000ADF0                 mov     [ebp+var_4], ecx
.text$mn:0000ADF3                 push    0               ; lParam
.text$mn:0000ADF5                 push    0               ; wParam
.text$mn:0000ADF7                 push    1032h           ; Msg
.text$mn:0000ADFC                 mov     eax, [ebp+var_4]
.text$mn:0000ADFF                 mov     ecx, [eax+0Ch]
.text$mn:0000AE02                 push    ecx             ; hWnd
.text$mn:0000AE03                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000AE09                 mov     esp, ebp
.text$mn:0000AE0B                 pop     ebp
.text$mn:0000AE0C                 retn
.text$mn:0000AE0C ?nbSelectedFiles@VerticalFileSwitcherListView@@QBEHXZ endp
.text$mn:0000AE0C
.text$mn:0000AE0C ; ---------------------------------------------------------------------------
.text$mn:0000AE0D                 align 10h
.text$mn:0000AE0D _text$mn        ends
.text$mn:0000AE0D
.text$mn:0000AE10 ; ===========================================================================
.text$mn:0000AE10
.text$mn:0000AE10 ; Segment type: Pure code
.text$mn:0000AE10 ; Segment permissions: Read/Execute
.text$mn:0000AE10 _text$mn        segment para public 'CODE' use32
.text$mn:0000AE10                 assume cs:_text$mn
.text$mn:0000AE10                 ;org 0AE10h
.text$mn:0000AE10 ; COMDAT (pick any)
.text$mn:0000AE10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AE10
.text$mn:0000AE10 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE10
.text$mn:0000AE10 ; Attributes: bp-based frame
.text$mn:0000AE10
.text$mn:0000AE10 ; public: void __thiscall std::stack<unsigned int, class std::deque<unsigned int, class std::allocator<unsigned int>>>::pop(void)
.text$mn:0000AE10                 public ?pop@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAEXXZ
.text$mn:0000AE10 ?pop@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000AE10                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+25E7p
.text$mn:0000AE10
.text$mn:0000AE10 var_4           = dword ptr -4
.text$mn:0000AE10
.text$mn:0000AE10                 push    ebp
.text$mn:0000AE11                 mov     ebp, esp
.text$mn:0000AE13                 push    ecx
.text$mn:0000AE14                 mov     [ebp+var_4], ecx
.text$mn:0000AE17                 mov     ecx, [ebp+var_4]
.text$mn:0000AE1A                 call    ?pop_back@?$deque@IV?$allocator@I@std@@@std@@QAEXXZ ; std::deque<uint,std::allocator<uint>>::pop_back(void)
.text$mn:0000AE1F                 mov     esp, ebp
.text$mn:0000AE21                 pop     ebp
.text$mn:0000AE22                 retn
.text$mn:0000AE22 ?pop@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000AE22
.text$mn:0000AE22 ; ---------------------------------------------------------------------------
.text$mn:0000AE23                 align 4
.text$mn:0000AE23 _text$mn        ends
.text$mn:0000AE23
.text$mn:0000AE24 ; ===========================================================================
.text$mn:0000AE24
.text$mn:0000AE24 ; Segment type: Pure code
.text$mn:0000AE24 ; Segment permissions: Read/Execute
.text$mn:0000AE24 _text$mn        segment para public 'CODE' use32
.text$mn:0000AE24                 assume cs:_text$mn
.text$mn:0000AE24                 ;org 0AE24h
.text$mn:0000AE24 ; COMDAT (pick any)
.text$mn:0000AE24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AE24
.text$mn:0000AE24 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AE24
.text$mn:0000AE24 ; Attributes: bp-based frame
.text$mn:0000AE24
.text$mn:0000AE24 ; public: void __thiscall std::deque<unsigned int, class std::allocator<unsigned int>>::pop_back(void)
.text$mn:0000AE24                 public ?pop_back@?$deque@IV?$allocator@I@std@@@std@@QAEXXZ
.text$mn:0000AE24 ?pop_back@?$deque@IV?$allocator@I@std@@@std@@QAEXXZ proc near
.text$mn:0000AE24                                         ; CODE XREF: std::deque<uint,std::allocator<uint>>::_Tidy(void)+30p
.text$mn:0000AE24                                         ; std::stack<uint,std::deque<uint,std::allocator<uint>>>::pop(void)+Ap
.text$mn:0000AE24
.text$mn:0000AE24 var_14          = dword ptr -14h
.text$mn:0000AE24 var_10          = dword ptr -10h
.text$mn:0000AE24 var_C           = dword ptr -0Ch
.text$mn:0000AE24 var_8           = dword ptr -8
.text$mn:0000AE24 var_1           = byte ptr -1
.text$mn:0000AE24
.text$mn:0000AE24                 push    ebp
.text$mn:0000AE25                 mov     ebp, esp
.text$mn:0000AE27                 sub     esp, 14h
.text$mn:0000AE2A                 push    esi
.text$mn:0000AE2B                 mov     [ebp+var_8], ecx
.text$mn:0000AE2E                 mov     ecx, [ebp+var_8]
.text$mn:0000AE31                 call    ?empty@?$deque@IV?$allocator@I@std@@@std@@QBE_NXZ ; std::deque<uint,std::allocator<uint>>::empty(void)
.text$mn:0000AE36                 movzx   eax, al
.text$mn:0000AE39                 test    eax, eax
.text$mn:0000AE3B                 jz      short loc_AE59
.text$mn:0000AE3D                 push    5C2h            ; unsigned int
.text$mn:0000AE42                 push    offset ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000AE47                 push    offset ??_C@_1CO@FNIDKHMC@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@ ; "deque empty before pop"
.text$mn:0000AE4C                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000AE51                 add     esp, 0Ch
.text$mn:0000AE54                 jmp     loc_AEDB
.text$mn:0000AE59 ; ---------------------------------------------------------------------------
.text$mn:0000AE59
.text$mn:0000AE59 loc_AE59:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::pop_back(void)+17j
.text$mn:0000AE59                 mov     ecx, [ebp+var_8]
.text$mn:0000AE5C                 mov     edx, [ecx+0Ch]
.text$mn:0000AE5F                 mov     eax, [ebp+var_8]
.text$mn:0000AE62                 mov     ecx, [eax+10h]
.text$mn:0000AE65                 lea     edx, [edx+ecx-1]
.text$mn:0000AE69                 mov     [ebp+var_C], edx
.text$mn:0000AE6C                 mov     eax, [ebp+var_C]
.text$mn:0000AE6F                 push    eax
.text$mn:0000AE70                 mov     ecx, [ebp+var_8]
.text$mn:0000AE73                 call    ?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z ; std::deque<uint,std::allocator<uint>>::_Orphan_off(uint)
.text$mn:0000AE78                 mov     ecx, [ebp+var_C]
.text$mn:0000AE7B                 push    ecx
.text$mn:0000AE7C                 mov     ecx, [ebp+var_8]
.text$mn:0000AE7F                 call    ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<uint>>::_Getblock(uint)
.text$mn:0000AE84                 mov     [ebp+var_14], eax
.text$mn:0000AE87                 mov     edx, [ebp+var_8]
.text$mn:0000AE8A                 mov     ecx, [edx+4]
.text$mn:0000AE8D                 mov     eax, [ebp+var_C]
.text$mn:0000AE90                 xor     edx, edx
.text$mn:0000AE92                 mov     esi, 4
.text$mn:0000AE97                 div     esi
.text$mn:0000AE99                 mov     eax, [ebp+var_14]
.text$mn:0000AE9C                 mov     ecx, [ecx+eax*4]
.text$mn:0000AE9F                 lea     edx, [ecx+edx*4]
.text$mn:0000AEA2                 push    edx
.text$mn:0000AEA3                 lea     eax, [ebp+var_1]
.text$mn:0000AEA6                 push    eax
.text$mn:0000AEA7                 mov     ecx, [ebp+var_8]
.text$mn:0000AEAA                 call    ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000AEAF                 mov     ecx, eax
.text$mn:0000AEB1                 call    ??$destroy@I@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAI@Z ; std::_Wrap_alloc<std::allocator<uint>>::destroy<uint>(uint *)
.text$mn:0000AEB6                 mov     ecx, [ebp+var_8]
.text$mn:0000AEB9                 mov     edx, [ecx+10h]
.text$mn:0000AEBC                 sub     edx, 1
.text$mn:0000AEBF                 mov     [ebp+var_10], edx
.text$mn:0000AEC2                 mov     eax, [ebp+var_8]
.text$mn:0000AEC5                 mov     ecx, [ebp+var_10]
.text$mn:0000AEC8                 mov     [eax+10h], ecx
.text$mn:0000AECB                 cmp     [ebp+var_10], 0
.text$mn:0000AECF                 jnz     short loc_AEDB
.text$mn:0000AED1                 mov     edx, [ebp+var_8]
.text$mn:0000AED4                 mov     dword ptr [edx+0Ch], 0
.text$mn:0000AEDB
.text$mn:0000AEDB loc_AEDB:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::pop_back(void)+30j
.text$mn:0000AEDB                                         ; std::deque<uint,std::allocator<uint>>::pop_back(void)+ABj
.text$mn:0000AEDB                 pop     esi
.text$mn:0000AEDC                 mov     esp, ebp
.text$mn:0000AEDE                 pop     ebp
.text$mn:0000AEDF                 retn
.text$mn:0000AEDF ?pop_back@?$deque@IV?$allocator@I@std@@@std@@QAEXXZ endp
.text$mn:0000AEDF
.text$mn:0000AEDF _text$mn        ends
.text$mn:0000AEDF
.text$mn:0000AEE0 ; ===========================================================================
.text$mn:0000AEE0
.text$mn:0000AEE0 ; Segment type: Pure code
.text$mn:0000AEE0 ; Segment permissions: Read/Execute
.text$mn:0000AEE0 _text$mn        segment para public 'CODE' use32
.text$mn:0000AEE0                 assume cs:_text$mn
.text$mn:0000AEE0                 ;org 0AEE0h
.text$mn:0000AEE0 ; COMDAT (pick any)
.text$mn:0000AEE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AEE0
.text$mn:0000AEE0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AEE0
.text$mn:0000AEE0 ; Attributes: bp-based frame
.text$mn:0000AEE0
.text$mn:0000AEE0 ; public: void __thiscall std::stack<unsigned int, class std::deque<unsigned int, class std::allocator<unsigned int>>>::push(unsigned int const &)
.text$mn:0000AEE0                 public ?push@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAEXABI@Z
.text$mn:0000AEE0 ?push@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAEXABI@Z proc near
.text$mn:0000AEE0                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2587p
.text$mn:0000AEE0
.text$mn:0000AEE0 var_4           = dword ptr -4
.text$mn:0000AEE0 arg_0           = dword ptr  8
.text$mn:0000AEE0
.text$mn:0000AEE0                 push    ebp
.text$mn:0000AEE1                 mov     ebp, esp
.text$mn:0000AEE3                 push    ecx
.text$mn:0000AEE4                 mov     [ebp+var_4], ecx
.text$mn:0000AEE7                 mov     eax, [ebp+arg_0]
.text$mn:0000AEEA                 push    eax
.text$mn:0000AEEB                 mov     ecx, [ebp+var_4]
.text$mn:0000AEEE                 call    ?push_back@?$deque@IV?$allocator@I@std@@@std@@QAEXABI@Z ; std::deque<uint,std::allocator<uint>>::push_back(uint const &)
.text$mn:0000AEF3                 mov     esp, ebp
.text$mn:0000AEF5                 pop     ebp
.text$mn:0000AEF6                 retn    4
.text$mn:0000AEF6 ?push@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAEXABI@Z endp
.text$mn:0000AEF6
.text$mn:0000AEF6 ; ---------------------------------------------------------------------------
.text$mn:0000AEF9                 align 4
.text$mn:0000AEF9 _text$mn        ends
.text$mn:0000AEF9
.text$mn:0000AEFC ; ===========================================================================
.text$mn:0000AEFC
.text$mn:0000AEFC ; Segment type: Pure code
.text$mn:0000AEFC ; Segment permissions: Read/Execute
.text$mn:0000AEFC _text$mn        segment para public 'CODE' use32
.text$mn:0000AEFC                 assume cs:_text$mn
.text$mn:0000AEFC                 ;org 0AEFCh
.text$mn:0000AEFC ; COMDAT (pick any)
.text$mn:0000AEFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AEFC
.text$mn:0000AEFC ; =============== S U B R O U T I N E =======================================
.text$mn:0000AEFC
.text$mn:0000AEFC ; Attributes: bp-based frame
.text$mn:0000AEFC
.text$mn:0000AEFC ; public: void __thiscall std::deque<unsigned int, class std::allocator<unsigned int>>::push_back(unsigned int const &)
.text$mn:0000AEFC                 public ?push_back@?$deque@IV?$allocator@I@std@@@std@@QAEXABI@Z
.text$mn:0000AEFC ?push_back@?$deque@IV?$allocator@I@std@@@std@@QAEXABI@Z proc near
.text$mn:0000AEFC                                         ; CODE XREF: std::stack<uint,std::deque<uint,std::allocator<uint>>>::push(uint const &)+Ep
.text$mn:0000AEFC
.text$mn:0000AEFC var_10          = dword ptr -10h
.text$mn:0000AEFC var_C           = dword ptr -0Ch
.text$mn:0000AEFC var_8           = dword ptr -8
.text$mn:0000AEFC var_2           = byte ptr -2
.text$mn:0000AEFC var_1           = byte ptr -1
.text$mn:0000AEFC arg_0           = dword ptr  8
.text$mn:0000AEFC
.text$mn:0000AEFC                 push    ebp
.text$mn:0000AEFD                 mov     ebp, esp
.text$mn:0000AEFF                 sub     esp, 10h
.text$mn:0000AF02                 push    esi
.text$mn:0000AF03                 mov     [ebp+var_8], ecx
.text$mn:0000AF06                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000AF09                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000AF0E                 mov     eax, [ebp+var_8]
.text$mn:0000AF11                 mov     eax, [eax+0Ch]
.text$mn:0000AF14                 mov     ecx, [ebp+var_8]
.text$mn:0000AF17                 add     eax, [ecx+10h]
.text$mn:0000AF1A                 xor     edx, edx
.text$mn:0000AF1C                 mov     ecx, 4
.text$mn:0000AF21                 div     ecx
.text$mn:0000AF23                 test    edx, edx
.text$mn:0000AF25                 jnz     short loc_AF45
.text$mn:0000AF27                 mov     edx, [ebp+var_8]
.text$mn:0000AF2A                 mov     eax, [edx+10h]
.text$mn:0000AF2D                 add     eax, 4
.text$mn:0000AF30                 shr     eax, 2
.text$mn:0000AF33                 mov     ecx, [ebp+var_8]
.text$mn:0000AF36                 cmp     [ecx+8], eax
.text$mn:0000AF39                 ja      short loc_AF45
.text$mn:0000AF3B                 push    1
.text$mn:0000AF3D                 mov     ecx, [ebp+var_8]
.text$mn:0000AF40                 call    ?_Growmap@?$deque@IV?$allocator@I@std@@@std@@IAEXI@Z ; std::deque<uint,std::allocator<uint>>::_Growmap(uint)
.text$mn:0000AF45
.text$mn:0000AF45 loc_AF45:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::push_back(uint const &)+29j
.text$mn:0000AF45                                         ; std::deque<uint,std::allocator<uint>>::push_back(uint const &)+3Dj
.text$mn:0000AF45                 mov     edx, [ebp+var_8]
.text$mn:0000AF48                 mov     eax, [edx+8]
.text$mn:0000AF4B                 lea     ecx, ds:0FFFFFFFFh[eax*4]
.text$mn:0000AF52                 mov     edx, [ebp+var_8]
.text$mn:0000AF55                 and     ecx, [edx+0Ch]
.text$mn:0000AF58                 mov     eax, [ebp+var_8]
.text$mn:0000AF5B                 mov     [eax+0Ch], ecx
.text$mn:0000AF5E                 mov     ecx, [ebp+var_8]
.text$mn:0000AF61                 mov     edx, [ecx+0Ch]
.text$mn:0000AF64                 mov     eax, [ebp+var_8]
.text$mn:0000AF67                 add     edx, [eax+10h]
.text$mn:0000AF6A                 mov     [ebp+var_10], edx
.text$mn:0000AF6D                 mov     ecx, [ebp+var_10]
.text$mn:0000AF70                 push    ecx
.text$mn:0000AF71                 mov     ecx, [ebp+var_8]
.text$mn:0000AF74                 call    ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<uint>>::_Getblock(uint)
.text$mn:0000AF79                 mov     [ebp+var_C], eax
.text$mn:0000AF7C                 mov     edx, [ebp+var_8]
.text$mn:0000AF7F                 mov     eax, [edx+4]
.text$mn:0000AF82                 mov     ecx, [ebp+var_C]
.text$mn:0000AF85                 cmp     dword ptr [eax+ecx*4], 0
.text$mn:0000AF89                 jnz     short loc_AFAC
.text$mn:0000AF8B                 push    4
.text$mn:0000AF8D                 lea     edx, [ebp+var_1]
.text$mn:0000AF90                 push    edx
.text$mn:0000AF91                 mov     ecx, [ebp+var_8]
.text$mn:0000AF94                 call    ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000AF99                 mov     ecx, eax
.text$mn:0000AF9B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEPAII@Z ; std::_Wrap_alloc<std::allocator<uint>>::allocate(uint)
.text$mn:0000AFA0                 mov     ecx, [ebp+var_8]
.text$mn:0000AFA3                 mov     edx, [ecx+4]
.text$mn:0000AFA6                 mov     ecx, [ebp+var_C]
.text$mn:0000AFA9                 mov     [edx+ecx*4], eax
.text$mn:0000AFAC
.text$mn:0000AFAC loc_AFAC:                               ; CODE XREF: std::deque<uint,std::allocator<uint>>::push_back(uint const &)+8Dj
.text$mn:0000AFAC                 mov     edx, [ebp+arg_0]
.text$mn:0000AFAF                 push    edx             ; int
.text$mn:0000AFB0                 mov     eax, [ebp+var_8]
.text$mn:0000AFB3                 mov     ecx, [eax+4]
.text$mn:0000AFB6                 mov     eax, [ebp+var_10]
.text$mn:0000AFB9                 xor     edx, edx
.text$mn:0000AFBB                 mov     esi, 4
.text$mn:0000AFC0                 div     esi
.text$mn:0000AFC2                 mov     eax, [ebp+var_C]
.text$mn:0000AFC5                 mov     ecx, [ecx+eax*4]
.text$mn:0000AFC8                 lea     edx, [ecx+edx*4]
.text$mn:0000AFCB                 push    edx             ; void *
.text$mn:0000AFCC                 lea     eax, [ebp+var_2]
.text$mn:0000AFCF                 push    eax
.text$mn:0000AFD0                 mov     ecx, [ebp+var_8]
.text$mn:0000AFD3                 call    ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@I@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<uint,std::allocator<uint>>>::_Getal(void)
.text$mn:0000AFD8                 mov     ecx, eax
.text$mn:0000AFDA                 call    ??$construct@IABI@?$_Wrap_alloc@V?$allocator@I@std@@@std@@QAEXPAIABI@Z ; std::_Wrap_alloc<std::allocator<uint>>::construct<uint,uint const &>(uint *,uint const &)
.text$mn:0000AFDF                 mov     ecx, [ebp+var_8]
.text$mn:0000AFE2                 mov     edx, [ecx+10h]
.text$mn:0000AFE5                 add     edx, 1
.text$mn:0000AFE8                 mov     eax, [ebp+var_8]
.text$mn:0000AFEB                 mov     [eax+10h], edx
.text$mn:0000AFEE                 pop     esi
.text$mn:0000AFEF                 mov     esp, ebp
.text$mn:0000AFF1                 pop     ebp
.text$mn:0000AFF2                 retn    4
.text$mn:0000AFF2 ?push_back@?$deque@IV?$allocator@I@std@@@std@@QAEXABI@Z endp
.text$mn:0000AFF2
.text$mn:0000AFF2 ; ---------------------------------------------------------------------------
.text$mn:0000AFF5                 align 4
.text$mn:0000AFF5 _text$mn        ends
.text$mn:0000AFF5
.text$mn:0000AFF8 ; ===========================================================================
.text$mn:0000AFF8
.text$mn:0000AFF8 ; Segment type: Pure code
.text$mn:0000AFF8 ; Segment permissions: Read/Execute
.text$mn:0000AFF8 _text$mn        segment para public 'CODE' use32
.text$mn:0000AFF8                 assume cs:_text$mn
.text$mn:0000AFF8                 ;org 0AFF8h
.text$mn:0000AFF8 ; COMDAT (pick any)
.text$mn:0000AFF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000AFF8
.text$mn:0000AFF8 ; =============== S U B R O U T I N E =======================================
.text$mn:0000AFF8
.text$mn:0000AFF8 ; Attributes: bp-based frame
.text$mn:0000AFF8
.text$mn:0000AFF8 ; public: void __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::push_back(struct MenuItemUnit &&)
.text$mn:0000AFF8                 public ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z
.text$mn:0000AFF8 ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z proc near
.text$mn:0000AFF8                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+6D3p
.text$mn:0000AFF8                                         ; Notepad_plus::notify(SCNotification *)+723p ...
.text$mn:0000AFF8
.text$mn:0000AFF8 var_C           = dword ptr -0Ch
.text$mn:0000AFF8 var_8           = dword ptr -8
.text$mn:0000AFF8 var_2           = byte ptr -2
.text$mn:0000AFF8 var_1           = byte ptr -1
.text$mn:0000AFF8 arg_0           = dword ptr  8
.text$mn:0000AFF8
.text$mn:0000AFF8                 push    ebp
.text$mn:0000AFF9                 mov     ebp, esp
.text$mn:0000AFFB                 sub     esp, 0Ch
.text$mn:0000AFFE                 mov     [ebp+var_8], ecx
.text$mn:0000B001                 mov     eax, [ebp+arg_0]
.text$mn:0000B004                 push    eax
.text$mn:0000B005                 call    ??$addressof@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@AAU1@@Z ; std::addressof<MenuItemUnit>(MenuItemUnit &)
.text$mn:0000B00A                 add     esp, 4
.text$mn:0000B00D                 push    eax
.text$mn:0000B00E                 mov     ecx, [ebp+var_8]
.text$mn:0000B011                 call    ?_Inside@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBE_NPBUMenuItemUnit@@@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Inside(MenuItemUnit const *)
.text$mn:0000B016                 movzx   ecx, al
.text$mn:0000B019                 test    ecx, ecx
.text$mn:0000B01B                 jz      loc_B0AB
.text$mn:0000B021                 mov     edx, [ebp+arg_0]
.text$mn:0000B024                 push    edx
.text$mn:0000B025                 call    ??$addressof@UMenuItemUnit@@@std@@YAPAUMenuItemUnit@@AAU1@@Z ; std::addressof<MenuItemUnit>(MenuItemUnit &)
.text$mn:0000B02A                 add     esp, 4
.text$mn:0000B02D                 mov     ecx, [ebp+var_8]
.text$mn:0000B030                 sub     eax, [ecx+4]
.text$mn:0000B033                 cdq
.text$mn:0000B034                 mov     ecx, 3Ch ; '<'
.text$mn:0000B039                 idiv    ecx
.text$mn:0000B03B                 mov     [ebp+var_C], eax
.text$mn:0000B03E                 mov     edx, [ebp+var_8]
.text$mn:0000B041                 mov     eax, [ebp+var_8]
.text$mn:0000B044                 mov     ecx, [edx+8]
.text$mn:0000B047                 cmp     ecx, [eax+0Ch]
.text$mn:0000B04A                 jnz     short loc_B056
.text$mn:0000B04C                 push    1
.text$mn:0000B04E                 mov     ecx, [ebp+var_8]
.text$mn:0000B051                 call    ?_Reserve@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)
.text$mn:0000B056
.text$mn:0000B056 loc_B056:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+52j
.text$mn:0000B056                 mov     edx, [ebp+var_8]
.text$mn:0000B059                 mov     eax, [edx+8]
.text$mn:0000B05C                 push    eax
.text$mn:0000B05D                 mov     ecx, [ebp+var_8]
.text$mn:0000B060                 mov     edx, [ecx+8]
.text$mn:0000B063                 push    edx
.text$mn:0000B064                 mov     ecx, [ebp+var_8]
.text$mn:0000B067                 call    ?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)
.text$mn:0000B06C                 imul    eax, [ebp+var_C], 3Ch
.text$mn:0000B070                 mov     ecx, [ebp+var_8]
.text$mn:0000B073                 add     eax, [ecx+4]
.text$mn:0000B076                 push    eax
.text$mn:0000B077                 call    ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z ; std::forward<MenuItemUnit>(MenuItemUnit &)
.text$mn:0000B07C                 add     esp, 4
.text$mn:0000B07F                 push    eax             ; int
.text$mn:0000B080                 mov     edx, [ebp+var_8]
.text$mn:0000B083                 mov     eax, [edx+8]
.text$mn:0000B086                 push    eax             ; void *
.text$mn:0000B087                 lea     ecx, [ebp+var_1]
.text$mn:0000B08A                 push    ecx
.text$mn:0000B08B                 mov     ecx, [ebp+var_8]
.text$mn:0000B08E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:0000B093                 mov     ecx, eax
.text$mn:0000B095                 call    ??$construct@UMenuItemUnit@@U1@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)
.text$mn:0000B09A                 mov     edx, [ebp+var_8]
.text$mn:0000B09D                 mov     eax, [edx+8]
.text$mn:0000B0A0                 add     eax, 3Ch ; '<'
.text$mn:0000B0A3                 mov     ecx, [ebp+var_8]
.text$mn:0000B0A6                 mov     [ecx+8], eax
.text$mn:0000B0A9                 jmp     short loc_B10F
.text$mn:0000B0AB ; ---------------------------------------------------------------------------
.text$mn:0000B0AB
.text$mn:0000B0AB loc_B0AB:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+23j
.text$mn:0000B0AB                 mov     edx, [ebp+var_8]
.text$mn:0000B0AE                 mov     eax, [ebp+var_8]
.text$mn:0000B0B1                 mov     ecx, [edx+8]
.text$mn:0000B0B4                 cmp     ecx, [eax+0Ch]
.text$mn:0000B0B7                 jnz     short loc_B0C3
.text$mn:0000B0B9                 push    1
.text$mn:0000B0BB                 mov     ecx, [ebp+var_8]
.text$mn:0000B0BE                 call    ?_Reserve@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)
.text$mn:0000B0C3
.text$mn:0000B0C3 loc_B0C3:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+BFj
.text$mn:0000B0C3                 mov     edx, [ebp+var_8]
.text$mn:0000B0C6                 mov     eax, [edx+8]
.text$mn:0000B0C9                 push    eax
.text$mn:0000B0CA                 mov     ecx, [ebp+var_8]
.text$mn:0000B0CD                 mov     edx, [ecx+8]
.text$mn:0000B0D0                 push    edx
.text$mn:0000B0D1                 mov     ecx, [ebp+var_8]
.text$mn:0000B0D4                 call    ?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Orphan_range(MenuItemUnit *,MenuItemUnit *)
.text$mn:0000B0D9                 mov     eax, [ebp+arg_0]
.text$mn:0000B0DC                 push    eax
.text$mn:0000B0DD                 call    ??$forward@UMenuItemUnit@@@std@@YA$$QAUMenuItemUnit@@AAU1@@Z ; std::forward<MenuItemUnit>(MenuItemUnit &)
.text$mn:0000B0E2                 add     esp, 4
.text$mn:0000B0E5                 push    eax             ; int
.text$mn:0000B0E6                 mov     ecx, [ebp+var_8]
.text$mn:0000B0E9                 mov     edx, [ecx+8]
.text$mn:0000B0EC                 push    edx             ; void *
.text$mn:0000B0ED                 lea     eax, [ebp+var_2]
.text$mn:0000B0F0                 push    eax
.text$mn:0000B0F1                 mov     ecx, [ebp+var_8]
.text$mn:0000B0F4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<MenuItemUnit,std::allocator<MenuItemUnit>>>::_Getal(void)
.text$mn:0000B0F9                 mov     ecx, eax
.text$mn:0000B0FB                 call    ??$construct@UMenuItemUnit@@U1@@?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<MenuItemUnit>>::construct<MenuItemUnit,MenuItemUnit>(MenuItemUnit *,MenuItemUnit &&)
.text$mn:0000B100                 mov     ecx, [ebp+var_8]
.text$mn:0000B103                 mov     edx, [ecx+8]
.text$mn:0000B106                 add     edx, 3Ch ; '<'
.text$mn:0000B109                 mov     eax, [ebp+var_8]
.text$mn:0000B10C                 mov     [eax+8], edx
.text$mn:0000B10F
.text$mn:0000B10F loc_B10F:                               ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::push_back(MenuItemUnit &&)+B1j
.text$mn:0000B10F                 mov     esp, ebp
.text$mn:0000B111                 pop     ebp
.text$mn:0000B112                 retn    4
.text$mn:0000B112 ?push_back@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAEX$$QAUMenuItemUnit@@@Z endp
.text$mn:0000B112
.text$mn:0000B112 ; ---------------------------------------------------------------------------
.text$mn:0000B115                 align 4
.text$mn:0000B115 _text$mn        ends
.text$mn:0000B115
.text$mn:0000B118 ; ===========================================================================
.text$mn:0000B118
.text$mn:0000B118 ; Segment type: Pure code
.text$mn:0000B118 ; Segment permissions: Read/Execute
.text$mn:0000B118 _text$mn        segment para public 'CODE' use32
.text$mn:0000B118                 assume cs:_text$mn
.text$mn:0000B118                 ;org 0B118h
.text$mn:0000B118 ; COMDAT (pick any)
.text$mn:0000B118                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B118
.text$mn:0000B118 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B118
.text$mn:0000B118 ; Attributes: bp-based frame
.text$mn:0000B118
.text$mn:0000B118 ; public: void __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::push_back(struct recordedMacroStep &&)
.text$mn:0000B118                 public ?push_back@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEX$$QAUrecordedMacroStep@@@Z
.text$mn:0000B118 ?push_back@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEX$$QAUrecordedMacroStep@@@Z proc near
.text$mn:0000B118                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2D47p
.text$mn:0000B118
.text$mn:0000B118 var_C           = dword ptr -0Ch
.text$mn:0000B118 var_8           = dword ptr -8
.text$mn:0000B118 var_2           = byte ptr -2
.text$mn:0000B118 var_1           = byte ptr -1
.text$mn:0000B118 arg_0           = dword ptr  8
.text$mn:0000B118
.text$mn:0000B118                 push    ebp
.text$mn:0000B119                 mov     ebp, esp
.text$mn:0000B11B                 sub     esp, 0Ch
.text$mn:0000B11E                 mov     [ebp+var_8], ecx
.text$mn:0000B121                 mov     eax, [ebp+arg_0]
.text$mn:0000B124                 push    eax
.text$mn:0000B125                 call    ??$addressof@UrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@AAU1@@Z ; std::addressof<recordedMacroStep>(recordedMacroStep &)
.text$mn:0000B12A                 add     esp, 4
.text$mn:0000B12D                 push    eax
.text$mn:0000B12E                 mov     ecx, [ebp+var_8]
.text$mn:0000B131                 call    ?_Inside@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBE_NPBUrecordedMacroStep@@@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Inside(recordedMacroStep const *)
.text$mn:0000B136                 movzx   ecx, al
.text$mn:0000B139                 test    ecx, ecx
.text$mn:0000B13B                 jz      loc_B1CB
.text$mn:0000B141                 mov     edx, [ebp+arg_0]
.text$mn:0000B144                 push    edx
.text$mn:0000B145                 call    ??$addressof@UrecordedMacroStep@@@std@@YAPAUrecordedMacroStep@@AAU1@@Z ; std::addressof<recordedMacroStep>(recordedMacroStep &)
.text$mn:0000B14A                 add     esp, 4
.text$mn:0000B14D                 mov     ecx, [ebp+var_8]
.text$mn:0000B150                 sub     eax, [ecx+4]
.text$mn:0000B153                 cdq
.text$mn:0000B154                 mov     ecx, 2Ch ; ','
.text$mn:0000B159                 idiv    ecx
.text$mn:0000B15B                 mov     [ebp+var_C], eax
.text$mn:0000B15E                 mov     edx, [ebp+var_8]
.text$mn:0000B161                 mov     eax, [ebp+var_8]
.text$mn:0000B164                 mov     ecx, [edx+8]
.text$mn:0000B167                 cmp     ecx, [eax+0Ch]
.text$mn:0000B16A                 jnz     short loc_B176
.text$mn:0000B16C                 push    1
.text$mn:0000B16E                 mov     ecx, [ebp+var_8]
.text$mn:0000B171                 call    ?_Reserve@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reserve(uint)
.text$mn:0000B176
.text$mn:0000B176 loc_B176:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::push_back(recordedMacroStep &&)+52j
.text$mn:0000B176                 mov     edx, [ebp+var_8]
.text$mn:0000B179                 mov     eax, [edx+8]
.text$mn:0000B17C                 push    eax
.text$mn:0000B17D                 mov     ecx, [ebp+var_8]
.text$mn:0000B180                 mov     edx, [ecx+8]
.text$mn:0000B183                 push    edx
.text$mn:0000B184                 mov     ecx, [ebp+var_8]
.text$mn:0000B187                 call    ?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Orphan_range(recordedMacroStep *,recordedMacroStep *)
.text$mn:0000B18C                 imul    eax, [ebp+var_C], 2Ch
.text$mn:0000B190                 mov     ecx, [ebp+var_8]
.text$mn:0000B193                 add     eax, [ecx+4]
.text$mn:0000B196                 push    eax
.text$mn:0000B197                 call    ??$forward@UrecordedMacroStep@@@std@@YA$$QAUrecordedMacroStep@@AAU1@@Z ; std::forward<recordedMacroStep>(recordedMacroStep &)
.text$mn:0000B19C                 add     esp, 4
.text$mn:0000B19F                 push    eax             ; int
.text$mn:0000B1A0                 mov     edx, [ebp+var_8]
.text$mn:0000B1A3                 mov     eax, [edx+8]
.text$mn:0000B1A6                 push    eax             ; void *
.text$mn:0000B1A7                 lea     ecx, [ebp+var_1]
.text$mn:0000B1AA                 push    ecx
.text$mn:0000B1AB                 mov     ecx, [ebp+var_8]
.text$mn:0000B1AE                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:0000B1B3                 mov     ecx, eax
.text$mn:0000B1B5                 call    ??$construct@UrecordedMacroStep@@U1@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep &&)
.text$mn:0000B1BA                 mov     edx, [ebp+var_8]
.text$mn:0000B1BD                 mov     eax, [edx+8]
.text$mn:0000B1C0                 add     eax, 2Ch ; ','
.text$mn:0000B1C3                 mov     ecx, [ebp+var_8]
.text$mn:0000B1C6                 mov     [ecx+8], eax
.text$mn:0000B1C9                 jmp     short loc_B22F
.text$mn:0000B1CB ; ---------------------------------------------------------------------------
.text$mn:0000B1CB
.text$mn:0000B1CB loc_B1CB:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::push_back(recordedMacroStep &&)+23j
.text$mn:0000B1CB                 mov     edx, [ebp+var_8]
.text$mn:0000B1CE                 mov     eax, [ebp+var_8]
.text$mn:0000B1D1                 mov     ecx, [edx+8]
.text$mn:0000B1D4                 cmp     ecx, [eax+0Ch]
.text$mn:0000B1D7                 jnz     short loc_B1E3
.text$mn:0000B1D9                 push    1
.text$mn:0000B1DB                 mov     ecx, [ebp+var_8]
.text$mn:0000B1DE                 call    ?_Reserve@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reserve(uint)
.text$mn:0000B1E3
.text$mn:0000B1E3 loc_B1E3:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::push_back(recordedMacroStep &&)+BFj
.text$mn:0000B1E3                 mov     edx, [ebp+var_8]
.text$mn:0000B1E6                 mov     eax, [edx+8]
.text$mn:0000B1E9                 push    eax
.text$mn:0000B1EA                 mov     ecx, [ebp+var_8]
.text$mn:0000B1ED                 mov     edx, [ecx+8]
.text$mn:0000B1F0                 push    edx
.text$mn:0000B1F1                 mov     ecx, [ebp+var_8]
.text$mn:0000B1F4                 call    ?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Orphan_range(recordedMacroStep *,recordedMacroStep *)
.text$mn:0000B1F9                 mov     eax, [ebp+arg_0]
.text$mn:0000B1FC                 push    eax
.text$mn:0000B1FD                 call    ??$forward@UrecordedMacroStep@@@std@@YA$$QAUrecordedMacroStep@@AAU1@@Z ; std::forward<recordedMacroStep>(recordedMacroStep &)
.text$mn:0000B202                 add     esp, 4
.text$mn:0000B205                 push    eax             ; int
.text$mn:0000B206                 mov     ecx, [ebp+var_8]
.text$mn:0000B209                 mov     edx, [ecx+8]
.text$mn:0000B20C                 push    edx             ; void *
.text$mn:0000B20D                 lea     eax, [ebp+var_2]
.text$mn:0000B210                 push    eax
.text$mn:0000B211                 mov     ecx, [ebp+var_8]
.text$mn:0000B214                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<recordedMacroStep,std::allocator<recordedMacroStep>>>::_Getal(void)
.text$mn:0000B219                 mov     ecx, eax
.text$mn:0000B21B                 call    ??$construct@UrecordedMacroStep@@U1@@?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<recordedMacroStep>>::construct<recordedMacroStep,recordedMacroStep>(recordedMacroStep *,recordedMacroStep &&)
.text$mn:0000B220                 mov     ecx, [ebp+var_8]
.text$mn:0000B223                 mov     edx, [ecx+8]
.text$mn:0000B226                 add     edx, 2Ch ; ','
.text$mn:0000B229                 mov     eax, [ebp+var_8]
.text$mn:0000B22C                 mov     [eax+8], edx
.text$mn:0000B22F
.text$mn:0000B22F loc_B22F:                               ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::push_back(recordedMacroStep &&)+B1j
.text$mn:0000B22F                 mov     esp, ebp
.text$mn:0000B231                 pop     ebp
.text$mn:0000B232                 retn    4
.text$mn:0000B232 ?push_back@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QAEX$$QAUrecordedMacroStep@@@Z endp
.text$mn:0000B232
.text$mn:0000B232 ; ---------------------------------------------------------------------------
.text$mn:0000B235                 align 4
.text$mn:0000B235 _text$mn        ends
.text$mn:0000B235
.text$mn:0000B238 ; ===========================================================================
.text$mn:0000B238
.text$mn:0000B238 ; Segment type: Pure code
.text$mn:0000B238 ; Segment permissions: Read/Execute
.text$mn:0000B238 _text$mn        segment para public 'CODE' use32
.text$mn:0000B238                 assume cs:_text$mn
.text$mn:0000B238                 ;org 0B238h
.text$mn:0000B238 ; COMDAT (pick any)
.text$mn:0000B238                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B238
.text$mn:0000B238 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B238
.text$mn:0000B238 ; Attributes: bp-based frame
.text$mn:0000B238
.text$mn:0000B238 ; void __thiscall TabBarPlus::resetDraggingPoint(TabBarPlus *__hidden this)
.text$mn:0000B238                 public ?resetDraggingPoint@TabBarPlus@@QAEXXZ
.text$mn:0000B238 ?resetDraggingPoint@TabBarPlus@@QAEXXZ proc near
.text$mn:0000B238                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+B81p
.text$mn:0000B238
.text$mn:0000B238 var_4           = dword ptr -4
.text$mn:0000B238
.text$mn:0000B238                 push    ebp
.text$mn:0000B239                 mov     ebp, esp
.text$mn:0000B23B                 push    ecx
.text$mn:0000B23C                 mov     [ebp+var_4], ecx
.text$mn:0000B23F                 mov     eax, [ebp+var_4]
.text$mn:0000B242                 mov     dword ptr [eax+3Ch], 0
.text$mn:0000B249                 mov     ecx, [ebp+var_4]
.text$mn:0000B24C                 mov     dword ptr [ecx+40h], 0
.text$mn:0000B253                 mov     esp, ebp
.text$mn:0000B255                 pop     ebp
.text$mn:0000B256                 retn
.text$mn:0000B256 ?resetDraggingPoint@TabBarPlus@@QAEXXZ endp
.text$mn:0000B256
.text$mn:0000B256 ; ---------------------------------------------------------------------------
.text$mn:0000B257                 align 4
.text$mn:0000B257 _text$mn        ends
.text$mn:0000B257
.text$mn:0000B258 ; ===========================================================================
.text$mn:0000B258
.text$mn:0000B258 ; Segment type: Pure code
.text$mn:0000B258 ; Segment permissions: Read/Execute
.text$mn:0000B258 _text$mn        segment para public 'CODE' use32
.text$mn:0000B258                 assume cs:_text$mn
.text$mn:0000B258                 ;org 0B258h
.text$mn:0000B258 ; COMDAT (pick any)
.text$mn:0000B258                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B258
.text$mn:0000B258 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B258
.text$mn:0000B258 ; Attributes: bp-based frame
.text$mn:0000B258
.text$mn:0000B258 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::select_on_container_copy_construction(void)const
.text$mn:0000B258                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ
.text$mn:0000B258 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ proc near
.text$mn:0000B258                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Ap
.text$mn:0000B258
.text$mn:0000B258 var_8           = dword ptr -8
.text$mn:0000B258 var_1           = byte ptr -1
.text$mn:0000B258 arg_0           = dword ptr  8
.text$mn:0000B258
.text$mn:0000B258                 push    ebp
.text$mn:0000B259                 mov     ebp, esp
.text$mn:0000B25B                 sub     esp, 8
.text$mn:0000B25E                 mov     [ebp+var_8], ecx
.text$mn:0000B261                 mov     eax, [ebp+var_8]
.text$mn:0000B264                 push    eax
.text$mn:0000B265                 lea     ecx, [ebp+var_1]
.text$mn:0000B268                 push    ecx
.text$mn:0000B269                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)
.text$mn:0000B26E                 add     esp, 8
.text$mn:0000B271                 push    eax
.text$mn:0000B272                 mov     ecx, [ebp+arg_0]
.text$mn:0000B275                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(std::allocator<wchar_t> const &)
.text$mn:0000B27A                 mov     eax, [ebp+arg_0]
.text$mn:0000B27D                 mov     esp, ebp
.text$mn:0000B27F                 pop     ebp
.text$mn:0000B280                 retn    4
.text$mn:0000B280 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ endp
.text$mn:0000B280
.text$mn:0000B280 ; ---------------------------------------------------------------------------
.text$mn:0000B283                 align 4
.text$mn:0000B283 _text$mn        ends
.text$mn:0000B283
.text$mn:0000B284 ; ===========================================================================
.text$mn:0000B284
.text$mn:0000B284 ; Segment type: Pure code
.text$mn:0000B284 ; Segment permissions: Read/Execute
.text$mn:0000B284 _text$mn        segment para public 'CODE' use32
.text$mn:0000B284                 assume cs:_text$mn
.text$mn:0000B284                 ;org 0B284h
.text$mn:0000B284 ; COMDAT (pick any)
.text$mn:0000B284                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B284
.text$mn:0000B284 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B284
.text$mn:0000B284 ; Attributes: bp-based frame
.text$mn:0000B284
.text$mn:0000B284 ; public: class std::allocator<wchar_t> __thiscall std::allocator<wchar_t>::select_on_container_copy_construction(void)const
.text$mn:0000B284                 public ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ
.text$mn:0000B284 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ proc near
.text$mn:0000B284                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)+Ap
.text$mn:0000B284
.text$mn:0000B284 var_4           = dword ptr -4
.text$mn:0000B284 arg_0           = dword ptr  8
.text$mn:0000B284
.text$mn:0000B284                 push    ebp
.text$mn:0000B285                 mov     ebp, esp
.text$mn:0000B287                 push    ecx
.text$mn:0000B288                 mov     [ebp+var_4], ecx
.text$mn:0000B28B                 mov     eax, [ebp+var_4]
.text$mn:0000B28E                 push    eax
.text$mn:0000B28F                 mov     ecx, [ebp+arg_0]
.text$mn:0000B292                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:0000B297                 mov     eax, [ebp+arg_0]
.text$mn:0000B29A                 mov     esp, ebp
.text$mn:0000B29C                 pop     ebp
.text$mn:0000B29D                 retn    4
.text$mn:0000B29D ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ endp
.text$mn:0000B29D
.text$mn:0000B29D _text$mn        ends
.text$mn:0000B29D
.text$mn:0000B2A0 ; ===========================================================================
.text$mn:0000B2A0
.text$mn:0000B2A0 ; Segment type: Pure code
.text$mn:0000B2A0 ; Segment permissions: Read/Execute
.text$mn:0000B2A0 _text$mn        segment para public 'CODE' use32
.text$mn:0000B2A0                 assume cs:_text$mn
.text$mn:0000B2A0                 ;org 0B2A0h
.text$mn:0000B2A0 ; COMDAT (pick any)
.text$mn:0000B2A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B2A0
.text$mn:0000B2A0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B2A0
.text$mn:0000B2A0 ; Attributes: bp-based frame
.text$mn:0000B2A0
.text$mn:0000B2A0 ; public: static class std::allocator<wchar_t> __cdecl std::allocator_traits<class std::allocator<wchar_t>>::select_on_container_copy_construction(class std::allocator<wchar_t> const &)
.text$mn:0000B2A0                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
.text$mn:0000B2A0 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z proc near
.text$mn:0000B2A0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+11p
.text$mn:0000B2A0
.text$mn:0000B2A0 arg_0           = dword ptr  8
.text$mn:0000B2A0 arg_4           = dword ptr  0Ch
.text$mn:0000B2A0
.text$mn:0000B2A0                 push    ebp
.text$mn:0000B2A1                 mov     ebp, esp
.text$mn:0000B2A3                 mov     eax, [ebp+arg_0]
.text$mn:0000B2A6                 push    eax
.text$mn:0000B2A7                 mov     ecx, [ebp+arg_4]
.text$mn:0000B2AA                 call    ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ ; std::allocator<wchar_t>::select_on_container_copy_construction(void)
.text$mn:0000B2AF                 mov     eax, [ebp+arg_0]
.text$mn:0000B2B2                 pop     ebp
.text$mn:0000B2B3                 retn
.text$mn:0000B2B3 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z endp
.text$mn:0000B2B3
.text$mn:0000B2B3 _text$mn        ends
.text$mn:0000B2B3
.text$mn:0000B2B4 ; ===========================================================================
.text$mn:0000B2B4
.text$mn:0000B2B4 ; Segment type: Pure code
.text$mn:0000B2B4 ; Segment permissions: Read/Execute
.text$mn:0000B2B4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B2B4                 assume cs:_text$mn
.text$mn:0000B2B4                 ;org 0B2B4h
.text$mn:0000B2B4 ; COMDAT (pick any)
.text$mn:0000B2B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B2B4
.text$mn:0000B2B4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B2B4
.text$mn:0000B2B4 ; Attributes: bp-based frame
.text$mn:0000B2B4
.text$mn:0000B2B4 ; void __thiscall Buffer::setDirty(Buffer *this, bool)
.text$mn:0000B2B4                 public ?setDirty@Buffer@@QAEX_N@Z
.text$mn:0000B2B4 ?setDirty@Buffer@@QAEX_N@Z proc near    ; CODE XREF: Notepad_plus::notify(SCNotification *)+56Fp
.text$mn:0000B2B4
.text$mn:0000B2B4 var_4           = dword ptr -4
.text$mn:0000B2B4 arg_0           = byte ptr  8
.text$mn:0000B2B4
.text$mn:0000B2B4                 push    ebp
.text$mn:0000B2B5                 mov     ebp, esp
.text$mn:0000B2B7                 push    ecx
.text$mn:0000B2B8                 mov     [ebp+var_4], ecx
.text$mn:0000B2BB                 mov     eax, [ebp+var_4]
.text$mn:0000B2BE                 mov     cl, [ebp+arg_0]
.text$mn:0000B2C1                 mov     [eax+34h], cl
.text$mn:0000B2C4                 push    2               ; int
.text$mn:0000B2C6                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000B2C9                 call    ?doNotify@Buffer@@AAEXH@Z ; Buffer::doNotify(int)
.text$mn:0000B2CE                 mov     esp, ebp
.text$mn:0000B2D0                 pop     ebp
.text$mn:0000B2D1                 retn    4
.text$mn:0000B2D1 ?setDirty@Buffer@@QAEX_N@Z endp
.text$mn:0000B2D1
.text$mn:0000B2D1 _text$mn        ends
.text$mn:0000B2D1
.text$mn:0000B2D4 ; ===========================================================================
.text$mn:0000B2D4
.text$mn:0000B2D4 ; Segment type: Pure code
.text$mn:0000B2D4 ; Segment permissions: Read/Execute
.text$mn:0000B2D4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B2D4                 assume cs:_text$mn
.text$mn:0000B2D4                 ;org 0B2D4h
.text$mn:0000B2D4 ; COMDAT (pick any)
.text$mn:0000B2D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B2D4
.text$mn:0000B2D4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B2D4
.text$mn:0000B2D4 ; Attributes: bp-based frame
.text$mn:0000B2D4
.text$mn:0000B2D4 ; void __thiscall Buffer::setModifiedStatus(Buffer *this, bool)
.text$mn:0000B2D4                 public ?setModifiedStatus@Buffer@@QAEX_N@Z
.text$mn:0000B2D4 ?setModifiedStatus@Buffer@@QAEX_N@Z proc near
.text$mn:0000B2D4                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+326p
.text$mn:0000B2D4
.text$mn:0000B2D4 var_4           = dword ptr -4
.text$mn:0000B2D4 arg_0           = byte ptr  8
.text$mn:0000B2D4
.text$mn:0000B2D4                 push    ebp
.text$mn:0000B2D5                 mov     ebp, esp
.text$mn:0000B2D7                 push    ecx
.text$mn:0000B2D8                 mov     [ebp+var_4], ecx
.text$mn:0000B2DB                 mov     eax, [ebp+var_4]
.text$mn:0000B2DE                 mov     cl, [ebp+arg_0]
.text$mn:0000B2E1                 mov     [eax+0D0h], cl
.text$mn:0000B2E7                 mov     esp, ebp
.text$mn:0000B2E9                 pop     ebp
.text$mn:0000B2EA                 retn    4
.text$mn:0000B2EA ?setModifiedStatus@Buffer@@QAEX_N@Z endp
.text$mn:0000B2EA
.text$mn:0000B2EA ; ---------------------------------------------------------------------------
.text$mn:0000B2ED                 align 10h
.text$mn:0000B2ED _text$mn        ends
.text$mn:0000B2ED
.text$mn:0000B2F0 ; ===========================================================================
.text$mn:0000B2F0
.text$mn:0000B2F0 ; Segment type: Pure code
.text$mn:0000B2F0 ; Segment permissions: Read/Execute
.text$mn:0000B2F0 _text$mn        segment para public 'CODE' use32
.text$mn:0000B2F0                 assume cs:_text$mn
.text$mn:0000B2F0                 ;org 0B2F0h
.text$mn:0000B2F0 ; COMDAT (pick any)
.text$mn:0000B2F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B2F0
.text$mn:0000B2F0 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B2F0
.text$mn:0000B2F0 ; Attributes: bp-based frame
.text$mn:0000B2F0
.text$mn:0000B2F0 ; void __thiscall ScintillaEditView::setWrapRestoreNeeded(ScintillaEditView *this, bool)
.text$mn:0000B2F0                 public ?setWrapRestoreNeeded@ScintillaEditView@@QAEX_N@Z
.text$mn:0000B2F0 ?setWrapRestoreNeeded@ScintillaEditView@@QAEX_N@Z proc near
.text$mn:0000B2F0                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2D9Ap
.text$mn:0000B2F0                                         ; Notepad_plus::notify(SCNotification *)+2DD6p
.text$mn:0000B2F0
.text$mn:0000B2F0 var_4           = dword ptr -4
.text$mn:0000B2F0 arg_0           = byte ptr  8
.text$mn:0000B2F0
.text$mn:0000B2F0                 push    ebp
.text$mn:0000B2F1                 mov     ebp, esp
.text$mn:0000B2F3                 push    ecx
.text$mn:0000B2F4                 mov     [ebp+var_4], ecx
.text$mn:0000B2F7                 mov     eax, [ebp+var_4]
.text$mn:0000B2FA                 mov     cl, [ebp+arg_0]
.text$mn:0000B2FD                 mov     [eax+2Dh], cl
.text$mn:0000B300                 mov     esp, ebp
.text$mn:0000B302                 pop     ebp
.text$mn:0000B303                 retn    4
.text$mn:0000B303 ?setWrapRestoreNeeded@ScintillaEditView@@QAEX_N@Z endp
.text$mn:0000B303
.text$mn:0000B303 ; ---------------------------------------------------------------------------
.text$mn:0000B306                 align 4
.text$mn:0000B306 _text$mn        ends
.text$mn:0000B306
.text$mn:0000B308 ; ===========================================================================
.text$mn:0000B308
.text$mn:0000B308 ; Segment type: Pure code
.text$mn:0000B308 ; Segment permissions: Read/Execute
.text$mn:0000B308 _text$mn        segment para public 'CODE' use32
.text$mn:0000B308                 assume cs:_text$mn
.text$mn:0000B308                 ;org 0B308h
.text$mn:0000B308 ; COMDAT (pick any)
.text$mn:0000B308                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B308
.text$mn:0000B308 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B308
.text$mn:0000B308 ; Attributes: bp-based frame
.text$mn:0000B308
.text$mn:0000B308 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:0000B308                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000B308 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000B308                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:0000B308                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:0000B308
.text$mn:0000B308 var_4           = dword ptr -4
.text$mn:0000B308
.text$mn:0000B308                 push    ebp
.text$mn:0000B309                 mov     ebp, esp
.text$mn:0000B30B                 push    ecx
.text$mn:0000B30C                 mov     [ebp+var_4], ecx
.text$mn:0000B30F                 mov     eax, [ebp+var_4]
.text$mn:0000B312                 mov     eax, [eax+14h]
.text$mn:0000B315                 mov     esp, ebp
.text$mn:0000B317                 pop     ebp
.text$mn:0000B318                 retn
.text$mn:0000B318 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:0000B318
.text$mn:0000B318 ; ---------------------------------------------------------------------------
.text$mn:0000B319                 align 4
.text$mn:0000B319 _text$mn        ends
.text$mn:0000B319
.text$mn:0000B31C ; ===========================================================================
.text$mn:0000B31C
.text$mn:0000B31C ; Segment type: Pure code
.text$mn:0000B31C ; Segment permissions: Read/Execute
.text$mn:0000B31C _text$mn        segment para public 'CODE' use32
.text$mn:0000B31C                 assume cs:_text$mn
.text$mn:0000B31C                 ;org 0B31Ch
.text$mn:0000B31C ; COMDAT (pick any)
.text$mn:0000B31C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B31C
.text$mn:0000B31C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B31C
.text$mn:0000B31C ; Attributes: bp-based frame
.text$mn:0000B31C
.text$mn:0000B31C ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:0000B31C                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000B31C ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000B31C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:0000B31C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p ...
.text$mn:0000B31C
.text$mn:0000B31C var_4           = dword ptr -4
.text$mn:0000B31C
.text$mn:0000B31C                 push    ebp
.text$mn:0000B31D                 mov     ebp, esp
.text$mn:0000B31F                 push    ecx
.text$mn:0000B320                 mov     [ebp+var_4], ecx
.text$mn:0000B323                 mov     eax, [ebp+var_4]
.text$mn:0000B326                 mov     eax, [eax+14h]
.text$mn:0000B329                 mov     esp, ebp
.text$mn:0000B32B                 pop     ebp
.text$mn:0000B32C                 retn
.text$mn:0000B32C ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:0000B32C
.text$mn:0000B32C ; ---------------------------------------------------------------------------
.text$mn:0000B32D                 align 10h
.text$mn:0000B32D _text$mn        ends
.text$mn:0000B32D
.text$mn:0000B330 ; ===========================================================================
.text$mn:0000B330
.text$mn:0000B330 ; Segment type: Pure code
.text$mn:0000B330 ; Segment permissions: Read/Execute
.text$mn:0000B330 _text$mn        segment para public 'CODE' use32
.text$mn:0000B330                 assume cs:_text$mn
.text$mn:0000B330                 ;org 0B330h
.text$mn:0000B330 ; COMDAT (pick any)
.text$mn:0000B330                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B330
.text$mn:0000B330 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B330
.text$mn:0000B330 ; Attributes: bp-based frame
.text$mn:0000B330
.text$mn:0000B330 ; public: unsigned int __thiscall std::vector<struct std::pair<char, char>, class std::allocator<struct std::pair<char, char>>>::size(void)const
.text$mn:0000B330                 public ?size@?$vector@U?$pair@DD@std@@V?$allocator@U?$pair@DD@std@@@2@@std@@QBEIXZ
.text$mn:0000B330 ?size@?$vector@U?$pair@DD@std@@V?$allocator@U?$pair@DD@std@@@2@@std@@QBEIXZ proc near
.text$mn:0000B330                                         ; CODE XREF: MatchedPairConf::hasUserDefinedPairs(void)+Cp
.text$mn:0000B330
.text$mn:0000B330 var_4           = dword ptr -4
.text$mn:0000B330
.text$mn:0000B330                 push    ebp
.text$mn:0000B331                 mov     ebp, esp
.text$mn:0000B333                 push    ecx
.text$mn:0000B334                 mov     [ebp+var_4], ecx
.text$mn:0000B337                 mov     eax, [ebp+var_4]
.text$mn:0000B33A                 mov     ecx, [ebp+var_4]
.text$mn:0000B33D                 mov     eax, [eax+8]
.text$mn:0000B340                 sub     eax, [ecx+4]
.text$mn:0000B343                 sar     eax, 1
.text$mn:0000B345                 mov     esp, ebp
.text$mn:0000B347                 pop     ebp
.text$mn:0000B348                 retn
.text$mn:0000B348 ?size@?$vector@U?$pair@DD@std@@V?$allocator@U?$pair@DD@std@@@2@@std@@QBEIXZ endp
.text$mn:0000B348
.text$mn:0000B348 ; ---------------------------------------------------------------------------
.text$mn:0000B349                 align 4
.text$mn:0000B349 _text$mn        ends
.text$mn:0000B349
.text$mn:0000B34C ; ===========================================================================
.text$mn:0000B34C
.text$mn:0000B34C ; Segment type: Pure code
.text$mn:0000B34C ; Segment permissions: Read/Execute
.text$mn:0000B34C _text$mn        segment para public 'CODE' use32
.text$mn:0000B34C                 assume cs:_text$mn
.text$mn:0000B34C                 ;org 0B34Ch
.text$mn:0000B34C ; COMDAT (pick any)
.text$mn:0000B34C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B34C
.text$mn:0000B34C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B34C
.text$mn:0000B34C ; Attributes: bp-based frame
.text$mn:0000B34C
.text$mn:0000B34C ; public: unsigned int __thiscall std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>>::size(void)const
.text$mn:0000B34C                 public ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ
.text$mn:0000B34C ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B34C                                         ; CODE XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reallocate(uint)+A9p
.text$mn:0000B34C                                         ; std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Reserve(uint)+22p ...
.text$mn:0000B34C
.text$mn:0000B34C var_4           = dword ptr -4
.text$mn:0000B34C
.text$mn:0000B34C                 push    ebp
.text$mn:0000B34D                 mov     ebp, esp
.text$mn:0000B34F                 push    ecx
.text$mn:0000B350                 mov     [ebp+var_4], ecx
.text$mn:0000B353                 mov     eax, [ebp+var_4]
.text$mn:0000B356                 mov     ecx, [ebp+var_4]
.text$mn:0000B359                 mov     eax, [eax+8]
.text$mn:0000B35C                 sub     eax, [ecx+4]
.text$mn:0000B35F                 cdq
.text$mn:0000B360                 mov     ecx, 3Ch ; '<'
.text$mn:0000B365                 idiv    ecx
.text$mn:0000B367                 mov     esp, ebp
.text$mn:0000B369                 pop     ebp
.text$mn:0000B36A                 retn
.text$mn:0000B36A ?size@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QBEIXZ endp
.text$mn:0000B36A
.text$mn:0000B36A ; ---------------------------------------------------------------------------
.text$mn:0000B36B                 align 4
.text$mn:0000B36B _text$mn        ends
.text$mn:0000B36B
.text$mn:0000B36C ; ===========================================================================
.text$mn:0000B36C
.text$mn:0000B36C ; Segment type: Pure code
.text$mn:0000B36C ; Segment permissions: Read/Execute
.text$mn:0000B36C _text$mn        segment para public 'CODE' use32
.text$mn:0000B36C                 assume cs:_text$mn
.text$mn:0000B36C                 ;org 0B36Ch
.text$mn:0000B36C ; COMDAT (pick any)
.text$mn:0000B36C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B36C
.text$mn:0000B36C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B36C
.text$mn:0000B36C ; Attributes: bp-based frame
.text$mn:0000B36C
.text$mn:0000B36C ; public: unsigned int __thiscall std::vector<struct recordedMacroStep, class std::allocator<struct recordedMacroStep>>::size(void)const
.text$mn:0000B36C                 public ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ
.text$mn:0000B36C ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ proc near
.text$mn:0000B36C                                         ; CODE XREF: std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reallocate(uint)+A9p
.text$mn:0000B36C                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Reserve(uint)+22p ...
.text$mn:0000B36C
.text$mn:0000B36C var_4           = dword ptr -4
.text$mn:0000B36C
.text$mn:0000B36C                 push    ebp
.text$mn:0000B36D                 mov     ebp, esp
.text$mn:0000B36F                 push    ecx
.text$mn:0000B370                 mov     [ebp+var_4], ecx
.text$mn:0000B373                 mov     eax, [ebp+var_4]
.text$mn:0000B376                 mov     ecx, [ebp+var_4]
.text$mn:0000B379                 mov     eax, [eax+8]
.text$mn:0000B37C                 sub     eax, [ecx+4]
.text$mn:0000B37F                 cdq
.text$mn:0000B380                 mov     ecx, 2Ch ; ','
.text$mn:0000B385                 idiv    ecx
.text$mn:0000B387                 mov     esp, ebp
.text$mn:0000B389                 pop     ebp
.text$mn:0000B38A                 retn
.text$mn:0000B38A ?size@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@QBEIXZ endp
.text$mn:0000B38A
.text$mn:0000B38A ; ---------------------------------------------------------------------------
.text$mn:0000B38B                 align 4
.text$mn:0000B38B _text$mn        ends
.text$mn:0000B38B
.text$mn:0000B38C ; ===========================================================================
.text$mn:0000B38C
.text$mn:0000B38C ; Segment type: Pure code
.text$mn:0000B38C ; Segment permissions: Read/Execute
.text$mn:0000B38C _text$mn        segment para public 'CODE' use32
.text$mn:0000B38C                 assume cs:_text$mn
.text$mn:0000B38C                 ;org 0B38Ch
.text$mn:0000B38C ; COMDAT (pick any)
.text$mn:0000B38C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B38C
.text$mn:0000B38C ; =============== S U B R O U T I N E =======================================
.text$mn:0000B38C
.text$mn:0000B38C ; Attributes: bp-based frame
.text$mn:0000B38C
.text$mn:0000B38C ; const struct std::error_category *__cdecl std::system_category()
.text$mn:0000B38C                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:0000B38C ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:0000B38C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_A0E0p
.text$mn:0000B38C                 push    ebp
.text$mn:0000B38D                 mov     ebp, esp
.text$mn:0000B38F                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:0000B394                 pop     ebp
.text$mn:0000B395                 retn
.text$mn:0000B395 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000B395
.text$mn:0000B395 ; ---------------------------------------------------------------------------
.text$mn:0000B396                 align 4
.text$mn:0000B396 _text$mn        ends
.text$mn:0000B396
.text$mn:0000B398 ; ===========================================================================
.text$mn:0000B398
.text$mn:0000B398 ; Segment type: Pure code
.text$mn:0000B398 ; Segment permissions: Read/Execute
.text$mn:0000B398 _text$mn        segment para public 'CODE' use32
.text$mn:0000B398                 assume cs:_text$mn
.text$mn:0000B398                 ;org 0B398h
.text$mn:0000B398 ; COMDAT (pick any)
.text$mn:0000B398                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B398
.text$mn:0000B398 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B398
.text$mn:0000B398 ; Attributes: bp-based frame
.text$mn:0000B398
.text$mn:0000B398 ; public: unsigned int & __thiscall std::stack<unsigned int, class std::deque<unsigned int, class std::allocator<unsigned int>>>::top(void)
.text$mn:0000B398                 public ?top@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAEAAIXZ
.text$mn:0000B398 ?top@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAEAAIXZ proc near
.text$mn:0000B398                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+25D4p
.text$mn:0000B398
.text$mn:0000B398 var_4           = dword ptr -4
.text$mn:0000B398
.text$mn:0000B398                 push    ebp
.text$mn:0000B399                 mov     ebp, esp
.text$mn:0000B39B                 push    ecx
.text$mn:0000B39C                 mov     [ebp+var_4], ecx
.text$mn:0000B39F                 mov     ecx, [ebp+var_4]
.text$mn:0000B3A2                 call    ?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ ; std::deque<uint,std::allocator<uint>>::back(void)
.text$mn:0000B3A7                 mov     esp, ebp
.text$mn:0000B3A9                 pop     ebp
.text$mn:0000B3AA                 retn
.text$mn:0000B3AA ?top@?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAEAAIXZ endp
.text$mn:0000B3AA
.text$mn:0000B3AA ; ---------------------------------------------------------------------------
.text$mn:0000B3AB                 align 4
.text$mn:0000B3AB _text$mn        ends
.text$mn:0000B3AB
.text$mn:0000B3AC ; ===========================================================================
.text$mn:0000B3AC
.text$mn:0000B3AC ; Segment type: Pure code
.text$mn:0000B3AC ; Segment permissions: Read/Execute
.text$mn:0000B3AC _text$mn        segment para public 'CODE' use32
.text$mn:0000B3AC                 assume cs:_text$mn
.text$mn:0000B3AC                 ;org 0B3ACh
.text$mn:0000B3AC ; COMDAT (pick any)
.text$mn:0000B3AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B3AC
.text$mn:0000B3AC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B3AC
.text$mn:0000B3AC ; Attributes: bp-based frame
.text$mn:0000B3AC
.text$mn:0000B3AC ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:0000B3AC                 public ?value@error_code@std@@QBEHXZ
.text$mn:0000B3AC ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:0000B3AC
.text$mn:0000B3AC var_4           = dword ptr -4
.text$mn:0000B3AC
.text$mn:0000B3AC                 push    ebp
.text$mn:0000B3AD                 mov     ebp, esp
.text$mn:0000B3AF                 push    ecx
.text$mn:0000B3B0                 mov     [ebp+var_4], ecx
.text$mn:0000B3B3                 mov     eax, [ebp+var_4]
.text$mn:0000B3B6                 mov     eax, [eax]
.text$mn:0000B3B8                 mov     esp, ebp
.text$mn:0000B3BA                 pop     ebp
.text$mn:0000B3BB                 retn
.text$mn:0000B3BB ?value@error_code@std@@QBEHXZ endp
.text$mn:0000B3BB
.text$mn:0000B3BB _text$mn        ends
.text$mn:0000B3BB
.text$mn:0000B3BC ; ===========================================================================
.text$mn:0000B3BC
.text$mn:0000B3BC ; Segment type: Pure code
.text$mn:0000B3BC ; Segment permissions: Read/Execute
.text$mn:0000B3BC _text$mn        segment para public 'CODE' use32
.text$mn:0000B3BC                 assume cs:_text$mn
.text$mn:0000B3BC                 ;org 0B3BCh
.text$mn:0000B3BC ; COMDAT (pick any)
.text$mn:0000B3BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B3BC
.text$mn:0000B3BC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B3BC
.text$mn:0000B3BC ; Attributes: bp-based frame
.text$mn:0000B3BC
.text$mn:0000B3BC ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:0000B3BC                 public ?value@error_condition@std@@QBEHXZ
.text$mn:0000B3BC ?value@error_condition@std@@QBEHXZ proc near
.text$mn:0000B3BC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:0000B3BC                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:0000B3BC
.text$mn:0000B3BC var_4           = dword ptr -4
.text$mn:0000B3BC
.text$mn:0000B3BC                 push    ebp
.text$mn:0000B3BD                 mov     ebp, esp
.text$mn:0000B3BF                 push    ecx
.text$mn:0000B3C0                 mov     [ebp+var_4], ecx
.text$mn:0000B3C3                 mov     eax, [ebp+var_4]
.text$mn:0000B3C6                 mov     eax, [eax]
.text$mn:0000B3C8                 mov     esp, ebp
.text$mn:0000B3CA                 pop     ebp
.text$mn:0000B3CB                 retn
.text$mn:0000B3CB ?value@error_condition@std@@QBEHXZ endp
.text$mn:0000B3CB
.text$mn:0000B3CB _text$mn        ends
.text$mn:0000B3CB
.text$mn:0000B3CC ; ===========================================================================
.text$mn:0000B3CC
.text$mn:0000B3CC ; Segment type: Pure code
.text$mn:0000B3CC ; Segment permissions: Read/Execute
.text$mn:0000B3CC _text$mn        segment para public 'CODE' use32
.text$mn:0000B3CC                 assume cs:_text$mn
.text$mn:0000B3CC                 ;org 0B3CCh
.text$mn:0000B3CC ; COMDAT (pick any)
.text$mn:0000B3CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B3CC
.text$mn:0000B3CC ; =============== S U B R O U T I N E =======================================
.text$mn:0000B3CC
.text$mn:0000B3CC ; Attributes: bp-based frame
.text$mn:0000B3CC
.text$mn:0000B3CC                 public _hypot
.text$mn:0000B3CC _hypot          proc near
.text$mn:0000B3CC
.text$mn:0000B3CC var_10          = qword ptr -10h
.text$mn:0000B3CC var_8           = qword ptr -8
.text$mn:0000B3CC arg_0           = qword ptr  8
.text$mn:0000B3CC arg_8           = qword ptr  10h
.text$mn:0000B3CC
.text$mn:0000B3CC                 push    ebp
.text$mn:0000B3CD                 mov     ebp, esp
.text$mn:0000B3CF                 sub     esp, 8
.text$mn:0000B3D2                 movsd   xmm0, [ebp+arg_8]
.text$mn:0000B3D7                 movsd   [esp+8+var_8], xmm0
.text$mn:0000B3DC                 sub     esp, 8
.text$mn:0000B3DF                 movsd   xmm0, [ebp+arg_0]
.text$mn:0000B3E4                 movsd   [esp+10h+var_10], xmm0
.text$mn:0000B3E9                 call    __hypot
.text$mn:0000B3EE                 add     esp, 10h
.text$mn:0000B3F1                 pop     ebp
.text$mn:0000B3F2                 retn
.text$mn:0000B3F2 _hypot          endp
.text$mn:0000B3F2
.text$mn:0000B3F2 ; ---------------------------------------------------------------------------
.text$mn:0000B3F3                 align 4
.text$mn:0000B3F3 _text$mn        ends
.text$mn:0000B3F3
.text$mn:0000B3F4 ; ===========================================================================
.text$mn:0000B3F4
.text$mn:0000B3F4 ; Segment type: Pure code
.text$mn:0000B3F4 ; Segment permissions: Read/Execute
.text$mn:0000B3F4 _text$mn        segment para public 'CODE' use32
.text$mn:0000B3F4                 assume cs:_text$mn
.text$mn:0000B3F4                 ;org 0B3F4h
.text$mn:0000B3F4 ; COMDAT (pick any)
.text$mn:0000B3F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B3F4
.text$mn:0000B3F4 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B3F4
.text$mn:0000B3F4 ; Attributes: bp-based frame
.text$mn:0000B3F4
.text$mn:0000B3F4 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:0000B3F4                 public _wmemcpy
.text$mn:0000B3F4 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:0000B3F4
.text$mn:0000B3F4 Dst             = dword ptr  8
.text$mn:0000B3F4 Src             = dword ptr  0Ch
.text$mn:0000B3F4 arg_8           = dword ptr  10h
.text$mn:0000B3F4
.text$mn:0000B3F4                 push    ebp
.text$mn:0000B3F5                 mov     ebp, esp
.text$mn:0000B3F7                 mov     eax, [ebp+arg_8]
.text$mn:0000B3FA                 shl     eax, 1
.text$mn:0000B3FC                 push    eax             ; Size
.text$mn:0000B3FD                 mov     ecx, [ebp+Src]
.text$mn:0000B400                 push    ecx             ; Src
.text$mn:0000B401                 mov     edx, [ebp+Dst]
.text$mn:0000B404                 push    edx             ; Dst
.text$mn:0000B405                 call    _memcpy
.text$mn:0000B40A                 add     esp, 0Ch
.text$mn:0000B40D                 pop     ebp
.text$mn:0000B40E                 retn
.text$mn:0000B40E _wmemcpy        endp
.text$mn:0000B40E
.text$mn:0000B40E ; ---------------------------------------------------------------------------
.text$mn:0000B40F                 align 10h
.text$mn:0000B40F _text$mn        ends
.text$mn:0000B40F
.text$mn:0000B410 ; ===========================================================================
.text$mn:0000B410
.text$mn:0000B410 ; Segment type: Pure code
.text$mn:0000B410 ; Segment permissions: Read/Execute
.text$mn:0000B410 _text$mn        segment para public 'CODE' use32
.text$mn:0000B410                 assume cs:_text$mn
.text$mn:0000B410                 ;org 0B410h
.text$mn:0000B410 ; COMDAT (pick any)
.text$mn:0000B410                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000B410
.text$mn:0000B410 ; =============== S U B R O U T I N E =======================================
.text$mn:0000B410
.text$mn:0000B410 ; Attributes: bp-based frame
.text$mn:0000B410
.text$mn:0000B410 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:0000B410                 public _wmemmove
.text$mn:0000B410 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:0000B410
.text$mn:0000B410 Dst             = dword ptr  8
.text$mn:0000B410 Src             = dword ptr  0Ch
.text$mn:0000B410 arg_8           = dword ptr  10h
.text$mn:0000B410
.text$mn:0000B410                 push    ebp
.text$mn:0000B411                 mov     ebp, esp
.text$mn:0000B413                 mov     eax, [ebp+arg_8]
.text$mn:0000B416                 shl     eax, 1
.text$mn:0000B418                 push    eax             ; Size
.text$mn:0000B419                 mov     ecx, [ebp+Src]
.text$mn:0000B41C                 push    ecx             ; Src
.text$mn:0000B41D                 mov     edx, [ebp+Dst]
.text$mn:0000B420                 push    edx             ; Dst
.text$mn:0000B421                 call    _memmove
.text$mn:0000B426                 add     esp, 0Ch
.text$mn:0000B429                 pop     ebp
.text$mn:0000B42A                 retn
.text$mn:0000B42A _wmemmove       endp
.text$mn:0000B42A
.text$mn:0000B42A ; ---------------------------------------------------------------------------
.text$mn:0000B42B                 align 4
.text$mn:0000B42B _text$mn        ends
.text$mn:0000B42B
.xdata$x:0000B42C ; ===========================================================================
.xdata$x:0000B42C
.xdata$x:0000B42C ; Segment type: Pure data
.xdata$x:0000B42C ; Segment permissions: Read
.xdata$x:0000B42C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B42C                 assume cs:_xdata$x
.xdata$x:0000B42C                 ;org 0B42Ch
.xdata$x:0000B42C ; COMDAT (pick associative to section at 89C8)
.xdata$x:0000B42C __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:0000B42C                                         ; DATA XREF: .xdata$x:0000B43Co
.xdata$x:0000B42D                 db 0FFh
.xdata$x:0000B42E                 db 0FFh
.xdata$x:0000B42F                 db 0FFh
.xdata$x:0000B430                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:0000B434 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:0000B434                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:0000B435                 db    5
.xdata$x:0000B436                 db  93h ; ô
.xdata$x:0000B437                 db  19h
.xdata$x:0000B438                 db    1
.xdata$x:0000B439                 db    0
.xdata$x:0000B43A                 db    0
.xdata$x:0000B43B                 db    0
.xdata$x:0000B43C                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:0000B440                 db    0
.xdata$x:0000B441                 db    0
.xdata$x:0000B442                 db    0
.xdata$x:0000B443                 db    0
.xdata$x:0000B444                 db    0
.xdata$x:0000B445                 db    0
.xdata$x:0000B446                 db    0
.xdata$x:0000B447                 db    0
.xdata$x:0000B448                 db    0
.xdata$x:0000B449                 db    0
.xdata$x:0000B44A                 db    0
.xdata$x:0000B44B                 db    0
.xdata$x:0000B44C                 db    0
.xdata$x:0000B44D                 db    0
.xdata$x:0000B44E                 db    0
.xdata$x:0000B44F                 db    0
.xdata$x:0000B450                 db    0
.xdata$x:0000B451                 db    0
.xdata$x:0000B452                 db    0
.xdata$x:0000B453                 db    0
.xdata$x:0000B454                 db    0
.xdata$x:0000B455                 db    0
.xdata$x:0000B456                 db    0
.xdata$x:0000B457                 db    0
.xdata$x:0000B457 _xdata$x        ends
.xdata$x:0000B457
.xdata$x:0000B458 ; ===========================================================================
.xdata$x:0000B458
.xdata$x:0000B458 ; Segment type: Pure data
.xdata$x:0000B458 ; Segment permissions: Read
.xdata$x:0000B458 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B458                 assume cs:_xdata$x
.xdata$x:0000B458                 ;org 0B458h
.xdata$x:0000B458 ; COMDAT (pick associative to section at 760C)
.xdata$x:0000B458 __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:0000B458                                         ; DATA XREF: .xdata$x:0000B468o
.xdata$x:0000B459                 db 0FFh
.xdata$x:0000B45A                 db 0FFh
.xdata$x:0000B45B                 db 0FFh
.xdata$x:0000B45C                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:0000B460 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:0000B460                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:0000B461                 db    5
.xdata$x:0000B462                 db  93h ; ô
.xdata$x:0000B463                 db  19h
.xdata$x:0000B464                 db    1
.xdata$x:0000B465                 db    0
.xdata$x:0000B466                 db    0
.xdata$x:0000B467                 db    0
.xdata$x:0000B468                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:0000B46C                 db    0
.xdata$x:0000B46D                 db    0
.xdata$x:0000B46E                 db    0
.xdata$x:0000B46F                 db    0
.xdata$x:0000B470                 db    0
.xdata$x:0000B471                 db    0
.xdata$x:0000B472                 db    0
.xdata$x:0000B473                 db    0
.xdata$x:0000B474                 db    0
.xdata$x:0000B475                 db    0
.xdata$x:0000B476                 db    0
.xdata$x:0000B477                 db    0
.xdata$x:0000B478                 db    0
.xdata$x:0000B479                 db    0
.xdata$x:0000B47A                 db    0
.xdata$x:0000B47B                 db    0
.xdata$x:0000B47C                 db    0
.xdata$x:0000B47D                 db    0
.xdata$x:0000B47E                 db    0
.xdata$x:0000B47F                 db    0
.xdata$x:0000B480                 db    0
.xdata$x:0000B481                 db    0
.xdata$x:0000B482                 db    0
.xdata$x:0000B483                 db    0
.xdata$x:0000B483 _xdata$x        ends
.xdata$x:0000B483
.xdata$x:0000B484 ; ===========================================================================
.xdata$x:0000B484
.xdata$x:0000B484 ; Segment type: Pure data
.xdata$x:0000B484 ; Segment permissions: Read
.xdata$x:0000B484 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B484                 assume cs:_xdata$x
.xdata$x:0000B484                 ;org 0B484h
.xdata$x:0000B484 ; COMDAT (pick associative to section at 7444)
.xdata$x:0000B484 __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:0000B484                                         ; DATA XREF: .xdata$x:0000B494o
.xdata$x:0000B485                 db 0FFh
.xdata$x:0000B486                 db 0FFh
.xdata$x:0000B487                 db 0FFh
.xdata$x:0000B488                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:0000B48C __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:0000B48C                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:0000B48D                 db    5
.xdata$x:0000B48E                 db  93h ; ô
.xdata$x:0000B48F                 db  19h
.xdata$x:0000B490                 db    1
.xdata$x:0000B491                 db    0
.xdata$x:0000B492                 db    0
.xdata$x:0000B493                 db    0
.xdata$x:0000B494                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:0000B498                 db    0
.xdata$x:0000B499                 db    0
.xdata$x:0000B49A                 db    0
.xdata$x:0000B49B                 db    0
.xdata$x:0000B49C                 db    0
.xdata$x:0000B49D                 db    0
.xdata$x:0000B49E                 db    0
.xdata$x:0000B49F                 db    0
.xdata$x:0000B4A0                 db    0
.xdata$x:0000B4A1                 db    0
.xdata$x:0000B4A2                 db    0
.xdata$x:0000B4A3                 db    0
.xdata$x:0000B4A4                 db    0
.xdata$x:0000B4A5                 db    0
.xdata$x:0000B4A6                 db    0
.xdata$x:0000B4A7                 db    0
.xdata$x:0000B4A8                 db    0
.xdata$x:0000B4A9                 db    0
.xdata$x:0000B4AA                 db    0
.xdata$x:0000B4AB                 db    0
.xdata$x:0000B4AC                 db    0
.xdata$x:0000B4AD                 db    0
.xdata$x:0000B4AE                 db    0
.xdata$x:0000B4AF                 db    0
.xdata$x:0000B4AF _xdata$x        ends
.xdata$x:0000B4AF
.xdata$x:0000B4B0 ; ===========================================================================
.xdata$x:0000B4B0
.xdata$x:0000B4B0 ; Segment type: Pure data
.xdata$x:0000B4B0 ; Segment permissions: Read
.xdata$x:0000B4B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B4B0                 assume cs:_xdata$x
.xdata$x:0000B4B0                 ;org 0B4B0h
.xdata$x:0000B4B0 ; COMDAT (pick associative to section at 7B68)
.xdata$x:0000B4B0 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:0000B4B0                                         ; DATA XREF: .xdata$x:0000B4C8o
.xdata$x:0000B4B1                 db 0FFh
.xdata$x:0000B4B2                 db 0FFh
.xdata$x:0000B4B3                 db 0FFh
.xdata$x:0000B4B4                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:0000B4B8                 db 0FFh
.xdata$x:0000B4B9                 db 0FFh
.xdata$x:0000B4BA                 db 0FFh
.xdata$x:0000B4BB                 db 0FFh
.xdata$x:0000B4BC                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:0000B4C0 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:0000B4C0                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:0000B4C1                 db    5
.xdata$x:0000B4C2                 db  93h ; ô
.xdata$x:0000B4C3                 db  19h
.xdata$x:0000B4C4                 db    2
.xdata$x:0000B4C5                 db    0
.xdata$x:0000B4C6                 db    0
.xdata$x:0000B4C7                 db    0
.xdata$x:0000B4C8                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:0000B4CC                 db    0
.xdata$x:0000B4CD                 db    0
.xdata$x:0000B4CE                 db    0
.xdata$x:0000B4CF                 db    0
.xdata$x:0000B4D0                 db    0
.xdata$x:0000B4D1                 db    0
.xdata$x:0000B4D2                 db    0
.xdata$x:0000B4D3                 db    0
.xdata$x:0000B4D4                 db    0
.xdata$x:0000B4D5                 db    0
.xdata$x:0000B4D6                 db    0
.xdata$x:0000B4D7                 db    0
.xdata$x:0000B4D8                 db    0
.xdata$x:0000B4D9                 db    0
.xdata$x:0000B4DA                 db    0
.xdata$x:0000B4DB                 db    0
.xdata$x:0000B4DC                 db    0
.xdata$x:0000B4DD                 db    0
.xdata$x:0000B4DE                 db    0
.xdata$x:0000B4DF                 db    0
.xdata$x:0000B4E0                 db    0
.xdata$x:0000B4E1                 db    0
.xdata$x:0000B4E2                 db    0
.xdata$x:0000B4E3                 db    0
.xdata$x:0000B4E3 _xdata$x        ends
.xdata$x:0000B4E3
.xdata$x:0000B4E4 ; ===========================================================================
.xdata$x:0000B4E4
.xdata$x:0000B4E4 ; Segment type: Pure data
.xdata$x:0000B4E4 ; Segment permissions: Read
.xdata$x:0000B4E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B4E4                 assume cs:_xdata$x
.xdata$x:0000B4E4                 ;org 0B4E4h
.xdata$x:0000B4E4 ; COMDAT (pick associative to section at 6060)
.xdata$x:0000B4E4 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000B4E4                                         ; DATA XREF: .xdata$x:0000B4F4o
.xdata$x:0000B4E5                 db 0FFh
.xdata$x:0000B4E6                 db 0FFh
.xdata$x:0000B4E7                 db 0FFh
.xdata$x:0000B4E8                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000B4EC __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000B4EC                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000B4ED                 db    5
.xdata$x:0000B4EE                 db  93h ; ô
.xdata$x:0000B4EF                 db  19h
.xdata$x:0000B4F0                 db    1
.xdata$x:0000B4F1                 db    0
.xdata$x:0000B4F2                 db    0
.xdata$x:0000B4F3                 db    0
.xdata$x:0000B4F4                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000B4F8                 db    0
.xdata$x:0000B4F9                 db    0
.xdata$x:0000B4FA                 db    0
.xdata$x:0000B4FB                 db    0
.xdata$x:0000B4FC                 db    0
.xdata$x:0000B4FD                 db    0
.xdata$x:0000B4FE                 db    0
.xdata$x:0000B4FF                 db    0
.xdata$x:0000B500                 db    0
.xdata$x:0000B501                 db    0
.xdata$x:0000B502                 db    0
.xdata$x:0000B503                 db    0
.xdata$x:0000B504                 db    0
.xdata$x:0000B505                 db    0
.xdata$x:0000B506                 db    0
.xdata$x:0000B507                 db    0
.xdata$x:0000B508                 db    0
.xdata$x:0000B509                 db    0
.xdata$x:0000B50A                 db    0
.xdata$x:0000B50B                 db    0
.xdata$x:0000B50C                 db    0
.xdata$x:0000B50D                 db    0
.xdata$x:0000B50E                 db    0
.xdata$x:0000B50F                 db    0
.xdata$x:0000B50F _xdata$x        ends
.xdata$x:0000B50F
.xdata$x:0000B510 ; ===========================================================================
.xdata$x:0000B510
.xdata$x:0000B510 ; Segment type: Pure data
.xdata$x:0000B510 ; Segment permissions: Read
.xdata$x:0000B510 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B510                 assume cs:_xdata$x
.xdata$x:0000B510                 ;org 0B510h
.xdata$x:0000B510 ; COMDAT (pick associative to section at 6E9C)
.xdata$x:0000B510 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000B510                                         ; DATA XREF: .xdata$x:0000B520o
.xdata$x:0000B511                 db 0FFh
.xdata$x:0000B512                 db 0FFh
.xdata$x:0000B513                 db 0FFh
.xdata$x:0000B514                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000B518 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000B518                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000B519                 db    5
.xdata$x:0000B51A                 db  93h ; ô
.xdata$x:0000B51B                 db  19h
.xdata$x:0000B51C                 db    1
.xdata$x:0000B51D                 db    0
.xdata$x:0000B51E                 db    0
.xdata$x:0000B51F                 db    0
.xdata$x:0000B520                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000B524                 db    0
.xdata$x:0000B525                 db    0
.xdata$x:0000B526                 db    0
.xdata$x:0000B527                 db    0
.xdata$x:0000B528                 db    0
.xdata$x:0000B529                 db    0
.xdata$x:0000B52A                 db    0
.xdata$x:0000B52B                 db    0
.xdata$x:0000B52C                 db    0
.xdata$x:0000B52D                 db    0
.xdata$x:0000B52E                 db    0
.xdata$x:0000B52F                 db    0
.xdata$x:0000B530                 db    0
.xdata$x:0000B531                 db    0
.xdata$x:0000B532                 db    0
.xdata$x:0000B533                 db    0
.xdata$x:0000B534                 db    0
.xdata$x:0000B535                 db    0
.xdata$x:0000B536                 db    0
.xdata$x:0000B537                 db    0
.xdata$x:0000B538                 db    0
.xdata$x:0000B539                 db    0
.xdata$x:0000B53A                 db    0
.xdata$x:0000B53B                 db    0
.xdata$x:0000B53B _xdata$x        ends
.xdata$x:0000B53B
.xdata$x:0000B53C ; ===========================================================================
.xdata$x:0000B53C
.xdata$x:0000B53C ; Segment type: Pure data
.xdata$x:0000B53C ; Segment permissions: Read
.xdata$x:0000B53C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B53C                 assume cs:_xdata$x
.xdata$x:0000B53C                 ;org 0B53Ch
.xdata$x:0000B53C ; COMDAT (pick associative to section at 5F68)
.xdata$x:0000B53C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:0000B53C                                         ; DATA XREF: .xdata$x:0000B54Co
.xdata$x:0000B53D                 db 0FFh
.xdata$x:0000B53E                 db 0FFh
.xdata$x:0000B53F                 db 0FFh
.xdata$x:0000B540                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:0000B544 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:0000B544                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:0000B545                 db    5
.xdata$x:0000B546                 db  93h ; ô
.xdata$x:0000B547                 db  19h
.xdata$x:0000B548                 db    1
.xdata$x:0000B549                 db    0
.xdata$x:0000B54A                 db    0
.xdata$x:0000B54B                 db    0
.xdata$x:0000B54C                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:0000B550                 db    0
.xdata$x:0000B551                 db    0
.xdata$x:0000B552                 db    0
.xdata$x:0000B553                 db    0
.xdata$x:0000B554                 db    0
.xdata$x:0000B555                 db    0
.xdata$x:0000B556                 db    0
.xdata$x:0000B557                 db    0
.xdata$x:0000B558                 db    0
.xdata$x:0000B559                 db    0
.xdata$x:0000B55A                 db    0
.xdata$x:0000B55B                 db    0
.xdata$x:0000B55C                 db    0
.xdata$x:0000B55D                 db    0
.xdata$x:0000B55E                 db    0
.xdata$x:0000B55F                 db    0
.xdata$x:0000B560                 db    0
.xdata$x:0000B561                 db    0
.xdata$x:0000B562                 db    0
.xdata$x:0000B563                 db    0
.xdata$x:0000B564                 db    0
.xdata$x:0000B565                 db    0
.xdata$x:0000B566                 db    0
.xdata$x:0000B567                 db    0
.xdata$x:0000B567 _xdata$x        ends
.xdata$x:0000B567
.xdata$x:0000B568 ; ===========================================================================
.xdata$x:0000B568
.xdata$x:0000B568 ; Segment type: Pure data
.xdata$x:0000B568 ; Segment permissions: Read
.xdata$x:0000B568 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B568                 assume cs:_xdata$x
.xdata$x:0000B568                 ;org 0B568h
.xdata$x:0000B568 ; COMDAT (pick associative to section at 6DAC)
.xdata$x:0000B568 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000B568                                         ; DATA XREF: .xdata$x:0000B578o
.xdata$x:0000B569                 db 0FFh
.xdata$x:0000B56A                 db 0FFh
.xdata$x:0000B56B                 db 0FFh
.xdata$x:0000B56C                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000B570 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000B570                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000B571                 db    5
.xdata$x:0000B572                 db  93h ; ô
.xdata$x:0000B573                 db  19h
.xdata$x:0000B574                 db    1
.xdata$x:0000B575                 db    0
.xdata$x:0000B576                 db    0
.xdata$x:0000B577                 db    0
.xdata$x:0000B578                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:0000B57C                 db    0
.xdata$x:0000B57D                 db    0
.xdata$x:0000B57E                 db    0
.xdata$x:0000B57F                 db    0
.xdata$x:0000B580                 db    0
.xdata$x:0000B581                 db    0
.xdata$x:0000B582                 db    0
.xdata$x:0000B583                 db    0
.xdata$x:0000B584                 db    0
.xdata$x:0000B585                 db    0
.xdata$x:0000B586                 db    0
.xdata$x:0000B587                 db    0
.xdata$x:0000B588                 db    0
.xdata$x:0000B589                 db    0
.xdata$x:0000B58A                 db    0
.xdata$x:0000B58B                 db    0
.xdata$x:0000B58C                 db    0
.xdata$x:0000B58D                 db    0
.xdata$x:0000B58E                 db    0
.xdata$x:0000B58F                 db    0
.xdata$x:0000B590                 db    0
.xdata$x:0000B591                 db    0
.xdata$x:0000B592                 db    0
.xdata$x:0000B593                 db    0
.xdata$x:0000B593 _xdata$x        ends
.xdata$x:0000B593
.xdata$x:0000B594 ; ===========================================================================
.xdata$x:0000B594
.xdata$x:0000B594 ; Segment type: Pure data
.xdata$x:0000B594 ; Segment permissions: Read
.xdata$x:0000B594 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B594                 assume cs:_xdata$x
.xdata$x:0000B594                 ;org 0B594h
.xdata$x:0000B594 ; COMDAT (pick associative to section at 6430)
.xdata$x:0000B594 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000B594                                         ; DATA XREF: .xdata$x:0000B5A4o
.xdata$x:0000B595                 db 0FFh
.xdata$x:0000B596                 db 0FFh
.xdata$x:0000B597                 db 0FFh
.xdata$x:0000B598                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:0000B59C __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000B59C                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:0000B59D                 db    5
.xdata$x:0000B59E                 db  93h ; ô
.xdata$x:0000B59F                 db  19h
.xdata$x:0000B5A0                 db    1
.xdata$x:0000B5A1                 db    0
.xdata$x:0000B5A2                 db    0
.xdata$x:0000B5A3                 db    0
.xdata$x:0000B5A4                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:0000B5A8                 align 20h
.xdata$x:0000B5A8 _xdata$x        ends
.xdata$x:0000B5A8
.xdata$x:0000B5C0 ; ===========================================================================
.xdata$x:0000B5C0
.xdata$x:0000B5C0 ; Segment type: Pure data
.xdata$x:0000B5C0 ; Segment permissions: Read
.xdata$x:0000B5C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B5C0                 assume cs:_xdata$x
.xdata$x:0000B5C0                 ;org 0B5C0h
.xdata$x:0000B5C0 ; COMDAT (pick associative to section at 6398)
.xdata$x:0000B5C0 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:0000B5C0                                         ; DATA XREF: .xdata$x:0000B5D0o
.xdata$x:0000B5C1                 db 0FFh
.xdata$x:0000B5C2                 db 0FFh
.xdata$x:0000B5C3                 db 0FFh
.xdata$x:0000B5C4                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:0000B5C8 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000B5C8                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:0000B5C9                 db    5
.xdata$x:0000B5CA                 db  93h ; ô
.xdata$x:0000B5CB                 db  19h
.xdata$x:0000B5CC                 db    1
.xdata$x:0000B5CD                 db    0
.xdata$x:0000B5CE                 db    0
.xdata$x:0000B5CF                 db    0
.xdata$x:0000B5D0                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:0000B5D4                 db    0
.xdata$x:0000B5D5                 db    0
.xdata$x:0000B5D6                 db    0
.xdata$x:0000B5D7                 db    0
.xdata$x:0000B5D8                 db    0
.xdata$x:0000B5D9                 db    0
.xdata$x:0000B5DA                 db    0
.xdata$x:0000B5DB                 db    0
.xdata$x:0000B5DC                 db    0
.xdata$x:0000B5DD                 db    0
.xdata$x:0000B5DE                 db    0
.xdata$x:0000B5DF                 db    0
.xdata$x:0000B5E0                 db    0
.xdata$x:0000B5E1                 db    0
.xdata$x:0000B5E2                 db    0
.xdata$x:0000B5E3                 db    0
.xdata$x:0000B5E4                 db    0
.xdata$x:0000B5E5                 db    0
.xdata$x:0000B5E6                 db    0
.xdata$x:0000B5E7                 db    0
.xdata$x:0000B5E8                 db    0
.xdata$x:0000B5E9                 db    0
.xdata$x:0000B5EA                 db    0
.xdata$x:0000B5EB                 db    0
.xdata$x:0000B5EB _xdata$x        ends
.xdata$x:0000B5EB
.xdata$x:0000B5EC ; ===========================================================================
.xdata$x:0000B5EC
.xdata$x:0000B5EC ; Segment type: Pure data
.xdata$x:0000B5EC ; Segment permissions: Read
.xdata$x:0000B5EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B5EC                 assume cs:_xdata$x
.xdata$x:0000B5EC                 ;org 0B5ECh
.xdata$x:0000B5EC ; COMDAT (pick associative to section at 7064)
.xdata$x:0000B5EC __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000B5EC                                         ; DATA XREF: .xdata$x:0000B5FCo
.xdata$x:0000B5ED                 db 0FFh
.xdata$x:0000B5EE                 db 0FFh
.xdata$x:0000B5EF                 db 0FFh
.xdata$x:0000B5F0                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:0000B5F4 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000B5F4                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:0000B5F5                 db    5
.xdata$x:0000B5F6                 db  93h ; ô
.xdata$x:0000B5F7                 db  19h
.xdata$x:0000B5F8                 db    1
.xdata$x:0000B5F9                 db    0
.xdata$x:0000B5FA                 db    0
.xdata$x:0000B5FB                 db    0
.xdata$x:0000B5FC                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:0000B600                 db    0
.xdata$x:0000B601                 db    0
.xdata$x:0000B602                 db    0
.xdata$x:0000B603                 db    0
.xdata$x:0000B604                 db    0
.xdata$x:0000B605                 db    0
.xdata$x:0000B606                 db    0
.xdata$x:0000B607                 db    0
.xdata$x:0000B608                 db    0
.xdata$x:0000B609                 db    0
.xdata$x:0000B60A                 db    0
.xdata$x:0000B60B                 db    0
.xdata$x:0000B60C                 db    0
.xdata$x:0000B60D                 db    0
.xdata$x:0000B60E                 db    0
.xdata$x:0000B60F                 db    0
.xdata$x:0000B610                 db    0
.xdata$x:0000B611                 db    0
.xdata$x:0000B612                 db    0
.xdata$x:0000B613                 db    0
.xdata$x:0000B614                 db    0
.xdata$x:0000B615                 db    0
.xdata$x:0000B616                 db    0
.xdata$x:0000B617                 db    0
.xdata$x:0000B617 _xdata$x        ends
.xdata$x:0000B617
.xdata$x:0000B618 ; ===========================================================================
.xdata$x:0000B618
.xdata$x:0000B618 ; Segment type: Pure data
.xdata$x:0000B618 ; Segment permissions: Read
.xdata$x:0000B618 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B618                 assume cs:_xdata$x
.xdata$x:0000B618                 ;org 0B618h
.xdata$x:0000B618 ; COMDAT (pick associative to section at 7D88)
.xdata$x:0000B618 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000B618                                         ; DATA XREF: .xdata$x:0000B6A0o
.xdata$x:0000B619                 db    0
.xdata$x:0000B61A                 db    0
.xdata$x:0000B61B                 db    0
.xdata$x:0000B61C                 db    0
.xdata$x:0000B61D                 db    0
.xdata$x:0000B61E                 db    0
.xdata$x:0000B61F                 db    0
.xdata$x:0000B620                 db    0
.xdata$x:0000B621                 db    0
.xdata$x:0000B622                 db    0
.xdata$x:0000B623                 db    0
.xdata$x:0000B624                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:0000B628 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000B628                                         ; DATA XREF: .xdata$x:0000B68Co
.xdata$x:0000B629                 db    0
.xdata$x:0000B62A                 db    0
.xdata$x:0000B62B                 db    0
.xdata$x:0000B62C                 db    0
.xdata$x:0000B62D                 db    0
.xdata$x:0000B62E                 db    0
.xdata$x:0000B62F                 db    0
.xdata$x:0000B630                 db    0
.xdata$x:0000B631                 db    0
.xdata$x:0000B632                 db    0
.xdata$x:0000B633                 db    0
.xdata$x:0000B634                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:0000B638 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000B638                                         ; DATA XREF: .xdata$x:0000B660o
.xdata$x:0000B639                 db 0FFh
.xdata$x:0000B63A                 db 0FFh
.xdata$x:0000B63B                 db 0FFh
.xdata$x:0000B63C                 db    0
.xdata$x:0000B63D                 db    0
.xdata$x:0000B63E                 db    0
.xdata$x:0000B63F                 db    0
.xdata$x:0000B640                 db 0FFh
.xdata$x:0000B641                 db 0FFh
.xdata$x:0000B642                 db 0FFh
.xdata$x:0000B643                 db 0FFh
.xdata$x:0000B644                 db    0
.xdata$x:0000B645                 db    0
.xdata$x:0000B646                 db    0
.xdata$x:0000B647                 db    0
.xdata$x:0000B648                 db    1
.xdata$x:0000B649                 db    0
.xdata$x:0000B64A                 db    0
.xdata$x:0000B64B                 db    0
.xdata$x:0000B64C                 db    0
.xdata$x:0000B64D                 db    0
.xdata$x:0000B64E                 db    0
.xdata$x:0000B64F                 db    0
.xdata$x:0000B650                 db    1
.xdata$x:0000B651                 db    0
.xdata$x:0000B652                 db    0
.xdata$x:0000B653                 db    0
.xdata$x:0000B654                 db    0
.xdata$x:0000B655                 db    0
.xdata$x:0000B656                 db    0
.xdata$x:0000B657                 db    0
.xdata$x:0000B658 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000B658                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:0000B659                 db    5
.xdata$x:0000B65A                 db  93h ; ô
.xdata$x:0000B65B                 db  19h
.xdata$x:0000B65C                 db    4
.xdata$x:0000B65D                 db    0
.xdata$x:0000B65E                 db    0
.xdata$x:0000B65F                 db    0
.xdata$x:0000B660                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000B664                 db    2
.xdata$x:0000B665                 db    0
.xdata$x:0000B666                 db    0
.xdata$x:0000B667                 db    0
.xdata$x:0000B668                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000B66C                 db    0
.xdata$x:0000B66D                 db    0
.xdata$x:0000B66E                 db    0
.xdata$x:0000B66F                 db    0
.xdata$x:0000B670                 db    0
.xdata$x:0000B671                 db    0
.xdata$x:0000B672                 db    0
.xdata$x:0000B673                 db    0
.xdata$x:0000B674                 db    0
.xdata$x:0000B675                 db    0
.xdata$x:0000B676                 db    0
.xdata$x:0000B677                 db    0
.xdata$x:0000B678                 db    0
.xdata$x:0000B679                 db    0
.xdata$x:0000B67A                 db    0
.xdata$x:0000B67B                 db    0
.xdata$x:0000B67C __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:0000B67C                                         ; DATA XREF: .xdata$x:0000B668o
.xdata$x:0000B67D                 db    0
.xdata$x:0000B67E                 db    0
.xdata$x:0000B67F                 db    0
.xdata$x:0000B680                 db    2
.xdata$x:0000B681                 db    0
.xdata$x:0000B682                 db    0
.xdata$x:0000B683                 db    0
.xdata$x:0000B684                 db    3
.xdata$x:0000B685                 db    0
.xdata$x:0000B686                 db    0
.xdata$x:0000B687                 db    0
.xdata$x:0000B688                 db    1
.xdata$x:0000B689                 db    0
.xdata$x:0000B68A                 db    0
.xdata$x:0000B68B                 db    0
.xdata$x:0000B68C                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:0000B690                 db    0
.xdata$x:0000B691                 db    0
.xdata$x:0000B692                 db    0
.xdata$x:0000B693                 db    0
.xdata$x:0000B694                 db    0
.xdata$x:0000B695                 db    0
.xdata$x:0000B696                 db    0
.xdata$x:0000B697                 db    0
.xdata$x:0000B698                 db    3
.xdata$x:0000B699                 db    0
.xdata$x:0000B69A                 db    0
.xdata$x:0000B69B                 db    0
.xdata$x:0000B69C                 db    1
.xdata$x:0000B69D                 db    0
.xdata$x:0000B69E                 db    0
.xdata$x:0000B69F                 db    0
.xdata$x:0000B6A0                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:0000B6A0 _xdata$x        ends
.xdata$x:0000B6A0
.xdata$x:0000B6A4 ; ===========================================================================
.xdata$x:0000B6A4
.xdata$x:0000B6A4 ; Segment type: Pure data
.xdata$x:0000B6A4 ; Segment permissions: Read
.xdata$x:0000B6A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B6A4                 assume cs:_xdata$x
.xdata$x:0000B6A4                 ;org 0B6A4h
.xdata$x:0000B6A4 ; COMDAT (pick associative to section at 6908)
.xdata$x:0000B6A4 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000B6A4                                         ; DATA XREF: .xdata$x:0000B6B4o
.xdata$x:0000B6A5                 db 0FFh
.xdata$x:0000B6A6                 db 0FFh
.xdata$x:0000B6A7                 db 0FFh
.xdata$x:0000B6A8                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:0000B6AC __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000B6AC                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:0000B6AD                 db    5
.xdata$x:0000B6AE                 db  93h ; ô
.xdata$x:0000B6AF                 db  19h
.xdata$x:0000B6B0                 db    1
.xdata$x:0000B6B1                 db    0
.xdata$x:0000B6B2                 db    0
.xdata$x:0000B6B3                 db    0
.xdata$x:0000B6B4                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:0000B6B8                 db    0
.xdata$x:0000B6B9                 db    0
.xdata$x:0000B6BA                 db    0
.xdata$x:0000B6BB                 db    0
.xdata$x:0000B6BC                 db    0
.xdata$x:0000B6BD                 db    0
.xdata$x:0000B6BE                 db    0
.xdata$x:0000B6BF                 db    0
.xdata$x:0000B6C0                 db    0
.xdata$x:0000B6C1                 db    0
.xdata$x:0000B6C2                 db    0
.xdata$x:0000B6C3                 db    0
.xdata$x:0000B6C4                 db    0
.xdata$x:0000B6C5                 db    0
.xdata$x:0000B6C6                 db    0
.xdata$x:0000B6C7                 db    0
.xdata$x:0000B6C8                 db    0
.xdata$x:0000B6C9                 db    0
.xdata$x:0000B6CA                 db    0
.xdata$x:0000B6CB                 db    0
.xdata$x:0000B6CC                 db    0
.xdata$x:0000B6CD                 db    0
.xdata$x:0000B6CE                 db    0
.xdata$x:0000B6CF                 db    0
.xdata$x:0000B6CF _xdata$x        ends
.xdata$x:0000B6CF
.xdata$x:0000B6D0 ; ===========================================================================
.xdata$x:0000B6D0
.xdata$x:0000B6D0 ; Segment type: Pure data
.xdata$x:0000B6D0 ; Segment permissions: Read
.xdata$x:0000B6D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B6D0                 assume cs:_xdata$x
.xdata$x:0000B6D0                 ;org 0B6D0h
.xdata$x:0000B6D0 ; COMDAT (pick associative to section at AB10)
.xdata$x:0000B6D0 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000B6D0                                         ; DATA XREF: .xdata$x:0000B6E0o
.xdata$x:0000B6D1                 db 0FFh
.xdata$x:0000B6D2                 db 0FFh
.xdata$x:0000B6D3                 db 0FFh
.xdata$x:0000B6D4                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000B6D8 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000B6D8                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000B6D9                 db    5
.xdata$x:0000B6DA                 db  93h ; ô
.xdata$x:0000B6DB                 db  19h
.xdata$x:0000B6DC                 db    1
.xdata$x:0000B6DD                 db    0
.xdata$x:0000B6DE                 db    0
.xdata$x:0000B6DF                 db    0
.xdata$x:0000B6E0                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000B6E4                 db    0
.xdata$x:0000B6E5                 db    0
.xdata$x:0000B6E6                 db    0
.xdata$x:0000B6E7                 db    0
.xdata$x:0000B6E8                 db    0
.xdata$x:0000B6E9                 db    0
.xdata$x:0000B6EA                 db    0
.xdata$x:0000B6EB                 db    0
.xdata$x:0000B6EC                 db    0
.xdata$x:0000B6ED                 db    0
.xdata$x:0000B6EE                 db    0
.xdata$x:0000B6EF                 db    0
.xdata$x:0000B6F0                 db    0
.xdata$x:0000B6F1                 db    0
.xdata$x:0000B6F2                 db    0
.xdata$x:0000B6F3                 db    0
.xdata$x:0000B6F4                 db    0
.xdata$x:0000B6F5                 db    0
.xdata$x:0000B6F6                 db    0
.xdata$x:0000B6F7                 db    0
.xdata$x:0000B6F8                 db    0
.xdata$x:0000B6F9                 db    0
.xdata$x:0000B6FA                 db    0
.xdata$x:0000B6FB                 db    0
.xdata$x:0000B6FB _xdata$x        ends
.xdata$x:0000B6FB
.xdata$x:0000B6FC ; ===========================================================================
.xdata$x:0000B6FC
.xdata$x:0000B6FC ; Segment type: Pure data
.xdata$x:0000B6FC ; Segment permissions: Read
.xdata$x:0000B6FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B6FC                 assume cs:_xdata$x
.xdata$x:0000B6FC                 ;org 0B6FCh
.xdata$x:0000B6FC ; COMDAT (pick associative to section at 7364)
.xdata$x:0000B6FC __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000B6FC                                         ; DATA XREF: .xdata$x:0000B70Co
.xdata$x:0000B6FD                 db 0FFh
.xdata$x:0000B6FE                 db 0FFh
.xdata$x:0000B6FF                 db 0FFh
.xdata$x:0000B700                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:0000B704 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000B704                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:0000B705                 db    5
.xdata$x:0000B706                 db  93h ; ô
.xdata$x:0000B707                 db  19h
.xdata$x:0000B708                 db    1
.xdata$x:0000B709                 db    0
.xdata$x:0000B70A                 db    0
.xdata$x:0000B70B                 db    0
.xdata$x:0000B70C                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:0000B710                 db    0
.xdata$x:0000B711                 db    0
.xdata$x:0000B712                 db    0
.xdata$x:0000B713                 db    0
.xdata$x:0000B714                 db    0
.xdata$x:0000B715                 db    0
.xdata$x:0000B716                 db    0
.xdata$x:0000B717                 db    0
.xdata$x:0000B718                 db    0
.xdata$x:0000B719                 db    0
.xdata$x:0000B71A                 db    0
.xdata$x:0000B71B                 db    0
.xdata$x:0000B71C                 db    0
.xdata$x:0000B71D                 db    0
.xdata$x:0000B71E                 db    0
.xdata$x:0000B71F                 db    0
.xdata$x:0000B720                 db    0
.xdata$x:0000B721                 db    0
.xdata$x:0000B722                 db    0
.xdata$x:0000B723                 db    0
.xdata$x:0000B724                 db    0
.xdata$x:0000B725                 db    0
.xdata$x:0000B726                 db    0
.xdata$x:0000B727                 db    0
.xdata$x:0000B727 _xdata$x        ends
.xdata$x:0000B727
.xdata$x:0000B728 ; ===========================================================================
.xdata$x:0000B728
.xdata$x:0000B728 ; Segment type: Pure data
.xdata$x:0000B728 ; Segment permissions: Read
.xdata$x:0000B728 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B728                 assume cs:_xdata$x
.xdata$x:0000B728                 ;org 0B728h
.xdata$x:0000B728 ; COMDAT (pick associative to section at 6994)
.xdata$x:0000B728 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000B728                                         ; DATA XREF: .xdata$x:0000B738o
.xdata$x:0000B729                 db 0FFh
.xdata$x:0000B72A                 db 0FFh
.xdata$x:0000B72B                 db 0FFh
.xdata$x:0000B72C                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:0000B730 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000B730                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:0000B731                 db    5
.xdata$x:0000B732                 db  93h ; ô
.xdata$x:0000B733                 db  19h
.xdata$x:0000B734                 db    1
.xdata$x:0000B735                 db    0
.xdata$x:0000B736                 db    0
.xdata$x:0000B737                 db    0
.xdata$x:0000B738                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:0000B73C                 db    0
.xdata$x:0000B73D                 db    0
.xdata$x:0000B73E                 db    0
.xdata$x:0000B73F                 db    0
.xdata$x:0000B740                 db    0
.xdata$x:0000B741                 db    0
.xdata$x:0000B742                 db    0
.xdata$x:0000B743                 db    0
.xdata$x:0000B744                 db    0
.xdata$x:0000B745                 db    0
.xdata$x:0000B746                 db    0
.xdata$x:0000B747                 db    0
.xdata$x:0000B748                 db    0
.xdata$x:0000B749                 db    0
.xdata$x:0000B74A                 db    0
.xdata$x:0000B74B                 db    0
.xdata$x:0000B74C                 db    0
.xdata$x:0000B74D                 db    0
.xdata$x:0000B74E                 db    0
.xdata$x:0000B74F                 db    0
.xdata$x:0000B750                 db    0
.xdata$x:0000B751                 db    0
.xdata$x:0000B752                 db    0
.xdata$x:0000B753                 db    0
.xdata$x:0000B753 _xdata$x        ends
.xdata$x:0000B753
.xdata$x:0000B754 ; ===========================================================================
.xdata$x:0000B754
.xdata$x:0000B754 ; Segment type: Pure data
.xdata$x:0000B754 ; Segment permissions: Read
.xdata$x:0000B754 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B754                 assume cs:_xdata$x
.xdata$x:0000B754                 ;org 0B754h
.xdata$x:0000B754 ; COMDAT (pick associative to section at ABC8)
.xdata$x:0000B754 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000B754                                         ; DATA XREF: .xdata$x:0000B764o
.xdata$x:0000B755                 db 0FFh
.xdata$x:0000B756                 db 0FFh
.xdata$x:0000B757                 db 0FFh
.xdata$x:0000B758                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000B75C __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000B75C                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000B75D                 db    5
.xdata$x:0000B75E                 db  93h ; ô
.xdata$x:0000B75F                 db  19h
.xdata$x:0000B760                 db    1
.xdata$x:0000B761                 db    0
.xdata$x:0000B762                 db    0
.xdata$x:0000B763                 db    0
.xdata$x:0000B764                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000B768                 align 20h
.xdata$x:0000B768 _xdata$x        ends
.xdata$x:0000B768
.xdata$x:0000B780 ; ===========================================================================
.xdata$x:0000B780
.xdata$x:0000B780 ; Segment type: Pure data
.xdata$x:0000B780 ; Segment permissions: Read
.xdata$x:0000B780 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B780                 assume cs:_xdata$x
.xdata$x:0000B780                 ;org 0B780h
.xdata$x:0000B780 ; COMDAT (pick associative to section at 73D4)
.xdata$x:0000B780 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000B780                                         ; DATA XREF: .xdata$x:0000B790o
.xdata$x:0000B781                 db 0FFh
.xdata$x:0000B782                 db 0FFh
.xdata$x:0000B783                 db 0FFh
.xdata$x:0000B784                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:0000B788 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000B788                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:0000B789                 db    5
.xdata$x:0000B78A                 db  93h ; ô
.xdata$x:0000B78B                 db  19h
.xdata$x:0000B78C                 db    1
.xdata$x:0000B78D                 db    0
.xdata$x:0000B78E                 db    0
.xdata$x:0000B78F                 db    0
.xdata$x:0000B790                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:0000B794                 db    0
.xdata$x:0000B795                 db    0
.xdata$x:0000B796                 db    0
.xdata$x:0000B797                 db    0
.xdata$x:0000B798                 db    0
.xdata$x:0000B799                 db    0
.xdata$x:0000B79A                 db    0
.xdata$x:0000B79B                 db    0
.xdata$x:0000B79C                 db    0
.xdata$x:0000B79D                 db    0
.xdata$x:0000B79E                 db    0
.xdata$x:0000B79F                 db    0
.xdata$x:0000B7A0                 db    0
.xdata$x:0000B7A1                 db    0
.xdata$x:0000B7A2                 db    0
.xdata$x:0000B7A3                 db    0
.xdata$x:0000B7A4                 db    0
.xdata$x:0000B7A5                 db    0
.xdata$x:0000B7A6                 db    0
.xdata$x:0000B7A7                 db    0
.xdata$x:0000B7A8                 db    0
.xdata$x:0000B7A9                 db    0
.xdata$x:0000B7AA                 db    0
.xdata$x:0000B7AB                 db    0
.xdata$x:0000B7AB _xdata$x        ends
.xdata$x:0000B7AB
.xdata$x:0000B7AC ; ===========================================================================
.xdata$x:0000B7AC
.xdata$x:0000B7AC ; Segment type: Pure data
.xdata$x:0000B7AC ; Segment permissions: Read
.xdata$x:0000B7AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B7AC                 assume cs:_xdata$x
.xdata$x:0000B7AC                 ;org 0B7ACh
.xdata$x:0000B7AC ; COMDAT (pick associative to section at 6A64)
.xdata$x:0000B7AC __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000B7AC                                         ; DATA XREF: .xdata$x:0000B7BCo
.xdata$x:0000B7AD                 db 0FFh
.xdata$x:0000B7AE                 db 0FFh
.xdata$x:0000B7AF                 db 0FFh
.xdata$x:0000B7B0                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:0000B7B4 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000B7B4                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:0000B7B5                 db    5
.xdata$x:0000B7B6                 db  93h ; ô
.xdata$x:0000B7B7                 db  19h
.xdata$x:0000B7B8                 db    1
.xdata$x:0000B7B9                 db    0
.xdata$x:0000B7BA                 db    0
.xdata$x:0000B7BB                 db    0
.xdata$x:0000B7BC                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:0000B7C0                 db    0
.xdata$x:0000B7C1                 db    0
.xdata$x:0000B7C2                 db    0
.xdata$x:0000B7C3                 db    0
.xdata$x:0000B7C4                 db    0
.xdata$x:0000B7C5                 db    0
.xdata$x:0000B7C6                 db    0
.xdata$x:0000B7C7                 db    0
.xdata$x:0000B7C8                 db    0
.xdata$x:0000B7C9                 db    0
.xdata$x:0000B7CA                 db    0
.xdata$x:0000B7CB                 db    0
.xdata$x:0000B7CC                 db    0
.xdata$x:0000B7CD                 db    0
.xdata$x:0000B7CE                 db    0
.xdata$x:0000B7CF                 db    0
.xdata$x:0000B7D0                 db    0
.xdata$x:0000B7D1                 db    0
.xdata$x:0000B7D2                 db    0
.xdata$x:0000B7D3                 db    0
.xdata$x:0000B7D4                 db    0
.xdata$x:0000B7D5                 db    0
.xdata$x:0000B7D6                 db    0
.xdata$x:0000B7D7                 db    0
.xdata$x:0000B7D7 _xdata$x        ends
.xdata$x:0000B7D7
.xdata$x:0000B7D8 ; ===========================================================================
.xdata$x:0000B7D8
.xdata$x:0000B7D8 ; Segment type: Pure data
.xdata$x:0000B7D8 ; Segment permissions: Read
.xdata$x:0000B7D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B7D8                 assume cs:_xdata$x
.xdata$x:0000B7D8                 ;org 0B7D8h
.xdata$x:0000B7D8 ; COMDAT (pick associative to section at AC8C)
.xdata$x:0000B7D8 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000B7D8                                         ; DATA XREF: .xdata$x:0000B7E8o
.xdata$x:0000B7D9                 db 0FFh
.xdata$x:0000B7DA                 db 0FFh
.xdata$x:0000B7DB                 db 0FFh
.xdata$x:0000B7DC                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000B7E0 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000B7E0                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000B7E1                 db    5
.xdata$x:0000B7E2                 db  93h ; ô
.xdata$x:0000B7E3                 db  19h
.xdata$x:0000B7E4                 db    1
.xdata$x:0000B7E5                 db    0
.xdata$x:0000B7E6                 db    0
.xdata$x:0000B7E7                 db    0
.xdata$x:0000B7E8                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000B7EC                 db    0
.xdata$x:0000B7ED                 db    0
.xdata$x:0000B7EE                 db    0
.xdata$x:0000B7EF                 db    0
.xdata$x:0000B7F0                 db    0
.xdata$x:0000B7F1                 db    0
.xdata$x:0000B7F2                 db    0
.xdata$x:0000B7F3                 db    0
.xdata$x:0000B7F4                 db    0
.xdata$x:0000B7F5                 db    0
.xdata$x:0000B7F6                 db    0
.xdata$x:0000B7F7                 db    0
.xdata$x:0000B7F8                 db    0
.xdata$x:0000B7F9                 db    0
.xdata$x:0000B7FA                 db    0
.xdata$x:0000B7FB                 db    0
.xdata$x:0000B7FC                 db    0
.xdata$x:0000B7FD                 db    0
.xdata$x:0000B7FE                 db    0
.xdata$x:0000B7FF                 db    0
.xdata$x:0000B800                 db    0
.xdata$x:0000B801                 db    0
.xdata$x:0000B802                 db    0
.xdata$x:0000B803                 db    0
.xdata$x:0000B803 _xdata$x        ends
.xdata$x:0000B803
.xdata$x:0000B804 ; ===========================================================================
.xdata$x:0000B804
.xdata$x:0000B804 ; Segment type: Pure data
.xdata$x:0000B804 ; Segment permissions: Read
.xdata$x:0000B804 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B804                 assume cs:_xdata$x
.xdata$x:0000B804                 ;org 0B804h
.xdata$x:0000B804 ; COMDAT (pick associative to section at 74C8)
.xdata$x:0000B804 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000B804                                         ; DATA XREF: .xdata$x:0000B814o
.xdata$x:0000B805                 db 0FFh
.xdata$x:0000B806                 db 0FFh
.xdata$x:0000B807                 db 0FFh
.xdata$x:0000B808                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:0000B80C __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000B80C                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:0000B80D                 db    5
.xdata$x:0000B80E                 db  93h ; ô
.xdata$x:0000B80F                 db  19h
.xdata$x:0000B810                 db    1
.xdata$x:0000B811                 db    0
.xdata$x:0000B812                 db    0
.xdata$x:0000B813                 db    0
.xdata$x:0000B814                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:0000B818                 db    0
.xdata$x:0000B819                 db    0
.xdata$x:0000B81A                 db    0
.xdata$x:0000B81B                 db    0
.xdata$x:0000B81C                 db    0
.xdata$x:0000B81D                 db    0
.xdata$x:0000B81E                 db    0
.xdata$x:0000B81F                 db    0
.xdata$x:0000B820                 db    0
.xdata$x:0000B821                 db    0
.xdata$x:0000B822                 db    0
.xdata$x:0000B823                 db    0
.xdata$x:0000B824                 db    0
.xdata$x:0000B825                 db    0
.xdata$x:0000B826                 db    0
.xdata$x:0000B827                 db    0
.xdata$x:0000B828                 db    0
.xdata$x:0000B829                 db    0
.xdata$x:0000B82A                 db    0
.xdata$x:0000B82B                 db    0
.xdata$x:0000B82C                 db    0
.xdata$x:0000B82D                 db    0
.xdata$x:0000B82E                 db    0
.xdata$x:0000B82F                 db    0
.xdata$x:0000B82F _xdata$x        ends
.xdata$x:0000B82F
.xdata$x:0000B830 ; ===========================================================================
.xdata$x:0000B830
.xdata$x:0000B830 ; Segment type: Pure data
.xdata$x:0000B830 ; Segment permissions: Read
.xdata$x:0000B830 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B830                 assume cs:_xdata$x
.xdata$x:0000B830                 ;org 0B830h
.xdata$x:0000B830 ; COMDAT (pick associative to section at 60E8)
.xdata$x:0000B830 __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000B830                                         ; DATA XREF: .xdata$x:0000B840o
.xdata$x:0000B831                 db 0FFh
.xdata$x:0000B832                 db 0FFh
.xdata$x:0000B833                 db 0FFh
.xdata$x:0000B834                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000B838 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000B838                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000B839                 db    5
.xdata$x:0000B83A                 db  93h ; ô
.xdata$x:0000B83B                 db  19h
.xdata$x:0000B83C                 db    1
.xdata$x:0000B83D                 db    0
.xdata$x:0000B83E                 db    0
.xdata$x:0000B83F                 db    0
.xdata$x:0000B840                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000B844                 db    0
.xdata$x:0000B845                 db    0
.xdata$x:0000B846                 db    0
.xdata$x:0000B847                 db    0
.xdata$x:0000B848                 db    0
.xdata$x:0000B849                 db    0
.xdata$x:0000B84A                 db    0
.xdata$x:0000B84B                 db    0
.xdata$x:0000B84C                 db    0
.xdata$x:0000B84D                 db    0
.xdata$x:0000B84E                 db    0
.xdata$x:0000B84F                 db    0
.xdata$x:0000B850                 db    0
.xdata$x:0000B851                 db    0
.xdata$x:0000B852                 db    0
.xdata$x:0000B853                 db    0
.xdata$x:0000B854                 db    0
.xdata$x:0000B855                 db    0
.xdata$x:0000B856                 db    0
.xdata$x:0000B857                 db    0
.xdata$x:0000B858                 db    0
.xdata$x:0000B859                 db    0
.xdata$x:0000B85A                 db    0
.xdata$x:0000B85B                 db    0
.xdata$x:0000B85B _xdata$x        ends
.xdata$x:0000B85B
.xdata$x:0000B85C ; ===========================================================================
.xdata$x:0000B85C
.xdata$x:0000B85C ; Segment type: Pure data
.xdata$x:0000B85C ; Segment permissions: Read
.xdata$x:0000B85C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B85C                 assume cs:_xdata$x
.xdata$x:0000B85C                 ;org 0B85Ch
.xdata$x:0000B85C ; COMDAT (pick associative to section at 6F0C)
.xdata$x:0000B85C __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000B85C                                         ; DATA XREF: .xdata$x:0000B86Co
.xdata$x:0000B85D                 db 0FFh
.xdata$x:0000B85E                 db 0FFh
.xdata$x:0000B85F                 db 0FFh
.xdata$x:0000B860                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000B864 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000B864                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000B865                 db    5
.xdata$x:0000B866                 db  93h ; ô
.xdata$x:0000B867                 db  19h
.xdata$x:0000B868                 db    1
.xdata$x:0000B869                 db    0
.xdata$x:0000B86A                 db    0
.xdata$x:0000B86B                 db    0
.xdata$x:0000B86C                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000B870                 db    0
.xdata$x:0000B871                 db    0
.xdata$x:0000B872                 db    0
.xdata$x:0000B873                 db    0
.xdata$x:0000B874                 db    0
.xdata$x:0000B875                 db    0
.xdata$x:0000B876                 db    0
.xdata$x:0000B877                 db    0
.xdata$x:0000B878                 db    0
.xdata$x:0000B879                 db    0
.xdata$x:0000B87A                 db    0
.xdata$x:0000B87B                 db    0
.xdata$x:0000B87C                 db    0
.xdata$x:0000B87D                 db    0
.xdata$x:0000B87E                 db    0
.xdata$x:0000B87F                 db    0
.xdata$x:0000B880                 db    0
.xdata$x:0000B881                 db    0
.xdata$x:0000B882                 db    0
.xdata$x:0000B883                 db    0
.xdata$x:0000B884                 db    0
.xdata$x:0000B885                 db    0
.xdata$x:0000B886                 db    0
.xdata$x:0000B887                 db    0
.xdata$x:0000B887 _xdata$x        ends
.xdata$x:0000B887
.xdata$x:0000B888 ; ===========================================================================
.xdata$x:0000B888
.xdata$x:0000B888 ; Segment type: Pure data
.xdata$x:0000B888 ; Segment permissions: Read
.xdata$x:0000B888 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B888                 assume cs:_xdata$x
.xdata$x:0000B888                 ;org 0B888h
.xdata$x:0000B888 ; COMDAT (pick associative to section at 5FE4)
.xdata$x:0000B888 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:0000B888                                         ; DATA XREF: .xdata$x:0000B898o
.xdata$x:0000B889                 db 0FFh
.xdata$x:0000B88A                 db 0FFh
.xdata$x:0000B88B                 db 0FFh
.xdata$x:0000B88C                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:0000B890 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:0000B890                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:0000B891                 db    5
.xdata$x:0000B892                 db  93h ; ô
.xdata$x:0000B893                 db  19h
.xdata$x:0000B894                 db    1
.xdata$x:0000B895                 db    0
.xdata$x:0000B896                 db    0
.xdata$x:0000B897                 db    0
.xdata$x:0000B898                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:0000B89C                 db    0
.xdata$x:0000B89D                 db    0
.xdata$x:0000B89E                 db    0
.xdata$x:0000B89F                 db    0
.xdata$x:0000B8A0                 db    0
.xdata$x:0000B8A1                 db    0
.xdata$x:0000B8A2                 db    0
.xdata$x:0000B8A3                 db    0
.xdata$x:0000B8A4                 db    0
.xdata$x:0000B8A5                 db    0
.xdata$x:0000B8A6                 db    0
.xdata$x:0000B8A7                 db    0
.xdata$x:0000B8A8                 db    0
.xdata$x:0000B8A9                 db    0
.xdata$x:0000B8AA                 db    0
.xdata$x:0000B8AB                 db    0
.xdata$x:0000B8AC                 db    0
.xdata$x:0000B8AD                 db    0
.xdata$x:0000B8AE                 db    0
.xdata$x:0000B8AF                 db    0
.xdata$x:0000B8B0                 db    0
.xdata$x:0000B8B1                 db    0
.xdata$x:0000B8B2                 db    0
.xdata$x:0000B8B3                 db    0
.xdata$x:0000B8B3 _xdata$x        ends
.xdata$x:0000B8B3
.xdata$x:0000B8B4 ; ===========================================================================
.xdata$x:0000B8B4
.xdata$x:0000B8B4 ; Segment type: Pure data
.xdata$x:0000B8B4 ; Segment permissions: Read
.xdata$x:0000B8B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B8B4                 assume cs:_xdata$x
.xdata$x:0000B8B4                 ;org 0B8B4h
.xdata$x:0000B8B4 ; COMDAT (pick associative to section at 6E24)
.xdata$x:0000B8B4 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000B8B4                                         ; DATA XREF: .xdata$x:0000B8C4o
.xdata$x:0000B8B5                 db 0FFh
.xdata$x:0000B8B6                 db 0FFh
.xdata$x:0000B8B7                 db 0FFh
.xdata$x:0000B8B8                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000B8BC __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000B8BC                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000B8BD                 db    5
.xdata$x:0000B8BE                 db  93h ; ô
.xdata$x:0000B8BF                 db  19h
.xdata$x:0000B8C0                 db    1
.xdata$x:0000B8C1                 db    0
.xdata$x:0000B8C2                 db    0
.xdata$x:0000B8C3                 db    0
.xdata$x:0000B8C4                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:0000B8C8                 align 20h
.xdata$x:0000B8C8 _xdata$x        ends
.xdata$x:0000B8C8
.xdata$x:0000B8E0 ; ===========================================================================
.xdata$x:0000B8E0
.xdata$x:0000B8E0 ; Segment type: Pure data
.xdata$x:0000B8E0 ; Segment permissions: Read
.xdata$x:0000B8E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B8E0                 assume cs:_xdata$x
.xdata$x:0000B8E0                 ;org 0B8E0h
.xdata$x:0000B8E0 ; COMDAT (pick associative to section at 64BC)
.xdata$x:0000B8E0 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000B8E0                                         ; DATA XREF: .xdata$x:0000B8F0o
.xdata$x:0000B8E1                 db 0FFh
.xdata$x:0000B8E2                 db 0FFh
.xdata$x:0000B8E3                 db 0FFh
.xdata$x:0000B8E4                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0
.xdata$x:0000B8E8 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000B8E8                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000B8E9                 db    5
.xdata$x:0000B8EA                 db  93h ; ô
.xdata$x:0000B8EB                 db  19h
.xdata$x:0000B8EC                 db    1
.xdata$x:0000B8ED                 db    0
.xdata$x:0000B8EE                 db    0
.xdata$x:0000B8EF                 db    0
.xdata$x:0000B8F0                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.xdata$x:0000B8F4                 db    0
.xdata$x:0000B8F5                 db    0
.xdata$x:0000B8F6                 db    0
.xdata$x:0000B8F7                 db    0
.xdata$x:0000B8F8                 db    0
.xdata$x:0000B8F9                 db    0
.xdata$x:0000B8FA                 db    0
.xdata$x:0000B8FB                 db    0
.xdata$x:0000B8FC                 db    0
.xdata$x:0000B8FD                 db    0
.xdata$x:0000B8FE                 db    0
.xdata$x:0000B8FF                 db    0
.xdata$x:0000B900                 db    0
.xdata$x:0000B901                 db    0
.xdata$x:0000B902                 db    0
.xdata$x:0000B903                 db    0
.xdata$x:0000B904                 db    0
.xdata$x:0000B905                 db    0
.xdata$x:0000B906                 db    0
.xdata$x:0000B907                 db    0
.xdata$x:0000B908                 db    0
.xdata$x:0000B909                 db    0
.xdata$x:0000B90A                 db    0
.xdata$x:0000B90B                 db    0
.xdata$x:0000B90B _xdata$x        ends
.xdata$x:0000B90B
.xdata$x:0000B90C ; ===========================================================================
.xdata$x:0000B90C
.xdata$x:0000B90C ; Segment type: Pure data
.xdata$x:0000B90C ; Segment permissions: Read
.xdata$x:0000B90C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B90C                 assume cs:_xdata$x
.xdata$x:0000B90C                 ;org 0B90Ch
.xdata$x:0000B90C ; COMDAT (pick associative to section at 6604)
.xdata$x:0000B90C __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000B90C                                         ; DATA XREF: .xdata$x:0000B91Co
.xdata$x:0000B90D                 db 0FFh
.xdata$x:0000B90E                 db 0FFh
.xdata$x:0000B90F                 db 0FFh
.xdata$x:0000B910                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:0000B914 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000B914                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:0000B915                 db    5
.xdata$x:0000B916                 db  93h ; ô
.xdata$x:0000B917                 db  19h
.xdata$x:0000B918                 db    1
.xdata$x:0000B919                 db    0
.xdata$x:0000B91A                 db    0
.xdata$x:0000B91B                 db    0
.xdata$x:0000B91C                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:0000B920                 db    0
.xdata$x:0000B921                 db    0
.xdata$x:0000B922                 db    0
.xdata$x:0000B923                 db    0
.xdata$x:0000B924                 db    0
.xdata$x:0000B925                 db    0
.xdata$x:0000B926                 db    0
.xdata$x:0000B927                 db    0
.xdata$x:0000B928                 db    0
.xdata$x:0000B929                 db    0
.xdata$x:0000B92A                 db    0
.xdata$x:0000B92B                 db    0
.xdata$x:0000B92C                 db    0
.xdata$x:0000B92D                 db    0
.xdata$x:0000B92E                 db    0
.xdata$x:0000B92F                 db    0
.xdata$x:0000B930                 db    0
.xdata$x:0000B931                 db    0
.xdata$x:0000B932                 db    0
.xdata$x:0000B933                 db    0
.xdata$x:0000B934                 db    0
.xdata$x:0000B935                 db    0
.xdata$x:0000B936                 db    0
.xdata$x:0000B937                 db    0
.xdata$x:0000B937 _xdata$x        ends
.xdata$x:0000B937
.xdata$x:0000B938 ; ===========================================================================
.xdata$x:0000B938
.xdata$x:0000B938 ; Segment type: Pure data
.xdata$x:0000B938 ; Segment permissions: Read
.xdata$x:0000B938 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B938                 assume cs:_xdata$x
.xdata$x:0000B938                 ;org 0B938h
.xdata$x:0000B938 ; COMDAT (pick associative to section at 656C)
.xdata$x:0000B938 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:0000B938                                         ; DATA XREF: .xdata$x:0000B948o
.xdata$x:0000B939                 db 0FFh
.xdata$x:0000B93A                 db 0FFh
.xdata$x:0000B93B                 db 0FFh
.xdata$x:0000B93C                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:0000B940 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:0000B940                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:0000B941                 db    5
.xdata$x:0000B942                 db  93h ; ô
.xdata$x:0000B943                 db  19h
.xdata$x:0000B944                 db    1
.xdata$x:0000B945                 db    0
.xdata$x:0000B946                 db    0
.xdata$x:0000B947                 db    0
.xdata$x:0000B948                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:0000B94C                 db    0
.xdata$x:0000B94D                 db    0
.xdata$x:0000B94E                 db    0
.xdata$x:0000B94F                 db    0
.xdata$x:0000B950                 db    0
.xdata$x:0000B951                 db    0
.xdata$x:0000B952                 db    0
.xdata$x:0000B953                 db    0
.xdata$x:0000B954                 db    0
.xdata$x:0000B955                 db    0
.xdata$x:0000B956                 db    0
.xdata$x:0000B957                 db    0
.xdata$x:0000B958                 db    0
.xdata$x:0000B959                 db    0
.xdata$x:0000B95A                 db    0
.xdata$x:0000B95B                 db    0
.xdata$x:0000B95C                 db    0
.xdata$x:0000B95D                 db    0
.xdata$x:0000B95E                 db    0
.xdata$x:0000B95F                 db    0
.xdata$x:0000B960                 db    0
.xdata$x:0000B961                 db    0
.xdata$x:0000B962                 db    0
.xdata$x:0000B963                 db    0
.xdata$x:0000B963 _xdata$x        ends
.xdata$x:0000B963
.xdata$x:0000B964 ; ===========================================================================
.xdata$x:0000B964
.xdata$x:0000B964 ; Segment type: Pure data
.xdata$x:0000B964 ; Segment permissions: Read
.xdata$x:0000B964 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B964                 assume cs:_xdata$x
.xdata$x:0000B964                 ;org 0B964h
.xdata$x:0000B964 ; COMDAT (pick associative to section at 70E0)
.xdata$x:0000B964 __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000B964                                         ; DATA XREF: .xdata$x:0000B974o
.xdata$x:0000B965                 db 0FFh
.xdata$x:0000B966                 db 0FFh
.xdata$x:0000B967                 db 0FFh
.xdata$x:0000B968                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:0000B96C __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000B96C                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:0000B96D                 db    5
.xdata$x:0000B96E                 db  93h ; ô
.xdata$x:0000B96F                 db  19h
.xdata$x:0000B970                 db    1
.xdata$x:0000B971                 db    0
.xdata$x:0000B972                 db    0
.xdata$x:0000B973                 db    0
.xdata$x:0000B974                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:0000B978                 db    0
.xdata$x:0000B979                 db    0
.xdata$x:0000B97A                 db    0
.xdata$x:0000B97B                 db    0
.xdata$x:0000B97C                 db    0
.xdata$x:0000B97D                 db    0
.xdata$x:0000B97E                 db    0
.xdata$x:0000B97F                 db    0
.xdata$x:0000B980                 db    0
.xdata$x:0000B981                 db    0
.xdata$x:0000B982                 db    0
.xdata$x:0000B983                 db    0
.xdata$x:0000B984                 db    0
.xdata$x:0000B985                 db    0
.xdata$x:0000B986                 db    0
.xdata$x:0000B987                 db    0
.xdata$x:0000B988                 db    0
.xdata$x:0000B989                 db    0
.xdata$x:0000B98A                 db    0
.xdata$x:0000B98B                 db    0
.xdata$x:0000B98C                 db    0
.xdata$x:0000B98D                 db    0
.xdata$x:0000B98E                 db    0
.xdata$x:0000B98F                 db    0
.xdata$x:0000B98F _xdata$x        ends
.xdata$x:0000B98F
.xdata$x:0000B990 ; ===========================================================================
.xdata$x:0000B990
.xdata$x:0000B990 ; Segment type: Pure data
.xdata$x:0000B990 ; Segment permissions: Read
.xdata$x:0000B990 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000B990                 assume cs:_xdata$x
.xdata$x:0000B990                 ;org 0B990h
.xdata$x:0000B990 ; COMDAT (pick associative to section at 7F48)
.xdata$x:0000B990 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000B990                                         ; DATA XREF: .xdata$x:0000BA18o
.xdata$x:0000B991                 db    0
.xdata$x:0000B992                 db    0
.xdata$x:0000B993                 db    0
.xdata$x:0000B994                 db    0
.xdata$x:0000B995                 db    0
.xdata$x:0000B996                 db    0
.xdata$x:0000B997                 db    0
.xdata$x:0000B998                 db    0
.xdata$x:0000B999                 db    0
.xdata$x:0000B99A                 db    0
.xdata$x:0000B99B                 db    0
.xdata$x:0000B99C                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:0000B9A0 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000B9A0                                         ; DATA XREF: .xdata$x:0000BA04o
.xdata$x:0000B9A1                 db    0
.xdata$x:0000B9A2                 db    0
.xdata$x:0000B9A3                 db    0
.xdata$x:0000B9A4                 db    0
.xdata$x:0000B9A5                 db    0
.xdata$x:0000B9A6                 db    0
.xdata$x:0000B9A7                 db    0
.xdata$x:0000B9A8                 db    0
.xdata$x:0000B9A9                 db    0
.xdata$x:0000B9AA                 db    0
.xdata$x:0000B9AB                 db    0
.xdata$x:0000B9AC                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:0000B9B0 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000B9B0                                         ; DATA XREF: .xdata$x:0000B9D8o
.xdata$x:0000B9B1                 db 0FFh
.xdata$x:0000B9B2                 db 0FFh
.xdata$x:0000B9B3                 db 0FFh
.xdata$x:0000B9B4                 db    0
.xdata$x:0000B9B5                 db    0
.xdata$x:0000B9B6                 db    0
.xdata$x:0000B9B7                 db    0
.xdata$x:0000B9B8                 db 0FFh
.xdata$x:0000B9B9                 db 0FFh
.xdata$x:0000B9BA                 db 0FFh
.xdata$x:0000B9BB                 db 0FFh
.xdata$x:0000B9BC                 db    0
.xdata$x:0000B9BD                 db    0
.xdata$x:0000B9BE                 db    0
.xdata$x:0000B9BF                 db    0
.xdata$x:0000B9C0                 db    1
.xdata$x:0000B9C1                 db    0
.xdata$x:0000B9C2                 db    0
.xdata$x:0000B9C3                 db    0
.xdata$x:0000B9C4                 db    0
.xdata$x:0000B9C5                 db    0
.xdata$x:0000B9C6                 db    0
.xdata$x:0000B9C7                 db    0
.xdata$x:0000B9C8                 db    1
.xdata$x:0000B9C9                 db    0
.xdata$x:0000B9CA                 db    0
.xdata$x:0000B9CB                 db    0
.xdata$x:0000B9CC                 db    0
.xdata$x:0000B9CD                 db    0
.xdata$x:0000B9CE                 db    0
.xdata$x:0000B9CF                 db    0
.xdata$x:0000B9D0 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000B9D0                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:0000B9D1                 db    5
.xdata$x:0000B9D2                 db  93h ; ô
.xdata$x:0000B9D3                 db  19h
.xdata$x:0000B9D4                 db    4
.xdata$x:0000B9D5                 db    0
.xdata$x:0000B9D6                 db    0
.xdata$x:0000B9D7                 db    0
.xdata$x:0000B9D8                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:0000B9DC                 db    2
.xdata$x:0000B9DD                 db    0
.xdata$x:0000B9DE                 db    0
.xdata$x:0000B9DF                 db    0
.xdata$x:0000B9E0                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:0000B9E4                 db    0
.xdata$x:0000B9E5                 db    0
.xdata$x:0000B9E6                 db    0
.xdata$x:0000B9E7                 db    0
.xdata$x:0000B9E8                 db    0
.xdata$x:0000B9E9                 db    0
.xdata$x:0000B9EA                 db    0
.xdata$x:0000B9EB                 db    0
.xdata$x:0000B9EC                 db    0
.xdata$x:0000B9ED                 db    0
.xdata$x:0000B9EE                 db    0
.xdata$x:0000B9EF                 db    0
.xdata$x:0000B9F0                 db    0
.xdata$x:0000B9F1                 db    0
.xdata$x:0000B9F2                 db    0
.xdata$x:0000B9F3                 db    0
.xdata$x:0000B9F4 __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:0000B9F4                                         ; DATA XREF: .xdata$x:0000B9E0o
.xdata$x:0000B9F5                 db    0
.xdata$x:0000B9F6                 db    0
.xdata$x:0000B9F7                 db    0
.xdata$x:0000B9F8                 db    2
.xdata$x:0000B9F9                 db    0
.xdata$x:0000B9FA                 db    0
.xdata$x:0000B9FB                 db    0
.xdata$x:0000B9FC                 db    3
.xdata$x:0000B9FD                 db    0
.xdata$x:0000B9FE                 db    0
.xdata$x:0000B9FF                 db    0
.xdata$x:0000BA00                 db    1
.xdata$x:0000BA01                 db    0
.xdata$x:0000BA02                 db    0
.xdata$x:0000BA03                 db    0
.xdata$x:0000BA04                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:0000BA08                 align 10h
.xdata$x:0000BA10                 db    3
.xdata$x:0000BA11                 db    0
.xdata$x:0000BA12                 db    0
.xdata$x:0000BA13                 db    0
.xdata$x:0000BA14                 db    1
.xdata$x:0000BA15                 db    0
.xdata$x:0000BA16                 db    0
.xdata$x:0000BA17                 db    0
.xdata$x:0000BA18                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:0000BA18 _xdata$x        ends
.xdata$x:0000BA18
.xdata$x:0000BA1C ; ===========================================================================
.xdata$x:0000BA1C
.xdata$x:0000BA1C ; Segment type: Pure data
.xdata$x:0000BA1C ; Segment permissions: Read
.xdata$x:0000BA1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BA1C                 assume cs:_xdata$x
.xdata$x:0000BA1C                 ;org 0BA1Ch
.xdata$x:0000BA1C ; COMDAT (pick associative to section at 754C)
.xdata$x:0000BA1C __unwindtable$??1recordedMacroStep@@QAE@XZ db 0FFh
.xdata$x:0000BA1C                                         ; DATA XREF: .xdata$x:0000BA2Co
.xdata$x:0000BA1D                 db 0FFh
.xdata$x:0000BA1E                 db 0FFh
.xdata$x:0000BA1F                 db 0FFh
.xdata$x:0000BA20                 dd offset __unwindfunclet$??1recordedMacroStep@@QAE@XZ$0
.xdata$x:0000BA24 __ehfuncinfo$??1recordedMacroStep@@QAE@XZ db  22h ; "
.xdata$x:0000BA24                                         ; DATA XREF: __ehhandler$??1recordedMacroStep@@QAE@XZ+11o
.xdata$x:0000BA25                 db    5
.xdata$x:0000BA26                 db  93h ; ô
.xdata$x:0000BA27                 db  19h
.xdata$x:0000BA28                 db    1
.xdata$x:0000BA29                 db    0
.xdata$x:0000BA2A                 db    0
.xdata$x:0000BA2B                 db    0
.xdata$x:0000BA2C                 dd offset __unwindtable$??1recordedMacroStep@@QAE@XZ
.xdata$x:0000BA30                 db    0
.xdata$x:0000BA31                 db    0
.xdata$x:0000BA32                 db    0
.xdata$x:0000BA33                 db    0
.xdata$x:0000BA34                 db    0
.xdata$x:0000BA35                 db    0
.xdata$x:0000BA36                 db    0
.xdata$x:0000BA37                 db    0
.xdata$x:0000BA38                 db    0
.xdata$x:0000BA39                 db    0
.xdata$x:0000BA3A                 db    0
.xdata$x:0000BA3B                 db    0
.xdata$x:0000BA3C                 db    0
.xdata$x:0000BA3D                 db    0
.xdata$x:0000BA3E                 db    0
.xdata$x:0000BA3F                 db    0
.xdata$x:0000BA40                 db    0
.xdata$x:0000BA41                 db    0
.xdata$x:0000BA42                 db    0
.xdata$x:0000BA43                 db    0
.xdata$x:0000BA44                 db    0
.xdata$x:0000BA45                 db    0
.xdata$x:0000BA46                 db    0
.xdata$x:0000BA47                 db    0
.xdata$x:0000BA47 _xdata$x        ends
.xdata$x:0000BA47
.xdata$x:0000BA48 ; ===========================================================================
.xdata$x:0000BA48
.xdata$x:0000BA48 ; Segment type: Pure data
.xdata$x:0000BA48 ; Segment permissions: Read
.xdata$x:0000BA48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BA48                 assume cs:_xdata$x
.xdata$x:0000BA48                 ;org 0BA48h
.xdata$x:0000BA48 ; COMDAT (pick associative to section at 6B34)
.xdata$x:0000BA48 __unwindtable$??0recordedMacroStep@@QAE@ABU0@@Z db 0FFh
.xdata$x:0000BA48                                         ; DATA XREF: .xdata$x:0000BA58o
.xdata$x:0000BA49                 db 0FFh
.xdata$x:0000BA4A                 db 0FFh
.xdata$x:0000BA4B                 db 0FFh
.xdata$x:0000BA4C                 dd offset __unwindfunclet$??0recordedMacroStep@@QAE@ABU0@@Z$0
.xdata$x:0000BA50 __ehfuncinfo$??0recordedMacroStep@@QAE@ABU0@@Z db  22h ; "
.xdata$x:0000BA50                                         ; DATA XREF: __ehhandler$??0recordedMacroStep@@QAE@ABU0@@Z+11o
.xdata$x:0000BA51                 db    5
.xdata$x:0000BA52                 db  93h ; ô
.xdata$x:0000BA53                 db  19h
.xdata$x:0000BA54                 db    1
.xdata$x:0000BA55                 db    0
.xdata$x:0000BA56                 db    0
.xdata$x:0000BA57                 db    0
.xdata$x:0000BA58                 dd offset __unwindtable$??0recordedMacroStep@@QAE@ABU0@@Z
.xdata$x:0000BA5C                 db    0
.xdata$x:0000BA5D                 db    0
.xdata$x:0000BA5E                 db    0
.xdata$x:0000BA5F                 db    0
.xdata$x:0000BA60                 db    0
.xdata$x:0000BA61                 db    0
.xdata$x:0000BA62                 db    0
.xdata$x:0000BA63                 db    0
.xdata$x:0000BA64                 db    0
.xdata$x:0000BA65                 db    0
.xdata$x:0000BA66                 db    0
.xdata$x:0000BA67                 db    0
.xdata$x:0000BA68                 db    0
.xdata$x:0000BA69                 db    0
.xdata$x:0000BA6A                 db    0
.xdata$x:0000BA6B                 db    0
.xdata$x:0000BA6C                 db    0
.xdata$x:0000BA6D                 db    0
.xdata$x:0000BA6E                 db    0
.xdata$x:0000BA6F                 db    0
.xdata$x:0000BA70                 db    0
.xdata$x:0000BA71                 db    0
.xdata$x:0000BA72                 db    0
.xdata$x:0000BA73                 db    0
.xdata$x:0000BA73 _xdata$x        ends
.xdata$x:0000BA73
.xdata$x:0000BA74 ; ===========================================================================
.xdata$x:0000BA74
.xdata$x:0000BA74 ; Segment type: Pure data
.xdata$x:0000BA74 ; Segment permissions: Read
.xdata$x:0000BA74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BA74                 assume cs:_xdata$x
.xdata$x:0000BA74                 ;org 0BA74h
.xdata$x:0000BA74 ; COMDAT (pick associative to section at 8F2C)
.xdata$x:0000BA74 __catchsym$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:0000BA74                                         ; DATA XREF: .xdata$x:0000BAA4o
.xdata$x:0000BA75                 db    0
.xdata$x:0000BA76                 db    0
.xdata$x:0000BA77                 db    0
.xdata$x:0000BA78                 db    0
.xdata$x:0000BA79                 db    0
.xdata$x:0000BA7A                 db    0
.xdata$x:0000BA7B                 db    0
.xdata$x:0000BA7C                 db    0
.xdata$x:0000BA7D                 db    0
.xdata$x:0000BA7E                 db    0
.xdata$x:0000BA7F                 db    0
.xdata$x:0000BA80                 dd offset __catch$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z$0
.xdata$x:0000BA84 __unwindtable$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:0000BA84                                         ; DATA XREF: .xdata$x:0000BAB0o
.xdata$x:0000BA85                 db 0FFh
.xdata$x:0000BA86                 db 0FFh
.xdata$x:0000BA87                 db 0FFh
.xdata$x:0000BA88                 db    0
.xdata$x:0000BA89                 db    0
.xdata$x:0000BA8A                 db    0
.xdata$x:0000BA8B                 db    0
.xdata$x:0000BA8C                 db 0FFh
.xdata$x:0000BA8D                 db 0FFh
.xdata$x:0000BA8E                 db 0FFh
.xdata$x:0000BA8F                 db 0FFh
.xdata$x:0000BA90                 db    0
.xdata$x:0000BA91                 db    0
.xdata$x:0000BA92                 db    0
.xdata$x:0000BA93                 db    0
.xdata$x:0000BA94 __tryblocktable$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z db    0
.xdata$x:0000BA94                                         ; DATA XREF: .xdata$x:0000BAB8o
.xdata$x:0000BA95                 db    0
.xdata$x:0000BA96                 db    0
.xdata$x:0000BA97                 db    0
.xdata$x:0000BA98                 db    0
.xdata$x:0000BA99                 db    0
.xdata$x:0000BA9A                 db    0
.xdata$x:0000BA9B                 db    0
.xdata$x:0000BA9C                 db    1
.xdata$x:0000BA9D                 db    0
.xdata$x:0000BA9E                 db    0
.xdata$x:0000BA9F                 db    0
.xdata$x:0000BAA0                 db    1
.xdata$x:0000BAA1                 db    0
.xdata$x:0000BAA2                 db    0
.xdata$x:0000BAA3                 db    0
.xdata$x:0000BAA4                 dd offset __catchsym$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z$2
.xdata$x:0000BAA8 __ehfuncinfo$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000BAA8                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z+11o
.xdata$x:0000BAA9                 db    5
.xdata$x:0000BAAA                 db  93h ; ô
.xdata$x:0000BAAB                 db  19h
.xdata$x:0000BAAC                 db    2
.xdata$x:0000BAAD                 db    0
.xdata$x:0000BAAE                 db    0
.xdata$x:0000BAAF                 db    0
.xdata$x:0000BAB0                 dd offset __unwindtable$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z
.xdata$x:0000BAB4                 db    1
.xdata$x:0000BAB5                 db    0
.xdata$x:0000BAB6                 db    0
.xdata$x:0000BAB7                 db    0
.xdata$x:0000BAB8                 dd offset __tryblocktable$?_Reallocate@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IAEXI@Z
.xdata$x:0000BABC                 db    0
.xdata$x:0000BABD                 db    0
.xdata$x:0000BABE                 db    0
.xdata$x:0000BABF                 db    0
.xdata$x:0000BAC0                 db    0
.xdata$x:0000BAC1                 db    0
.xdata$x:0000BAC2                 db    0
.xdata$x:0000BAC3                 db    0
.xdata$x:0000BAC4                 db    0
.xdata$x:0000BAC5                 db    0
.xdata$x:0000BAC6                 db    0
.xdata$x:0000BAC7                 db    0
.xdata$x:0000BAC8                 db    0
.xdata$x:0000BAC9                 db    0
.xdata$x:0000BACA                 db    0
.xdata$x:0000BACB                 db    0
.xdata$x:0000BACB _xdata$x        ends
.xdata$x:0000BACB
.xdata$x:0000BACC ; ===========================================================================
.xdata$x:0000BACC
.xdata$x:0000BACC ; Segment type: Pure data
.xdata$x:0000BACC ; Segment permissions: Read
.xdata$x:0000BACC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BACC                 assume cs:_xdata$x
.xdata$x:0000BACC                 ;org 0BACCh
.xdata$x:0000BACC ; COMDAT (pick associative to section at 8CF4)
.xdata$x:0000BACC __unwindtable$?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z db 0FFh
.xdata$x:0000BACC                                         ; DATA XREF: .xdata$x:0000BADCo
.xdata$x:0000BACD                 db 0FFh
.xdata$x:0000BACE                 db 0FFh
.xdata$x:0000BACF                 db 0FFh
.xdata$x:0000BAD0                 dd offset __unwindfunclet$?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z$0
.xdata$x:0000BAD4 __ehfuncinfo$?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z db  22h ; "
.xdata$x:0000BAD4                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z+11o
.xdata$x:0000BAD5                 db    5
.xdata$x:0000BAD6                 db  93h ; ô
.xdata$x:0000BAD7                 db  19h
.xdata$x:0000BAD8                 db    1
.xdata$x:0000BAD9                 db    0
.xdata$x:0000BADA                 db    0
.xdata$x:0000BADB                 db    0
.xdata$x:0000BADC                 dd offset __unwindtable$?_Orphan_range@?$vector@UrecordedMacroStep@@V?$allocator@UrecordedMacroStep@@@std@@@std@@IBEXPAUrecordedMacroStep@@0@Z
.xdata$x:0000BAE0                 db    0
.xdata$x:0000BAE1                 db    0
.xdata$x:0000BAE2                 db    0
.xdata$x:0000BAE3                 db    0
.xdata$x:0000BAE4                 db    0
.xdata$x:0000BAE5                 db    0
.xdata$x:0000BAE6                 db    0
.xdata$x:0000BAE7                 db    0
.xdata$x:0000BAE8                 db    0
.xdata$x:0000BAE9                 db    0
.xdata$x:0000BAEA                 db    0
.xdata$x:0000BAEB                 db    0
.xdata$x:0000BAEC                 db    0
.xdata$x:0000BAED                 db    0
.xdata$x:0000BAEE                 db    0
.xdata$x:0000BAEF                 db    0
.xdata$x:0000BAF0                 db    0
.xdata$x:0000BAF1                 db    0
.xdata$x:0000BAF2                 db    0
.xdata$x:0000BAF3                 db    0
.xdata$x:0000BAF4                 db    0
.xdata$x:0000BAF5                 db    0
.xdata$x:0000BAF6                 db    0
.xdata$x:0000BAF7                 db    0
.xdata$x:0000BAF7 _xdata$x        ends
.xdata$x:0000BAF7
.xdata$x:0000BAF8 ; ===========================================================================
.xdata$x:0000BAF8
.xdata$x:0000BAF8 ; Segment type: Pure data
.xdata$x:0000BAF8 ; Segment permissions: Read
.xdata$x:0000BAF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BAF8                 assume cs:_xdata$x
.xdata$x:0000BAF8                 ;org 0BAF8h
.xdata$x:0000BAF8 ; COMDAT (pick associative to section at 72BC)
.xdata$x:0000BAF8 __unwindtable$??1MenuItemUnit@@QAE@XZ db 0FFh
.xdata$x:0000BAF8                                         ; DATA XREF: .xdata$x:0000BB10o
.xdata$x:0000BAF9                 db 0FFh
.xdata$x:0000BAFA                 db 0FFh
.xdata$x:0000BAFB                 db 0FFh
.xdata$x:0000BAFC                 dd offset __unwindfunclet$??1MenuItemUnit@@QAE@XZ$0
.xdata$x:0000BB00                 db    0
.xdata$x:0000BB01                 db    0
.xdata$x:0000BB02                 db    0
.xdata$x:0000BB03                 db    0
.xdata$x:0000BB04                 dd offset __unwindfunclet$??1MenuItemUnit@@QAE@XZ$1
.xdata$x:0000BB08 __ehfuncinfo$??1MenuItemUnit@@QAE@XZ db  22h ; "
.xdata$x:0000BB08                                         ; DATA XREF: __ehhandler$??1MenuItemUnit@@QAE@XZ+11o
.xdata$x:0000BB09                 db    5
.xdata$x:0000BB0A                 db  93h ; ô
.xdata$x:0000BB0B                 db  19h
.xdata$x:0000BB0C                 db    2
.xdata$x:0000BB0D                 db    0
.xdata$x:0000BB0E                 db    0
.xdata$x:0000BB0F                 db    0
.xdata$x:0000BB10                 dd offset __unwindtable$??1MenuItemUnit@@QAE@XZ
.xdata$x:0000BB14                 db    0
.xdata$x:0000BB15                 db    0
.xdata$x:0000BB16                 db    0
.xdata$x:0000BB17                 db    0
.xdata$x:0000BB18                 db    0
.xdata$x:0000BB19                 db    0
.xdata$x:0000BB1A                 db    0
.xdata$x:0000BB1B                 db    0
.xdata$x:0000BB1C                 db    0
.xdata$x:0000BB1D                 db    0
.xdata$x:0000BB1E                 db    0
.xdata$x:0000BB1F                 db    0
.xdata$x:0000BB20                 db    0
.xdata$x:0000BB21                 db    0
.xdata$x:0000BB22                 db    0
.xdata$x:0000BB23                 db    0
.xdata$x:0000BB24                 db    0
.xdata$x:0000BB25                 db    0
.xdata$x:0000BB26                 db    0
.xdata$x:0000BB27                 db    0
.xdata$x:0000BB28                 db    0
.xdata$x:0000BB29                 db    0
.xdata$x:0000BB2A                 db    0
.xdata$x:0000BB2B                 db    0
.xdata$x:0000BB2B _xdata$x        ends
.xdata$x:0000BB2B
.xdata$x:0000BB2C ; ===========================================================================
.xdata$x:0000BB2C
.xdata$x:0000BB2C ; Segment type: Pure data
.xdata$x:0000BB2C ; Segment permissions: Read
.xdata$x:0000BB2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BB2C                 assume cs:_xdata$x
.xdata$x:0000BB2C                 ;org 0BB2Ch
.xdata$x:0000BB2C ; COMDAT (pick associative to section at 6804)
.xdata$x:0000BB2C __unwindtable$??0MenuItemUnit@@QAE@ABU0@@Z db 0FFh
.xdata$x:0000BB2C                                         ; DATA XREF: .xdata$x:0000BB44o
.xdata$x:0000BB2D                 db 0FFh
.xdata$x:0000BB2E                 db 0FFh
.xdata$x:0000BB2F                 db 0FFh
.xdata$x:0000BB30                 dd offset __unwindfunclet$??0MenuItemUnit@@QAE@ABU0@@Z$0
.xdata$x:0000BB34                 align 8
.xdata$x:0000BB38                 dd offset __unwindfunclet$??0MenuItemUnit@@QAE@ABU0@@Z$1
.xdata$x:0000BB3C __ehfuncinfo$??0MenuItemUnit@@QAE@ABU0@@Z db  22h ; "
.xdata$x:0000BB3C                                         ; DATA XREF: __ehhandler$??0MenuItemUnit@@QAE@ABU0@@Z+11o
.xdata$x:0000BB3D                 db    5
.xdata$x:0000BB3E                 db  93h ; ô
.xdata$x:0000BB3F                 db  19h
.xdata$x:0000BB40                 db    2
.xdata$x:0000BB41                 db    0
.xdata$x:0000BB42                 db    0
.xdata$x:0000BB43                 db    0
.xdata$x:0000BB44                 dd offset __unwindtable$??0MenuItemUnit@@QAE@ABU0@@Z
.xdata$x:0000BB48                 align 20h
.xdata$x:0000BB48 _xdata$x        ends
.xdata$x:0000BB48
.xdata$x:0000BB60 ; ===========================================================================
.xdata$x:0000BB60
.xdata$x:0000BB60 ; Segment type: Pure data
.xdata$x:0000BB60 ; Segment permissions: Read
.xdata$x:0000BB60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BB60                 assume cs:_xdata$x
.xdata$x:0000BB60                 ;org 0BB60h
.xdata$x:0000BB60 ; COMDAT (pick associative to section at 61EC)
.xdata$x:0000BB60 __unwindtable$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000BB60                                         ; DATA XREF: .xdata$x:0000BB70o
.xdata$x:0000BB61                 db 0FFh
.xdata$x:0000BB62                 db 0FFh
.xdata$x:0000BB63                 db 0FFh
.xdata$x:0000BB64                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ$0
.xdata$x:0000BB68 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000BB68                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000BB69                 db    5
.xdata$x:0000BB6A                 db  93h ; ô
.xdata$x:0000BB6B                 db  19h
.xdata$x:0000BB6C                 db    1
.xdata$x:0000BB6D                 db    0
.xdata$x:0000BB6E                 db    0
.xdata$x:0000BB6F                 db    0
.xdata$x:0000BB70                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.xdata$x:0000BB74                 db    0
.xdata$x:0000BB75                 db    0
.xdata$x:0000BB76                 db    0
.xdata$x:0000BB77                 db    0
.xdata$x:0000BB78                 db    0
.xdata$x:0000BB79                 db    0
.xdata$x:0000BB7A                 db    0
.xdata$x:0000BB7B                 db    0
.xdata$x:0000BB7C                 db    0
.xdata$x:0000BB7D                 db    0
.xdata$x:0000BB7E                 db    0
.xdata$x:0000BB7F                 db    0
.xdata$x:0000BB80                 db    0
.xdata$x:0000BB81                 db    0
.xdata$x:0000BB82                 db    0
.xdata$x:0000BB83                 db    0
.xdata$x:0000BB84                 db    0
.xdata$x:0000BB85                 db    0
.xdata$x:0000BB86                 db    0
.xdata$x:0000BB87                 db    0
.xdata$x:0000BB88                 db    0
.xdata$x:0000BB89                 db    0
.xdata$x:0000BB8A                 db    0
.xdata$x:0000BB8B                 db    0
.xdata$x:0000BB8B _xdata$x        ends
.xdata$x:0000BB8B
.xdata$x:0000BB8C ; ===========================================================================
.xdata$x:0000BB8C
.xdata$x:0000BB8C ; Segment type: Pure data
.xdata$x:0000BB8C ; Segment permissions: Read
.xdata$x:0000BB8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BB8C                 assume cs:_xdata$x
.xdata$x:0000BB8C                 ;org 0BB8Ch
.xdata$x:0000BB8C ; COMDAT (pick associative to section at 6FF4)
.xdata$x:0000BB8C __unwindtable$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000BB8C                                         ; DATA XREF: .xdata$x:0000BB9Co
.xdata$x:0000BB8D                 db 0FFh
.xdata$x:0000BB8E                 db 0FFh
.xdata$x:0000BB8F                 db 0FFh
.xdata$x:0000BB90                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ$0
.xdata$x:0000BB94 __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000BB94                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000BB95                 db    5
.xdata$x:0000BB96                 db  93h ; ô
.xdata$x:0000BB97                 db  19h
.xdata$x:0000BB98                 db    1
.xdata$x:0000BB99                 db    0
.xdata$x:0000BB9A                 db    0
.xdata$x:0000BB9B                 db    0
.xdata$x:0000BB9C                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@UMenuItemUnit@@@std@@@std@@QAE@XZ
.xdata$x:0000BBA0                 db    0
.xdata$x:0000BBA1                 db    0
.xdata$x:0000BBA2                 db    0
.xdata$x:0000BBA3                 db    0
.xdata$x:0000BBA4                 db    0
.xdata$x:0000BBA5                 db    0
.xdata$x:0000BBA6                 db    0
.xdata$x:0000BBA7                 db    0
.xdata$x:0000BBA8                 db    0
.xdata$x:0000BBA9                 db    0
.xdata$x:0000BBAA                 db    0
.xdata$x:0000BBAB                 db    0
.xdata$x:0000BBAC                 db    0
.xdata$x:0000BBAD                 db    0
.xdata$x:0000BBAE                 db    0
.xdata$x:0000BBAF                 db    0
.xdata$x:0000BBB0                 db    0
.xdata$x:0000BBB1                 db    0
.xdata$x:0000BBB2                 db    0
.xdata$x:0000BBB3                 db    0
.xdata$x:0000BBB4                 db    0
.xdata$x:0000BBB5                 db    0
.xdata$x:0000BBB6                 db    0
.xdata$x:0000BBB7                 db    0
.xdata$x:0000BBB7 _xdata$x        ends
.xdata$x:0000BBB7
.xdata$x:0000BBB8 ; ===========================================================================
.xdata$x:0000BBB8
.xdata$x:0000BBB8 ; Segment type: Pure data
.xdata$x:0000BBB8 ; Segment permissions: Read
.xdata$x:0000BBB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BBB8                 assume cs:_xdata$x
.xdata$x:0000BBB8                 ;org 0BBB8h
.xdata$x:0000BBB8 ; COMDAT (pick associative to section at 6170)
.xdata$x:0000BBB8 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z db 0FFh
.xdata$x:0000BBB8                                         ; DATA XREF: .xdata$x:0000BBC8o
.xdata$x:0000BBB9                 db 0FFh
.xdata$x:0000BBBA                 db 0FFh
.xdata$x:0000BBBB                 db 0FFh
.xdata$x:0000BBBC                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z$0
.xdata$x:0000BBC0 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z db  22h ; "
.xdata$x:0000BBC0                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z+11o
.xdata$x:0000BBC1                 db    5
.xdata$x:0000BBC2                 db  93h ; ô
.xdata$x:0000BBC3                 db  19h
.xdata$x:0000BBC4                 db    1
.xdata$x:0000BBC5                 db    0
.xdata$x:0000BBC6                 db    0
.xdata$x:0000BBC7                 db    0
.xdata$x:0000BBC8                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@ABV?$allocator@UMenuItemUnit@@@1@@Z
.xdata$x:0000BBCC                 db    0
.xdata$x:0000BBCD                 db    0
.xdata$x:0000BBCE                 db    0
.xdata$x:0000BBCF                 db    0
.xdata$x:0000BBD0                 db    0
.xdata$x:0000BBD1                 db    0
.xdata$x:0000BBD2                 db    0
.xdata$x:0000BBD3                 db    0
.xdata$x:0000BBD4                 db    0
.xdata$x:0000BBD5                 db    0
.xdata$x:0000BBD6                 db    0
.xdata$x:0000BBD7                 db    0
.xdata$x:0000BBD8                 db    0
.xdata$x:0000BBD9                 db    0
.xdata$x:0000BBDA                 db    0
.xdata$x:0000BBDB                 db    0
.xdata$x:0000BBDC                 db    0
.xdata$x:0000BBDD                 db    0
.xdata$x:0000BBDE                 db    0
.xdata$x:0000BBDF                 db    0
.xdata$x:0000BBE0                 db    0
.xdata$x:0000BBE1                 db    0
.xdata$x:0000BBE2                 db    0
.xdata$x:0000BBE3                 db    0
.xdata$x:0000BBE3 _xdata$x        ends
.xdata$x:0000BBE3
.xdata$x:0000BBE4 ; ===========================================================================
.xdata$x:0000BBE4
.xdata$x:0000BBE4 ; Segment type: Pure data
.xdata$x:0000BBE4 ; Segment permissions: Read
.xdata$x:0000BBE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BBE4                 assume cs:_xdata$x
.xdata$x:0000BBE4                 ;org 0BBE4h
.xdata$x:0000BBE4 ; COMDAT (pick associative to section at 6F7C)
.xdata$x:0000BBE4 __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000BBE4                                         ; DATA XREF: .xdata$x:0000BBF4o
.xdata$x:0000BBE5                 db 0FFh
.xdata$x:0000BBE6                 db 0FFh
.xdata$x:0000BBE7                 db 0FFh
.xdata$x:0000BBE8                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000BBEC __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000BBEC                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000BBED                 db    5
.xdata$x:0000BBEE                 db  93h ; ô
.xdata$x:0000BBEF                 db  19h
.xdata$x:0000BBF0                 db    1
.xdata$x:0000BBF1                 db    0
.xdata$x:0000BBF2                 db    0
.xdata$x:0000BBF3                 db    0
.xdata$x:0000BBF4                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@@std@@QAE@XZ
.xdata$x:0000BBF8                 db    0
.xdata$x:0000BBF9                 db    0
.xdata$x:0000BBFA                 db    0
.xdata$x:0000BBFB                 db    0
.xdata$x:0000BBFC                 db    0
.xdata$x:0000BBFD                 db    0
.xdata$x:0000BBFE                 db    0
.xdata$x:0000BBFF                 db    0
.xdata$x:0000BC00                 db    0
.xdata$x:0000BC01                 db    0
.xdata$x:0000BC02                 db    0
.xdata$x:0000BC03                 db    0
.xdata$x:0000BC04                 db    0
.xdata$x:0000BC05                 db    0
.xdata$x:0000BC06                 db    0
.xdata$x:0000BC07                 db    0
.xdata$x:0000BC08                 db    0
.xdata$x:0000BC09                 db    0
.xdata$x:0000BC0A                 db    0
.xdata$x:0000BC0B                 db    0
.xdata$x:0000BC0C                 db    0
.xdata$x:0000BC0D                 db    0
.xdata$x:0000BC0E                 db    0
.xdata$x:0000BC0F                 db    0
.xdata$x:0000BC0F _xdata$x        ends
.xdata$x:0000BC0F
.xdata$x:0000BC10 ; ===========================================================================
.xdata$x:0000BC10
.xdata$x:0000BC10 ; Segment type: Pure data
.xdata$x:0000BC10 ; Segment permissions: Read
.xdata$x:0000BC10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BC10                 assume cs:_xdata$x
.xdata$x:0000BC10                 ;org 0BC10h
.xdata$x:0000BC10 ; COMDAT (pick associative to section at 6784)
.xdata$x:0000BC10 __unwindtable$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000BC10                                         ; DATA XREF: .xdata$x:0000BC20o
.xdata$x:0000BC11                 db 0FFh
.xdata$x:0000BC12                 db 0FFh
.xdata$x:0000BC13                 db 0FFh
.xdata$x:0000BC14                 dd offset __unwindfunclet$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ$0
.xdata$x:0000BC18 __ehfuncinfo$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000BC18                                         ; DATA XREF: __ehhandler$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000BC19                 db    5
.xdata$x:0000BC1A                 db  93h ; ô
.xdata$x:0000BC1B                 db  19h
.xdata$x:0000BC1C                 db    1
.xdata$x:0000BC1D                 db    0
.xdata$x:0000BC1E                 db    0
.xdata$x:0000BC1F                 db    0
.xdata$x:0000BC20                 dd offset __unwindtable$??0?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.xdata$x:0000BC24                 db    0
.xdata$x:0000BC25                 db    0
.xdata$x:0000BC26                 db    0
.xdata$x:0000BC27                 db    0
.xdata$x:0000BC28                 db    0
.xdata$x:0000BC29                 db    0
.xdata$x:0000BC2A                 db    0
.xdata$x:0000BC2B                 db    0
.xdata$x:0000BC2C                 db    0
.xdata$x:0000BC2D                 db    0
.xdata$x:0000BC2E                 db    0
.xdata$x:0000BC2F                 db    0
.xdata$x:0000BC30                 db    0
.xdata$x:0000BC31                 db    0
.xdata$x:0000BC32                 db    0
.xdata$x:0000BC33                 db    0
.xdata$x:0000BC34                 db    0
.xdata$x:0000BC35                 db    0
.xdata$x:0000BC36                 db    0
.xdata$x:0000BC37                 db    0
.xdata$x:0000BC38                 db    0
.xdata$x:0000BC39                 db    0
.xdata$x:0000BC3A                 db    0
.xdata$x:0000BC3B                 db    0
.xdata$x:0000BC3B _xdata$x        ends
.xdata$x:0000BC3B
.xdata$x:0000BC3C ; ===========================================================================
.xdata$x:0000BC3C
.xdata$x:0000BC3C ; Segment type: Pure data
.xdata$x:0000BC3C ; Segment permissions: Read
.xdata$x:0000BC3C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BC3C                 assume cs:_xdata$x
.xdata$x:0000BC3C                 ;org 0BC3Ch
.xdata$x:0000BC3C ; COMDAT (pick associative to section at 7244)
.xdata$x:0000BC3C __unwindtable$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000BC3C                                         ; DATA XREF: .xdata$x:0000BC4Co
.xdata$x:0000BC3D                 db 0FFh
.xdata$x:0000BC3E                 db 0FFh
.xdata$x:0000BC3F                 db 0FFh
.xdata$x:0000BC40                 dd offset __unwindfunclet$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ$0
.xdata$x:0000BC44 __ehfuncinfo$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000BC44                                         ; DATA XREF: __ehhandler$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000BC45                 db    5
.xdata$x:0000BC46                 db  93h ; ô
.xdata$x:0000BC47                 db  19h
.xdata$x:0000BC48                 db    1
.xdata$x:0000BC49                 db    0
.xdata$x:0000BC4A                 db    0
.xdata$x:0000BC4B                 db    0
.xdata$x:0000BC4C                 dd offset __unwindtable$??1?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAE@XZ
.xdata$x:0000BC50                 db    0
.xdata$x:0000BC51                 db    0
.xdata$x:0000BC52                 db    0
.xdata$x:0000BC53                 db    0
.xdata$x:0000BC54                 db    0
.xdata$x:0000BC55                 db    0
.xdata$x:0000BC56                 db    0
.xdata$x:0000BC57                 db    0
.xdata$x:0000BC58                 db    0
.xdata$x:0000BC59                 db    0
.xdata$x:0000BC5A                 db    0
.xdata$x:0000BC5B                 db    0
.xdata$x:0000BC5C                 db    0
.xdata$x:0000BC5D                 db    0
.xdata$x:0000BC5E                 db    0
.xdata$x:0000BC5F                 db    0
.xdata$x:0000BC60                 db    0
.xdata$x:0000BC61                 db    0
.xdata$x:0000BC62                 db    0
.xdata$x:0000BC63                 db    0
.xdata$x:0000BC64                 db    0
.xdata$x:0000BC65                 db    0
.xdata$x:0000BC66                 db    0
.xdata$x:0000BC67                 db    0
.xdata$x:0000BC67 _xdata$x        ends
.xdata$x:0000BC67
.xdata$x:0000BC68 ; ===========================================================================
.xdata$x:0000BC68
.xdata$x:0000BC68 ; Segment type: Pure data
.xdata$x:0000BC68 ; Segment permissions: Read
.xdata$x:0000BC68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BC68                 assume cs:_xdata$x
.xdata$x:0000BC68                 ;org 0BC68h
.xdata$x:0000BC68 ; COMDAT (pick associative to section at 8DD0)
.xdata$x:0000BC68 __catchsym$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:0000BC68                                         ; DATA XREF: .xdata$x:0000BC98o
.xdata$x:0000BC69                 db    0
.xdata$x:0000BC6A                 db    0
.xdata$x:0000BC6B                 db    0
.xdata$x:0000BC6C                 db    0
.xdata$x:0000BC6D                 db    0
.xdata$x:0000BC6E                 db    0
.xdata$x:0000BC6F                 db    0
.xdata$x:0000BC70                 db    0
.xdata$x:0000BC71                 db    0
.xdata$x:0000BC72                 db    0
.xdata$x:0000BC73                 db    0
.xdata$x:0000BC74                 dd offset __catch$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z$0
.xdata$x:0000BC78 __unwindtable$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:0000BC78                                         ; DATA XREF: .xdata$x:0000BCA4o
.xdata$x:0000BC79                 db 0FFh
.xdata$x:0000BC7A                 db 0FFh
.xdata$x:0000BC7B                 db 0FFh
.xdata$x:0000BC7C                 db    0
.xdata$x:0000BC7D                 db    0
.xdata$x:0000BC7E                 db    0
.xdata$x:0000BC7F                 db    0
.xdata$x:0000BC80                 db 0FFh
.xdata$x:0000BC81                 db 0FFh
.xdata$x:0000BC82                 db 0FFh
.xdata$x:0000BC83                 db 0FFh
.xdata$x:0000BC84                 db    0
.xdata$x:0000BC85                 db    0
.xdata$x:0000BC86                 db    0
.xdata$x:0000BC87                 db    0
.xdata$x:0000BC88 __tryblocktable$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z db    0
.xdata$x:0000BC88                                         ; DATA XREF: .xdata$x:0000BCACo
.xdata$x:0000BC89                 db    0
.xdata$x:0000BC8A                 db    0
.xdata$x:0000BC8B                 db    0
.xdata$x:0000BC8C                 db    0
.xdata$x:0000BC8D                 db    0
.xdata$x:0000BC8E                 db    0
.xdata$x:0000BC8F                 db    0
.xdata$x:0000BC90                 db    1
.xdata$x:0000BC91                 db    0
.xdata$x:0000BC92                 db    0
.xdata$x:0000BC93                 db    0
.xdata$x:0000BC94                 db    1
.xdata$x:0000BC95                 db    0
.xdata$x:0000BC96                 db    0
.xdata$x:0000BC97                 db    0
.xdata$x:0000BC98                 dd offset __catchsym$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z$2
.xdata$x:0000BC9C __ehfuncinfo$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000BC9C                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z+11o
.xdata$x:0000BC9D                 db    5
.xdata$x:0000BC9E                 db  93h ; ô
.xdata$x:0000BC9F                 db  19h
.xdata$x:0000BCA0                 db    2
.xdata$x:0000BCA1                 db    0
.xdata$x:0000BCA2                 db    0
.xdata$x:0000BCA3                 db    0
.xdata$x:0000BCA4                 dd offset __unwindtable$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.xdata$x:0000BCA8                 db    1
.xdata$x:0000BCA9                 db    0
.xdata$x:0000BCAA                 db    0
.xdata$x:0000BCAB                 db    0
.xdata$x:0000BCAC                 dd offset __tryblocktable$?_Reallocate@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IAEXI@Z
.xdata$x:0000BCB0                 align 20h
.xdata$x:0000BCB0 _xdata$x        ends
.xdata$x:0000BCB0
.xdata$x:0000BCC0 ; ===========================================================================
.xdata$x:0000BCC0
.xdata$x:0000BCC0 ; Segment type: Pure data
.xdata$x:0000BCC0 ; Segment permissions: Read
.xdata$x:0000BCC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BCC0                 assume cs:_xdata$x
.xdata$x:0000BCC0                 ;org 0BCC0h
.xdata$x:0000BCC0 ; COMDAT (pick associative to section at 8C18)
.xdata$x:0000BCC0 __unwindtable$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z db 0FFh
.xdata$x:0000BCC0                                         ; DATA XREF: .xdata$x:0000BCD0o
.xdata$x:0000BCC1                 db 0FFh
.xdata$x:0000BCC2                 db 0FFh
.xdata$x:0000BCC3                 db 0FFh
.xdata$x:0000BCC4                 dd offset __unwindfunclet$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z$0
.xdata$x:0000BCC8 __ehfuncinfo$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z db  22h ; "
.xdata$x:0000BCC8                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z+11o
.xdata$x:0000BCC9                 db    5
.xdata$x:0000BCCA                 db  93h ; ô
.xdata$x:0000BCCB                 db  19h
.xdata$x:0000BCCC                 db    1
.xdata$x:0000BCCD                 db    0
.xdata$x:0000BCCE                 db    0
.xdata$x:0000BCCF                 db    0
.xdata$x:0000BCD0                 dd offset __unwindtable$?_Orphan_range@?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@IBEXPAUMenuItemUnit@@0@Z
.xdata$x:0000BCD4                 db    0
.xdata$x:0000BCD5                 db    0
.xdata$x:0000BCD6                 db    0
.xdata$x:0000BCD7                 db    0
.xdata$x:0000BCD8                 db    0
.xdata$x:0000BCD9                 db    0
.xdata$x:0000BCDA                 db    0
.xdata$x:0000BCDB                 db    0
.xdata$x:0000BCDC                 db    0
.xdata$x:0000BCDD                 db    0
.xdata$x:0000BCDE                 db    0
.xdata$x:0000BCDF                 db    0
.xdata$x:0000BCE0                 db    0
.xdata$x:0000BCE1                 db    0
.xdata$x:0000BCE2                 db    0
.xdata$x:0000BCE3                 db    0
.xdata$x:0000BCE4                 db    0
.xdata$x:0000BCE5                 db    0
.xdata$x:0000BCE6                 db    0
.xdata$x:0000BCE7                 db    0
.xdata$x:0000BCE8                 db    0
.xdata$x:0000BCE9                 db    0
.xdata$x:0000BCEA                 db    0
.xdata$x:0000BCEB                 db    0
.xdata$x:0000BCEB _xdata$x        ends
.xdata$x:0000BCEB
.xdata$x:0000BCEC ; ===========================================================================
.xdata$x:0000BCEC
.xdata$x:0000BCEC ; Segment type: Pure data
.xdata$x:0000BCEC ; Segment permissions: Read
.xdata$x:0000BCEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BCEC                 assume cs:_xdata$x
.xdata$x:0000BCEC                 ;org 0BCECh
.xdata$x:0000BCEC __catchsym$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$41 db    0
.xdata$x:0000BCEC                                         ; DATA XREF: .xdata$x:0000BD0Co
.xdata$x:0000BCED                 db    0
.xdata$x:0000BCEE                 db    0
.xdata$x:0000BCEF                 db    0
.xdata$x:0000BCF0                 db    0
.xdata$x:0000BCF1                 db    0
.xdata$x:0000BCF2                 db    0
.xdata$x:0000BCF3                 db    0
.xdata$x:0000BCF4                 db    0
.xdata$x:0000BCF5                 db    0
.xdata$x:0000BCF6                 db    0
.xdata$x:0000BCF7                 db    0
.xdata$x:0000BCF8                 dd offset __catch$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$0
.xdata$x:0000BCFC __tryblocktable$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z dd offset off_24+1
.xdata$x:0000BCFC                                         ; DATA XREF: .xdata$x:0000BD20o
.xdata$x:0000BD00                 dd offset off_24+2
.xdata$x:0000BD04                 dd offset off_24+3
.xdata$x:0000BD08                 db    1
.xdata$x:0000BD09                 db    0
.xdata$x:0000BD0A                 db    0
.xdata$x:0000BD0B                 db    0
.xdata$x:0000BD0C                 dd offset __catchsym$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$41
.xdata$x:0000BD10 __ehfuncinfo$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z db  22h ; "
.xdata$x:0000BD10                                         ; DATA XREF: __ehhandler$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z+1Eo
.xdata$x:0000BD11                 db    5
.xdata$x:0000BD12                 db  93h ; ô
.xdata$x:0000BD13                 db  19h
.xdata$x:0000BD14                 db  29h ; )
.xdata$x:0000BD15                 db    0
.xdata$x:0000BD16                 db    0
.xdata$x:0000BD17                 db    0
.xdata$x:0000BD18                 dd offset __unwindtable$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z
.xdata$x:0000BD1C                 db    1
.xdata$x:0000BD1D                 db    0
.xdata$x:0000BD1E                 db    0
.xdata$x:0000BD1F                 db    0
.xdata$x:0000BD20                 dd offset __tryblocktable$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z
.xdata$x:0000BD24                 db    0
.xdata$x:0000BD25                 db    0
.xdata$x:0000BD26                 db    0
.xdata$x:0000BD27                 db    0
.xdata$x:0000BD28                 db    0
.xdata$x:0000BD29                 db    0
.xdata$x:0000BD2A                 db    0
.xdata$x:0000BD2B                 db    0
.xdata$x:0000BD2C                 db    0
.xdata$x:0000BD2D                 db    0
.xdata$x:0000BD2E                 db    0
.xdata$x:0000BD2F                 db    0
.xdata$x:0000BD30                 db    0
.xdata$x:0000BD31                 db    0
.xdata$x:0000BD32                 db    0
.xdata$x:0000BD33                 db    0
.xdata$x:0000BD34 __unwindtable$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z db 0FFh
.xdata$x:0000BD34                                         ; DATA XREF: .xdata$x:0000BD18o
.xdata$x:0000BD35                 db 0FFh
.xdata$x:0000BD36                 db 0FFh
.xdata$x:0000BD37                 db 0FFh
.xdata$x:0000BD38                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$2
.xdata$x:0000BD3C                 align 10h
.xdata$x:0000BD40                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$3
.xdata$x:0000BD44                 align 8
.xdata$x:0000BD48                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$4
.xdata$x:0000BD4C                 db 0FFh
.xdata$x:0000BD4D                 db 0FFh
.xdata$x:0000BD4E                 db 0FFh
.xdata$x:0000BD4F                 db 0FFh
.xdata$x:0000BD50                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$5
.xdata$x:0000BD54                 db    3
.xdata$x:0000BD55                 db    0
.xdata$x:0000BD56                 db    0
.xdata$x:0000BD57                 db    0
.xdata$x:0000BD58                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$6
.xdata$x:0000BD5C                 db    4
.xdata$x:0000BD5D                 db    0
.xdata$x:0000BD5E                 db    0
.xdata$x:0000BD5F                 db    0
.xdata$x:0000BD60                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$7
.xdata$x:0000BD64                 db 0FFh
.xdata$x:0000BD65                 db 0FFh
.xdata$x:0000BD66                 db 0FFh
.xdata$x:0000BD67                 db 0FFh
.xdata$x:0000BD68                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$8
.xdata$x:0000BD6C                 db    6
.xdata$x:0000BD6D                 db    0
.xdata$x:0000BD6E                 db    0
.xdata$x:0000BD6F                 db    0
.xdata$x:0000BD70                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$9
.xdata$x:0000BD74                 db    6
.xdata$x:0000BD75                 db    0
.xdata$x:0000BD76                 db    0
.xdata$x:0000BD77                 db    0
.xdata$x:0000BD78                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$10
.xdata$x:0000BD7C                 db 0FFh
.xdata$x:0000BD7D                 db 0FFh
.xdata$x:0000BD7E                 db 0FFh
.xdata$x:0000BD7F                 db 0FFh
.xdata$x:0000BD80                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$11
.xdata$x:0000BD84                 db    9
.xdata$x:0000BD85                 db    0
.xdata$x:0000BD86                 db    0
.xdata$x:0000BD87                 db    0
.xdata$x:0000BD88                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$12
.xdata$x:0000BD8C                 db    9
.xdata$x:0000BD8D                 db    0
.xdata$x:0000BD8E                 db    0
.xdata$x:0000BD8F                 db    0
.xdata$x:0000BD90                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$13
.xdata$x:0000BD94                 db    9
.xdata$x:0000BD95                 db    0
.xdata$x:0000BD96                 db    0
.xdata$x:0000BD97                 db    0
.xdata$x:0000BD98                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$14
.xdata$x:0000BD9C                 db    9
.xdata$x:0000BD9D                 db    0
.xdata$x:0000BD9E                 db    0
.xdata$x:0000BD9F                 db    0
.xdata$x:0000BDA0                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$15
.xdata$x:0000BDA4                 db    9
.xdata$x:0000BDA5                 db    0
.xdata$x:0000BDA6                 db    0
.xdata$x:0000BDA7                 db    0
.xdata$x:0000BDA8                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$16
.xdata$x:0000BDAC                 db    9
.xdata$x:0000BDAD                 db    0
.xdata$x:0000BDAE                 db    0
.xdata$x:0000BDAF                 db    0
.xdata$x:0000BDB0                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$17
.xdata$x:0000BDB4                 db    9
.xdata$x:0000BDB5                 db    0
.xdata$x:0000BDB6                 db    0
.xdata$x:0000BDB7                 db    0
.xdata$x:0000BDB8                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$18
.xdata$x:0000BDBC                 db    9
.xdata$x:0000BDBD                 db    0
.xdata$x:0000BDBE                 db    0
.xdata$x:0000BDBF                 db    0
.xdata$x:0000BDC0                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$19
.xdata$x:0000BDC4                 db    9
.xdata$x:0000BDC5                 db    0
.xdata$x:0000BDC6                 db    0
.xdata$x:0000BDC7                 db    0
.xdata$x:0000BDC8                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$20
.xdata$x:0000BDCC                 db    9
.xdata$x:0000BDCD                 db    0
.xdata$x:0000BDCE                 db    0
.xdata$x:0000BDCF                 db    0
.xdata$x:0000BDD0                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$21
.xdata$x:0000BDD4                 db    9
.xdata$x:0000BDD5                 db    0
.xdata$x:0000BDD6                 db    0
.xdata$x:0000BDD7                 db    0
.xdata$x:0000BDD8                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$22
.xdata$x:0000BDDC                 db    9
.xdata$x:0000BDDD                 db    0
.xdata$x:0000BDDE                 db    0
.xdata$x:0000BDDF                 db    0
.xdata$x:0000BDE0                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$23
.xdata$x:0000BDE4                 db    9
.xdata$x:0000BDE5                 db    0
.xdata$x:0000BDE6                 db    0
.xdata$x:0000BDE7                 db    0
.xdata$x:0000BDE8                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$24
.xdata$x:0000BDEC                 db    9
.xdata$x:0000BDED                 db    0
.xdata$x:0000BDEE                 db    0
.xdata$x:0000BDEF                 db    0
.xdata$x:0000BDF0                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$25
.xdata$x:0000BDF4                 db    9
.xdata$x:0000BDF5                 db    0
.xdata$x:0000BDF6                 db    0
.xdata$x:0000BDF7                 db    0
.xdata$x:0000BDF8                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$26
.xdata$x:0000BDFC                 db    9
.xdata$x:0000BDFD                 db    0
.xdata$x:0000BDFE                 db    0
.xdata$x:0000BDFF                 db    0
.xdata$x:0000BE00                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$27
.xdata$x:0000BE04                 db    9
.xdata$x:0000BE05                 db    0
.xdata$x:0000BE06                 db    0
.xdata$x:0000BE07                 db    0
.xdata$x:0000BE08                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$28
.xdata$x:0000BE0C                 db    9
.xdata$x:0000BE0D                 db    0
.xdata$x:0000BE0E                 db    0
.xdata$x:0000BE0F                 db    0
.xdata$x:0000BE10                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$29
.xdata$x:0000BE14                 db    9
.xdata$x:0000BE15                 db    0
.xdata$x:0000BE16                 db    0
.xdata$x:0000BE17                 db    0
.xdata$x:0000BE18                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$30
.xdata$x:0000BE1C                 db    9
.xdata$x:0000BE1D                 db    0
.xdata$x:0000BE1E                 db    0
.xdata$x:0000BE1F                 db    0
.xdata$x:0000BE20                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$31
.xdata$x:0000BE24                 db    9
.xdata$x:0000BE25                 db    0
.xdata$x:0000BE26                 db    0
.xdata$x:0000BE27                 db    0
.xdata$x:0000BE28                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$32
.xdata$x:0000BE2C                 db    9
.xdata$x:0000BE2D                 db    0
.xdata$x:0000BE2E                 db    0
.xdata$x:0000BE2F                 db    0
.xdata$x:0000BE30                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$33
.xdata$x:0000BE34                 db    9
.xdata$x:0000BE35                 db    0
.xdata$x:0000BE36                 db    0
.xdata$x:0000BE37                 db    0
.xdata$x:0000BE38                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$34
.xdata$x:0000BE3C                 db    9
.xdata$x:0000BE3D                 db    0
.xdata$x:0000BE3E                 db    0
.xdata$x:0000BE3F                 db    0
.xdata$x:0000BE40                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$35
.xdata$x:0000BE44                 db    9
.xdata$x:0000BE45                 db    0
.xdata$x:0000BE46                 db    0
.xdata$x:0000BE47                 db    0
.xdata$x:0000BE48                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$36
.xdata$x:0000BE4C                 db 0FFh
.xdata$x:0000BE4D                 db 0FFh
.xdata$x:0000BE4E                 db 0FFh
.xdata$x:0000BE4F                 db 0FFh
.xdata$x:0000BE50                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$37
.xdata$x:0000BE54                 dd offset off_20+3
.xdata$x:0000BE58                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$38
.xdata$x:0000BE5C                 db 0FFh
.xdata$x:0000BE5D                 db 0FFh
.xdata$x:0000BE5E                 db 0FFh
.xdata$x:0000BE5F                 db 0FFh
.xdata$x:0000BE60                 db    0
.xdata$x:0000BE61                 db    0
.xdata$x:0000BE62                 db    0
.xdata$x:0000BE63                 db    0
.xdata$x:0000BE64                 db  25h ; %
.xdata$x:0000BE65                 db    0
.xdata$x:0000BE66                 db    0
.xdata$x:0000BE67                 db    0
.xdata$x:0000BE68                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$39
.xdata$x:0000BE6C                 db 0FFh
.xdata$x:0000BE6D                 db 0FFh
.xdata$x:0000BE6E                 db 0FFh
.xdata$x:0000BE6F                 db 0FFh
.xdata$x:0000BE70                 db    0
.xdata$x:0000BE71                 db    0
.xdata$x:0000BE72                 db    0
.xdata$x:0000BE73                 db    0
.xdata$x:0000BE74                 db 0FFh
.xdata$x:0000BE75                 db 0FFh
.xdata$x:0000BE76                 db 0FFh
.xdata$x:0000BE77                 db 0FFh
.xdata$x:0000BE78                 dd offset __unwindfunclet$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z$40
.xdata$x:0000BE78 _xdata$x        ends
.xdata$x:0000BE78
.xdata$x:0000BE7C ; ===========================================================================
.xdata$x:0000BE7C
.xdata$x:0000BE7C ; Segment type: Pure data
.xdata$x:0000BE7C ; Segment permissions: Read
.xdata$x:0000BE7C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BE7C                 assume cs:_xdata$x
.xdata$x:0000BE7C                 ;org 0BE7Ch
.xdata$x:0000BE7C ; COMDAT (pick associative to section at 5ECC)
.xdata$x:0000BE7C __unwindtable$??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000BE7C                                         ; DATA XREF: .xdata$x:0000BE8Co
.xdata$x:0000BE7D                 db 0FFh
.xdata$x:0000BE7E                 db 0FFh
.xdata$x:0000BE7F                 db 0FFh
.xdata$x:0000BE80                 dd offset __unwindfunclet$??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ$0
.xdata$x:0000BE84 __ehfuncinfo$??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000BE84                                         ; DATA XREF: __ehhandler$??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ+11o
.xdata$x:0000BE85                 db    5
.xdata$x:0000BE86                 db  93h ; ô
.xdata$x:0000BE87                 db  19h
.xdata$x:0000BE88                 db    1
.xdata$x:0000BE89                 db    0
.xdata$x:0000BE8A                 db    0
.xdata$x:0000BE8B                 db    0
.xdata$x:0000BE8C                 dd offset __unwindtable$??0?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ
.xdata$x:0000BE90                 db    0
.xdata$x:0000BE91                 db    0
.xdata$x:0000BE92                 db    0
.xdata$x:0000BE93                 db    0
.xdata$x:0000BE94                 db    0
.xdata$x:0000BE95                 db    0
.xdata$x:0000BE96                 db    0
.xdata$x:0000BE97                 db    0
.xdata$x:0000BE98                 db    0
.xdata$x:0000BE99                 db    0
.xdata$x:0000BE9A                 db    0
.xdata$x:0000BE9B                 db    0
.xdata$x:0000BE9C                 db    0
.xdata$x:0000BE9D                 db    0
.xdata$x:0000BE9E                 db    0
.xdata$x:0000BE9F                 db    0
.xdata$x:0000BEA0                 db    0
.xdata$x:0000BEA1                 db    0
.xdata$x:0000BEA2                 db    0
.xdata$x:0000BEA3                 db    0
.xdata$x:0000BEA4                 db    0
.xdata$x:0000BEA5                 db    0
.xdata$x:0000BEA6                 db    0
.xdata$x:0000BEA7                 db    0
.xdata$x:0000BEA7 _xdata$x        ends
.xdata$x:0000BEA7
.xdata$x:0000BEA8 ; ===========================================================================
.xdata$x:0000BEA8
.xdata$x:0000BEA8 ; Segment type: Pure data
.xdata$x:0000BEA8 ; Segment permissions: Read
.xdata$x:0000BEA8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BEA8                 assume cs:_xdata$x
.xdata$x:0000BEA8                 ;org 0BEA8h
.xdata$x:0000BEA8 ; COMDAT (pick associative to section at 6D3C)
.xdata$x:0000BEA8 __unwindtable$??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000BEA8                                         ; DATA XREF: .xdata$x:0000BEB8o
.xdata$x:0000BEA9                 db 0FFh
.xdata$x:0000BEAA                 db 0FFh
.xdata$x:0000BEAB                 db 0FFh
.xdata$x:0000BEAC                 dd offset __unwindfunclet$??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ$0
.xdata$x:0000BEB0 __ehfuncinfo$??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000BEB0                                         ; DATA XREF: __ehhandler$??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ+11o
.xdata$x:0000BEB1                 db    5
.xdata$x:0000BEB2                 db  93h ; ô
.xdata$x:0000BEB3                 db  19h
.xdata$x:0000BEB4                 db    1
.xdata$x:0000BEB5                 db    0
.xdata$x:0000BEB6                 db    0
.xdata$x:0000BEB7                 db    0
.xdata$x:0000BEB8                 dd offset __unwindtable$??1?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@QAE@XZ
.xdata$x:0000BEBC                 db    0
.xdata$x:0000BEBD                 db    0
.xdata$x:0000BEBE                 db    0
.xdata$x:0000BEBF                 db    0
.xdata$x:0000BEC0                 db    0
.xdata$x:0000BEC1                 db    0
.xdata$x:0000BEC2                 db    0
.xdata$x:0000BEC3                 db    0
.xdata$x:0000BEC4                 db    0
.xdata$x:0000BEC5                 db    0
.xdata$x:0000BEC6                 db    0
.xdata$x:0000BEC7                 db    0
.xdata$x:0000BEC8                 db    0
.xdata$x:0000BEC9                 db    0
.xdata$x:0000BECA                 db    0
.xdata$x:0000BECB                 db    0
.xdata$x:0000BECC                 db    0
.xdata$x:0000BECD                 db    0
.xdata$x:0000BECE                 db    0
.xdata$x:0000BECF                 db    0
.xdata$x:0000BED0                 db    0
.xdata$x:0000BED1                 db    0
.xdata$x:0000BED2                 db    0
.xdata$x:0000BED3                 db    0
.xdata$x:0000BED3 _xdata$x        ends
.xdata$x:0000BED3
.xdata$x:0000BED4 ; ===========================================================================
.xdata$x:0000BED4
.xdata$x:0000BED4 ; Segment type: Pure data
.xdata$x:0000BED4 ; Segment permissions: Read
.xdata$x:0000BED4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BED4                 assume cs:_xdata$x
.xdata$x:0000BED4                 ;org 0BED4h
.xdata$x:0000BED4 ; COMDAT (pick associative to section at 5C4C)
.xdata$x:0000BED4 __unwindtable$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z db 0FFh
.xdata$x:0000BED4                                         ; DATA XREF: .xdata$x:0000BEE4o
.xdata$x:0000BED5                 db 0FFh
.xdata$x:0000BED6                 db 0FFh
.xdata$x:0000BED7                 db 0FFh
.xdata$x:0000BED8                 dd offset __unwindfunclet$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z$0
.xdata$x:0000BEDC __ehfuncinfo$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z db  22h ; "
.xdata$x:0000BEDC                                         ; DATA XREF: __ehhandler$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z+11o
.xdata$x:0000BEDD                 db    5
.xdata$x:0000BEDE                 db  93h ; ô
.xdata$x:0000BEDF                 db  19h
.xdata$x:0000BEE0                 db    1
.xdata$x:0000BEE1                 db    0
.xdata$x:0000BEE2                 db    0
.xdata$x:0000BEE3                 db    0
.xdata$x:0000BEE4                 dd offset __unwindtable$??0?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@ABV?$allocator@I@1@@Z
.xdata$x:0000BEE8                 align 20h
.xdata$x:0000BEE8 _xdata$x        ends
.xdata$x:0000BEE8
.xdata$x:0000BF00 ; ===========================================================================
.xdata$x:0000BF00
.xdata$x:0000BF00 ; Segment type: Pure data
.xdata$x:0000BF00 ; Segment permissions: Read
.xdata$x:0000BF00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BF00                 assume cs:_xdata$x
.xdata$x:0000BF00                 ;org 0BF00h
.xdata$x:0000BF00 ; COMDAT (pick associative to section at 6BE4)
.xdata$x:0000BF00 __unwindtable$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000BF00                                         ; DATA XREF: .xdata$x:0000BF10o
.xdata$x:0000BF01                 db 0FFh
.xdata$x:0000BF02                 db 0FFh
.xdata$x:0000BF03                 db 0FFh
.xdata$x:0000BF04                 dd offset __unwindfunclet$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000BF08 __ehfuncinfo$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000BF08                                         ; DATA XREF: __ehhandler$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000BF09                 db    5
.xdata$x:0000BF0A                 db  93h ; ô
.xdata$x:0000BF0B                 db  19h
.xdata$x:0000BF0C                 db    1
.xdata$x:0000BF0D                 db    0
.xdata$x:0000BF0E                 db    0
.xdata$x:0000BF0F                 db    0
.xdata$x:0000BF10                 dd offset __unwindtable$??1?$_Deque_alloc@$0A@U?$_Deque_base_types@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.xdata$x:0000BF14                 db    0
.xdata$x:0000BF15                 db    0
.xdata$x:0000BF16                 db    0
.xdata$x:0000BF17                 db    0
.xdata$x:0000BF18                 db    0
.xdata$x:0000BF19                 db    0
.xdata$x:0000BF1A                 db    0
.xdata$x:0000BF1B                 db    0
.xdata$x:0000BF1C                 db    0
.xdata$x:0000BF1D                 db    0
.xdata$x:0000BF1E                 db    0
.xdata$x:0000BF1F                 db    0
.xdata$x:0000BF20                 db    0
.xdata$x:0000BF21                 db    0
.xdata$x:0000BF22                 db    0
.xdata$x:0000BF23                 db    0
.xdata$x:0000BF24                 db    0
.xdata$x:0000BF25                 db    0
.xdata$x:0000BF26                 db    0
.xdata$x:0000BF27                 db    0
.xdata$x:0000BF28                 db    0
.xdata$x:0000BF29                 db    0
.xdata$x:0000BF2A                 db    0
.xdata$x:0000BF2B                 db    0
.xdata$x:0000BF2B _xdata$x        ends
.xdata$x:0000BF2B
.xdata$x:0000BF2C ; ===========================================================================
.xdata$x:0000BF2C
.xdata$x:0000BF2C ; Segment type: Pure data
.xdata$x:0000BF2C ; Segment permissions: Read
.xdata$x:0000BF2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BF2C                 assume cs:_xdata$x
.xdata$x:0000BF2C                 ;org 0BF2Ch
.xdata$x:0000BF2C ; COMDAT (pick associative to section at 6690)
.xdata$x:0000BF2C __unwindtable$??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000BF2C                                         ; DATA XREF: .xdata$x:0000BF3Co
.xdata$x:0000BF2D                 db 0FFh
.xdata$x:0000BF2E                 db 0FFh
.xdata$x:0000BF2F                 db 0FFh
.xdata$x:0000BF30                 dd offset __unwindfunclet$??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ$0
.xdata$x:0000BF34 __ehfuncinfo$??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000BF34                                         ; DATA XREF: __ehhandler$??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ+11o
.xdata$x:0000BF35                 db    5
.xdata$x:0000BF36                 db  93h ; ô
.xdata$x:0000BF37                 db  19h
.xdata$x:0000BF38                 db    1
.xdata$x:0000BF39                 db    0
.xdata$x:0000BF3A                 db    0
.xdata$x:0000BF3B                 db    0
.xdata$x:0000BF3C                 dd offset __unwindtable$??0?$deque@IV?$allocator@I@std@@@std@@QAE@XZ
.xdata$x:0000BF40                 db    0
.xdata$x:0000BF41                 db    0
.xdata$x:0000BF42                 db    0
.xdata$x:0000BF43                 db    0
.xdata$x:0000BF44                 db    0
.xdata$x:0000BF45                 db    0
.xdata$x:0000BF46                 db    0
.xdata$x:0000BF47                 db    0
.xdata$x:0000BF48                 db    0
.xdata$x:0000BF49                 db    0
.xdata$x:0000BF4A                 db    0
.xdata$x:0000BF4B                 db    0
.xdata$x:0000BF4C                 db    0
.xdata$x:0000BF4D                 db    0
.xdata$x:0000BF4E                 db    0
.xdata$x:0000BF4F                 db    0
.xdata$x:0000BF50                 db    0
.xdata$x:0000BF51                 db    0
.xdata$x:0000BF52                 db    0
.xdata$x:0000BF53                 db    0
.xdata$x:0000BF54                 db    0
.xdata$x:0000BF55                 db    0
.xdata$x:0000BF56                 db    0
.xdata$x:0000BF57                 db    0
.xdata$x:0000BF57 _xdata$x        ends
.xdata$x:0000BF57
.xdata$x:0000BF58 ; ===========================================================================
.xdata$x:0000BF58
.xdata$x:0000BF58 ; Segment type: Pure data
.xdata$x:0000BF58 ; Segment permissions: Read
.xdata$x:0000BF58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BF58                 assume cs:_xdata$x
.xdata$x:0000BF58                 ;org 0BF58h
.xdata$x:0000BF58 ; COMDAT (pick associative to section at 715C)
.xdata$x:0000BF58 __unwindtable$??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000BF58                                         ; DATA XREF: .xdata$x:0000BF68o
.xdata$x:0000BF59                 db 0FFh
.xdata$x:0000BF5A                 db 0FFh
.xdata$x:0000BF5B                 db 0FFh
.xdata$x:0000BF5C                 dd offset __unwindfunclet$??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ$0
.xdata$x:0000BF60 __ehfuncinfo$??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000BF60                                         ; DATA XREF: __ehhandler$??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ+11o
.xdata$x:0000BF61                 db    5
.xdata$x:0000BF62                 db  93h ; ô
.xdata$x:0000BF63                 db  19h
.xdata$x:0000BF64                 db    1
.xdata$x:0000BF65                 db    0
.xdata$x:0000BF66                 db    0
.xdata$x:0000BF67                 db    0
.xdata$x:0000BF68                 dd offset __unwindtable$??1?$deque@IV?$allocator@I@std@@@std@@QAE@XZ
.xdata$x:0000BF6C                 db    0
.xdata$x:0000BF6D                 db    0
.xdata$x:0000BF6E                 db    0
.xdata$x:0000BF6F                 db    0
.xdata$x:0000BF70                 db    0
.xdata$x:0000BF71                 db    0
.xdata$x:0000BF72                 db    0
.xdata$x:0000BF73                 db    0
.xdata$x:0000BF74                 db    0
.xdata$x:0000BF75                 db    0
.xdata$x:0000BF76                 db    0
.xdata$x:0000BF77                 db    0
.xdata$x:0000BF78                 db    0
.xdata$x:0000BF79                 db    0
.xdata$x:0000BF7A                 db    0
.xdata$x:0000BF7B                 db    0
.xdata$x:0000BF7C                 db    0
.xdata$x:0000BF7D                 db    0
.xdata$x:0000BF7E                 db    0
.xdata$x:0000BF7F                 db    0
.xdata$x:0000BF80                 db    0
.xdata$x:0000BF81                 db    0
.xdata$x:0000BF82                 db    0
.xdata$x:0000BF83                 db    0
.xdata$x:0000BF83 _xdata$x        ends
.xdata$x:0000BF83
.xdata$x:0000BF84 ; ===========================================================================
.xdata$x:0000BF84
.xdata$x:0000BF84 ; Segment type: Pure data
.xdata$x:0000BF84 ; Segment permissions: Read
.xdata$x:0000BF84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BF84                 assume cs:_xdata$x
.xdata$x:0000BF84                 ;org 0BF84h
.xdata$x:0000BF84 ; COMDAT (pick associative to section at A280)
.xdata$x:0000BF84 __unwindtable$?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000BF84                                         ; DATA XREF: .xdata$x:0000BF94o
.xdata$x:0000BF85                 db 0FFh
.xdata$x:0000BF86                 db 0FFh
.xdata$x:0000BF87                 db 0FFh
.xdata$x:0000BF88                 dd offset __unwindfunclet$?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ$0
.xdata$x:0000BF8C __ehfuncinfo$?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000BF8C                                         ; DATA XREF: __ehhandler$?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ+11o
.xdata$x:0000BF8D                 db    5
.xdata$x:0000BF8E                 db  93h ; ô
.xdata$x:0000BF8F                 db  19h
.xdata$x:0000BF90                 db    1
.xdata$x:0000BF91                 db    0
.xdata$x:0000BF92                 db    0
.xdata$x:0000BF93                 db    0
.xdata$x:0000BF94                 dd offset __unwindtable$?end@?$deque@IV?$allocator@I@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@2@XZ
.xdata$x:0000BF98                 db    0
.xdata$x:0000BF99                 db    0
.xdata$x:0000BF9A                 db    0
.xdata$x:0000BF9B                 db    0
.xdata$x:0000BF9C                 db    0
.xdata$x:0000BF9D                 db    0
.xdata$x:0000BF9E                 db    0
.xdata$x:0000BF9F                 db    0
.xdata$x:0000BFA0                 db    0
.xdata$x:0000BFA1                 db    0
.xdata$x:0000BFA2                 db    0
.xdata$x:0000BFA3                 db    0
.xdata$x:0000BFA4                 db    0
.xdata$x:0000BFA5                 db    0
.xdata$x:0000BFA6                 db    0
.xdata$x:0000BFA7                 db    0
.xdata$x:0000BFA8                 db    0
.xdata$x:0000BFA9                 db    0
.xdata$x:0000BFAA                 db    0
.xdata$x:0000BFAB                 db    0
.xdata$x:0000BFAC                 db    0
.xdata$x:0000BFAD                 db    0
.xdata$x:0000BFAE                 db    0
.xdata$x:0000BFAF                 db    0
.xdata$x:0000BFAF _xdata$x        ends
.xdata$x:0000BFAF
.xdata$x:0000BFB0 ; ===========================================================================
.xdata$x:0000BFB0
.xdata$x:0000BFB0 ; Segment type: Pure data
.xdata$x:0000BFB0 ; Segment permissions: Read
.xdata$x:0000BFB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BFB0                 assume cs:_xdata$x
.xdata$x:0000BFB0                 ;org 0BFB0h
.xdata$x:0000BFB0 ; COMDAT (pick associative to section at 9B9C)
.xdata$x:0000BFB0 __unwindtable$?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ db 0FFh
.xdata$x:0000BFB0                                         ; DATA XREF: .xdata$x:0000BFC8o
.xdata$x:0000BFB1                 db 0FFh
.xdata$x:0000BFB2                 db 0FFh
.xdata$x:0000BFB3                 db 0FFh
.xdata$x:0000BFB4                 dd offset __unwindfunclet$?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ$0
.xdata$x:0000BFB8                 db    0
.xdata$x:0000BFB9                 db    0
.xdata$x:0000BFBA                 db    0
.xdata$x:0000BFBB                 db    0
.xdata$x:0000BFBC                 dd offset __unwindfunclet$?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ$1
.xdata$x:0000BFC0 __ehfuncinfo$?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ db  22h ; "
.xdata$x:0000BFC0                                         ; DATA XREF: __ehhandler$?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ+11o
.xdata$x:0000BFC1                 db    5
.xdata$x:0000BFC2                 db  93h ; ô
.xdata$x:0000BFC3                 db  19h
.xdata$x:0000BFC4                 db    2
.xdata$x:0000BFC5                 db    0
.xdata$x:0000BFC6                 db    0
.xdata$x:0000BFC7                 db    0
.xdata$x:0000BFC8                 dd offset __unwindtable$?back@?$deque@IV?$allocator@I@std@@@std@@QAEAAIXZ
.xdata$x:0000BFCC                 db    0
.xdata$x:0000BFCD                 db    0
.xdata$x:0000BFCE                 db    0
.xdata$x:0000BFCF                 db    0
.xdata$x:0000BFD0                 db    0
.xdata$x:0000BFD1                 db    0
.xdata$x:0000BFD2                 db    0
.xdata$x:0000BFD3                 db    0
.xdata$x:0000BFD4                 db    0
.xdata$x:0000BFD5                 db    0
.xdata$x:0000BFD6                 db    0
.xdata$x:0000BFD7                 db    0
.xdata$x:0000BFD8                 db    0
.xdata$x:0000BFD9                 db    0
.xdata$x:0000BFDA                 db    0
.xdata$x:0000BFDB                 db    0
.xdata$x:0000BFDC                 db    0
.xdata$x:0000BFDD                 db    0
.xdata$x:0000BFDE                 db    0
.xdata$x:0000BFDF                 db    0
.xdata$x:0000BFE0                 db    0
.xdata$x:0000BFE1                 db    0
.xdata$x:0000BFE2                 db    0
.xdata$x:0000BFE3                 db    0
.xdata$x:0000BFE3 _xdata$x        ends
.xdata$x:0000BFE3
.xdata$x:0000BFE4 ; ===========================================================================
.xdata$x:0000BFE4
.xdata$x:0000BFE4 ; Segment type: Pure data
.xdata$x:0000BFE4 ; Segment permissions: Read
.xdata$x:0000BFE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000BFE4                 assume cs:_xdata$x
.xdata$x:0000BFE4                 ;org 0BFE4h
.xdata$x:0000BFE4 ; COMDAT (pick associative to section at 8AFC)
.xdata$x:0000BFE4 __unwindtable$?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z db 0FFh
.xdata$x:0000BFE4                                         ; DATA XREF: .xdata$x:0000BFF4o
.xdata$x:0000BFE5                 db 0FFh
.xdata$x:0000BFE6                 db 0FFh
.xdata$x:0000BFE7                 db 0FFh
.xdata$x:0000BFE8                 dd offset __unwindfunclet$?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z$0
.xdata$x:0000BFEC __ehfuncinfo$?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z db  22h ; "
.xdata$x:0000BFEC                                         ; DATA XREF: __ehhandler$?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z+11o
.xdata$x:0000BFED                 db    5
.xdata$x:0000BFEE                 db  93h ; ô
.xdata$x:0000BFEF                 db  19h
.xdata$x:0000BFF0                 db    1
.xdata$x:0000BFF1                 db    0
.xdata$x:0000BFF2                 db    0
.xdata$x:0000BFF3                 db    0
.xdata$x:0000BFF4                 dd offset __unwindtable$?_Orphan_off@?$deque@IV?$allocator@I@std@@@std@@IBEXI@Z
.xdata$x:0000BFF8                 db    0
.xdata$x:0000BFF9                 db    0
.xdata$x:0000BFFA                 db    0
.xdata$x:0000BFFB                 db    0
.xdata$x:0000BFFC                 db    0
.xdata$x:0000BFFD                 db    0
.xdata$x:0000BFFE                 db    0
.xdata$x:0000BFFF                 db    0
.xdata$x:0000C000                 db    0
.xdata$x:0000C001                 db    0
.xdata$x:0000C002                 db    0
.xdata$x:0000C003                 db    0
.xdata$x:0000C004                 db    0
.xdata$x:0000C005                 db    0
.xdata$x:0000C006                 db    0
.xdata$x:0000C007                 db    0
.xdata$x:0000C008                 db    0
.xdata$x:0000C009                 db    0
.xdata$x:0000C00A                 db    0
.xdata$x:0000C00B                 db    0
.xdata$x:0000C00C                 db    0
.xdata$x:0000C00D                 db    0
.xdata$x:0000C00E                 db    0
.xdata$x:0000C00F                 db    0
.xdata$x:0000C00F _xdata$x        ends
.xdata$x:0000C00F
.xdata$x:0000C010 ; ===========================================================================
.xdata$x:0000C010
.xdata$x:0000C010 ; Segment type: Pure data
.xdata$x:0000C010 ; Segment permissions: Read
.xdata$x:0000C010 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C010                 assume cs:_xdata$x
.xdata$x:0000C010                 ;org 0C010h
.xdata$x:0000C010 ; COMDAT (pick associative to section at 6710)
.xdata$x:0000C010 __unwindtable$??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C010                                         ; DATA XREF: .xdata$x:0000C020o
.xdata$x:0000C011                 db 0FFh
.xdata$x:0000C012                 db 0FFh
.xdata$x:0000C013                 db 0FFh
.xdata$x:0000C014                 dd offset __unwindfunclet$??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000C018 __ehfuncinfo$??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C018                                         ; DATA XREF: __ehhandler$??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000C019                 db    5
.xdata$x:0000C01A                 db  93h ; ô
.xdata$x:0000C01B                 db  19h
.xdata$x:0000C01C                 db    1
.xdata$x:0000C01D                 db    0
.xdata$x:0000C01E                 db    0
.xdata$x:0000C01F                 db    0
.xdata$x:0000C020                 dd offset __unwindtable$??0?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.xdata$x:0000C024                 db    0
.xdata$x:0000C025                 db    0
.xdata$x:0000C026                 db    0
.xdata$x:0000C027                 db    0
.xdata$x:0000C028                 db    0
.xdata$x:0000C029                 db    0
.xdata$x:0000C02A                 db    0
.xdata$x:0000C02B                 db    0
.xdata$x:0000C02C                 db    0
.xdata$x:0000C02D                 db    0
.xdata$x:0000C02E                 db    0
.xdata$x:0000C02F                 db    0
.xdata$x:0000C030                 db    0
.xdata$x:0000C031                 db    0
.xdata$x:0000C032                 db    0
.xdata$x:0000C033                 db    0
.xdata$x:0000C034                 db    0
.xdata$x:0000C035                 db    0
.xdata$x:0000C036                 db    0
.xdata$x:0000C037                 db    0
.xdata$x:0000C038                 db    0
.xdata$x:0000C039                 db    0
.xdata$x:0000C03A                 db    0
.xdata$x:0000C03B                 db    0
.xdata$x:0000C03B _xdata$x        ends
.xdata$x:0000C03B
.xdata$x:0000C03C ; ===========================================================================
.xdata$x:0000C03C
.xdata$x:0000C03C ; Segment type: Pure data
.xdata$x:0000C03C ; Segment permissions: Read
.xdata$x:0000C03C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C03C                 assume cs:_xdata$x
.xdata$x:0000C03C                 ;org 0C03Ch
.xdata$x:0000C03C ; COMDAT (pick associative to section at 71D4)
.xdata$x:0000C03C __unwindtable$??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C03C                                         ; DATA XREF: .xdata$x:0000C04Co
.xdata$x:0000C03D                 db 0FFh
.xdata$x:0000C03E                 db 0FFh
.xdata$x:0000C03F                 db 0FFh
.xdata$x:0000C040                 dd offset __unwindfunclet$??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000C044 __ehfuncinfo$??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C044                                         ; DATA XREF: __ehhandler$??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000C045                 db    5
.xdata$x:0000C046                 db  93h ; ô
.xdata$x:0000C047                 db  19h
.xdata$x:0000C048                 db    1
.xdata$x:0000C049                 db    0
.xdata$x:0000C04A                 db    0
.xdata$x:0000C04B                 db    0
.xdata$x:0000C04C                 dd offset __unwindtable$??1?$stack@IV?$deque@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
.xdata$x:0000C050                 db    0
.xdata$x:0000C051                 db    0
.xdata$x:0000C052                 db    0
.xdata$x:0000C053                 db    0
.xdata$x:0000C054                 db    0
.xdata$x:0000C055                 db    0
.xdata$x:0000C056                 db    0
.xdata$x:0000C057                 db    0
.xdata$x:0000C058                 db    0
.xdata$x:0000C059                 db    0
.xdata$x:0000C05A                 db    0
.xdata$x:0000C05B                 db    0
.xdata$x:0000C05C                 db    0
.xdata$x:0000C05D                 db    0
.xdata$x:0000C05E                 db    0
.xdata$x:0000C05F                 db    0
.xdata$x:0000C060                 db    0
.xdata$x:0000C061                 db    0
.xdata$x:0000C062                 db    0
.xdata$x:0000C063                 db    0
.xdata$x:0000C064                 db    0
.xdata$x:0000C065                 db    0
.xdata$x:0000C066                 db    0
.xdata$x:0000C067                 db    0
.xdata$x:0000C067 _xdata$x        ends
.xdata$x:0000C067
.xdata$x:0000C068 ; ===========================================================================
.xdata$x:0000C068
.xdata$x:0000C068 ; Segment type: Pure data
.xdata$x:0000C068 ; Segment permissions: Read
.xdata$x:0000C068 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C068                 assume cs:_xdata$x
.xdata$x:0000C068                 ;org 0C068h
.xdata$x:0000C068 ; COMDAT (pick associative to section at 5D4C)
.xdata$x:0000C068 __unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000C068                                         ; DATA XREF: .xdata$x:0000C078o
.xdata$x:0000C069                 db 0FFh
.xdata$x:0000C06A                 db 0FFh
.xdata$x:0000C06B                 db 0FFh
.xdata$x:0000C06C                 dd offset __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0
.xdata$x:0000C070 __ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000C070                                         ; DATA XREF: __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z+11o
.xdata$x:0000C071                 db    5
.xdata$x:0000C072                 db  93h ; ô
.xdata$x:0000C073                 db  19h
.xdata$x:0000C074                 db    1
.xdata$x:0000C075                 db    0
.xdata$x:0000C076                 db    0
.xdata$x:0000C077                 db    0
.xdata$x:0000C078                 dd offset __unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.xdata$x:0000C07C                 db    0
.xdata$x:0000C07D                 db    0
.xdata$x:0000C07E                 db    0
.xdata$x:0000C07F                 db    0
.xdata$x:0000C080                 db    0
.xdata$x:0000C081                 db    0
.xdata$x:0000C082                 db    0
.xdata$x:0000C083                 db    0
.xdata$x:0000C084                 db    0
.xdata$x:0000C085                 db    0
.xdata$x:0000C086                 db    0
.xdata$x:0000C087                 db    0
.xdata$x:0000C088                 db    0
.xdata$x:0000C089                 db    0
.xdata$x:0000C08A                 db    0
.xdata$x:0000C08B                 db    0
.xdata$x:0000C08C                 db    0
.xdata$x:0000C08D                 db    0
.xdata$x:0000C08E                 db    0
.xdata$x:0000C08F                 db    0
.xdata$x:0000C090                 db    0
.xdata$x:0000C091                 db    0
.xdata$x:0000C092                 db    0
.xdata$x:0000C093                 db    0
.xdata$x:0000C093 _xdata$x        ends
.xdata$x:0000C093
.xdata$x:0000C094 ; ===========================================================================
.xdata$x:0000C094
.xdata$x:0000C094 ; Segment type: Pure data
.xdata$x:0000C094 ; Segment permissions: Read
.xdata$x:0000C094 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C094                 assume cs:_xdata$x
.xdata$x:0000C094                 ;org 0C094h
.xdata$x:0000C094 ; COMDAT (pick associative to section at 6C5C)
.xdata$x:0000C094 __unwindtable$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C094                                         ; DATA XREF: .xdata$x:0000C0A4o
.xdata$x:0000C095                 db 0FFh
.xdata$x:0000C096                 db 0FFh
.xdata$x:0000C097                 db 0FFh
.xdata$x:0000C098                 dd offset __unwindfunclet$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000C09C __ehfuncinfo$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C09C                                         ; DATA XREF: __ehhandler$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000C09D                 db    5
.xdata$x:0000C09E                 db  93h ; ô
.xdata$x:0000C09F                 db  19h
.xdata$x:0000C0A0                 db    1
.xdata$x:0000C0A1                 db    0
.xdata$x:0000C0A2                 db    0
.xdata$x:0000C0A3                 db    0
.xdata$x:0000C0A4                 dd offset __unwindtable$??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ
.xdata$x:0000C0A8                 align 20h
.xdata$x:0000C0A8 _xdata$x        ends
.xdata$x:0000C0A8
.xdata$x:0000C0C0 ; ===========================================================================
.xdata$x:0000C0C0
.xdata$x:0000C0C0 ; Segment type: Pure data
.xdata$x:0000C0C0 ; Segment permissions: Read
.xdata$x:0000C0C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C0C0                 assume cs:_xdata$x
.xdata$x:0000C0C0                 ;org 0C0C0h
.xdata$x:0000C0C0 ; COMDAT (pick associative to section at 5CC8)
.xdata$x:0000C0C0 __unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000C0C0                                         ; DATA XREF: .xdata$x:0000C0D0o
.xdata$x:0000C0C1                 db 0FFh
.xdata$x:0000C0C2                 db 0FFh
.xdata$x:0000C0C3                 db 0FFh
.xdata$x:0000C0C4                 dd offset __unwindfunclet$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000C0C8 __ehfuncinfo$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000C0C8                                         ; DATA XREF: __ehhandler$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000C0C9                 db    5
.xdata$x:0000C0CA                 db  93h ; ô
.xdata$x:0000C0CB                 db  19h
.xdata$x:0000C0CC                 db    1
.xdata$x:0000C0CD                 db    0
.xdata$x:0000C0CE                 db    0
.xdata$x:0000C0CF                 db    0
.xdata$x:0000C0D0                 dd offset __unwindtable$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000C0D4                 db    0
.xdata$x:0000C0D5                 db    0
.xdata$x:0000C0D6                 db    0
.xdata$x:0000C0D7                 db    0
.xdata$x:0000C0D8                 db    0
.xdata$x:0000C0D9                 db    0
.xdata$x:0000C0DA                 db    0
.xdata$x:0000C0DB                 db    0
.xdata$x:0000C0DC                 db    0
.xdata$x:0000C0DD                 db    0
.xdata$x:0000C0DE                 db    0
.xdata$x:0000C0DF                 db    0
.xdata$x:0000C0E0                 db    0
.xdata$x:0000C0E1                 db    0
.xdata$x:0000C0E2                 db    0
.xdata$x:0000C0E3                 db    0
.xdata$x:0000C0E4                 db    0
.xdata$x:0000C0E5                 db    0
.xdata$x:0000C0E6                 db    0
.xdata$x:0000C0E7                 db    0
.xdata$x:0000C0E8                 db    0
.xdata$x:0000C0E9                 db    0
.xdata$x:0000C0EA                 db    0
.xdata$x:0000C0EB                 db    0
.xdata$x:0000C0EB _xdata$x        ends
.xdata$x:0000C0EB
.xdata$x:0000C0EC ; ===========================================================================
.xdata$x:0000C0EC
.xdata$x:0000C0EC ; Segment type: Pure data
.xdata$x:0000C0EC ; Segment permissions: Read
.xdata$x:0000C0EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C0EC                 assume cs:_xdata$x
.xdata$x:0000C0EC                 ;org 0C0ECh
.xdata$x:0000C0EC ; COMDAT (pick associative to section at 5E50)
.xdata$x:0000C0EC __unwindtable$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z db 0FFh
.xdata$x:0000C0EC                                         ; DATA XREF: .xdata$x:0000C0FCo
.xdata$x:0000C0ED                 db 0FFh
.xdata$x:0000C0EE                 db 0FFh
.xdata$x:0000C0EF                 db 0FFh
.xdata$x:0000C0F0                 dd offset __unwindfunclet$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z$0
.xdata$x:0000C0F4 __ehfuncinfo$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:0000C0F4                                         ; DATA XREF: __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z+11o
.xdata$x:0000C0F5                 db    5
.xdata$x:0000C0F6                 db  93h ; ô
.xdata$x:0000C0F7                 db  19h
.xdata$x:0000C0F8                 db    1
.xdata$x:0000C0F9                 db    0
.xdata$x:0000C0FA                 db    0
.xdata$x:0000C0FB                 db    0
.xdata$x:0000C0FC                 dd offset __unwindtable$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
.xdata$x:0000C100                 db    0
.xdata$x:0000C101                 db    0
.xdata$x:0000C102                 db    0
.xdata$x:0000C103                 db    0
.xdata$x:0000C104                 db    0
.xdata$x:0000C105                 db    0
.xdata$x:0000C106                 db    0
.xdata$x:0000C107                 db    0
.xdata$x:0000C108                 db    0
.xdata$x:0000C109                 db    0
.xdata$x:0000C10A                 db    0
.xdata$x:0000C10B                 db    0
.xdata$x:0000C10C                 db    0
.xdata$x:0000C10D                 db    0
.xdata$x:0000C10E                 db    0
.xdata$x:0000C10F                 db    0
.xdata$x:0000C110                 db    0
.xdata$x:0000C111                 db    0
.xdata$x:0000C112                 db    0
.xdata$x:0000C113                 db    0
.xdata$x:0000C114                 db    0
.xdata$x:0000C115                 db    0
.xdata$x:0000C116                 db    0
.xdata$x:0000C117                 db    0
.xdata$x:0000C117 _xdata$x        ends
.xdata$x:0000C117
.xdata$x:0000C118 ; ===========================================================================
.xdata$x:0000C118
.xdata$x:0000C118 ; Segment type: Pure data
.xdata$x:0000C118 ; Segment permissions: Read
.xdata$x:0000C118 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C118                 assume cs:_xdata$x
.xdata$x:0000C118                 ;org 0C118h
.xdata$x:0000C118 ; COMDAT (pick associative to section at 7838)
.xdata$x:0000C118 __unwindtable$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:0000C118                                         ; DATA XREF: .xdata$x:0000C130o
.xdata$x:0000C119                 db 0FFh
.xdata$x:0000C11A                 db 0FFh
.xdata$x:0000C11B                 db 0FFh
.xdata$x:0000C11C                 dd offset __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:0000C120                 db    0
.xdata$x:0000C121                 db    0
.xdata$x:0000C122                 db    0
.xdata$x:0000C123                 db    0
.xdata$x:0000C124                 dd offset __unwindfunclet$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:0000C128 __ehfuncinfo$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:0000C128                                         ; DATA XREF: __ehhandler$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:0000C129                 db    5
.xdata$x:0000C12A                 db  93h ; ô
.xdata$x:0000C12B                 db  19h
.xdata$x:0000C12C                 db    2
.xdata$x:0000C12D                 db    0
.xdata$x:0000C12E                 db    0
.xdata$x:0000C12F                 db    0
.xdata$x:0000C130                 dd offset __unwindtable$??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:0000C134                 db    0
.xdata$x:0000C135                 db    0
.xdata$x:0000C136                 db    0
.xdata$x:0000C137                 db    0
.xdata$x:0000C138                 db    0
.xdata$x:0000C139                 db    0
.xdata$x:0000C13A                 db    0
.xdata$x:0000C13B                 db    0
.xdata$x:0000C13C                 db    0
.xdata$x:0000C13D                 db    0
.xdata$x:0000C13E                 db    0
.xdata$x:0000C13F                 db    0
.xdata$x:0000C140                 db    0
.xdata$x:0000C141                 db    0
.xdata$x:0000C142                 db    0
.xdata$x:0000C143                 db    0
.xdata$x:0000C144                 db    0
.xdata$x:0000C145                 db    0
.xdata$x:0000C146                 db    0
.xdata$x:0000C147                 db    0
.xdata$x:0000C148                 db    0
.xdata$x:0000C149                 db    0
.xdata$x:0000C14A                 db    0
.xdata$x:0000C14B                 db    0
.xdata$x:0000C14B _xdata$x        ends
.xdata$x:0000C14B
.xdata$x:0000C14C ; ===========================================================================
.xdata$x:0000C14C
.xdata$x:0000C14C ; Segment type: Pure data
.xdata$x:0000C14C ; Segment permissions: Read
.xdata$x:0000C14C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C14C                 assume cs:_xdata$x
.xdata$x:0000C14C                 ;org 0C14Ch
.xdata$x:0000C14C ; COMDAT (pick associative to section at 6CCC)
.xdata$x:0000C14C __unwindtable$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000C14C                                         ; DATA XREF: .xdata$x:0000C15Co
.xdata$x:0000C14D                 db 0FFh
.xdata$x:0000C14E                 db 0FFh
.xdata$x:0000C14F                 db 0FFh
.xdata$x:0000C150                 dd offset __unwindfunclet$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000C154 __ehfuncinfo$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000C154                                         ; DATA XREF: __ehhandler$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000C155                 db    5
.xdata$x:0000C156                 db  93h ; ô
.xdata$x:0000C157                 db  19h
.xdata$x:0000C158                 db    1
.xdata$x:0000C159                 db    0
.xdata$x:0000C15A                 db    0
.xdata$x:0000C15B                 db    0
.xdata$x:0000C15C                 dd offset __unwindtable$??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@XZ
.xdata$x:0000C160                 db    0
.xdata$x:0000C161                 db    0
.xdata$x:0000C162                 db    0
.xdata$x:0000C163                 db    0
.xdata$x:0000C164                 db    0
.xdata$x:0000C165                 db    0
.xdata$x:0000C166                 db    0
.xdata$x:0000C167                 db    0
.xdata$x:0000C168                 db    0
.xdata$x:0000C169                 db    0
.xdata$x:0000C16A                 db    0
.xdata$x:0000C16B                 db    0
.xdata$x:0000C16C                 db    0
.xdata$x:0000C16D                 db    0
.xdata$x:0000C16E                 db    0
.xdata$x:0000C16F                 db    0
.xdata$x:0000C170                 db    0
.xdata$x:0000C171                 db    0
.xdata$x:0000C172                 db    0
.xdata$x:0000C173                 db    0
.xdata$x:0000C174                 db    0
.xdata$x:0000C175                 db    0
.xdata$x:0000C176                 db    0
.xdata$x:0000C177                 db    0
.xdata$x:0000C177 _xdata$x        ends
.xdata$x:0000C177
.xdata$x:0000C178 ; ===========================================================================
.xdata$x:0000C178
.xdata$x:0000C178 ; Segment type: Pure data
.xdata$x:0000C178 ; Segment permissions: Read
.xdata$x:0000C178 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C178                 assume cs:_xdata$x
.xdata$x:0000C178                 ;org 0C178h
.xdata$x:0000C178 ; COMDAT (pick associative to section at 5DD8)
.xdata$x:0000C178 __unwindtable$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000C178                                         ; DATA XREF: .xdata$x:0000C188o
.xdata$x:0000C179                 db 0FFh
.xdata$x:0000C17A                 db 0FFh
.xdata$x:0000C17B                 db 0FFh
.xdata$x:0000C17C                 dd offset __unwindfunclet$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:0000C180 __ehfuncinfo$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:0000C180                                         ; DATA XREF: __ehhandler$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:0000C181                 db    5
.xdata$x:0000C182                 db  93h ; ô
.xdata$x:0000C183                 db  19h
.xdata$x:0000C184                 db    1
.xdata$x:0000C185                 db    0
.xdata$x:0000C186                 db    0
.xdata$x:0000C187                 db    0
.xdata$x:0000C188                 dd offset __unwindtable$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000C18C                 db    0
.xdata$x:0000C18D                 db    0
.xdata$x:0000C18E                 db    0
.xdata$x:0000C18F                 db    0
.xdata$x:0000C190                 db    0
.xdata$x:0000C191                 db    0
.xdata$x:0000C192                 db    0
.xdata$x:0000C193                 db    0
.xdata$x:0000C194                 db    0
.xdata$x:0000C195                 db    0
.xdata$x:0000C196                 db    0
.xdata$x:0000C197                 db    0
.xdata$x:0000C198                 db    0
.xdata$x:0000C199                 db    0
.xdata$x:0000C19A                 db    0
.xdata$x:0000C19B                 db    0
.xdata$x:0000C19C                 db    0
.xdata$x:0000C19D                 db    0
.xdata$x:0000C19E                 db    0
.xdata$x:0000C19F                 db    0
.xdata$x:0000C1A0                 db    0
.xdata$x:0000C1A1                 db    0
.xdata$x:0000C1A2                 db    0
.xdata$x:0000C1A3                 db    0
.xdata$x:0000C1A3 _xdata$x        ends
.xdata$x:0000C1A3
.xdata$x:0000C1A4 ; ===========================================================================
.xdata$x:0000C1A4
.xdata$x:0000C1A4 ; Segment type: Pure data
.xdata$x:0000C1A4 ; Segment permissions: Read
.xdata$x:0000C1A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C1A4                 assume cs:_xdata$x
.xdata$x:0000C1A4                 ;org 0C1A4h
.xdata$x:0000C1A4 ; COMDAT (pick associative to section at 5858)
.xdata$x:0000C1A4 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:0000C1A4                                         ; DATA XREF: .xdata$x:0000C1B4o
.xdata$x:0000C1A5                 db 0FFh
.xdata$x:0000C1A6                 db 0FFh
.xdata$x:0000C1A7                 db 0FFh
.xdata$x:0000C1A8                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:0000C1AC __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:0000C1AC                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:0000C1AD                 db    5
.xdata$x:0000C1AE                 db  93h ; ô
.xdata$x:0000C1AF                 db  19h
.xdata$x:0000C1B0                 db    1
.xdata$x:0000C1B1                 db    0
.xdata$x:0000C1B2                 db    0
.xdata$x:0000C1B3                 db    0
.xdata$x:0000C1B4                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:0000C1B8                 db    0
.xdata$x:0000C1B9                 db    0
.xdata$x:0000C1BA                 db    0
.xdata$x:0000C1BB                 db    0
.xdata$x:0000C1BC                 db    0
.xdata$x:0000C1BD                 db    0
.xdata$x:0000C1BE                 db    0
.xdata$x:0000C1BF                 db    0
.xdata$x:0000C1C0                 db    0
.xdata$x:0000C1C1                 db    0
.xdata$x:0000C1C2                 db    0
.xdata$x:0000C1C3                 db    0
.xdata$x:0000C1C4                 db    0
.xdata$x:0000C1C5                 db    0
.xdata$x:0000C1C6                 db    0
.xdata$x:0000C1C7                 db    0
.xdata$x:0000C1C8                 db    0
.xdata$x:0000C1C9                 db    0
.xdata$x:0000C1CA                 db    0
.xdata$x:0000C1CB                 db    0
.xdata$x:0000C1CC                 db    0
.xdata$x:0000C1CD                 db    0
.xdata$x:0000C1CE                 db    0
.xdata$x:0000C1CF                 db    0
.xdata$x:0000C1CF _xdata$x        ends
.xdata$x:0000C1CF
.xdata$x:0000C1D0 ; ===========================================================================
.xdata$x:0000C1D0
.xdata$x:0000C1D0 ; Segment type: Pure data
.xdata$x:0000C1D0 ; Segment permissions: Read
.xdata$x:0000C1D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C1D0                 assume cs:_xdata$x
.xdata$x:0000C1D0                 ;org 0C1D0h
.xdata$x:0000C1D0 ; COMDAT (pick associative to section at 595C)
.xdata$x:0000C1D0 __unwindtable$??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z db 0FFh
.xdata$x:0000C1D0                                         ; DATA XREF: .xdata$x:0000C1E0o
.xdata$x:0000C1D1                 db 0FFh
.xdata$x:0000C1D2                 db 0FFh
.xdata$x:0000C1D3                 db 0FFh
.xdata$x:0000C1D4                 dd offset __unwindfunclet$??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z$0
.xdata$x:0000C1D8 __ehfuncinfo$??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z db  22h ; "
.xdata$x:0000C1D8                                         ; DATA XREF: __ehhandler$??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z+11o
.xdata$x:0000C1D9                 db    5
.xdata$x:0000C1DA                 db  93h ; ô
.xdata$x:0000C1DB                 db  19h
.xdata$x:0000C1DC                 db    1
.xdata$x:0000C1DD                 db    0
.xdata$x:0000C1DE                 db    0
.xdata$x:0000C1DF                 db    0
.xdata$x:0000C1E0                 dd offset __unwindtable$??$construct@UrecordedMacroStep@@U1@@?$allocator@UrecordedMacroStep@@@std@@QAEXPAUrecordedMacroStep@@$$QAU2@@Z
.xdata$x:0000C1E4                 db    0
.xdata$x:0000C1E5                 db    0
.xdata$x:0000C1E6                 db    0
.xdata$x:0000C1E7                 db    0
.xdata$x:0000C1E8                 db    0
.xdata$x:0000C1E9                 db    0
.xdata$x:0000C1EA                 db    0
.xdata$x:0000C1EB                 db    0
.xdata$x:0000C1EC                 db    0
.xdata$x:0000C1ED                 db    0
.xdata$x:0000C1EE                 db    0
.xdata$x:0000C1EF                 db    0
.xdata$x:0000C1F0                 db    0
.xdata$x:0000C1F1                 db    0
.xdata$x:0000C1F2                 db    0
.xdata$x:0000C1F3                 db    0
.xdata$x:0000C1F4                 db    0
.xdata$x:0000C1F5                 db    0
.xdata$x:0000C1F6                 db    0
.xdata$x:0000C1F7                 db    0
.xdata$x:0000C1F8                 db    0
.xdata$x:0000C1F9                 db    0
.xdata$x:0000C1FA                 db    0
.xdata$x:0000C1FB                 db    0
.xdata$x:0000C1FB _xdata$x        ends
.xdata$x:0000C1FB
.xdata$x:0000C1FC ; ===========================================================================
.xdata$x:0000C1FC
.xdata$x:0000C1FC ; Segment type: Pure data
.xdata$x:0000C1FC ; Segment permissions: Read
.xdata$x:0000C1FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C1FC                 assume cs:_xdata$x
.xdata$x:0000C1FC                 ;org 0C1FCh
.xdata$x:0000C1FC ; COMDAT (pick associative to section at 5758)
.xdata$x:0000C1FC __unwindtable$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z db 0FFh
.xdata$x:0000C1FC                                         ; DATA XREF: .xdata$x:0000C20Co
.xdata$x:0000C1FD                 db 0FFh
.xdata$x:0000C1FE                 db 0FFh
.xdata$x:0000C1FF                 db 0FFh
.xdata$x:0000C200                 dd offset __unwindfunclet$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z$0
.xdata$x:0000C204 __ehfuncinfo$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z db  22h ; "
.xdata$x:0000C204                                         ; DATA XREF: __ehhandler$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z+11o
.xdata$x:0000C205                 db    5
.xdata$x:0000C206                 db  93h ; ô
.xdata$x:0000C207                 db  19h
.xdata$x:0000C208                 db    1
.xdata$x:0000C209                 db    0
.xdata$x:0000C20A                 db    0
.xdata$x:0000C20B                 db    0
.xdata$x:0000C20C                 dd offset __unwindtable$??$construct@UMenuItemUnit@@U1@@?$allocator@UMenuItemUnit@@@std@@QAEXPAUMenuItemUnit@@$$QAU2@@Z
.xdata$x:0000C210                 db    0
.xdata$x:0000C211                 db    0
.xdata$x:0000C212                 db    0
.xdata$x:0000C213                 db    0
.xdata$x:0000C214                 db    0
.xdata$x:0000C215                 db    0
.xdata$x:0000C216                 db    0
.xdata$x:0000C217                 db    0
.xdata$x:0000C218                 db    0
.xdata$x:0000C219                 db    0
.xdata$x:0000C21A                 db    0
.xdata$x:0000C21B                 db    0
.xdata$x:0000C21C                 db    0
.xdata$x:0000C21D                 db    0
.xdata$x:0000C21E                 db    0
.xdata$x:0000C21F                 db    0
.xdata$x:0000C220                 db    0
.xdata$x:0000C221                 db    0
.xdata$x:0000C222                 db    0
.xdata$x:0000C223                 db    0
.xdata$x:0000C224                 db    0
.xdata$x:0000C225                 db    0
.xdata$x:0000C226                 db    0
.xdata$x:0000C227                 db    0
.xdata$x:0000C227 _xdata$x        ends
.xdata$x:0000C227
.xdata$x:0000C228 ; ===========================================================================
.xdata$x:0000C228
.xdata$x:0000C228 ; Segment type: Pure data
.xdata$x:0000C228 ; Segment permissions: Read
.xdata$x:0000C228 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C228                 assume cs:_xdata$x
.xdata$x:0000C228                 ;org 0C228h
.xdata$x:0000C228 ; COMDAT (pick associative to section at 5558)
.xdata$x:0000C228 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:0000C228                                         ; DATA XREF: .xdata$x:0000C238o
.xdata$x:0000C229                 db 0FFh
.xdata$x:0000C22A                 db 0FFh
.xdata$x:0000C22B                 db 0FFh
.xdata$x:0000C22C                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:0000C230 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:0000C230                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:0000C231                 db    5
.xdata$x:0000C232                 db  93h ; ô
.xdata$x:0000C233                 db  19h
.xdata$x:0000C234                 db    1
.xdata$x:0000C235                 db    0
.xdata$x:0000C236                 db    0
.xdata$x:0000C237                 db    0
.xdata$x:0000C238                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:0000C23C                 db    0
.xdata$x:0000C23D                 db    0
.xdata$x:0000C23E                 db    0
.xdata$x:0000C23F                 db    0
.xdata$x:0000C240                 db    0
.xdata$x:0000C241                 db    0
.xdata$x:0000C242                 db    0
.xdata$x:0000C243                 db    0
.xdata$x:0000C244                 db    0
.xdata$x:0000C245                 db    0
.xdata$x:0000C246                 db    0
.xdata$x:0000C247                 db    0
.xdata$x:0000C248                 db    0
.xdata$x:0000C249                 db    0
.xdata$x:0000C24A                 db    0
.xdata$x:0000C24B                 db    0
.xdata$x:0000C24C                 db    0
.xdata$x:0000C24D                 db    0
.xdata$x:0000C24E                 db    0
.xdata$x:0000C24F                 db    0
.xdata$x:0000C250                 db    0
.xdata$x:0000C251                 db    0
.xdata$x:0000C252                 db    0
.xdata$x:0000C253                 db    0
.xdata$x:0000C253 _xdata$x        ends
.xdata$x:0000C253
.xdata$x:0000C254 ; ===========================================================================
.xdata$x:0000C254
.xdata$x:0000C254 ; Segment type: Pure data
.xdata$x:0000C254 ; Segment permissions: Read
.xdata$x:0000C254 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C254                 assume cs:_xdata$x
.xdata$x:0000C254                 ;org 0C254h
.xdata$x:0000C254 ; COMDAT (pick associative to section at 5658)
.xdata$x:0000C254 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:0000C254                                         ; DATA XREF: .xdata$x:0000C264o
.xdata$x:0000C255                 db 0FFh
.xdata$x:0000C256                 db 0FFh
.xdata$x:0000C257                 db 0FFh
.xdata$x:0000C258                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:0000C25C __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:0000C25C                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:0000C25D                 db    5
.xdata$x:0000C25E                 db  93h ; ô
.xdata$x:0000C25F                 db  19h
.xdata$x:0000C260                 db    1
.xdata$x:0000C261                 db    0
.xdata$x:0000C262                 db    0
.xdata$x:0000C263                 db    0
.xdata$x:0000C264                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:0000C268                 align 20h
.xdata$x:0000C268 _xdata$x        ends
.xdata$x:0000C268
.xdata$x:0000C280 ; ===========================================================================
.xdata$x:0000C280
.xdata$x:0000C280 ; Segment type: Pure data
.xdata$x:0000C280 ; Segment permissions: Read
.xdata$x:0000C280 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C280                 assume cs:_xdata$x
.xdata$x:0000C280                 ;org 0C280h
.xdata$x:0000C280 ; COMDAT (pick associative to section at 5284)
.xdata$x:0000C280 __catchsym$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000C280                                         ; DATA XREF: .xdata$x:0000C2B0o
.xdata$x:0000C281                 db    0
.xdata$x:0000C282                 db    0
.xdata$x:0000C283                 db    0
.xdata$x:0000C284                 db    0
.xdata$x:0000C285                 db    0
.xdata$x:0000C286                 db    0
.xdata$x:0000C287                 db    0
.xdata$x:0000C288                 db    0
.xdata$x:0000C289                 db    0
.xdata$x:0000C28A                 db    0
.xdata$x:0000C28B                 db    0
.xdata$x:0000C28C                 dd offset __catch$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000C290 __unwindtable$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000C290                                         ; DATA XREF: .xdata$x:0000C2BCo
.xdata$x:0000C291                 db 0FFh
.xdata$x:0000C292                 db 0FFh
.xdata$x:0000C293                 db 0FFh
.xdata$x:0000C294                 db    0
.xdata$x:0000C295                 db    0
.xdata$x:0000C296                 db    0
.xdata$x:0000C297                 db    0
.xdata$x:0000C298                 db 0FFh
.xdata$x:0000C299                 db 0FFh
.xdata$x:0000C29A                 db 0FFh
.xdata$x:0000C29B                 db 0FFh
.xdata$x:0000C29C                 db    0
.xdata$x:0000C29D                 db    0
.xdata$x:0000C29E                 db    0
.xdata$x:0000C29F                 db    0
.xdata$x:0000C2A0 __tryblocktable$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000C2A0                                         ; DATA XREF: .xdata$x:0000C2C4o
.xdata$x:0000C2A1                 db    0
.xdata$x:0000C2A2                 db    0
.xdata$x:0000C2A3                 db    0
.xdata$x:0000C2A4                 db    0
.xdata$x:0000C2A5                 db    0
.xdata$x:0000C2A6                 db    0
.xdata$x:0000C2A7                 db    0
.xdata$x:0000C2A8                 db    1
.xdata$x:0000C2A9                 db    0
.xdata$x:0000C2AA                 db    0
.xdata$x:0000C2AB                 db    0
.xdata$x:0000C2AC                 db    1
.xdata$x:0000C2AD                 db    0
.xdata$x:0000C2AE                 db    0
.xdata$x:0000C2AF                 db    0
.xdata$x:0000C2B0                 dd offset __catchsym$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000C2B4 __ehfuncinfo$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000C2B4                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000C2B5                 db    5
.xdata$x:0000C2B6                 db  93h ; ô
.xdata$x:0000C2B7                 db  19h
.xdata$x:0000C2B8                 db    2
.xdata$x:0000C2B9                 db    0
.xdata$x:0000C2BA                 db    0
.xdata$x:0000C2BB                 db    0
.xdata$x:0000C2BC                 dd offset __unwindtable$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000C2C0                 db    1
.xdata$x:0000C2C1                 db    0
.xdata$x:0000C2C2                 db    0
.xdata$x:0000C2C3                 db    0
.xdata$x:0000C2C4                 dd offset __tryblocktable$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000C2C8                 db    0
.xdata$x:0000C2C9                 db    0
.xdata$x:0000C2CA                 db    0
.xdata$x:0000C2CB                 db    0
.xdata$x:0000C2CC                 db    0
.xdata$x:0000C2CD                 db    0
.xdata$x:0000C2CE                 db    0
.xdata$x:0000C2CF                 db    0
.xdata$x:0000C2D0                 db    0
.xdata$x:0000C2D1                 db    0
.xdata$x:0000C2D2                 db    0
.xdata$x:0000C2D3                 db    0
.xdata$x:0000C2D4                 db    0
.xdata$x:0000C2D5                 db    0
.xdata$x:0000C2D6                 db    0
.xdata$x:0000C2D7                 db    0
.xdata$x:0000C2D7 _xdata$x        ends
.xdata$x:0000C2D7
.xdata$x:0000C2D8 ; ===========================================================================
.xdata$x:0000C2D8
.xdata$x:0000C2D8 ; Segment type: Pure data
.xdata$x:0000C2D8 ; Segment permissions: Read
.xdata$x:0000C2D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000C2D8                 assume cs:_xdata$x
.xdata$x:0000C2D8                 ;org 0C2D8h
.xdata$x:0000C2D8 ; COMDAT (pick associative to section at 5134)
.xdata$x:0000C2D8 __catchsym$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:0000C2D8                                         ; DATA XREF: .xdata$x:0000C308o
.xdata$x:0000C2D9                 db    0
.xdata$x:0000C2DA                 db    0
.xdata$x:0000C2DB                 db    0
.xdata$x:0000C2DC                 db    0
.xdata$x:0000C2DD                 db    0
.xdata$x:0000C2DE                 db    0
.xdata$x:0000C2DF                 db    0
.xdata$x:0000C2E0                 db    0
.xdata$x:0000C2E1                 db    0
.xdata$x:0000C2E2                 db    0
.xdata$x:0000C2E3                 db    0
.xdata$x:0000C2E4                 dd offset __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000C2E8 __unwindtable$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000C2E8                                         ; DATA XREF: .xdata$x:0000C314o
.xdata$x:0000C2E9                 db 0FFh
.xdata$x:0000C2EA                 db 0FFh
.xdata$x:0000C2EB                 db 0FFh
.xdata$x:0000C2EC                 db    0
.xdata$x:0000C2ED                 db    0
.xdata$x:0000C2EE                 db    0
.xdata$x:0000C2EF                 db    0
.xdata$x:0000C2F0                 db 0FFh
.xdata$x:0000C2F1                 db 0FFh
.xdata$x:0000C2F2                 db 0FFh
.xdata$x:0000C2F3                 db 0FFh
.xdata$x:0000C2F4                 db    0
.xdata$x:0000C2F5                 db    0
.xdata$x:0000C2F6                 db    0
.xdata$x:0000C2F7                 db    0
.xdata$x:0000C2F8 __tryblocktable$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000C2F8                                         ; DATA XREF: .xdata$x:0000C31Co
.xdata$x:0000C2F9                 db    0
.xdata$x:0000C2FA                 db    0
.xdata$x:0000C2FB                 db    0
.xdata$x:0000C2FC                 db    0
.xdata$x:0000C2FD                 db    0
.xdata$x:0000C2FE                 db    0
.xdata$x:0000C2FF                 db    0
.xdata$x:0000C300                 db    1
.xdata$x:0000C301                 db    0
.xdata$x:0000C302                 db    0
.xdata$x:0000C303                 db    0
.xdata$x:0000C304                 db    1
.xdata$x:0000C305                 db    0
.xdata$x:0000C306                 db    0
.xdata$x:0000C307                 db    0
.xdata$x:0000C308                 dd offset __catchsym$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000C30C __ehfuncinfo$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000C30C                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000C30D                 db    5
.xdata$x:0000C30E                 db  93h ; ô
.xdata$x:0000C30F                 db  19h
.xdata$x:0000C310                 db    2
.xdata$x:0000C311                 db    0
.xdata$x:0000C312                 db    0
.xdata$x:0000C313                 db    0
.xdata$x:0000C314                 dd offset __unwindtable$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000C318                 db    1
.xdata$x:0000C319                 db    0
.xdata$x:0000C31A                 db    0
.xdata$x:0000C31B                 db    0
.xdata$x:0000C31C                 dd offset __tryblocktable$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000C320                 db    0
.xdata$x:0000C321                 db    0
.xdata$x:0000C322                 db    0
.xdata$x:0000C323                 db    0
.xdata$x:0000C324                 db    0
.xdata$x:0000C325                 db    0
.xdata$x:0000C326                 db    0
.xdata$x:0000C327                 db    0
.xdata$x:0000C328                 db    0
.xdata$x:0000C329                 db    0
.xdata$x:0000C32A                 db    0
.xdata$x:0000C32B                 db    0
.xdata$x:0000C32C                 db    0
.xdata$x:0000C32D                 db    0
.xdata$x:0000C32E                 db    0
.xdata$x:0000C32F                 db    0
.xdata$x:0000C32F _xdata$x        ends
.xdata$x:0000C32F
.rdata:0000C330 ; ===========================================================================
.rdata:0000C330
.rdata:0000C330 ; Segment type: Pure data
.rdata:0000C330 ; Segment permissions: Read
.rdata:0000C330 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000C330 _rdata          segment para public 'DATA' use32
.rdata:0000C330                 assume cs:_rdata
.rdata:0000C330                 ;org 0C330h
.rdata:0000C330 ; COMDAT (pick any)
.rdata:0000C330                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000C330 ; wchar_t `string'
.rdata:0000C330 ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000C330                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+48o
.rdata:0000C330                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000C330                 unicode 0, <clude\xutility>,0
.rdata:0000C330 _rdata          ends
.rdata:0000C330
.rdata:0000C3C0 ; ===========================================================================
.rdata:0000C3C0
.rdata:0000C3C0 ; Segment type: Pure data
.rdata:0000C3C0 ; Segment permissions: Read
.rdata:0000C3C0 _rdata          segment dword public 'DATA' use32
.rdata:0000C3C0                 assume cs:_rdata
.rdata:0000C3C0                 ;org 0C3C0h
.rdata:0000C3C0 ; COMDAT (pick any)
.rdata:0000C3C0                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:0000C3C0 ; wchar_t `string'
.rdata:0000C3C0 ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:0000C3C0                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:0000C3C0                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:0000C3F2                 align 4
.rdata:0000C3F2 _rdata          ends
.rdata:0000C3F2
.rdata:0000C3F4 ; ===========================================================================
.rdata:0000C3F4
.rdata:0000C3F4 ; Segment type: Pure data
.rdata:0000C3F4 ; Segment permissions: Read
.rdata:0000C3F4 _rdata          segment dword public 'DATA' use32
.rdata:0000C3F4                 assume cs:_rdata
.rdata:0000C3F4                 ;org 0C3F4h
.rdata:0000C3F4 ; COMDAT (pick largest)
.rdata:0000C3F4                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:0000C3F8                 public ??_7error_category@std@@6B@
.rdata:0000C3F8 ; const std::error_category::`vftable'
.rdata:0000C3F8 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:0000C3F8                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:0000C3F8                                         ; std::error_category::~error_category(void)+Ao
.rdata:0000C3F8                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:0000C3FC                 dd offset __purecall
.rdata:0000C400                 dd offset __purecall
.rdata:0000C404                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000C408                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000C40C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000C40C _rdata          ends
.rdata:0000C40C
.rdata:0000C410 ; ===========================================================================
.rdata:0000C410
.rdata:0000C410 ; Segment type: Pure data
.rdata:0000C410 ; Segment permissions: Read
.rdata:0000C410 _rdata          segment dword public 'DATA' use32
.rdata:0000C410                 assume cs:_rdata
.rdata:0000C410                 ;org 0C410h
.rdata:0000C410 ; COMDAT (pick largest)
.rdata:0000C410                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000C414                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000C414 ; const std::_Generic_error_category::`vftable'
.rdata:0000C414 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000C414                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000C414                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:0000C418                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:0000C41C                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:0000C420                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000C424                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000C428                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000C428 _rdata          ends
.rdata:0000C428
.rdata:0000C42C ; ===========================================================================
.rdata:0000C42C
.rdata:0000C42C ; Segment type: Pure data
.rdata:0000C42C ; Segment permissions: Read
.rdata:0000C42C _rdata          segment dword public 'DATA' use32
.rdata:0000C42C                 assume cs:_rdata
.rdata:0000C42C                 ;org 0C42Ch
.rdata:0000C42C ; COMDAT (pick any)
.rdata:0000C42C                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:0000C42C ; `string'
.rdata:0000C42C ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:0000C42C                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:0000C42C _rdata          ends
.rdata:0000C42C
.rdata:0000C434 ; ===========================================================================
.rdata:0000C434
.rdata:0000C434 ; Segment type: Pure data
.rdata:0000C434 ; Segment permissions: Read
.rdata:0000C434 _rdata          segment dword public 'DATA' use32
.rdata:0000C434                 assume cs:_rdata
.rdata:0000C434                 ;org 0C434h
.rdata:0000C434 ; COMDAT (pick any)
.rdata:0000C434                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000C434 ; `string'
.rdata:0000C434 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000C434                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_AB5Co
.rdata:0000C434                                         ; std::_System_error_category::message(int):loc_ACD8o
.rdata:0000C442                 align 4
.rdata:0000C442 _rdata          ends
.rdata:0000C442
.rdata:0000C444 ; ===========================================================================
.rdata:0000C444
.rdata:0000C444 ; Segment type: Pure data
.rdata:0000C444 ; Segment permissions: Read
.rdata:0000C444 _rdata          segment dword public 'DATA' use32
.rdata:0000C444                 assume cs:_rdata
.rdata:0000C444                 ;org 0C444h
.rdata:0000C444 ; COMDAT (pick largest)
.rdata:0000C444                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:0000C448                 public ??_7_Iostream_error_category@std@@6B@
.rdata:0000C448 ; const std::_Iostream_error_category::`vftable'
.rdata:0000C448 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:0000C448                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:0000C448                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:0000C44C                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:0000C450                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:0000C454                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000C458                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000C45C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000C45C _rdata          ends
.rdata:0000C45C
.rdata:0000C460 ; ===========================================================================
.rdata:0000C460
.rdata:0000C460 ; Segment type: Pure data
.rdata:0000C460 ; Segment permissions: Read
.rdata:0000C460 _rdata          segment dword public 'DATA' use32
.rdata:0000C460                 assume cs:_rdata
.rdata:0000C460                 ;org 0C460h
.rdata:0000C460 ; COMDAT (pick any)
.rdata:0000C460                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:0000C460 ; `string'
.rdata:0000C460 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:0000C460                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:0000C469                 align 4
.rdata:0000C469 _rdata          ends
.rdata:0000C469
.rdata:0000C46C ; ===========================================================================
.rdata:0000C46C
.rdata:0000C46C ; Segment type: Pure data
.rdata:0000C46C ; Segment permissions: Read
.rdata:0000C46C _rdata          segment dword public 'DATA' use32
.rdata:0000C46C                 assume cs:_rdata
.rdata:0000C46C                 ;org 0C46Ch
.rdata:0000C46C ; COMDAT (pick any)
.rdata:0000C46C                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:0000C46C ; char `string'[]
.rdata:0000C46C ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:0000C46C                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000C482                 align 4
.rdata:0000C482 _rdata          ends
.rdata:0000C482
.rdata:0000C484 ; ===========================================================================
.rdata:0000C484
.rdata:0000C484 ; Segment type: Pure data
.rdata:0000C484 ; Segment permissions: Read
.rdata:0000C484 _rdata          segment dword public 'DATA' use32
.rdata:0000C484                 assume cs:_rdata
.rdata:0000C484                 ;org 0C484h
.rdata:0000C484 ; COMDAT (pick largest)
.rdata:0000C484                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:0000C488                 public ??_7_System_error_category@std@@6B@
.rdata:0000C488 ; const std::_System_error_category::`vftable'
.rdata:0000C488 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:0000C488                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:0000C488                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:0000C48C                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:0000C490                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000C494                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:0000C498                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000C49C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000C49C _rdata          ends
.rdata:0000C49C
.rdata:0000C4A0 ; ===========================================================================
.rdata:0000C4A0
.rdata:0000C4A0 ; Segment type: Pure data
.rdata:0000C4A0 ; Segment permissions: Read
.rdata:0000C4A0 _rdata          segment dword public 'DATA' use32
.rdata:0000C4A0                 assume cs:_rdata
.rdata:0000C4A0                 ;org 0C4A0h
.rdata:0000C4A0 ; COMDAT (pick any)
.rdata:0000C4A0                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:0000C4A0 ; `string'
.rdata:0000C4A0 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:0000C4A0                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000C4A7                 align 4
.rdata:0000C4A7 _rdata          ends
.rdata:0000C4A7
.bss:0000C4A8 ; ===========================================================================
.bss:0000C4A8
.bss:0000C4A8 ; Segment type: Uninitialized
.bss:0000C4A8 ; Segment permissions: Read/Write
.bss:0000C4A8 _bss            segment dword public 'BSS' use32
.bss:0000C4A8                 assume cs:_bss
.bss:0000C4A8                 ;org 0C4A8h
.bss:0000C4A8 ; COMDAT (pick any)
.bss:0000C4A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000C4A8                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:0000C4A8 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:0000C4A8 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:0000C4A8                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:0000C4A8                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:0000C4A9                 db    ? ;
.bss:0000C4AA                 db    ? ;
.bss:0000C4AB                 db    ? ;
.bss:0000C4AB _bss            ends
.bss:0000C4AB
.bss:0000C4AC ; ===========================================================================
.bss:0000C4AC
.bss:0000C4AC ; Segment type: Uninitialized
.bss:0000C4AC ; Segment permissions: Read/Write
.bss:0000C4AC _bss            segment dword public 'BSS' use32
.bss:0000C4AC                 assume cs:_bss
.bss:0000C4AC                 ;org 0C4ACh
.bss:0000C4AC ; COMDAT (pick any)
.bss:0000C4AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000C4AC                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:0000C4AC ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:0000C4AC ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:0000C4AC                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000C4AC                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000C4AD                 db    ? ;
.bss:0000C4AE                 db    ? ;
.bss:0000C4AF                 db    ? ;
.bss:0000C4AF _bss            ends
.bss:0000C4AF
.bss:0000C4B0 ; ===========================================================================
.bss:0000C4B0
.bss:0000C4B0 ; Segment type: Uninitialized
.bss:0000C4B0 ; Segment permissions: Read/Write
.bss:0000C4B0 _bss            segment dword public 'BSS' use32
.bss:0000C4B0                 assume cs:_bss
.bss:0000C4B0                 ;org 0C4B0h
.bss:0000C4B0 ; COMDAT (pick any)
.bss:0000C4B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000C4B0                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:0000C4B0 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:0000C4B0 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:0000C4B0                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:0000C4B0                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:0000C4B1                 db    ? ;
.bss:0000C4B2                 db    ? ;
.bss:0000C4B3                 db    ? ;
.bss:0000C4B3 _bss            ends
.bss:0000C4B3
.rdata:0000C4B4 ; ===========================================================================
.rdata:0000C4B4
.rdata:0000C4B4 ; Segment type: Pure data
.rdata:0000C4B4 ; Segment permissions: Read
.rdata:0000C4B4 _rdata          segment dword public 'DATA' use32
.rdata:0000C4B4                 assume cs:_rdata
.rdata:0000C4B4                 ;org 0C4B4h
.rdata:0000C4B4 ; COMDAT (pick any)
.rdata:0000C4B4                 public ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
.rdata:0000C4B4 ; public: static unsigned int const std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::npos
.rdata:0000C4B4 ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB dd 0FFFFFFFFh
.rdata:0000C4B4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Br
.rdata:0000C4B4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+3Dr ...
.rdata:0000C4B4 _rdata          ends
.rdata:0000C4B4
.bss:0000C4B8 ; ===========================================================================
.bss:0000C4B8
.bss:0000C4B8 ; Segment type: Uninitialized
.bss:0000C4B8 ; Segment permissions: Read/Write
.bss:0000C4B8 _bss            segment dword public 'BSS' use32
.bss:0000C4B8                 assume cs:_bss
.bss:0000C4B8                 ;org 0C4B8h
.bss:0000C4B8 ; COMDAT (pick any)
.bss:0000C4B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000C4B8                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000C4B8 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:0000C4B8 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000C4B8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:0000C4B9                 db    ? ;
.bss:0000C4BA                 db    ? ;
.bss:0000C4BB                 db    ? ;
.bss:0000C4BB _bss            ends
.bss:0000C4BB
.bss:0000C4BC ; ===========================================================================
.bss:0000C4BC
.bss:0000C4BC ; Segment type: Uninitialized
.bss:0000C4BC ; Segment permissions: Read/Write
.bss:0000C4BC _bss            segment dword public 'BSS' use32
.bss:0000C4BC                 assume cs:_bss
.bss:0000C4BC                 ;org 0C4BCh
.bss:0000C4BC ; COMDAT (pick any)
.bss:0000C4BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000C4BC                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000C4BC ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:0000C4BC ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000C4BC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:0000C4BD                 db    ? ;
.bss:0000C4BE                 db    ? ;
.bss:0000C4BF                 db    ? ;
.bss:0000C4BF _bss            ends
.bss:0000C4BF
.bss:0000C4C0 ; ===========================================================================
.bss:0000C4C0
.bss:0000C4C0 ; Segment type: Uninitialized
.bss:0000C4C0 ; Segment permissions: Read/Write
.bss:0000C4C0 _bss            segment byte public 'BSS' use32
.bss:0000C4C0                 assume cs:_bss
.bss:0000C4C0                 ;org 0C4C0h
.bss:0000C4C0 ; COMDAT (pick any)
.bss:0000C4C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000C4C0 ; bool `private: int __thiscall Notepad_plus::notify(struct SCNotification *)'::`5'::prevWasEdit
.bss:0000C4C0 ?prevWasEdit@?4??notify@Notepad_plus@@AAEHPAUSCNotification@@@Z@4_NA db ?
.bss:0000C4C0                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+2DCw
.bss:0000C4C0                                         ; Notepad_plus::notify(SCNotification *)+336r ...
.bss:0000C4C1                 align 4
.bss:0000C4C1 _bss            ends
.bss:0000C4C1
.bss:0000C4C4 ; ===========================================================================
.bss:0000C4C4
.bss:0000C4C4 ; Segment type: Uninitialized
.bss:0000C4C4 ; Segment permissions: Read/Write
.bss:0000C4C4 ; Segment alignment 'qword' can not be represented in assembly
.bss:0000C4C4 _bss            segment para public 'BSS' use32
.bss:0000C4C4                 assume cs:_bss
.bss:0000C4C4                 ;org 0C4C4h
.bss:0000C4C4 ; COMDAT (pick any)
.bss:0000C4C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000C4C4 ; WCHAR `Notepad_plus::notify'::`306'::docTip
.bss:0000C4C4 ?docTip@?BDC@??notify@Notepad_plus@@AAEHPAUSCNotification@@@Z@4PA_WA dw ?
.bss:0000C4C4                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+29DCw
.bss:0000C4C4                                         ; Notepad_plus::notify(SCNotification *)+2B5Fo ...
.bss:0000C4C6                 db    ? ;
.bss:0000C4C7                 db    ? ;
.bss:0000C4C8                 db    ? ;
.bss:0000C4C9                 db    ? ;
.bss:0000C4CA                 db    ? ;
.bss:0000C4CB                 db    ? ;
.bss:0000C4CC                 db    ? ;
.bss:0000C4CD                 db    ? ;
.bss:0000C4CE                 db    ? ;
.bss:0000C4CF                 db    ? ;
.bss:0000C4D0                 db    ? ;
.bss:0000C4D1                 db    ? ;
.bss:0000C4D2                 db    ? ;
.bss:0000C4D3                 db    ? ;
.bss:0000C4D4                 db    ? ;
.bss:0000C4D5                 db    ? ;
.bss:0000C4D6                 db    ? ;
.bss:0000C4D7                 db    ? ;
.bss:0000C4D8                 db    ? ;
.bss:0000C4D9                 db    ? ;
.bss:0000C4DA                 db    ? ;
.bss:0000C4DB                 db    ? ;
.bss:0000C4DC                 db    ? ;
.bss:0000C4DD                 db    ? ;
.bss:0000C4DE                 db    ? ;
.bss:0000C4DF                 db    ? ;
.bss:0000C4E0                 db    ? ;
.bss:0000C4E1                 db    ? ;
.bss:0000C4E2                 db    ? ;
.bss:0000C4E3                 db    ? ;
.bss:0000C4E4                 db    ? ;
.bss:0000C4E5                 db    ? ;
.bss:0000C4E6                 db    ? ;
.bss:0000C4E7                 db    ? ;
.bss:0000C4E8                 db    ? ;
.bss:0000C4E9                 db    ? ;
.bss:0000C4EA                 db    ? ;
.bss:0000C4EB                 db    ? ;
.bss:0000C4EC                 db    ? ;
.bss:0000C4ED                 db    ? ;
.bss:0000C4EE                 db    ? ;
.bss:0000C4EF                 db    ? ;
.bss:0000C4F0                 db    ? ;
.bss:0000C4F1                 db    ? ;
.bss:0000C4F2                 db    ? ;
.bss:0000C4F3                 db    ? ;
.bss:0000C4F4                 db    ? ;
.bss:0000C4F5                 db    ? ;
.bss:0000C4F6                 db    ? ;
.bss:0000C4F7                 db    ? ;
.bss:0000C4F8                 db    ? ;
.bss:0000C4F9                 db    ? ;
.bss:0000C4FA                 db    ? ;
.bss:0000C4FB                 db    ? ;
.bss:0000C4FC                 db    ? ;
.bss:0000C4FD                 db    ? ;
.bss:0000C4FE                 db    ? ;
.bss:0000C4FF                 db    ? ;
.bss:0000C500                 db    ? ;
.bss:0000C501                 db    ? ;
.bss:0000C502                 db    ? ;
.bss:0000C503                 db    ? ;
.bss:0000C504                 db    ? ;
.bss:0000C505                 db    ? ;
.bss:0000C506                 db    ? ;
.bss:0000C507                 db    ? ;
.bss:0000C508                 db    ? ;
.bss:0000C509                 db    ? ;
.bss:0000C50A                 db    ? ;
.bss:0000C50B                 db    ? ;
.bss:0000C50C                 db    ? ;
.bss:0000C50D                 db    ? ;
.bss:0000C50E                 db    ? ;
.bss:0000C50F                 db    ? ;
.bss:0000C510                 db    ? ;
.bss:0000C511                 db    ? ;
.bss:0000C512                 db    ? ;
.bss:0000C513                 db    ? ;
.bss:0000C514                 db    ? ;
.bss:0000C515                 db    ? ;
.bss:0000C516                 db    ? ;
.bss:0000C517                 db    ? ;
.bss:0000C518                 db    ? ;
.bss:0000C519                 db    ? ;
.bss:0000C51A                 db    ? ;
.bss:0000C51B                 db    ? ;
.bss:0000C51C                 db    ? ;
.bss:0000C51D                 db    ? ;
.bss:0000C51E                 db    ? ;
.bss:0000C51F                 db    ? ;
.bss:0000C520                 db    ? ;
.bss:0000C521                 db    ? ;
.bss:0000C522                 db    ? ;
.bss:0000C523                 db    ? ;
.bss:0000C524                 db    ? ;
.bss:0000C525                 db    ? ;
.bss:0000C526                 db    ? ;
.bss:0000C527                 db    ? ;
.bss:0000C528                 db    ? ;
.bss:0000C529                 db    ? ;
.bss:0000C52A                 db    ? ;
.bss:0000C52B                 db    ? ;
.bss:0000C52C                 db    ? ;
.bss:0000C52D                 db    ? ;
.bss:0000C52E                 db    ? ;
.bss:0000C52F                 db    ? ;
.bss:0000C530                 db    ? ;
.bss:0000C531                 db    ? ;
.bss:0000C532                 db    ? ;
.bss:0000C533                 db    ? ;
.bss:0000C534                 db    ? ;
.bss:0000C535                 db    ? ;
.bss:0000C536                 db    ? ;
.bss:0000C537                 db    ? ;
.bss:0000C538                 db    ? ;
.bss:0000C539                 db    ? ;
.bss:0000C53A                 db    ? ;
.bss:0000C53B                 db    ? ;
.bss:0000C53C                 db    ? ;
.bss:0000C53D                 db    ? ;
.bss:0000C53E                 db    ? ;
.bss:0000C53F                 db    ? ;
.bss:0000C540                 db    ? ;
.bss:0000C541                 db    ? ;
.bss:0000C542                 db    ? ;
.bss:0000C543                 db    ? ;
.bss:0000C544                 db    ? ;
.bss:0000C545                 db    ? ;
.bss:0000C546                 db    ? ;
.bss:0000C547                 db    ? ;
.bss:0000C548                 db    ? ;
.bss:0000C549                 db    ? ;
.bss:0000C54A                 db    ? ;
.bss:0000C54B                 db    ? ;
.bss:0000C54C                 db    ? ;
.bss:0000C54D                 db    ? ;
.bss:0000C54E                 db    ? ;
.bss:0000C54F                 db    ? ;
.bss:0000C550                 db    ? ;
.bss:0000C551                 db    ? ;
.bss:0000C552                 db    ? ;
.bss:0000C553                 db    ? ;
.bss:0000C554                 db    ? ;
.bss:0000C555                 db    ? ;
.bss:0000C556                 db    ? ;
.bss:0000C557                 db    ? ;
.bss:0000C558                 db    ? ;
.bss:0000C559                 db    ? ;
.bss:0000C55A                 db    ? ;
.bss:0000C55B                 db    ? ;
.bss:0000C55C                 db    ? ;
.bss:0000C55D                 db    ? ;
.bss:0000C55E                 db    ? ;
.bss:0000C55F                 db    ? ;
.bss:0000C560                 db    ? ;
.bss:0000C561                 db    ? ;
.bss:0000C562                 db    ? ;
.bss:0000C563                 db    ? ;
.bss:0000C564                 db    ? ;
.bss:0000C565                 db    ? ;
.bss:0000C566                 db    ? ;
.bss:0000C567                 db    ? ;
.bss:0000C568                 db    ? ;
.bss:0000C569                 db    ? ;
.bss:0000C56A                 db    ? ;
.bss:0000C56B                 db    ? ;
.bss:0000C56C                 db    ? ;
.bss:0000C56D                 db    ? ;
.bss:0000C56E                 db    ? ;
.bss:0000C56F                 db    ? ;
.bss:0000C570                 db    ? ;
.bss:0000C571                 db    ? ;
.bss:0000C572                 db    ? ;
.bss:0000C573                 db    ? ;
.bss:0000C574                 db    ? ;
.bss:0000C575                 db    ? ;
.bss:0000C576                 db    ? ;
.bss:0000C577                 db    ? ;
.bss:0000C578                 db    ? ;
.bss:0000C579                 db    ? ;
.bss:0000C57A                 db    ? ;
.bss:0000C57B                 db    ? ;
.bss:0000C57C                 db    ? ;
.bss:0000C57D                 db    ? ;
.bss:0000C57E                 db    ? ;
.bss:0000C57F                 db    ? ;
.bss:0000C580                 db    ? ;
.bss:0000C581                 db    ? ;
.bss:0000C582                 db    ? ;
.bss:0000C583                 db    ? ;
.bss:0000C584                 db    ? ;
.bss:0000C585                 db    ? ;
.bss:0000C586                 db    ? ;
.bss:0000C587                 db    ? ;
.bss:0000C588                 db    ? ;
.bss:0000C589                 db    ? ;
.bss:0000C58A                 db    ? ;
.bss:0000C58B                 db    ? ;
.bss:0000C58C                 db    ? ;
.bss:0000C58D                 db    ? ;
.bss:0000C58E                 db    ? ;
.bss:0000C58F                 db    ? ;
.bss:0000C590                 db    ? ;
.bss:0000C591                 db    ? ;
.bss:0000C592                 db    ? ;
.bss:0000C593                 db    ? ;
.bss:0000C594                 db    ? ;
.bss:0000C595                 db    ? ;
.bss:0000C596                 db    ? ;
.bss:0000C597                 db    ? ;
.bss:0000C598                 db    ? ;
.bss:0000C599                 db    ? ;
.bss:0000C59A                 db    ? ;
.bss:0000C59B                 db    ? ;
.bss:0000C59C                 db    ? ;
.bss:0000C59D                 db    ? ;
.bss:0000C59E                 db    ? ;
.bss:0000C59F                 db    ? ;
.bss:0000C5A0                 db    ? ;
.bss:0000C5A1                 db    ? ;
.bss:0000C5A2                 db    ? ;
.bss:0000C5A3                 db    ? ;
.bss:0000C5A4                 db    ? ;
.bss:0000C5A5                 db    ? ;
.bss:0000C5A6                 db    ? ;
.bss:0000C5A7                 db    ? ;
.bss:0000C5A8                 db    ? ;
.bss:0000C5A9                 db    ? ;
.bss:0000C5AA                 db    ? ;
.bss:0000C5AB                 db    ? ;
.bss:0000C5AC                 db    ? ;
.bss:0000C5AD                 db    ? ;
.bss:0000C5AE                 db    ? ;
.bss:0000C5AF                 db    ? ;
.bss:0000C5B0                 db    ? ;
.bss:0000C5B1                 db    ? ;
.bss:0000C5B2                 db    ? ;
.bss:0000C5B3                 db    ? ;
.bss:0000C5B4                 db    ? ;
.bss:0000C5B5                 db    ? ;
.bss:0000C5B6                 db    ? ;
.bss:0000C5B7                 db    ? ;
.bss:0000C5B8                 db    ? ;
.bss:0000C5B9                 db    ? ;
.bss:0000C5BA                 db    ? ;
.bss:0000C5BB                 db    ? ;
.bss:0000C5BC                 db    ? ;
.bss:0000C5BD                 db    ? ;
.bss:0000C5BE                 db    ? ;
.bss:0000C5BF                 db    ? ;
.bss:0000C5C0                 db    ? ;
.bss:0000C5C1                 db    ? ;
.bss:0000C5C2                 db    ? ;
.bss:0000C5C3                 db    ? ;
.bss:0000C5C4                 db    ? ;
.bss:0000C5C5                 db    ? ;
.bss:0000C5C6                 db    ? ;
.bss:0000C5C7                 db    ? ;
.bss:0000C5C8                 db    ? ;
.bss:0000C5C9                 db    ? ;
.bss:0000C5CA                 db    ? ;
.bss:0000C5CB                 db    ? ;
.bss:0000C5CC                 db    ? ;
.bss:0000C5CD                 db    ? ;
.bss:0000C5CE                 db    ? ;
.bss:0000C5CF                 db    ? ;
.bss:0000C5D0                 db    ? ;
.bss:0000C5D1                 db    ? ;
.bss:0000C5D2                 db    ? ;
.bss:0000C5D3                 db    ? ;
.bss:0000C5D4                 db    ? ;
.bss:0000C5D5                 db    ? ;
.bss:0000C5D6                 db    ? ;
.bss:0000C5D7                 db    ? ;
.bss:0000C5D8                 db    ? ;
.bss:0000C5D9                 db    ? ;
.bss:0000C5DA                 db    ? ;
.bss:0000C5DB                 db    ? ;
.bss:0000C5DC                 db    ? ;
.bss:0000C5DD                 db    ? ;
.bss:0000C5DE                 db    ? ;
.bss:0000C5DF                 db    ? ;
.bss:0000C5E0                 db    ? ;
.bss:0000C5E1                 db    ? ;
.bss:0000C5E2                 db    ? ;
.bss:0000C5E3                 db    ? ;
.bss:0000C5E4                 db    ? ;
.bss:0000C5E5                 db    ? ;
.bss:0000C5E6                 db    ? ;
.bss:0000C5E7                 db    ? ;
.bss:0000C5E8                 db    ? ;
.bss:0000C5E9                 db    ? ;
.bss:0000C5EA                 db    ? ;
.bss:0000C5EB                 db    ? ;
.bss:0000C5EC                 db    ? ;
.bss:0000C5ED                 db    ? ;
.bss:0000C5EE                 db    ? ;
.bss:0000C5EF                 db    ? ;
.bss:0000C5F0                 db    ? ;
.bss:0000C5F1                 db    ? ;
.bss:0000C5F2                 db    ? ;
.bss:0000C5F3                 db    ? ;
.bss:0000C5F4                 db    ? ;
.bss:0000C5F5                 db    ? ;
.bss:0000C5F6                 db    ? ;
.bss:0000C5F7                 db    ? ;
.bss:0000C5F8                 db    ? ;
.bss:0000C5F9                 db    ? ;
.bss:0000C5FA                 db    ? ;
.bss:0000C5FB                 db    ? ;
.bss:0000C5FC                 db    ? ;
.bss:0000C5FD                 db    ? ;
.bss:0000C5FE                 db    ? ;
.bss:0000C5FF                 db    ? ;
.bss:0000C600                 db    ? ;
.bss:0000C601                 db    ? ;
.bss:0000C602                 db    ? ;
.bss:0000C603                 db    ? ;
.bss:0000C604                 db    ? ;
.bss:0000C605                 db    ? ;
.bss:0000C606                 db    ? ;
.bss:0000C607                 db    ? ;
.bss:0000C608                 db    ? ;
.bss:0000C609                 db    ? ;
.bss:0000C60A                 db    ? ;
.bss:0000C60B                 db    ? ;
.bss:0000C60C                 db    ? ;
.bss:0000C60D                 db    ? ;
.bss:0000C60E                 db    ? ;
.bss:0000C60F                 db    ? ;
.bss:0000C610                 db    ? ;
.bss:0000C611                 db    ? ;
.bss:0000C612                 db    ? ;
.bss:0000C613                 db    ? ;
.bss:0000C614                 db    ? ;
.bss:0000C615                 db    ? ;
.bss:0000C616                 db    ? ;
.bss:0000C617                 db    ? ;
.bss:0000C618                 db    ? ;
.bss:0000C619                 db    ? ;
.bss:0000C61A                 db    ? ;
.bss:0000C61B                 db    ? ;
.bss:0000C61C                 db    ? ;
.bss:0000C61D                 db    ? ;
.bss:0000C61E                 db    ? ;
.bss:0000C61F                 db    ? ;
.bss:0000C620                 db    ? ;
.bss:0000C621                 db    ? ;
.bss:0000C622                 db    ? ;
.bss:0000C623                 db    ? ;
.bss:0000C624                 db    ? ;
.bss:0000C625                 db    ? ;
.bss:0000C626                 db    ? ;
.bss:0000C627                 db    ? ;
.bss:0000C628                 db    ? ;
.bss:0000C629                 db    ? ;
.bss:0000C62A                 db    ? ;
.bss:0000C62B                 db    ? ;
.bss:0000C62C                 db    ? ;
.bss:0000C62D                 db    ? ;
.bss:0000C62E                 db    ? ;
.bss:0000C62F                 db    ? ;
.bss:0000C630                 db    ? ;
.bss:0000C631                 db    ? ;
.bss:0000C632                 db    ? ;
.bss:0000C633                 db    ? ;
.bss:0000C634                 db    ? ;
.bss:0000C635                 db    ? ;
.bss:0000C636                 db    ? ;
.bss:0000C637                 db    ? ;
.bss:0000C638                 db    ? ;
.bss:0000C639                 db    ? ;
.bss:0000C63A                 db    ? ;
.bss:0000C63B                 db    ? ;
.bss:0000C63C                 db    ? ;
.bss:0000C63D                 db    ? ;
.bss:0000C63E                 db    ? ;
.bss:0000C63F                 db    ? ;
.bss:0000C640                 db    ? ;
.bss:0000C641                 db    ? ;
.bss:0000C642                 db    ? ;
.bss:0000C643                 db    ? ;
.bss:0000C644                 db    ? ;
.bss:0000C645                 db    ? ;
.bss:0000C646                 db    ? ;
.bss:0000C647                 db    ? ;
.bss:0000C648                 db    ? ;
.bss:0000C649                 db    ? ;
.bss:0000C64A                 db    ? ;
.bss:0000C64B                 db    ? ;
.bss:0000C64C                 db    ? ;
.bss:0000C64D                 db    ? ;
.bss:0000C64E                 db    ? ;
.bss:0000C64F                 db    ? ;
.bss:0000C650                 db    ? ;
.bss:0000C651                 db    ? ;
.bss:0000C652                 db    ? ;
.bss:0000C653                 db    ? ;
.bss:0000C654                 db    ? ;
.bss:0000C655                 db    ? ;
.bss:0000C656                 db    ? ;
.bss:0000C657                 db    ? ;
.bss:0000C658                 db    ? ;
.bss:0000C659                 db    ? ;
.bss:0000C65A                 db    ? ;
.bss:0000C65B                 db    ? ;
.bss:0000C65C                 db    ? ;
.bss:0000C65D                 db    ? ;
.bss:0000C65E                 db    ? ;
.bss:0000C65F                 db    ? ;
.bss:0000C660                 db    ? ;
.bss:0000C661                 db    ? ;
.bss:0000C662                 db    ? ;
.bss:0000C663                 db    ? ;
.bss:0000C664                 db    ? ;
.bss:0000C665                 db    ? ;
.bss:0000C666                 db    ? ;
.bss:0000C667                 db    ? ;
.bss:0000C668                 db    ? ;
.bss:0000C669                 db    ? ;
.bss:0000C66A                 db    ? ;
.bss:0000C66B                 db    ? ;
.bss:0000C66C                 db    ? ;
.bss:0000C66D                 db    ? ;
.bss:0000C66E                 db    ? ;
.bss:0000C66F                 db    ? ;
.bss:0000C670                 db    ? ;
.bss:0000C671                 db    ? ;
.bss:0000C672                 db    ? ;
.bss:0000C673                 db    ? ;
.bss:0000C674                 db    ? ;
.bss:0000C675                 db    ? ;
.bss:0000C676                 db    ? ;
.bss:0000C677                 db    ? ;
.bss:0000C678                 db    ? ;
.bss:0000C679                 db    ? ;
.bss:0000C67A                 db    ? ;
.bss:0000C67B                 db    ? ;
.bss:0000C67C                 db    ? ;
.bss:0000C67D                 db    ? ;
.bss:0000C67E                 db    ? ;
.bss:0000C67F                 db    ? ;
.bss:0000C680                 db    ? ;
.bss:0000C681                 db    ? ;
.bss:0000C682                 db    ? ;
.bss:0000C683                 db    ? ;
.bss:0000C684                 db    ? ;
.bss:0000C685                 db    ? ;
.bss:0000C686                 db    ? ;
.bss:0000C687                 db    ? ;
.bss:0000C688                 db    ? ;
.bss:0000C689                 db    ? ;
.bss:0000C68A                 db    ? ;
.bss:0000C68B                 db    ? ;
.bss:0000C68C                 db    ? ;
.bss:0000C68D                 db    ? ;
.bss:0000C68E                 db    ? ;
.bss:0000C68F                 db    ? ;
.bss:0000C690                 db    ? ;
.bss:0000C691                 db    ? ;
.bss:0000C692                 db    ? ;
.bss:0000C693                 db    ? ;
.bss:0000C694                 db    ? ;
.bss:0000C695                 db    ? ;
.bss:0000C696                 db    ? ;
.bss:0000C697                 db    ? ;
.bss:0000C698                 db    ? ;
.bss:0000C699                 db    ? ;
.bss:0000C69A                 db    ? ;
.bss:0000C69B                 db    ? ;
.bss:0000C69C                 db    ? ;
.bss:0000C69D                 db    ? ;
.bss:0000C69E                 db    ? ;
.bss:0000C69F                 db    ? ;
.bss:0000C6A0                 db    ? ;
.bss:0000C6A1                 db    ? ;
.bss:0000C6A2                 db    ? ;
.bss:0000C6A3                 db    ? ;
.bss:0000C6A4                 db    ? ;
.bss:0000C6A5                 db    ? ;
.bss:0000C6A6                 db    ? ;
.bss:0000C6A7                 db    ? ;
.bss:0000C6A8                 db    ? ;
.bss:0000C6A9                 db    ? ;
.bss:0000C6AA                 db    ? ;
.bss:0000C6AB                 db    ? ;
.bss:0000C6AC                 db    ? ;
.bss:0000C6AD                 db    ? ;
.bss:0000C6AE                 db    ? ;
.bss:0000C6AF                 db    ? ;
.bss:0000C6B0                 db    ? ;
.bss:0000C6B1                 db    ? ;
.bss:0000C6B2                 db    ? ;
.bss:0000C6B3                 db    ? ;
.bss:0000C6B4                 db    ? ;
.bss:0000C6B5                 db    ? ;
.bss:0000C6B6                 db    ? ;
.bss:0000C6B7                 db    ? ;
.bss:0000C6B8                 db    ? ;
.bss:0000C6B9                 db    ? ;
.bss:0000C6BA                 db    ? ;
.bss:0000C6BB                 db    ? ;
.bss:0000C6BC                 db    ? ;
.bss:0000C6BD                 db    ? ;
.bss:0000C6BE                 db    ? ;
.bss:0000C6BF                 db    ? ;
.bss:0000C6C0                 db    ? ;
.bss:0000C6C1                 db    ? ;
.bss:0000C6C2                 db    ? ;
.bss:0000C6C3                 db    ? ;
.bss:0000C6C4                 db    ? ;
.bss:0000C6C5                 db    ? ;
.bss:0000C6C6                 db    ? ;
.bss:0000C6C7                 db    ? ;
.bss:0000C6C8                 db    ? ;
.bss:0000C6C9                 db    ? ;
.bss:0000C6CA                 db    ? ;
.bss:0000C6CB                 db    ? ;
.bss:0000C6CC                 db    ? ;
.bss:0000C6CD                 db    ? ;
.bss:0000C6CE                 db    ? ;
.bss:0000C6CF                 db    ? ;
.bss:0000C6D0                 db    ? ;
.bss:0000C6D1                 db    ? ;
.bss:0000C6D2                 db    ? ;
.bss:0000C6D3                 db    ? ;
.bss:0000C6D4                 db    ? ;
.bss:0000C6D5                 db    ? ;
.bss:0000C6D6                 db    ? ;
.bss:0000C6D7                 db    ? ;
.bss:0000C6D8                 db    ? ;
.bss:0000C6D9                 db    ? ;
.bss:0000C6DA                 db    ? ;
.bss:0000C6DB                 db    ? ;
.bss:0000C6DC                 db    ? ;
.bss:0000C6DD                 db    ? ;
.bss:0000C6DE                 db    ? ;
.bss:0000C6DF                 db    ? ;
.bss:0000C6E0                 db    ? ;
.bss:0000C6E1                 db    ? ;
.bss:0000C6E2                 db    ? ;
.bss:0000C6E3                 db    ? ;
.bss:0000C6E4                 db    ? ;
.bss:0000C6E5                 db    ? ;
.bss:0000C6E6                 db    ? ;
.bss:0000C6E7                 db    ? ;
.bss:0000C6E8                 db    ? ;
.bss:0000C6E9                 db    ? ;
.bss:0000C6EA                 db    ? ;
.bss:0000C6EB                 db    ? ;
.bss:0000C6EC                 db    ? ;
.bss:0000C6ED                 db    ? ;
.bss:0000C6EE                 db    ? ;
.bss:0000C6EF                 db    ? ;
.bss:0000C6F0                 db    ? ;
.bss:0000C6F1                 db    ? ;
.bss:0000C6F2                 db    ? ;
.bss:0000C6F3                 db    ? ;
.bss:0000C6F4                 db    ? ;
.bss:0000C6F5                 db    ? ;
.bss:0000C6F6                 db    ? ;
.bss:0000C6F7                 db    ? ;
.bss:0000C6F8                 db    ? ;
.bss:0000C6F9                 db    ? ;
.bss:0000C6FA                 db    ? ;
.bss:0000C6FB                 db    ? ;
.bss:0000C6FC                 db    ? ;
.bss:0000C6FD                 db    ? ;
.bss:0000C6FE                 db    ? ;
.bss:0000C6FF                 db    ? ;
.bss:0000C700                 db    ? ;
.bss:0000C701                 db    ? ;
.bss:0000C702                 db    ? ;
.bss:0000C703                 db    ? ;
.bss:0000C704                 db    ? ;
.bss:0000C705                 db    ? ;
.bss:0000C706                 db    ? ;
.bss:0000C707                 db    ? ;
.bss:0000C708                 db    ? ;
.bss:0000C709                 db    ? ;
.bss:0000C70A                 db    ? ;
.bss:0000C70B                 db    ? ;
.bss:0000C70C                 db    ? ;
.bss:0000C70D                 db    ? ;
.bss:0000C70E                 db    ? ;
.bss:0000C70F                 db    ? ;
.bss:0000C710                 db    ? ;
.bss:0000C711                 db    ? ;
.bss:0000C712                 db    ? ;
.bss:0000C713                 db    ? ;
.bss:0000C714                 db    ? ;
.bss:0000C715                 db    ? ;
.bss:0000C716                 db    ? ;
.bss:0000C717                 db    ? ;
.bss:0000C718                 db    ? ;
.bss:0000C719                 db    ? ;
.bss:0000C71A                 db    ? ;
.bss:0000C71B                 db    ? ;
.bss:0000C71C                 db    ? ;
.bss:0000C71D                 db    ? ;
.bss:0000C71E                 db    ? ;
.bss:0000C71F                 db    ? ;
.bss:0000C720                 db    ? ;
.bss:0000C721                 db    ? ;
.bss:0000C722                 db    ? ;
.bss:0000C723                 db    ? ;
.bss:0000C724                 db    ? ;
.bss:0000C725                 db    ? ;
.bss:0000C726                 db    ? ;
.bss:0000C727                 db    ? ;
.bss:0000C728                 db    ? ;
.bss:0000C729                 db    ? ;
.bss:0000C72A                 db    ? ;
.bss:0000C72B                 db    ? ;
.bss:0000C72C                 db    ? ;
.bss:0000C72D                 db    ? ;
.bss:0000C72E                 db    ? ;
.bss:0000C72F                 db    ? ;
.bss:0000C730                 db    ? ;
.bss:0000C731                 db    ? ;
.bss:0000C732                 db    ? ;
.bss:0000C733                 db    ? ;
.bss:0000C734                 db    ? ;
.bss:0000C735                 db    ? ;
.bss:0000C736                 db    ? ;
.bss:0000C737                 db    ? ;
.bss:0000C738                 db    ? ;
.bss:0000C739                 db    ? ;
.bss:0000C73A                 db    ? ;
.bss:0000C73B                 db    ? ;
.bss:0000C73C                 db    ? ;
.bss:0000C73D                 db    ? ;
.bss:0000C73E                 db    ? ;
.bss:0000C73F                 db    ? ;
.bss:0000C740                 db    ? ;
.bss:0000C741                 db    ? ;
.bss:0000C742                 db    ? ;
.bss:0000C743                 db    ? ;
.bss:0000C744                 db    ? ;
.bss:0000C745                 db    ? ;
.bss:0000C746                 db    ? ;
.bss:0000C747                 db    ? ;
.bss:0000C748                 db    ? ;
.bss:0000C749                 db    ? ;
.bss:0000C74A                 db    ? ;
.bss:0000C74B                 db    ? ;
.bss:0000C74C                 db    ? ;
.bss:0000C74D                 db    ? ;
.bss:0000C74E                 db    ? ;
.bss:0000C74F                 db    ? ;
.bss:0000C750                 db    ? ;
.bss:0000C751                 db    ? ;
.bss:0000C752                 db    ? ;
.bss:0000C753                 db    ? ;
.bss:0000C754                 db    ? ;
.bss:0000C755                 db    ? ;
.bss:0000C756                 db    ? ;
.bss:0000C757                 db    ? ;
.bss:0000C758                 db    ? ;
.bss:0000C759                 db    ? ;
.bss:0000C75A                 db    ? ;
.bss:0000C75B                 db    ? ;
.bss:0000C75C                 db    ? ;
.bss:0000C75D                 db    ? ;
.bss:0000C75E                 db    ? ;
.bss:0000C75F                 db    ? ;
.bss:0000C760                 db    ? ;
.bss:0000C761                 db    ? ;
.bss:0000C762                 db    ? ;
.bss:0000C763                 db    ? ;
.bss:0000C764                 db    ? ;
.bss:0000C765                 db    ? ;
.bss:0000C766                 db    ? ;
.bss:0000C767                 db    ? ;
.bss:0000C768                 db    ? ;
.bss:0000C769                 db    ? ;
.bss:0000C76A                 db    ? ;
.bss:0000C76B                 db    ? ;
.bss:0000C76C                 db    ? ;
.bss:0000C76D                 db    ? ;
.bss:0000C76E                 db    ? ;
.bss:0000C76F                 db    ? ;
.bss:0000C770                 db    ? ;
.bss:0000C771                 db    ? ;
.bss:0000C772                 db    ? ;
.bss:0000C773                 db    ? ;
.bss:0000C774                 db    ? ;
.bss:0000C775                 db    ? ;
.bss:0000C776                 db    ? ;
.bss:0000C777                 db    ? ;
.bss:0000C778                 db    ? ;
.bss:0000C779                 db    ? ;
.bss:0000C77A                 db    ? ;
.bss:0000C77B                 db    ? ;
.bss:0000C77C                 db    ? ;
.bss:0000C77D                 db    ? ;
.bss:0000C77E                 db    ? ;
.bss:0000C77F                 db    ? ;
.bss:0000C780                 db    ? ;
.bss:0000C781                 db    ? ;
.bss:0000C782                 db    ? ;
.bss:0000C783                 db    ? ;
.bss:0000C784                 db    ? ;
.bss:0000C785                 db    ? ;
.bss:0000C786                 db    ? ;
.bss:0000C787                 db    ? ;
.bss:0000C788                 db    ? ;
.bss:0000C789                 db    ? ;
.bss:0000C78A                 db    ? ;
.bss:0000C78B                 db    ? ;
.bss:0000C78C                 db    ? ;
.bss:0000C78D                 db    ? ;
.bss:0000C78E                 db    ? ;
.bss:0000C78F                 db    ? ;
.bss:0000C790                 db    ? ;
.bss:0000C791                 db    ? ;
.bss:0000C792                 db    ? ;
.bss:0000C793                 db    ? ;
.bss:0000C794                 db    ? ;
.bss:0000C795                 db    ? ;
.bss:0000C796                 db    ? ;
.bss:0000C797                 db    ? ;
.bss:0000C798                 db    ? ;
.bss:0000C799                 db    ? ;
.bss:0000C79A                 db    ? ;
.bss:0000C79B                 db    ? ;
.bss:0000C79C                 db    ? ;
.bss:0000C79D                 db    ? ;
.bss:0000C79E                 db    ? ;
.bss:0000C79F                 db    ? ;
.bss:0000C7A0                 db    ? ;
.bss:0000C7A1                 db    ? ;
.bss:0000C7A2                 db    ? ;
.bss:0000C7A3                 db    ? ;
.bss:0000C7A4                 db    ? ;
.bss:0000C7A5                 db    ? ;
.bss:0000C7A6                 db    ? ;
.bss:0000C7A7                 db    ? ;
.bss:0000C7A8                 db    ? ;
.bss:0000C7A9                 db    ? ;
.bss:0000C7AA                 db    ? ;
.bss:0000C7AB                 db    ? ;
.bss:0000C7AC                 db    ? ;
.bss:0000C7AD                 db    ? ;
.bss:0000C7AE                 db    ? ;
.bss:0000C7AF                 db    ? ;
.bss:0000C7B0                 db    ? ;
.bss:0000C7B1                 db    ? ;
.bss:0000C7B2                 db    ? ;
.bss:0000C7B3                 db    ? ;
.bss:0000C7B4                 db    ? ;
.bss:0000C7B5                 db    ? ;
.bss:0000C7B6                 db    ? ;
.bss:0000C7B7                 db    ? ;
.bss:0000C7B8                 db    ? ;
.bss:0000C7B9                 db    ? ;
.bss:0000C7BA                 db    ? ;
.bss:0000C7BB                 db    ? ;
.bss:0000C7BC                 db    ? ;
.bss:0000C7BD                 db    ? ;
.bss:0000C7BE                 db    ? ;
.bss:0000C7BF                 db    ? ;
.bss:0000C7C0                 db    ? ;
.bss:0000C7C1                 db    ? ;
.bss:0000C7C2                 db    ? ;
.bss:0000C7C3                 db    ? ;
.bss:0000C7C4                 db    ? ;
.bss:0000C7C5                 db    ? ;
.bss:0000C7C6                 db    ? ;
.bss:0000C7C7                 db    ? ;
.bss:0000C7C8                 db    ? ;
.bss:0000C7C9                 db    ? ;
.bss:0000C7CA                 db    ? ;
.bss:0000C7CB                 db    ? ;
.bss:0000C7CC                 db    ? ;
.bss:0000C7CD                 db    ? ;
.bss:0000C7CE                 db    ? ;
.bss:0000C7CF                 db    ? ;
.bss:0000C7D0                 db    ? ;
.bss:0000C7D1                 db    ? ;
.bss:0000C7D2                 db    ? ;
.bss:0000C7D3                 db    ? ;
.bss:0000C7D4                 db    ? ;
.bss:0000C7D5                 db    ? ;
.bss:0000C7D6                 db    ? ;
.bss:0000C7D7                 db    ? ;
.bss:0000C7D8                 db    ? ;
.bss:0000C7D9                 db    ? ;
.bss:0000C7DA                 db    ? ;
.bss:0000C7DB                 db    ? ;
.bss:0000C7DC                 db    ? ;
.bss:0000C7DD                 db    ? ;
.bss:0000C7DE                 db    ? ;
.bss:0000C7DF                 db    ? ;
.bss:0000C7E0                 db    ? ;
.bss:0000C7E1                 db    ? ;
.bss:0000C7E2                 db    ? ;
.bss:0000C7E3                 db    ? ;
.bss:0000C7E4                 db    ? ;
.bss:0000C7E5                 db    ? ;
.bss:0000C7E6                 db    ? ;
.bss:0000C7E7                 db    ? ;
.bss:0000C7E8                 db    ? ;
.bss:0000C7E9                 db    ? ;
.bss:0000C7EA                 db    ? ;
.bss:0000C7EB                 db    ? ;
.bss:0000C7EC                 db    ? ;
.bss:0000C7ED                 db    ? ;
.bss:0000C7EE                 db    ? ;
.bss:0000C7EF                 db    ? ;
.bss:0000C7F0                 db    ? ;
.bss:0000C7F1                 db    ? ;
.bss:0000C7F2                 db    ? ;
.bss:0000C7F3                 db    ? ;
.bss:0000C7F4                 db    ? ;
.bss:0000C7F5                 db    ? ;
.bss:0000C7F6                 db    ? ;
.bss:0000C7F7                 db    ? ;
.bss:0000C7F8                 db    ? ;
.bss:0000C7F9                 db    ? ;
.bss:0000C7FA                 db    ? ;
.bss:0000C7FB                 db    ? ;
.bss:0000C7FC                 db    ? ;
.bss:0000C7FD                 db    ? ;
.bss:0000C7FE                 db    ? ;
.bss:0000C7FF                 db    ? ;
.bss:0000C800                 db    ? ;
.bss:0000C801                 db    ? ;
.bss:0000C802                 db    ? ;
.bss:0000C803                 db    ? ;
.bss:0000C804                 db    ? ;
.bss:0000C805                 db    ? ;
.bss:0000C806                 db    ? ;
.bss:0000C807                 db    ? ;
.bss:0000C808                 db    ? ;
.bss:0000C809                 db    ? ;
.bss:0000C80A                 db    ? ;
.bss:0000C80B                 db    ? ;
.bss:0000C80C                 db    ? ;
.bss:0000C80D                 db    ? ;
.bss:0000C80E                 db    ? ;
.bss:0000C80F                 db    ? ;
.bss:0000C810                 db    ? ;
.bss:0000C811                 db    ? ;
.bss:0000C812                 db    ? ;
.bss:0000C813                 db    ? ;
.bss:0000C814                 db    ? ;
.bss:0000C815                 db    ? ;
.bss:0000C816                 db    ? ;
.bss:0000C817                 db    ? ;
.bss:0000C818                 db    ? ;
.bss:0000C819                 db    ? ;
.bss:0000C81A                 db    ? ;
.bss:0000C81B                 db    ? ;
.bss:0000C81C                 db    ? ;
.bss:0000C81D                 db    ? ;
.bss:0000C81E                 db    ? ;
.bss:0000C81F                 db    ? ;
.bss:0000C820                 db    ? ;
.bss:0000C821                 db    ? ;
.bss:0000C822                 db    ? ;
.bss:0000C823                 db    ? ;
.bss:0000C824                 db    ? ;
.bss:0000C825                 db    ? ;
.bss:0000C826                 db    ? ;
.bss:0000C827                 db    ? ;
.bss:0000C828                 db    ? ;
.bss:0000C829                 db    ? ;
.bss:0000C82A                 db    ? ;
.bss:0000C82B                 db    ? ;
.bss:0000C82C                 db    ? ;
.bss:0000C82D                 db    ? ;
.bss:0000C82E                 db    ? ;
.bss:0000C82F                 db    ? ;
.bss:0000C830                 db    ? ;
.bss:0000C831                 db    ? ;
.bss:0000C832                 db    ? ;
.bss:0000C833                 db    ? ;
.bss:0000C834                 db    ? ;
.bss:0000C835                 db    ? ;
.bss:0000C836                 db    ? ;
.bss:0000C837                 db    ? ;
.bss:0000C838                 db    ? ;
.bss:0000C839                 db    ? ;
.bss:0000C83A                 db    ? ;
.bss:0000C83B                 db    ? ;
.bss:0000C83C                 db    ? ;
.bss:0000C83D                 db    ? ;
.bss:0000C83E                 db    ? ;
.bss:0000C83F                 db    ? ;
.bss:0000C840                 db    ? ;
.bss:0000C841                 db    ? ;
.bss:0000C842                 db    ? ;
.bss:0000C843                 db    ? ;
.bss:0000C844                 db    ? ;
.bss:0000C845                 db    ? ;
.bss:0000C846                 db    ? ;
.bss:0000C847                 db    ? ;
.bss:0000C848                 db    ? ;
.bss:0000C849                 db    ? ;
.bss:0000C84A                 db    ? ;
.bss:0000C84B                 db    ? ;
.bss:0000C84C                 db    ? ;
.bss:0000C84D                 db    ? ;
.bss:0000C84E                 db    ? ;
.bss:0000C84F                 db    ? ;
.bss:0000C850                 db    ? ;
.bss:0000C851                 db    ? ;
.bss:0000C852                 db    ? ;
.bss:0000C853                 db    ? ;
.bss:0000C854                 db    ? ;
.bss:0000C855                 db    ? ;
.bss:0000C856                 db    ? ;
.bss:0000C857                 db    ? ;
.bss:0000C858                 db    ? ;
.bss:0000C859                 db    ? ;
.bss:0000C85A                 db    ? ;
.bss:0000C85B                 db    ? ;
.bss:0000C85C                 db    ? ;
.bss:0000C85D                 db    ? ;
.bss:0000C85E                 db    ? ;
.bss:0000C85F                 db    ? ;
.bss:0000C860                 db    ? ;
.bss:0000C861                 db    ? ;
.bss:0000C862                 db    ? ;
.bss:0000C863                 db    ? ;
.bss:0000C864                 db    ? ;
.bss:0000C865                 db    ? ;
.bss:0000C866                 db    ? ;
.bss:0000C867                 db    ? ;
.bss:0000C868                 db    ? ;
.bss:0000C869                 db    ? ;
.bss:0000C86A                 db    ? ;
.bss:0000C86B                 db    ? ;
.bss:0000C86C                 db    ? ;
.bss:0000C86D                 db    ? ;
.bss:0000C86E                 db    ? ;
.bss:0000C86F                 db    ? ;
.bss:0000C870                 db    ? ;
.bss:0000C871                 db    ? ;
.bss:0000C872                 db    ? ;
.bss:0000C873                 db    ? ;
.bss:0000C874                 db    ? ;
.bss:0000C875                 db    ? ;
.bss:0000C876                 db    ? ;
.bss:0000C877                 db    ? ;
.bss:0000C878                 db    ? ;
.bss:0000C879                 db    ? ;
.bss:0000C87A                 db    ? ;
.bss:0000C87B                 db    ? ;
.bss:0000C87C                 db    ? ;
.bss:0000C87D                 db    ? ;
.bss:0000C87E                 db    ? ;
.bss:0000C87F                 db    ? ;
.bss:0000C880                 db    ? ;
.bss:0000C881                 db    ? ;
.bss:0000C882                 db    ? ;
.bss:0000C883                 db    ? ;
.bss:0000C884                 db    ? ;
.bss:0000C885                 db    ? ;
.bss:0000C886                 db    ? ;
.bss:0000C887                 db    ? ;
.bss:0000C888                 db    ? ;
.bss:0000C889                 db    ? ;
.bss:0000C88A                 db    ? ;
.bss:0000C88B                 db    ? ;
.bss:0000C88C                 db    ? ;
.bss:0000C88D                 db    ? ;
.bss:0000C88E                 db    ? ;
.bss:0000C88F                 db    ? ;
.bss:0000C890                 db    ? ;
.bss:0000C891                 db    ? ;
.bss:0000C892                 db    ? ;
.bss:0000C893                 db    ? ;
.bss:0000C894                 db    ? ;
.bss:0000C895                 db    ? ;
.bss:0000C896                 db    ? ;
.bss:0000C897                 db    ? ;
.bss:0000C898                 db    ? ;
.bss:0000C899                 db    ? ;
.bss:0000C89A                 db    ? ;
.bss:0000C89B                 db    ? ;
.bss:0000C89C                 db    ? ;
.bss:0000C89D                 db    ? ;
.bss:0000C89E                 db    ? ;
.bss:0000C89F                 db    ? ;
.bss:0000C8A0                 db    ? ;
.bss:0000C8A1                 db    ? ;
.bss:0000C8A2                 db    ? ;
.bss:0000C8A3                 db    ? ;
.bss:0000C8A4                 db    ? ;
.bss:0000C8A5                 db    ? ;
.bss:0000C8A6                 db    ? ;
.bss:0000C8A7                 db    ? ;
.bss:0000C8A8                 db    ? ;
.bss:0000C8A9                 db    ? ;
.bss:0000C8AA                 db    ? ;
.bss:0000C8AB                 db    ? ;
.bss:0000C8AC                 db    ? ;
.bss:0000C8AD                 db    ? ;
.bss:0000C8AE                 db    ? ;
.bss:0000C8AF                 db    ? ;
.bss:0000C8B0                 db    ? ;
.bss:0000C8B1                 db    ? ;
.bss:0000C8B2                 db    ? ;
.bss:0000C8B3                 db    ? ;
.bss:0000C8B4                 db    ? ;
.bss:0000C8B5                 db    ? ;
.bss:0000C8B6                 db    ? ;
.bss:0000C8B7                 db    ? ;
.bss:0000C8B8                 db    ? ;
.bss:0000C8B9                 db    ? ;
.bss:0000C8BA                 db    ? ;
.bss:0000C8BB                 db    ? ;
.bss:0000C8BC                 db    ? ;
.bss:0000C8BD                 db    ? ;
.bss:0000C8BE                 db    ? ;
.bss:0000C8BF                 db    ? ;
.bss:0000C8C0                 db    ? ;
.bss:0000C8C1                 db    ? ;
.bss:0000C8C2                 db    ? ;
.bss:0000C8C3                 db    ? ;
.bss:0000C8C4                 db    ? ;
.bss:0000C8C5                 db    ? ;
.bss:0000C8C6                 db    ? ;
.bss:0000C8C7                 db    ? ;
.bss:0000C8C8                 db    ? ;
.bss:0000C8C9                 db    ? ;
.bss:0000C8CA                 db    ? ;
.bss:0000C8CB                 db    ? ;
.bss:0000C8CC                 db    ? ;
.bss:0000C8CD                 db    ? ;
.bss:0000C8CE                 db    ? ;
.bss:0000C8CF                 db    ? ;
.bss:0000C8D0                 db    ? ;
.bss:0000C8D1                 db    ? ;
.bss:0000C8D2                 db    ? ;
.bss:0000C8D3                 db    ? ;
.bss:0000C8D4                 db    ? ;
.bss:0000C8D5                 db    ? ;
.bss:0000C8D6                 db    ? ;
.bss:0000C8D7                 db    ? ;
.bss:0000C8D8                 db    ? ;
.bss:0000C8D9                 db    ? ;
.bss:0000C8DA                 db    ? ;
.bss:0000C8DB                 db    ? ;
.bss:0000C8DC                 db    ? ;
.bss:0000C8DD                 db    ? ;
.bss:0000C8DE                 db    ? ;
.bss:0000C8DF                 db    ? ;
.bss:0000C8E0                 db    ? ;
.bss:0000C8E1                 db    ? ;
.bss:0000C8E2                 db    ? ;
.bss:0000C8E3                 db    ? ;
.bss:0000C8E4                 db    ? ;
.bss:0000C8E5                 db    ? ;
.bss:0000C8E6                 db    ? ;
.bss:0000C8E7                 db    ? ;
.bss:0000C8E8                 db    ? ;
.bss:0000C8E9                 db    ? ;
.bss:0000C8EA                 db    ? ;
.bss:0000C8EB                 db    ? ;
.bss:0000C8EC                 db    ? ;
.bss:0000C8ED                 db    ? ;
.bss:0000C8EE                 db    ? ;
.bss:0000C8EF                 db    ? ;
.bss:0000C8F0                 db    ? ;
.bss:0000C8F1                 db    ? ;
.bss:0000C8F2                 db    ? ;
.bss:0000C8F3                 db    ? ;
.bss:0000C8F4                 db    ? ;
.bss:0000C8F5                 db    ? ;
.bss:0000C8F6                 db    ? ;
.bss:0000C8F7                 db    ? ;
.bss:0000C8F8                 db    ? ;
.bss:0000C8F9                 db    ? ;
.bss:0000C8FA                 db    ? ;
.bss:0000C8FB                 db    ? ;
.bss:0000C8FC                 db    ? ;
.bss:0000C8FD                 db    ? ;
.bss:0000C8FE                 db    ? ;
.bss:0000C8FF                 db    ? ;
.bss:0000C900                 db    ? ;
.bss:0000C901                 db    ? ;
.bss:0000C902                 db    ? ;
.bss:0000C903                 db    ? ;
.bss:0000C904                 db    ? ;
.bss:0000C905                 db    ? ;
.bss:0000C906                 db    ? ;
.bss:0000C907                 db    ? ;
.bss:0000C908                 db    ? ;
.bss:0000C909                 db    ? ;
.bss:0000C90A                 db    ? ;
.bss:0000C90B                 db    ? ;
.bss:0000C90C                 db    ? ;
.bss:0000C90D                 db    ? ;
.bss:0000C90E                 db    ? ;
.bss:0000C90F                 db    ? ;
.bss:0000C910                 db    ? ;
.bss:0000C911                 db    ? ;
.bss:0000C912                 db    ? ;
.bss:0000C913                 db    ? ;
.bss:0000C914                 db    ? ;
.bss:0000C915                 db    ? ;
.bss:0000C916                 db    ? ;
.bss:0000C917                 db    ? ;
.bss:0000C918                 db    ? ;
.bss:0000C919                 db    ? ;
.bss:0000C91A                 db    ? ;
.bss:0000C91B                 db    ? ;
.bss:0000C91C                 db    ? ;
.bss:0000C91D                 db    ? ;
.bss:0000C91E                 db    ? ;
.bss:0000C91F                 db    ? ;
.bss:0000C920                 db    ? ;
.bss:0000C921                 db    ? ;
.bss:0000C922                 db    ? ;
.bss:0000C923                 db    ? ;
.bss:0000C924                 db    ? ;
.bss:0000C925                 db    ? ;
.bss:0000C926                 db    ? ;
.bss:0000C927                 db    ? ;
.bss:0000C928                 db    ? ;
.bss:0000C929                 db    ? ;
.bss:0000C92A                 db    ? ;
.bss:0000C92B                 db    ? ;
.bss:0000C92C                 db    ? ;
.bss:0000C92D                 db    ? ;
.bss:0000C92E                 db    ? ;
.bss:0000C92F                 db    ? ;
.bss:0000C930                 db    ? ;
.bss:0000C931                 db    ? ;
.bss:0000C932                 db    ? ;
.bss:0000C933                 db    ? ;
.bss:0000C934                 db    ? ;
.bss:0000C935                 db    ? ;
.bss:0000C936                 db    ? ;
.bss:0000C937                 db    ? ;
.bss:0000C938                 db    ? ;
.bss:0000C939                 db    ? ;
.bss:0000C93A                 db    ? ;
.bss:0000C93B                 db    ? ;
.bss:0000C93C                 db    ? ;
.bss:0000C93D                 db    ? ;
.bss:0000C93E                 db    ? ;
.bss:0000C93F                 db    ? ;
.bss:0000C940                 db    ? ;
.bss:0000C941                 db    ? ;
.bss:0000C942                 db    ? ;
.bss:0000C943                 db    ? ;
.bss:0000C944                 db    ? ;
.bss:0000C945                 db    ? ;
.bss:0000C946                 db    ? ;
.bss:0000C947                 db    ? ;
.bss:0000C948                 db    ? ;
.bss:0000C949                 db    ? ;
.bss:0000C94A                 db    ? ;
.bss:0000C94B                 db    ? ;
.bss:0000C94C                 db    ? ;
.bss:0000C94D                 db    ? ;
.bss:0000C94E                 db    ? ;
.bss:0000C94F                 db    ? ;
.bss:0000C950                 db    ? ;
.bss:0000C951                 db    ? ;
.bss:0000C952                 db    ? ;
.bss:0000C953                 db    ? ;
.bss:0000C954                 db    ? ;
.bss:0000C955                 db    ? ;
.bss:0000C956                 db    ? ;
.bss:0000C957                 db    ? ;
.bss:0000C958                 db    ? ;
.bss:0000C959                 db    ? ;
.bss:0000C95A                 db    ? ;
.bss:0000C95B                 db    ? ;
.bss:0000C95C                 db    ? ;
.bss:0000C95D                 db    ? ;
.bss:0000C95E                 db    ? ;
.bss:0000C95F                 db    ? ;
.bss:0000C960                 db    ? ;
.bss:0000C961                 db    ? ;
.bss:0000C962                 db    ? ;
.bss:0000C963                 db    ? ;
.bss:0000C964                 db    ? ;
.bss:0000C965                 db    ? ;
.bss:0000C966                 db    ? ;
.bss:0000C967                 db    ? ;
.bss:0000C968                 db    ? ;
.bss:0000C969                 db    ? ;
.bss:0000C96A                 db    ? ;
.bss:0000C96B                 db    ? ;
.bss:0000C96C                 db    ? ;
.bss:0000C96D                 db    ? ;
.bss:0000C96E                 db    ? ;
.bss:0000C96F                 db    ? ;
.bss:0000C970                 db    ? ;
.bss:0000C971                 db    ? ;
.bss:0000C972                 db    ? ;
.bss:0000C973                 db    ? ;
.bss:0000C974                 db    ? ;
.bss:0000C975                 db    ? ;
.bss:0000C976                 db    ? ;
.bss:0000C977                 db    ? ;
.bss:0000C978                 db    ? ;
.bss:0000C979                 db    ? ;
.bss:0000C97A                 db    ? ;
.bss:0000C97B                 db    ? ;
.bss:0000C97C                 db    ? ;
.bss:0000C97D                 db    ? ;
.bss:0000C97E                 db    ? ;
.bss:0000C97F                 db    ? ;
.bss:0000C980                 db    ? ;
.bss:0000C981                 db    ? ;
.bss:0000C982                 db    ? ;
.bss:0000C983                 db    ? ;
.bss:0000C984                 db    ? ;
.bss:0000C985                 db    ? ;
.bss:0000C986                 db    ? ;
.bss:0000C987                 db    ? ;
.bss:0000C988                 db    ? ;
.bss:0000C989                 db    ? ;
.bss:0000C98A                 db    ? ;
.bss:0000C98B                 db    ? ;
.bss:0000C98C                 db    ? ;
.bss:0000C98D                 db    ? ;
.bss:0000C98E                 db    ? ;
.bss:0000C98F                 db    ? ;
.bss:0000C990                 db    ? ;
.bss:0000C991                 db    ? ;
.bss:0000C992                 db    ? ;
.bss:0000C993                 db    ? ;
.bss:0000C994                 db    ? ;
.bss:0000C995                 db    ? ;
.bss:0000C996                 db    ? ;
.bss:0000C997                 db    ? ;
.bss:0000C998                 db    ? ;
.bss:0000C999                 db    ? ;
.bss:0000C99A                 db    ? ;
.bss:0000C99B                 db    ? ;
.bss:0000C99C                 db    ? ;
.bss:0000C99D                 db    ? ;
.bss:0000C99E                 db    ? ;
.bss:0000C99F                 db    ? ;
.bss:0000C9A0                 db    ? ;
.bss:0000C9A1                 db    ? ;
.bss:0000C9A2                 db    ? ;
.bss:0000C9A3                 db    ? ;
.bss:0000C9A4                 db    ? ;
.bss:0000C9A5                 db    ? ;
.bss:0000C9A6                 db    ? ;
.bss:0000C9A7                 db    ? ;
.bss:0000C9A8                 db    ? ;
.bss:0000C9A9                 db    ? ;
.bss:0000C9AA                 db    ? ;
.bss:0000C9AB                 db    ? ;
.bss:0000C9AC                 db    ? ;
.bss:0000C9AD                 db    ? ;
.bss:0000C9AE                 db    ? ;
.bss:0000C9AF                 db    ? ;
.bss:0000C9B0                 db    ? ;
.bss:0000C9B1                 db    ? ;
.bss:0000C9B2                 db    ? ;
.bss:0000C9B3                 db    ? ;
.bss:0000C9B4                 db    ? ;
.bss:0000C9B5                 db    ? ;
.bss:0000C9B6                 db    ? ;
.bss:0000C9B7                 db    ? ;
.bss:0000C9B8                 db    ? ;
.bss:0000C9B9                 db    ? ;
.bss:0000C9BA                 db    ? ;
.bss:0000C9BB                 db    ? ;
.bss:0000C9BC                 db    ? ;
.bss:0000C9BD                 db    ? ;
.bss:0000C9BE                 db    ? ;
.bss:0000C9BF                 db    ? ;
.bss:0000C9C0                 db    ? ;
.bss:0000C9C1                 db    ? ;
.bss:0000C9C2                 db    ? ;
.bss:0000C9C3                 db    ? ;
.bss:0000C9C4                 db    ? ;
.bss:0000C9C5                 db    ? ;
.bss:0000C9C6                 db    ? ;
.bss:0000C9C7                 db    ? ;
.bss:0000C9C8                 db    ? ;
.bss:0000C9C9                 db    ? ;
.bss:0000C9CA                 db    ? ;
.bss:0000C9CB                 db    ? ;
.bss:0000C9CC                 db    ? ;
.bss:0000C9CD                 db    ? ;
.bss:0000C9CE                 db    ? ;
.bss:0000C9CF                 db    ? ;
.bss:0000C9D0                 db    ? ;
.bss:0000C9D1                 db    ? ;
.bss:0000C9D2                 db    ? ;
.bss:0000C9D3                 db    ? ;
.bss:0000C9D4                 db    ? ;
.bss:0000C9D5                 db    ? ;
.bss:0000C9D6                 db    ? ;
.bss:0000C9D7                 db    ? ;
.bss:0000C9D8                 db    ? ;
.bss:0000C9D9                 db    ? ;
.bss:0000C9DA                 db    ? ;
.bss:0000C9DB                 db    ? ;
.bss:0000C9DC                 db    ? ;
.bss:0000C9DD                 db    ? ;
.bss:0000C9DE                 db    ? ;
.bss:0000C9DF                 db    ? ;
.bss:0000C9E0                 db    ? ;
.bss:0000C9E1                 db    ? ;
.bss:0000C9E2                 db    ? ;
.bss:0000C9E3                 db    ? ;
.bss:0000C9E4                 db    ? ;
.bss:0000C9E5                 db    ? ;
.bss:0000C9E6                 db    ? ;
.bss:0000C9E7                 db    ? ;
.bss:0000C9E8                 db    ? ;
.bss:0000C9E9                 db    ? ;
.bss:0000C9EA                 db    ? ;
.bss:0000C9EB                 db    ? ;
.bss:0000C9EC                 db    ? ;
.bss:0000C9ED                 db    ? ;
.bss:0000C9EE                 db    ? ;
.bss:0000C9EF                 db    ? ;
.bss:0000C9F0                 db    ? ;
.bss:0000C9F1                 db    ? ;
.bss:0000C9F2                 db    ? ;
.bss:0000C9F3                 db    ? ;
.bss:0000C9F4                 db    ? ;
.bss:0000C9F5                 db    ? ;
.bss:0000C9F6                 db    ? ;
.bss:0000C9F7                 db    ? ;
.bss:0000C9F8                 db    ? ;
.bss:0000C9F9                 db    ? ;
.bss:0000C9FA                 db    ? ;
.bss:0000C9FB                 db    ? ;
.bss:0000C9FC                 db    ? ;
.bss:0000C9FD                 db    ? ;
.bss:0000C9FE                 db    ? ;
.bss:0000C9FF                 db    ? ;
.bss:0000CA00                 db    ? ;
.bss:0000CA01                 db    ? ;
.bss:0000CA02                 db    ? ;
.bss:0000CA03                 db    ? ;
.bss:0000CA04                 db    ? ;
.bss:0000CA05                 db    ? ;
.bss:0000CA06                 db    ? ;
.bss:0000CA07                 db    ? ;
.bss:0000CA08                 db    ? ;
.bss:0000CA09                 db    ? ;
.bss:0000CA0A                 db    ? ;
.bss:0000CA0B                 db    ? ;
.bss:0000CA0C                 db    ? ;
.bss:0000CA0D                 db    ? ;
.bss:0000CA0E                 db    ? ;
.bss:0000CA0F                 db    ? ;
.bss:0000CA10                 db    ? ;
.bss:0000CA11                 db    ? ;
.bss:0000CA12                 db    ? ;
.bss:0000CA13                 db    ? ;
.bss:0000CA14                 db    ? ;
.bss:0000CA15                 db    ? ;
.bss:0000CA16                 db    ? ;
.bss:0000CA17                 db    ? ;
.bss:0000CA18                 db    ? ;
.bss:0000CA19                 db    ? ;
.bss:0000CA1A                 db    ? ;
.bss:0000CA1B                 db    ? ;
.bss:0000CA1C                 db    ? ;
.bss:0000CA1D                 db    ? ;
.bss:0000CA1E                 db    ? ;
.bss:0000CA1F                 db    ? ;
.bss:0000CA20                 db    ? ;
.bss:0000CA21                 db    ? ;
.bss:0000CA22                 db    ? ;
.bss:0000CA23                 db    ? ;
.bss:0000CA24                 db    ? ;
.bss:0000CA25                 db    ? ;
.bss:0000CA26                 db    ? ;
.bss:0000CA27                 db    ? ;
.bss:0000CA28                 db    ? ;
.bss:0000CA29                 db    ? ;
.bss:0000CA2A                 db    ? ;
.bss:0000CA2B                 db    ? ;
.bss:0000CA2C                 db    ? ;
.bss:0000CA2D                 db    ? ;
.bss:0000CA2E                 db    ? ;
.bss:0000CA2F                 db    ? ;
.bss:0000CA30                 db    ? ;
.bss:0000CA31                 db    ? ;
.bss:0000CA32                 db    ? ;
.bss:0000CA33                 db    ? ;
.bss:0000CA34                 db    ? ;
.bss:0000CA35                 db    ? ;
.bss:0000CA36                 db    ? ;
.bss:0000CA37                 db    ? ;
.bss:0000CA38                 db    ? ;
.bss:0000CA39                 db    ? ;
.bss:0000CA3A                 db    ? ;
.bss:0000CA3B                 db    ? ;
.bss:0000CA3C                 db    ? ;
.bss:0000CA3D                 db    ? ;
.bss:0000CA3E                 db    ? ;
.bss:0000CA3F                 db    ? ;
.bss:0000CA40                 db    ? ;
.bss:0000CA41                 db    ? ;
.bss:0000CA42                 db    ? ;
.bss:0000CA43                 db    ? ;
.bss:0000CA44                 db    ? ;
.bss:0000CA45                 db    ? ;
.bss:0000CA46                 db    ? ;
.bss:0000CA47                 db    ? ;
.bss:0000CA48                 db    ? ;
.bss:0000CA49                 db    ? ;
.bss:0000CA4A                 db    ? ;
.bss:0000CA4B                 db    ? ;
.bss:0000CA4C                 db    ? ;
.bss:0000CA4D                 db    ? ;
.bss:0000CA4E                 db    ? ;
.bss:0000CA4F                 db    ? ;
.bss:0000CA50                 db    ? ;
.bss:0000CA51                 db    ? ;
.bss:0000CA52                 db    ? ;
.bss:0000CA53                 db    ? ;
.bss:0000CA54                 db    ? ;
.bss:0000CA55                 db    ? ;
.bss:0000CA56                 db    ? ;
.bss:0000CA57                 db    ? ;
.bss:0000CA58                 db    ? ;
.bss:0000CA59                 db    ? ;
.bss:0000CA5A                 db    ? ;
.bss:0000CA5B                 db    ? ;
.bss:0000CA5C                 db    ? ;
.bss:0000CA5D                 db    ? ;
.bss:0000CA5E                 db    ? ;
.bss:0000CA5F                 db    ? ;
.bss:0000CA60                 db    ? ;
.bss:0000CA61                 db    ? ;
.bss:0000CA62                 db    ? ;
.bss:0000CA63                 db    ? ;
.bss:0000CA64                 db    ? ;
.bss:0000CA65                 db    ? ;
.bss:0000CA66                 db    ? ;
.bss:0000CA67                 db    ? ;
.bss:0000CA68                 db    ? ;
.bss:0000CA69                 db    ? ;
.bss:0000CA6A                 db    ? ;
.bss:0000CA6B                 db    ? ;
.bss:0000CA6C                 db    ? ;
.bss:0000CA6D                 db    ? ;
.bss:0000CA6E                 db    ? ;
.bss:0000CA6F                 db    ? ;
.bss:0000CA70                 db    ? ;
.bss:0000CA71                 db    ? ;
.bss:0000CA72                 db    ? ;
.bss:0000CA73                 db    ? ;
.bss:0000CA74                 db    ? ;
.bss:0000CA75                 db    ? ;
.bss:0000CA76                 db    ? ;
.bss:0000CA77                 db    ? ;
.bss:0000CA78                 db    ? ;
.bss:0000CA79                 db    ? ;
.bss:0000CA7A                 db    ? ;
.bss:0000CA7B                 db    ? ;
.bss:0000CA7C                 db    ? ;
.bss:0000CA7D                 db    ? ;
.bss:0000CA7E                 db    ? ;
.bss:0000CA7F                 db    ? ;
.bss:0000CA80                 db    ? ;
.bss:0000CA81                 db    ? ;
.bss:0000CA82                 db    ? ;
.bss:0000CA83                 db    ? ;
.bss:0000CA84                 db    ? ;
.bss:0000CA85                 db    ? ;
.bss:0000CA86                 db    ? ;
.bss:0000CA87                 db    ? ;
.bss:0000CA88                 db    ? ;
.bss:0000CA89                 db    ? ;
.bss:0000CA8A                 db    ? ;
.bss:0000CA8B                 db    ? ;
.bss:0000CA8C                 db    ? ;
.bss:0000CA8D                 db    ? ;
.bss:0000CA8E                 db    ? ;
.bss:0000CA8F                 db    ? ;
.bss:0000CA90                 db    ? ;
.bss:0000CA91                 db    ? ;
.bss:0000CA92                 db    ? ;
.bss:0000CA93                 db    ? ;
.bss:0000CA94                 db    ? ;
.bss:0000CA95                 db    ? ;
.bss:0000CA96                 db    ? ;
.bss:0000CA97                 db    ? ;
.bss:0000CA98                 db    ? ;
.bss:0000CA99                 db    ? ;
.bss:0000CA9A                 db    ? ;
.bss:0000CA9B                 db    ? ;
.bss:0000CA9C                 db    ? ;
.bss:0000CA9D                 db    ? ;
.bss:0000CA9E                 db    ? ;
.bss:0000CA9F                 db    ? ;
.bss:0000CAA0                 db    ? ;
.bss:0000CAA1                 db    ? ;
.bss:0000CAA2                 db    ? ;
.bss:0000CAA3                 db    ? ;
.bss:0000CAA4                 db    ? ;
.bss:0000CAA5                 db    ? ;
.bss:0000CAA6                 db    ? ;
.bss:0000CAA7                 db    ? ;
.bss:0000CAA8                 db    ? ;
.bss:0000CAA9                 db    ? ;
.bss:0000CAAA                 db    ? ;
.bss:0000CAAB                 db    ? ;
.bss:0000CAAC                 db    ? ;
.bss:0000CAAD                 db    ? ;
.bss:0000CAAE                 db    ? ;
.bss:0000CAAF                 db    ? ;
.bss:0000CAB0                 db    ? ;
.bss:0000CAB1                 db    ? ;
.bss:0000CAB2                 db    ? ;
.bss:0000CAB3                 db    ? ;
.bss:0000CAB4                 db    ? ;
.bss:0000CAB5                 db    ? ;
.bss:0000CAB6                 db    ? ;
.bss:0000CAB7                 db    ? ;
.bss:0000CAB8                 db    ? ;
.bss:0000CAB9                 db    ? ;
.bss:0000CABA                 db    ? ;
.bss:0000CABB                 db    ? ;
.bss:0000CABC                 db    ? ;
.bss:0000CABD                 db    ? ;
.bss:0000CABE                 db    ? ;
.bss:0000CABF                 db    ? ;
.bss:0000CAC0                 db    ? ;
.bss:0000CAC1                 db    ? ;
.bss:0000CAC2                 db    ? ;
.bss:0000CAC3                 db    ? ;
.bss:0000CAC4                 db    ? ;
.bss:0000CAC5                 db    ? ;
.bss:0000CAC6                 db    ? ;
.bss:0000CAC7                 db    ? ;
.bss:0000CAC8                 db    ? ;
.bss:0000CAC9                 db    ? ;
.bss:0000CACA                 db    ? ;
.bss:0000CACB                 db    ? ;
.bss:0000CACC                 db    ? ;
.bss:0000CACD                 db    ? ;
.bss:0000CACE                 db    ? ;
.bss:0000CACF                 db    ? ;
.bss:0000CAD0                 db    ? ;
.bss:0000CAD1                 db    ? ;
.bss:0000CAD2                 db    ? ;
.bss:0000CAD3                 db    ? ;
.bss:0000CAD4                 db    ? ;
.bss:0000CAD5                 db    ? ;
.bss:0000CAD6                 db    ? ;
.bss:0000CAD7                 db    ? ;
.bss:0000CAD8                 db    ? ;
.bss:0000CAD9                 db    ? ;
.bss:0000CADA                 db    ? ;
.bss:0000CADB                 db    ? ;
.bss:0000CADC                 db    ? ;
.bss:0000CADD                 db    ? ;
.bss:0000CADE                 db    ? ;
.bss:0000CADF                 db    ? ;
.bss:0000CAE0                 db    ? ;
.bss:0000CAE1                 db    ? ;
.bss:0000CAE2                 db    ? ;
.bss:0000CAE3                 db    ? ;
.bss:0000CAE4                 db    ? ;
.bss:0000CAE5                 db    ? ;
.bss:0000CAE6                 db    ? ;
.bss:0000CAE7                 db    ? ;
.bss:0000CAE8                 db    ? ;
.bss:0000CAE9                 db    ? ;
.bss:0000CAEA                 db    ? ;
.bss:0000CAEB                 db    ? ;
.bss:0000CAEC                 db    ? ;
.bss:0000CAED                 db    ? ;
.bss:0000CAEE                 db    ? ;
.bss:0000CAEF                 db    ? ;
.bss:0000CAF0                 db    ? ;
.bss:0000CAF1                 db    ? ;
.bss:0000CAF2                 db    ? ;
.bss:0000CAF3                 db    ? ;
.bss:0000CAF4                 db    ? ;
.bss:0000CAF5                 db    ? ;
.bss:0000CAF6                 db    ? ;
.bss:0000CAF7                 db    ? ;
.bss:0000CAF8                 db    ? ;
.bss:0000CAF9                 db    ? ;
.bss:0000CAFA                 db    ? ;
.bss:0000CAFB                 db    ? ;
.bss:0000CAFC                 db    ? ;
.bss:0000CAFD                 db    ? ;
.bss:0000CAFE                 db    ? ;
.bss:0000CAFF                 db    ? ;
.bss:0000CB00                 db    ? ;
.bss:0000CB01                 db    ? ;
.bss:0000CB02                 db    ? ;
.bss:0000CB03                 db    ? ;
.bss:0000CB04                 db    ? ;
.bss:0000CB05                 db    ? ;
.bss:0000CB06                 db    ? ;
.bss:0000CB07                 db    ? ;
.bss:0000CB08                 db    ? ;
.bss:0000CB09                 db    ? ;
.bss:0000CB0A                 db    ? ;
.bss:0000CB0B                 db    ? ;
.bss:0000CB0C                 db    ? ;
.bss:0000CB0D                 db    ? ;
.bss:0000CB0E                 db    ? ;
.bss:0000CB0F                 db    ? ;
.bss:0000CB10                 db    ? ;
.bss:0000CB11                 db    ? ;
.bss:0000CB12                 db    ? ;
.bss:0000CB13                 db    ? ;
.bss:0000CB14                 db    ? ;
.bss:0000CB15                 db    ? ;
.bss:0000CB16                 db    ? ;
.bss:0000CB17                 db    ? ;
.bss:0000CB18                 db    ? ;
.bss:0000CB19                 db    ? ;
.bss:0000CB1A                 db    ? ;
.bss:0000CB1B                 db    ? ;
.bss:0000CB1C                 db    ? ;
.bss:0000CB1D                 db    ? ;
.bss:0000CB1E                 db    ? ;
.bss:0000CB1F                 db    ? ;
.bss:0000CB20                 db    ? ;
.bss:0000CB21                 db    ? ;
.bss:0000CB22                 db    ? ;
.bss:0000CB23                 db    ? ;
.bss:0000CB24                 db    ? ;
.bss:0000CB25                 db    ? ;
.bss:0000CB26                 db    ? ;
.bss:0000CB27                 db    ? ;
.bss:0000CB28                 db    ? ;
.bss:0000CB29                 db    ? ;
.bss:0000CB2A                 db    ? ;
.bss:0000CB2B                 db    ? ;
.bss:0000CB2C                 db    ? ;
.bss:0000CB2D                 db    ? ;
.bss:0000CB2E                 db    ? ;
.bss:0000CB2F                 db    ? ;
.bss:0000CB30                 db    ? ;
.bss:0000CB31                 db    ? ;
.bss:0000CB32                 db    ? ;
.bss:0000CB33                 db    ? ;
.bss:0000CB34                 db    ? ;
.bss:0000CB35                 db    ? ;
.bss:0000CB36                 db    ? ;
.bss:0000CB37                 db    ? ;
.bss:0000CB38                 db    ? ;
.bss:0000CB39                 db    ? ;
.bss:0000CB3A                 db    ? ;
.bss:0000CB3B                 db    ? ;
.bss:0000CB3C                 db    ? ;
.bss:0000CB3D                 db    ? ;
.bss:0000CB3E                 db    ? ;
.bss:0000CB3F                 db    ? ;
.bss:0000CB40                 db    ? ;
.bss:0000CB41                 db    ? ;
.bss:0000CB42                 db    ? ;
.bss:0000CB43                 db    ? ;
.bss:0000CB44                 db    ? ;
.bss:0000CB45                 db    ? ;
.bss:0000CB46                 db    ? ;
.bss:0000CB47                 db    ? ;
.bss:0000CB48                 db    ? ;
.bss:0000CB49                 db    ? ;
.bss:0000CB4A                 db    ? ;
.bss:0000CB4B                 db    ? ;
.bss:0000CB4C                 db    ? ;
.bss:0000CB4D                 db    ? ;
.bss:0000CB4E                 db    ? ;
.bss:0000CB4F                 db    ? ;
.bss:0000CB50                 db    ? ;
.bss:0000CB51                 db    ? ;
.bss:0000CB52                 db    ? ;
.bss:0000CB53                 db    ? ;
.bss:0000CB54                 db    ? ;
.bss:0000CB55                 db    ? ;
.bss:0000CB56                 db    ? ;
.bss:0000CB57                 db    ? ;
.bss:0000CB58                 db    ? ;
.bss:0000CB59                 db    ? ;
.bss:0000CB5A                 db    ? ;
.bss:0000CB5B                 db    ? ;
.bss:0000CB5C                 db    ? ;
.bss:0000CB5D                 db    ? ;
.bss:0000CB5E                 db    ? ;
.bss:0000CB5F                 db    ? ;
.bss:0000CB60                 db    ? ;
.bss:0000CB61                 db    ? ;
.bss:0000CB62                 db    ? ;
.bss:0000CB63                 db    ? ;
.bss:0000CB64                 db    ? ;
.bss:0000CB65                 db    ? ;
.bss:0000CB66                 db    ? ;
.bss:0000CB67                 db    ? ;
.bss:0000CB68                 db    ? ;
.bss:0000CB69                 db    ? ;
.bss:0000CB6A                 db    ? ;
.bss:0000CB6B                 db    ? ;
.bss:0000CB6C                 db    ? ;
.bss:0000CB6D                 db    ? ;
.bss:0000CB6E                 db    ? ;
.bss:0000CB6F                 db    ? ;
.bss:0000CB70                 db    ? ;
.bss:0000CB71                 db    ? ;
.bss:0000CB72                 db    ? ;
.bss:0000CB73                 db    ? ;
.bss:0000CB74                 db    ? ;
.bss:0000CB75                 db    ? ;
.bss:0000CB76                 db    ? ;
.bss:0000CB77                 db    ? ;
.bss:0000CB78                 db    ? ;
.bss:0000CB79                 db    ? ;
.bss:0000CB7A                 db    ? ;
.bss:0000CB7B                 db    ? ;
.bss:0000CB7C                 db    ? ;
.bss:0000CB7D                 db    ? ;
.bss:0000CB7E                 db    ? ;
.bss:0000CB7F                 db    ? ;
.bss:0000CB80                 db    ? ;
.bss:0000CB81                 db    ? ;
.bss:0000CB82                 db    ? ;
.bss:0000CB83                 db    ? ;
.bss:0000CB84                 db    ? ;
.bss:0000CB85                 db    ? ;
.bss:0000CB86                 db    ? ;
.bss:0000CB87                 db    ? ;
.bss:0000CB88                 db    ? ;
.bss:0000CB89                 db    ? ;
.bss:0000CB8A                 db    ? ;
.bss:0000CB8B                 db    ? ;
.bss:0000CB8C                 db    ? ;
.bss:0000CB8D                 db    ? ;
.bss:0000CB8E                 db    ? ;
.bss:0000CB8F                 db    ? ;
.bss:0000CB90                 db    ? ;
.bss:0000CB91                 db    ? ;
.bss:0000CB92                 db    ? ;
.bss:0000CB93                 db    ? ;
.bss:0000CB94                 db    ? ;
.bss:0000CB95                 db    ? ;
.bss:0000CB96                 db    ? ;
.bss:0000CB97                 db    ? ;
.bss:0000CB98                 db    ? ;
.bss:0000CB99                 db    ? ;
.bss:0000CB9A                 db    ? ;
.bss:0000CB9B                 db    ? ;
.bss:0000CB9C                 db    ? ;
.bss:0000CB9D                 db    ? ;
.bss:0000CB9E                 db    ? ;
.bss:0000CB9F                 db    ? ;
.bss:0000CBA0                 db    ? ;
.bss:0000CBA1                 db    ? ;
.bss:0000CBA2                 db    ? ;
.bss:0000CBA3                 db    ? ;
.bss:0000CBA4                 db    ? ;
.bss:0000CBA5                 db    ? ;
.bss:0000CBA6                 db    ? ;
.bss:0000CBA7                 db    ? ;
.bss:0000CBA8                 db    ? ;
.bss:0000CBA9                 db    ? ;
.bss:0000CBAA                 db    ? ;
.bss:0000CBAB                 db    ? ;
.bss:0000CBAC                 db    ? ;
.bss:0000CBAD                 db    ? ;
.bss:0000CBAE                 db    ? ;
.bss:0000CBAF                 db    ? ;
.bss:0000CBB0                 db    ? ;
.bss:0000CBB1                 db    ? ;
.bss:0000CBB2                 db    ? ;
.bss:0000CBB3                 db    ? ;
.bss:0000CBB4                 db    ? ;
.bss:0000CBB5                 db    ? ;
.bss:0000CBB6                 db    ? ;
.bss:0000CBB7                 db    ? ;
.bss:0000CBB8                 db    ? ;
.bss:0000CBB9                 db    ? ;
.bss:0000CBBA                 db    ? ;
.bss:0000CBBB                 db    ? ;
.bss:0000CBBC                 db    ? ;
.bss:0000CBBD                 db    ? ;
.bss:0000CBBE                 db    ? ;
.bss:0000CBBF                 db    ? ;
.bss:0000CBC0                 db    ? ;
.bss:0000CBC1                 db    ? ;
.bss:0000CBC2                 db    ? ;
.bss:0000CBC3                 db    ? ;
.bss:0000CBC4                 db    ? ;
.bss:0000CBC5                 db    ? ;
.bss:0000CBC6                 db    ? ;
.bss:0000CBC7                 db    ? ;
.bss:0000CBC8                 db    ? ;
.bss:0000CBC9                 db    ? ;
.bss:0000CBCA                 db    ? ;
.bss:0000CBCB                 db    ? ;
.bss:0000CBCC                 db    ? ;
.bss:0000CBCD                 db    ? ;
.bss:0000CBCE                 db    ? ;
.bss:0000CBCF                 db    ? ;
.bss:0000CBD0                 db    ? ;
.bss:0000CBD1                 db    ? ;
.bss:0000CBD2                 db    ? ;
.bss:0000CBD3                 db    ? ;
.bss:0000CBD4                 db    ? ;
.bss:0000CBD5                 db    ? ;
.bss:0000CBD6                 db    ? ;
.bss:0000CBD7                 db    ? ;
.bss:0000CBD8                 db    ? ;
.bss:0000CBD9                 db    ? ;
.bss:0000CBDA                 db    ? ;
.bss:0000CBDB                 db    ? ;
.bss:0000CBDC                 db    ? ;
.bss:0000CBDD                 db    ? ;
.bss:0000CBDE                 db    ? ;
.bss:0000CBDF                 db    ? ;
.bss:0000CBE0                 db    ? ;
.bss:0000CBE1                 db    ? ;
.bss:0000CBE2                 db    ? ;
.bss:0000CBE3                 db    ? ;
.bss:0000CBE4                 db    ? ;
.bss:0000CBE5                 db    ? ;
.bss:0000CBE6                 db    ? ;
.bss:0000CBE7                 db    ? ;
.bss:0000CBE8                 db    ? ;
.bss:0000CBE9                 db    ? ;
.bss:0000CBEA                 db    ? ;
.bss:0000CBEB                 db    ? ;
.bss:0000CBEC                 db    ? ;
.bss:0000CBED                 db    ? ;
.bss:0000CBEE                 db    ? ;
.bss:0000CBEF                 db    ? ;
.bss:0000CBF0                 db    ? ;
.bss:0000CBF1                 db    ? ;
.bss:0000CBF2                 db    ? ;
.bss:0000CBF3                 db    ? ;
.bss:0000CBF4                 db    ? ;
.bss:0000CBF5                 db    ? ;
.bss:0000CBF6                 db    ? ;
.bss:0000CBF7                 db    ? ;
.bss:0000CBF8                 db    ? ;
.bss:0000CBF9                 db    ? ;
.bss:0000CBFA                 db    ? ;
.bss:0000CBFB                 db    ? ;
.bss:0000CBFC                 db    ? ;
.bss:0000CBFD                 db    ? ;
.bss:0000CBFE                 db    ? ;
.bss:0000CBFF                 db    ? ;
.bss:0000CC00                 db    ? ;
.bss:0000CC01                 db    ? ;
.bss:0000CC02                 db    ? ;
.bss:0000CC03                 db    ? ;
.bss:0000CC04                 db    ? ;
.bss:0000CC05                 db    ? ;
.bss:0000CC06                 db    ? ;
.bss:0000CC07                 db    ? ;
.bss:0000CC08                 db    ? ;
.bss:0000CC09                 db    ? ;
.bss:0000CC0A                 db    ? ;
.bss:0000CC0B                 db    ? ;
.bss:0000CC0C                 db    ? ;
.bss:0000CC0D                 db    ? ;
.bss:0000CC0E                 db    ? ;
.bss:0000CC0F                 db    ? ;
.bss:0000CC10                 db    ? ;
.bss:0000CC11                 db    ? ;
.bss:0000CC12                 db    ? ;
.bss:0000CC13                 db    ? ;
.bss:0000CC14                 db    ? ;
.bss:0000CC15                 db    ? ;
.bss:0000CC16                 db    ? ;
.bss:0000CC17                 db    ? ;
.bss:0000CC18                 db    ? ;
.bss:0000CC19                 db    ? ;
.bss:0000CC1A                 db    ? ;
.bss:0000CC1B                 db    ? ;
.bss:0000CC1C                 db    ? ;
.bss:0000CC1D                 db    ? ;
.bss:0000CC1E                 db    ? ;
.bss:0000CC1F                 db    ? ;
.bss:0000CC20                 db    ? ;
.bss:0000CC21                 db    ? ;
.bss:0000CC22                 db    ? ;
.bss:0000CC23                 db    ? ;
.bss:0000CC24                 db    ? ;
.bss:0000CC25                 db    ? ;
.bss:0000CC26                 db    ? ;
.bss:0000CC27                 db    ? ;
.bss:0000CC28                 db    ? ;
.bss:0000CC29                 db    ? ;
.bss:0000CC2A                 db    ? ;
.bss:0000CC2B                 db    ? ;
.bss:0000CC2C                 db    ? ;
.bss:0000CC2D                 db    ? ;
.bss:0000CC2E                 db    ? ;
.bss:0000CC2F                 db    ? ;
.bss:0000CC30                 db    ? ;
.bss:0000CC31                 db    ? ;
.bss:0000CC32                 db    ? ;
.bss:0000CC33                 db    ? ;
.bss:0000CC34                 db    ? ;
.bss:0000CC35                 db    ? ;
.bss:0000CC36                 db    ? ;
.bss:0000CC37                 db    ? ;
.bss:0000CC38                 db    ? ;
.bss:0000CC39                 db    ? ;
.bss:0000CC3A                 db    ? ;
.bss:0000CC3B                 db    ? ;
.bss:0000CC3C                 db    ? ;
.bss:0000CC3D                 db    ? ;
.bss:0000CC3E                 db    ? ;
.bss:0000CC3F                 db    ? ;
.bss:0000CC40                 db    ? ;
.bss:0000CC41                 db    ? ;
.bss:0000CC42                 db    ? ;
.bss:0000CC43                 db    ? ;
.bss:0000CC44                 db    ? ;
.bss:0000CC45                 db    ? ;
.bss:0000CC46                 db    ? ;
.bss:0000CC47                 db    ? ;
.bss:0000CC48                 db    ? ;
.bss:0000CC49                 db    ? ;
.bss:0000CC4A                 db    ? ;
.bss:0000CC4B                 db    ? ;
.bss:0000CC4C                 db    ? ;
.bss:0000CC4D                 db    ? ;
.bss:0000CC4E                 db    ? ;
.bss:0000CC4F                 db    ? ;
.bss:0000CC50                 db    ? ;
.bss:0000CC51                 db    ? ;
.bss:0000CC52                 db    ? ;
.bss:0000CC53                 db    ? ;
.bss:0000CC54                 db    ? ;
.bss:0000CC55                 db    ? ;
.bss:0000CC56                 db    ? ;
.bss:0000CC57                 db    ? ;
.bss:0000CC58                 db    ? ;
.bss:0000CC59                 db    ? ;
.bss:0000CC5A                 db    ? ;
.bss:0000CC5B                 db    ? ;
.bss:0000CC5C                 db    ? ;
.bss:0000CC5D                 db    ? ;
.bss:0000CC5E                 db    ? ;
.bss:0000CC5F                 db    ? ;
.bss:0000CC60                 db    ? ;
.bss:0000CC61                 db    ? ;
.bss:0000CC62                 db    ? ;
.bss:0000CC63                 db    ? ;
.bss:0000CC64                 db    ? ;
.bss:0000CC65                 db    ? ;
.bss:0000CC66                 db    ? ;
.bss:0000CC67                 db    ? ;
.bss:0000CC68                 db    ? ;
.bss:0000CC69                 db    ? ;
.bss:0000CC6A                 db    ? ;
.bss:0000CC6B                 db    ? ;
.bss:0000CC6C                 db    ? ;
.bss:0000CC6D                 db    ? ;
.bss:0000CC6E                 db    ? ;
.bss:0000CC6F                 db    ? ;
.bss:0000CC70                 db    ? ;
.bss:0000CC71                 db    ? ;
.bss:0000CC72                 db    ? ;
.bss:0000CC73                 db    ? ;
.bss:0000CC74                 db    ? ;
.bss:0000CC75                 db    ? ;
.bss:0000CC76                 db    ? ;
.bss:0000CC77                 db    ? ;
.bss:0000CC78                 db    ? ;
.bss:0000CC79                 db    ? ;
.bss:0000CC7A                 db    ? ;
.bss:0000CC7B                 db    ? ;
.bss:0000CC7C                 db    ? ;
.bss:0000CC7D                 db    ? ;
.bss:0000CC7E                 db    ? ;
.bss:0000CC7F                 db    ? ;
.bss:0000CC80                 db    ? ;
.bss:0000CC81                 db    ? ;
.bss:0000CC82                 db    ? ;
.bss:0000CC83                 db    ? ;
.bss:0000CC84                 db    ? ;
.bss:0000CC85                 db    ? ;
.bss:0000CC86                 db    ? ;
.bss:0000CC87                 db    ? ;
.bss:0000CC88                 db    ? ;
.bss:0000CC89                 db    ? ;
.bss:0000CC8A                 db    ? ;
.bss:0000CC8B                 db    ? ;
.bss:0000CC8C                 db    ? ;
.bss:0000CC8D                 db    ? ;
.bss:0000CC8E                 db    ? ;
.bss:0000CC8F                 db    ? ;
.bss:0000CC90                 db    ? ;
.bss:0000CC91                 db    ? ;
.bss:0000CC92                 db    ? ;
.bss:0000CC93                 db    ? ;
.bss:0000CC94                 db    ? ;
.bss:0000CC95                 db    ? ;
.bss:0000CC96                 db    ? ;
.bss:0000CC97                 db    ? ;
.bss:0000CC98                 db    ? ;
.bss:0000CC99                 db    ? ;
.bss:0000CC9A                 db    ? ;
.bss:0000CC9B                 db    ? ;
.bss:0000CC9C                 db    ? ;
.bss:0000CC9D                 db    ? ;
.bss:0000CC9E                 db    ? ;
.bss:0000CC9F                 db    ? ;
.bss:0000CCA0                 db    ? ;
.bss:0000CCA1                 db    ? ;
.bss:0000CCA2                 db    ? ;
.bss:0000CCA3                 db    ? ;
.bss:0000CCA4                 db    ? ;
.bss:0000CCA5                 db    ? ;
.bss:0000CCA6                 db    ? ;
.bss:0000CCA7                 db    ? ;
.bss:0000CCA8                 db    ? ;
.bss:0000CCA9                 db    ? ;
.bss:0000CCAA                 db    ? ;
.bss:0000CCAB                 db    ? ;
.bss:0000CCAC                 db    ? ;
.bss:0000CCAD                 db    ? ;
.bss:0000CCAE                 db    ? ;
.bss:0000CCAF                 db    ? ;
.bss:0000CCB0                 db    ? ;
.bss:0000CCB1                 db    ? ;
.bss:0000CCB2                 db    ? ;
.bss:0000CCB3                 db    ? ;
.bss:0000CCB4                 db    ? ;
.bss:0000CCB5                 db    ? ;
.bss:0000CCB6                 db    ? ;
.bss:0000CCB7                 db    ? ;
.bss:0000CCB8                 db    ? ;
.bss:0000CCB9                 db    ? ;
.bss:0000CCBA                 db    ? ;
.bss:0000CCBB                 db    ? ;
.bss:0000CCBC                 db    ? ;
.bss:0000CCBD                 db    ? ;
.bss:0000CCBE                 db    ? ;
.bss:0000CCBF                 db    ? ;
.bss:0000CCC0                 db    ? ;
.bss:0000CCC1                 db    ? ;
.bss:0000CCC2                 db    ? ;
.bss:0000CCC3                 db    ? ;
.bss:0000CCC3 _bss            ends
.bss:0000CCC3
.rdata:0000CCC4 ; ===========================================================================
.rdata:0000CCC4
.rdata:0000CCC4 ; Segment type: Pure data
.rdata:0000CCC4 ; Segment permissions: Read
.rdata:0000CCC4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000CCC4 _rdata          segment para public 'DATA' use32
.rdata:0000CCC4                 assume cs:_rdata
.rdata:0000CCC4                 ;org 0CCC4h
.rdata:0000CCC4 ; COMDAT (pick any)
.rdata:0000CCC4                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000CCC4 ; wchar_t `string'
.rdata:0000CCC4 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000CCC4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+Co
.rdata:0000CCC4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+14o ...
.rdata:0000CCC4                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000CCC4                 unicode 0, <clude\xstring>,0
.rdata:0000CD52                 align 4
.rdata:0000CD52 _rdata          ends
.rdata:0000CD52
.bss:0000CD54 ; ===========================================================================
.bss:0000CD54
.bss:0000CD54 ; Segment type: Uninitialized
.bss:0000CD54 ; Segment permissions: Read/Write
.bss:0000CD54 _bss            segment dword public 'BSS' use32
.bss:0000CD54                 assume cs:_bss
.bss:0000CD54                 ;org 0CD54h
.bss:0000CD54 ; COMDAT (pick any)
.bss:0000CD54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000CD54                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:0000CD54 ; std::locale::id std::numpunct<char>::id
.bss:0000CD54 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:0000CD54                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:0000CD55                 db    ? ;
.bss:0000CD56                 db    ? ;
.bss:0000CD57                 db    ? ;
.bss:0000CD57 _bss            ends
.bss:0000CD57
.bss:0000CD58 ; ===========================================================================
.bss:0000CD58
.bss:0000CD58 ; Segment type: Uninitialized
.bss:0000CD58 ; Segment permissions: Read/Write
.bss:0000CD58 _bss            segment dword public 'BSS' use32
.bss:0000CD58                 assume cs:_bss
.bss:0000CD58                 ;org 0CD58h
.bss:0000CD58 ; COMDAT (pick any)
.bss:0000CD58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000CD58                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:0000CD58 ; std::locale::id std::numpunct<wchar_t>::id
.bss:0000CD58 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:0000CD58                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:0000CD59                 db    ? ;
.bss:0000CD5A                 db    ? ;
.bss:0000CD5B                 db    ? ;
.bss:0000CD5B _bss            ends
.bss:0000CD5B
.rdata:0000CD5C ; ===========================================================================
.rdata:0000CD5C
.rdata:0000CD5C ; Segment type: Pure data
.rdata:0000CD5C ; Segment permissions: Read
.rdata:0000CD5C _rdata          segment dword public 'DATA' use32
.rdata:0000CD5C                 assume cs:_rdata
.rdata:0000CD5C                 ;org 0CD5Ch
.rdata:0000CD5C ; COMDAT (pick any)
.rdata:0000CD5C                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:0000CD5C ; `string'
.rdata:0000CD5C ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:0000CD5C                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+53o
.rdata:0000CD5C _rdata          ends
.rdata:0000CD5C
.rdata:0000CD80 ; ===========================================================================
.rdata:0000CD80
.rdata:0000CD80 ; Segment type: Pure data
.rdata:0000CD80 ; Segment permissions: Read
.rdata:0000CD80 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000CD80 _rdata          segment para public 'DATA' use32
.rdata:0000CD80                 assume cs:_rdata
.rdata:0000CD80                 ;org 0CD80h
.rdata:0000CD80 ; COMDAT (pick any)
.rdata:0000CD80                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:0000CD80 ; `string'
.rdata:0000CD80 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:0000CD80                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void):loc_77A4o
.rdata:0000CD80                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:0000CDD6                 align 4
.rdata:0000CDD6 _rdata          ends
.rdata:0000CDD6
.rdata:0000CDD8 ; ===========================================================================
.rdata:0000CDD8
.rdata:0000CDD8 ; Segment type: Pure data
.rdata:0000CDD8 ; Segment permissions: Read
.rdata:0000CDD8 _rdata          segment dword public 'DATA' use32
.rdata:0000CDD8                 assume cs:_rdata
.rdata:0000CDD8                 ;org 0CDD8h
.rdata:0000CDD8 ; COMDAT (pick any)
.rdata:0000CDD8                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:0000CDD8 ; `string'
.rdata:0000CDD8 ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:0000CDD8                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+65o
.rdata:0000CDD8                 unicode 0, <%s>,0
.rdata:0000CDDE                 align 10h
.rdata:0000CDDE _rdata          ends
.rdata:0000CDDE
.rdata:0000CDE0 ; ===========================================================================
.rdata:0000CDE0
.rdata:0000CDE0 ; Segment type: Pure data
.rdata:0000CDE0 ; Segment permissions: Read
.rdata:0000CDE0 _rdata          segment dword public 'DATA' use32
.rdata:0000CDE0                 assume cs:_rdata
.rdata:0000CDE0                 ;org 0CDE0h
.rdata:0000CDE0 ; COMDAT (pick any)
.rdata:0000CDE0                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:0000CDE0 ; `string'
.rdata:0000CDE0 ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:0000CDE0                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+97o
.rdata:0000CDE0                 unicode 0, <"out of range">,0
.rdata:0000CDFE                 align 10h
.rdata:0000CDFE _rdata          ends
.rdata:0000CDFE
.rdata:0000CE00 ; ===========================================================================
.rdata:0000CE00
.rdata:0000CE00 ; Segment type: Pure data
.rdata:0000CE00 ; Segment permissions: Read
.rdata:0000CE00 _rdata          segment dword public 'DATA' use32
.rdata:0000CE00                 assume cs:_rdata
.rdata:0000CE00                 ;org 0CE00h
.rdata:0000CE00 ; COMDAT (pick any)
.rdata:0000CE00                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000CE00 ; char `string'[]
.rdata:0000CE00 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000CE00                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000CE00                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:0000CE00 _rdata          ends
.rdata:0000CE00
.rdata:0000CE18 ; ===========================================================================
.rdata:0000CE18
.rdata:0000CE18 ; Segment type: Pure data
.rdata:0000CE18 ; Segment permissions: Read
.rdata:0000CE18 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000CE18 _rdata          segment para public 'DATA' use32
.rdata:0000CE18                 assume cs:_rdata
.rdata:0000CE18                 ;org 0CE18h
.rdata:0000CE18 ; COMDAT (pick any)
.rdata:0000CE18                 public ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000CE18 ; wchar_t `string'
.rdata:0000CE18 ??_C@_1IK@CIFBAAFK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000CE18                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+41o
.rdata:0000CE18                                         ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+71o ...
.rdata:0000CE18                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000CE18                 unicode 0, <clude\deque>,0
.rdata:0000CEA2                 align 4
.rdata:0000CEA2 _rdata          ends
.rdata:0000CEA2
.rdata:0000CEA4 ; ===========================================================================
.rdata:0000CEA4
.rdata:0000CEA4 ; Segment type: Pure data
.rdata:0000CEA4 ; Segment permissions: Read
.rdata:0000CEA4 _rdata          segment dword public 'DATA' use32
.rdata:0000CEA4                 assume cs:_rdata
.rdata:0000CEA4                 ;org 0CEA4h
.rdata:0000CEA4 ; COMDAT (pick any)
.rdata:0000CEA4                 public ??_C@_1CO@FNIDKHMC@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@
.rdata:0000CEA4 ; wchar_t `string'
.rdata:0000CEA4 ??_C@_1CO@FNIDKHMC@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?5?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA?5?$AAp?$AAo?$AAp?$AA?$AA@:
.rdata:0000CEA4                                         ; DATA XREF: std::deque<uint,std::allocator<uint>>::pop_back(void)+23o
.rdata:0000CEA4                 unicode 0, <deque empty before pop>,0
.rdata:0000CED2                 align 4
.rdata:0000CED2 _rdata          ends
.rdata:0000CED2
.rdata:0000CED4 ; ===========================================================================
.rdata:0000CED4
.rdata:0000CED4 ; Segment type: Pure data
.rdata:0000CED4 ; Segment permissions: Read
.rdata:0000CED4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000CED4 _rdata          segment para public 'DATA' use32
.rdata:0000CED4                 assume cs:_rdata
.rdata:0000CED4                 ;org 0CED4h
.rdata:0000CED4 ; COMDAT (pick any)
.rdata:0000CED4                 public ??_C@_1EE@INPCGGNP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl@
.rdata:0000CED4 ; wchar_t `string'
.rdata:0000CED4 ??_C@_1EE@INPCGGNP@?$AAd?$AAe?$AAq?$AAu?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb?$AAl@:
.rdata:0000CED4                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+46o
.rdata:0000CED4                 unicode 0, <deque iterator not dereferencable>,0
.rdata:0000CED4 _rdata          ends
.rdata:0000CED4
.rdata:0000CF18 ; ===========================================================================
.rdata:0000CF18
.rdata:0000CF18 ; Segment type: Pure data
.rdata:0000CF18 ; Segment permissions: Read
.rdata:0000CF18 _rdata          segment dword public 'DATA' use32
.rdata:0000CF18                 assume cs:_rdata
.rdata:0000CF18                 ;org 0CF18h
.rdata:0000CF18 ; COMDAT (pick any)
.rdata:0000CF18                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000CF18 ; char `string'[]
.rdata:0000CF18 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000CF18                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000CF18                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:0000CF18 _rdata          ends
.rdata:0000CF18
.rdata:0000CF28 ; ===========================================================================
.rdata:0000CF28
.rdata:0000CF28 ; Segment type: Pure data
.rdata:0000CF28 ; Segment permissions: Read
.rdata:0000CF28 _rdata          segment dword public 'DATA' use32
.rdata:0000CF28                 assume cs:_rdata
.rdata:0000CF28                 ;org 0CF28h
.rdata:0000CF28 ; COMDAT (pick any)
.rdata:0000CF28                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:0000CF28 ; char `string'[]
.rdata:0000CF28 ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:0000CF28                                         ; DATA XREF: std::vector<MenuItemUnit,std::allocator<MenuItemUnit>>::_Xlen(void)+7o
.rdata:0000CF28                                         ; std::vector<recordedMacroStep,std::allocator<recordedMacroStep>>::_Xlen(void)+7o
.rdata:0000CF3B                 align 4
.rdata:0000CF3B _rdata          ends
.rdata:0000CF3B
.rdata:0000CF3C ; ===========================================================================
.rdata:0000CF3C
.rdata:0000CF3C ; Segment type: Pure data
.rdata:0000CF3C ; Segment permissions: Read
.rdata:0000CF3C _rdata          segment dword public 'DATA' use32
.rdata:0000CF3C                 assume cs:_rdata
.rdata:0000CF3C                 ;org 0CF3Ch
.rdata:0000CF3C ; COMDAT (pick any)
.rdata:0000CF3C                 public ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
.rdata:0000CF3C ; char `string'[]
.rdata:0000CF3C ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ db 'deque<T> too long',0
.rdata:0000CF3C                                         ; DATA XREF: std::deque<uint,std::allocator<uint>>::_Xlen(void)+7o
.rdata:0000CF4E                 align 10h
.rdata:0000CF4E _rdata          ends
.rdata:0000CF4E
.rdata:0000CF50 ; ===========================================================================
.rdata:0000CF50
.rdata:0000CF50 ; Segment type: Pure data
.rdata:0000CF50 ; Segment permissions: Read
.rdata:0000CF50 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000CF50 _rdata          segment para public 'DATA' use32
.rdata:0000CF50                 assume cs:_rdata
.rdata:0000CF50                 ;org 0CF50h
.rdata:0000CF50 ; COMDAT (pick any)
.rdata:0000CF50                 public ??_C@_1NO@MNBGKAMN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@
.rdata:0000CF50 ; `string'
.rdata:0000CF50 ??_C@_1NO@MNBGKAMN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAq?$AAu?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs@:
.rdata:0000CF50                                         ; DATA XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+92o
.rdata:0000CF50                 unicode 0, <std::_Deque_const_iterator>
.rdata:0000CF50                 dw 3Ch
.rdata:0000CF50                 unicode 0, <class std::_Deque_val>
.rdata:0000CF50                 dw 3Ch
.rdata:0000CF50                 unicode 0, <struct std::_Deque_simple_types>
.rdata:0000CF50                 dw 3Ch
.rdata:0000CF50                 unicode 0, <unsigned int>
.rdata:0000CF50                 dw 3Eh
.rdata:0000CF50                 unicode 0, < >
.rdata:0000CF50                 dw 3Eh
.rdata:0000CF50                 unicode 0, < >
.rdata:0000CF50                 dw 3Eh
.rdata:0000CF50                 unicode 0, <::operator *>,0
.rdata:0000D02E                 align 10h
.rdata:0000D02E _rdata          ends
.rdata:0000D02E
.rdata:0000D030 ; ===========================================================================
.rdata:0000D030
.rdata:0000D030 ; Segment type: Pure data
.rdata:0000D030 ; Segment permissions: Read
.rdata:0000D030 _rdata          segment dword public 'DATA' use32
.rdata:0000D030                 assume cs:_rdata
.rdata:0000D030                 ;org 0D030h
.rdata:0000D030 ; COMDAT (pick any)
.rdata:0000D030                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:0000D030 ; wchar_t `string'
.rdata:0000D030 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:0000D030                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:0000D030                                         ; std::_Debug_pointer<uint *>(uint * *,wchar_t const *,uint)+11o ...
.rdata:0000D030                 unicode 0, <invalid null pointer>,0
.rdata:0000D05A                 align 4
.rdata:0000D05A _rdata          ends
.rdata:0000D05A
.rdata:0000D05C ; ===========================================================================
.rdata:0000D05C
.rdata:0000D05C ; Segment type: Pure data
.rdata:0000D05C ; Segment permissions: Read
.rdata:0000D05C _rdata          segment dword public 'DATA' use32
.rdata:0000D05C                 assume cs:_rdata
.rdata:0000D05C                 ;org 0D05Ch
.rdata:0000D05C ; COMDAT (pick any)
.rdata:0000D05C                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000D05C ; wchar_t `string'
.rdata:0000D05C ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000D05C                                         ; DATA XREF: std::_Debug_range2<uint * *>(uint * *,uint * *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:0000D05C                                         ; std::_Debug_range2<MenuItemUnit *>(MenuItemUnit *,MenuItemUnit *,wchar_t const *,uint,std::random_access_iterator_tag)+43o ...
.rdata:0000D05C                 unicode 0, <invalid iterator range>,0
.rdata:0000D08A                 align 4
.rdata:0000D08A _rdata          ends
.rdata:0000D08A
.rdata:0000D08C ; ===========================================================================
.rdata:0000D08C
.rdata:0000D08C ; Segment type: Pure data
.rdata:0000D08C ; Segment permissions: Read
.rdata:0000D08C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000D08C _rdata          segment para public 'DATA' use32
.rdata:0000D08C                 assume cs:_rdata
.rdata:0000D08C                 ;org 0D08Ch
.rdata:0000D08C ; COMDAT (pick any)
.rdata:0000D08C                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000D08C ; wchar_t `string'
.rdata:0000D08C ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000D08C                                         ; DATA XREF: std::_Uninit_copy<uint *,uint *>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &,std::_Scalar_ptr_iterator_tag)+9o
.rdata:0000D08C                                         ; std::_Uninit_copy<uint *,uint *>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &,std::_Scalar_ptr_iterator_tag)+23o ...
.rdata:0000D08C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000D08C                 unicode 0, <clude\xmemory>,0
.rdata:0000D11A                 align 4
.rdata:0000D11A _rdata          ends
.rdata:0000D11A
.rdata$r:0000D11C ; ===========================================================================
.rdata$r:0000D11C
.rdata$r:0000D11C ; Segment type: Pure data
.rdata$r:0000D11C ; Segment permissions: Read
.rdata$r:0000D11C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D11C                 assume cs:_rdata$r
.rdata$r:0000D11C                 ;org 0D11Ch
.rdata$r:0000D11C ; COMDAT (pick any)
.rdata$r:0000D11C                 public ??_R4error_category@std@@6B@
.rdata$r:0000D11C ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:0000D11C ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:0000C3F4o
.rdata$r:0000D11D                 db    0
.rdata$r:0000D11E                 db    0
.rdata$r:0000D11F                 db    0
.rdata$r:0000D120                 db    0
.rdata$r:0000D121                 db    0
.rdata$r:0000D122                 db    0
.rdata$r:0000D123                 db    0
.rdata$r:0000D124                 db    0
.rdata$r:0000D125                 db    0
.rdata$r:0000D126                 db    0
.rdata$r:0000D127                 db    0
.rdata$r:0000D128                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000D12C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000D12C _rdata$r        ends
.rdata$r:0000D12C
.data$r:0000D130 ; ===========================================================================
.data$r:0000D130
.data$r:0000D130 ; Segment type: Pure data
.data$r:0000D130 ; Segment permissions: Read/Write
.data$r:0000D130 _data$r         segment dword public 'DATA' use32
.data$r:0000D130                 assume cs:_data$r
.data$r:0000D130                 ;org 0D130h
.data$r:0000D130 ; COMDAT (pick any)
.data$r:0000D130                 public ??_R0?AVerror_category@std@@@8
.data$r:0000D130 ; class std::error_category `RTTI Type Descriptor'
.data$r:0000D130 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000D130                                         ; DATA XREF: .rdata$r:0000D128o
.data$r:0000D130                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000D130                                         ; const type_info::`vftable'
.data$r:0000D134                 align 8
.data$r:0000D138 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:0000D151                 align 4
.data$r:0000D151 _data$r         ends
.data$r:0000D151
.rdata$r:0000D154 ; ===========================================================================
.rdata$r:0000D154
.rdata$r:0000D154 ; Segment type: Pure data
.rdata$r:0000D154 ; Segment permissions: Read
.rdata$r:0000D154 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D154                 assume cs:_rdata$r
.rdata$r:0000D154                 ;org 0D154h
.rdata$r:0000D154 ; COMDAT (pick any)
.rdata$r:0000D154                 public ??_R3error_category@std@@8
.rdata$r:0000D154 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000D154 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:0000D12Co
.rdata$r:0000D154                                         ; .rdata$r:0000D184o
.rdata$r:0000D155                 db    0
.rdata$r:0000D156                 db    0
.rdata$r:0000D157                 db    0
.rdata$r:0000D158                 db    0
.rdata$r:0000D159                 db    0
.rdata$r:0000D15A                 db    0
.rdata$r:0000D15B                 db    0
.rdata$r:0000D15C                 db    1
.rdata$r:0000D15D                 db    0
.rdata$r:0000D15E                 db    0
.rdata$r:0000D15F                 db    0
.rdata$r:0000D160                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000D160 _rdata$r        ends
.rdata$r:0000D160
.rdata$r:0000D164 ; ===========================================================================
.rdata$r:0000D164
.rdata$r:0000D164 ; Segment type: Pure data
.rdata$r:0000D164 ; Segment permissions: Read
.rdata$r:0000D164 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D164                 assume cs:_rdata$r
.rdata$r:0000D164                 ;org 0D164h
.rdata$r:0000D164 ; COMDAT (pick any)
.rdata$r:0000D164                 public ??_R2error_category@std@@8
.rdata$r:0000D164 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000D164 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000D164                                         ; DATA XREF: .rdata$r:0000D160o
.rdata$r:0000D164                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000D168                 db    0
.rdata$r:0000D169                 align 4
.rdata$r:0000D169 _rdata$r        ends
.rdata$r:0000D169
.rdata$r:0000D16C ; ===========================================================================
.rdata$r:0000D16C
.rdata$r:0000D16C ; Segment type: Pure data
.rdata$r:0000D16C ; Segment permissions: Read
.rdata$r:0000D16C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D16C                 assume cs:_rdata$r
.rdata$r:0000D16C                 ;org 0D16Ch
.rdata$r:0000D16C ; COMDAT (pick any)
.rdata$r:0000D16C                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000D16C ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000D16C ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:0000D16C                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:0000D16C                                         ; .rdata$r:0000D1DCo ...
.rdata$r:0000D16C                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000D170                 db    0
.rdata$r:0000D171                 db    0
.rdata$r:0000D172                 db    0
.rdata$r:0000D173                 db    0
.rdata$r:0000D174                 db    0
.rdata$r:0000D175                 db    0
.rdata$r:0000D176                 db    0
.rdata$r:0000D177                 db    0
.rdata$r:0000D178                 db 0FFh
.rdata$r:0000D179                 db 0FFh
.rdata$r:0000D17A                 db 0FFh
.rdata$r:0000D17B                 db 0FFh
.rdata$r:0000D17C                 db    0
.rdata$r:0000D17D                 db    0
.rdata$r:0000D17E                 db    0
.rdata$r:0000D17F                 db    0
.rdata$r:0000D180                 db  40h ; @
.rdata$r:0000D181                 db    0
.rdata$r:0000D182                 db    0
.rdata$r:0000D183                 db    0
.rdata$r:0000D184                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000D184 _rdata$r        ends
.rdata$r:0000D184
.rdata$r:0000D188 ; ===========================================================================
.rdata$r:0000D188
.rdata$r:0000D188 ; Segment type: Pure data
.rdata$r:0000D188 ; Segment permissions: Read
.rdata$r:0000D188 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D188                 assume cs:_rdata$r
.rdata$r:0000D188                 ;org 0D188h
.rdata$r:0000D188 ; COMDAT (pick any)
.rdata$r:0000D188                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:0000D188 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:0000D188 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:0000D188                                         ; DATA XREF: .rdata:0000C410o
.rdata$r:0000D189                 db    0
.rdata$r:0000D18A                 db    0
.rdata$r:0000D18B                 db    0
.rdata$r:0000D18C                 db    0
.rdata$r:0000D18D                 db    0
.rdata$r:0000D18E                 db    0
.rdata$r:0000D18F                 db    0
.rdata$r:0000D190                 db    0
.rdata$r:0000D191                 db    0
.rdata$r:0000D192                 db    0
.rdata$r:0000D193                 db    0
.rdata$r:0000D194                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000D198                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000D198 _rdata$r        ends
.rdata$r:0000D198
.data$r:0000D19C ; ===========================================================================
.data$r:0000D19C
.data$r:0000D19C ; Segment type: Pure data
.data$r:0000D19C ; Segment permissions: Read/Write
.data$r:0000D19C _data$r         segment dword public 'DATA' use32
.data$r:0000D19C                 assume cs:_data$r
.data$r:0000D19C                 ;org 0D19Ch
.data$r:0000D19C ; COMDAT (pick any)
.data$r:0000D19C                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:0000D19C ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:0000D19C ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000D19C                                         ; DATA XREF: .rdata$r:0000D194o
.data$r:0000D19C                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000D19C                                         ; const type_info::`vftable'
.data$r:0000D1A0                 db    0
.data$r:0000D1A1                 db    0
.data$r:0000D1A2                 db    0
.data$r:0000D1A3                 db    0
.data$r:0000D1A4                 db  2Eh ; .
.data$r:0000D1A5                 db  3Fh ; ?
.data$r:0000D1A6                 db  41h ; A
.data$r:0000D1A7                 db  56h ; V
.data$r:0000D1A8                 db  5Fh ; _
.data$r:0000D1A9                 db  47h ; G
.data$r:0000D1AA                 db  65h ; e
.data$r:0000D1AB                 db  6Eh ; n
.data$r:0000D1AC                 db  65h ; e
.data$r:0000D1AD                 db  72h ; r
.data$r:0000D1AE                 db  69h ; i
.data$r:0000D1AF                 db  63h ; c
.data$r:0000D1B0                 db  5Fh ; _
.data$r:0000D1B1                 db  65h ; e
.data$r:0000D1B2                 db  72h ; r
.data$r:0000D1B3                 db  72h ; r
.data$r:0000D1B4                 db  6Fh ; o
.data$r:0000D1B5                 db  72h ; r
.data$r:0000D1B6                 db  5Fh ; _
.data$r:0000D1B7                 db  63h ; c
.data$r:0000D1B8                 db  61h ; a
.data$r:0000D1B9                 db  74h ; t
.data$r:0000D1BA                 db  65h ; e
.data$r:0000D1BB                 db  67h ; g
.data$r:0000D1BC                 db  6Fh ; o
.data$r:0000D1BD                 db  72h ; r
.data$r:0000D1BE                 db  79h ; y
.data$r:0000D1BF                 db  40h ; @
.data$r:0000D1C0                 db  73h ; s
.data$r:0000D1C1                 db  74h ; t
.data$r:0000D1C2                 db  64h ; d
.data$r:0000D1C3                 db  40h ; @
.data$r:0000D1C4                 db  40h ; @
.data$r:0000D1C5                 db    0
.data$r:0000D1C6                 align 4
.data$r:0000D1C6 _data$r         ends
.data$r:0000D1C6
.rdata$r:0000D1C8 ; ===========================================================================
.rdata$r:0000D1C8
.rdata$r:0000D1C8 ; Segment type: Pure data
.rdata$r:0000D1C8 ; Segment permissions: Read
.rdata$r:0000D1C8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D1C8                 assume cs:_rdata$r
.rdata$r:0000D1C8                 ;org 0D1C8h
.rdata$r:0000D1C8 ; COMDAT (pick any)
.rdata$r:0000D1C8                 public ??_R3_Generic_error_category@std@@8
.rdata$r:0000D1C8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000D1C8 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:0000D1C8                                         ; DATA XREF: .rdata$r:0000D198o
.rdata$r:0000D1C8                                         ; .rdata$r:0000D1FCo
.rdata$r:0000D1C9                 db    0
.rdata$r:0000D1CA                 db    0
.rdata$r:0000D1CB                 db    0
.rdata$r:0000D1CC                 db    0
.rdata$r:0000D1CD                 db    0
.rdata$r:0000D1CE                 db    0
.rdata$r:0000D1CF                 db    0
.rdata$r:0000D1D0                 db    2
.rdata$r:0000D1D1                 db    0
.rdata$r:0000D1D2                 db    0
.rdata$r:0000D1D3                 db    0
.rdata$r:0000D1D4                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000D1D4 _rdata$r        ends
.rdata$r:0000D1D4
.rdata$r:0000D1D8 ; ===========================================================================
.rdata$r:0000D1D8
.rdata$r:0000D1D8 ; Segment type: Pure data
.rdata$r:0000D1D8 ; Segment permissions: Read
.rdata$r:0000D1D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D1D8                 assume cs:_rdata$r
.rdata$r:0000D1D8                 ;org 0D1D8h
.rdata$r:0000D1D8 ; COMDAT (pick any)
.rdata$r:0000D1D8                 public ??_R2_Generic_error_category@std@@8
.rdata$r:0000D1D8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000D1D8 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000D1D8                                         ; DATA XREF: .rdata$r:0000D1D4o
.rdata$r:0000D1D8                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000D1DC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000D1E0                 db    0
.rdata$r:0000D1E1                 align 4
.rdata$r:0000D1E1 _rdata$r        ends
.rdata$r:0000D1E1
.rdata$r:0000D1E4 ; ===========================================================================
.rdata$r:0000D1E4
.rdata$r:0000D1E4 ; Segment type: Pure data
.rdata$r:0000D1E4 ; Segment permissions: Read
.rdata$r:0000D1E4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D1E4                 assume cs:_rdata$r
.rdata$r:0000D1E4                 ;org 0D1E4h
.rdata$r:0000D1E4 ; COMDAT (pick any)
.rdata$r:0000D1E4                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000D1E4 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000D1E4 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0000D1E4                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0000D1E4                                         ; .rdata$r:0000D254o ...
.rdata$r:0000D1E4                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000D1E8                 db    1
.rdata$r:0000D1E9                 db    0
.rdata$r:0000D1EA                 db    0
.rdata$r:0000D1EB                 db    0
.rdata$r:0000D1EC                 db    0
.rdata$r:0000D1ED                 db    0
.rdata$r:0000D1EE                 db    0
.rdata$r:0000D1EF                 db    0
.rdata$r:0000D1F0                 db 0FFh
.rdata$r:0000D1F1                 db 0FFh
.rdata$r:0000D1F2                 db 0FFh
.rdata$r:0000D1F3                 db 0FFh
.rdata$r:0000D1F4                 db    0
.rdata$r:0000D1F5                 db    0
.rdata$r:0000D1F6                 db    0
.rdata$r:0000D1F7                 db    0
.rdata$r:0000D1F8                 db  40h ; @
.rdata$r:0000D1F9                 db    0
.rdata$r:0000D1FA                 db    0
.rdata$r:0000D1FB                 db    0
.rdata$r:0000D1FC                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000D1FC _rdata$r        ends
.rdata$r:0000D1FC
.rdata$r:0000D200 ; ===========================================================================
.rdata$r:0000D200
.rdata$r:0000D200 ; Segment type: Pure data
.rdata$r:0000D200 ; Segment permissions: Read
.rdata$r:0000D200 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D200                 assume cs:_rdata$r
.rdata$r:0000D200                 ;org 0D200h
.rdata$r:0000D200 ; COMDAT (pick any)
.rdata$r:0000D200                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:0000D200 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:0000D200 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:0000D200                                         ; DATA XREF: .rdata:0000C444o
.rdata$r:0000D201                 db    0
.rdata$r:0000D202                 db    0
.rdata$r:0000D203                 db    0
.rdata$r:0000D204                 db    0
.rdata$r:0000D205                 db    0
.rdata$r:0000D206                 db    0
.rdata$r:0000D207                 db    0
.rdata$r:0000D208                 db    0
.rdata$r:0000D209                 db    0
.rdata$r:0000D20A                 db    0
.rdata$r:0000D20B                 db    0
.rdata$r:0000D20C                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000D210                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000D210 _rdata$r        ends
.rdata$r:0000D210
.data$r:0000D214 ; ===========================================================================
.data$r:0000D214
.data$r:0000D214 ; Segment type: Pure data
.data$r:0000D214 ; Segment permissions: Read/Write
.data$r:0000D214 _data$r         segment dword public 'DATA' use32
.data$r:0000D214                 assume cs:_data$r
.data$r:0000D214                 ;org 0D214h
.data$r:0000D214 ; COMDAT (pick any)
.data$r:0000D214                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000D214 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000D214 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000D214                                         ; DATA XREF: .rdata$r:0000D20Co
.data$r:0000D214                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000D214                                         ; const type_info::`vftable'
.data$r:0000D218                 db    0
.data$r:0000D219                 db    0
.data$r:0000D21A                 db    0
.data$r:0000D21B                 db    0
.data$r:0000D21C                 db  2Eh ; .
.data$r:0000D21D                 db  3Fh ; ?
.data$r:0000D21E                 db  41h ; A
.data$r:0000D21F                 db  56h ; V
.data$r:0000D220                 db  5Fh ; _
.data$r:0000D221                 db  49h ; I
.data$r:0000D222                 db  6Fh ; o
.data$r:0000D223                 db  73h ; s
.data$r:0000D224                 db  74h ; t
.data$r:0000D225                 db  72h ; r
.data$r:0000D226                 db  65h ; e
.data$r:0000D227                 db  61h ; a
.data$r:0000D228                 db  6Dh ; m
.data$r:0000D229                 db  5Fh ; _
.data$r:0000D22A                 db  65h ; e
.data$r:0000D22B                 db  72h ; r
.data$r:0000D22C                 db  72h ; r
.data$r:0000D22D                 db  6Fh ; o
.data$r:0000D22E                 db  72h ; r
.data$r:0000D22F                 db  5Fh ; _
.data$r:0000D230                 db  63h ; c
.data$r:0000D231                 db  61h ; a
.data$r:0000D232                 db  74h ; t
.data$r:0000D233                 db  65h ; e
.data$r:0000D234                 db  67h ; g
.data$r:0000D235                 db  6Fh ; o
.data$r:0000D236                 db  72h ; r
.data$r:0000D237                 db  79h ; y
.data$r:0000D238                 db  40h ; @
.data$r:0000D239                 db  73h ; s
.data$r:0000D23A                 db  74h ; t
.data$r:0000D23B                 db  64h ; d
.data$r:0000D23C                 db  40h ; @
.data$r:0000D23D                 db  40h ; @
.data$r:0000D23E                 db    0
.data$r:0000D23F                 align 10h
.data$r:0000D23F _data$r         ends
.data$r:0000D23F
.rdata$r:0000D240 ; ===========================================================================
.rdata$r:0000D240
.rdata$r:0000D240 ; Segment type: Pure data
.rdata$r:0000D240 ; Segment permissions: Read
.rdata$r:0000D240 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D240                 assume cs:_rdata$r
.rdata$r:0000D240                 ;org 0D240h
.rdata$r:0000D240 ; COMDAT (pick any)
.rdata$r:0000D240                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:0000D240 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000D240 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:0000D240                                         ; DATA XREF: .rdata$r:0000D210o
.rdata$r:0000D240                                         ; .rdata$r:0000D278o
.rdata$r:0000D241                 db    0
.rdata$r:0000D242                 db    0
.rdata$r:0000D243                 db    0
.rdata$r:0000D244                 db    0
.rdata$r:0000D245                 db    0
.rdata$r:0000D246                 db    0
.rdata$r:0000D247                 db    0
.rdata$r:0000D248                 db    3
.rdata$r:0000D249                 db    0
.rdata$r:0000D24A                 db    0
.rdata$r:0000D24B                 db    0
.rdata$r:0000D24C                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000D24C _rdata$r        ends
.rdata$r:0000D24C
.rdata$r:0000D250 ; ===========================================================================
.rdata$r:0000D250
.rdata$r:0000D250 ; Segment type: Pure data
.rdata$r:0000D250 ; Segment permissions: Read
.rdata$r:0000D250 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D250                 assume cs:_rdata$r
.rdata$r:0000D250                 ;org 0D250h
.rdata$r:0000D250 ; COMDAT (pick any)
.rdata$r:0000D250                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:0000D250 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000D250 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000D250                                         ; DATA XREF: .rdata$r:0000D24Co
.rdata$r:0000D250                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000D254                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000D258                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000D25C                 db    0
.rdata$r:0000D25D                 align 10h
.rdata$r:0000D25D _rdata$r        ends
.rdata$r:0000D25D
.rdata$r:0000D260 ; ===========================================================================
.rdata$r:0000D260
.rdata$r:0000D260 ; Segment type: Pure data
.rdata$r:0000D260 ; Segment permissions: Read
.rdata$r:0000D260 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D260                 assume cs:_rdata$r
.rdata$r:0000D260                 ;org 0D260h
.rdata$r:0000D260 ; COMDAT (pick any)
.rdata$r:0000D260                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000D260 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000D260 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:0000D260                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:0000D260                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000D264                 db    2
.rdata$r:0000D265                 db    0
.rdata$r:0000D266                 db    0
.rdata$r:0000D267                 db    0
.rdata$r:0000D268                 db    0
.rdata$r:0000D269                 db    0
.rdata$r:0000D26A                 db    0
.rdata$r:0000D26B                 db    0
.rdata$r:0000D26C                 db 0FFh
.rdata$r:0000D26D                 db 0FFh
.rdata$r:0000D26E                 db 0FFh
.rdata$r:0000D26F                 db 0FFh
.rdata$r:0000D270                 db    0
.rdata$r:0000D271                 db    0
.rdata$r:0000D272                 db    0
.rdata$r:0000D273                 db    0
.rdata$r:0000D274                 db  40h ; @
.rdata$r:0000D275                 db    0
.rdata$r:0000D276                 db    0
.rdata$r:0000D277                 db    0
.rdata$r:0000D278                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000D278 _rdata$r        ends
.rdata$r:0000D278
.rdata$r:0000D27C ; ===========================================================================
.rdata$r:0000D27C
.rdata$r:0000D27C ; Segment type: Pure data
.rdata$r:0000D27C ; Segment permissions: Read
.rdata$r:0000D27C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D27C                 assume cs:_rdata$r
.rdata$r:0000D27C                 ;org 0D27Ch
.rdata$r:0000D27C ; COMDAT (pick any)
.rdata$r:0000D27C                 public ??_R4_System_error_category@std@@6B@
.rdata$r:0000D27C ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:0000D27C ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000C484o
.rdata$r:0000D27D                 db    0
.rdata$r:0000D27E                 db    0
.rdata$r:0000D27F                 db    0
.rdata$r:0000D280                 db    0
.rdata$r:0000D281                 db    0
.rdata$r:0000D282                 db    0
.rdata$r:0000D283                 db    0
.rdata$r:0000D284                 db    0
.rdata$r:0000D285                 db    0
.rdata$r:0000D286                 db    0
.rdata$r:0000D287                 db    0
.rdata$r:0000D288                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000D28C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000D28C _rdata$r        ends
.rdata$r:0000D28C
.data$r:0000D290 ; ===========================================================================
.data$r:0000D290
.data$r:0000D290 ; Segment type: Pure data
.data$r:0000D290 ; Segment permissions: Read/Write
.data$r:0000D290 _data$r         segment dword public 'DATA' use32
.data$r:0000D290                 assume cs:_data$r
.data$r:0000D290                 ;org 0D290h
.data$r:0000D290 ; COMDAT (pick any)
.data$r:0000D290                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000D290 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000D290 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000D290                                         ; DATA XREF: .rdata$r:0000D288o
.data$r:0000D290                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000D290                                         ; const type_info::`vftable'
.data$r:0000D294                 align 8
.data$r:0000D298 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:0000D2B9                 align 4
.data$r:0000D2B9 _data$r         ends
.data$r:0000D2B9
.rdata$r:0000D2BC ; ===========================================================================
.rdata$r:0000D2BC
.rdata$r:0000D2BC ; Segment type: Pure data
.rdata$r:0000D2BC ; Segment permissions: Read
.rdata$r:0000D2BC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D2BC                 assume cs:_rdata$r
.rdata$r:0000D2BC                 ;org 0D2BCh
.rdata$r:0000D2BC ; COMDAT (pick any)
.rdata$r:0000D2BC                 public ??_R3_System_error_category@std@@8
.rdata$r:0000D2BC ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000D2BC ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:0000D28Co
.rdata$r:0000D2BC                                         ; .rdata$r:0000D2F4o
.rdata$r:0000D2BD                 db    0
.rdata$r:0000D2BE                 db    0
.rdata$r:0000D2BF                 db    0
.rdata$r:0000D2C0                 db    0
.rdata$r:0000D2C1                 db    0
.rdata$r:0000D2C2                 db    0
.rdata$r:0000D2C3                 db    0
.rdata$r:0000D2C4                 db    3
.rdata$r:0000D2C5                 db    0
.rdata$r:0000D2C6                 db    0
.rdata$r:0000D2C7                 db    0
.rdata$r:0000D2C8                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000D2C8 _rdata$r        ends
.rdata$r:0000D2C8
.rdata$r:0000D2CC ; ===========================================================================
.rdata$r:0000D2CC
.rdata$r:0000D2CC ; Segment type: Pure data
.rdata$r:0000D2CC ; Segment permissions: Read
.rdata$r:0000D2CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D2CC                 assume cs:_rdata$r
.rdata$r:0000D2CC                 ;org 0D2CCh
.rdata$r:0000D2CC ; COMDAT (pick any)
.rdata$r:0000D2CC                 public ??_R2_System_error_category@std@@8
.rdata$r:0000D2CC ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000D2CC ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000D2CC                                         ; DATA XREF: .rdata$r:0000D2C8o
.rdata$r:0000D2CC                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000D2D0                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000D2D4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000D2D8                 db    0
.rdata$r:0000D2D9                 align 4
.rdata$r:0000D2D9 _rdata$r        ends
.rdata$r:0000D2D9
.rdata$r:0000D2DC ; ===========================================================================
.rdata$r:0000D2DC
.rdata$r:0000D2DC ; Segment type: Pure data
.rdata$r:0000D2DC ; Segment permissions: Read
.rdata$r:0000D2DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000D2DC                 assume cs:_rdata$r
.rdata$r:0000D2DC                 ;org 0D2DCh
.rdata$r:0000D2DC ; COMDAT (pick any)
.rdata$r:0000D2DC                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000D2DC ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000D2DC ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:0000D2DC                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:0000D2DC                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000D2E0                 db    2
.rdata$r:0000D2E1                 db    0
.rdata$r:0000D2E2                 db    0
.rdata$r:0000D2E3                 db    0
.rdata$r:0000D2E4                 db    0
.rdata$r:0000D2E5                 db    0
.rdata$r:0000D2E6                 db    0
.rdata$r:0000D2E7                 db    0
.rdata$r:0000D2E8                 db 0FFh
.rdata$r:0000D2E9                 db 0FFh
.rdata$r:0000D2EA                 db 0FFh
.rdata$r:0000D2EB                 db 0FFh
.rdata$r:0000D2EC                 db    0
.rdata$r:0000D2ED                 db    0
.rdata$r:0000D2EE                 db    0
.rdata$r:0000D2EF                 db    0
.rdata$r:0000D2F0                 db  40h ; @
.rdata$r:0000D2F1                 db    0
.rdata$r:0000D2F2                 db    0
.rdata$r:0000D2F3                 db    0
.rdata$r:0000D2F4                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000D2F4 _rdata$r        ends
.rdata$r:0000D2F4
.CRT$XCU:0000D2F8 ; ===========================================================================
.CRT$XCU:0000D2F8
.CRT$XCU:0000D2F8 ; Segment type: Pure data
.CRT$XCU:0000D2F8 ; Segment permissions: Read
.CRT$XCU:0000D2F8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000D2F8                 assume cs:_CRT$XCU
.CRT$XCU:0000D2F8                 ;org 0D2F8h
.CRT$XCU:0000D2F8 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:0000D2FC _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:0000D300 _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:0000D304 __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:0000D304 _CRT$XCU        ends
.CRT$XCU:0000D304
.CRT$XCU:0000D308 ; ===========================================================================
.CRT$XCU:0000D308
.CRT$XCU:0000D308 ; Segment type: Pure data
.CRT$XCU:0000D308 ; Segment permissions: Read
.CRT$XCU:0000D308 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000D308                 assume cs:_CRT$XCU
.CRT$XCU:0000D308                 ;org 0D308h
.CRT$XCU:0000D308 ; COMDAT (pick associative to section at C4A8)
.CRT$XCU:0000D308 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:0000D308 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:0000D308 _CRT$XCU        ends
.CRT$XCU:0000D308
.CRT$XCU:0000D30C ; ===========================================================================
.CRT$XCU:0000D30C
.CRT$XCU:0000D30C ; Segment type: Pure data
.CRT$XCU:0000D30C ; Segment permissions: Read
.CRT$XCU:0000D30C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000D30C                 assume cs:_CRT$XCU
.CRT$XCU:0000D30C                 ;org 0D30Ch
.CRT$XCU:0000D30C ; COMDAT (pick associative to section at C4AC)
.CRT$XCU:0000D30C ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000D30C ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000D30C _CRT$XCU        ends
.CRT$XCU:0000D30C
.CRT$XCU:0000D310 ; ===========================================================================
.CRT$XCU:0000D310
.CRT$XCU:0000D310 ; Segment type: Pure data
.CRT$XCU:0000D310 ; Segment permissions: Read
.CRT$XCU:0000D310 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000D310                 assume cs:_CRT$XCU
.CRT$XCU:0000D310                 ;org 0D310h
.CRT$XCU:0000D310 ; COMDAT (pick associative to section at C4B0)
.CRT$XCU:0000D310 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:0000D310 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:0000D310 _CRT$XCU        ends
.CRT$XCU:0000D310
.CRT$XCU:0000D314 ; ===========================================================================
.CRT$XCU:0000D314
.CRT$XCU:0000D314 ; Segment type: Pure data
.CRT$XCU:0000D314 ; Segment permissions: Read
.CRT$XCU:0000D314 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000D314                 assume cs:_CRT$XCU
.CRT$XCU:0000D314                 ;org 0D314h
.CRT$XCU:0000D314 ; COMDAT (pick associative to section at C4B8)
.CRT$XCU:0000D314 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:0000D314 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:0000D314 _CRT$XCU        ends
.CRT$XCU:0000D314
.CRT$XCU:0000D318 ; ===========================================================================
.CRT$XCU:0000D318
.CRT$XCU:0000D318 ; Segment type: Pure data
.CRT$XCU:0000D318 ; Segment permissions: Read
.CRT$XCU:0000D318 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000D318                 assume cs:_CRT$XCU
.CRT$XCU:0000D318                 ;org 0D318h
.CRT$XCU:0000D318 ; COMDAT (pick associative to section at C4BC)
.CRT$XCU:0000D318 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:0000D318 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:0000D318 _CRT$XCU        ends
.CRT$XCU:0000D318
.CRT$XCU:0000D31C ; ===========================================================================
.CRT$XCU:0000D31C
.CRT$XCU:0000D31C ; Segment type: Pure data
.CRT$XCU:0000D31C ; Segment permissions: Read
.CRT$XCU:0000D31C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000D31C                 assume cs:_CRT$XCU
.CRT$XCU:0000D31C                 ;org 0D31Ch
.CRT$XCU:0000D31C ; COMDAT (pick associative to section at CD54)
.CRT$XCU:0000D31C ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000D31C ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000D31C _CRT$XCU        ends
.CRT$XCU:0000D31C
.CRT$XCU:0000D320 ; ===========================================================================
.CRT$XCU:0000D320
.CRT$XCU:0000D320 ; Segment type: Pure data
.CRT$XCU:0000D320 ; Segment permissions: Read
.CRT$XCU:0000D320 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000D320                 assume cs:_CRT$XCU
.CRT$XCU:0000D320                 ;org 0D320h
.CRT$XCU:0000D320 ; COMDAT (pick associative to section at CD58)
.CRT$XCU:0000D320 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:0000D320 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:0000D320 _CRT$XCU        ends
.CRT$XCU:0000D320
UNDEF:0000D330 ; ===========================================================================
UNDEF:0000D330
UNDEF:0000D330 ; Segment type: Externs
UNDEF:0000D330 ; UNDEF
UNDEF:0000D330                 extrn __purecall:near   ; DATA XREF: .rdata:0000C3FCo
UNDEF:0000D330                                         ; .rdata:0000C400o
UNDEF:0000D334 ; void *__cdecl operator new(unsigned int)
UNDEF:0000D334                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:0000D334                                         ; std::_Allocate<uint>(uint,uint *)+23p ...
UNDEF:0000D338 ; void __cdecl operator delete(void *)
UNDEF:0000D338                 extrn ??3@YAXPAX@Z:near ; CODE XREF: MenuItemUnit::`scalar deleting destructor'(uint)+1Bp
UNDEF:0000D338                                         ; std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000D33C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000D33C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000D33C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:0000D340                 extrn ___report_rangecheckfailure:near
UNDEF:0000D340                                         ; CODE XREF: Notepad_plus::notify(SCNotification *):loc_3DF3p
UNDEF:0000D340                                         ; Notepad_plus::notify(SCNotification *):loc_44B0p
UNDEF:0000D344                 extrn __invalid_parameter:near
UNDEF:0000D344                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+9Cp
UNDEF:0000D348 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000D348                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:0000D348                                         ; _wmemcpy+11p
UNDEF:0000D34C ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:0000D34C                 extrn _memset:near      ; CODE XREF: Notepad_plus::notify(SCNotification *)+3313p
UNDEF:0000D350 ; size_t __cdecl strlen(const char *Str)
UNDEF:0000D350                 extrn _strlen:near      ; CODE XREF: Notepad_plus::notify(SCNotification *)+2F65p
UNDEF:0000D350                                         ; std::char_traits<char>::length(char const *)+1Bp
UNDEF:0000D354 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:0000D354                 extrn _memmove:near     ; CODE XREF: std::_Uninit_copy<uint *,uint *>(uint * *,uint * *,uint * *,std::_Wrap_alloc<std::allocator<uint *>> &,std::_Scalar_ptr_iterator_tag)+4Fp
UNDEF:0000D354                                         ; std::char_traits<char>::move(char *,char const *,uint)+1Ep ...
UNDEF:0000D358 ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:0000D358                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:0000D35C ; size_t __cdecl wcsnlen(const wchar_t *Src, size_t MaxCount)
UNDEF:0000D35C                 extrn _wcsnlen:near     ; CODE XREF: Notepad_plus::notify(SCNotification *)+3024p
UNDEF:0000D360 ; int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
UNDEF:0000D360                 extrn __imp__lstrcmpW@8:near
UNDEF:0000D360                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+970p
UNDEF:0000D360                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+970r
UNDEF:0000D364 ; LPWSTR __stdcall lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
UNDEF:0000D364                 extrn __imp__lstrcpyW@8:near
UNDEF:0000D364                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2A83p
UNDEF:0000D364                                         ; Notepad_plus::notify(SCNotification *)+2B64p ...
UNDEF:0000D368 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000D368                 extrn __imp__SendMessageW@16:near
UNDEF:0000D368                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+AAAp
UNDEF:0000D368                                         ; Notepad_plus::notify(SCNotification *)+ACFp ...
UNDEF:0000D36C ; SHORT __stdcall GetKeyState(int nVirtKey)
UNDEF:0000D36C                 extrn __imp__GetKeyState@4:near
UNDEF:0000D36C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+594p
UNDEF:0000D36C                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+594r
UNDEF:0000D370 ; UINT __stdcall GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
UNDEF:0000D370                 extrn __imp__GetMenuState@12:near
UNDEF:0000D370                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+1C8Dp
UNDEF:0000D370                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+1C8Dr
UNDEF:0000D374 ; DWORD __stdcall CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck)
UNDEF:0000D374                 extrn __imp__CheckMenuItem@12:near
UNDEF:0000D374                                         ; CODE XREF: ContextMenu::checkItem(int,bool)+30p
UNDEF:0000D374                                         ; DATA XREF: ContextMenu::checkItem(int,bool)+30r
UNDEF:0000D378 ; BOOL __stdcall EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable)
UNDEF:0000D378                 extrn __imp__EnableMenuItem@12:near
UNDEF:0000D378                                         ; CODE XREF: ContextMenu::enableItem(int,bool)+36p
UNDEF:0000D378                                         ; DATA XREF: ContextMenu::enableItem(int,bool)+36r
UNDEF:0000D37C ; HMENU __stdcall GetSubMenu(HMENU hMenu, int nPos)
UNDEF:0000D37C                 extrn __imp__GetSubMenu@8:near
UNDEF:0000D37C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+FFAp
UNDEF:0000D37C                                         ; Notepad_plus::notify(SCNotification *)+1081p ...
UNDEF:0000D380 ; BOOL __stdcall TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
UNDEF:0000D380                 extrn __imp__TrackPopupMenu@28:near
UNDEF:0000D380                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+1030p
UNDEF:0000D380                                         ; Notepad_plus::notify(SCNotification *)+10FAp ...
UNDEF:0000D384 ; BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
UNDEF:0000D384                 extrn __imp__InvalidateRect@12:near
UNDEF:0000D384                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+300p
UNDEF:0000D384                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+300r
UNDEF:0000D388 ; BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect)
UNDEF:0000D388                 extrn __imp__GetWindowRect@8:near
UNDEF:0000D388                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+83Dp
UNDEF:0000D388                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+83Dr
UNDEF:0000D38C ; BOOL __stdcall GetCursorPos(LPPOINT lpPoint)
UNDEF:0000D38C                 extrn __imp__GetCursorPos@4:near
UNDEF:0000D38C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+FE5p
UNDEF:0000D38C                                         ; Notepad_plus::notify(SCNotification *)+1052p ...
UNDEF:0000D390 ; BOOL __stdcall ClientToScreen(HWND hWnd, LPPOINT lpPoint)
UNDEF:0000D390                 extrn __imp__ClientToScreen@8:near
UNDEF:0000D390                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+32DCp
UNDEF:0000D390                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+32DCr
UNDEF:0000D394 ; BOOL __stdcall ScreenToClient(HWND hWnd, LPPOINT lpPoint)
UNDEF:0000D394                 extrn __imp__ScreenToClient@8:near
UNDEF:0000D394                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+297Ap
UNDEF:0000D394                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+297Ar
UNDEF:0000D398 ; HWND __stdcall WindowFromPoint(POINT Point)
UNDEF:0000D398                 extrn __imp__WindowFromPoint@8:near
UNDEF:0000D398                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+5F4p
UNDEF:0000D398                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+5F4r
UNDEF:0000D39C ; HWND __stdcall GetParent(HWND hWnd)
UNDEF:0000D39C                 extrn __imp__GetParent@4:near
UNDEF:0000D39C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+934p
UNDEF:0000D39C                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+934r
UNDEF:0000D3A0 ; int __stdcall GetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount)
UNDEF:0000D3A0                 extrn __imp__GetClassNameW@12:near
UNDEF:0000D3A0                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+95Dp
UNDEF:0000D3A0                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+95Dr
UNDEF:0000D3A4 ; HWND __stdcall RealChildWindowFromPoint(HWND hwndParent, POINT ptParentClientCoords)
UNDEF:0000D3A4                 extrn __imp__RealChildWindowFromPoint@12:near
UNDEF:0000D3A4                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+299Dp
UNDEF:0000D3A4                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+299Dr
UNDEF:0000D3A8 ; HINSTANCE __stdcall ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
UNDEF:0000D3A8                 extrn __imp__ShellExecuteW@24:near
UNDEF:0000D3A8                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+30C2p
UNDEF:0000D3A8                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+30C2r
UNDEF:0000D3AC ; void __cdecl _wassert(const wchar_t *Message, const wchar_t *File, unsigned int Line)
UNDEF:0000D3AC                 extrn __wassert:near    ; CODE XREF: Notepad_plus::notify(SCNotification *)+261Fp
UNDEF:0000D3B0 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:0000D3B0                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:0000D3B0                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:0000D3B0                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:0000D3B4 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:0000D3B4                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:0000D3B4                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:0000D3B4                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:0000D3B8                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000D3BC ; void __cdecl operator delete[](void *)
UNDEF:0000D3BC                 extrn ??_V@YAXPAX@Z:near
UNDEF:0000D3BC                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+236Dp
UNDEF:0000D3C0 ; void *__cdecl operator new[](unsigned int)
UNDEF:0000D3C0                 extrn ??_U@YAPAXI@Z:near
UNDEF:0000D3C0                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2276p
UNDEF:0000D3C0                                         ; Notepad_plus::notify(SCNotification *)+22DAp
UNDEF:0000D3C4                 extrn __CrtDbgReportW:near
UNDEF:0000D3C4                                         ; CODE XREF: std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<uint>>>::operator*(void)+78p
UNDEF:0000D3C8 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0000D3C8                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0000D3C8                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000D3C8                                         ; std::_Debug_pointer<uint *>(uint * *,wchar_t const *,uint)+16p ...
UNDEF:0000D3CC ; void __cdecl std::_Xbad_alloc()
UNDEF:0000D3CC                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000D3CC                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_4A26p
UNDEF:0000D3CC                                         ; std::_Allocate<uint>(uint,uint *):loc_4A68p ...
UNDEF:0000D3D0 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000D3D0                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000D3D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:0000D3D0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp ...
UNDEF:0000D3D4 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:0000D3D4                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:0000D3D4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000D3D4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp
UNDEF:0000D3D8 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000D3D8                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000D3D8                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000D3DC ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000D3DC                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000D3DC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000D3DC                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000D3E0 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000D3E0                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000D3E0                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:0000D3E4 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000D3E4                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000D3E4                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000D3E8 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000D3E8                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000D3E8                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:0000D3EC ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000D3EC                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000D3EC                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000D3F0 ; void __thiscall ToolBar::doPopop(ToolBar *__hidden this, struct tagPOINT)
UNDEF:0000D3F0                 extrn ?doPopop@ToolBar@@QAEXUtagPOINT@@@Z:near
UNDEF:0000D3F0                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+32FCp
UNDEF:0000D3F4 ; void __cdecl getNameStrFromCmd(unsigned long, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &)
UNDEF:0000D3F4                 extrn ?getNameStrFromCmd@@YAXKAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z:near
UNDEF:0000D3F4                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2A31p
UNDEF:0000D3F8 ; _DWORD __thiscall recordedMacroStep::recordedMacroStep(recordedMacroStep *__hidden this, int, __int32, __int32, int)
UNDEF:0000D3F8                 extrn ??0recordedMacroStep@@QAE@HJJH@Z:near
UNDEF:0000D3F8                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2D16p
UNDEF:0000D3FC ; _DWORD __thiscall MenuItemUnit::MenuItemUnit(MenuItemUnit *__hidden this, unsigned __int32, const wchar_t *, const wchar_t *)
UNDEF:0000D3FC                 extrn ??0MenuItemUnit@@QAE@KPB_W0@Z:near
UNDEF:0000D3FC                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+6ABp
UNDEF:0000D3FC                                         ; Notepad_plus::notify(SCNotification *)+6FBp ...
UNDEF:0000D400 ; public: void __thiscall ContextMenu::create(struct HWND__ *, class std::vector<struct MenuItemUnit, class std::allocator<struct MenuItemUnit>> const &, struct HMENU__ * const)
UNDEF:0000D400                 extrn ?create@ContextMenu@@QAEXPAUHWND__@@ABV?$vector@UMenuItemUnit@@V?$allocator@UMenuItemUnit@@@std@@@std@@QAUHMENU__@@@Z:near
UNDEF:0000D400                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+766p
UNDEF:0000D400                                         ; Notepad_plus::notify(SCNotification *)+13FFp ...
UNDEF:0000D404 ; void __thiscall FileManager::beNotifiedOfBufferChange(FileManager *__hidden this, struct Buffer *, int)
UNDEF:0000D404                 extrn ?beNotifiedOfBufferChange@FileManager@@QAEXPAVBuffer@@H@Z:near
UNDEF:0000D404                                         ; CODE XREF: Buffer::doNotify(int)+1Fp
UNDEF:0000D408 ; struct Buffer *__thiscall FileManager::getBufferFromDocument(FileManager *__hidden this, __int32)
UNDEF:0000D408                 extrn ?getBufferFromDocument@FileManager@@QAEPAVBuffer@@J@Z:near
UNDEF:0000D408                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+41Dp
UNDEF:0000D408                                         ; Notepad_plus::notify(SCNotification *)+464p
UNDEF:0000D40C ; bool __thiscall FileManager::backupCurrentBuffer(FileManager *__hidden this)
UNDEF:0000D40C                 extrn ?backupCurrentBuffer@FileManager@@QAE_NXZ:near
UNDEF:0000D40C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+E59p
UNDEF:0000D40C                                         ; Notepad_plus::notify(SCNotification *)+EBFp
UNDEF:0000D410 ; void __thiscall ScintillaEditView::getGenericText(ScintillaEditView *__hidden this, wchar_t *, unsigned int, int, int)
UNDEF:0000D410                 extrn ?getGenericText@ScintillaEditView@@QBEXPA_WIHH@Z:near
UNDEF:0000D410                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+3013p
UNDEF:0000D414 ; void __thiscall ScintillaEditView::restoreCurrentPos(ScintillaEditView *__hidden this)
UNDEF:0000D414                 extrn ?restoreCurrentPos@ScintillaEditView@@QAEXXZ:near
UNDEF:0000D414                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2D87p
UNDEF:0000D414                                         ; Notepad_plus::notify(SCNotification *)+2DC3p
UNDEF:0000D418 ; void __thiscall ScintillaEditView::updateBeginEndSelectPosition(ScintillaEditView *__hidden this, bool, int, int)
UNDEF:0000D418                 extrn ?updateBeginEndSelectPosition@ScintillaEditView@@QAEX_NHH@Z:near
UNDEF:0000D418                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2D7p
UNDEF:0000D41C ; void __thiscall ScintillaEditView::marginClick(ScintillaEditView *__hidden this, int, int)
UNDEF:0000D41C                 extrn ?marginClick@ScintillaEditView@@QAEXHH@Z:near
UNDEF:0000D41C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+1F5Fp
UNDEF:0000D420 ; void __thiscall ScintillaEditView::updateLineNumberWidth(ScintillaEditView *__hidden this)
UNDEF:0000D420                 extrn ?updateLineNumberWidth@ScintillaEditView@@QAEXXZ:near
UNDEF:0000D420                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2DE1p
UNDEF:0000D424 ; void __thiscall ScintillaEditView::foldChanged(ScintillaEditView *__hidden this, int, int, int)
UNDEF:0000D424                 extrn ?foldChanged@ScintillaEditView@@QAEXHHH@Z:near
UNDEF:0000D424                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+35Cp
UNDEF:0000D428 ; bool __thiscall ScintillaEditView::markerMarginClick(ScintillaEditView *__hidden this, int)
UNDEF:0000D428                 extrn ?markerMarginClick@ScintillaEditView@@QAE_NH@Z:near
UNDEF:0000D428                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+1FD3p
UNDEF:0000D42C ; struct Buffer *__thiscall DocTabView::getBufferByIndex(DocTabView *__hidden this, int)
UNDEF:0000D42C                 extrn ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z:near
UNDEF:0000D42C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+9BCp
UNDEF:0000D42C                                         ; Notepad_plus::notify(SCNotification *)+BACp ...
UNDEF:0000D430 ; BOOL __stdcall PathFileExistsW(LPCWSTR pszPath)
UNDEF:0000D430                 extrn __imp__PathFileExistsW@4:near
UNDEF:0000D430                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+1D92p
UNDEF:0000D430                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+1D92r
UNDEF:0000D434 ; bool __thiscall StatusBar::setText(StatusBar *__hidden this, const wchar_t *, int)
UNDEF:0000D434                 extrn ?setText@StatusBar@@QAE_NPB_WH@Z:near
UNDEF:0000D434                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+DFDp
UNDEF:0000D438 ; void __thiscall AutoCompletion::insertMatchedChars(AutoCompletion *__hidden this, int, const struct MatchedPairConf *)
UNDEF:0000D438                 extrn ?insertMatchedChars@AutoCompletion@@QAEXHABUMatchedPairConf@@@Z:near
UNDEF:0000D438                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+21C0p
UNDEF:0000D43C ; void __thiscall AutoCompletion::update(AutoCompletion *__hidden this, int)
UNDEF:0000D43C                 extrn ?update@AutoCompletion@@QAEXH@Z:near
UNDEF:0000D43C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+21D2p
UNDEF:0000D43C                                         ; Notepad_plus::notify(SCNotification *)+292Dp
UNDEF:0000D440 ; void __thiscall AutoCompletion::callTipClick(AutoCompletion *__hidden this, int)
UNDEF:0000D440                 extrn ?callTipClick@AutoCompletion@@QAEXH@Z:near
UNDEF:0000D440                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+322Ep
UNDEF:0000D444 ; void __thiscall SmartHighlighter::highlightView(SmartHighlighter *__hidden this, struct ScintillaEditView *)
UNDEF:0000D444                 extrn ?highlightView@SmartHighlighter@@QAEXPAVScintillaEditView@@@Z:near
UNDEF:0000D444                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+28D9p
UNDEF:0000D448 ; void __thiscall NativeLangSpeaker::changeLangTabContextMenu(NativeLangSpeaker *__hidden this, HMENU)
UNDEF:0000D448                 extrn ?changeLangTabContextMenu@NativeLangSpeaker@@QAEXPAUHMENU__@@@Z:near
UNDEF:0000D448                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+1422p
UNDEF:0000D448                                         ; Notepad_plus::notify(SCNotification *)+1C62p
UNDEF:0000D44C ; bool __thiscall NativeLangSpeaker::changeDlgLang(NativeLangSpeaker *__hidden this, HWND, const char *, char *)
UNDEF:0000D44C                 extrn ?changeDlgLang@NativeLangSpeaker@@QAE_NPAUHWND__@@PBDPAD@Z:near
UNDEF:0000D44C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+FA7p
UNDEF:0000D450 ; void __thiscall NativeLangSpeaker::changeLangTabDrapContextMenu(NativeLangSpeaker *__hidden this, HMENU)
UNDEF:0000D450                 extrn ?changeLangTabDrapContextMenu@NativeLangSpeaker@@QAEXPAUHMENU__@@@Z:near
UNDEF:0000D450                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+789p
UNDEF:0000D454 ; int __thiscall NativeLangSpeaker::messageBox(NativeLangSpeaker *__hidden this, const char *, HWND, const wchar_t *, const wchar_t *, int, int, const wchar_t *)
UNDEF:0000D454                 extrn ?messageBox@NativeLangSpeaker@@QAEHPBDPAUHWND__@@PB_W2HH2@Z:near
UNDEF:0000D454                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+A6Dp
UNDEF:0000D458 ; struct MenuPosition *__cdecl getMenuPosition(const char *)
UNDEF:0000D458                 extrn ?getMenuPosition@@YAAAVMenuPosition@@PBD@Z:near
UNDEF:0000D458                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+105Dp
UNDEF:0000D458                                         ; Notepad_plus::notify(SCNotification *)+1216p
UNDEF:0000D45C ; bool __thiscall Notepad_plus::fileClose(Notepad_plus *__hidden this, struct Buffer *, int)
UNDEF:0000D45C                 extrn ?fileClose@Notepad_plus@@QAE_NPAVBuffer@@H@Z:near
UNDEF:0000D45C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+AF4p
UNDEF:0000D45C                                         ; Notepad_plus::notify(SCNotification *)+C3Cp
UNDEF:0000D460 ; void __thiscall Notepad_plus::command(Notepad_plus *__hidden this, int)
UNDEF:0000D460                 extrn ?command@Notepad_plus@@AAEXH@Z:near
UNDEF:0000D460                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+FC8p
UNDEF:0000D464 ; int __thiscall Notepad_plus::switchEditViewTo(Notepad_plus *__hidden this, int)
UNDEF:0000D464                 extrn ?switchEditViewTo@Notepad_plus@@AAEHH@Z:near
UNDEF:0000D464                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+CAAp
UNDEF:0000D464                                         ; Notepad_plus::notify(SCNotification *)+E66p ...
UNDEF:0000D468 ; void __thiscall __high Notepad_plus::docGotoAnotherEditView(enum FileTransferMode)
UNDEF:0000D468                 extrn ?docGotoAnotherEditView@Notepad_plus@@AAEXW4FileTransferMode@@@Z:near
UNDEF:0000D468                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+81Dp
UNDEF:0000D46C ; void __thiscall __high Notepad_plus::docOpenInNewInstance(enum FileTransferMode, int, int)
UNDEF:0000D46C                 extrn ?docOpenInNewInstance@Notepad_plus@@AAEXW4FileTransferMode@@HH@Z:near
UNDEF:0000D46C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+B64p
UNDEF:0000D470 ; bool __thiscall Notepad_plus::activateBuffer(Notepad_plus *__hidden this, struct Buffer *, int)
UNDEF:0000D470                 extrn ?activateBuffer@Notepad_plus@@AAE_NPAVBuffer@@H@Z:near
UNDEF:0000D470                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+C23p
UNDEF:0000D470                                         ; Notepad_plus::notify(SCNotification *)+CF5p
UNDEF:0000D474 ; void __thiscall Notepad_plus::maintainIndentation(Notepad_plus *__hidden this, wchar_t)
UNDEF:0000D474                 extrn ?maintainIndentation@Notepad_plus@@AAEX_W@Z:near
UNDEF:0000D474                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2100p
UNDEF:0000D478 ; void __thiscall Notepad_plus::addHotSpot(Notepad_plus *__hidden this)
UNDEF:0000D478                 extrn ?addHotSpot@Notepad_plus@@AAEXXZ:near
UNDEF:0000D478                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2074p
UNDEF:0000D478                                         ; Notepad_plus::notify(SCNotification *)+2811p ...
UNDEF:0000D47C ; bool __thiscall Notepad_plus::braceMatch(Notepad_plus *__hidden this)
UNDEF:0000D47C                 extrn ?braceMatch@Notepad_plus@@AAE_NXZ:near
UNDEF:0000D47C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+284Cp
UNDEF:0000D480 ; void __thiscall Notepad_plus::updateStatusBar(Notepad_plus *__hidden this)
UNDEF:0000D480                 extrn ?updateStatusBar@Notepad_plus@@AAEXXZ:near
UNDEF:0000D480                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+28E4p
UNDEF:0000D484 ; void __thiscall Notepad_plus::doSynScorll(Notepad_plus *__hidden this, HWND)
UNDEF:0000D484                 extrn ?doSynScorll@Notepad_plus@@AAEXPAUHWND__@@@Z:near
UNDEF:0000D484                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2E0Ap
UNDEF:0000D488 ; bool __thiscall Notepad_plus::noOpenedDoc(Notepad_plus *__hidden this)
UNDEF:0000D488                 extrn ?noOpenedDoc@Notepad_plus@@ABE_NXZ:near
UNDEF:0000D488                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+AFFp
UNDEF:0000D48C ; void __thiscall XmlMatchedTagsHighlighter::tagMatch(XmlMatchedTagsHighlighter *__hidden this, bool)
UNDEF:0000D48C                 extrn ?tagMatch@XmlMatchedTagsHighlighter@@QAEX_N@Z:near
UNDEF:0000D48C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2899p
UNDEF:0000D490 ; void __thiscall DocumentMap::wrapMap(DocumentMap *__hidden this)
UNDEF:0000D490                 extrn ?wrapMap@DocumentMap@@QAEXXZ:near
UNDEF:0000D490                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2E9Fp
UNDEF:0000D494 ; void __thiscall DocumentMap::scrollMap(DocumentMap *__hidden this)
UNDEF:0000D494                 extrn ?scrollMap@DocumentMap@@QAEXXZ:near
UNDEF:0000D494                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+2EB0p
UNDEF:0000D498 ; void __thiscall DocumentMap::fold(DocumentMap *__hidden this, int, bool)
UNDEF:0000D498                 extrn ?fold@DocumentMap@@QAEXH_N@Z:near
UNDEF:0000D498                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+1FA2p
UNDEF:0000D498                                         ; Notepad_plus::notify(SCNotification *)+20B7p
UNDEF:0000D49C ; __fastcall __security_check_cookie(x)
UNDEF:0000D49C                 extrn @__security_check_cookie@4:near
UNDEF:0000D49C                                         ; CODE XREF: Notepad_plus::notify(SCNotification *)+3384p
UNDEF:0000D49C                                         ; __ehhandler$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z+Fp ...
UNDEF:0000D4A0 ; __stdcall _CxxThrowException(x, x)
UNDEF:0000D4A0                 extrn __CxxThrowException@8:near
UNDEF:0000D4A0                                         ; CODE XREF: __catch$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+25p
UNDEF:0000D4A0                                         ; __catch$??$_Uninit_move@PAUrecordedMacroStep@@PAU1@V?$allocator@UrecordedMacroStep@@@std@@U1@@std@@YAPAUrecordedMacroStep@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UrecordedMacroStep@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+25p ...
UNDEF:0000D4A4                 extrn ___CxxFrameHandler3:near
UNDEF:0000D4A4                                         ; CODE XREF: __ehhandler$?notify@Notepad_plus@@AAEHPAUSCNotification@@@Z+23j
UNDEF:0000D4A4                                         ; __ehhandler$??$_Uninit_move@PAUMenuItemUnit@@PAU1@V?$allocator@UMenuItemUnit@@@std@@U1@@std@@YAPAUMenuItemUnit@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UMenuItemUnit@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+16j ...
UNDEF:0000D4A8                 extrn __chkstk:near     ; CODE XREF: Notepad_plus::notify(SCNotification *)+17p
UNDEF:0000D4AC ; const type_info::`vftable'
UNDEF:0000D4AC                 extrn ??_7type_info@@6B@:near
UNDEF:0000D4AC                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:0000D4AC                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:0000D4B0 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:0000D4B0                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:0000D4B0                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:0000D4B4 ; private: static class FileManager * FileManager::_pSelf
UNDEF:0000D4B4                 extrn ?_pSelf@FileManager@@0PAV1@A:near
UNDEF:0000D4B4                                         ; DATA XREF: FileManager::getInstance(void)+3r
UNDEF:0000D4B8 ; public: static int const ScintillaEditView::_SC_MARGE_SYBOLE
UNDEF:0000D4B8                 extrn ?_SC_MARGE_SYBOLE@ScintillaEditView@@2HB:near
UNDEF:0000D4B8                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+1FAFr
UNDEF:0000D4BC ; public: static int const ScintillaEditView::_SC_MARGE_FOLDER
UNDEF:0000D4BC                 extrn ?_SC_MARGE_FOLDER@ScintillaEditView@@2HB:near
UNDEF:0000D4BC                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+1F3Dr
UNDEF:0000D4C0 ; private: static wchar_t const * const Notepad_plus_Window::_className
UNDEF:0000D4C0                 extrn ?_className@Notepad_plus_Window@@0QB_WB:near
UNDEF:0000D4C0                                         ; DATA XREF: Notepad_plus_Window::getClassName(void)+3o
UNDEF:0000D4C4                 extrn ___security_cookie:near
UNDEF:0000D4C4                                         ; DATA XREF: Notepad_plus::notify(SCNotification *)+1Cr
UNDEF:0000D4C4                                         ; std::_Uninit_move<MenuItemUnit *,MenuItemUnit *,std::allocator<MenuItemUnit>,MenuItemUnit>(MenuItemUnit *,MenuItemUnit *,MenuItemUnit *,std::_Wrap_alloc<std::allocator<MenuItemUnit>> &,MenuItemUnit *,std::_Nonscalar_ptr_iterator_tag)+16r ...
UNDEF:0000D4C8                 extrn __fltused:near
UNDEF:0000D4C8
UNDEF:0000D4C8
UNDEF:0000D4C8                 end