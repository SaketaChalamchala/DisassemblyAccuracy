.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : 3EAD2878F31DB1EEBADD5069EF599AAB
.data:00000000 ; Input CRC32 : 8DF20112
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\FindCharsInRange.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 ; Segment alignment 'qword' can not be represented in assembly
.data:00000000 _data           segment para public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000 _acTop_xpm      dd offset $SG143413     ; "12 12 56 1"
.data:00000004                 dd offset $SG143414     ; " \tc #FFFFFF"
.data:00000008                 dd offset $SG143415     ; ".\tc #8AB2E9"
.data:0000000C                 dd offset $SG143416     ; "+\tc #CCDCF6"
.data:00000010                 dd offset $SG143417     ; "@\tc #80ABEA"
.data:00000014                 dd offset $SG143418     ; "#\tc #7DA9E8"
.data:00000018                 dd offset $SG143419     ; "$\tc #C7DAF3"
.data:0000001C                 dd offset $SG143420     ; "%\tc #79A7E6"
.data:00000020                 dd offset $SG143421     ; "&\tc #ADC8EF"
.data:00000024                 dd offset $SG143422     ; "*\tc #87B0E8"
.data:00000028                 dd offset $SG143423     ; "=\tc #BBD2F0"
.data:0000002C                 dd offset $SG143424     ; "-\tc #6EA0E2"
.data:00000030                 dd offset $SG143425     ; ";\tc #A8C7EE"
.data:00000034                 dd offset $SG143426     ; ">\tc #A3C2ED"
.data:00000038                 dd offset $SG143427     ; ",\tc #75A4E3"
.data:0000003C                 dd offset $SG143428     ; "'\tc #A7C4EB"
.data:00000040                 dd offset $SG143429     ; ")\tc #6297E1"
.data:00000044                 dd offset $SG143430     ; "!\tc #A1C1EC"
.data:00000048                 dd offset $SG143431     ; "~\tc #92B7E8"
.data:0000004C                 dd offset $SG143432     ; "{\tc #99BBE9"
.data:00000050                 dd offset $SG143433     ; "]\tc #6197DD"
.data:00000054                 dd offset $SG143434     ; "^\tc #96B9E6"
.data:00000058                 dd offset $SG143435     ; "/\tc #538EDB"
.data:0000005C                 dd offset $SG143436     ; "(\tc #99BBEA"
.data:00000060                 dd offset $SG143437     ; "_\tc #80AAE3"
.data:00000064                 dd offset $SG143438     ; ":\tc #81ABE3"
.data:00000068                 dd offset $SG143439     ; "<\tc #8AB1E4"
.data:0000006C                 dd offset $SG143440     ; "[\tc #4B88D6"
.data:00000070                 dd offset $SG143441     ; "}\tc #4882D1"
.data:00000074                 dd offset $SG143442     ; "|\tc #4384D6"
.data:00000078                 dd offset $SG143443     ; "1\tc #90B5E7"
.data:0000007C                 dd offset $SG143444     ; "2\tc #74A3E0"
.data:00000080                 dd offset $SG143445     ; "3\tc #77A4E0"
.data:00000084                 dd offset $SG143446     ; "4\tc #81ABE2"
.data:00000088                 dd offset $SG143447     ; "5\tc #437FD3"
.data:0000008C                 dd offset $SG143448     ; "6\tc #7FA2DF"
.data:00000090                 dd offset $SG143449     ; "7\tc #3577D2"
.data:00000094                 dd offset $SG143450     ; "8\tc #87AFE4"
.data:00000098                 dd offset $SG143451     ; "9\tc #72A1DF"
.data:0000009C                 dd offset $SG143452     ; "0\tc #7CA9E1"
.data:000000A0                 dd offset $SG143453     ; "a\tc #3F7AD0"
.data:000000A4                 dd offset $SG143454     ; "b\tc #85A4DE"
.data:000000A8                 dd offset $SG143455     ; "c\tc #FBFCFE"
.data:000000AC                 dd offset $SG143456     ; "d\tc #236ECD"
.data:000000B0                 dd offset $SG143457     ; "e\tc #7EA8E1"
.data:000000B4                 dd offset $SG143458     ; "f\tc #79A6E0"
.data:000000B8                 dd offset $SG143459     ; "g\tc #3D77D0"
.data:000000BC                 dd offset $SG143460     ; "h\tc #87A4DC"
.data:000000C0                 dd offset $SG143461     ; "i\tc #1A62C9"
.data:000000C4                 dd offset $SG143462     ; "j\tc #75A3DF"
.data:000000C8                 dd offset $SG143463     ; "k\tc #3C74CF"
.data:000000CC                 dd offset $SG143464     ; "l\tc #8DA6DE"
.data:000000D0                 dd offset $SG143465     ; "m\tc #1859C4"
.data:000000D4                 dd offset $SG143466     ; "n\tc #3B71CC"
.data:000000D8                 dd offset $SG143467     ; "o\tc #8EA5DD"
.data:000000DC                 dd offset $SG143468     ; "p\tc #164EC0"
.data:000000E0                 dd offset $SG143469     ; "q\tc #92A7DD"
.data:000000E4                 dd offset $SG143470     ; "    .+      "
.data:000000E8                 dd offset $SG143471     ; "    @#$     "
.data:000000EC                 dd offset $SG143472     ; "    %&*=    "
.data:000000F0                 dd offset $SG143473     ; "    -;>,'   "
.data:000000F4                 dd offset $SG143474     ; "    )!~{]^  "
.data:000000F8                 dd offset $SG143475     ; "    /(_:<[} "
.data:000000FC                 dd offset $SG143476     ; "    |123456 "
.data:00000100                 dd offset $SG143477     ; "    7890abc "
.data:00000104                 dd offset $SG143478     ; "    defgh   "
.data:00000108                 dd offset $SG143479     ; "    ijkl    "
.data:0000010C                 dd offset $SG143480     ; "    mno     "
.data:00000110                 dd offset $SG143481     ; "    pq      "
.data:00000114                 align 8
.data:00000118 _acBottom_xpm   dd offset $SG143483     ; "12 12 54 1"
.data:0000011C                 dd offset $SG143484     ; " \tc #FFFFFF"
.data:00000120                 dd offset $SG143485     ; ".\tc #C4D7F3"
.data:00000124                 dd offset $SG143486     ; "+\tc #72A1E3"
.data:00000128                 dd offset $SG143487     ; "@\tc #C1D6F2"
.data:0000012C                 dd offset $SG143488     ; "#\tc #6397E1"
.data:00000130                 dd offset $SG143489     ; "$\tc #5990DD"
.data:00000134                 dd offset $SG143490     ; "%\tc #BBD2F0"
.data:00000138                 dd offset $SG143491     ; "&\tc #7AA6E5"
.data:0000013C                 dd offset $SG143492     ; "*\tc #9ABDEA"
.data:00000140                 dd offset $SG143493     ; "=\tc #4A87D9"
.data:00000144                 dd offset $SG143494     ; "-\tc #B1CAEE"
.data:00000148                 dd offset $SG143495     ; ";\tc #75A4E3"
.data:0000014C                 dd offset $SG143496     ; ">\tc #99BBE9"
.data:00000150                 dd offset $SG143497     ; ",\tc #95B9E8"
.data:00000154                 dd offset $SG143498     ; "'\tc #3A7CD4"
.data:00000158                 dd offset $SG143499     ; ")\tc #A9C6EC"
.data:0000015C                 dd offset $SG143500     ; "!\tc #71A0E0"
.data:00000160                 dd offset $SG143501     ; "~\tc #86AFE5"
.data:00000164                 dd offset $SG143502     ; "{\tc #8DB2E6"
.data:00000168                 dd offset $SG143503     ; "]\tc #2A72CF"
.data:0000016C                 dd offset $SG143504     ; "^\tc #73A0E0"
.data:00000170                 dd offset $SG143505     ; "/\tc #6B9DE0"
.data:00000174                 dd offset $SG143506     ; "(\tc #95B8E8"
.data:00000178                 dd offset $SG143507     ; "_\tc #81ABE3"
.data:0000017C                 dd offset $SG143508     ; ":\tc #72A1DF"
.data:00000180                 dd offset $SG143509     ; "<\tc #83ADE3"
.data:00000184                 dd offset $SG143510     ; "[\tc #1B65C9"
.data:00000188                 dd offset $SG143511     ; "}\tc #5F95DC"
.data:0000018C                 dd offset $SG143512     ; "|\tc #8BB3E5"
.data:00000190                 dd offset $SG143513     ; "1\tc #77A4E0"
.data:00000194                 dd offset $SG143514     ; "2\tc #679ADC"
.data:00000198                 dd offset $SG143515     ; "3\tc #7AA6E1"
.data:0000019C                 dd offset $SG143516     ; "4\tc #195CC6"
.data:000001A0                 dd offset $SG143517     ; "5\tc #FCFDFE"
.data:000001A4                 dd offset $SG143518     ; "6\tc #8DB2E4"
.data:000001A8                 dd offset $SG143519     ; "7\tc #4885D6"
.data:000001AC                 dd offset $SG143520     ; "8\tc #7CA9E1"
.data:000001B0                 dd offset $SG143521     ; "9\tc #6698DB"
.data:000001B4                 dd offset $SG143522     ; "0\tc #71A1DE"
.data:000001B8                 dd offset $SG143523     ; "a\tc #1752C0"
.data:000001BC                 dd offset $SG143524     ; "b\tc #88ABE0"
.data:000001C0                 dd offset $SG143525     ; "c\tc #3D77D0"
.data:000001C4                 dd offset $SG143526     ; "d\tc #6E9FDD"
.data:000001C8                 dd offset $SG143527     ; "e\tc #699BDC"
.data:000001CC                 dd offset $SG143528     ; "f\tc #1547BD"
.data:000001D0                 dd offset $SG143529     ; "g\tc #8DA6DE"
.data:000001D4                 dd offset $SG143530     ; "h\tc #376BC9"
.data:000001D8                 dd offset $SG143531     ; "i\tc #6295DA"
.data:000001DC                 dd offset $SG143532     ; "j\tc #1440B9"
.data:000001E0                 dd offset $SG143533     ; "k\tc #8DA0DB"
.data:000001E4                 dd offset $SG143534     ; "l\tc #315FC4"
.data:000001E8                 dd offset $SG143535     ; "m\tc #1339B7"
.data:000001EC                 dd offset $SG143536     ; "n\tc #909FDA"
.data:000001F0                 dd offset $SG143537     ; "o\tc #1233B4"
.data:000001F4                 dd offset $SG143538     ; "         .+ "
.data:000001F8                 dd offset $SG143539     ; "        @#$ "
.data:000001FC                 dd offset $SG143540     ; "       %&*= L"
.data:00000200                 dd offset $SG143541     ; "      -;>,' "
.data:00000204                 dd offset $SG143542     ; "     )!>~{] "
.data:00000208                 dd offset $SG143543     ; "    ^/(_:<[ "
.data:0000020C                 dd offset $SG143544     ; "    (}|1234 "
.data:00000210                 dd offset $SG143545     ; "    567890a "
.data:00000214                 dd offset $SG143546     ; "      bcdef "
.data:00000218                 dd offset $SG143547     ; "       ghij "
.data:0000021C                 dd offset $SG143548     ; "        klm "
.data:00000220                 dd offset $SG143549     ; "         no "
.data:00000224                 align 8
.data:00000228 _bookmark_xpm   dd offset $SG143551     ; "13 14 54 1"
.data:0000022C                 dd offset $SG143552     ; " \tc None"
.data:00000230                 dd offset $SG143553     ; ".\tc #545254"
.data:00000234                 dd offset $SG143554     ; "+\tc #3C3E3C"
.data:00000238                 dd offset $SG143555     ; "@\tc #646464"
.data:0000023C                 dd offset $SG143556     ; "#\tc #A4A4A4"
.data:00000240                 dd offset $SG143557     ; "$\tc #B7B8B7"
.data:00000244                 dd offset $SG143558     ; "%\tc #747284"
.data:00000248                 dd offset $SG143559     ; "&\tc #B4B2C4"
.data:0000024C                 dd offset $SG143560     ; "*\tc #DCD7E4"
.data:00000250                 dd offset $SG143561     ; "=\tc #1C1A1C"
.data:00000254                 dd offset $SG143562     ; "-\tc #403E58"
.data:00000258                 dd offset $SG143563     ; ";\tc #5C5A8C"
.data:0000025C                 dd offset $SG143564     ; ">\tc #7C7EAC"
.data:00000260                 dd offset $SG143565     ; ",\tc #7C8EBC"
.data:00000264                 dd offset $SG143566     ; "'\tc #242644"
.data:00000268                 dd offset $SG143567     ; ")\tc #282668"
.data:0000026C                 dd offset $SG143568     ; "!\tc #24367C"
.data:00000270                 dd offset $SG143569     ; "~\tc #244A84"
.data:00000274                 dd offset $SG143570     ; "{\tc #2C5098"
.data:00000278                 dd offset $SG143571     ; "]\tc #14162C"
.data:0000027C                 dd offset $SG143572     ; "^\tc #142E7C"
.data:00000280                 dd offset $SG143573     ; "/\tc #143789"
.data:00000284                 dd offset $SG143574     ; "(\tc #204990"
.data:00000288                 dd offset $SG143575     ; "_\tc #174091"
.data:0000028C                 dd offset $SG143576     ; ":\tc #0C0630"
.data:00000290                 dd offset $SG143577     ; "<\tc #24327C"
.data:00000294                 dd offset $SG143578     ; "[\tc #2450A0"
.data:00000298                 dd offset $SG143579     ; "}\tc #345DB4"
.data:0000029C                 dd offset $SG143580     ; "|\tc #3C68B8"
.data:000002A0                 dd offset $SG143581     ; "1\tc #141244"
.data:000002A4                 dd offset $SG143582     ; "2\tc #24428C"
.data:000002A8                 dd offset $SG143583     ; "3\tc #3462B9"
.data:000002AC                 dd offset $SG143584     ; "4\tc #4470C4"
.data:000002B0                 dd offset $SG143585     ; "5\tc #4C7FD6"
.data:000002B4                 dd offset $SG143586     ; "6\tc #4472CC"
.data:000002B8                 dd offset $SG143587     ; "7\tc #24224C"
.data:000002BC                 dd offset $SG143588     ; "8\tc #5C8DEC"
.data:000002C0                 dd offset $SG143589     ; "9\tc #5C94F6"
.data:000002C4                 dd offset $SG143590     ; "0\tc #5482DF"
.data:000002C8                 dd offset $SG143591     ; "a\tc #619DF7"
.data:000002CC                 dd offset $SG143592     ; "b\tc #6CA6FC"
.data:000002D0                 dd offset $SG143593     ; "c\tc #64A2FC"
.data:000002D4                 dd offset $SG143594     ; "d\tc #1C2E5C"
.data:000002D8                 dd offset $SG143595     ; "e\tc #6CA2FC"
.data:000002DC                 dd offset $SG143596     ; "f\tc #74B2FC"
.data:000002E0                 dd offset $SG143597     ; "g\tc #7CB8FC"
.data:000002E4                 dd offset $SG143598     ; "h\tc #1C3264"
.data:000002E8                 dd offset $SG143599     ; "i\tc #346AD4"
.data:000002EC                 dd offset $SG143600     ; "j\tc #7CBEFC"
.data:000002F0                 dd offset $SG143601     ; "k\tc #3C72DC"
.data:000002F4                 dd offset $SG143602     ; "l\tc #243250"
.data:000002F8                 dd offset $SG143603     ; "m\tc #346AB4"
.data:000002FC                 dd offset $SG143604     ; "n\tc #3C82DC"
.data:00000300                 dd offset $SG143605     ; "o\tc #6C6A6C"
.data:00000304                 dd offset $SG143606     ; "     .+.     "
.data:00000308                 dd offset $SG143607     ; "   @##$##@   "
.data:0000030C                 dd offset $SG143608     ; "  @%&***&%@  "
.data:00000310                 dd offset $SG143609     ; " =-;>,,,>;-= "
.data:00000314                 dd offset $SG143610     ; " ')!~{{{~!)' "
.data:00000318                 dd offset $SG143611     ; "])^/({{{(_^)]"
.data:0000031C                 dd offset $SG143612     ; ":<_[}|||}[_<:"
.data:00000320                 dd offset $SG143613     ; "12[3455563[21"
.data:00000324                 dd offset $SG143614     ; "7_365899063_7"
.data:00000328                 dd offset $SG143615     ; " /|09abc904/ "
.data:0000032C                 dd offset $SG143616     ; " d}8efgfb83d "
.data:00000330                 dd offset $SG143617     ; "  hiafjgakh  "
.data:00000334                 dd offset $SG143618     ; "   l~mnm~l   "
.data:00000338                 dd offset $SG143619     ; "     o@o     "
.data:00000338 _data           ends
.data:00000338
.rdata:0000033C ; ===========================================================================
.rdata:0000033C
.rdata:0000033C ; Segment type: Pure data
.rdata:0000033C ; Segment permissions: Read
.rdata:0000033C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000033C _rdata          segment para public 'DATA' use32
.rdata:0000033C                 assume cs:_rdata
.rdata:0000033C                 ;org 33Ch
.rdata:0000033C $SG143413       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:00000347                 align 4
.rdata:00000348 $SG143414       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000004o
.rdata:00000354 $SG143415       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000008o
.rdata:00000360 $SG143416       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:0000000Co
.rdata:0000036C $SG143417       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000010o
.rdata:00000378 $SG143418       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000014o
.rdata:00000384 $SG143419       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000018o
.rdata:00000390 $SG143420       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:0000001Co
.rdata:0000039C $SG143421       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:00000020o
.rdata:000003A8 $SG143422       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:00000024o
.rdata:000003B4 $SG143423       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000028o
.rdata:000003C0 $SG143424       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:0000002Co
.rdata:000003CC $SG143425       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000030o
.rdata:000003D8 $SG143426       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000034o
.rdata:000003E4 $SG143427       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000038o
.rdata:000003F0 $SG143428       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:0000003Co
.rdata:000003FC $SG143429       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000040o
.rdata:00000408 $SG143430       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000044o
.rdata:00000414 $SG143431       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000048o
.rdata:00000420 $SG143432       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:0000004Co
.rdata:0000042C $SG143433       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000050o
.rdata:00000438 $SG143434       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000054o
.rdata:00000444 $SG143435       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000058o
.rdata:00000450 $SG143436       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:0000005Co
.rdata:0000045C $SG143437       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000060o
.rdata:00000468 $SG143438       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000064o
.rdata:00000474 $SG143439       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000068o
.rdata:00000480 $SG143440       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:0000006Co
.rdata:0000048C $SG143441       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000070o
.rdata:00000498 $SG143442       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000074o
.rdata:000004A4 $SG143443       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000078o
.rdata:000004B0 $SG143444       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:0000007Co
.rdata:000004BC $SG143445       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000080o
.rdata:000004C8 $SG143446       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000084o
.rdata:000004D4 $SG143447       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000088o
.rdata:000004E0 $SG143448       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:0000008Co
.rdata:000004EC $SG143449       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000090o
.rdata:000004F8 $SG143450       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000094o
.rdata:00000504 $SG143451       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000098o
.rdata:00000510 $SG143452       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:0000009Co
.rdata:0000051C $SG143453       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:000000A0o
.rdata:00000528 $SG143454       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:000000A4o
.rdata:00000534 $SG143455       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:000000A8o
.rdata:00000540 $SG143456       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:000000ACo
.rdata:0000054C $SG143457       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:000000B0o
.rdata:00000558 $SG143458       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:000000B4o
.rdata:00000564 $SG143459       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:000000B8o
.rdata:00000570 $SG143460       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:000000BCo
.rdata:0000057C $SG143461       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:000000C0o
.rdata:00000588 $SG143462       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:000000C4o
.rdata:00000594 $SG143463       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:000000C8o
.rdata:000005A0 $SG143464       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:000000CCo
.rdata:000005AC $SG143465       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:000000D0o
.rdata:000005B8 $SG143466       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:000000D4o
.rdata:000005C4 $SG143467       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:000000D8o
.rdata:000005D0 $SG143468       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:000000DCo
.rdata:000005DC $SG143469       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:000000E0o
.rdata:000005E8 $SG143470       db '    .+      ',0     ; DATA XREF: .data:000000E4o
.rdata:000005F5                 align 4
.rdata:000005F8 $SG143471       db '    @#$     ',0     ; DATA XREF: .data:000000E8o
.rdata:00000605                 align 4
.rdata:00000608 $SG143472       db '    %&*=    ',0     ; DATA XREF: .data:000000ECo
.rdata:00000615                 align 4
.rdata:00000618 $SG143473       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:000000F0o
.rdata:00000625                 align 4
.rdata:00000628 $SG143474       db '    )!~{]^  ',0     ; DATA XREF: .data:000000F4o
.rdata:00000635                 align 4
.rdata:00000638 $SG143475       db '    /(_:<[} ',0     ; DATA XREF: .data:000000F8o
.rdata:00000645                 align 4
.rdata:00000648 $SG143476       db '    |123456 ',0     ; DATA XREF: .data:000000FCo
.rdata:00000655                 align 4
.rdata:00000658 $SG143477       db '    7890abc ',0     ; DATA XREF: .data:00000100o
.rdata:00000665                 align 4
.rdata:00000668 $SG143478       db '    defgh   ',0     ; DATA XREF: .data:00000104o
.rdata:00000675                 align 4
.rdata:00000678 $SG143479       db '    ijkl    ',0     ; DATA XREF: .data:00000108o
.rdata:00000685                 align 4
.rdata:00000688 $SG143480       db '    mno     ',0     ; DATA XREF: .data:0000010Co
.rdata:00000695                 align 4
.rdata:00000698 $SG143481       db '    pq      ',0     ; DATA XREF: .data:00000110o
.rdata:000006A5                 align 4
.rdata:000006A8 $SG143483       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:000006B3                 align 4
.rdata:000006B4 $SG143484       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:0000011Co
.rdata:000006C0 $SG143485       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000120o
.rdata:000006CC $SG143486       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000124o
.rdata:000006D8 $SG143487       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000128o
.rdata:000006E4 $SG143488       db '#',9,'c #6397E1',0  ; DATA XREF: .data:0000012Co
.rdata:000006F0 $SG143489       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000130o
.rdata:000006FC $SG143490       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000134o
.rdata:00000708 $SG143491       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000138o
.rdata:00000714 $SG143492       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:0000013Co
.rdata:00000720 $SG143493       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000140o
.rdata:0000072C $SG143494       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000144o
.rdata:00000738 $SG143495       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000148o
.rdata:00000744 $SG143496       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:0000014Co
.rdata:00000750 $SG143497       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000150o
.rdata:0000075C $SG143498       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000154o
.rdata:00000768 $SG143499       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000158o
.rdata:00000774 $SG143500       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:0000015Co
.rdata:00000780 $SG143501       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000160o
.rdata:0000078C $SG143502       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000164o
.rdata:00000798 $SG143503       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000168o
.rdata:000007A4 $SG143504       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:0000016Co
.rdata:000007B0 $SG143505       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000170o
.rdata:000007BC $SG143506       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000174o
.rdata:000007C8 $SG143507       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000178o
.rdata:000007D4 $SG143508       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:0000017Co
.rdata:000007E0 $SG143509       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000180o
.rdata:000007EC $SG143510       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000184o
.rdata:000007F8 $SG143511       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000188o
.rdata:00000804 $SG143512       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:0000018Co
.rdata:00000810 $SG143513       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000190o
.rdata:0000081C $SG143514       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000194o
.rdata:00000828 $SG143515       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000198o
.rdata:00000834 $SG143516       db '4',9,'c #195CC6',0  ; DATA XREF: .data:0000019Co
.rdata:00000840 $SG143517       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:000001A0o
.rdata:0000084C $SG143518       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:000001A4o
.rdata:00000858 $SG143519       db '7',9,'c #4885D6',0  ; DATA XREF: .data:000001A8o
.rdata:00000864 $SG143520       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:000001ACo
.rdata:00000870 $SG143521       db '9',9,'c #6698DB',0  ; DATA XREF: .data:000001B0o
.rdata:0000087C $SG143522       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:000001B4o
.rdata:00000888 $SG143523       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:000001B8o
.rdata:00000894 $SG143524       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:000001BCo
.rdata:000008A0 $SG143525       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:000001C0o
.rdata:000008AC $SG143526       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:000001C4o
.rdata:000008B8 $SG143527       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:000001C8o
.rdata:000008C4 $SG143528       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:000001CCo
.rdata:000008D0 $SG143529       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:000001D0o
.rdata:000008DC $SG143530       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:000001D4o
.rdata:000008E8 $SG143531       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:000001D8o
.rdata:000008F4 $SG143532       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:000001DCo
.rdata:00000900 $SG143533       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:000001E0o
.rdata:0000090C $SG143534       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:000001E4o
.rdata:00000918 $SG143535       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:000001E8o
.rdata:00000924 $SG143536       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:000001ECo
.rdata:00000930 $SG143537       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:000001F0o
.rdata:0000093C $SG143538       db '         .+ ',0     ; DATA XREF: .data:000001F4o
.rdata:00000949                 align 4
.rdata:0000094C $SG143539       db '        @#$ ',0     ; DATA XREF: .data:000001F8o
.rdata:00000959                 align 4
.rdata:0000095C $SG143540       db '       %&*= L',0    ; DATA XREF: .data:000001FCo
.rdata:0000096A                 align 4
.rdata:0000096C $SG143541       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000200o
.rdata:00000979                 align 4
.rdata:0000097C $SG143542       db '     )!>~{] ',0     ; DATA XREF: .data:00000204o
.rdata:00000989                 align 4
.rdata:0000098C $SG143543       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000208o
.rdata:00000999                 align 4
.rdata:0000099C $SG143544       db '    (}|1234 ',0     ; DATA XREF: .data:0000020Co
.rdata:000009A9                 align 4
.rdata:000009AC $SG143545       db '    567890a ',0     ; DATA XREF: .data:00000210o
.rdata:000009B9                 align 4
.rdata:000009BC $SG143546       db '      bcdef ',0     ; DATA XREF: .data:00000214o
.rdata:000009C9                 align 4
.rdata:000009CC $SG143547       db '       ghij ',0     ; DATA XREF: .data:00000218o
.rdata:000009D9                 align 4
.rdata:000009DC $SG143548       db '        klm ',0     ; DATA XREF: .data:0000021Co
.rdata:000009E9                 align 4
.rdata:000009EC $SG143549       db '         no ',0     ; DATA XREF: .data:00000220o
.rdata:000009F9                 align 4
.rdata:000009FC $SG143551       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:00000A07                 align 4
.rdata:00000A08 $SG143552       db ' ',9,'c None',0     ; DATA XREF: .data:0000022Co
.rdata:00000A11                 align 4
.rdata:00000A14 $SG143553       db '.',9,'c #545254',0  ; DATA XREF: .data:00000230o
.rdata:00000A20 $SG143554       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000234o
.rdata:00000A2C $SG143555       db '@',9,'c #646464',0  ; DATA XREF: .data:00000238o
.rdata:00000A38 $SG143556       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:0000023Co
.rdata:00000A44 $SG143557       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000240o
.rdata:00000A50 $SG143558       db '%',9,'c #747284',0  ; DATA XREF: .data:00000244o
.rdata:00000A5C $SG143559       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000248o
.rdata:00000A68 $SG143560       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:0000024Co
.rdata:00000A74 $SG143561       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000250o
.rdata:00000A80 $SG143562       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000254o
.rdata:00000A8C $SG143563       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000258o
.rdata:00000A98 $SG143564       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:0000025Co
.rdata:00000AA4 $SG143565       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000260o
.rdata:00000AB0 $SG143566       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000264o
.rdata:00000ABC $SG143567       db ')',9,'c #282668',0  ; DATA XREF: .data:00000268o
.rdata:00000AC8 $SG143568       db '!',9,'c #24367C',0  ; DATA XREF: .data:0000026Co
.rdata:00000AD4 $SG143569       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000270o
.rdata:00000AE0 $SG143570       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000274o
.rdata:00000AEC $SG143571       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000278o
.rdata:00000AF8 $SG143572       db '^',9,'c #142E7C',0  ; DATA XREF: .data:0000027Co
.rdata:00000B04 $SG143573       db '/',9,'c #143789',0  ; DATA XREF: .data:00000280o
.rdata:00000B10 $SG143574       db '(',9,'c #204990',0  ; DATA XREF: .data:00000284o
.rdata:00000B1C $SG143575       db '_',9,'c #174091',0  ; DATA XREF: .data:00000288o
.rdata:00000B28 $SG143576       db ':',9,'c #0C0630',0  ; DATA XREF: .data:0000028Co
.rdata:00000B34 $SG143577       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000290o
.rdata:00000B40 $SG143578       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000294o
.rdata:00000B4C $SG143579       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000298o
.rdata:00000B58 $SG143580       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:0000029Co
.rdata:00000B64 $SG143581       db '1',9,'c #141244',0  ; DATA XREF: .data:000002A0o
.rdata:00000B70 $SG143582       db '2',9,'c #24428C',0  ; DATA XREF: .data:000002A4o
.rdata:00000B7C $SG143583       db '3',9,'c #3462B9',0  ; DATA XREF: .data:000002A8o
.rdata:00000B88 $SG143584       db '4',9,'c #4470C4',0  ; DATA XREF: .data:000002ACo
.rdata:00000B94 $SG143585       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:000002B0o
.rdata:00000BA0 $SG143586       db '6',9,'c #4472CC',0  ; DATA XREF: .data:000002B4o
.rdata:00000BAC $SG143587       db '7',9,'c #24224C',0  ; DATA XREF: .data:000002B8o
.rdata:00000BB8 $SG143588       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:000002BCo
.rdata:00000BC4 $SG143589       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:000002C0o
.rdata:00000BD0 $SG143590       db '0',9,'c #5482DF',0  ; DATA XREF: .data:000002C4o
.rdata:00000BDC $SG143591       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:000002C8o
.rdata:00000BE8 $SG143592       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:000002CCo
.rdata:00000BF4 $SG143593       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:000002D0o
.rdata:00000C00 $SG143594       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:000002D4o
.rdata:00000C0C $SG143595       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:000002D8o
.rdata:00000C18 $SG143596       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:000002DCo
.rdata:00000C24 $SG143597       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:000002E0o
.rdata:00000C30 $SG143598       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:000002E4o
.rdata:00000C3C $SG143599       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:000002E8o
.rdata:00000C48 $SG143600       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:000002ECo
.rdata:00000C54 $SG143601       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:000002F0o
.rdata:00000C60 $SG143602       db 'l',9,'c #243250',0  ; DATA XREF: .data:000002F4o
.rdata:00000C6C $SG143603       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:000002F8o
.rdata:00000C78 $SG143604       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:000002FCo
.rdata:00000C84 $SG143605       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000300o
.rdata:00000C90 $SG143606       db '     .+.     ',0    ; DATA XREF: .data:00000304o
.rdata:00000C9E                 align 10h
.rdata:00000CA0 $SG143607       db '   @##$##@   ',0    ; DATA XREF: .data:00000308o
.rdata:00000CAE                 align 10h
.rdata:00000CB0 $SG143608       db '  @%&***&%@  ',0    ; DATA XREF: .data:0000030Co
.rdata:00000CBE                 align 10h
.rdata:00000CC0 $SG143609       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000310o
.rdata:00000CCE                 align 10h
.rdata:00000CD0 $SG143610       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:00000CD0                                         ; DATA XREF: .data:00000314o
.rdata:00000CDE                 align 10h
.rdata:00000CE0 $SG143611       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000318o
.rdata:00000CEE                 align 10h
.rdata:00000CF0 $SG143612       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:0000031Co
.rdata:00000CFE                 align 10h
.rdata:00000D00 $SG143613       db '12[3455563[21',0    ; DATA XREF: .data:00000320o
.rdata:00000D0E                 align 10h
.rdata:00000D10 $SG143614       db '7_365899063_7',0    ; DATA XREF: .data:00000324o
.rdata:00000D1E                 align 10h
.rdata:00000D20 $SG143615       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000328o
.rdata:00000D2E                 align 10h
.rdata:00000D30 $SG143616       db ' d}8efgfb83d ',0    ; DATA XREF: .data:0000032Co
.rdata:00000D3E                 align 10h
.rdata:00000D40 $SG143617       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000330o
.rdata:00000D4E                 align 10h
.rdata:00000D50 $SG143618       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000334o
.rdata:00000D5E                 align 10h
.rdata:00000D60 $SG143619       db '     o@o     ',0    ; DATA XREF: .data:00000338o
.rdata:00000D6E                 align 10h
.rdata:00000D70 ; const WCHAR _SG151208
.rdata:00000D70 $SG151208:                              ; DATA XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+11Ao
.rdata:00000D70                 unicode 0, <Range Value problem>,0
.rdata:00000D98                 db    0
.rdata:00000D99                 db    0
.rdata:00000D9A                 db    0
.rdata:00000D9B                 db    0
.rdata:00000D9C ; const WCHAR _SG151209
.rdata:00000D9C $SG151209:                              ; DATA XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+11Fo
.rdata:00000D9C                 unicode 0, <You should type between from 0 to 255.>,0
.rdata:00000DEA                 align 4
.rdata:00000DEA _rdata          ends
.rdata:00000DEA
.text$mn:00000DEC ; ===========================================================================
.text$mn:00000DEC
.text$mn:00000DEC ; Segment type: Pure code
.text$mn:00000DEC ; Segment permissions: Read/Execute
.text$mn:00000DEC _text$mn        segment para public 'CODE' use32
.text$mn:00000DEC                 assume cs:_text$mn
.text$mn:00000DEC                 ;org 0DECh
.text$mn:00000DEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000DEC
.text$mn:00000DEC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DEC
.text$mn:00000DEC ; Attributes: bp-based frame
.text$mn:00000DEC
.text$mn:00000DEC ; int __stdcall FindCharsInRangeDlg::run_dlgProc(FindCharsInRangeDlg *this, unsigned int, unsigned int, __int32)
.text$mn:00000DEC                 public ?run_dlgProc@FindCharsInRangeDlg@@MAGHIIJ@Z
.text$mn:00000DEC ?run_dlgProc@FindCharsInRangeDlg@@MAGHIIJ@Z proc near
.text$mn:00000DEC
.text$mn:00000DEC var_10          = dword ptr -10h
.text$mn:00000DEC var_C           = dword ptr -0Ch
.text$mn:00000DEC var_8           = dword ptr -8
.text$mn:00000DEC var_4           = byte ptr -4
.text$mn:00000DEC var_3           = byte ptr -3
.text$mn:00000DEC var_2           = byte ptr -2
.text$mn:00000DEC var_1           = byte ptr -1
.text$mn:00000DEC this            = dword ptr  8
.text$mn:00000DEC arg_4           = dword ptr  0Ch
.text$mn:00000DEC arg_8           = dword ptr  10h
.text$mn:00000DEC
.text$mn:00000DEC                 push    ebp
.text$mn:00000DED                 mov     ebp, esp
.text$mn:00000DEF                 sub     esp, 10h
.text$mn:00000DF2                 mov     eax, [ebp+arg_4]
.text$mn:00000DF5                 mov     [ebp+var_8], eax
.text$mn:00000DF8                 cmp     [ebp+var_8], 110h
.text$mn:00000DFF                 jz      short loc_E13
.text$mn:00000E01                 cmp     [ebp+var_8], 111h
.text$mn:00000E08                 jz      loc_E91
.text$mn:00000E0E                 jmp     loc_F5B
.text$mn:00000E13 ; ---------------------------------------------------------------------------
.text$mn:00000E13
.text$mn:00000E13 loc_E13:                                ; CODE XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+13j
.text$mn:00000E13                 push    0               ; lParam
.text$mn:00000E15                 push    3               ; wParam
.text$mn:00000E17                 push    0C5h ; '+'      ; Msg
.text$mn:00000E1C                 push    0B58h           ; nIDDlgItem
.text$mn:00000E21                 mov     ecx, [ebp+this]
.text$mn:00000E24                 mov     edx, [ecx+0Ch]
.text$mn:00000E27                 push    edx             ; hDlg
.text$mn:00000E28                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000E2E                 push    0               ; lParam
.text$mn:00000E30                 push    3               ; wParam
.text$mn:00000E32                 push    0C5h ; '+'      ; Msg
.text$mn:00000E37                 push    0B59h           ; nIDDlgItem
.text$mn:00000E3C                 mov     eax, [ebp+this]
.text$mn:00000E3F                 mov     ecx, [eax+0Ch]
.text$mn:00000E42                 push    ecx             ; hDlg
.text$mn:00000E43                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000E49                 push    0               ; lParam
.text$mn:00000E4B                 push    1               ; wParam
.text$mn:00000E4D                 push    0F1h ; '±'      ; Msg
.text$mn:00000E52                 push    0B55h           ; nIDDlgItem
.text$mn:00000E57                 mov     edx, [ebp+this]
.text$mn:00000E5A                 mov     eax, [edx+0Ch]
.text$mn:00000E5D                 push    eax             ; hDlg
.text$mn:00000E5E                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000E64                 push    0               ; lParam
.text$mn:00000E66                 push    1               ; wParam
.text$mn:00000E68                 push    0F1h ; '±'      ; Msg
.text$mn:00000E6D                 push    0B5Bh           ; nIDDlgItem
.text$mn:00000E72                 mov     ecx, [ebp+this]
.text$mn:00000E75                 mov     edx, [ecx+0Ch]
.text$mn:00000E78                 push    edx             ; hDlg
.text$mn:00000E79                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000E7F                 mov     ecx, [ebp+this] ; this
.text$mn:00000E82                 call    ?goToCenter@StaticDialog@@QAEXXZ ; StaticDialog::goToCenter(void)
.text$mn:00000E87                 mov     eax, 1
.text$mn:00000E8C                 jmp     loc_F5D
.text$mn:00000E91 ; ---------------------------------------------------------------------------
.text$mn:00000E91
.text$mn:00000E91 loc_E91:                                ; CODE XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+1Cj
.text$mn:00000E91                 mov     eax, [ebp+arg_8]
.text$mn:00000E94                 mov     [ebp+var_C], eax
.text$mn:00000E97                 cmp     [ebp+var_C], 2
.text$mn:00000E9B                 jz      short loc_EAB
.text$mn:00000E9D                 cmp     [ebp+var_C], 0B5Eh
.text$mn:00000EA4                 jz      short loc_EC4
.text$mn:00000EA6                 jmp     loc_F5B
.text$mn:00000EAB ; ---------------------------------------------------------------------------
.text$mn:00000EAB
.text$mn:00000EAB loc_EAB:                                ; CODE XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+AFj
.text$mn:00000EAB                 push    0
.text$mn:00000EAD                 mov     ecx, [ebp+this]
.text$mn:00000EB0                 mov     edx, [ecx]
.text$mn:00000EB2                 mov     ecx, [ebp+this]
.text$mn:00000EB5                 mov     eax, [edx+0Ch]
.text$mn:00000EB8                 call    eax
.text$mn:00000EBA                 mov     eax, 1
.text$mn:00000EBF                 jmp     loc_F5D
.text$mn:00000EC4 ; ---------------------------------------------------------------------------
.text$mn:00000EC4
.text$mn:00000EC4 loc_EC4:                                ; CODE XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+B8j
.text$mn:00000EC4                 push    0               ; __int32
.text$mn:00000EC6                 push    0               ; unsigned int
.text$mn:00000EC8                 push    7D8h            ; unsigned int
.text$mn:00000ECD                 mov     ecx, [ebp+this]
.text$mn:00000ED0                 mov     edx, [ecx+20h]
.text$mn:00000ED3                 mov     ecx, [edx]      ; this
.text$mn:00000ED5                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00000EDA                 mov     [ebp+var_10], eax
.text$mn:00000EDD                 mov     [ebp+var_4], 0
.text$mn:00000EE1                 mov     [ebp+var_3], 0FFh
.text$mn:00000EE5                 mov     [ebp+var_2], 0
.text$mn:00000EE9                 mov     [ebp+var_1], 1
.text$mn:00000EED                 lea     eax, [ebp+var_3]
.text$mn:00000EF0                 push    eax             ; unsigned __int8 *
.text$mn:00000EF1                 lea     ecx, [ebp+var_4]
.text$mn:00000EF4                 push    ecx             ; unsigned __int8 *
.text$mn:00000EF5                 mov     ecx, [ebp+this] ; this
.text$mn:00000EF8                 call    ?getRangeFromUI@FindCharsInRangeDlg@@AAE_NAAE0@Z ; FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)
.text$mn:00000EFD                 movzx   edx, al
.text$mn:00000F00                 test    edx, edx
.text$mn:00000F02                 jnz     short loc_F24
.text$mn:00000F04                 push    0               ; uType
.text$mn:00000F06                 push    offset $SG151208 ; "Range Value problem"
.text$mn:00000F0B                 push    offset $SG151209 ; "You should type between from 0 to 255."
.text$mn:00000F10                 mov     eax, [ebp+this]
.text$mn:00000F13                 mov     ecx, [eax+0Ch]
.text$mn:00000F16                 push    ecx             ; hWnd
.text$mn:00000F17                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:00000F1D                 mov     eax, 1
.text$mn:00000F22                 jmp     short loc_F5D
.text$mn:00000F24 ; ---------------------------------------------------------------------------
.text$mn:00000F24
.text$mn:00000F24 loc_F24:                                ; CODE XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+116j
.text$mn:00000F24                 lea     edx, [ebp+var_1]
.text$mn:00000F27                 push    edx             ; bool *
.text$mn:00000F28                 lea     eax, [ebp+var_2]
.text$mn:00000F2B                 push    eax             ; bool *
.text$mn:00000F2C                 mov     ecx, [ebp+this] ; this
.text$mn:00000F2F                 call    ?getDirectionFromUI@FindCharsInRangeDlg@@AAEXAA_N0@Z ; FindCharsInRangeDlg::getDirectionFromUI(bool &,bool &)
.text$mn:00000F34                 movzx   ecx, [ebp+var_1]
.text$mn:00000F38                 push    ecx             ; bool
.text$mn:00000F39                 movzx   edx, [ebp+var_2]
.text$mn:00000F3D                 push    edx             ; bool
.text$mn:00000F3E                 mov     eax, [ebp+var_10]
.text$mn:00000F41                 push    eax             ; int
.text$mn:00000F42                 movzx   ecx, [ebp+var_3]
.text$mn:00000F46                 push    ecx             ; char
.text$mn:00000F47                 movzx   edx, [ebp+var_4]
.text$mn:00000F4B                 push    edx             ; char
.text$mn:00000F4C                 mov     ecx, [ebp+this] ; this
.text$mn:00000F4F                 call    ?findCharInRange@FindCharsInRangeDlg@@AAE_NEEH_N0@Z ; FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)
.text$mn:00000F54                 mov     eax, 1
.text$mn:00000F59                 jmp     short loc_F5D
.text$mn:00000F5B ; ---------------------------------------------------------------------------
.text$mn:00000F5B
.text$mn:00000F5B loc_F5B:                                ; CODE XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+22j
.text$mn:00000F5B                                         ; FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+BAj
.text$mn:00000F5B                 xor     eax, eax
.text$mn:00000F5D
.text$mn:00000F5D loc_F5D:                                ; CODE XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+A0j
.text$mn:00000F5D                                         ; FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+D3j ...
.text$mn:00000F5D                 mov     esp, ebp
.text$mn:00000F5F                 pop     ebp
.text$mn:00000F60                 retn    10h
.text$mn:00000F60 ?run_dlgProc@FindCharsInRangeDlg@@MAGHIIJ@Z endp
.text$mn:00000F60
.text$mn:00000F60 ; ---------------------------------------------------------------------------
.text$mn:00000F63                 db 9 dup(0CCh)
.text$mn:00000F6C
.text$mn:00000F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F6C
.text$mn:00000F6C ; Attributes: bp-based frame
.text$mn:00000F6C
.text$mn:00000F6C ; bool __thiscall FindCharsInRangeDlg::findCharInRange(FindCharsInRangeDlg *this, char, char, int, bool, bool)
.text$mn:00000F6C                 public ?findCharInRange@FindCharsInRangeDlg@@AAE_NEEH_N0@Z
.text$mn:00000F6C ?findCharInRange@FindCharsInRangeDlg@@AAE_NEEH_N0@Z proc near
.text$mn:00000F6C                                         ; CODE XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+163p
.text$mn:00000F6C
.text$mn:00000F6C var_5C          = dword ptr -5Ch
.text$mn:00000F6C var_58          = dword ptr -58h
.text$mn:00000F6C var_54          = dword ptr -54h
.text$mn:00000F6C var_50          = dword ptr -50h
.text$mn:00000F6C var_4C          = dword ptr -4Ch
.text$mn:00000F6C var_48          = dword ptr -48h
.text$mn:00000F6C var_44          = dword ptr -44h
.text$mn:00000F6C var_40          = dword ptr -40h
.text$mn:00000F6C var_3C          = dword ptr -3Ch
.text$mn:00000F6C var_38          = dword ptr -38h
.text$mn:00000F6C var_34          = dword ptr -34h
.text$mn:00000F6C var_30          = dword ptr -30h
.text$mn:00000F6C var_2C          = dword ptr -2Ch
.text$mn:00000F6C var_28          = dword ptr -28h
.text$mn:00000F6C var_24          = dword ptr -24h
.text$mn:00000F6C var_20          = dword ptr -20h
.text$mn:00000F6C var_1C          = dword ptr -1Ch
.text$mn:00000F6C var_18          = dword ptr -18h
.text$mn:00000F6C var_14          = dword ptr -14h
.text$mn:00000F6C var_10          = dword ptr -10h
.text$mn:00000F6C var_C           = dword ptr -0Ch
.text$mn:00000F6C var_8           = dword ptr -8
.text$mn:00000F6C var_4           = dword ptr -4
.text$mn:00000F6C arg_0           = byte ptr  8
.text$mn:00000F6C arg_4           = byte ptr  0Ch
.text$mn:00000F6C arg_8           = dword ptr  10h
.text$mn:00000F6C arg_C           = byte ptr  14h
.text$mn:00000F6C arg_10          = byte ptr  18h
.text$mn:00000F6C
.text$mn:00000F6C                 push    ebp
.text$mn:00000F6D                 mov     ebp, esp
.text$mn:00000F6F                 sub     esp, 5Ch
.text$mn:00000F72                 mov     [ebp+var_14], ecx
.text$mn:00000F75                 mov     eax, [ebp+var_14]
.text$mn:00000F78                 mov     ecx, [eax+20h]
.text$mn:00000F7B                 mov     ecx, [ecx]      ; this
.text$mn:00000F7D                 call    ?getCurrentDocLen@ScintillaEditView@@QBEHXZ ; ScintillaEditView::getCurrentDocLen(void)
.text$mn:00000F82                 mov     [ebp+var_10], eax
.text$mn:00000F85                 cmp     [ebp+arg_8], 0FFFFFFFFh
.text$mn:00000F89                 jnz     short loc_FAB
.text$mn:00000F8B                 movzx   edx, [ebp+arg_C]
.text$mn:00000F8F                 test    edx, edx
.text$mn:00000F91                 jnz     short loc_F9C
.text$mn:00000F93                 mov     [ebp+var_1C], 0
.text$mn:00000F9A                 jmp     short loc_FA5
.text$mn:00000F9C ; ---------------------------------------------------------------------------
.text$mn:00000F9C
.text$mn:00000F9C loc_F9C:                                ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+25j
.text$mn:00000F9C                 mov     eax, [ebp+var_10]
.text$mn:00000F9F                 sub     eax, 1
.text$mn:00000FA2                 mov     [ebp+var_1C], eax
.text$mn:00000FA5
.text$mn:00000FA5 loc_FA5:                                ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+2Ej
.text$mn:00000FA5                 mov     ecx, [ebp+var_1C]
.text$mn:00000FA8                 mov     [ebp+arg_8], ecx
.text$mn:00000FAB
.text$mn:00000FAB loc_FAB:                                ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+1Dj
.text$mn:00000FAB                 mov     edx, [ebp+arg_8]
.text$mn:00000FAE                 cmp     edx, [ebp+var_10]
.text$mn:00000FB1                 jle     short loc_FBA
.text$mn:00000FB3                 xor     al, al
.text$mn:00000FB5                 jmp     loc_125B
.text$mn:00000FBA ; ---------------------------------------------------------------------------
.text$mn:00000FBA
.text$mn:00000FBA loc_FBA:                                ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+45j
.text$mn:00000FBA                 mov     eax, [ebp+var_10]
.text$mn:00000FBD                 add     eax, 1
.text$mn:00000FC0                 push    eax             ; unsigned int
.text$mn:00000FC1                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00000FC6                 add     esp, 4
.text$mn:00000FC9                 mov     [ebp+var_4C], eax
.text$mn:00000FCC                 mov     ecx, [ebp+var_4C]
.text$mn:00000FCF                 mov     [ebp+var_18], ecx
.text$mn:00000FD2                 mov     edx, [ebp+var_10]
.text$mn:00000FD5                 push    edx             ; int
.text$mn:00000FD6                 push    0               ; int
.text$mn:00000FD8                 mov     eax, [ebp+var_18]
.text$mn:00000FDB                 push    eax             ; char *
.text$mn:00000FDC                 mov     ecx, [ebp+var_14]
.text$mn:00000FDF                 mov     edx, [ecx+20h]
.text$mn:00000FE2                 mov     ecx, [edx]      ; this
.text$mn:00000FE4                 call    ?getText@ScintillaEditView@@QBEXPADHH@Z ; ScintillaEditView::getText(char *,int,int)
.text$mn:00000FE9                 mov     [ebp+var_C], 0FFFFFFFFh
.text$mn:00000FF0                 movzx   eax, [ebp+arg_C]
.text$mn:00000FF4                 cmp     eax, 1
.text$mn:00000FF7                 jnz     short loc_1002
.text$mn:00000FF9                 mov     [ebp+var_20], 1
.text$mn:00001000                 jmp     short loc_1009
.text$mn:00001002 ; ---------------------------------------------------------------------------
.text$mn:00001002
.text$mn:00001002 loc_1002:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+8Bj
.text$mn:00001002                 mov     [ebp+var_20], 0
.text$mn:00001009
.text$mn:00001009 loc_1009:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+94j
.text$mn:00001009                 mov     ecx, [ebp+arg_8]
.text$mn:0000100C                 sub     ecx, [ebp+var_20]
.text$mn:0000100F                 mov     [ebp+var_4], ecx
.text$mn:00001012                 jmp     short loc_103C
.text$mn:00001014 ; ---------------------------------------------------------------------------
.text$mn:00001014
.text$mn:00001014 loc_1014:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool):loc_10B0j
.text$mn:00001014                 movzx   edx, [ebp+arg_C]
.text$mn:00001018                 test    edx, edx
.text$mn:0000101A                 jnz     short loc_102D
.text$mn:0000101C                 mov     eax, [ebp+var_4]
.text$mn:0000101F                 add     eax, 1
.text$mn:00001022                 mov     [ebp+var_4], eax
.text$mn:00001025                 mov     ecx, [ebp+var_4]
.text$mn:00001028                 mov     [ebp+var_50], ecx
.text$mn:0000102B                 jmp     short loc_103C
.text$mn:0000102D ; ---------------------------------------------------------------------------
.text$mn:0000102D
.text$mn:0000102D loc_102D:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+AEj
.text$mn:0000102D                 mov     edx, [ebp+var_4]
.text$mn:00001030                 sub     edx, 1
.text$mn:00001033                 mov     [ebp+var_4], edx
.text$mn:00001036                 mov     eax, [ebp+var_4]
.text$mn:00001039                 mov     [ebp+var_50], eax
.text$mn:0000103C
.text$mn:0000103C loc_103C:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+A6j
.text$mn:0000103C                                         ; FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+BFj
.text$mn:0000103C                 movzx   ecx, [ebp+arg_C]
.text$mn:00001040                 test    ecx, ecx
.text$mn:00001042                 jnz     short loc_1064
.text$mn:00001044                 mov     edx, [ebp+var_4]
.text$mn:00001047                 cmp     edx, [ebp+var_10]
.text$mn:0000104A                 jge     short loc_1055
.text$mn:0000104C                 mov     [ebp+var_24], 1
.text$mn:00001053                 jmp     short loc_105C
.text$mn:00001055 ; ---------------------------------------------------------------------------
.text$mn:00001055
.text$mn:00001055 loc_1055:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+DEj
.text$mn:00001055                 mov     [ebp+var_24], 0
.text$mn:0000105C
.text$mn:0000105C loc_105C:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+E7j
.text$mn:0000105C                 mov     eax, [ebp+var_24]
.text$mn:0000105F                 mov     [ebp+var_2C], eax
.text$mn:00001062                 jmp     short loc_1080
.text$mn:00001064 ; ---------------------------------------------------------------------------
.text$mn:00001064
.text$mn:00001064 loc_1064:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+D6j
.text$mn:00001064                 cmp     [ebp+var_4], 0
.text$mn:00001068                 jl      short loc_1073
.text$mn:0000106A                 mov     [ebp+var_28], 1
.text$mn:00001071                 jmp     short loc_107A
.text$mn:00001073 ; ---------------------------------------------------------------------------
.text$mn:00001073
.text$mn:00001073 loc_1073:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+FCj
.text$mn:00001073                 mov     [ebp+var_28], 0
.text$mn:0000107A
.text$mn:0000107A loc_107A:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+105j
.text$mn:0000107A                 mov     ecx, [ebp+var_28]
.text$mn:0000107D                 mov     [ebp+var_2C], ecx
.text$mn:00001080
.text$mn:00001080 loc_1080:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+F6j
.text$mn:00001080                 cmp     [ebp+var_2C], 0
.text$mn:00001084                 jz      short loc_10B5
.text$mn:00001086                 mov     edx, [ebp+var_18]
.text$mn:00001089                 add     edx, [ebp+var_4]
.text$mn:0000108C                 movzx   eax, byte ptr [edx]
.text$mn:0000108F                 movzx   ecx, [ebp+arg_0]
.text$mn:00001093                 cmp     eax, ecx
.text$mn:00001095                 jl      short loc_10B0
.text$mn:00001097                 mov     edx, [ebp+var_18]
.text$mn:0000109A                 add     edx, [ebp+var_4]
.text$mn:0000109D                 movzx   eax, byte ptr [edx]
.text$mn:000010A0                 movzx   ecx, [ebp+arg_4]
.text$mn:000010A4                 cmp     eax, ecx
.text$mn:000010A6                 jg      short loc_10B0
.text$mn:000010A8                 mov     edx, [ebp+var_4]
.text$mn:000010AB                 mov     [ebp+var_C], edx
.text$mn:000010AE                 jmp     short loc_10B5
.text$mn:000010B0 ; ---------------------------------------------------------------------------
.text$mn:000010B0
.text$mn:000010B0 loc_10B0:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+129j
.text$mn:000010B0                                         ; FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+13Aj
.text$mn:000010B0                 jmp     loc_1014
.text$mn:000010B5 ; ---------------------------------------------------------------------------
.text$mn:000010B5
.text$mn:000010B5 loc_10B5:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+118j
.text$mn:000010B5                                         ; FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+142j
.text$mn:000010B5                 cmp     [ebp+var_C], 0FFFFFFFFh
.text$mn:000010B9                 jnz     loc_118F
.text$mn:000010BF                 movzx   eax, [ebp+arg_10]
.text$mn:000010C3                 test    eax, eax
.text$mn:000010C5                 jz      loc_118F
.text$mn:000010CB                 movzx   ecx, [ebp+arg_C]
.text$mn:000010CF                 cmp     ecx, 1
.text$mn:000010D2                 jnz     short loc_10DF
.text$mn:000010D4                 mov     edx, [ebp+var_10]
.text$mn:000010D7                 sub     edx, 1
.text$mn:000010DA                 mov     [ebp+var_30], edx
.text$mn:000010DD                 jmp     short loc_10E6
.text$mn:000010DF ; ---------------------------------------------------------------------------
.text$mn:000010DF
.text$mn:000010DF loc_10DF:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+166j
.text$mn:000010DF                 mov     [ebp+var_30], 0
.text$mn:000010E6
.text$mn:000010E6 loc_10E6:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+171j
.text$mn:000010E6                 mov     eax, [ebp+var_30]
.text$mn:000010E9                 mov     [ebp+var_8], eax
.text$mn:000010EC                 jmp     short loc_1116
.text$mn:000010EE ; ---------------------------------------------------------------------------
.text$mn:000010EE
.text$mn:000010EE loc_10EE:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool):loc_118Aj
.text$mn:000010EE                 movzx   ecx, [ebp+arg_C]
.text$mn:000010F2                 test    ecx, ecx
.text$mn:000010F4                 jnz     short loc_1107
.text$mn:000010F6                 mov     edx, [ebp+var_8]
.text$mn:000010F9                 add     edx, 1
.text$mn:000010FC                 mov     [ebp+var_8], edx
.text$mn:000010FF                 mov     eax, [ebp+var_8]
.text$mn:00001102                 mov     [ebp+var_54], eax
.text$mn:00001105                 jmp     short loc_1116
.text$mn:00001107 ; ---------------------------------------------------------------------------
.text$mn:00001107
.text$mn:00001107 loc_1107:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+188j
.text$mn:00001107                 mov     ecx, [ebp+var_8]
.text$mn:0000110A                 sub     ecx, 1
.text$mn:0000110D                 mov     [ebp+var_8], ecx
.text$mn:00001110                 mov     edx, [ebp+var_8]
.text$mn:00001113                 mov     [ebp+var_54], edx
.text$mn:00001116
.text$mn:00001116 loc_1116:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+180j
.text$mn:00001116                                         ; FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+199j
.text$mn:00001116                 movzx   eax, [ebp+arg_C]
.text$mn:0000111A                 test    eax, eax
.text$mn:0000111C                 jnz     short loc_113E
.text$mn:0000111E                 mov     ecx, [ebp+var_8]
.text$mn:00001121                 cmp     ecx, [ebp+var_10]
.text$mn:00001124                 jge     short loc_112F
.text$mn:00001126                 mov     [ebp+var_34], 1
.text$mn:0000112D                 jmp     short loc_1136
.text$mn:0000112F ; ---------------------------------------------------------------------------
.text$mn:0000112F
.text$mn:0000112F loc_112F:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+1B8j
.text$mn:0000112F                 mov     [ebp+var_34], 0
.text$mn:00001136
.text$mn:00001136 loc_1136:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+1C1j
.text$mn:00001136                 mov     edx, [ebp+var_34]
.text$mn:00001139                 mov     [ebp+var_3C], edx
.text$mn:0000113C                 jmp     short loc_115A
.text$mn:0000113E ; ---------------------------------------------------------------------------
.text$mn:0000113E
.text$mn:0000113E loc_113E:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+1B0j
.text$mn:0000113E                 cmp     [ebp+var_8], 0
.text$mn:00001142                 jl      short loc_114D
.text$mn:00001144                 mov     [ebp+var_38], 1
.text$mn:0000114B                 jmp     short loc_1154
.text$mn:0000114D ; ---------------------------------------------------------------------------
.text$mn:0000114D
.text$mn:0000114D loc_114D:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+1D6j
.text$mn:0000114D                 mov     [ebp+var_38], 0
.text$mn:00001154
.text$mn:00001154 loc_1154:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+1DFj
.text$mn:00001154                 mov     eax, [ebp+var_38]
.text$mn:00001157                 mov     [ebp+var_3C], eax
.text$mn:0000115A
.text$mn:0000115A loc_115A:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+1D0j
.text$mn:0000115A                 cmp     [ebp+var_3C], 0
.text$mn:0000115E                 jz      short loc_118F
.text$mn:00001160                 mov     ecx, [ebp+var_18]
.text$mn:00001163                 add     ecx, [ebp+var_8]
.text$mn:00001166                 movzx   edx, byte ptr [ecx]
.text$mn:00001169                 movzx   eax, [ebp+arg_0]
.text$mn:0000116D                 cmp     edx, eax
.text$mn:0000116F                 jl      short loc_118A
.text$mn:00001171                 mov     ecx, [ebp+var_18]
.text$mn:00001174                 add     ecx, [ebp+var_8]
.text$mn:00001177                 movzx   edx, byte ptr [ecx]
.text$mn:0000117A                 movzx   eax, [ebp+arg_4]
.text$mn:0000117E                 cmp     edx, eax
.text$mn:00001180                 jg      short loc_118A
.text$mn:00001182                 mov     ecx, [ebp+var_8]
.text$mn:00001185                 mov     [ebp+var_C], ecx
.text$mn:00001188                 jmp     short loc_118F
.text$mn:0000118A ; ---------------------------------------------------------------------------
.text$mn:0000118A
.text$mn:0000118A loc_118A:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+203j
.text$mn:0000118A                                         ; FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+214j
.text$mn:0000118A                 jmp     loc_10EE
.text$mn:0000118F ; ---------------------------------------------------------------------------
.text$mn:0000118F
.text$mn:0000118F loc_118F:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+14Dj
.text$mn:0000118F                                         ; FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+159j ...
.text$mn:0000118F                 cmp     [ebp+var_C], 0FFFFFFFFh
.text$mn:00001193                 jz      loc_1230
.text$mn:00001199                 push    0               ; __int32
.text$mn:0000119B                 mov     edx, [ebp+var_C]
.text$mn:0000119E                 push    edx             ; unsigned int
.text$mn:0000119F                 push    876h            ; unsigned int
.text$mn:000011A4                 mov     eax, [ebp+var_14]
.text$mn:000011A7                 mov     ecx, [eax+20h]
.text$mn:000011AA                 mov     ecx, [ecx]      ; this
.text$mn:000011AC                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000011B1                 mov     [ebp+var_58], eax
.text$mn:000011B4                 push    0               ; __int32
.text$mn:000011B6                 mov     edx, [ebp+var_58]
.text$mn:000011B9                 push    edx             ; unsigned int
.text$mn:000011BA                 push    8B8h            ; unsigned int
.text$mn:000011BF                 mov     eax, [ebp+var_14]
.text$mn:000011C2                 mov     ecx, [eax+20h]
.text$mn:000011C5                 mov     ecx, [ecx]      ; this
.text$mn:000011C7                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000011CC                 push    0               ; __int32
.text$mn:000011CE                 mov     edx, [ebp+var_C]
.text$mn:000011D1                 push    edx             ; unsigned int
.text$mn:000011D2                 push    7E9h            ; unsigned int
.text$mn:000011D7                 mov     eax, [ebp+var_14]
.text$mn:000011DA                 mov     ecx, [eax+20h]
.text$mn:000011DD                 mov     ecx, [ecx]      ; this
.text$mn:000011DF                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:000011E4                 movzx   edx, [ebp+arg_C]
.text$mn:000011E8                 test    edx, edx
.text$mn:000011EA                 jnz     short loc_11F7
.text$mn:000011EC                 mov     eax, [ebp+var_C]
.text$mn:000011EF                 add     eax, 1
.text$mn:000011F2                 mov     [ebp+var_40], eax
.text$mn:000011F5                 jmp     short loc_11FD
.text$mn:000011F7 ; ---------------------------------------------------------------------------
.text$mn:000011F7
.text$mn:000011F7 loc_11F7:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+27Ej
.text$mn:000011F7                 mov     ecx, [ebp+var_C]
.text$mn:000011FA                 mov     [ebp+var_40], ecx
.text$mn:000011FD
.text$mn:000011FD loc_11FD:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+289j
.text$mn:000011FD                 movzx   edx, [ebp+arg_C]
.text$mn:00001201                 test    edx, edx
.text$mn:00001203                 jnz     short loc_120D
.text$mn:00001205                 mov     eax, [ebp+var_C]
.text$mn:00001208                 mov     [ebp+var_44], eax
.text$mn:0000120B                 jmp     short loc_1216
.text$mn:0000120D ; ---------------------------------------------------------------------------
.text$mn:0000120D
.text$mn:0000120D loc_120D:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+297j
.text$mn:0000120D                 mov     ecx, [ebp+var_C]
.text$mn:00001210                 add     ecx, 1
.text$mn:00001213                 mov     [ebp+var_44], ecx
.text$mn:00001216
.text$mn:00001216 loc_1216:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+29Fj
.text$mn:00001216                 mov     edx, [ebp+var_40]
.text$mn:00001219                 push    edx             ; __int32
.text$mn:0000121A                 mov     eax, [ebp+var_44]
.text$mn:0000121D                 push    eax             ; unsigned int
.text$mn:0000121E                 push    870h            ; unsigned int
.text$mn:00001223                 mov     ecx, [ebp+var_14]
.text$mn:00001226                 mov     edx, [ecx+20h]
.text$mn:00001229                 mov     ecx, [edx]      ; this
.text$mn:0000122B                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001230
.text$mn:00001230 loc_1230:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+227j
.text$mn:00001230                 mov     eax, [ebp+var_18]
.text$mn:00001233                 mov     [ebp+var_5C], eax
.text$mn:00001236                 mov     ecx, [ebp+var_5C]
.text$mn:00001239                 push    ecx             ; void *
.text$mn:0000123A                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:0000123F                 add     esp, 4
.text$mn:00001242                 cmp     [ebp+var_C], 0FFFFFFFFh
.text$mn:00001246                 jz      short loc_1251
.text$mn:00001248                 mov     [ebp+var_48], 1
.text$mn:0000124F                 jmp     short loc_1258
.text$mn:00001251 ; ---------------------------------------------------------------------------
.text$mn:00001251
.text$mn:00001251 loc_1251:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+2DAj
.text$mn:00001251                 mov     [ebp+var_48], 0
.text$mn:00001258
.text$mn:00001258 loc_1258:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+2E3j
.text$mn:00001258                 mov     al, byte ptr [ebp+var_48]
.text$mn:0000125B
.text$mn:0000125B loc_125B:                               ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+49j
.text$mn:0000125B                 mov     esp, ebp
.text$mn:0000125D                 pop     ebp
.text$mn:0000125E                 retn    14h
.text$mn:0000125E ?findCharInRange@FindCharsInRangeDlg@@AAE_NEEH_N0@Z endp
.text$mn:0000125E
.text$mn:0000125E ; ---------------------------------------------------------------------------
.text$mn:00001261                 db 0Bh dup(0CCh)
.text$mn:0000126C
.text$mn:0000126C ; =============== S U B R O U T I N E =======================================
.text$mn:0000126C
.text$mn:0000126C ; Attributes: bp-based frame
.text$mn:0000126C
.text$mn:0000126C ; bool __thiscall FindCharsInRangeDlg::getRangeFromUI(FindCharsInRangeDlg *this, unsigned __int8 *, unsigned __int8 *)
.text$mn:0000126C                 public ?getRangeFromUI@FindCharsInRangeDlg@@AAE_NAAE0@Z
.text$mn:0000126C ?getRangeFromUI@FindCharsInRangeDlg@@AAE_NAAE0@Z proc near
.text$mn:0000126C                                         ; CODE XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+10Cp
.text$mn:0000126C
.text$mn:0000126C var_14          = dword ptr -14h
.text$mn:0000126C Translated      = dword ptr -10h
.text$mn:0000126C var_C           = dword ptr -0Ch
.text$mn:0000126C var_8           = dword ptr -8
.text$mn:0000126C var_4           = dword ptr -4
.text$mn:0000126C arg_0           = dword ptr  8
.text$mn:0000126C arg_4           = dword ptr  0Ch
.text$mn:0000126C
.text$mn:0000126C                 push    ebp
.text$mn:0000126D                 mov     ebp, esp
.text$mn:0000126F                 sub     esp, 14h
.text$mn:00001272                 mov     [ebp+var_4], ecx
.text$mn:00001275                 push    0B55h           ; int
.text$mn:0000127A                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000127D                 call    ?isCheckedOrNot@StaticDialog@@QBE_NH@Z ; StaticDialog::isCheckedOrNot(int)
.text$mn:00001282                 movzx   eax, al
.text$mn:00001285                 test    eax, eax
.text$mn:00001287                 jz      short loc_129C
.text$mn:00001289                 mov     ecx, [ebp+arg_0]
.text$mn:0000128C                 mov     byte ptr [ecx], 80h ; 'Ç'
.text$mn:0000128F                 mov     edx, [ebp+arg_4]
.text$mn:00001292                 mov     byte ptr [edx], 0FFh
.text$mn:00001295                 mov     al, 1
.text$mn:00001297                 jmp     loc_1355
.text$mn:0000129C ; ---------------------------------------------------------------------------
.text$mn:0000129C
.text$mn:0000129C loc_129C:                               ; CODE XREF: FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)+1Bj
.text$mn:0000129C                 push    0B56h           ; int
.text$mn:000012A1                 mov     ecx, [ebp+var_4] ; this
.text$mn:000012A4                 call    ?isCheckedOrNot@StaticDialog@@QBE_NH@Z ; StaticDialog::isCheckedOrNot(int)
.text$mn:000012A9                 movzx   eax, al
.text$mn:000012AC                 test    eax, eax
.text$mn:000012AE                 jz      short loc_12C3
.text$mn:000012B0                 mov     ecx, [ebp+arg_0]
.text$mn:000012B3                 mov     byte ptr [ecx], 0
.text$mn:000012B6                 mov     edx, [ebp+arg_4]
.text$mn:000012B9                 mov     byte ptr [edx], 7Fh ; ''
.text$mn:000012BC                 mov     al, 1
.text$mn:000012BE                 jmp     loc_1355
.text$mn:000012C3 ; ---------------------------------------------------------------------------
.text$mn:000012C3
.text$mn:000012C3 loc_12C3:                               ; CODE XREF: FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)+42j
.text$mn:000012C3                 push    0B57h           ; int
.text$mn:000012C8                 mov     ecx, [ebp+var_4] ; this
.text$mn:000012CB                 call    ?isCheckedOrNot@StaticDialog@@QBE_NH@Z ; StaticDialog::isCheckedOrNot(int)
.text$mn:000012D0                 movzx   eax, al
.text$mn:000012D3                 test    eax, eax
.text$mn:000012D5                 jz      short loc_1353
.text$mn:000012D7                 push    0               ; bSigned
.text$mn:000012D9                 lea     ecx, [ebp+Translated]
.text$mn:000012DC                 push    ecx             ; lpTranslated
.text$mn:000012DD                 push    0B58h           ; nIDDlgItem
.text$mn:000012E2                 mov     edx, [ebp+var_4]
.text$mn:000012E5                 mov     eax, [edx+0Ch]
.text$mn:000012E8                 push    eax             ; hDlg
.text$mn:000012E9                 call    dword ptr ds:__imp__GetDlgItemInt@16 ; GetDlgItemInt(x,x,x,x)
.text$mn:000012EF                 mov     [ebp+var_8], eax
.text$mn:000012F2                 push    0               ; bSigned
.text$mn:000012F4                 lea     ecx, [ebp+var_14]
.text$mn:000012F7                 push    ecx             ; lpTranslated
.text$mn:000012F8                 push    0B59h           ; nIDDlgItem
.text$mn:000012FD                 mov     edx, [ebp+var_4]
.text$mn:00001300                 mov     eax, [edx+0Ch]
.text$mn:00001303                 push    eax             ; hDlg
.text$mn:00001304                 call    dword ptr ds:__imp__GetDlgItemInt@16 ; GetDlgItemInt(x,x,x,x)
.text$mn:0000130A                 mov     [ebp+var_C], eax
.text$mn:0000130D                 cmp     [ebp+Translated], 0
.text$mn:00001311                 jz      short loc_1319
.text$mn:00001313                 cmp     [ebp+var_14], 0
.text$mn:00001317                 jnz     short loc_131D
.text$mn:00001319
.text$mn:00001319 loc_1319:                               ; CODE XREF: FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)+A5j
.text$mn:00001319                 xor     al, al
.text$mn:0000131B                 jmp     short loc_1355
.text$mn:0000131D ; ---------------------------------------------------------------------------
.text$mn:0000131D
.text$mn:0000131D loc_131D:                               ; CODE XREF: FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)+ABj
.text$mn:0000131D                 cmp     [ebp+var_8], 0FFh
.text$mn:00001324                 jg      short loc_132F
.text$mn:00001326                 cmp     [ebp+var_C], 0FFh
.text$mn:0000132D                 jle     short loc_1333
.text$mn:0000132F
.text$mn:0000132F loc_132F:                               ; CODE XREF: FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)+B8j
.text$mn:0000132F                 xor     al, al
.text$mn:00001331                 jmp     short loc_1355
.text$mn:00001333 ; ---------------------------------------------------------------------------
.text$mn:00001333
.text$mn:00001333 loc_1333:                               ; CODE XREF: FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)+C1j
.text$mn:00001333                 mov     ecx, [ebp+var_8]
.text$mn:00001336                 cmp     ecx, [ebp+var_C]
.text$mn:00001339                 jle     short loc_133F
.text$mn:0000133B                 xor     al, al
.text$mn:0000133D                 jmp     short loc_1355
.text$mn:0000133F ; ---------------------------------------------------------------------------
.text$mn:0000133F
.text$mn:0000133F loc_133F:                               ; CODE XREF: FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)+CDj
.text$mn:0000133F                 mov     edx, [ebp+arg_0]
.text$mn:00001342                 mov     al, byte ptr [ebp+var_8]
.text$mn:00001345                 mov     [edx], al
.text$mn:00001347                 mov     ecx, [ebp+arg_4]
.text$mn:0000134A                 mov     dl, byte ptr [ebp+var_C]
.text$mn:0000134D                 mov     [ecx], dl
.text$mn:0000134F                 mov     al, 1
.text$mn:00001351                 jmp     short loc_1355
.text$mn:00001353 ; ---------------------------------------------------------------------------
.text$mn:00001353
.text$mn:00001353 loc_1353:                               ; CODE XREF: FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)+69j
.text$mn:00001353                 xor     al, al
.text$mn:00001355
.text$mn:00001355 loc_1355:                               ; CODE XREF: FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)+2Bj
.text$mn:00001355                                         ; FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)+52j ...
.text$mn:00001355                 mov     esp, ebp
.text$mn:00001357                 pop     ebp
.text$mn:00001358                 retn    8
.text$mn:00001358 ?getRangeFromUI@FindCharsInRangeDlg@@AAE_NAAE0@Z endp
.text$mn:00001358
.text$mn:00001358 ; ---------------------------------------------------------------------------
.text$mn:0000135B                 align 4
.text$mn:0000135C
.text$mn:0000135C ; =============== S U B R O U T I N E =======================================
.text$mn:0000135C
.text$mn:0000135C ; Attributes: bp-based frame
.text$mn:0000135C
.text$mn:0000135C ; void __thiscall FindCharsInRangeDlg::getDirectionFromUI(FindCharsInRangeDlg *this, bool *, bool *)
.text$mn:0000135C                 public ?getDirectionFromUI@FindCharsInRangeDlg@@AAEXAA_N0@Z
.text$mn:0000135C ?getDirectionFromUI@FindCharsInRangeDlg@@AAEXAA_N0@Z proc near
.text$mn:0000135C                                         ; CODE XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+143p
.text$mn:0000135C
.text$mn:0000135C var_4           = dword ptr -4
.text$mn:0000135C arg_0           = dword ptr  8
.text$mn:0000135C arg_4           = dword ptr  0Ch
.text$mn:0000135C
.text$mn:0000135C                 push    ebp
.text$mn:0000135D                 mov     ebp, esp
.text$mn:0000135F                 push    ecx
.text$mn:00001360                 mov     [ebp+var_4], ecx
.text$mn:00001363                 push    0B5Ah           ; int
.text$mn:00001368                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000136B                 call    ?isCheckedOrNot@StaticDialog@@QBE_NH@Z ; StaticDialog::isCheckedOrNot(int)
.text$mn:00001370                 mov     ecx, [ebp+arg_0]
.text$mn:00001373                 mov     [ecx], al
.text$mn:00001375                 push    0B5Dh           ; int
.text$mn:0000137A                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000137D                 call    ?isCheckedOrNot@StaticDialog@@QBE_NH@Z ; StaticDialog::isCheckedOrNot(int)
.text$mn:00001382                 mov     edx, [ebp+arg_4]
.text$mn:00001385                 mov     [edx], al
.text$mn:00001387                 mov     esp, ebp
.text$mn:00001389                 pop     ebp
.text$mn:0000138A                 retn    8
.text$mn:0000138A ?getDirectionFromUI@FindCharsInRangeDlg@@AAEXAA_N0@Z endp
.text$mn:0000138A
.text$mn:0000138A ; ---------------------------------------------------------------------------
.text$mn:0000138D                 align 10h
.text$mn:0000138D _text$mn        ends
.text$mn:0000138D
.text$mn:00001390 ; ===========================================================================
.text$mn:00001390
.text$mn:00001390 ; Segment type: Pure code
.text$mn:00001390 ; Segment permissions: Read/Execute
.text$mn:00001390 _text$mn        segment para public 'CODE' use32
.text$mn:00001390                 assume cs:_text$mn
.text$mn:00001390                 ;org 1390h
.text$mn:00001390 ; COMDAT (pick any)
.text$mn:00001390                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001390
.text$mn:00001390 ; =============== S U B R O U T I N E =======================================
.text$mn:00001390
.text$mn:00001390 ; Attributes: bp-based frame
.text$mn:00001390
.text$mn:00001390 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00001390                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00001390 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00001390                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00001390
.text$mn:00001390 var_4           = dword ptr -4
.text$mn:00001390 arg_0           = dword ptr  8
.text$mn:00001390
.text$mn:00001390                 push    ebp
.text$mn:00001391                 mov     ebp, esp
.text$mn:00001393                 push    ecx
.text$mn:00001394                 mov     [ebp+var_4], 0
.text$mn:0000139B                 cmp     [ebp+arg_0], 0
.text$mn:0000139F                 jnz     short loc_13A3
.text$mn:000013A1                 jmp     short loc_13C3
.text$mn:000013A3 ; ---------------------------------------------------------------------------
.text$mn:000013A3
.text$mn:000013A3 loc_13A3:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000013A3                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:000013A7                 ja      short loc_13BE
.text$mn:000013A9                 mov     eax, [ebp+arg_0]
.text$mn:000013AC                 push    eax             ; unsigned int
.text$mn:000013AD                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000013B2                 add     esp, 4
.text$mn:000013B5                 mov     [ebp+var_4], eax
.text$mn:000013B8                 cmp     [ebp+var_4], 0
.text$mn:000013BC                 jnz     short loc_13C3
.text$mn:000013BE
.text$mn:000013BE loc_13BE:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000013BE                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000013C3
.text$mn:000013C3 loc_13C3:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000013C3                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000013C3                 mov     eax, [ebp+var_4]
.text$mn:000013C6                 mov     esp, ebp
.text$mn:000013C8                 pop     ebp
.text$mn:000013C9                 retn
.text$mn:000013C9 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000013C9
.text$mn:000013C9 ; ---------------------------------------------------------------------------
.text$mn:000013CA                 align 4
.text$mn:000013CA _text$mn        ends
.text$mn:000013CA
.text$mn:000013CC ; ===========================================================================
.text$mn:000013CC
.text$mn:000013CC ; Segment type: Pure code
.text$mn:000013CC ; Segment permissions: Read/Execute
.text$mn:000013CC _text$mn        segment para public 'CODE' use32
.text$mn:000013CC                 assume cs:_text$mn
.text$mn:000013CC                 ;org 13CCh
.text$mn:000013CC ; COMDAT (pick any)
.text$mn:000013CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013CC
.text$mn:000013CC ; =============== S U B R O U T I N E =======================================
.text$mn:000013CC
.text$mn:000013CC ; Attributes: bp-based frame
.text$mn:000013CC
.text$mn:000013CC ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000013CC                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000013CC ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000013CC                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000013CC
.text$mn:000013CC var_4           = dword ptr -4
.text$mn:000013CC arg_0           = dword ptr  8
.text$mn:000013CC
.text$mn:000013CC                 push    ebp
.text$mn:000013CD                 mov     ebp, esp
.text$mn:000013CF                 push    ecx
.text$mn:000013D0                 mov     [ebp+var_4], 0
.text$mn:000013D7                 cmp     [ebp+arg_0], 0
.text$mn:000013DB                 jnz     short loc_13DF
.text$mn:000013DD                 jmp     short loc_1405
.text$mn:000013DF ; ---------------------------------------------------------------------------
.text$mn:000013DF
.text$mn:000013DF loc_13DF:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000013DF                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000013E6                 ja      short loc_1400
.text$mn:000013E8                 mov     eax, [ebp+arg_0]
.text$mn:000013EB                 shl     eax, 3
.text$mn:000013EE                 push    eax             ; unsigned int
.text$mn:000013EF                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000013F4                 add     esp, 4
.text$mn:000013F7                 mov     [ebp+var_4], eax
.text$mn:000013FA                 cmp     [ebp+var_4], 0
.text$mn:000013FE                 jnz     short loc_1405
.text$mn:00001400
.text$mn:00001400 loc_1400:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00001400                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001405
.text$mn:00001405 loc_1405:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00001405                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00001405                 mov     eax, [ebp+var_4]
.text$mn:00001408                 mov     esp, ebp
.text$mn:0000140A                 pop     ebp
.text$mn:0000140B                 retn
.text$mn:0000140B ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:0000140B
.text$mn:0000140B _text$mn        ends
.text$mn:0000140B
.text$mn:0000140C ; ===========================================================================
.text$mn:0000140C
.text$mn:0000140C ; Segment type: Pure code
.text$mn:0000140C ; Segment permissions: Read/Execute
.text$mn:0000140C _text$mn        segment para public 'CODE' use32
.text$mn:0000140C                 assume cs:_text$mn
.text$mn:0000140C                 ;org 140Ch
.text$mn:0000140C ; COMDAT (pick any)
.text$mn:0000140C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000140C
.text$mn:0000140C ; =============== S U B R O U T I N E =======================================
.text$mn:0000140C
.text$mn:0000140C ; Attributes: bp-based frame
.text$mn:0000140C
.text$mn:0000140C ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:0000140C                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:0000140C ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:0000140C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:0000140C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:0000140C
.text$mn:0000140C arg_0           = dword ptr  8
.text$mn:0000140C arg_4           = dword ptr  0Ch
.text$mn:0000140C arg_8           = dword ptr  10h
.text$mn:0000140C
.text$mn:0000140C                 push    ebp
.text$mn:0000140D                 mov     ebp, esp
.text$mn:0000140F                 cmp     [ebp+arg_0], 0
.text$mn:00001413                 jnz     short loc_142A
.text$mn:00001415                 mov     eax, [ebp+arg_8]
.text$mn:00001418                 push    eax             ; unsigned int
.text$mn:00001419                 mov     ecx, [ebp+arg_4]
.text$mn:0000141C                 push    ecx             ; wchar_t *
.text$mn:0000141D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001422                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001427                 add     esp, 0Ch
.text$mn:0000142A
.text$mn:0000142A loc_142A:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000142A                 pop     ebp
.text$mn:0000142B                 retn
.text$mn:0000142B ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000142B
.text$mn:0000142B _text$mn        ends
.text$mn:0000142B
.text$mn:0000142C ; ===========================================================================
.text$mn:0000142C
.text$mn:0000142C ; Segment type: Pure code
.text$mn:0000142C ; Segment permissions: Read/Execute
.text$mn:0000142C _text$mn        segment para public 'CODE' use32
.text$mn:0000142C                 assume cs:_text$mn
.text$mn:0000142C                 ;org 142Ch
.text$mn:0000142C ; COMDAT (pick any)
.text$mn:0000142C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000142C
.text$mn:0000142C ; =============== S U B R O U T I N E =======================================
.text$mn:0000142C
.text$mn:0000142C ; Attributes: bp-based frame
.text$mn:0000142C
.text$mn:0000142C ; char * __cdecl std::addressof<char>(char &)
.text$mn:0000142C                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:0000142C ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:0000142C                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:0000142C                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:0000142C
.text$mn:0000142C arg_0           = dword ptr  8
.text$mn:0000142C
.text$mn:0000142C                 push    ebp
.text$mn:0000142D                 mov     ebp, esp
.text$mn:0000142F                 mov     eax, [ebp+arg_0]
.text$mn:00001432                 pop     ebp
.text$mn:00001433                 retn
.text$mn:00001433 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00001433
.text$mn:00001433 _text$mn        ends
.text$mn:00001433
.text$mn:00001434 ; ===========================================================================
.text$mn:00001434
.text$mn:00001434 ; Segment type: Pure code
.text$mn:00001434 ; Segment permissions: Read/Execute
.text$mn:00001434 _text$mn        segment para public 'CODE' use32
.text$mn:00001434                 assume cs:_text$mn
.text$mn:00001434                 ;org 1434h
.text$mn:00001434 ; COMDAT (pick any)
.text$mn:00001434                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001434
.text$mn:00001434 ; =============== S U B R O U T I N E =======================================
.text$mn:00001434
.text$mn:00001434 ; Attributes: bp-based frame
.text$mn:00001434
.text$mn:00001434 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00001434                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00001434 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001434                                         ; CODE XREF: $LN19+4Bp
.text$mn:00001434
.text$mn:00001434 var_4           = dword ptr -4
.text$mn:00001434 arg_0           = dword ptr  8
.text$mn:00001434 arg_4           = dword ptr  0Ch
.text$mn:00001434
.text$mn:00001434                 push    ebp
.text$mn:00001435                 mov     ebp, esp
.text$mn:00001437                 push    ecx
.text$mn:00001438                 mov     [ebp+var_4], ecx
.text$mn:0000143B                 mov     eax, [ebp+arg_4]
.text$mn:0000143E                 push    eax
.text$mn:0000143F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001444                 add     esp, 4
.text$mn:00001447                 push    eax             ; int
.text$mn:00001448                 mov     ecx, [ebp+arg_0]
.text$mn:0000144B                 push    ecx             ; void *
.text$mn:0000144C                 mov     edx, [ebp+var_4]
.text$mn:0000144F                 push    edx             ; int
.text$mn:00001450                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00001455                 add     esp, 0Ch
.text$mn:00001458                 mov     esp, ebp
.text$mn:0000145A                 pop     ebp
.text$mn:0000145B                 retn    8
.text$mn:0000145B ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000145B
.text$mn:0000145B ; ---------------------------------------------------------------------------
.text$mn:0000145E                 align 10h
.text$mn:0000145E _text$mn        ends
.text$mn:0000145E
.text$mn:00001460 ; ===========================================================================
.text$mn:00001460
.text$mn:00001460 ; Segment type: Pure code
.text$mn:00001460 ; Segment permissions: Read/Execute
.text$mn:00001460 _text$mn        segment para public 'CODE' use32
.text$mn:00001460                 assume cs:_text$mn
.text$mn:00001460                 ;org 1460h
.text$mn:00001460 ; COMDAT (pick any)
.text$mn:00001460                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001460
.text$mn:00001460 ; =============== S U B R O U T I N E =======================================
.text$mn:00001460
.text$mn:00001460 ; Attributes: bp-based frame
.text$mn:00001460
.text$mn:00001460 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00001460                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00001460 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001460                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00001460
.text$mn:00001460 var_1C          = dword ptr -1Ch
.text$mn:00001460 var_18          = dword ptr -18h
.text$mn:00001460 var_14          = dword ptr -14h
.text$mn:00001460 var_10          = dword ptr -10h
.text$mn:00001460 var_C           = dword ptr -0Ch
.text$mn:00001460 var_4           = dword ptr -4
.text$mn:00001460 arg_0           = dword ptr  8
.text$mn:00001460 arg_4           = dword ptr  0Ch
.text$mn:00001460
.text$mn:00001460                 push    ebp
.text$mn:00001461                 mov     ebp, esp
.text$mn:00001463                 push    0FFFFFFFFh
.text$mn:00001465                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000146A                 mov     eax, large fs:0
.text$mn:00001470                 push    eax
.text$mn:00001471                 sub     esp, 10h
.text$mn:00001474                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001479                 xor     eax, ebp
.text$mn:0000147B                 push    eax
.text$mn:0000147C                 lea     eax, [ebp+var_C]
.text$mn:0000147F                 mov     large fs:0, eax
.text$mn:00001485                 mov     [ebp+var_18], ecx
.text$mn:00001488                 mov     eax, [ebp+arg_0]
.text$mn:0000148B                 push    eax             ; void *
.text$mn:0000148C                 push    4               ; unsigned int
.text$mn:0000148E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001493                 add     esp, 8
.text$mn:00001496                 mov     [ebp+var_10], eax
.text$mn:00001499                 mov     [ebp+var_4], 0
.text$mn:000014A0                 cmp     [ebp+var_10], 0
.text$mn:000014A4                 jz      short loc_14C1
.text$mn:000014A6                 mov     ecx, [ebp+arg_4]
.text$mn:000014A9                 push    ecx
.text$mn:000014AA                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000014AF                 add     esp, 4
.text$mn:000014B2                 mov     edx, [ebp+var_10]
.text$mn:000014B5                 mov     eax, [eax]
.text$mn:000014B7                 mov     [edx], eax
.text$mn:000014B9                 mov     ecx, [ebp+var_10]
.text$mn:000014BC                 mov     [ebp+var_14], ecx
.text$mn:000014BF                 jmp     short loc_14C8
.text$mn:000014C1 ; ---------------------------------------------------------------------------
.text$mn:000014C1
.text$mn:000014C1 loc_14C1:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000014C1                 mov     [ebp+var_14], 0
.text$mn:000014C8
.text$mn:000014C8 loc_14C8:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000014C8                 mov     edx, [ebp+var_14]
.text$mn:000014CB                 mov     [ebp+var_1C], edx
.text$mn:000014CE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000014D5                 mov     ecx, [ebp+var_C]
.text$mn:000014D8                 mov     large fs:0, ecx
.text$mn:000014DF                 pop     ecx
.text$mn:000014E0                 mov     esp, ebp
.text$mn:000014E2                 pop     ebp
.text$mn:000014E3                 retn    8
.text$mn:000014E3 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000014E3
.text$mn:000014E3 ; ---------------------------------------------------------------------------
.text$mn:000014E6                 align 4
.text$mn:000014E6 _text$mn        ends
.text$mn:000014E6
.text$x:000014E8 ; ===========================================================================
.text$x:000014E8
.text$x:000014E8 ; Segment type: Pure code
.text$x:000014E8 ; Segment permissions: Read/Execute
.text$x:000014E8 _text$x         segment para public 'CODE' use32
.text$x:000014E8                 assume cs:_text$x
.text$x:000014E8                 ;org 14E8h
.text$x:000014E8 ; COMDAT (pick associative to section at 1460)
.text$x:000014E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000014E8
.text$x:000014E8 ; =============== S U B R O U T I N E =======================================
.text$x:000014E8
.text$x:000014E8
.text$x:000014E8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000014E8                                         ; DATA XREF: .xdata$x:000030E0o
.text$x:000014E8                 mov     eax, [ebp+8]
.text$x:000014EB                 push    eax
.text$x:000014EC                 mov     eax, [ebp-10h]
.text$x:000014EF                 push    eax             ; void *
.text$x:000014F0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000014F5                 add     esp, 8
.text$x:000014F8                 retn
.text$x:000014F8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000014F8
.text$x:000014F9
.text$x:000014F9 ; =============== S U B R O U T I N E =======================================
.text$x:000014F9
.text$x:000014F9
.text$x:000014F9 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000014F9                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000014F9
.text$x:000014F9 arg_4           = dword ptr  8
.text$x:000014F9
.text$x:000014F9                 mov     edx, [esp+arg_4]
.text$x:000014FD                 lea     eax, [edx+0Ch]
.text$x:00001500                 mov     ecx, [edx-14h]
.text$x:00001503                 xor     ecx, eax
.text$x:00001505                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000150A                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000150F                 jmp     ___CxxFrameHandler3
.text$x:0000150F __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000150F
.text$x:0000150F _text$x         ends
.text$x:0000150F
.text$mn:00001514 ; ===========================================================================
.text$mn:00001514
.text$mn:00001514 ; Segment type: Pure code
.text$mn:00001514 ; Segment permissions: Read/Execute
.text$mn:00001514 _text$mn        segment para public 'CODE' use32
.text$mn:00001514                 assume cs:_text$mn
.text$mn:00001514                 ;org 1514h
.text$mn:00001514 ; COMDAT (pick any)
.text$mn:00001514                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001514
.text$mn:00001514 ; =============== S U B R O U T I N E =======================================
.text$mn:00001514
.text$mn:00001514 ; Attributes: bp-based frame
.text$mn:00001514
.text$mn:00001514 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00001514                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00001514 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00001514                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00001514
.text$mn:00001514 arg_0           = dword ptr  8
.text$mn:00001514 arg_4           = dword ptr  0Ch
.text$mn:00001514 arg_8           = dword ptr  10h
.text$mn:00001514
.text$mn:00001514                 push    ebp
.text$mn:00001515                 mov     ebp, esp
.text$mn:00001517                 mov     eax, [ebp+arg_8]
.text$mn:0000151A                 push    eax
.text$mn:0000151B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001520                 add     esp, 4
.text$mn:00001523                 push    eax             ; int
.text$mn:00001524                 mov     ecx, [ebp+arg_4]
.text$mn:00001527                 push    ecx             ; void *
.text$mn:00001528                 mov     ecx, [ebp+arg_0]
.text$mn:0000152B                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001530                 pop     ebp
.text$mn:00001531                 retn
.text$mn:00001531 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00001531
.text$mn:00001531 ; ---------------------------------------------------------------------------
.text$mn:00001532                 align 4
.text$mn:00001532 _text$mn        ends
.text$mn:00001532
.text$mn:00001534 ; ===========================================================================
.text$mn:00001534
.text$mn:00001534 ; Segment type: Pure code
.text$mn:00001534 ; Segment permissions: Read/Execute
.text$mn:00001534 _text$mn        segment para public 'CODE' use32
.text$mn:00001534                 assume cs:_text$mn
.text$mn:00001534                 ;org 1534h
.text$mn:00001534 ; COMDAT (pick any)
.text$mn:00001534                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001534
.text$mn:00001534 ; =============== S U B R O U T I N E =======================================
.text$mn:00001534
.text$mn:00001534 ; Attributes: bp-based frame
.text$mn:00001534
.text$mn:00001534 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00001534                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001534 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00001534                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00001534
.text$mn:00001534 var_1C          = dword ptr -1Ch
.text$mn:00001534 var_18          = dword ptr -18h
.text$mn:00001534 var_14          = dword ptr -14h
.text$mn:00001534 var_10          = dword ptr -10h
.text$mn:00001534 var_C           = dword ptr -0Ch
.text$mn:00001534 var_4           = dword ptr -4
.text$mn:00001534 arg_0           = dword ptr  8
.text$mn:00001534 arg_4           = dword ptr  0Ch
.text$mn:00001534
.text$mn:00001534                 push    ebp
.text$mn:00001535                 mov     ebp, esp
.text$mn:00001537                 push    0FFFFFFFFh
.text$mn:00001539                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000153E                 mov     eax, large fs:0
.text$mn:00001544                 push    eax
.text$mn:00001545                 sub     esp, 10h
.text$mn:00001548                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000154D                 xor     eax, ebp
.text$mn:0000154F                 push    eax
.text$mn:00001550                 lea     eax, [ebp+var_C]
.text$mn:00001553                 mov     large fs:0, eax
.text$mn:00001559                 mov     [ebp+var_18], ecx
.text$mn:0000155C                 mov     eax, [ebp+arg_0]
.text$mn:0000155F                 push    eax             ; void *
.text$mn:00001560                 push    8               ; unsigned int
.text$mn:00001562                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001567                 add     esp, 8
.text$mn:0000156A                 mov     [ebp+var_10], eax
.text$mn:0000156D                 mov     [ebp+var_4], 0
.text$mn:00001574                 cmp     [ebp+var_10], 0
.text$mn:00001578                 jz      short loc_159B
.text$mn:0000157A                 mov     ecx, [ebp+arg_4]
.text$mn:0000157D                 push    ecx
.text$mn:0000157E                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00001583                 add     esp, 4
.text$mn:00001586                 mov     edx, [eax]
.text$mn:00001588                 mov     eax, [eax+4]
.text$mn:0000158B                 mov     ecx, [ebp+var_10]
.text$mn:0000158E                 mov     [ecx], edx
.text$mn:00001590                 mov     [ecx+4], eax
.text$mn:00001593                 mov     edx, [ebp+var_10]
.text$mn:00001596                 mov     [ebp+var_14], edx
.text$mn:00001599                 jmp     short loc_15A2
.text$mn:0000159B ; ---------------------------------------------------------------------------
.text$mn:0000159B
.text$mn:0000159B loc_159B:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:0000159B                 mov     [ebp+var_14], 0
.text$mn:000015A2
.text$mn:000015A2 loc_15A2:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:000015A2                 mov     eax, [ebp+var_14]
.text$mn:000015A5                 mov     [ebp+var_1C], eax
.text$mn:000015A8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000015AF                 mov     ecx, [ebp+var_C]
.text$mn:000015B2                 mov     large fs:0, ecx
.text$mn:000015B9                 pop     ecx
.text$mn:000015BA                 mov     esp, ebp
.text$mn:000015BC                 pop     ebp
.text$mn:000015BD                 retn    8
.text$mn:000015BD ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000015BD
.text$mn:000015BD _text$mn        ends
.text$mn:000015BD
.text$x:000015C0 ; ===========================================================================
.text$x:000015C0
.text$x:000015C0 ; Segment type: Pure code
.text$x:000015C0 ; Segment permissions: Read/Execute
.text$x:000015C0 _text$x         segment para public 'CODE' use32
.text$x:000015C0                 assume cs:_text$x
.text$x:000015C0                 ;org 15C0h
.text$x:000015C0 ; COMDAT (pick associative to section at 1534)
.text$x:000015C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000015C0
.text$x:000015C0 ; =============== S U B R O U T I N E =======================================
.text$x:000015C0
.text$x:000015C0
.text$x:000015C0 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000015C0                                         ; DATA XREF: .xdata$x:000030B4o
.text$x:000015C0                 mov     eax, [ebp+8]
.text$x:000015C3                 push    eax
.text$x:000015C4                 mov     eax, [ebp-10h]
.text$x:000015C7                 push    eax             ; void *
.text$x:000015C8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000015CD                 add     esp, 8
.text$x:000015D0                 retn
.text$x:000015D0 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:000015D0
.text$x:000015D1
.text$x:000015D1 ; =============== S U B R O U T I N E =======================================
.text$x:000015D1
.text$x:000015D1
.text$x:000015D1 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:000015D1                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:000015D1
.text$x:000015D1 arg_4           = dword ptr  8
.text$x:000015D1
.text$x:000015D1                 mov     edx, [esp+arg_4]
.text$x:000015D5                 lea     eax, [edx+0Ch]
.text$x:000015D8                 mov     ecx, [edx-14h]
.text$x:000015DB                 xor     ecx, eax
.text$x:000015DD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000015E2                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000015E7                 jmp     ___CxxFrameHandler3
.text$x:000015E7 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000015E7
.text$x:000015E7 _text$x         ends
.text$x:000015E7
.text$mn:000015EC ; ===========================================================================
.text$mn:000015EC
.text$mn:000015EC ; Segment type: Pure code
.text$mn:000015EC ; Segment permissions: Read/Execute
.text$mn:000015EC _text$mn        segment para public 'CODE' use32
.text$mn:000015EC                 assume cs:_text$mn
.text$mn:000015EC                 ;org 15ECh
.text$mn:000015EC ; COMDAT (pick any)
.text$mn:000015EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000015EC
.text$mn:000015EC ; =============== S U B R O U T I N E =======================================
.text$mn:000015EC
.text$mn:000015EC ; Attributes: bp-based frame
.text$mn:000015EC
.text$mn:000015EC ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000015EC                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:000015EC ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:000015EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:000015EC
.text$mn:000015EC var_4           = dword ptr -4
.text$mn:000015EC arg_0           = dword ptr  8
.text$mn:000015EC
.text$mn:000015EC                 push    ebp
.text$mn:000015ED                 mov     ebp, esp
.text$mn:000015EF                 push    ecx
.text$mn:000015F0                 mov     [ebp+var_4], ecx
.text$mn:000015F3                 mov     eax, [ebp+arg_0]
.text$mn:000015F6                 push    eax
.text$mn:000015F7                 mov     ecx, [ebp+var_4]
.text$mn:000015FA                 push    ecx
.text$mn:000015FB                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00001600                 add     esp, 8
.text$mn:00001603                 mov     esp, ebp
.text$mn:00001605                 pop     ebp
.text$mn:00001606                 retn    4
.text$mn:00001606 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00001606
.text$mn:00001606 ; ---------------------------------------------------------------------------
.text$mn:00001609                 align 4
.text$mn:00001609 _text$mn        ends
.text$mn:00001609
.text$mn:0000160C ; ===========================================================================
.text$mn:0000160C
.text$mn:0000160C ; Segment type: Pure code
.text$mn:0000160C ; Segment permissions: Read/Execute
.text$mn:0000160C _text$mn        segment para public 'CODE' use32
.text$mn:0000160C                 assume cs:_text$mn
.text$mn:0000160C                 ;org 160Ch
.text$mn:0000160C ; COMDAT (pick any)
.text$mn:0000160C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000160C
.text$mn:0000160C ; =============== S U B R O U T I N E =======================================
.text$mn:0000160C
.text$mn:0000160C ; Attributes: bp-based frame
.text$mn:0000160C
.text$mn:0000160C ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:0000160C                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:0000160C ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:0000160C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:0000160C
.text$mn:0000160C var_4           = dword ptr -4
.text$mn:0000160C
.text$mn:0000160C                 push    ebp
.text$mn:0000160D                 mov     ebp, esp
.text$mn:0000160F                 push    ecx
.text$mn:00001610                 mov     [ebp+var_4], ecx
.text$mn:00001613                 mov     esp, ebp
.text$mn:00001615                 pop     ebp
.text$mn:00001616                 retn    4
.text$mn:00001616 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00001616
.text$mn:00001616 ; ---------------------------------------------------------------------------
.text$mn:00001619                 align 4
.text$mn:00001619 _text$mn        ends
.text$mn:00001619
.text$mn:0000161C ; ===========================================================================
.text$mn:0000161C
.text$mn:0000161C ; Segment type: Pure code
.text$mn:0000161C ; Segment permissions: Read/Execute
.text$mn:0000161C _text$mn        segment para public 'CODE' use32
.text$mn:0000161C                 assume cs:_text$mn
.text$mn:0000161C                 ;org 161Ch
.text$mn:0000161C ; COMDAT (pick any)
.text$mn:0000161C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000161C
.text$mn:0000161C ; =============== S U B R O U T I N E =======================================
.text$mn:0000161C
.text$mn:0000161C ; Attributes: bp-based frame
.text$mn:0000161C
.text$mn:0000161C ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:0000161C                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:0000161C ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:0000161C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:0000161C
.text$mn:0000161C arg_0           = dword ptr  8
.text$mn:0000161C arg_4           = dword ptr  0Ch
.text$mn:0000161C
.text$mn:0000161C                 push    ebp
.text$mn:0000161D                 mov     ebp, esp
.text$mn:0000161F                 mov     eax, [ebp+arg_4]
.text$mn:00001622                 push    eax
.text$mn:00001623                 mov     ecx, [ebp+arg_0]
.text$mn:00001626                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:0000162B                 pop     ebp
.text$mn:0000162C                 retn
.text$mn:0000162C ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:0000162C
.text$mn:0000162C ; ---------------------------------------------------------------------------
.text$mn:0000162D                 align 10h
.text$mn:0000162D _text$mn        ends
.text$mn:0000162D
.text$mn:00001630 ; ===========================================================================
.text$mn:00001630
.text$mn:00001630 ; Segment type: Pure code
.text$mn:00001630 ; Segment permissions: Read/Execute
.text$mn:00001630 _text$mn        segment para public 'CODE' use32
.text$mn:00001630                 assume cs:_text$mn
.text$mn:00001630                 ;org 1630h
.text$mn:00001630 ; COMDAT (pick any)
.text$mn:00001630                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001630
.text$mn:00001630 ; =============== S U B R O U T I N E =======================================
.text$mn:00001630
.text$mn:00001630 ; Attributes: bp-based frame
.text$mn:00001630
.text$mn:00001630 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00001630                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00001630 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00001630                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00001630
.text$mn:00001630 var_4           = dword ptr -4
.text$mn:00001630
.text$mn:00001630                 push    ebp
.text$mn:00001631                 mov     ebp, esp
.text$mn:00001633                 push    ecx
.text$mn:00001634                 mov     [ebp+var_4], ecx
.text$mn:00001637                 mov     esp, ebp
.text$mn:00001639                 pop     ebp
.text$mn:0000163A                 retn    4
.text$mn:0000163A ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:0000163A
.text$mn:0000163A ; ---------------------------------------------------------------------------
.text$mn:0000163D                 align 10h
.text$mn:0000163D _text$mn        ends
.text$mn:0000163D
.text$mn:00001640 ; ===========================================================================
.text$mn:00001640
.text$mn:00001640 ; Segment type: Pure code
.text$mn:00001640 ; Segment permissions: Read/Execute
.text$mn:00001640 _text$mn        segment para public 'CODE' use32
.text$mn:00001640                 assume cs:_text$mn
.text$mn:00001640                 ;org 1640h
.text$mn:00001640 ; COMDAT (pick any)
.text$mn:00001640                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001640
.text$mn:00001640 ; =============== S U B R O U T I N E =======================================
.text$mn:00001640
.text$mn:00001640 ; Attributes: bp-based frame
.text$mn:00001640
.text$mn:00001640 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00001640                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00001640 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00001640                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00001640                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00001640
.text$mn:00001640 arg_0           = dword ptr  8
.text$mn:00001640
.text$mn:00001640                 push    ebp
.text$mn:00001641                 mov     ebp, esp
.text$mn:00001643                 mov     eax, [ebp+arg_0]
.text$mn:00001646                 pop     ebp
.text$mn:00001647                 retn
.text$mn:00001647 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00001647
.text$mn:00001647 _text$mn        ends
.text$mn:00001647
.text$mn:00001648 ; ===========================================================================
.text$mn:00001648
.text$mn:00001648 ; Segment type: Pure code
.text$mn:00001648 ; Segment permissions: Read/Execute
.text$mn:00001648 _text$mn        segment para public 'CODE' use32
.text$mn:00001648                 assume cs:_text$mn
.text$mn:00001648                 ;org 1648h
.text$mn:00001648 ; COMDAT (pick any)
.text$mn:00001648                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001648
.text$mn:00001648 ; =============== S U B R O U T I N E =======================================
.text$mn:00001648
.text$mn:00001648 ; Attributes: bp-based frame
.text$mn:00001648
.text$mn:00001648 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00001648                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00001648 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00001648                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00001648
.text$mn:00001648 arg_0           = dword ptr  8
.text$mn:00001648
.text$mn:00001648                 push    ebp
.text$mn:00001649                 mov     ebp, esp
.text$mn:0000164B                 mov     eax, [ebp+arg_0]
.text$mn:0000164E                 pop     ebp
.text$mn:0000164F                 retn
.text$mn:0000164F ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:0000164F
.text$mn:0000164F _text$mn        ends
.text$mn:0000164F
.text$mn:00001650 ; ===========================================================================
.text$mn:00001650
.text$mn:00001650 ; Segment type: Pure code
.text$mn:00001650 ; Segment permissions: Read/Execute
.text$mn:00001650 _text$mn        segment para public 'CODE' use32
.text$mn:00001650                 assume cs:_text$mn
.text$mn:00001650                 ;org 1650h
.text$mn:00001650 ; COMDAT (pick any)
.text$mn:00001650                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001650
.text$mn:00001650 ; =============== S U B R O U T I N E =======================================
.text$mn:00001650
.text$mn:00001650 ; Attributes: bp-based frame
.text$mn:00001650
.text$mn:00001650 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00001650                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00001650 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00001650                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00001650
.text$mn:00001650 var_10          = dword ptr -10h
.text$mn:00001650 var_C           = dword ptr -0Ch
.text$mn:00001650 var_4           = dword ptr -4
.text$mn:00001650
.text$mn:00001650                 push    ebp
.text$mn:00001651                 mov     ebp, esp
.text$mn:00001653                 push    0FFFFFFFFh
.text$mn:00001655                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000165A                 mov     eax, large fs:0
.text$mn:00001660                 push    eax
.text$mn:00001661                 push    ecx
.text$mn:00001662                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001667                 xor     eax, ebp
.text$mn:00001669                 push    eax
.text$mn:0000166A                 lea     eax, [ebp+var_C]
.text$mn:0000166D                 mov     large fs:0, eax
.text$mn:00001673                 mov     [ebp+var_10], ecx
.text$mn:00001676                 mov     ecx, [ebp+var_10]
.text$mn:00001679                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:0000167E                 mov     [ebp+var_4], 0
.text$mn:00001685                 mov     ecx, [ebp+var_10]
.text$mn:00001688                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:0000168D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001694                 mov     eax, [ebp+var_10]
.text$mn:00001697                 mov     ecx, [ebp+var_C]
.text$mn:0000169A                 mov     large fs:0, ecx
.text$mn:000016A1                 pop     ecx
.text$mn:000016A2                 mov     esp, ebp
.text$mn:000016A4                 pop     ebp
.text$mn:000016A5                 retn    4
.text$mn:000016A5 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:000016A5
.text$mn:000016A5 _text$mn        ends
.text$mn:000016A5
.text$x:000016A8 ; ===========================================================================
.text$x:000016A8
.text$x:000016A8 ; Segment type: Pure code
.text$x:000016A8 ; Segment permissions: Read/Execute
.text$x:000016A8 _text$x         segment para public 'CODE' use32
.text$x:000016A8                 assume cs:_text$x
.text$x:000016A8                 ;org 16A8h
.text$x:000016A8 ; COMDAT (pick associative to section at 1650)
.text$x:000016A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000016A8
.text$x:000016A8 ; =============== S U B R O U T I N E =======================================
.text$x:000016A8
.text$x:000016A8
.text$x:000016A8 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:000016A8                                         ; DATA XREF: .xdata$x:00002DECo
.text$x:000016A8                 mov     ecx, [ebp-10h]
.text$x:000016AB                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000016AB __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:000016AB
.text$x:000016B0
.text$x:000016B0 ; =============== S U B R O U T I N E =======================================
.text$x:000016B0
.text$x:000016B0
.text$x:000016B0 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:000016B0                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:000016B0
.text$x:000016B0 arg_4           = dword ptr  8
.text$x:000016B0
.text$x:000016B0                 mov     edx, [esp+arg_4]
.text$x:000016B4                 lea     eax, [edx+0Ch]
.text$x:000016B7                 mov     ecx, [edx-8]
.text$x:000016BA                 xor     ecx, eax
.text$x:000016BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000016C1                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000016C6                 jmp     ___CxxFrameHandler3
.text$x:000016C6 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000016C6
.text$x:000016C6 ; ---------------------------------------------------------------------------
.text$x:000016CB                 align 4
.text$x:000016CB _text$x         ends
.text$x:000016CB
.text$mn:000016CC ; ===========================================================================
.text$mn:000016CC
.text$mn:000016CC ; Segment type: Pure code
.text$mn:000016CC ; Segment permissions: Read/Execute
.text$mn:000016CC _text$mn        segment para public 'CODE' use32
.text$mn:000016CC                 assume cs:_text$mn
.text$mn:000016CC                 ;org 16CCh
.text$mn:000016CC ; COMDAT (pick any)
.text$mn:000016CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000016CC
.text$mn:000016CC ; =============== S U B R O U T I N E =======================================
.text$mn:000016CC
.text$mn:000016CC ; Attributes: bp-based frame
.text$mn:000016CC
.text$mn:000016CC ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000016CC                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000016CC ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000016CC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:000016CC
.text$mn:000016CC var_10          = dword ptr -10h
.text$mn:000016CC var_C           = dword ptr -0Ch
.text$mn:000016CC var_4           = dword ptr -4
.text$mn:000016CC
.text$mn:000016CC                 push    ebp
.text$mn:000016CD                 mov     ebp, esp
.text$mn:000016CF                 push    0FFFFFFFFh
.text$mn:000016D1                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000016D6                 mov     eax, large fs:0
.text$mn:000016DC                 push    eax
.text$mn:000016DD                 push    ecx
.text$mn:000016DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000016E3                 xor     eax, ebp
.text$mn:000016E5                 push    eax
.text$mn:000016E6                 lea     eax, [ebp+var_C]
.text$mn:000016E9                 mov     large fs:0, eax
.text$mn:000016EF                 mov     [ebp+var_10], ecx
.text$mn:000016F2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000016F5                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000016FA                 mov     [ebp+var_4], 0
.text$mn:00001701                 mov     eax, [ebp+var_10]
.text$mn:00001704                 mov     dword ptr [eax+14h], 0
.text$mn:0000170B                 mov     ecx, [ebp+var_10]
.text$mn:0000170E                 mov     dword ptr [ecx+18h], 0
.text$mn:00001715                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000171C                 mov     eax, [ebp+var_10]
.text$mn:0000171F                 mov     ecx, [ebp+var_C]
.text$mn:00001722                 mov     large fs:0, ecx
.text$mn:00001729                 pop     ecx
.text$mn:0000172A                 mov     esp, ebp
.text$mn:0000172C                 pop     ebp
.text$mn:0000172D                 retn
.text$mn:0000172D ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:0000172D
.text$mn:0000172D ; ---------------------------------------------------------------------------
.text$mn:0000172E                 align 10h
.text$mn:0000172E _text$mn        ends
.text$mn:0000172E
.text$x:00001730 ; ===========================================================================
.text$x:00001730
.text$x:00001730 ; Segment type: Pure code
.text$x:00001730 ; Segment permissions: Read/Execute
.text$x:00001730 _text$x         segment para public 'CODE' use32
.text$x:00001730                 assume cs:_text$x
.text$x:00001730                 ;org 1730h
.text$x:00001730 ; COMDAT (pick associative to section at 16CC)
.text$x:00001730                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001730
.text$x:00001730 ; =============== S U B R O U T I N E =======================================
.text$x:00001730
.text$x:00001730
.text$x:00001730 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001730                                         ; DATA XREF: .xdata$x:00002D94o
.text$x:00001730                 mov     ecx, [ebp-10h]  ; this
.text$x:00001733                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001733 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001733
.text$x:00001738
.text$x:00001738 ; =============== S U B R O U T I N E =======================================
.text$x:00001738
.text$x:00001738
.text$x:00001738 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001738                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001738
.text$x:00001738 arg_4           = dword ptr  8
.text$x:00001738
.text$x:00001738                 mov     edx, [esp+arg_4]
.text$x:0000173C                 lea     eax, [edx+0Ch]
.text$x:0000173F                 mov     ecx, [edx-8]
.text$x:00001742                 xor     ecx, eax
.text$x:00001744                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001749                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000174E                 jmp     ___CxxFrameHandler3
.text$x:0000174E __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000174E
.text$x:0000174E ; ---------------------------------------------------------------------------
.text$x:00001753                 align 4
.text$x:00001753 _text$x         ends
.text$x:00001753
.text$mn:00001754 ; ===========================================================================
.text$mn:00001754
.text$mn:00001754 ; Segment type: Pure code
.text$mn:00001754 ; Segment permissions: Read/Execute
.text$mn:00001754 _text$mn        segment para public 'CODE' use32
.text$mn:00001754                 assume cs:_text$mn
.text$mn:00001754                 ;org 1754h
.text$mn:00001754 ; COMDAT (pick any)
.text$mn:00001754                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001754
.text$mn:00001754 ; =============== S U B R O U T I N E =======================================
.text$mn:00001754
.text$mn:00001754 ; Attributes: bp-based frame
.text$mn:00001754
.text$mn:00001754 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00001754                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00001754 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00001754                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00001754
.text$mn:00001754 var_4           = dword ptr -4
.text$mn:00001754
.text$mn:00001754                 push    ebp
.text$mn:00001755                 mov     ebp, esp
.text$mn:00001757                 push    ecx
.text$mn:00001758                 mov     [ebp+var_4], ecx
.text$mn:0000175B                 mov     ecx, [ebp+var_4]
.text$mn:0000175E                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00001763                 mov     eax, [ebp+var_4]
.text$mn:00001766                 mov     esp, ebp
.text$mn:00001768                 pop     ebp
.text$mn:00001769                 retn
.text$mn:00001769 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00001769
.text$mn:00001769 ; ---------------------------------------------------------------------------
.text$mn:0000176A                 align 4
.text$mn:0000176A _text$mn        ends
.text$mn:0000176A
.text$mn:0000176C ; ===========================================================================
.text$mn:0000176C
.text$mn:0000176C ; Segment type: Pure code
.text$mn:0000176C ; Segment permissions: Read/Execute
.text$mn:0000176C _text$mn        segment para public 'CODE' use32
.text$mn:0000176C                 assume cs:_text$mn
.text$mn:0000176C                 ;org 176Ch
.text$mn:0000176C ; COMDAT (pick any)
.text$mn:0000176C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000176C
.text$mn:0000176C ; =============== S U B R O U T I N E =======================================
.text$mn:0000176C
.text$mn:0000176C ; Attributes: bp-based frame
.text$mn:0000176C
.text$mn:0000176C ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:0000176C                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:0000176C ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:0000176C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:0000176C
.text$mn:0000176C var_4           = dword ptr -4
.text$mn:0000176C
.text$mn:0000176C                 push    ebp
.text$mn:0000176D                 mov     ebp, esp
.text$mn:0000176F                 push    ecx
.text$mn:00001770                 mov     [ebp+var_4], ecx
.text$mn:00001773                 mov     eax, [ebp+var_4]
.text$mn:00001776                 mov     esp, ebp
.text$mn:00001778                 pop     ebp
.text$mn:00001779                 retn
.text$mn:00001779 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00001779
.text$mn:00001779 ; ---------------------------------------------------------------------------
.text$mn:0000177A                 align 4
.text$mn:0000177A _text$mn        ends
.text$mn:0000177A
.text$mn:0000177C ; ===========================================================================
.text$mn:0000177C
.text$mn:0000177C ; Segment type: Pure code
.text$mn:0000177C ; Segment permissions: Read/Execute
.text$mn:0000177C _text$mn        segment para public 'CODE' use32
.text$mn:0000177C                 assume cs:_text$mn
.text$mn:0000177C                 ;org 177Ch
.text$mn:0000177C ; COMDAT (pick any)
.text$mn:0000177C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000177C
.text$mn:0000177C ; =============== S U B R O U T I N E =======================================
.text$mn:0000177C
.text$mn:0000177C ; Attributes: bp-based frame
.text$mn:0000177C
.text$mn:0000177C ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:0000177C                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:0000177C ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:0000177C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:0000177C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:0000177C
.text$mn:0000177C var_4           = dword ptr -4
.text$mn:0000177C
.text$mn:0000177C                 push    ebp
.text$mn:0000177D                 mov     ebp, esp
.text$mn:0000177F                 push    ecx
.text$mn:00001780                 mov     [ebp+var_4], ecx
.text$mn:00001783                 mov     eax, [ebp+var_4]
.text$mn:00001786                 mov     esp, ebp
.text$mn:00001788                 pop     ebp
.text$mn:00001789                 retn
.text$mn:00001789 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00001789
.text$mn:00001789 ; ---------------------------------------------------------------------------
.text$mn:0000178A                 align 4
.text$mn:0000178A _text$mn        ends
.text$mn:0000178A
.text$mn:0000178C ; ===========================================================================
.text$mn:0000178C
.text$mn:0000178C ; Segment type: Pure code
.text$mn:0000178C ; Segment permissions: Read/Execute
.text$mn:0000178C _text$mn        segment para public 'CODE' use32
.text$mn:0000178C                 assume cs:_text$mn
.text$mn:0000178C                 ;org 178Ch
.text$mn:0000178C ; COMDAT (pick any)
.text$mn:0000178C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000178C
.text$mn:0000178C ; =============== S U B R O U T I N E =======================================
.text$mn:0000178C
.text$mn:0000178C ; Attributes: bp-based frame
.text$mn:0000178C
.text$mn:0000178C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:0000178C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000178C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:0000178C                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:0000178C                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:0000178C
.text$mn:0000178C var_14          = dword ptr -14h
.text$mn:0000178C var_D           = byte ptr -0Dh
.text$mn:0000178C var_C           = dword ptr -0Ch
.text$mn:0000178C var_4           = dword ptr -4
.text$mn:0000178C Str             = dword ptr  8
.text$mn:0000178C
.text$mn:0000178C                 push    ebp
.text$mn:0000178D                 mov     ebp, esp
.text$mn:0000178F                 push    0FFFFFFFFh
.text$mn:00001791                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00001796                 mov     eax, large fs:0
.text$mn:0000179C                 push    eax
.text$mn:0000179D                 sub     esp, 8
.text$mn:000017A0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000017A5                 xor     eax, ebp
.text$mn:000017A7                 push    eax
.text$mn:000017A8                 lea     eax, [ebp+var_C]
.text$mn:000017AB                 mov     large fs:0, eax
.text$mn:000017B1                 mov     [ebp+var_14], ecx
.text$mn:000017B4                 lea     ecx, [ebp+var_D]
.text$mn:000017B7                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000017BC                 push    eax
.text$mn:000017BD                 mov     ecx, [ebp+var_14]
.text$mn:000017C0                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000017C5                 mov     [ebp+var_4], 0
.text$mn:000017CC                 push    0               ; Size
.text$mn:000017CE                 push    0               ; char
.text$mn:000017D0                 mov     ecx, [ebp+var_14]
.text$mn:000017D3                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000017D8                 mov     eax, [ebp+Str]
.text$mn:000017DB                 push    eax             ; Str
.text$mn:000017DC                 mov     ecx, [ebp+var_14]
.text$mn:000017DF                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000017E4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000017EB                 mov     eax, [ebp+var_14]
.text$mn:000017EE                 mov     ecx, [ebp+var_C]
.text$mn:000017F1                 mov     large fs:0, ecx
.text$mn:000017F8                 pop     ecx
.text$mn:000017F9                 mov     esp, ebp
.text$mn:000017FB                 pop     ebp
.text$mn:000017FC                 retn    4
.text$mn:000017FC ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:000017FC
.text$mn:000017FC ; ---------------------------------------------------------------------------
.text$mn:000017FF                 align 10h
.text$mn:000017FF _text$mn        ends
.text$mn:000017FF
.text$x:00001800 ; ===========================================================================
.text$x:00001800
.text$x:00001800 ; Segment type: Pure code
.text$x:00001800 ; Segment permissions: Read/Execute
.text$x:00001800 _text$x         segment para public 'CODE' use32
.text$x:00001800                 assume cs:_text$x
.text$x:00001800                 ;org 1800h
.text$x:00001800 ; COMDAT (pick associative to section at 178C)
.text$x:00001800                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001800
.text$x:00001800 ; =============== S U B R O U T I N E =======================================
.text$x:00001800
.text$x:00001800
.text$x:00001800 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00001800                                         ; DATA XREF: .xdata$x:00002E44o
.text$x:00001800                 mov     ecx, [ebp-14h]
.text$x:00001803                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00001803 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00001803
.text$x:00001808
.text$x:00001808 ; =============== S U B R O U T I N E =======================================
.text$x:00001808
.text$x:00001808
.text$x:00001808 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00001808                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00001808
.text$x:00001808 arg_4           = dword ptr  8
.text$x:00001808
.text$x:00001808                 mov     edx, [esp+arg_4]
.text$x:0000180C                 lea     eax, [edx+0Ch]
.text$x:0000180F                 mov     ecx, [edx-0Ch]
.text$x:00001812                 xor     ecx, eax
.text$x:00001814                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001819                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:0000181E                 jmp     ___CxxFrameHandler3
.text$x:0000181E __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:0000181E
.text$x:0000181E ; ---------------------------------------------------------------------------
.text$x:00001823                 align 4
.text$x:00001823 _text$x         ends
.text$x:00001823
.text$mn:00001824 ; ===========================================================================
.text$mn:00001824
.text$mn:00001824 ; Segment type: Pure code
.text$mn:00001824 ; Segment permissions: Read/Execute
.text$mn:00001824 _text$mn        segment para public 'CODE' use32
.text$mn:00001824                 assume cs:_text$mn
.text$mn:00001824                 ;org 1824h
.text$mn:00001824 ; COMDAT (pick any)
.text$mn:00001824                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001824
.text$mn:00001824 ; =============== S U B R O U T I N E =======================================
.text$mn:00001824
.text$mn:00001824 ; Attributes: bp-based frame
.text$mn:00001824
.text$mn:00001824 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001824                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00001824 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00001824                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00001824
.text$mn:00001824 var_4           = dword ptr -4
.text$mn:00001824
.text$mn:00001824                 push    ebp
.text$mn:00001825                 mov     ebp, esp
.text$mn:00001827                 push    ecx
.text$mn:00001828                 mov     [ebp+var_4], ecx
.text$mn:0000182B                 mov     eax, [ebp+var_4]
.text$mn:0000182E                 mov     dword ptr [eax], 0
.text$mn:00001834                 mov     eax, [ebp+var_4]
.text$mn:00001837                 mov     esp, ebp
.text$mn:00001839                 pop     ebp
.text$mn:0000183A                 retn
.text$mn:0000183A ??0_Container_base12@std@@QAE@XZ endp
.text$mn:0000183A
.text$mn:0000183A ; ---------------------------------------------------------------------------
.text$mn:0000183B                 align 4
.text$mn:0000183B _text$mn        ends
.text$mn:0000183B
.text$mn:0000183C ; ===========================================================================
.text$mn:0000183C
.text$mn:0000183C ; Segment type: Pure code
.text$mn:0000183C ; Segment permissions: Read/Execute
.text$mn:0000183C _text$mn        segment para public 'CODE' use32
.text$mn:0000183C                 assume cs:_text$mn
.text$mn:0000183C                 ;org 183Ch
.text$mn:0000183C ; COMDAT (pick any)
.text$mn:0000183C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000183C
.text$mn:0000183C ; =============== S U B R O U T I N E =======================================
.text$mn:0000183C
.text$mn:0000183C ; Attributes: bp-based frame
.text$mn:0000183C
.text$mn:0000183C ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:0000183C                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:0000183C ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:0000183C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:0000183C
.text$mn:0000183C var_4           = dword ptr -4
.text$mn:0000183C
.text$mn:0000183C                 push    ebp
.text$mn:0000183D                 mov     ebp, esp
.text$mn:0000183F                 push    ecx
.text$mn:00001840                 mov     [ebp+var_4], ecx
.text$mn:00001843                 mov     eax, [ebp+var_4]
.text$mn:00001846                 mov     dword ptr [eax], 0
.text$mn:0000184C                 mov     ecx, [ebp+var_4]
.text$mn:0000184F                 mov     dword ptr [ecx+4], 0
.text$mn:00001856                 mov     eax, [ebp+var_4]
.text$mn:00001859                 mov     esp, ebp
.text$mn:0000185B                 pop     ebp
.text$mn:0000185C                 retn
.text$mn:0000185C ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:0000185C
.text$mn:0000185C ; ---------------------------------------------------------------------------
.text$mn:0000185D                 align 10h
.text$mn:0000185D _text$mn        ends
.text$mn:0000185D
.text$mn:00001860 ; ===========================================================================
.text$mn:00001860
.text$mn:00001860 ; Segment type: Pure code
.text$mn:00001860 ; Segment permissions: Read/Execute
.text$mn:00001860 _text$mn        segment para public 'CODE' use32
.text$mn:00001860                 assume cs:_text$mn
.text$mn:00001860                 ;org 1860h
.text$mn:00001860 ; COMDAT (pick any)
.text$mn:00001860                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001860
.text$mn:00001860 ; =============== S U B R O U T I N E =======================================
.text$mn:00001860
.text$mn:00001860 ; Attributes: bp-based frame
.text$mn:00001860
.text$mn:00001860 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001860                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00001860 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00001860                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00001860                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00001860
.text$mn:00001860 var_10          = dword ptr -10h
.text$mn:00001860 var_C           = dword ptr -0Ch
.text$mn:00001860 var_4           = dword ptr -4
.text$mn:00001860
.text$mn:00001860                 push    ebp
.text$mn:00001861                 mov     ebp, esp
.text$mn:00001863                 push    0FFFFFFFFh
.text$mn:00001865                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000186A                 mov     eax, large fs:0
.text$mn:00001870                 push    eax
.text$mn:00001871                 push    ecx
.text$mn:00001872                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001877                 xor     eax, ebp
.text$mn:00001879                 push    eax
.text$mn:0000187A                 lea     eax, [ebp+var_C]
.text$mn:0000187D                 mov     large fs:0, eax
.text$mn:00001883                 mov     [ebp+var_10], ecx
.text$mn:00001886                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001889                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:0000188E                 mov     [ebp+var_4], 0
.text$mn:00001895                 mov     eax, [ebp+var_10]
.text$mn:00001898                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:0000189E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000018A5                 mov     eax, [ebp+var_10]
.text$mn:000018A8                 mov     ecx, [ebp+var_C]
.text$mn:000018AB                 mov     large fs:0, ecx
.text$mn:000018B2                 pop     ecx
.text$mn:000018B3                 mov     esp, ebp
.text$mn:000018B5                 pop     ebp
.text$mn:000018B6                 retn
.text$mn:000018B6 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000018B6
.text$mn:000018B6 ; ---------------------------------------------------------------------------
.text$mn:000018B7                 align 4
.text$mn:000018B7 _text$mn        ends
.text$mn:000018B7
.text$x:000018B8 ; ===========================================================================
.text$x:000018B8
.text$x:000018B8 ; Segment type: Pure code
.text$x:000018B8 ; Segment permissions: Read/Execute
.text$x:000018B8 _text$x         segment para public 'CODE' use32
.text$x:000018B8                 assume cs:_text$x
.text$x:000018B8                 ;org 18B8h
.text$x:000018B8 ; COMDAT (pick associative to section at 1860)
.text$x:000018B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000018B8
.text$x:000018B8 ; =============== S U B R O U T I N E =======================================
.text$x:000018B8
.text$x:000018B8
.text$x:000018B8 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000018B8                                         ; DATA XREF: .xdata$x:00002F28o
.text$x:000018B8                 mov     ecx, [ebp-10h]  ; this
.text$x:000018BB                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000018BB __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000018BB
.text$x:000018C0
.text$x:000018C0 ; =============== S U B R O U T I N E =======================================
.text$x:000018C0
.text$x:000018C0
.text$x:000018C0 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000018C0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000018C0
.text$x:000018C0 arg_4           = dword ptr  8
.text$x:000018C0
.text$x:000018C0                 mov     edx, [esp+arg_4]
.text$x:000018C4                 lea     eax, [edx+0Ch]
.text$x:000018C7                 mov     ecx, [edx-8]
.text$x:000018CA                 xor     ecx, eax
.text$x:000018CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000018D1                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000018D6                 jmp     ___CxxFrameHandler3
.text$x:000018D6 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000018D6
.text$x:000018D6 ; ---------------------------------------------------------------------------
.text$x:000018DB                 align 4
.text$x:000018DB _text$x         ends
.text$x:000018DB
.text$mn:000018DC ; ===========================================================================
.text$mn:000018DC
.text$mn:000018DC ; Segment type: Pure code
.text$mn:000018DC ; Segment permissions: Read/Execute
.text$mn:000018DC _text$mn        segment para public 'CODE' use32
.text$mn:000018DC                 assume cs:_text$mn
.text$mn:000018DC                 ;org 18DCh
.text$mn:000018DC ; COMDAT (pick any)
.text$mn:000018DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000018DC
.text$mn:000018DC ; =============== S U B R O U T I N E =======================================
.text$mn:000018DC
.text$mn:000018DC ; Attributes: bp-based frame
.text$mn:000018DC
.text$mn:000018DC ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:000018DC                 public ??0_Ignore@std@@QAE@XZ
.text$mn:000018DC ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:000018DC
.text$mn:000018DC var_4           = dword ptr -4
.text$mn:000018DC
.text$mn:000018DC                 push    ebp
.text$mn:000018DD                 mov     ebp, esp
.text$mn:000018DF                 push    ecx
.text$mn:000018E0                 mov     [ebp+var_4], ecx
.text$mn:000018E3                 mov     eax, [ebp+var_4]
.text$mn:000018E6                 mov     esp, ebp
.text$mn:000018E8                 pop     ebp
.text$mn:000018E9                 retn
.text$mn:000018E9 ??0_Ignore@std@@QAE@XZ endp
.text$mn:000018E9
.text$mn:000018E9 ; ---------------------------------------------------------------------------
.text$mn:000018EA                 align 4
.text$mn:000018EA _text$mn        ends
.text$mn:000018EA
.text$mn:000018EC ; ===========================================================================
.text$mn:000018EC
.text$mn:000018EC ; Segment type: Pure code
.text$mn:000018EC ; Segment permissions: Read/Execute
.text$mn:000018EC _text$mn        segment para public 'CODE' use32
.text$mn:000018EC                 assume cs:_text$mn
.text$mn:000018EC                 ;org 18ECh
.text$mn:000018EC ; COMDAT (pick any)
.text$mn:000018EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000018EC
.text$mn:000018EC ; =============== S U B R O U T I N E =======================================
.text$mn:000018EC
.text$mn:000018EC ; Attributes: bp-based frame
.text$mn:000018EC
.text$mn:000018EC ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000018EC                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000018EC ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:000018EC                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000018EC
.text$mn:000018EC var_10          = dword ptr -10h
.text$mn:000018EC var_C           = dword ptr -0Ch
.text$mn:000018EC var_4           = dword ptr -4
.text$mn:000018EC
.text$mn:000018EC                 push    ebp
.text$mn:000018ED                 mov     ebp, esp
.text$mn:000018EF                 push    0FFFFFFFFh
.text$mn:000018F1                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000018F6                 mov     eax, large fs:0
.text$mn:000018FC                 push    eax
.text$mn:000018FD                 push    ecx
.text$mn:000018FE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001903                 xor     eax, ebp
.text$mn:00001905                 push    eax
.text$mn:00001906                 lea     eax, [ebp+var_C]
.text$mn:00001909                 mov     large fs:0, eax
.text$mn:0000190F                 mov     [ebp+var_10], ecx
.text$mn:00001912                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001915                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000191A                 mov     [ebp+var_4], 0
.text$mn:00001921                 mov     eax, [ebp+var_10]
.text$mn:00001924                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:0000192A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001931                 mov     eax, [ebp+var_10]
.text$mn:00001934                 mov     ecx, [ebp+var_C]
.text$mn:00001937                 mov     large fs:0, ecx
.text$mn:0000193E                 pop     ecx
.text$mn:0000193F                 mov     esp, ebp
.text$mn:00001941                 pop     ebp
.text$mn:00001942                 retn
.text$mn:00001942 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00001942
.text$mn:00001942 ; ---------------------------------------------------------------------------
.text$mn:00001943                 align 4
.text$mn:00001943 _text$mn        ends
.text$mn:00001943
.text$x:00001944 ; ===========================================================================
.text$x:00001944
.text$x:00001944 ; Segment type: Pure code
.text$x:00001944 ; Segment permissions: Read/Execute
.text$x:00001944 _text$x         segment para public 'CODE' use32
.text$x:00001944                 assume cs:_text$x
.text$x:00001944                 ;org 1944h
.text$x:00001944 ; COMDAT (pick associative to section at 18EC)
.text$x:00001944                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001944
.text$x:00001944 ; =============== S U B R O U T I N E =======================================
.text$x:00001944
.text$x:00001944
.text$x:00001944 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00001944                                         ; DATA XREF: .xdata$x:00002FACo
.text$x:00001944                 mov     ecx, [ebp-10h]  ; this
.text$x:00001947                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001947 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00001947
.text$x:0000194C
.text$x:0000194C ; =============== S U B R O U T I N E =======================================
.text$x:0000194C
.text$x:0000194C
.text$x:0000194C __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:0000194C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:0000194C
.text$x:0000194C arg_4           = dword ptr  8
.text$x:0000194C
.text$x:0000194C                 mov     edx, [esp+arg_4]
.text$x:00001950                 lea     eax, [edx+0Ch]
.text$x:00001953                 mov     ecx, [edx-8]
.text$x:00001956                 xor     ecx, eax
.text$x:00001958                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000195D                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00001962                 jmp     ___CxxFrameHandler3
.text$x:00001962 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00001962
.text$x:00001962 ; ---------------------------------------------------------------------------
.text$x:00001967                 align 4
.text$x:00001967 _text$x         ends
.text$x:00001967
.text$mn:00001968 ; ===========================================================================
.text$mn:00001968
.text$mn:00001968 ; Segment type: Pure code
.text$mn:00001968 ; Segment permissions: Read/Execute
.text$mn:00001968 _text$mn        segment para public 'CODE' use32
.text$mn:00001968                 assume cs:_text$mn
.text$mn:00001968                 ;org 1968h
.text$mn:00001968 ; COMDAT (pick any)
.text$mn:00001968                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001968
.text$mn:00001968 ; =============== S U B R O U T I N E =======================================
.text$mn:00001968
.text$mn:00001968 ; Attributes: bp-based frame
.text$mn:00001968
.text$mn:00001968 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001968                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00001968 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00001968                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001968
.text$mn:00001968 var_10          = dword ptr -10h
.text$mn:00001968 var_C           = dword ptr -0Ch
.text$mn:00001968 var_4           = dword ptr -4
.text$mn:00001968
.text$mn:00001968                 push    ebp
.text$mn:00001969                 mov     ebp, esp
.text$mn:0000196B                 push    0FFFFFFFFh
.text$mn:0000196D                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00001972                 mov     eax, large fs:0
.text$mn:00001978                 push    eax
.text$mn:00001979                 push    ecx
.text$mn:0000197A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000197F                 xor     eax, ebp
.text$mn:00001981                 push    eax
.text$mn:00001982                 lea     eax, [ebp+var_C]
.text$mn:00001985                 mov     large fs:0, eax
.text$mn:0000198B                 mov     [ebp+var_10], ecx
.text$mn:0000198E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001991                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00001996                 mov     [ebp+var_4], 0
.text$mn:0000199D                 mov     eax, [ebp+var_10]
.text$mn:000019A0                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:000019A6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000019AD                 mov     eax, [ebp+var_10]
.text$mn:000019B0                 mov     ecx, [ebp+var_C]
.text$mn:000019B3                 mov     large fs:0, ecx
.text$mn:000019BA                 pop     ecx
.text$mn:000019BB                 mov     esp, ebp
.text$mn:000019BD                 pop     ebp
.text$mn:000019BE                 retn
.text$mn:000019BE ??0_System_error_category@std@@QAE@XZ endp
.text$mn:000019BE
.text$mn:000019BE ; ---------------------------------------------------------------------------
.text$mn:000019BF                 align 10h
.text$mn:000019BF _text$mn        ends
.text$mn:000019BF
.text$x:000019C0 ; ===========================================================================
.text$x:000019C0
.text$x:000019C0 ; Segment type: Pure code
.text$x:000019C0 ; Segment permissions: Read/Execute
.text$x:000019C0 _text$x         segment para public 'CODE' use32
.text$x:000019C0                 assume cs:_text$x
.text$x:000019C0                 ;org 19C0h
.text$x:000019C0 ; COMDAT (pick associative to section at 1968)
.text$x:000019C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000019C0
.text$x:000019C0 ; =============== S U B R O U T I N E =======================================
.text$x:000019C0
.text$x:000019C0
.text$x:000019C0 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:000019C0                                         ; DATA XREF: .xdata$x:00003030o
.text$x:000019C0                 mov     ecx, [ebp-10h]  ; this
.text$x:000019C3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000019C3 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:000019C3
.text$x:000019C8
.text$x:000019C8 ; =============== S U B R O U T I N E =======================================
.text$x:000019C8
.text$x:000019C8
.text$x:000019C8 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000019C8                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000019C8
.text$x:000019C8 arg_4           = dword ptr  8
.text$x:000019C8
.text$x:000019C8                 mov     edx, [esp+arg_4]
.text$x:000019CC                 lea     eax, [edx+0Ch]
.text$x:000019CF                 mov     ecx, [edx-8]
.text$x:000019D2                 xor     ecx, eax
.text$x:000019D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019D9                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000019DE                 jmp     ___CxxFrameHandler3
.text$x:000019DE __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000019DE
.text$x:000019DE ; ---------------------------------------------------------------------------
.text$x:000019E3                 align 4
.text$x:000019E3 _text$x         ends
.text$x:000019E3
.text$mn:000019E4 ; ===========================================================================
.text$mn:000019E4
.text$mn:000019E4 ; Segment type: Pure code
.text$mn:000019E4 ; Segment permissions: Read/Execute
.text$mn:000019E4 _text$mn        segment para public 'CODE' use32
.text$mn:000019E4                 assume cs:_text$mn
.text$mn:000019E4                 ;org 19E4h
.text$mn:000019E4 ; COMDAT (pick any)
.text$mn:000019E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000019E4
.text$mn:000019E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000019E4
.text$mn:000019E4 ; Attributes: bp-based frame
.text$mn:000019E4
.text$mn:000019E4 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000019E4                 public ??0error_category@std@@QAE@XZ
.text$mn:000019E4 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000019E4
.text$mn:000019E4 var_4           = dword ptr -4
.text$mn:000019E4
.text$mn:000019E4                 push    ebp
.text$mn:000019E5                 mov     ebp, esp
.text$mn:000019E7                 push    ecx
.text$mn:000019E8                 mov     [ebp+var_4], ecx
.text$mn:000019EB                 mov     eax, [ebp+var_4]
.text$mn:000019EE                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000019F4                 mov     eax, [ebp+var_4]
.text$mn:000019F7                 mov     esp, ebp
.text$mn:000019F9                 pop     ebp
.text$mn:000019FA                 retn
.text$mn:000019FA ??0error_category@std@@QAE@XZ endp
.text$mn:000019FA
.text$mn:000019FA ; ---------------------------------------------------------------------------
.text$mn:000019FB                 align 4
.text$mn:000019FB _text$mn        ends
.text$mn:000019FB
.text$mn:000019FC ; ===========================================================================
.text$mn:000019FC
.text$mn:000019FC ; Segment type: Pure code
.text$mn:000019FC ; Segment permissions: Read/Execute
.text$mn:000019FC _text$mn        segment para public 'CODE' use32
.text$mn:000019FC                 assume cs:_text$mn
.text$mn:000019FC                 ;org 19FCh
.text$mn:000019FC ; COMDAT (pick any)
.text$mn:000019FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000019FC
.text$mn:000019FC ; =============== S U B R O U T I N E =======================================
.text$mn:000019FC
.text$mn:000019FC ; Attributes: bp-based frame
.text$mn:000019FC
.text$mn:000019FC ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:000019FC                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:000019FC ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:000019FC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:000019FC                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:000019FC
.text$mn:000019FC var_4           = dword ptr -4
.text$mn:000019FC arg_0           = dword ptr  8
.text$mn:000019FC arg_4           = dword ptr  0Ch
.text$mn:000019FC
.text$mn:000019FC                 push    ebp
.text$mn:000019FD                 mov     ebp, esp
.text$mn:000019FF                 push    ecx
.text$mn:00001A00                 mov     [ebp+var_4], ecx
.text$mn:00001A03                 mov     eax, [ebp+var_4]
.text$mn:00001A06                 mov     ecx, [ebp+arg_0]
.text$mn:00001A09                 mov     [eax], ecx
.text$mn:00001A0B                 mov     edx, [ebp+var_4]
.text$mn:00001A0E                 mov     eax, [ebp+arg_4]
.text$mn:00001A11                 mov     [edx+4], eax
.text$mn:00001A14                 mov     eax, [ebp+var_4]
.text$mn:00001A17                 mov     esp, ebp
.text$mn:00001A19                 pop     ebp
.text$mn:00001A1A                 retn    8
.text$mn:00001A1A ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00001A1A
.text$mn:00001A1A ; ---------------------------------------------------------------------------
.text$mn:00001A1D                 align 10h
.text$mn:00001A1D _text$mn        ends
.text$mn:00001A1D
.text$mn:00001A20 ; ===========================================================================
.text$mn:00001A20
.text$mn:00001A20 ; Segment type: Pure code
.text$mn:00001A20 ; Segment permissions: Read/Execute
.text$mn:00001A20 _text$mn        segment para public 'CODE' use32
.text$mn:00001A20                 assume cs:_text$mn
.text$mn:00001A20                 ;org 1A20h
.text$mn:00001A20 ; COMDAT (pick any)
.text$mn:00001A20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A20
.text$mn:00001A20 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A20
.text$mn:00001A20 ; Attributes: bp-based frame
.text$mn:00001A20
.text$mn:00001A20 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00001A20                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00001A20 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00001A20                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00001A20
.text$mn:00001A20 var_4           = dword ptr -4
.text$mn:00001A20 arg_0           = dword ptr  8
.text$mn:00001A20
.text$mn:00001A20                 push    ebp
.text$mn:00001A21                 mov     ebp, esp
.text$mn:00001A23                 push    ecx
.text$mn:00001A24                 mov     [ebp+var_4], ecx
.text$mn:00001A27                 mov     eax, [ebp+var_4]
.text$mn:00001A2A                 mov     ecx, [ebp+arg_0]
.text$mn:00001A2D                 mov     [eax], ecx
.text$mn:00001A2F                 mov     eax, [ebp+var_4]
.text$mn:00001A32                 mov     esp, ebp
.text$mn:00001A34                 pop     ebp
.text$mn:00001A35                 retn    4
.text$mn:00001A35 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00001A35
.text$mn:00001A35 _text$mn        ends
.text$mn:00001A35
.text$mn:00001A38 ; ===========================================================================
.text$mn:00001A38
.text$mn:00001A38 ; Segment type: Pure code
.text$mn:00001A38 ; Segment permissions: Read/Execute
.text$mn:00001A38 _text$mn        segment para public 'CODE' use32
.text$mn:00001A38                 assume cs:_text$mn
.text$mn:00001A38                 ;org 1A38h
.text$mn:00001A38 ; COMDAT (pick any)
.text$mn:00001A38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A38
.text$mn:00001A38 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A38
.text$mn:00001A38 ; Attributes: bp-based frame
.text$mn:00001A38
.text$mn:00001A38 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00001A38                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001A38 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00001A38                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00001A38                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00001A38
.text$mn:00001A38 var_10          = dword ptr -10h
.text$mn:00001A38 var_C           = dword ptr -0Ch
.text$mn:00001A38 var_4           = dword ptr -4
.text$mn:00001A38
.text$mn:00001A38                 push    ebp
.text$mn:00001A39                 mov     ebp, esp
.text$mn:00001A3B                 push    0FFFFFFFFh
.text$mn:00001A3D                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001A42                 mov     eax, large fs:0
.text$mn:00001A48                 push    eax
.text$mn:00001A49                 push    ecx
.text$mn:00001A4A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A4F                 xor     eax, ebp
.text$mn:00001A51                 push    eax
.text$mn:00001A52                 lea     eax, [ebp+var_C]
.text$mn:00001A55                 mov     large fs:0, eax
.text$mn:00001A5B                 mov     [ebp+var_10], ecx
.text$mn:00001A5E                 mov     [ebp+var_4], 0
.text$mn:00001A65                 mov     ecx, [ebp+var_10]
.text$mn:00001A68                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001A6D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A74                 mov     ecx, [ebp+var_10]
.text$mn:00001A77                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00001A7C                 mov     ecx, [ebp+var_C]
.text$mn:00001A7F                 mov     large fs:0, ecx
.text$mn:00001A86                 pop     ecx
.text$mn:00001A87                 mov     esp, ebp
.text$mn:00001A89                 pop     ebp
.text$mn:00001A8A                 retn
.text$mn:00001A8A ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00001A8A
.text$mn:00001A8A ; ---------------------------------------------------------------------------
.text$mn:00001A8B                 align 4
.text$mn:00001A8B _text$mn        ends
.text$mn:00001A8B
.text$x:00001A8C ; ===========================================================================
.text$x:00001A8C
.text$x:00001A8C ; Segment type: Pure code
.text$x:00001A8C ; Segment permissions: Read/Execute
.text$x:00001A8C _text$x         segment para public 'CODE' use32
.text$x:00001A8C                 assume cs:_text$x
.text$x:00001A8C                 ;org 1A8Ch
.text$x:00001A8C ; COMDAT (pick associative to section at 1A38)
.text$x:00001A8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001A8C
.text$x:00001A8C ; =============== S U B R O U T I N E =======================================
.text$x:00001A8C
.text$x:00001A8C
.text$x:00001A8C __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00001A8C                                         ; DATA XREF: .xdata$x:00002E18o
.text$x:00001A8C                 mov     ecx, [ebp-10h]
.text$x:00001A8F                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00001A8F __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00001A8F
.text$x:00001A94
.text$x:00001A94 ; =============== S U B R O U T I N E =======================================
.text$x:00001A94
.text$x:00001A94
.text$x:00001A94 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00001A94                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00001A94
.text$x:00001A94 arg_4           = dword ptr  8
.text$x:00001A94
.text$x:00001A94                 mov     edx, [esp+arg_4]
.text$x:00001A98                 lea     eax, [edx+0Ch]
.text$x:00001A9B                 mov     ecx, [edx-8]
.text$x:00001A9E                 xor     ecx, eax
.text$x:00001AA0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001AA5                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00001AAA                 jmp     ___CxxFrameHandler3
.text$x:00001AAA __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00001AAA
.text$x:00001AAA ; ---------------------------------------------------------------------------
.text$x:00001AAF                 align 10h
.text$x:00001AAF _text$x         ends
.text$x:00001AAF
.text$mn:00001AB0 ; ===========================================================================
.text$mn:00001AB0
.text$mn:00001AB0 ; Segment type: Pure code
.text$mn:00001AB0 ; Segment permissions: Read/Execute
.text$mn:00001AB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001AB0                 assume cs:_text$mn
.text$mn:00001AB0                 ;org 1AB0h
.text$mn:00001AB0 ; COMDAT (pick any)
.text$mn:00001AB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001AB0
.text$mn:00001AB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AB0
.text$mn:00001AB0 ; Attributes: bp-based frame
.text$mn:00001AB0
.text$mn:00001AB0 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001AB0                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001AB0 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001AB0                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00001AB0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00001AB0
.text$mn:00001AB0 var_10          = dword ptr -10h
.text$mn:00001AB0 var_C           = dword ptr -0Ch
.text$mn:00001AB0 var_4           = dword ptr -4
.text$mn:00001AB0
.text$mn:00001AB0                 push    ebp
.text$mn:00001AB1                 mov     ebp, esp
.text$mn:00001AB3                 push    0FFFFFFFFh
.text$mn:00001AB5                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001ABA                 mov     eax, large fs:0
.text$mn:00001AC0                 push    eax
.text$mn:00001AC1                 push    ecx
.text$mn:00001AC2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001AC7                 xor     eax, ebp
.text$mn:00001AC9                 push    eax
.text$mn:00001ACA                 lea     eax, [ebp+var_C]
.text$mn:00001ACD                 mov     large fs:0, eax
.text$mn:00001AD3                 mov     [ebp+var_10], ecx
.text$mn:00001AD6                 mov     [ebp+var_4], 0
.text$mn:00001ADD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001AE4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001AE7                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00001AEC                 mov     ecx, [ebp+var_C]
.text$mn:00001AEF                 mov     large fs:0, ecx
.text$mn:00001AF6                 pop     ecx
.text$mn:00001AF7                 mov     esp, ebp
.text$mn:00001AF9                 pop     ebp
.text$mn:00001AFA                 retn
.text$mn:00001AFA ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00001AFA
.text$mn:00001AFA ; ---------------------------------------------------------------------------
.text$mn:00001AFB                 align 4
.text$mn:00001AFB _text$mn        ends
.text$mn:00001AFB
.text$x:00001AFC ; ===========================================================================
.text$x:00001AFC
.text$x:00001AFC ; Segment type: Pure code
.text$x:00001AFC ; Segment permissions: Read/Execute
.text$x:00001AFC _text$x         segment para public 'CODE' use32
.text$x:00001AFC                 assume cs:_text$x
.text$x:00001AFC                 ;org 1AFCh
.text$x:00001AFC ; COMDAT (pick associative to section at 1AB0)
.text$x:00001AFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001AFC
.text$x:00001AFC ; =============== S U B R O U T I N E =======================================
.text$x:00001AFC
.text$x:00001AFC
.text$x:00001AFC __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001AFC                                         ; DATA XREF: .xdata$x:00002DC0o
.text$x:00001AFC                 mov     ecx, [ebp-10h]  ; this
.text$x:00001AFF                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001AFF __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001AFF
.text$x:00001B04
.text$x:00001B04 ; =============== S U B R O U T I N E =======================================
.text$x:00001B04
.text$x:00001B04
.text$x:00001B04 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001B04                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001B04
.text$x:00001B04 arg_4           = dword ptr  8
.text$x:00001B04
.text$x:00001B04                 mov     edx, [esp+arg_4]
.text$x:00001B08                 lea     eax, [edx+0Ch]
.text$x:00001B0B                 mov     ecx, [edx-8]
.text$x:00001B0E                 xor     ecx, eax
.text$x:00001B10                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B15                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00001B1A                 jmp     ___CxxFrameHandler3
.text$x:00001B1A __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00001B1A
.text$x:00001B1A ; ---------------------------------------------------------------------------
.text$x:00001B1F                 align 10h
.text$x:00001B1F _text$x         ends
.text$x:00001B1F
.text$mn:00001B20 ; ===========================================================================
.text$mn:00001B20
.text$mn:00001B20 ; Segment type: Pure code
.text$mn:00001B20 ; Segment permissions: Read/Execute
.text$mn:00001B20 _text$mn        segment para public 'CODE' use32
.text$mn:00001B20                 assume cs:_text$mn
.text$mn:00001B20                 ;org 1B20h
.text$mn:00001B20 ; COMDAT (pick any)
.text$mn:00001B20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B20
.text$mn:00001B20 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B20
.text$mn:00001B20 ; Attributes: bp-based frame
.text$mn:00001B20
.text$mn:00001B20 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00001B20                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001B20 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00001B20                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00001B20                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00001B20
.text$mn:00001B20 var_10          = dword ptr -10h
.text$mn:00001B20 var_C           = dword ptr -0Ch
.text$mn:00001B20 var_4           = dword ptr -4
.text$mn:00001B20
.text$mn:00001B20                 push    ebp
.text$mn:00001B21                 mov     ebp, esp
.text$mn:00001B23                 push    0FFFFFFFFh
.text$mn:00001B25                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001B2A                 mov     eax, large fs:0
.text$mn:00001B30                 push    eax
.text$mn:00001B31                 push    ecx
.text$mn:00001B32                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001B37                 xor     eax, ebp
.text$mn:00001B39                 push    eax
.text$mn:00001B3A                 lea     eax, [ebp+var_C]
.text$mn:00001B3D                 mov     large fs:0, eax
.text$mn:00001B43                 mov     [ebp+var_10], ecx
.text$mn:00001B46                 mov     [ebp+var_4], 0
.text$mn:00001B4D                 push    0               ; Size
.text$mn:00001B4F                 push    1               ; char
.text$mn:00001B51                 mov     ecx, [ebp+var_10]
.text$mn:00001B54                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001B59                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001B60                 mov     ecx, [ebp+var_10]
.text$mn:00001B63                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00001B68                 mov     ecx, [ebp+var_C]
.text$mn:00001B6B                 mov     large fs:0, ecx
.text$mn:00001B72                 pop     ecx
.text$mn:00001B73                 mov     esp, ebp
.text$mn:00001B75                 pop     ebp
.text$mn:00001B76                 retn
.text$mn:00001B76 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00001B76
.text$mn:00001B76 ; ---------------------------------------------------------------------------
.text$mn:00001B77                 align 4
.text$mn:00001B77 _text$mn        ends
.text$mn:00001B77
.text$x:00001B78 ; ===========================================================================
.text$x:00001B78
.text$x:00001B78 ; Segment type: Pure code
.text$x:00001B78 ; Segment permissions: Read/Execute
.text$x:00001B78 _text$x         segment para public 'CODE' use32
.text$x:00001B78                 assume cs:_text$x
.text$x:00001B78                 ;org 1B78h
.text$x:00001B78 ; COMDAT (pick associative to section at 1B20)
.text$x:00001B78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001B78
.text$x:00001B78 ; =============== S U B R O U T I N E =======================================
.text$x:00001B78
.text$x:00001B78
.text$x:00001B78 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00001B78                                         ; DATA XREF: .xdata$x:00002E70o
.text$x:00001B78                 mov     ecx, [ebp-10h]
.text$x:00001B7B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00001B7B __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00001B7B
.text$x:00001B80
.text$x:00001B80 ; =============== S U B R O U T I N E =======================================
.text$x:00001B80
.text$x:00001B80
.text$x:00001B80 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00001B80                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00001B80
.text$x:00001B80 arg_4           = dword ptr  8
.text$x:00001B80
.text$x:00001B80                 mov     edx, [esp+arg_4]
.text$x:00001B84                 lea     eax, [edx+0Ch]
.text$x:00001B87                 mov     ecx, [edx-8]
.text$x:00001B8A                 xor     ecx, eax
.text$x:00001B8C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B91                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00001B96                 jmp     ___CxxFrameHandler3
.text$x:00001B96 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00001B96
.text$x:00001B96 ; ---------------------------------------------------------------------------
.text$x:00001B9B                 align 4
.text$x:00001B9B _text$x         ends
.text$x:00001B9B
.text$mn:00001B9C ; ===========================================================================
.text$mn:00001B9C
.text$mn:00001B9C ; Segment type: Pure code
.text$mn:00001B9C ; Segment permissions: Read/Execute
.text$mn:00001B9C _text$mn        segment para public 'CODE' use32
.text$mn:00001B9C                 assume cs:_text$mn
.text$mn:00001B9C                 ;org 1B9Ch
.text$mn:00001B9C ; COMDAT (pick any)
.text$mn:00001B9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B9C
.text$mn:00001B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00001B9C
.text$mn:00001B9C ; Attributes: bp-based frame
.text$mn:00001B9C
.text$mn:00001B9C ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001B9C                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00001B9C ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00001B9C                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00001B9C                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00001B9C
.text$mn:00001B9C var_4           = dword ptr -4
.text$mn:00001B9C
.text$mn:00001B9C                 push    ebp
.text$mn:00001B9D                 mov     ebp, esp
.text$mn:00001B9F                 push    ecx
.text$mn:00001BA0                 mov     [ebp+var_4], ecx
.text$mn:00001BA3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001BA6                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001BAB                 mov     esp, ebp
.text$mn:00001BAD                 pop     ebp
.text$mn:00001BAE                 retn
.text$mn:00001BAE ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00001BAE
.text$mn:00001BAE ; ---------------------------------------------------------------------------
.text$mn:00001BAF                 align 10h
.text$mn:00001BAF _text$mn        ends
.text$mn:00001BAF
.text$mn:00001BB0 ; ===========================================================================
.text$mn:00001BB0
.text$mn:00001BB0 ; Segment type: Pure code
.text$mn:00001BB0 ; Segment permissions: Read/Execute
.text$mn:00001BB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001BB0                 assume cs:_text$mn
.text$mn:00001BB0                 ;org 1BB0h
.text$mn:00001BB0 ; COMDAT (pick any)
.text$mn:00001BB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001BB0
.text$mn:00001BB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BB0
.text$mn:00001BB0 ; Attributes: bp-based frame
.text$mn:00001BB0
.text$mn:00001BB0 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001BB0                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001BB0 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00001BB0                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00001BB0                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00001BB0
.text$mn:00001BB0 var_10          = dword ptr -10h
.text$mn:00001BB0 var_C           = dword ptr -0Ch
.text$mn:00001BB0 var_4           = dword ptr -4
.text$mn:00001BB0
.text$mn:00001BB0                 push    ebp
.text$mn:00001BB1                 mov     ebp, esp
.text$mn:00001BB3                 push    0FFFFFFFFh
.text$mn:00001BB5                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001BBA                 mov     eax, large fs:0
.text$mn:00001BC0                 push    eax
.text$mn:00001BC1                 push    ecx
.text$mn:00001BC2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001BC7                 xor     eax, ebp
.text$mn:00001BC9                 push    eax
.text$mn:00001BCA                 lea     eax, [ebp+var_C]
.text$mn:00001BCD                 mov     large fs:0, eax
.text$mn:00001BD3                 mov     [ebp+var_10], ecx
.text$mn:00001BD6                 mov     [ebp+var_4], 0
.text$mn:00001BDD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001BE4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001BE7                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001BEC                 mov     ecx, [ebp+var_C]
.text$mn:00001BEF                 mov     large fs:0, ecx
.text$mn:00001BF6                 pop     ecx
.text$mn:00001BF7                 mov     esp, ebp
.text$mn:00001BF9                 pop     ebp
.text$mn:00001BFA                 retn
.text$mn:00001BFA ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00001BFA
.text$mn:00001BFA ; ---------------------------------------------------------------------------
.text$mn:00001BFB                 align 4
.text$mn:00001BFB _text$mn        ends
.text$mn:00001BFB
.text$x:00001BFC ; ===========================================================================
.text$x:00001BFC
.text$x:00001BFC ; Segment type: Pure code
.text$x:00001BFC ; Segment permissions: Read/Execute
.text$x:00001BFC _text$x         segment para public 'CODE' use32
.text$x:00001BFC                 assume cs:_text$x
.text$x:00001BFC                 ;org 1BFCh
.text$x:00001BFC ; COMDAT (pick associative to section at 1BB0)
.text$x:00001BFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001BFC
.text$x:00001BFC ; =============== S U B R O U T I N E =======================================
.text$x:00001BFC
.text$x:00001BFC
.text$x:00001BFC __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00001BFC                                         ; DATA XREF: .xdata$x:00002F80o
.text$x:00001BFC                 mov     ecx, [ebp-10h]  ; this
.text$x:00001BFF                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00001BFF __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00001BFF
.text$x:00001C04
.text$x:00001C04 ; =============== S U B R O U T I N E =======================================
.text$x:00001C04
.text$x:00001C04
.text$x:00001C04 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00001C04                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00001C04
.text$x:00001C04 arg_4           = dword ptr  8
.text$x:00001C04
.text$x:00001C04                 mov     edx, [esp+arg_4]
.text$x:00001C08                 lea     eax, [edx+0Ch]
.text$x:00001C0B                 mov     ecx, [edx-8]
.text$x:00001C0E                 xor     ecx, eax
.text$x:00001C10                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C15                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00001C1A                 jmp     ___CxxFrameHandler3
.text$x:00001C1A __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00001C1A
.text$x:00001C1A ; ---------------------------------------------------------------------------
.text$x:00001C1F                 align 10h
.text$x:00001C1F _text$x         ends
.text$x:00001C1F
.text$mn:00001C20 ; ===========================================================================
.text$mn:00001C20
.text$mn:00001C20 ; Segment type: Pure code
.text$mn:00001C20 ; Segment permissions: Read/Execute
.text$mn:00001C20 _text$mn        segment para public 'CODE' use32
.text$mn:00001C20                 assume cs:_text$mn
.text$mn:00001C20                 ;org 1C20h
.text$mn:00001C20 ; COMDAT (pick any)
.text$mn:00001C20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C20
.text$mn:00001C20 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C20
.text$mn:00001C20 ; Attributes: bp-based frame
.text$mn:00001C20
.text$mn:00001C20 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00001C20                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001C20 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00001C20                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001C20                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00001C20
.text$mn:00001C20 var_10          = dword ptr -10h
.text$mn:00001C20 var_C           = dword ptr -0Ch
.text$mn:00001C20 var_4           = dword ptr -4
.text$mn:00001C20
.text$mn:00001C20                 push    ebp
.text$mn:00001C21                 mov     ebp, esp
.text$mn:00001C23                 push    0FFFFFFFFh
.text$mn:00001C25                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001C2A                 mov     eax, large fs:0
.text$mn:00001C30                 push    eax
.text$mn:00001C31                 push    ecx
.text$mn:00001C32                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001C37                 xor     eax, ebp
.text$mn:00001C39                 push    eax
.text$mn:00001C3A                 lea     eax, [ebp+var_C]
.text$mn:00001C3D                 mov     large fs:0, eax
.text$mn:00001C43                 mov     [ebp+var_10], ecx
.text$mn:00001C46                 mov     [ebp+var_4], 0
.text$mn:00001C4D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001C54                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001C57                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001C5C                 mov     ecx, [ebp+var_C]
.text$mn:00001C5F                 mov     large fs:0, ecx
.text$mn:00001C66                 pop     ecx
.text$mn:00001C67                 mov     esp, ebp
.text$mn:00001C69                 pop     ebp
.text$mn:00001C6A                 retn
.text$mn:00001C6A ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00001C6A
.text$mn:00001C6A ; ---------------------------------------------------------------------------
.text$mn:00001C6B                 align 4
.text$mn:00001C6B _text$mn        ends
.text$mn:00001C6B
.text$x:00001C6C ; ===========================================================================
.text$x:00001C6C
.text$x:00001C6C ; Segment type: Pure code
.text$x:00001C6C ; Segment permissions: Read/Execute
.text$x:00001C6C _text$x         segment para public 'CODE' use32
.text$x:00001C6C                 assume cs:_text$x
.text$x:00001C6C                 ;org 1C6Ch
.text$x:00001C6C ; COMDAT (pick associative to section at 1C20)
.text$x:00001C6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001C6C
.text$x:00001C6C ; =============== S U B R O U T I N E =======================================
.text$x:00001C6C
.text$x:00001C6C
.text$x:00001C6C __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00001C6C                                         ; DATA XREF: .xdata$x:00003004o
.text$x:00001C6C                 mov     ecx, [ebp-10h]  ; this
.text$x:00001C6F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001C6F __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00001C6F
.text$x:00001C74
.text$x:00001C74 ; =============== S U B R O U T I N E =======================================
.text$x:00001C74
.text$x:00001C74
.text$x:00001C74 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00001C74                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00001C74
.text$x:00001C74 arg_4           = dword ptr  8
.text$x:00001C74
.text$x:00001C74                 mov     edx, [esp+arg_4]
.text$x:00001C78                 lea     eax, [edx+0Ch]
.text$x:00001C7B                 mov     ecx, [edx-8]
.text$x:00001C7E                 xor     ecx, eax
.text$x:00001C80                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C85                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00001C8A                 jmp     ___CxxFrameHandler3
.text$x:00001C8A __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00001C8A
.text$x:00001C8A ; ---------------------------------------------------------------------------
.text$x:00001C8F                 align 10h
.text$x:00001C8F _text$x         ends
.text$x:00001C8F
.text$mn:00001C90 ; ===========================================================================
.text$mn:00001C90
.text$mn:00001C90 ; Segment type: Pure code
.text$mn:00001C90 ; Segment permissions: Read/Execute
.text$mn:00001C90 _text$mn        segment para public 'CODE' use32
.text$mn:00001C90                 assume cs:_text$mn
.text$mn:00001C90                 ;org 1C90h
.text$mn:00001C90 ; COMDAT (pick any)
.text$mn:00001C90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C90
.text$mn:00001C90 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C90
.text$mn:00001C90 ; Attributes: bp-based frame
.text$mn:00001C90
.text$mn:00001C90 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001C90                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00001C90 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00001C90                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001C90                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001C90
.text$mn:00001C90 var_10          = dword ptr -10h
.text$mn:00001C90 var_C           = dword ptr -0Ch
.text$mn:00001C90 var_4           = dword ptr -4
.text$mn:00001C90
.text$mn:00001C90                 push    ebp
.text$mn:00001C91                 mov     ebp, esp
.text$mn:00001C93                 push    0FFFFFFFFh
.text$mn:00001C95                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00001C9A                 mov     eax, large fs:0
.text$mn:00001CA0                 push    eax
.text$mn:00001CA1                 push    ecx
.text$mn:00001CA2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001CA7                 xor     eax, ebp
.text$mn:00001CA9                 push    eax
.text$mn:00001CAA                 lea     eax, [ebp+var_C]
.text$mn:00001CAD                 mov     large fs:0, eax
.text$mn:00001CB3                 mov     [ebp+var_10], ecx
.text$mn:00001CB6                 mov     [ebp+var_4], 0
.text$mn:00001CBD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001CC4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001CC7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001CCC                 mov     ecx, [ebp+var_C]
.text$mn:00001CCF                 mov     large fs:0, ecx
.text$mn:00001CD6                 pop     ecx
.text$mn:00001CD7                 mov     esp, ebp
.text$mn:00001CD9                 pop     ebp
.text$mn:00001CDA                 retn
.text$mn:00001CDA ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00001CDA
.text$mn:00001CDA ; ---------------------------------------------------------------------------
.text$mn:00001CDB                 align 4
.text$mn:00001CDB _text$mn        ends
.text$mn:00001CDB
.text$x:00001CDC ; ===========================================================================
.text$x:00001CDC
.text$x:00001CDC ; Segment type: Pure code
.text$x:00001CDC ; Segment permissions: Read/Execute
.text$x:00001CDC _text$x         segment para public 'CODE' use32
.text$x:00001CDC                 assume cs:_text$x
.text$x:00001CDC                 ;org 1CDCh
.text$x:00001CDC ; COMDAT (pick associative to section at 1C90)
.text$x:00001CDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001CDC
.text$x:00001CDC ; =============== S U B R O U T I N E =======================================
.text$x:00001CDC
.text$x:00001CDC
.text$x:00001CDC __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00001CDC                                         ; DATA XREF: .xdata$x:00003088o
.text$x:00001CDC                 mov     ecx, [ebp-10h]  ; this
.text$x:00001CDF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001CDF __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00001CDF
.text$x:00001CE4
.text$x:00001CE4 ; =============== S U B R O U T I N E =======================================
.text$x:00001CE4
.text$x:00001CE4
.text$x:00001CE4 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00001CE4                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00001CE4
.text$x:00001CE4 arg_4           = dword ptr  8
.text$x:00001CE4
.text$x:00001CE4                 mov     edx, [esp+arg_4]
.text$x:00001CE8                 lea     eax, [edx+0Ch]
.text$x:00001CEB                 mov     ecx, [edx-8]
.text$x:00001CEE                 xor     ecx, eax
.text$x:00001CF0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001CF5                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00001CFA                 jmp     ___CxxFrameHandler3
.text$x:00001CFA __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00001CFA
.text$x:00001CFA ; ---------------------------------------------------------------------------
.text$x:00001CFF                 align 10h
.text$x:00001CFF _text$x         ends
.text$x:00001CFF
.text$mn:00001D00 ; ===========================================================================
.text$mn:00001D00
.text$mn:00001D00 ; Segment type: Pure code
.text$mn:00001D00 ; Segment permissions: Read/Execute
.text$mn:00001D00 _text$mn        segment para public 'CODE' use32
.text$mn:00001D00                 assume cs:_text$mn
.text$mn:00001D00                 ;org 1D00h
.text$mn:00001D00 ; COMDAT (pick any)
.text$mn:00001D00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D00
.text$mn:00001D00 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D00
.text$mn:00001D00 ; Attributes: bp-based frame
.text$mn:00001D00
.text$mn:00001D00 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00001D00                 public ??1error_category@std@@UAE@XZ
.text$mn:00001D00 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00001D00                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00001D00
.text$mn:00001D00 var_4           = dword ptr -4
.text$mn:00001D00
.text$mn:00001D00                 push    ebp
.text$mn:00001D01                 mov     ebp, esp
.text$mn:00001D03                 push    ecx
.text$mn:00001D04                 mov     [ebp+var_4], ecx
.text$mn:00001D07                 mov     eax, [ebp+var_4]
.text$mn:00001D0A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001D10                 mov     esp, ebp
.text$mn:00001D12                 pop     ebp
.text$mn:00001D13                 retn
.text$mn:00001D13 ??1error_category@std@@UAE@XZ endp
.text$mn:00001D13
.text$mn:00001D13 _text$mn        ends
.text$mn:00001D13
.text$mn:00001D14 ; ===========================================================================
.text$mn:00001D14
.text$mn:00001D14 ; Segment type: Pure code
.text$mn:00001D14 ; Segment permissions: Read/Execute
.text$mn:00001D14 _text$mn        segment para public 'CODE' use32
.text$mn:00001D14                 assume cs:_text$mn
.text$mn:00001D14                 ;org 1D14h
.text$mn:00001D14 ; COMDAT (pick any)
.text$mn:00001D14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D14
.text$mn:00001D14 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D14
.text$mn:00001D14 ; Attributes: bp-based frame
.text$mn:00001D14
.text$mn:00001D14 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00001D14                 public ??2@YAPAXIPAX@Z
.text$mn:00001D14 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00001D14                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00001D14
.text$mn:00001D14 arg_4           = dword ptr  0Ch
.text$mn:00001D14
.text$mn:00001D14                 push    ebp
.text$mn:00001D15                 mov     ebp, esp
.text$mn:00001D17                 mov     eax, [ebp+arg_4]
.text$mn:00001D1A                 pop     ebp
.text$mn:00001D1B                 retn
.text$mn:00001D1B ??2@YAPAXIPAX@Z endp
.text$mn:00001D1B
.text$mn:00001D1B _text$mn        ends
.text$mn:00001D1B
.text$mn:00001D1C ; ===========================================================================
.text$mn:00001D1C
.text$mn:00001D1C ; Segment type: Pure code
.text$mn:00001D1C ; Segment permissions: Read/Execute
.text$mn:00001D1C _text$mn        segment para public 'CODE' use32
.text$mn:00001D1C                 assume cs:_text$mn
.text$mn:00001D1C                 ;org 1D1Ch
.text$mn:00001D1C ; COMDAT (pick any)
.text$mn:00001D1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D1C
.text$mn:00001D1C ; =============== S U B R O U T I N E =======================================
.text$mn:00001D1C
.text$mn:00001D1C ; Attributes: bp-based frame
.text$mn:00001D1C
.text$mn:00001D1C ; void __cdecl operator delete(void *)
.text$mn:00001D1C                 public ??3@YAXPAX0@Z
.text$mn:00001D1C ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00001D1C                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00001D1C                 push    ebp
.text$mn:00001D1D                 mov     ebp, esp
.text$mn:00001D1F                 pop     ebp
.text$mn:00001D20                 retn
.text$mn:00001D20 ??3@YAXPAX0@Z   endp
.text$mn:00001D20
.text$mn:00001D20 ; ---------------------------------------------------------------------------
.text$mn:00001D21                 align 4
.text$mn:00001D21 _text$mn        ends
.text$mn:00001D21
.text$mn:00001D24 ; ===========================================================================
.text$mn:00001D24
.text$mn:00001D24 ; Segment type: Pure code
.text$mn:00001D24 ; Segment permissions: Read/Execute
.text$mn:00001D24 _text$mn        segment para public 'CODE' use32
.text$mn:00001D24                 assume cs:_text$mn
.text$mn:00001D24                 ;org 1D24h
.text$mn:00001D24 ; COMDAT (pick any)
.text$mn:00001D24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D24
.text$mn:00001D24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D24
.text$mn:00001D24 ; Attributes: bp-based frame
.text$mn:00001D24
.text$mn:00001D24 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00001D24                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00001D24 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00001D24                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00001D24                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00001D24
.text$mn:00001D24 var_8           = dword ptr -8
.text$mn:00001D24 var_4           = dword ptr -4
.text$mn:00001D24 arg_0           = dword ptr  8
.text$mn:00001D24
.text$mn:00001D24                 push    ebp
.text$mn:00001D25                 mov     ebp, esp
.text$mn:00001D27                 sub     esp, 8
.text$mn:00001D2A                 mov     [ebp+var_8], ecx
.text$mn:00001D2D                 mov     eax, [ebp+var_8]
.text$mn:00001D30                 cmp     eax, [ebp+arg_0]
.text$mn:00001D33                 jnz     short loc_1D3E
.text$mn:00001D35                 mov     [ebp+var_4], 1
.text$mn:00001D3C                 jmp     short loc_1D45
.text$mn:00001D3E ; ---------------------------------------------------------------------------
.text$mn:00001D3E
.text$mn:00001D3E loc_1D3E:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00001D3E                 mov     [ebp+var_4], 0
.text$mn:00001D45
.text$mn:00001D45 loc_1D45:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00001D45                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001D48                 mov     esp, ebp
.text$mn:00001D4A                 pop     ebp
.text$mn:00001D4B                 retn    4
.text$mn:00001D4B ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00001D4B
.text$mn:00001D4B ; ---------------------------------------------------------------------------
.text$mn:00001D4E                 align 10h
.text$mn:00001D4E _text$mn        ends
.text$mn:00001D4E
.text$mn:00001D50 ; ===========================================================================
.text$mn:00001D50
.text$mn:00001D50 ; Segment type: Pure code
.text$mn:00001D50 ; Segment permissions: Read/Execute
.text$mn:00001D50 _text$mn        segment para public 'CODE' use32
.text$mn:00001D50                 assume cs:_text$mn
.text$mn:00001D50                 ;org 1D50h
.text$mn:00001D50 ; COMDAT (pick any)
.text$mn:00001D50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D50
.text$mn:00001D50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D50
.text$mn:00001D50 ; Attributes: bp-based frame
.text$mn:00001D50
.text$mn:00001D50 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00001D50                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00001D50 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00001D50                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00001D50
.text$mn:00001D50 var_8           = dword ptr -8
.text$mn:00001D50 var_4           = dword ptr -4
.text$mn:00001D50 arg_0           = dword ptr  8
.text$mn:00001D50
.text$mn:00001D50                 push    ebp
.text$mn:00001D51                 mov     ebp, esp
.text$mn:00001D53                 sub     esp, 8
.text$mn:00001D56                 push    esi
.text$mn:00001D57                 mov     [ebp+var_4], ecx
.text$mn:00001D5A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001D5D                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001D62                 push    eax
.text$mn:00001D63                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001D66                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001D6B                 mov     ecx, eax
.text$mn:00001D6D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001D72                 movzx   eax, al
.text$mn:00001D75                 test    eax, eax
.text$mn:00001D77                 jz      short loc_1D98
.text$mn:00001D79                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001D7C                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001D81                 mov     esi, eax
.text$mn:00001D83                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001D86                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001D8B                 cmp     esi, eax
.text$mn:00001D8D                 jnz     short loc_1D98
.text$mn:00001D8F                 mov     [ebp+var_8], 1
.text$mn:00001D96                 jmp     short loc_1D9F
.text$mn:00001D98 ; ---------------------------------------------------------------------------
.text$mn:00001D98
.text$mn:00001D98 loc_1D98:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00001D98                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00001D98                 mov     [ebp+var_8], 0
.text$mn:00001D9F
.text$mn:00001D9F loc_1D9F:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00001D9F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00001DA2                 pop     esi
.text$mn:00001DA3                 mov     esp, ebp
.text$mn:00001DA5                 pop     ebp
.text$mn:00001DA6                 retn    4
.text$mn:00001DA6 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00001DA6
.text$mn:00001DA6 ; ---------------------------------------------------------------------------
.text$mn:00001DA9                 align 4
.text$mn:00001DA9 _text$mn        ends
.text$mn:00001DA9
.text$mn:00001DAC ; ===========================================================================
.text$mn:00001DAC
.text$mn:00001DAC ; Segment type: Pure code
.text$mn:00001DAC ; Segment permissions: Read/Execute
.text$mn:00001DAC _text$mn        segment para public 'CODE' use32
.text$mn:00001DAC                 assume cs:_text$mn
.text$mn:00001DAC                 ;org 1DACh
.text$mn:00001DAC ; COMDAT (pick any)
.text$mn:00001DAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001DAC
.text$mn:00001DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DAC
.text$mn:00001DAC ; Attributes: bp-based frame
.text$mn:00001DAC
.text$mn:00001DAC ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001DAC                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00001DAC ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001DAC
.text$mn:00001DAC var_4           = dword ptr -4
.text$mn:00001DAC arg_0           = dword ptr  8
.text$mn:00001DAC
.text$mn:00001DAC                 push    ebp
.text$mn:00001DAD                 mov     ebp, esp
.text$mn:00001DAF                 push    ecx
.text$mn:00001DB0                 mov     [ebp+var_4], ecx
.text$mn:00001DB3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001DB6                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001DBB                 mov     eax, [ebp+arg_0]
.text$mn:00001DBE                 and     eax, 1
.text$mn:00001DC1                 jz      short loc_1DCF
.text$mn:00001DC3                 mov     ecx, [ebp+var_4]
.text$mn:00001DC6                 push    ecx             ; void *
.text$mn:00001DC7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001DCC                 add     esp, 4
.text$mn:00001DCF
.text$mn:00001DCF loc_1DCF:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001DCF                 mov     eax, [ebp+var_4]
.text$mn:00001DD2                 mov     esp, ebp
.text$mn:00001DD4                 pop     ebp
.text$mn:00001DD5                 retn    4
.text$mn:00001DD5 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00001DD5
.text$mn:00001DD5 _text$mn        ends
.text$mn:00001DD5
.text$mn:00001DD8 ; ===========================================================================
.text$mn:00001DD8
.text$mn:00001DD8 ; Segment type: Pure code
.text$mn:00001DD8 ; Segment permissions: Read/Execute
.text$mn:00001DD8 _text$mn        segment para public 'CODE' use32
.text$mn:00001DD8                 assume cs:_text$mn
.text$mn:00001DD8                 ;org 1DD8h
.text$mn:00001DD8 ; COMDAT (pick any)
.text$mn:00001DD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001DD8
.text$mn:00001DD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DD8
.text$mn:00001DD8 ; Attributes: bp-based frame
.text$mn:00001DD8
.text$mn:00001DD8 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001DD8                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00001DD8 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001DD8
.text$mn:00001DD8 var_4           = dword ptr -4
.text$mn:00001DD8 arg_0           = dword ptr  8
.text$mn:00001DD8
.text$mn:00001DD8                 push    ebp
.text$mn:00001DD9                 mov     ebp, esp
.text$mn:00001DDB                 push    ecx
.text$mn:00001DDC                 mov     [ebp+var_4], ecx
.text$mn:00001DDF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001DE2                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00001DE7                 mov     eax, [ebp+arg_0]
.text$mn:00001DEA                 and     eax, 1
.text$mn:00001DED                 jz      short loc_1DFB
.text$mn:00001DEF                 mov     ecx, [ebp+var_4]
.text$mn:00001DF2                 push    ecx             ; void *
.text$mn:00001DF3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001DF8                 add     esp, 4
.text$mn:00001DFB
.text$mn:00001DFB loc_1DFB:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001DFB                 mov     eax, [ebp+var_4]
.text$mn:00001DFE                 mov     esp, ebp
.text$mn:00001E00                 pop     ebp
.text$mn:00001E01                 retn    4
.text$mn:00001E01 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00001E01
.text$mn:00001E01 _text$mn        ends
.text$mn:00001E01
.text$mn:00001E04 ; ===========================================================================
.text$mn:00001E04
.text$mn:00001E04 ; Segment type: Pure code
.text$mn:00001E04 ; Segment permissions: Read/Execute
.text$mn:00001E04 _text$mn        segment para public 'CODE' use32
.text$mn:00001E04                 assume cs:_text$mn
.text$mn:00001E04                 ;org 1E04h
.text$mn:00001E04 ; COMDAT (pick any)
.text$mn:00001E04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E04
.text$mn:00001E04 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E04
.text$mn:00001E04 ; Attributes: bp-based frame
.text$mn:00001E04
.text$mn:00001E04 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001E04                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00001E04 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001E04
.text$mn:00001E04 var_4           = dword ptr -4
.text$mn:00001E04 arg_0           = dword ptr  8
.text$mn:00001E04
.text$mn:00001E04                 push    ebp
.text$mn:00001E05                 mov     ebp, esp
.text$mn:00001E07                 push    ecx
.text$mn:00001E08                 mov     [ebp+var_4], ecx
.text$mn:00001E0B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001E0E                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00001E13                 mov     eax, [ebp+arg_0]
.text$mn:00001E16                 and     eax, 1
.text$mn:00001E19                 jz      short loc_1E27
.text$mn:00001E1B                 mov     ecx, [ebp+var_4]
.text$mn:00001E1E                 push    ecx             ; void *
.text$mn:00001E1F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001E24                 add     esp, 4
.text$mn:00001E27
.text$mn:00001E27 loc_1E27:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001E27                 mov     eax, [ebp+var_4]
.text$mn:00001E2A                 mov     esp, ebp
.text$mn:00001E2C                 pop     ebp
.text$mn:00001E2D                 retn    4
.text$mn:00001E2D ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00001E2D
.text$mn:00001E2D _text$mn        ends
.text$mn:00001E2D
.text$mn:00001E30 ; ===========================================================================
.text$mn:00001E30
.text$mn:00001E30 ; Segment type: Pure code
.text$mn:00001E30 ; Segment permissions: Read/Execute
.text$mn:00001E30 _text$mn        segment para public 'CODE' use32
.text$mn:00001E30                 assume cs:_text$mn
.text$mn:00001E30                 ;org 1E30h
.text$mn:00001E30 ; COMDAT (pick any)
.text$mn:00001E30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E30
.text$mn:00001E30 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E30
.text$mn:00001E30 ; Attributes: bp-based frame
.text$mn:00001E30
.text$mn:00001E30 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001E30                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00001E30 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00001E30
.text$mn:00001E30 var_4           = dword ptr -4
.text$mn:00001E30 arg_0           = dword ptr  8
.text$mn:00001E30
.text$mn:00001E30                 push    ebp
.text$mn:00001E31                 mov     ebp, esp
.text$mn:00001E33                 push    ecx
.text$mn:00001E34                 mov     [ebp+var_4], ecx
.text$mn:00001E37                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001E3A                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001E3F                 mov     eax, [ebp+arg_0]
.text$mn:00001E42                 and     eax, 1
.text$mn:00001E45                 jz      short loc_1E53
.text$mn:00001E47                 mov     ecx, [ebp+var_4]
.text$mn:00001E4A                 push    ecx             ; void *
.text$mn:00001E4B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001E50                 add     esp, 4
.text$mn:00001E53
.text$mn:00001E53 loc_1E53:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001E53                 mov     eax, [ebp+var_4]
.text$mn:00001E56                 mov     esp, ebp
.text$mn:00001E58                 pop     ebp
.text$mn:00001E59                 retn    4
.text$mn:00001E59 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00001E59
.text$mn:00001E59 _text$mn        ends
.text$mn:00001E59
.text$di:00001E5C ; ===========================================================================
.text$di:00001E5C
.text$di:00001E5C ; Segment type: Pure code
.text$di:00001E5C ; Segment permissions: Read/Execute
.text$di:00001E5C _text$di        segment para public 'CODE' use32
.text$di:00001E5C                 assume cs:_text$di
.text$di:00001E5C                 ;org 1E5Ch
.text$di:00001E5C ; COMDAT (pick any)
.text$di:00001E5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001E5C
.text$di:00001E5C ; =============== S U B R O U T I N E =======================================
.text$di:00001E5C
.text$di:00001E5C ; Attributes: bp-based frame
.text$di:00001E5C
.text$di:00001E5C ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00001E5C ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00001E5C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00001E5C                 push    ebp
.text$di:00001E5D                 mov     ebp, esp
.text$di:00001E5F                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00001E64                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00001E69                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001E6E                 call    _atexit
.text$di:00001E73                 add     esp, 4
.text$di:00001E76                 pop     ebp
.text$di:00001E77                 retn
.text$di:00001E77 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00001E77
.text$di:00001E77 _text$di        ends
.text$di:00001E77
.text$di:00001E78 ; ===========================================================================
.text$di:00001E78
.text$di:00001E78 ; Segment type: Pure code
.text$di:00001E78 ; Segment permissions: Read/Execute
.text$di:00001E78 _text$di        segment para public 'CODE' use32
.text$di:00001E78                 assume cs:_text$di
.text$di:00001E78                 ;org 1E78h
.text$di:00001E78 ; COMDAT (pick any)
.text$di:00001E78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001E78
.text$di:00001E78 ; =============== S U B R O U T I N E =======================================
.text$di:00001E78
.text$di:00001E78 ; Attributes: bp-based frame
.text$di:00001E78
.text$di:00001E78 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00001E78 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00001E78                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00001E78                 push    ebp
.text$di:00001E79                 mov     ebp, esp
.text$di:00001E7B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00001E80                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00001E85                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001E8A                 call    _atexit
.text$di:00001E8F                 add     esp, 4
.text$di:00001E92                 pop     ebp
.text$di:00001E93                 retn
.text$di:00001E93 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00001E93
.text$di:00001E93 _text$di        ends
.text$di:00001E93
.text$di:00001E94 ; ===========================================================================
.text$di:00001E94
.text$di:00001E94 ; Segment type: Pure code
.text$di:00001E94 ; Segment permissions: Read/Execute
.text$di:00001E94 _text$di        segment para public 'CODE' use32
.text$di:00001E94                 assume cs:_text$di
.text$di:00001E94                 ;org 1E94h
.text$di:00001E94 ; COMDAT (pick any)
.text$di:00001E94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001E94
.text$di:00001E94 ; =============== S U B R O U T I N E =======================================
.text$di:00001E94
.text$di:00001E94 ; Attributes: bp-based frame
.text$di:00001E94
.text$di:00001E94 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00001E94 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00001E94                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00001E94                 push    ebp
.text$di:00001E95                 mov     ebp, esp
.text$di:00001E97                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00001E9C                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00001EA1                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001EA6                 call    _atexit
.text$di:00001EAB                 add     esp, 4
.text$di:00001EAE                 pop     ebp
.text$di:00001EAF                 retn
.text$di:00001EAF ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00001EAF
.text$di:00001EAF _text$di        ends
.text$di:00001EAF
.text$di:00001EB0 ; ===========================================================================
.text$di:00001EB0
.text$di:00001EB0 ; Segment type: Pure code
.text$di:00001EB0 ; Segment permissions: Read/Execute
.text$di:00001EB0 _text$di        segment para public 'CODE' use32
.text$di:00001EB0                 assume cs:_text$di
.text$di:00001EB0                 ;org 1EB0h
.text$di:00001EB0 ; COMDAT (pick any)
.text$di:00001EB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001EB0
.text$di:00001EB0 ; =============== S U B R O U T I N E =======================================
.text$di:00001EB0
.text$di:00001EB0 ; Attributes: bp-based frame
.text$di:00001EB0
.text$di:00001EB0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00001EB0 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001EB0                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00001EB0                 push    ebp
.text$di:00001EB1                 mov     ebp, esp
.text$di:00001EB3                 push    0               ; unsigned int
.text$di:00001EB5                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001EBA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001EBF                 pop     ebp
.text$di:00001EC0                 retn
.text$di:00001EC0 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001EC0
.text$di:00001EC0 ; ---------------------------------------------------------------------------
.text$di:00001EC1                 align 4
.text$di:00001EC1 _text$di        ends
.text$di:00001EC1
.text$di:00001EC4 ; ===========================================================================
.text$di:00001EC4
.text$di:00001EC4 ; Segment type: Pure code
.text$di:00001EC4 ; Segment permissions: Read/Execute
.text$di:00001EC4 _text$di        segment para public 'CODE' use32
.text$di:00001EC4                 assume cs:_text$di
.text$di:00001EC4                 ;org 1EC4h
.text$di:00001EC4 ; COMDAT (pick any)
.text$di:00001EC4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001EC4
.text$di:00001EC4 ; =============== S U B R O U T I N E =======================================
.text$di:00001EC4
.text$di:00001EC4 ; Attributes: bp-based frame
.text$di:00001EC4
.text$di:00001EC4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00001EC4 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001EC4                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00001EC4                 push    ebp
.text$di:00001EC5                 mov     ebp, esp
.text$di:00001EC7                 push    0               ; unsigned int
.text$di:00001EC9                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001ECE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001ED3                 pop     ebp
.text$di:00001ED4                 retn
.text$di:00001ED4 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001ED4
.text$di:00001ED4 ; ---------------------------------------------------------------------------
.text$di:00001ED5                 align 4
.text$di:00001ED5 _text$di        ends
.text$di:00001ED5
.text$di:00001ED8 ; ===========================================================================
.text$di:00001ED8
.text$di:00001ED8 ; Segment type: Pure code
.text$di:00001ED8 ; Segment permissions: Read/Execute
.text$di:00001ED8 _text$di        segment para public 'CODE' use32
.text$di:00001ED8                 assume cs:_text$di
.text$di:00001ED8                 ;org 1ED8h
.text$di:00001ED8 ; COMDAT (pick any)
.text$di:00001ED8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001ED8
.text$di:00001ED8 ; =============== S U B R O U T I N E =======================================
.text$di:00001ED8
.text$di:00001ED8 ; Attributes: bp-based frame
.text$di:00001ED8
.text$di:00001ED8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00001ED8 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001ED8                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00001ED8                 push    ebp
.text$di:00001ED9                 mov     ebp, esp
.text$di:00001EDB                 push    0               ; unsigned int
.text$di:00001EDD                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00001EE2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001EE7                 pop     ebp
.text$di:00001EE8                 retn
.text$di:00001EE8 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001EE8
.text$di:00001EE8 ; ---------------------------------------------------------------------------
.text$di:00001EE9                 align 4
.text$di:00001EE9 _text$di        ends
.text$di:00001EE9
.text$di:00001EEC ; ===========================================================================
.text$di:00001EEC
.text$di:00001EEC ; Segment type: Pure code
.text$di:00001EEC ; Segment permissions: Read/Execute
.text$di:00001EEC _text$di        segment para public 'CODE' use32
.text$di:00001EEC                 assume cs:_text$di
.text$di:00001EEC                 ;org 1EECh
.text$di:00001EEC ; COMDAT (pick any)
.text$di:00001EEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001EEC
.text$di:00001EEC ; =============== S U B R O U T I N E =======================================
.text$di:00001EEC
.text$di:00001EEC ; Attributes: bp-based frame
.text$di:00001EEC
.text$di:00001EEC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00001EEC ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001EEC                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00001EEC                 push    ebp
.text$di:00001EED                 mov     ebp, esp
.text$di:00001EEF                 push    0               ; unsigned int
.text$di:00001EF1                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00001EF6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001EFB                 pop     ebp
.text$di:00001EFC                 retn
.text$di:00001EFC ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001EFC
.text$di:00001EFC ; ---------------------------------------------------------------------------
.text$di:00001EFD                 align 10h
.text$di:00001EFD _text$di        ends
.text$di:00001EFD
.text$di:00001F00 ; ===========================================================================
.text$di:00001F00
.text$di:00001F00 ; Segment type: Pure code
.text$di:00001F00 ; Segment permissions: Read/Execute
.text$di:00001F00 _text$di        segment para public 'CODE' use32
.text$di:00001F00                 assume cs:_text$di
.text$di:00001F00                 ;org 1F00h
.text$di:00001F00 ; COMDAT (pick any)
.text$di:00001F00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001F00
.text$di:00001F00 ; =============== S U B R O U T I N E =======================================
.text$di:00001F00
.text$di:00001F00 ; Attributes: bp-based frame
.text$di:00001F00
.text$di:00001F00 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00001F00 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00001F00
.text$di:00001F00 var_1           = byte ptr -1
.text$di:00001F00
.text$di:00001F00                 push    ebp
.text$di:00001F01                 mov     ebp, esp
.text$di:00001F03                 push    ecx
.text$di:00001F04                 xor     eax, eax
.text$di:00001F06                 mov     [ebp+var_1], al
.text$di:00001F09                 mov     esp, ebp
.text$di:00001F0B                 pop     ebp
.text$di:00001F0C                 retn
.text$di:00001F0C ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:00001F0C
.text$di:00001F0C ; ---------------------------------------------------------------------------
.text$di:00001F0D                 align 10h
.text$di:00001F0D _text$di        ends
.text$di:00001F0D
.text$di:00001F10 ; ===========================================================================
.text$di:00001F10
.text$di:00001F10 ; Segment type: Pure code
.text$di:00001F10 ; Segment permissions: Read/Execute
.text$di:00001F10 _text$di        segment para public 'CODE' use32
.text$di:00001F10                 assume cs:_text$di
.text$di:00001F10                 ;org 1F10h
.text$di:00001F10 ; COMDAT (pick any)
.text$di:00001F10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001F10
.text$di:00001F10 ; =============== S U B R O U T I N E =======================================
.text$di:00001F10
.text$di:00001F10 ; Attributes: bp-based frame
.text$di:00001F10
.text$di:00001F10 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00001F10 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00001F10
.text$di:00001F10 var_1           = byte ptr -1
.text$di:00001F10
.text$di:00001F10                 push    ebp
.text$di:00001F11                 mov     ebp, esp
.text$di:00001F13                 push    ecx
.text$di:00001F14                 xor     eax, eax
.text$di:00001F16                 mov     [ebp+var_1], al
.text$di:00001F19                 mov     esp, ebp
.text$di:00001F1B                 pop     ebp
.text$di:00001F1C                 retn
.text$di:00001F1C ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00001F1C
.text$di:00001F1C ; ---------------------------------------------------------------------------
.text$di:00001F1D                 align 10h
.text$di:00001F1D _text$di        ends
.text$di:00001F1D
.text$di:00001F20 ; ===========================================================================
.text$di:00001F20
.text$di:00001F20 ; Segment type: Pure code
.text$di:00001F20 ; Segment permissions: Read/Execute
.text$di:00001F20 _text$di        segment para public 'CODE' use32
.text$di:00001F20                 assume cs:_text$di
.text$di:00001F20                 ;org 1F20h
.text$di:00001F20 ; COMDAT (pick any)
.text$di:00001F20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001F20
.text$di:00001F20 ; =============== S U B R O U T I N E =======================================
.text$di:00001F20
.text$di:00001F20 ; Attributes: bp-based frame
.text$di:00001F20
.text$di:00001F20 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00001F20 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00001F20                 push    ebp
.text$di:00001F21                 mov     ebp, esp
.text$di:00001F23                 mov     ecx, offset _ignore ; this
.text$di:00001F28                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:00001F2D                 pop     ebp
.text$di:00001F2E                 retn
.text$di:00001F2E ??__Eignore@std@@YAXXZ endp
.text$di:00001F2E
.text$di:00001F2E ; ---------------------------------------------------------------------------
.text$di:00001F2F                 align 10h
.text$di:00001F2F _text$di        ends
.text$di:00001F2F
.text$di:00001F30 ; ===========================================================================
.text$di:00001F30
.text$di:00001F30 ; Segment type: Pure code
.text$di:00001F30 ; Segment permissions: Read/Execute
.text$di:00001F30 _text$di        segment para public 'CODE' use32
.text$di:00001F30                 assume cs:_text$di
.text$di:00001F30                 ;org 1F30h
.text$di:00001F30 ; COMDAT (pick any)
.text$di:00001F30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001F30
.text$di:00001F30 ; =============== S U B R O U T I N E =======================================
.text$di:00001F30
.text$di:00001F30 ; Attributes: bp-based frame
.text$di:00001F30
.text$di:00001F30 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00001F30 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00001F30                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00001F30
.text$di:00001F30 var_1           = byte ptr -1
.text$di:00001F30
.text$di:00001F30                 push    ebp
.text$di:00001F31                 mov     ebp, esp
.text$di:00001F33                 push    ecx
.text$di:00001F34                 xor     eax, eax
.text$di:00001F36                 mov     [ebp+var_1], al
.text$di:00001F39                 mov     esp, ebp
.text$di:00001F3B                 pop     ebp
.text$di:00001F3C                 retn
.text$di:00001F3C ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00001F3C
.text$di:00001F3C ; ---------------------------------------------------------------------------
.text$di:00001F3D                 align 10h
.text$di:00001F3D _text$di        ends
.text$di:00001F3D
.text$yd:00001F40 ; ===========================================================================
.text$yd:00001F40
.text$yd:00001F40 ; Segment type: Pure code
.text$yd:00001F40 ; Segment permissions: Read/Execute
.text$yd:00001F40 _text$yd        segment para public 'CODE' use32
.text$yd:00001F40                 assume cs:_text$yd
.text$yd:00001F40                 ;org 1F40h
.text$yd:00001F40 ; COMDAT (pick any)
.text$yd:00001F40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001F40
.text$yd:00001F40 ; =============== S U B R O U T I N E =======================================
.text$yd:00001F40
.text$yd:00001F40 ; Attributes: bp-based frame
.text$yd:00001F40
.text$yd:00001F40 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00001F40 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00001F40                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00001F40                 push    ebp
.text$yd:00001F41                 mov     ebp, esp
.text$yd:00001F43                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00001F48                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00001F4D                 pop     ebp
.text$yd:00001F4E                 retn
.text$yd:00001F4E ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00001F4E
.text$yd:00001F4E ; ---------------------------------------------------------------------------
.text$yd:00001F4F                 align 10h
.text$yd:00001F4F _text$yd        ends
.text$yd:00001F4F
.text$yd:00001F50 ; ===========================================================================
.text$yd:00001F50
.text$yd:00001F50 ; Segment type: Pure code
.text$yd:00001F50 ; Segment permissions: Read/Execute
.text$yd:00001F50 _text$yd        segment para public 'CODE' use32
.text$yd:00001F50                 assume cs:_text$yd
.text$yd:00001F50                 ;org 1F50h
.text$yd:00001F50 ; COMDAT (pick any)
.text$yd:00001F50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001F50
.text$yd:00001F50 ; =============== S U B R O U T I N E =======================================
.text$yd:00001F50
.text$yd:00001F50 ; Attributes: bp-based frame
.text$yd:00001F50
.text$yd:00001F50 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00001F50 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00001F50                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00001F50                 push    ebp
.text$yd:00001F51                 mov     ebp, esp
.text$yd:00001F53                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00001F58                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00001F5D                 pop     ebp
.text$yd:00001F5E                 retn
.text$yd:00001F5E ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00001F5E
.text$yd:00001F5E ; ---------------------------------------------------------------------------
.text$yd:00001F5F                 align 10h
.text$yd:00001F5F _text$yd        ends
.text$yd:00001F5F
.text$yd:00001F60 ; ===========================================================================
.text$yd:00001F60
.text$yd:00001F60 ; Segment type: Pure code
.text$yd:00001F60 ; Segment permissions: Read/Execute
.text$yd:00001F60 _text$yd        segment para public 'CODE' use32
.text$yd:00001F60                 assume cs:_text$yd
.text$yd:00001F60                 ;org 1F60h
.text$yd:00001F60 ; COMDAT (pick any)
.text$yd:00001F60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001F60
.text$yd:00001F60 ; =============== S U B R O U T I N E =======================================
.text$yd:00001F60
.text$yd:00001F60 ; Attributes: bp-based frame
.text$yd:00001F60
.text$yd:00001F60 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00001F60 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00001F60                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00001F60                 push    ebp
.text$yd:00001F61                 mov     ebp, esp
.text$yd:00001F63                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00001F68                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00001F6D                 pop     ebp
.text$yd:00001F6E                 retn
.text$yd:00001F6E ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00001F6E
.text$yd:00001F6E ; ---------------------------------------------------------------------------
.text$yd:00001F6F                 align 10h
.text$yd:00001F6F _text$yd        ends
.text$yd:00001F6F
.text$mn:00001F70 ; ===========================================================================
.text$mn:00001F70
.text$mn:00001F70 ; Segment type: Pure code
.text$mn:00001F70 ; Segment permissions: Read/Execute
.text$mn:00001F70 _text$mn        segment para public 'CODE' use32
.text$mn:00001F70                 assume cs:_text$mn
.text$mn:00001F70                 ;org 1F70h
.text$mn:00001F70 ; COMDAT (pick any)
.text$mn:00001F70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001F70
.text$mn:00001F70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F70
.text$mn:00001F70 ; Attributes: bp-based frame
.text$mn:00001F70
.text$mn:00001F70 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00001F70                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001F70 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001F70                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00001F70
.text$mn:00001F70 var_10          = byte ptr -10h
.text$mn:00001F70 var_8           = dword ptr -8
.text$mn:00001F70 var_1           = byte ptr -1
.text$mn:00001F70
.text$mn:00001F70                 push    ebp
.text$mn:00001F71                 mov     ebp, esp
.text$mn:00001F73                 sub     esp, 10h
.text$mn:00001F76                 mov     [ebp+var_8], ecx
.text$mn:00001F79                 lea     ecx, [ebp+var_1]
.text$mn:00001F7C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001F81                 push    1
.text$mn:00001F83                 lea     ecx, [ebp+var_1]
.text$mn:00001F86                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00001F8B                 mov     ecx, [ebp+var_8]
.text$mn:00001F8E                 mov     [ecx], eax
.text$mn:00001F90                 lea     ecx, [ebp+var_10] ; this
.text$mn:00001F93                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001F98                 push    eax             ; int
.text$mn:00001F99                 mov     edx, [ebp+var_8]
.text$mn:00001F9C                 mov     eax, [edx]
.text$mn:00001F9E                 push    eax             ; void *
.text$mn:00001F9F                 lea     ecx, [ebp+var_1]
.text$mn:00001FA2                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001FA7                 mov     ecx, [ebp+var_8]
.text$mn:00001FAA                 mov     edx, [ecx]
.text$mn:00001FAC                 mov     eax, [ebp+var_8]
.text$mn:00001FAF                 mov     [edx], eax
.text$mn:00001FB1                 mov     esp, ebp
.text$mn:00001FB3                 pop     ebp
.text$mn:00001FB4                 retn
.text$mn:00001FB4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001FB4
.text$mn:00001FB4 ; ---------------------------------------------------------------------------
.text$mn:00001FB5                 align 4
.text$mn:00001FB5 _text$mn        ends
.text$mn:00001FB5
.text$mn:00001FB8 ; ===========================================================================
.text$mn:00001FB8
.text$mn:00001FB8 ; Segment type: Pure code
.text$mn:00001FB8 ; Segment permissions: Read/Execute
.text$mn:00001FB8 _text$mn        segment para public 'CODE' use32
.text$mn:00001FB8                 assume cs:_text$mn
.text$mn:00001FB8                 ;org 1FB8h
.text$mn:00001FB8 ; COMDAT (pick any)
.text$mn:00001FB8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001FB8
.text$mn:00001FB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FB8
.text$mn:00001FB8 ; Attributes: bp-based frame
.text$mn:00001FB8
.text$mn:00001FB8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00001FB8                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001FB8 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00001FB8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00001FB8
.text$mn:00001FB8 var_20          = dword ptr -20h
.text$mn:00001FB8 var_1C          = dword ptr -1Ch
.text$mn:00001FB8 var_18          = dword ptr -18h
.text$mn:00001FB8 var_11          = byte ptr -11h
.text$mn:00001FB8 var_10          = dword ptr -10h
.text$mn:00001FB8 var_C           = byte ptr -0Ch
.text$mn:00001FB8 var_4           = dword ptr -4
.text$mn:00001FB8 arg_0           = dword ptr  8
.text$mn:00001FB8
.text$mn:00001FB8 ; FUNCTION CHUNK AT .text$mn:000020DA SIZE 00000009 BYTES
.text$mn:00001FB8
.text$mn:00001FB8                 push    ebp
.text$mn:00001FB9                 mov     ebp, esp
.text$mn:00001FBB                 push    0FFFFFFFFh
.text$mn:00001FBD                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001FC2                 mov     eax, large fs:0
.text$mn:00001FC8                 push    eax
.text$mn:00001FC9                 push    ecx
.text$mn:00001FCA                 sub     esp, 10h
.text$mn:00001FCD                 push    ebx
.text$mn:00001FCE                 push    esi
.text$mn:00001FCF                 push    edi
.text$mn:00001FD0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001FD5                 xor     eax, ebp
.text$mn:00001FD7                 push    eax
.text$mn:00001FD8                 lea     eax, [ebp+var_C]
.text$mn:00001FDB                 mov     large fs:0, eax
.text$mn:00001FE1                 mov     [ebp+var_10], esp
.text$mn:00001FE4                 mov     [ebp+var_18], ecx
.text$mn:00001FE7                 mov     eax, [ebp+arg_0]
.text$mn:00001FEA                 or      eax, 0Fh
.text$mn:00001FED                 mov     [ebp+var_1C], eax
.text$mn:00001FF0                 mov     ecx, [ebp+var_18]
.text$mn:00001FF3                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001FF8                 cmp     eax, [ebp+var_1C]
.text$mn:00001FFB                 jnb     short loc_2005
.text$mn:00001FFD                 mov     ecx, [ebp+arg_0]
.text$mn:00002000                 mov     [ebp+var_1C], ecx
.text$mn:00002003                 jmp     short loc_2057
.text$mn:00002005 ; ---------------------------------------------------------------------------
.text$mn:00002005
.text$mn:00002005 loc_2005:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00002005                 mov     edx, [ebp+var_18]
.text$mn:00002008                 mov     ecx, [edx+18h]
.text$mn:0000200B                 shr     ecx, 1
.text$mn:0000200D                 mov     eax, [ebp+var_1C]
.text$mn:00002010                 xor     edx, edx
.text$mn:00002012                 mov     esi, 3
.text$mn:00002017                 div     esi
.text$mn:00002019                 cmp     ecx, eax
.text$mn:0000201B                 ja      short loc_201F
.text$mn:0000201D                 jmp     short loc_2057
.text$mn:0000201F ; ---------------------------------------------------------------------------
.text$mn:0000201F
.text$mn:0000201F loc_201F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:0000201F                 mov     ecx, [ebp+var_18]
.text$mn:00002022                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00002027                 mov     edx, [ebp+var_18]
.text$mn:0000202A                 mov     ecx, [edx+18h]
.text$mn:0000202D                 shr     ecx, 1
.text$mn:0000202F                 sub     eax, ecx
.text$mn:00002031                 mov     edx, [ebp+var_18]
.text$mn:00002034                 cmp     [edx+18h], eax
.text$mn:00002037                 ja      short loc_204C
.text$mn:00002039                 mov     eax, [ebp+var_18]
.text$mn:0000203C                 mov     ecx, [eax+18h]
.text$mn:0000203F                 shr     ecx, 1
.text$mn:00002041                 mov     edx, [ebp+var_18]
.text$mn:00002044                 add     ecx, [edx+18h]
.text$mn:00002047                 mov     [ebp+var_1C], ecx
.text$mn:0000204A                 jmp     short loc_2057
.text$mn:0000204C ; ---------------------------------------------------------------------------
.text$mn:0000204C
.text$mn:0000204C loc_204C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:0000204C                 mov     ecx, [ebp+var_18]
.text$mn:0000204F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00002054                 mov     [ebp+var_1C], eax
.text$mn:00002057
.text$mn:00002057 loc_2057:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00002057                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00002057                 mov     [ebp+var_4], 0
.text$mn:0000205E                 mov     eax, [ebp+var_1C]
.text$mn:00002061                 add     eax, 1
.text$mn:00002064                 push    eax
.text$mn:00002065                 lea     ecx, [ebp+var_11]
.text$mn:00002068                 push    ecx
.text$mn:00002069                 mov     ecx, [ebp+var_18]
.text$mn:0000206C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002071                 mov     ecx, eax
.text$mn:00002073                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00002078                 mov     [ebp+var_20], eax
.text$mn:0000207B                 jmp     short loc_20DA
.text$mn:0000207B ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:0000207B
.text$mn:0000207D
.text$mn:0000207D ; =============== S U B R O U T I N E =======================================
.text$mn:0000207D
.text$mn:0000207D
.text$mn:0000207D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:0000207D                                         ; DATA XREF: .xdata$x:00002EA4o
.text$mn:0000207D
.text$mn:0000207D ; FUNCTION CHUNK AT .text$mn:000020C4 SIZE 00000009 BYTES
.text$mn:0000207D ; FUNCTION CHUNK AT .text$mn:000020D4 SIZE 00000006 BYTES
.text$mn:0000207D
.text$mn:0000207D                 mov     [ebp-10h], esp
.text$mn:00002080                 mov     edx, [ebp+8]
.text$mn:00002083                 mov     [ebp-1Ch], edx
.text$mn:00002086                 mov     byte ptr [ebp-4], 2
.text$mn:0000208A                 mov     eax, [ebp-1Ch]
.text$mn:0000208D                 add     eax, 1
.text$mn:00002090                 push    eax
.text$mn:00002091                 lea     ecx, [ebp-12h]
.text$mn:00002094                 push    ecx
.text$mn:00002095                 mov     ecx, [ebp-18h]
.text$mn:00002098                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000209D                 mov     ecx, eax
.text$mn:0000209F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000020A4                 mov     [ebp-20h], eax
.text$mn:000020A7                 jmp     short loc_20C4
.text$mn:000020A7 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:000020A7
.text$mn:000020A9
.text$mn:000020A9 ; =============== S U B R O U T I N E =======================================
.text$mn:000020A9
.text$mn:000020A9 ; Attributes: noreturn
.text$mn:000020A9
.text$mn:000020A9 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:000020A9                                         ; DATA XREF: .xdata$x:00002EB4o
.text$mn:000020A9                 push    0               ; Size
.text$mn:000020AB                 push    1               ; char
.text$mn:000020AD                 mov     ecx, [ebp-18h]
.text$mn:000020B0                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000020B5                 push    0
.text$mn:000020B7                 push    0
.text$mn:000020B9                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000020B9 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:000020B9
.text$mn:000020BE ; ---------------------------------------------------------------------------
.text$mn:000020BE                 mov     eax, offset $LN17
.text$mn:000020C3                 retn
.text$mn:000020C4 ; ---------------------------------------------------------------------------
.text$mn:000020C4 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000020C4
.text$mn:000020C4 loc_20C4:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:000020C4                 mov     dword ptr [ebp-4], 1
.text$mn:000020CB                 jmp     short loc_20D4
.text$mn:000020CB ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000020CD
.text$mn:000020CD ; =============== S U B R O U T I N E =======================================
.text$mn:000020CD
.text$mn:000020CD
.text$mn:000020CD $LN17           proc near               ; DATA XREF: .text$mn:000020BEo
.text$mn:000020CD                 mov     dword ptr [ebp-4], 1
.text$mn:000020CD $LN17           endp ; sp-analysis failed
.text$mn:000020CD
.text$mn:000020D4 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000020D4
.text$mn:000020D4 loc_20D4:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:000020D4                 mov     eax, offset $LN19
.text$mn:000020D9                 retn
.text$mn:000020D9 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000020DA ; ---------------------------------------------------------------------------
.text$mn:000020DA ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000020DA
.text$mn:000020DA loc_20DA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:000020DA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000020E1                 jmp     short loc_20EA
.text$mn:000020E1 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000020E3
.text$mn:000020E3 ; =============== S U B R O U T I N E =======================================
.text$mn:000020E3
.text$mn:000020E3
.text$mn:000020E3 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_20D4o
.text$mn:000020E3                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000020EA
.text$mn:000020EA loc_20EA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:000020EA                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:000020EE                 jbe     short loc_2109
.text$mn:000020F0                 mov     edx, [ebp+0Ch]
.text$mn:000020F3                 push    edx             ; Size
.text$mn:000020F4                 mov     ecx, [ebp-18h]
.text$mn:000020F7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000020FC                 push    eax             ; Src
.text$mn:000020FD                 mov     eax, [ebp-20h]
.text$mn:00002100                 push    eax             ; Dst
.text$mn:00002101                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002106                 add     esp, 0Ch
.text$mn:00002109
.text$mn:00002109 loc_2109:                               ; CODE XREF: $LN19+Bj
.text$mn:00002109                 push    0               ; Size
.text$mn:0000210B                 push    1               ; char
.text$mn:0000210D                 mov     ecx, [ebp-18h]
.text$mn:00002110                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002115                 lea     ecx, [ebp-20h]
.text$mn:00002118                 push    ecx             ; int
.text$mn:00002119                 mov     edx, [ebp-18h]
.text$mn:0000211C                 add     edx, 4
.text$mn:0000211F                 push    edx             ; void *
.text$mn:00002120                 lea     eax, [ebp-13h]
.text$mn:00002123                 push    eax
.text$mn:00002124                 mov     ecx, [ebp-18h]
.text$mn:00002127                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000212C                 mov     ecx, eax
.text$mn:0000212E                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00002133                 mov     ecx, [ebp-18h]
.text$mn:00002136                 mov     edx, [ebp-1Ch]
.text$mn:00002139                 mov     [ecx+18h], edx
.text$mn:0000213C                 mov     eax, [ebp+0Ch]
.text$mn:0000213F                 push    eax
.text$mn:00002140                 mov     ecx, [ebp-18h]
.text$mn:00002143                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002148                 mov     ecx, [ebp-0Ch]
.text$mn:0000214B                 mov     large fs:0, ecx
.text$mn:00002152                 pop     ecx
.text$mn:00002153                 pop     edi
.text$mn:00002154                 pop     esi
.text$mn:00002155                 pop     ebx
.text$mn:00002156                 mov     esp, ebp
.text$mn:00002158                 pop     ebp
.text$mn:00002159                 retn    8
.text$mn:00002159 $LN19           endp ; sp-analysis failed
.text$mn:00002159
.text$mn:00002159 _text$mn        ends
.text$mn:00002159
.text$x:0000215C ; ===========================================================================
.text$x:0000215C
.text$x:0000215C ; Segment type: Pure code
.text$x:0000215C ; Segment permissions: Read/Execute
.text$x:0000215C _text$x         segment para public 'CODE' use32
.text$x:0000215C                 assume cs:_text$x
.text$x:0000215C                 ;org 215Ch
.text$x:0000215C ; COMDAT (pick associative to section at 1FB8)
.text$x:0000215C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000215C
.text$x:0000215C ; =============== S U B R O U T I N E =======================================
.text$x:0000215C
.text$x:0000215C
.text$x:0000215C __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:0000215C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:0000215C
.text$x:0000215C arg_4           = dword ptr  8
.text$x:0000215C
.text$x:0000215C                 mov     edx, [esp+arg_4]
.text$x:00002160                 lea     eax, [edx+0Ch]
.text$x:00002163                 mov     ecx, [edx-24h]
.text$x:00002166                 xor     ecx, eax
.text$x:00002168                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000216D                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00002172                 jmp     ___CxxFrameHandler3
.text$x:00002172 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00002172
.text$x:00002172 ; ---------------------------------------------------------------------------
.text$x:00002177                 align 4
.text$x:00002177 _text$x         ends
.text$x:00002177
.text$mn:00002178 ; ===========================================================================
.text$mn:00002178
.text$mn:00002178 ; Segment type: Pure code
.text$mn:00002178 ; Segment permissions: Read/Execute
.text$mn:00002178 _text$mn        segment para public 'CODE' use32
.text$mn:00002178                 assume cs:_text$mn
.text$mn:00002178                 ;org 2178h
.text$mn:00002178 ; COMDAT (pick any)
.text$mn:00002178                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002178
.text$mn:00002178 ; =============== S U B R O U T I N E =======================================
.text$mn:00002178
.text$mn:00002178 ; Attributes: bp-based frame
.text$mn:00002178
.text$mn:00002178 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00002178                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00002178 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00002178                                         ; CODE XREF: $LN19+60p
.text$mn:00002178                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00002178
.text$mn:00002178 var_8           = dword ptr -8
.text$mn:00002178 var_1           = byte ptr -1
.text$mn:00002178 arg_0           = dword ptr  8
.text$mn:00002178
.text$mn:00002178                 push    ebp
.text$mn:00002179                 mov     ebp, esp
.text$mn:0000217B                 sub     esp, 8
.text$mn:0000217E                 mov     [ebp+var_8], ecx
.text$mn:00002181                 mov     [ebp+var_1], 0
.text$mn:00002185                 mov     eax, [ebp+var_8]
.text$mn:00002188                 mov     ecx, [ebp+arg_0]
.text$mn:0000218B                 mov     [eax+14h], ecx
.text$mn:0000218E                 lea     edx, [ebp+var_1]
.text$mn:00002191                 push    edx
.text$mn:00002192                 mov     ecx, [ebp+var_8]
.text$mn:00002195                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000219A                 add     eax, [ebp+arg_0]
.text$mn:0000219D                 push    eax
.text$mn:0000219E                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:000021A3                 add     esp, 8
.text$mn:000021A6                 mov     esp, ebp
.text$mn:000021A8                 pop     ebp
.text$mn:000021A9                 retn    4
.text$mn:000021A9 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:000021A9
.text$mn:000021A9 _text$mn        ends
.text$mn:000021A9
.text$mn:000021AC ; ===========================================================================
.text$mn:000021AC
.text$mn:000021AC ; Segment type: Pure code
.text$mn:000021AC ; Segment permissions: Read/Execute
.text$mn:000021AC _text$mn        segment para public 'CODE' use32
.text$mn:000021AC                 assume cs:_text$mn
.text$mn:000021AC                 ;org 21ACh
.text$mn:000021AC ; COMDAT (pick any)
.text$mn:000021AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021AC
.text$mn:000021AC ; =============== S U B R O U T I N E =======================================
.text$mn:000021AC
.text$mn:000021AC ; Attributes: bp-based frame
.text$mn:000021AC
.text$mn:000021AC ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:000021AC                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000021AC ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000021AC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:000021AC
.text$mn:000021AC var_8           = dword ptr -8
.text$mn:000021AC var_1           = byte ptr -1
.text$mn:000021AC
.text$mn:000021AC                 push    ebp
.text$mn:000021AD                 mov     ebp, esp
.text$mn:000021AF                 sub     esp, 8
.text$mn:000021B2                 mov     [ebp+var_8], ecx
.text$mn:000021B5                 lea     ecx, [ebp+var_1]
.text$mn:000021B8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000021BD                 mov     ecx, [ebp+var_8] ; this
.text$mn:000021C0                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000021C5                 mov     eax, [ebp+var_8]
.text$mn:000021C8                 mov     ecx, [eax]
.text$mn:000021CA                 push    ecx
.text$mn:000021CB                 lea     ecx, [ebp+var_1]
.text$mn:000021CE                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000021D3                 push    1               ; int
.text$mn:000021D5                 mov     edx, [ebp+var_8]
.text$mn:000021D8                 mov     eax, [edx]
.text$mn:000021DA                 push    eax             ; void *
.text$mn:000021DB                 lea     ecx, [ebp+var_1]
.text$mn:000021DE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000021E3                 mov     ecx, [ebp+var_8]
.text$mn:000021E6                 mov     dword ptr [ecx], 0
.text$mn:000021EC                 mov     esp, ebp
.text$mn:000021EE                 pop     ebp
.text$mn:000021EF                 retn
.text$mn:000021EF ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000021EF
.text$mn:000021EF _text$mn        ends
.text$mn:000021EF
.text$mn:000021F0 ; ===========================================================================
.text$mn:000021F0
.text$mn:000021F0 ; Segment type: Pure code
.text$mn:000021F0 ; Segment permissions: Read/Execute
.text$mn:000021F0 _text$mn        segment para public 'CODE' use32
.text$mn:000021F0                 assume cs:_text$mn
.text$mn:000021F0                 ;org 21F0h
.text$mn:000021F0 ; COMDAT (pick any)
.text$mn:000021F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021F0
.text$mn:000021F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000021F0
.text$mn:000021F0 ; Attributes: bp-based frame
.text$mn:000021F0
.text$mn:000021F0 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:000021F0                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:000021F0 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:000021F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:000021F0                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:000021F0
.text$mn:000021F0 var_4           = dword ptr -4
.text$mn:000021F0 arg_0           = dword ptr  8
.text$mn:000021F0
.text$mn:000021F0                 push    ebp
.text$mn:000021F1                 mov     ebp, esp
.text$mn:000021F3                 push    ecx
.text$mn:000021F4                 mov     [ebp+var_4], ecx
.text$mn:000021F7                 mov     ecx, [ebp+arg_0]
.text$mn:000021FA                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:000021FF                 mov     eax, [ebp+arg_0]
.text$mn:00002202                 mov     esp, ebp
.text$mn:00002204                 pop     ebp
.text$mn:00002205                 retn    4
.text$mn:00002205 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00002205
.text$mn:00002205 _text$mn        ends
.text$mn:00002205
.text$mn:00002208 ; ===========================================================================
.text$mn:00002208
.text$mn:00002208 ; Segment type: Pure code
.text$mn:00002208 ; Segment permissions: Read/Execute
.text$mn:00002208 _text$mn        segment para public 'CODE' use32
.text$mn:00002208                 assume cs:_text$mn
.text$mn:00002208                 ;org 2208h
.text$mn:00002208 ; COMDAT (pick any)
.text$mn:00002208                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002208
.text$mn:00002208 ; =============== S U B R O U T I N E =======================================
.text$mn:00002208
.text$mn:00002208 ; Attributes: bp-based frame
.text$mn:00002208
.text$mn:00002208 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00002208                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00002208 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00002208                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00002208                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00002208
.text$mn:00002208 var_C           = dword ptr -0Ch
.text$mn:00002208 Size            = dword ptr -8
.text$mn:00002208 var_4           = dword ptr -4
.text$mn:00002208 arg_0           = dword ptr  8
.text$mn:00002208 arg_4           = byte ptr  0Ch
.text$mn:00002208
.text$mn:00002208                 push    ebp
.text$mn:00002209                 mov     ebp, esp
.text$mn:0000220B                 sub     esp, 0Ch
.text$mn:0000220E                 mov     [ebp+var_4], ecx
.text$mn:00002211                 mov     ecx, [ebp+var_4]
.text$mn:00002214                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00002219                 cmp     eax, [ebp+arg_0]
.text$mn:0000221C                 jnb     short loc_2226
.text$mn:0000221E                 mov     ecx, [ebp+var_4]
.text$mn:00002221                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00002226
.text$mn:00002226 loc_2226:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00002226                 mov     eax, [ebp+var_4]
.text$mn:00002229                 mov     ecx, [eax+18h]
.text$mn:0000222C                 cmp     ecx, [ebp+arg_0]
.text$mn:0000222F                 jnb     short loc_2246
.text$mn:00002231                 mov     edx, [ebp+var_4]
.text$mn:00002234                 mov     eax, [edx+14h]
.text$mn:00002237                 push    eax
.text$mn:00002238                 mov     ecx, [ebp+arg_0]
.text$mn:0000223B                 push    ecx
.text$mn:0000223C                 mov     ecx, [ebp+var_4]
.text$mn:0000223F                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00002244                 jmp     short loc_2290
.text$mn:00002246 ; ---------------------------------------------------------------------------
.text$mn:00002246
.text$mn:00002246 loc_2246:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00002246                 movzx   edx, [ebp+arg_4]
.text$mn:0000224A                 test    edx, edx
.text$mn:0000224C                 jz      short loc_2280
.text$mn:0000224E                 cmp     [ebp+arg_0], 10h
.text$mn:00002252                 jnb     short loc_2280
.text$mn:00002254                 mov     eax, [ebp+var_4]
.text$mn:00002257                 mov     ecx, [ebp+arg_0]
.text$mn:0000225A                 cmp     ecx, [eax+14h]
.text$mn:0000225D                 jnb     short loc_2267
.text$mn:0000225F                 mov     edx, [ebp+arg_0]
.text$mn:00002262                 mov     [ebp+Size], edx
.text$mn:00002265                 jmp     short loc_2270
.text$mn:00002267 ; ---------------------------------------------------------------------------
.text$mn:00002267
.text$mn:00002267 loc_2267:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00002267                 mov     eax, [ebp+var_4]
.text$mn:0000226A                 mov     ecx, [eax+14h]
.text$mn:0000226D                 mov     [ebp+Size], ecx
.text$mn:00002270
.text$mn:00002270 loc_2270:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00002270                 mov     edx, [ebp+Size]
.text$mn:00002273                 push    edx             ; Size
.text$mn:00002274                 push    1               ; char
.text$mn:00002276                 mov     ecx, [ebp+var_4]
.text$mn:00002279                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000227E                 jmp     short loc_2290
.text$mn:00002280 ; ---------------------------------------------------------------------------
.text$mn:00002280
.text$mn:00002280 loc_2280:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00002280                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00002280                 cmp     [ebp+arg_0], 0
.text$mn:00002284                 jnz     short loc_2290
.text$mn:00002286                 push    0
.text$mn:00002288                 mov     ecx, [ebp+var_4]
.text$mn:0000228B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002290
.text$mn:00002290 loc_2290:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00002290                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00002290                 cmp     [ebp+arg_0], 0
.text$mn:00002294                 jbe     short loc_229F
.text$mn:00002296                 mov     [ebp+var_C], 1
.text$mn:0000229D                 jmp     short loc_22A6
.text$mn:0000229F ; ---------------------------------------------------------------------------
.text$mn:0000229F
.text$mn:0000229F loc_229F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000229F                 mov     [ebp+var_C], 0
.text$mn:000022A6
.text$mn:000022A6 loc_22A6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:000022A6                 mov     al, byte ptr [ebp+var_C]
.text$mn:000022A9                 mov     esp, ebp
.text$mn:000022AB                 pop     ebp
.text$mn:000022AC                 retn    8
.text$mn:000022AC ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:000022AC
.text$mn:000022AC ; ---------------------------------------------------------------------------
.text$mn:000022AF                 align 10h
.text$mn:000022AF _text$mn        ends
.text$mn:000022AF
.text$mn:000022B0 ; ===========================================================================
.text$mn:000022B0
.text$mn:000022B0 ; Segment type: Pure code
.text$mn:000022B0 ; Segment permissions: Read/Execute
.text$mn:000022B0 _text$mn        segment para public 'CODE' use32
.text$mn:000022B0                 assume cs:_text$mn
.text$mn:000022B0                 ;org 22B0h
.text$mn:000022B0 ; COMDAT (pick any)
.text$mn:000022B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022B0
.text$mn:000022B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022B0
.text$mn:000022B0 ; Attributes: bp-based frame
.text$mn:000022B0
.text$mn:000022B0 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000022B0                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000022B0 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000022B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000022B0
.text$mn:000022B0 var_4           = dword ptr -4
.text$mn:000022B0 arg_0           = dword ptr  8
.text$mn:000022B0
.text$mn:000022B0                 push    ebp
.text$mn:000022B1                 mov     ebp, esp
.text$mn:000022B3                 push    ecx
.text$mn:000022B4                 mov     [ebp+var_4], ecx
.text$mn:000022B7                 cmp     [ebp+arg_0], 0
.text$mn:000022BB                 jz      short loc_22DD
.text$mn:000022BD                 mov     ecx, [ebp+var_4]
.text$mn:000022C0                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000022C5                 cmp     [ebp+arg_0], eax
.text$mn:000022C8                 jb      short loc_22DD
.text$mn:000022CA                 mov     ecx, [ebp+var_4]
.text$mn:000022CD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000022D2                 mov     ecx, [ebp+var_4]
.text$mn:000022D5                 add     eax, [ecx+14h]
.text$mn:000022D8                 cmp     eax, [ebp+arg_0]
.text$mn:000022DB                 ja      short loc_22E3
.text$mn:000022DD
.text$mn:000022DD loc_22DD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:000022DD                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:000022DD                 xor     al, al
.text$mn:000022DF                 jmp     short loc_22E5
.text$mn:000022E1 ; ---------------------------------------------------------------------------
.text$mn:000022E1                 jmp     short loc_22E5
.text$mn:000022E3 ; ---------------------------------------------------------------------------
.text$mn:000022E3
.text$mn:000022E3 loc_22E3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:000022E3                 mov     al, 1
.text$mn:000022E5
.text$mn:000022E5 loc_22E5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000022E5                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000022E5                 mov     esp, ebp
.text$mn:000022E7                 pop     ebp
.text$mn:000022E8                 retn    4
.text$mn:000022E8 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000022E8
.text$mn:000022E8 ; ---------------------------------------------------------------------------
.text$mn:000022EB                 align 4
.text$mn:000022EB _text$mn        ends
.text$mn:000022EB
.text$mn:000022EC ; ===========================================================================
.text$mn:000022EC
.text$mn:000022EC ; Segment type: Pure code
.text$mn:000022EC ; Segment permissions: Read/Execute
.text$mn:000022EC _text$mn        segment para public 'CODE' use32
.text$mn:000022EC                 assume cs:_text$mn
.text$mn:000022EC                 ;org 22ECh
.text$mn:000022EC ; COMDAT (pick any)
.text$mn:000022EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022EC
.text$mn:000022EC ; =============== S U B R O U T I N E =======================================
.text$mn:000022EC
.text$mn:000022EC ; Attributes: bp-based frame
.text$mn:000022EC
.text$mn:000022EC ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:000022EC                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:000022EC ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:000022EC                                         ; CODE XREF: $LN19+14p
.text$mn:000022EC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:000022EC
.text$mn:000022EC var_8           = dword ptr -8
.text$mn:000022EC var_4           = dword ptr -4
.text$mn:000022EC
.text$mn:000022EC                 push    ebp
.text$mn:000022ED                 mov     ebp, esp
.text$mn:000022EF                 sub     esp, 8
.text$mn:000022F2                 mov     [ebp+var_4], ecx
.text$mn:000022F5                 mov     eax, [ebp+var_4]
.text$mn:000022F8                 cmp     dword ptr [eax+18h], 10h
.text$mn:000022FC                 jb      short loc_2312
.text$mn:000022FE                 mov     ecx, [ebp+var_4]
.text$mn:00002301                 mov     edx, [ecx+4]
.text$mn:00002304                 push    edx
.text$mn:00002305                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000230A                 add     esp, 4
.text$mn:0000230D                 mov     [ebp+var_8], eax
.text$mn:00002310                 jmp     short loc_231B
.text$mn:00002312 ; ---------------------------------------------------------------------------
.text$mn:00002312
.text$mn:00002312 loc_2312:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00002312                 mov     eax, [ebp+var_4]
.text$mn:00002315                 add     eax, 4
.text$mn:00002318                 mov     [ebp+var_8], eax
.text$mn:0000231B
.text$mn:0000231B loc_231B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000231B                 mov     eax, [ebp+var_8]
.text$mn:0000231E                 mov     esp, ebp
.text$mn:00002320                 pop     ebp
.text$mn:00002321                 retn
.text$mn:00002321 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00002321
.text$mn:00002321 ; ---------------------------------------------------------------------------
.text$mn:00002322                 align 4
.text$mn:00002322 _text$mn        ends
.text$mn:00002322
.text$mn:00002324 ; ===========================================================================
.text$mn:00002324
.text$mn:00002324 ; Segment type: Pure code
.text$mn:00002324 ; Segment permissions: Read/Execute
.text$mn:00002324 _text$mn        segment para public 'CODE' use32
.text$mn:00002324                 assume cs:_text$mn
.text$mn:00002324                 ;org 2324h
.text$mn:00002324 ; COMDAT (pick any)
.text$mn:00002324                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002324
.text$mn:00002324 ; =============== S U B R O U T I N E =======================================
.text$mn:00002324
.text$mn:00002324 ; Attributes: bp-based frame
.text$mn:00002324
.text$mn:00002324 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00002324                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00002324 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00002324                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00002324
.text$mn:00002324 var_8           = dword ptr -8
.text$mn:00002324 var_4           = dword ptr -4
.text$mn:00002324
.text$mn:00002324                 push    ebp
.text$mn:00002325                 mov     ebp, esp
.text$mn:00002327                 sub     esp, 8
.text$mn:0000232A                 mov     [ebp+var_4], ecx
.text$mn:0000232D                 mov     eax, [ebp+var_4]
.text$mn:00002330                 cmp     dword ptr [eax+18h], 10h
.text$mn:00002334                 jb      short loc_234A
.text$mn:00002336                 mov     ecx, [ebp+var_4]
.text$mn:00002339                 mov     edx, [ecx+4]
.text$mn:0000233C                 push    edx
.text$mn:0000233D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002342                 add     esp, 4
.text$mn:00002345                 mov     [ebp+var_8], eax
.text$mn:00002348                 jmp     short loc_2353
.text$mn:0000234A ; ---------------------------------------------------------------------------
.text$mn:0000234A
.text$mn:0000234A loc_234A:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000234A                 mov     eax, [ebp+var_4]
.text$mn:0000234D                 add     eax, 4
.text$mn:00002350                 mov     [ebp+var_8], eax
.text$mn:00002353
.text$mn:00002353 loc_2353:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00002353                 mov     eax, [ebp+var_8]
.text$mn:00002356                 mov     esp, ebp
.text$mn:00002358                 pop     ebp
.text$mn:00002359                 retn
.text$mn:00002359 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00002359
.text$mn:00002359 ; ---------------------------------------------------------------------------
.text$mn:0000235A                 align 4
.text$mn:0000235A _text$mn        ends
.text$mn:0000235A
.text$mn:0000235C ; ===========================================================================
.text$mn:0000235C
.text$mn:0000235C ; Segment type: Pure code
.text$mn:0000235C ; Segment permissions: Read/Execute
.text$mn:0000235C _text$mn        segment para public 'CODE' use32
.text$mn:0000235C                 assume cs:_text$mn
.text$mn:0000235C                 ;org 235Ch
.text$mn:0000235C ; COMDAT (pick any)
.text$mn:0000235C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000235C
.text$mn:0000235C ; =============== S U B R O U T I N E =======================================
.text$mn:0000235C
.text$mn:0000235C ; Attributes: bp-based frame
.text$mn:0000235C
.text$mn:0000235C ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:0000235C                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000235C ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:0000235C                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:0000235C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:0000235C
.text$mn:0000235C var_18          = byte ptr -18h
.text$mn:0000235C var_14          = dword ptr -14h
.text$mn:0000235C var_10          = dword ptr -10h
.text$mn:0000235C var_C           = dword ptr -0Ch
.text$mn:0000235C var_4           = dword ptr -4
.text$mn:0000235C
.text$mn:0000235C                 push    ebp
.text$mn:0000235D                 mov     ebp, esp
.text$mn:0000235F                 push    0FFFFFFFFh
.text$mn:00002361                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00002366                 mov     eax, large fs:0
.text$mn:0000236C                 push    eax
.text$mn:0000236D                 sub     esp, 0Ch
.text$mn:00002370                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002375                 xor     eax, ebp
.text$mn:00002377                 push    eax
.text$mn:00002378                 lea     eax, [ebp+var_C]
.text$mn:0000237B                 mov     large fs:0, eax
.text$mn:00002381                 mov     [ebp+var_14], ecx
.text$mn:00002384                 mov     eax, [ebp+var_14]
.text$mn:00002387                 cmp     dword ptr [eax], 0
.text$mn:0000238A                 jz      short loc_23E7
.text$mn:0000238C                 push    3               ; int
.text$mn:0000238E                 lea     ecx, [ebp+var_18] ; this
.text$mn:00002391                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00002396                 mov     [ebp+var_4], 0
.text$mn:0000239D                 mov     ecx, [ebp+var_14]
.text$mn:000023A0                 mov     edx, [ecx]
.text$mn:000023A2                 add     edx, 4
.text$mn:000023A5                 mov     [ebp+var_10], edx
.text$mn:000023A8                 jmp     short loc_23B7
.text$mn:000023AA ; ---------------------------------------------------------------------------
.text$mn:000023AA
.text$mn:000023AA loc_23AA:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:000023AA                 mov     eax, [ebp+var_10]
.text$mn:000023AD                 mov     ecx, [eax]
.text$mn:000023AF                 mov     edx, [ebp+var_10]
.text$mn:000023B2                 mov     eax, [ecx+4]
.text$mn:000023B5                 mov     [edx], eax
.text$mn:000023B7
.text$mn:000023B7 loc_23B7:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:000023B7                 mov     ecx, [ebp+var_10]
.text$mn:000023BA                 cmp     dword ptr [ecx], 0
.text$mn:000023BD                 jz      short loc_23CC
.text$mn:000023BF                 mov     edx, [ebp+var_10]
.text$mn:000023C2                 mov     eax, [edx]
.text$mn:000023C4                 mov     dword ptr [eax], 0
.text$mn:000023CA                 jmp     short loc_23AA
.text$mn:000023CC ; ---------------------------------------------------------------------------
.text$mn:000023CC
.text$mn:000023CC loc_23CC:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:000023CC                 mov     ecx, [ebp+var_14]
.text$mn:000023CF                 mov     edx, [ecx]
.text$mn:000023D1                 mov     dword ptr [edx+4], 0
.text$mn:000023D8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000023DF                 lea     ecx, [ebp+var_18] ; this
.text$mn:000023E2                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000023E7
.text$mn:000023E7 loc_23E7:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000023E7                 mov     ecx, [ebp+var_C]
.text$mn:000023EA                 mov     large fs:0, ecx
.text$mn:000023F1                 pop     ecx
.text$mn:000023F2                 mov     esp, ebp
.text$mn:000023F4                 pop     ebp
.text$mn:000023F5                 retn
.text$mn:000023F5 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000023F5
.text$mn:000023F5 ; ---------------------------------------------------------------------------
.text$mn:000023F6                 align 4
.text$mn:000023F6 _text$mn        ends
.text$mn:000023F6
.text$x:000023F8 ; ===========================================================================
.text$x:000023F8
.text$x:000023F8 ; Segment type: Pure code
.text$x:000023F8 ; Segment permissions: Read/Execute
.text$x:000023F8 _text$x         segment para public 'CODE' use32
.text$x:000023F8                 assume cs:_text$x
.text$x:000023F8                 ;org 23F8h
.text$x:000023F8 ; COMDAT (pick associative to section at 235C)
.text$x:000023F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000023F8
.text$x:000023F8 ; =============== S U B R O U T I N E =======================================
.text$x:000023F8
.text$x:000023F8
.text$x:000023F8 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000023F8                                         ; DATA XREF: .xdata$x:00002D68o
.text$x:000023F8                 lea     ecx, [ebp-18h]  ; this
.text$x:000023FB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000023FB __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000023FB
.text$x:00002400
.text$x:00002400 ; =============== S U B R O U T I N E =======================================
.text$x:00002400
.text$x:00002400
.text$x:00002400 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00002400                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00002400
.text$x:00002400 arg_4           = dword ptr  8
.text$x:00002400
.text$x:00002400                 mov     edx, [esp+arg_4]
.text$x:00002404                 lea     eax, [edx+0Ch]
.text$x:00002407                 mov     ecx, [edx-10h]
.text$x:0000240A                 xor     ecx, eax
.text$x:0000240C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002411                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00002416                 jmp     ___CxxFrameHandler3
.text$x:00002416 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00002416
.text$x:00002416 ; ---------------------------------------------------------------------------
.text$x:0000241B                 align 4
.text$x:0000241B _text$x         ends
.text$x:0000241B
.text$mn:0000241C ; ===========================================================================
.text$mn:0000241C
.text$mn:0000241C ; Segment type: Pure code
.text$mn:0000241C ; Segment permissions: Read/Execute
.text$mn:0000241C _text$mn        segment para public 'CODE' use32
.text$mn:0000241C                 assume cs:_text$mn
.text$mn:0000241C                 ;org 241Ch
.text$mn:0000241C ; COMDAT (pick any)
.text$mn:0000241C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000241C
.text$mn:0000241C ; =============== S U B R O U T I N E =======================================
.text$mn:0000241C
.text$mn:0000241C ; Attributes: bp-based frame
.text$mn:0000241C
.text$mn:0000241C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:0000241C                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:0000241C ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:0000241C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:0000241C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:0000241C
.text$mn:0000241C var_C           = dword ptr -0Ch
.text$mn:0000241C var_8           = dword ptr -8
.text$mn:0000241C var_2           = byte ptr -2
.text$mn:0000241C var_1           = byte ptr -1
.text$mn:0000241C arg_0           = byte ptr  8
.text$mn:0000241C Size            = dword ptr  0Ch
.text$mn:0000241C
.text$mn:0000241C                 push    ebp
.text$mn:0000241D                 mov     ebp, esp
.text$mn:0000241F                 sub     esp, 0Ch
.text$mn:00002422                 mov     [ebp+var_8], ecx
.text$mn:00002425                 movzx   eax, [ebp+arg_0]
.text$mn:00002429                 test    eax, eax
.text$mn:0000242B                 jnz     short loc_242F
.text$mn:0000242D                 jmp     short loc_24A2
.text$mn:0000242F ; ---------------------------------------------------------------------------
.text$mn:0000242F
.text$mn:0000242F loc_242F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000242F                 mov     ecx, [ebp+var_8]
.text$mn:00002432                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00002436                 jb      short loc_24A2
.text$mn:00002438                 mov     edx, [ebp+var_8]
.text$mn:0000243B                 mov     eax, [edx+4]
.text$mn:0000243E                 mov     [ebp+var_C], eax
.text$mn:00002441                 mov     ecx, [ebp+var_8]
.text$mn:00002444                 add     ecx, 4
.text$mn:00002447                 push    ecx
.text$mn:00002448                 lea     edx, [ebp+var_1]
.text$mn:0000244B                 push    edx
.text$mn:0000244C                 mov     ecx, [ebp+var_8]
.text$mn:0000244F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002454                 mov     ecx, eax
.text$mn:00002456                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000245B                 cmp     [ebp+Size], 0
.text$mn:0000245F                 jbe     short loc_2481
.text$mn:00002461                 mov     eax, [ebp+Size]
.text$mn:00002464                 push    eax             ; Size
.text$mn:00002465                 mov     ecx, [ebp+var_C]
.text$mn:00002468                 push    ecx
.text$mn:00002469                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000246E                 add     esp, 4
.text$mn:00002471                 push    eax             ; Src
.text$mn:00002472                 mov     edx, [ebp+var_8]
.text$mn:00002475                 add     edx, 4
.text$mn:00002478                 push    edx             ; Dst
.text$mn:00002479                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000247E                 add     esp, 0Ch
.text$mn:00002481
.text$mn:00002481 loc_2481:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00002481                 mov     eax, [ebp+var_8]
.text$mn:00002484                 mov     ecx, [eax+18h]
.text$mn:00002487                 add     ecx, 1
.text$mn:0000248A                 push    ecx             ; int
.text$mn:0000248B                 mov     edx, [ebp+var_C]
.text$mn:0000248E                 push    edx             ; void *
.text$mn:0000248F                 lea     eax, [ebp+var_2]
.text$mn:00002492                 push    eax
.text$mn:00002493                 mov     ecx, [ebp+var_8]
.text$mn:00002496                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000249B                 mov     ecx, eax
.text$mn:0000249D                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000024A2
.text$mn:000024A2 loc_24A2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000024A2                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000024A2                 mov     ecx, [ebp+var_8]
.text$mn:000024A5                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:000024AC                 mov     edx, [ebp+Size]
.text$mn:000024AF                 push    edx
.text$mn:000024B0                 mov     ecx, [ebp+var_8]
.text$mn:000024B3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000024B8                 mov     esp, ebp
.text$mn:000024BA                 pop     ebp
.text$mn:000024BB                 retn    8
.text$mn:000024BB ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:000024BB
.text$mn:000024BB ; ---------------------------------------------------------------------------
.text$mn:000024BE                 align 10h
.text$mn:000024BE _text$mn        ends
.text$mn:000024BE
.text$mn:000024C0 ; ===========================================================================
.text$mn:000024C0
.text$mn:000024C0 ; Segment type: Pure code
.text$mn:000024C0 ; Segment permissions: Read/Execute
.text$mn:000024C0 _text$mn        segment para public 'CODE' use32
.text$mn:000024C0                 assume cs:_text$mn
.text$mn:000024C0                 ;org 24C0h
.text$mn:000024C0 ; COMDAT (pick any)
.text$mn:000024C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024C0
.text$mn:000024C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000024C0
.text$mn:000024C0 ; Attributes: bp-based frame
.text$mn:000024C0
.text$mn:000024C0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:000024C0                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000024C0 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000024C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:000024C0
.text$mn:000024C0 var_4           = dword ptr -4
.text$mn:000024C0
.text$mn:000024C0                 push    ebp
.text$mn:000024C1                 mov     ebp, esp
.text$mn:000024C3                 push    ecx
.text$mn:000024C4                 mov     [ebp+var_4], ecx
.text$mn:000024C7                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000024CC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000024D1                 mov     esp, ebp
.text$mn:000024D3                 pop     ebp
.text$mn:000024D4                 retn
.text$mn:000024D4 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000024D4
.text$mn:000024D4 ; ---------------------------------------------------------------------------
.text$mn:000024D5                 align 4
.text$mn:000024D5 _text$mn        ends
.text$mn:000024D5
.text$mn:000024D8 ; ===========================================================================
.text$mn:000024D8
.text$mn:000024D8 ; Segment type: Pure code
.text$mn:000024D8 ; Segment permissions: Read/Execute
.text$mn:000024D8 _text$mn        segment para public 'CODE' use32
.text$mn:000024D8                 assume cs:_text$mn
.text$mn:000024D8                 ;org 24D8h
.text$mn:000024D8 ; COMDAT (pick any)
.text$mn:000024D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024D8
.text$mn:000024D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000024D8
.text$mn:000024D8 ; Attributes: bp-based frame
.text$mn:000024D8
.text$mn:000024D8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000024D8                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000024D8 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000024D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000024D8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:000024D8
.text$mn:000024D8 var_4           = dword ptr -4
.text$mn:000024D8
.text$mn:000024D8                 push    ebp
.text$mn:000024D9                 mov     ebp, esp
.text$mn:000024DB                 push    ecx
.text$mn:000024DC                 mov     [ebp+var_4], ecx
.text$mn:000024DF                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000024E4                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000024E9                 mov     esp, ebp
.text$mn:000024EB                 pop     ebp
.text$mn:000024EC                 retn
.text$mn:000024EC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000024EC
.text$mn:000024EC ; ---------------------------------------------------------------------------
.text$mn:000024ED                 align 10h
.text$mn:000024ED _text$mn        ends
.text$mn:000024ED
.text$mn:000024F0 ; ===========================================================================
.text$mn:000024F0
.text$mn:000024F0 ; Segment type: Pure code
.text$mn:000024F0 ; Segment permissions: Read/Execute
.text$mn:000024F0 _text$mn        segment para public 'CODE' use32
.text$mn:000024F0                 assume cs:_text$mn
.text$mn:000024F0                 ;org 24F0h
.text$mn:000024F0 ; COMDAT (pick any)
.text$mn:000024F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000024F0
.text$mn:000024F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000024F0
.text$mn:000024F0 ; Attributes: bp-based frame
.text$mn:000024F0
.text$mn:000024F0 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:000024F0                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:000024F0 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:000024F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:000024F0                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:000024F0
.text$mn:000024F0 var_4           = dword ptr -4
.text$mn:000024F0 arg_0           = dword ptr  8
.text$mn:000024F0
.text$mn:000024F0                 push    ebp
.text$mn:000024F1                 mov     ebp, esp
.text$mn:000024F3                 push    ecx
.text$mn:000024F4                 mov     [ebp+var_4], ecx
.text$mn:000024F7                 mov     eax, [ebp+arg_0]
.text$mn:000024FA                 push    eax
.text$mn:000024FB                 mov     ecx, [ebp+var_4]
.text$mn:000024FE                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00002503                 mov     esp, ebp
.text$mn:00002505                 pop     ebp
.text$mn:00002506                 retn    4
.text$mn:00002506 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00002506
.text$mn:00002506 ; ---------------------------------------------------------------------------
.text$mn:00002509                 align 4
.text$mn:00002509 _text$mn        ends
.text$mn:00002509
.text$mn:0000250C ; ===========================================================================
.text$mn:0000250C
.text$mn:0000250C ; Segment type: Pure code
.text$mn:0000250C ; Segment permissions: Read/Execute
.text$mn:0000250C _text$mn        segment para public 'CODE' use32
.text$mn:0000250C                 assume cs:_text$mn
.text$mn:0000250C                 ;org 250Ch
.text$mn:0000250C ; COMDAT (pick any)
.text$mn:0000250C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000250C
.text$mn:0000250C ; =============== S U B R O U T I N E =======================================
.text$mn:0000250C
.text$mn:0000250C ; Attributes: bp-based frame
.text$mn:0000250C
.text$mn:0000250C ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:0000250C                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:0000250C ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:0000250C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:0000250C
.text$mn:0000250C var_4           = dword ptr -4
.text$mn:0000250C arg_0           = dword ptr  8
.text$mn:0000250C
.text$mn:0000250C                 push    ebp
.text$mn:0000250D                 mov     ebp, esp
.text$mn:0000250F                 push    ecx
.text$mn:00002510                 mov     [ebp+var_4], ecx
.text$mn:00002513                 push    0
.text$mn:00002515                 mov     eax, [ebp+arg_0]
.text$mn:00002518                 push    eax
.text$mn:00002519                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:0000251E                 add     esp, 8
.text$mn:00002521                 mov     esp, ebp
.text$mn:00002523                 pop     ebp
.text$mn:00002524                 retn    4
.text$mn:00002524 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00002524
.text$mn:00002524 ; ---------------------------------------------------------------------------
.text$mn:00002527                 align 4
.text$mn:00002527 _text$mn        ends
.text$mn:00002527
.text$mn:00002528 ; ===========================================================================
.text$mn:00002528
.text$mn:00002528 ; Segment type: Pure code
.text$mn:00002528 ; Segment permissions: Read/Execute
.text$mn:00002528 _text$mn        segment para public 'CODE' use32
.text$mn:00002528                 assume cs:_text$mn
.text$mn:00002528                 ;org 2528h
.text$mn:00002528 ; COMDAT (pick any)
.text$mn:00002528                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002528
.text$mn:00002528 ; =============== S U B R O U T I N E =======================================
.text$mn:00002528
.text$mn:00002528 ; Attributes: bp-based frame
.text$mn:00002528
.text$mn:00002528 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00002528                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00002528 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00002528                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00002528
.text$mn:00002528 var_4           = dword ptr -4
.text$mn:00002528 arg_0           = dword ptr  8
.text$mn:00002528
.text$mn:00002528                 push    ebp
.text$mn:00002529                 mov     ebp, esp
.text$mn:0000252B                 push    ecx
.text$mn:0000252C                 mov     [ebp+var_4], ecx
.text$mn:0000252F                 push    0
.text$mn:00002531                 mov     eax, [ebp+arg_0]
.text$mn:00002534                 push    eax
.text$mn:00002535                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000253A                 add     esp, 8
.text$mn:0000253D                 mov     esp, ebp
.text$mn:0000253F                 pop     ebp
.text$mn:00002540                 retn    4
.text$mn:00002540 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00002540
.text$mn:00002540 ; ---------------------------------------------------------------------------
.text$mn:00002543                 align 4
.text$mn:00002543 _text$mn        ends
.text$mn:00002543
.text$mn:00002544 ; ===========================================================================
.text$mn:00002544
.text$mn:00002544 ; Segment type: Pure code
.text$mn:00002544 ; Segment permissions: Read/Execute
.text$mn:00002544 _text$mn        segment para public 'CODE' use32
.text$mn:00002544                 assume cs:_text$mn
.text$mn:00002544                 ;org 2544h
.text$mn:00002544 ; COMDAT (pick any)
.text$mn:00002544                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002544
.text$mn:00002544 ; =============== S U B R O U T I N E =======================================
.text$mn:00002544
.text$mn:00002544 ; Attributes: bp-based frame
.text$mn:00002544
.text$mn:00002544 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00002544                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00002544 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00002544                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00002544
.text$mn:00002544 Size            = dword ptr -8
.text$mn:00002544 var_4           = dword ptr -4
.text$mn:00002544 arg_0           = dword ptr  8
.text$mn:00002544 arg_4           = dword ptr  0Ch
.text$mn:00002544 arg_8           = dword ptr  10h
.text$mn:00002544
.text$mn:00002544                 push    ebp
.text$mn:00002545                 mov     ebp, esp
.text$mn:00002547                 sub     esp, 8
.text$mn:0000254A                 mov     [ebp+var_4], ecx
.text$mn:0000254D                 mov     ecx, [ebp+arg_0]
.text$mn:00002550                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00002555                 cmp     eax, [ebp+arg_4]
.text$mn:00002558                 jnb     short loc_2562
.text$mn:0000255A                 mov     ecx, [ebp+var_4]
.text$mn:0000255D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002562
.text$mn:00002562 loc_2562:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00002562                 mov     ecx, [ebp+arg_0]
.text$mn:00002565                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000256A                 sub     eax, [ebp+arg_4]
.text$mn:0000256D                 mov     [ebp+Size], eax
.text$mn:00002570                 mov     eax, [ebp+arg_8]
.text$mn:00002573                 cmp     eax, [ebp+Size]
.text$mn:00002576                 jnb     short loc_257E
.text$mn:00002578                 mov     ecx, [ebp+arg_8]
.text$mn:0000257B                 mov     [ebp+Size], ecx
.text$mn:0000257E
.text$mn:0000257E loc_257E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000257E                 mov     edx, [ebp+var_4]
.text$mn:00002581                 cmp     edx, [ebp+arg_0]
.text$mn:00002584                 jnz     short loc_25A5
.text$mn:00002586                 mov     eax, [ebp+arg_4]
.text$mn:00002589                 add     eax, [ebp+Size]
.text$mn:0000258C                 push    eax
.text$mn:0000258D                 mov     ecx, [ebp+var_4]
.text$mn:00002590                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00002595                 mov     ecx, [ebp+arg_4]
.text$mn:00002598                 push    ecx
.text$mn:00002599                 push    0
.text$mn:0000259B                 mov     ecx, [ebp+var_4]
.text$mn:0000259E                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000025A3                 jmp     short loc_25E7
.text$mn:000025A5 ; ---------------------------------------------------------------------------
.text$mn:000025A5
.text$mn:000025A5 loc_25A5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000025A5                 push    0
.text$mn:000025A7                 mov     edx, [ebp+Size]
.text$mn:000025AA                 push    edx
.text$mn:000025AB                 mov     ecx, [ebp+var_4]
.text$mn:000025AE                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000025B3                 movzx   eax, al
.text$mn:000025B6                 test    eax, eax
.text$mn:000025B8                 jz      short loc_25E7
.text$mn:000025BA                 mov     ecx, [ebp+Size]
.text$mn:000025BD                 push    ecx             ; Size
.text$mn:000025BE                 mov     ecx, [ebp+arg_0]
.text$mn:000025C1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000025C6                 add     eax, [ebp+arg_4]
.text$mn:000025C9                 push    eax             ; Src
.text$mn:000025CA                 mov     ecx, [ebp+var_4]
.text$mn:000025CD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000025D2                 push    eax             ; Dst
.text$mn:000025D3                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000025D8                 add     esp, 0Ch
.text$mn:000025DB                 mov     edx, [ebp+Size]
.text$mn:000025DE                 push    edx
.text$mn:000025DF                 mov     ecx, [ebp+var_4]
.text$mn:000025E2                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000025E7
.text$mn:000025E7 loc_25E7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000025E7                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000025E7                 mov     eax, [ebp+var_4]
.text$mn:000025EA                 mov     esp, ebp
.text$mn:000025EC                 pop     ebp
.text$mn:000025ED                 retn    0Ch
.text$mn:000025ED ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000025ED
.text$mn:000025ED _text$mn        ends
.text$mn:000025ED
.text$mn:000025F0 ; ===========================================================================
.text$mn:000025F0
.text$mn:000025F0 ; Segment type: Pure code
.text$mn:000025F0 ; Segment permissions: Read/Execute
.text$mn:000025F0 _text$mn        segment para public 'CODE' use32
.text$mn:000025F0                 assume cs:_text$mn
.text$mn:000025F0                 ;org 25F0h
.text$mn:000025F0 ; COMDAT (pick any)
.text$mn:000025F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025F0
.text$mn:000025F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025F0
.text$mn:000025F0 ; Attributes: bp-based frame
.text$mn:000025F0
.text$mn:000025F0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:000025F0                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:000025F0 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:000025F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:000025F0
.text$mn:000025F0 var_4           = dword ptr -4
.text$mn:000025F0 Str             = dword ptr  8
.text$mn:000025F0
.text$mn:000025F0                 push    ebp
.text$mn:000025F1                 mov     ebp, esp
.text$mn:000025F3                 push    ecx
.text$mn:000025F4                 mov     [ebp+var_4], ecx
.text$mn:000025F7                 push    490h            ; unsigned int
.text$mn:000025FC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002601                 mov     eax, [ebp+Str]
.text$mn:00002604                 push    eax             ; int
.text$mn:00002605                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000260A                 add     esp, 0Ch
.text$mn:0000260D                 mov     ecx, [ebp+Str]
.text$mn:00002610                 push    ecx             ; Str
.text$mn:00002611                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00002616                 add     esp, 4
.text$mn:00002619                 push    eax             ; Size
.text$mn:0000261A                 mov     edx, [ebp+Str]
.text$mn:0000261D                 push    edx             ; Src
.text$mn:0000261E                 mov     ecx, [ebp+var_4]
.text$mn:00002621                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00002626                 mov     esp, ebp
.text$mn:00002628                 pop     ebp
.text$mn:00002629                 retn    4
.text$mn:00002629 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00002629
.text$mn:00002629 _text$mn        ends
.text$mn:00002629
.text$mn:0000262C ; ===========================================================================
.text$mn:0000262C
.text$mn:0000262C ; Segment type: Pure code
.text$mn:0000262C ; Segment permissions: Read/Execute
.text$mn:0000262C _text$mn        segment para public 'CODE' use32
.text$mn:0000262C                 assume cs:_text$mn
.text$mn:0000262C                 ;org 262Ch
.text$mn:0000262C ; COMDAT (pick any)
.text$mn:0000262C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000262C
.text$mn:0000262C ; =============== S U B R O U T I N E =======================================
.text$mn:0000262C
.text$mn:0000262C ; Attributes: bp-based frame
.text$mn:0000262C
.text$mn:0000262C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:0000262C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:0000262C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:0000262C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:0000262C
.text$mn:0000262C var_4           = dword ptr -4
.text$mn:0000262C Src             = dword ptr  8
.text$mn:0000262C Size            = dword ptr  0Ch
.text$mn:0000262C
.text$mn:0000262C                 push    ebp
.text$mn:0000262D                 mov     ebp, esp
.text$mn:0000262F                 push    ecx
.text$mn:00002630                 mov     [ebp+var_4], ecx
.text$mn:00002633                 cmp     [ebp+Size], 0
.text$mn:00002637                 jz      short loc_264F
.text$mn:00002639                 push    47Fh            ; unsigned int
.text$mn:0000263E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002643                 mov     eax, [ebp+Src]
.text$mn:00002646                 push    eax             ; int
.text$mn:00002647                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000264C                 add     esp, 0Ch
.text$mn:0000264F
.text$mn:0000264F loc_264F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000264F                 mov     ecx, [ebp+Src]
.text$mn:00002652                 push    ecx
.text$mn:00002653                 mov     ecx, [ebp+var_4]
.text$mn:00002656                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000265B                 movzx   edx, al
.text$mn:0000265E                 test    edx, edx
.text$mn:00002660                 jz      short loc_2682
.text$mn:00002662                 mov     eax, [ebp+Size]
.text$mn:00002665                 push    eax
.text$mn:00002666                 mov     ecx, [ebp+var_4]
.text$mn:00002669                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000266E                 mov     ecx, [ebp+Src]
.text$mn:00002671                 sub     ecx, eax
.text$mn:00002673                 push    ecx
.text$mn:00002674                 mov     edx, [ebp+var_4]
.text$mn:00002677                 push    edx
.text$mn:00002678                 mov     ecx, [ebp+var_4]
.text$mn:0000267B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00002680                 jmp     short loc_26BF
.text$mn:00002682 ; ---------------------------------------------------------------------------
.text$mn:00002682
.text$mn:00002682 loc_2682:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00002682                 push    0
.text$mn:00002684                 mov     eax, [ebp+Size]
.text$mn:00002687                 push    eax
.text$mn:00002688                 mov     ecx, [ebp+var_4]
.text$mn:0000268B                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00002690                 movzx   ecx, al
.text$mn:00002693                 test    ecx, ecx
.text$mn:00002695                 jz      short loc_26BC
.text$mn:00002697                 mov     edx, [ebp+Size]
.text$mn:0000269A                 push    edx             ; Size
.text$mn:0000269B                 mov     eax, [ebp+Src]
.text$mn:0000269E                 push    eax             ; Src
.text$mn:0000269F                 mov     ecx, [ebp+var_4]
.text$mn:000026A2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000026A7                 push    eax             ; Dst
.text$mn:000026A8                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000026AD                 add     esp, 0Ch
.text$mn:000026B0                 mov     ecx, [ebp+Size]
.text$mn:000026B3                 push    ecx
.text$mn:000026B4                 mov     ecx, [ebp+var_4]
.text$mn:000026B7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000026BC
.text$mn:000026BC loc_26BC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:000026BC                 mov     eax, [ebp+var_4]
.text$mn:000026BF
.text$mn:000026BF loc_26BF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:000026BF                 mov     esp, ebp
.text$mn:000026C1                 pop     ebp
.text$mn:000026C2                 retn    8
.text$mn:000026C2 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:000026C2
.text$mn:000026C2 ; ---------------------------------------------------------------------------
.text$mn:000026C5                 align 4
.text$mn:000026C5 _text$mn        ends
.text$mn:000026C5
.text$mn:000026C8 ; ===========================================================================
.text$mn:000026C8
.text$mn:000026C8 ; Segment type: Pure code
.text$mn:000026C8 ; Segment permissions: Read/Execute
.text$mn:000026C8 _text$mn        segment para public 'CODE' use32
.text$mn:000026C8                 assume cs:_text$mn
.text$mn:000026C8                 ;org 26C8h
.text$mn:000026C8 ; COMDAT (pick any)
.text$mn:000026C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026C8
.text$mn:000026C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000026C8
.text$mn:000026C8 ; Attributes: bp-based frame
.text$mn:000026C8
.text$mn:000026C8 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:000026C8                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:000026C8 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:000026C8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:000026C8
.text$mn:000026C8 arg_0           = dword ptr  8
.text$mn:000026C8 arg_4           = dword ptr  0Ch
.text$mn:000026C8
.text$mn:000026C8                 push    ebp
.text$mn:000026C9                 mov     ebp, esp
.text$mn:000026CB                 mov     eax, [ebp+arg_0]
.text$mn:000026CE                 mov     ecx, [ebp+arg_4]
.text$mn:000026D1                 mov     dl, [ecx]
.text$mn:000026D3                 mov     [eax], dl
.text$mn:000026D5                 pop     ebp
.text$mn:000026D6                 retn
.text$mn:000026D6 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:000026D6
.text$mn:000026D6 ; ---------------------------------------------------------------------------
.text$mn:000026D7                 align 4
.text$mn:000026D7 _text$mn        ends
.text$mn:000026D7
.text$mn:000026D8 ; ===========================================================================
.text$mn:000026D8
.text$mn:000026D8 ; Segment type: Pure code
.text$mn:000026D8 ; Segment permissions: Read/Execute
.text$mn:000026D8 _text$mn        segment para public 'CODE' use32
.text$mn:000026D8                 assume cs:_text$mn
.text$mn:000026D8                 ;org 26D8h
.text$mn:000026D8 ; COMDAT (pick any)
.text$mn:000026D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026D8
.text$mn:000026D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000026D8
.text$mn:000026D8 ; Attributes: bp-based frame
.text$mn:000026D8
.text$mn:000026D8 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:000026D8                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:000026D8 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000026D8                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:000026D8
.text$mn:000026D8 var_4           = dword ptr -4
.text$mn:000026D8
.text$mn:000026D8                 push    ebp
.text$mn:000026D9                 mov     ebp, esp
.text$mn:000026DB                 push    ecx
.text$mn:000026DC                 mov     [ebp+var_4], ecx
.text$mn:000026DF                 mov     eax, [ebp+var_4]
.text$mn:000026E2                 mov     eax, [eax+4]
.text$mn:000026E5                 mov     esp, ebp
.text$mn:000026E7                 pop     ebp
.text$mn:000026E8                 retn
.text$mn:000026E8 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:000026E8
.text$mn:000026E8 ; ---------------------------------------------------------------------------
.text$mn:000026E9                 align 4
.text$mn:000026E9 _text$mn        ends
.text$mn:000026E9
.text$mn:000026EC ; ===========================================================================
.text$mn:000026EC
.text$mn:000026EC ; Segment type: Pure code
.text$mn:000026EC ; Segment permissions: Read/Execute
.text$mn:000026EC _text$mn        segment para public 'CODE' use32
.text$mn:000026EC                 assume cs:_text$mn
.text$mn:000026EC                 ;org 26ECh
.text$mn:000026EC ; COMDAT (pick any)
.text$mn:000026EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026EC
.text$mn:000026EC ; =============== S U B R O U T I N E =======================================
.text$mn:000026EC
.text$mn:000026EC ; Attributes: bp-based frame
.text$mn:000026EC
.text$mn:000026EC ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:000026EC                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:000026EC ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000026EC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:000026EC                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:000026EC
.text$mn:000026EC var_4           = dword ptr -4
.text$mn:000026EC
.text$mn:000026EC                 push    ebp
.text$mn:000026ED                 mov     ebp, esp
.text$mn:000026EF                 push    ecx
.text$mn:000026F0                 mov     [ebp+var_4], ecx
.text$mn:000026F3                 mov     eax, [ebp+var_4]
.text$mn:000026F6                 mov     eax, [eax+4]
.text$mn:000026F9                 mov     esp, ebp
.text$mn:000026FB                 pop     ebp
.text$mn:000026FC                 retn
.text$mn:000026FC ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:000026FC
.text$mn:000026FC ; ---------------------------------------------------------------------------
.text$mn:000026FD                 align 10h
.text$mn:000026FD _text$mn        ends
.text$mn:000026FD
.text$mn:00002700 ; ===========================================================================
.text$mn:00002700
.text$mn:00002700 ; Segment type: Pure code
.text$mn:00002700 ; Segment permissions: Read/Execute
.text$mn:00002700 _text$mn        segment para public 'CODE' use32
.text$mn:00002700                 assume cs:_text$mn
.text$mn:00002700                 ;org 2700h
.text$mn:00002700 ; COMDAT (pick any)
.text$mn:00002700                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002700
.text$mn:00002700 ; =============== S U B R O U T I N E =======================================
.text$mn:00002700
.text$mn:00002700 ; Attributes: bp-based frame
.text$mn:00002700
.text$mn:00002700 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00002700                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002700 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00002700                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00002700
.text$mn:00002700 var_4           = dword ptr -4
.text$mn:00002700 Dst             = dword ptr  8
.text$mn:00002700 Src             = dword ptr  0Ch
.text$mn:00002700 Size            = dword ptr  10h
.text$mn:00002700
.text$mn:00002700                 push    ebp
.text$mn:00002701                 mov     ebp, esp
.text$mn:00002703                 push    ecx
.text$mn:00002704                 cmp     [ebp+Size], 0
.text$mn:00002708                 jnz     short loc_2712
.text$mn:0000270A                 mov     eax, [ebp+Dst]
.text$mn:0000270D                 mov     [ebp+var_4], eax
.text$mn:00002710                 jmp     short loc_2729
.text$mn:00002712 ; ---------------------------------------------------------------------------
.text$mn:00002712
.text$mn:00002712 loc_2712:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00002712                 mov     ecx, [ebp+Size]
.text$mn:00002715                 push    ecx             ; Size
.text$mn:00002716                 mov     edx, [ebp+Src]
.text$mn:00002719                 push    edx             ; Src
.text$mn:0000271A                 mov     eax, [ebp+Dst]
.text$mn:0000271D                 push    eax             ; Dst
.text$mn:0000271E                 call    _memcpy
.text$mn:00002723                 add     esp, 0Ch
.text$mn:00002726                 mov     [ebp+var_4], eax
.text$mn:00002729
.text$mn:00002729 loc_2729:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00002729                 mov     eax, [ebp+var_4]
.text$mn:0000272C                 mov     esp, ebp
.text$mn:0000272E                 pop     ebp
.text$mn:0000272F                 retn
.text$mn:0000272F ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000272F
.text$mn:0000272F _text$mn        ends
.text$mn:0000272F
.text$mn:00002730 ; ===========================================================================
.text$mn:00002730
.text$mn:00002730 ; Segment type: Pure code
.text$mn:00002730 ; Segment permissions: Read/Execute
.text$mn:00002730 _text$mn        segment para public 'CODE' use32
.text$mn:00002730                 assume cs:_text$mn
.text$mn:00002730                 ;org 2730h
.text$mn:00002730 ; COMDAT (pick any)
.text$mn:00002730                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002730
.text$mn:00002730 ; =============== S U B R O U T I N E =======================================
.text$mn:00002730
.text$mn:00002730 ; Attributes: bp-based frame
.text$mn:00002730
.text$mn:00002730 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00002730                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00002730 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00002730                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00002730
.text$mn:00002730 var_4           = dword ptr -4
.text$mn:00002730 arg_0           = dword ptr  8
.text$mn:00002730 arg_4           = dword ptr  0Ch
.text$mn:00002730
.text$mn:00002730                 push    ebp
.text$mn:00002731                 mov     ebp, esp
.text$mn:00002733                 push    ecx
.text$mn:00002734                 mov     [ebp+var_4], ecx
.text$mn:00002737                 mov     eax, [ebp+arg_4]
.text$mn:0000273A                 push    eax             ; int
.text$mn:0000273B                 mov     ecx, [ebp+arg_0]
.text$mn:0000273E                 push    ecx             ; void *
.text$mn:0000273F                 mov     ecx, [ebp+var_4]
.text$mn:00002742                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00002747                 mov     esp, ebp
.text$mn:00002749                 pop     ebp
.text$mn:0000274A                 retn    8
.text$mn:0000274A ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000274A
.text$mn:0000274A ; ---------------------------------------------------------------------------
.text$mn:0000274D                 align 10h
.text$mn:0000274D _text$mn        ends
.text$mn:0000274D
.text$mn:00002750 ; ===========================================================================
.text$mn:00002750
.text$mn:00002750 ; Segment type: Pure code
.text$mn:00002750 ; Segment permissions: Read/Execute
.text$mn:00002750 _text$mn        segment para public 'CODE' use32
.text$mn:00002750                 assume cs:_text$mn
.text$mn:00002750                 ;org 2750h
.text$mn:00002750 ; COMDAT (pick any)
.text$mn:00002750                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002750
.text$mn:00002750 ; =============== S U B R O U T I N E =======================================
.text$mn:00002750
.text$mn:00002750 ; Attributes: bp-based frame
.text$mn:00002750
.text$mn:00002750 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00002750                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00002750 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00002750                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00002750
.text$mn:00002750 var_4           = dword ptr -4
.text$mn:00002750 arg_0           = dword ptr  8
.text$mn:00002750
.text$mn:00002750                 push    ebp
.text$mn:00002751                 mov     ebp, esp
.text$mn:00002753                 push    ecx
.text$mn:00002754                 mov     [ebp+var_4], ecx
.text$mn:00002757                 mov     eax, [ebp+arg_0]
.text$mn:0000275A                 push    eax             ; void *
.text$mn:0000275B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002760                 add     esp, 4
.text$mn:00002763                 mov     esp, ebp
.text$mn:00002765                 pop     ebp
.text$mn:00002766                 retn    8
.text$mn:00002766 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00002766
.text$mn:00002766 ; ---------------------------------------------------------------------------
.text$mn:00002769                 align 4
.text$mn:00002769 _text$mn        ends
.text$mn:00002769
.text$mn:0000276C ; ===========================================================================
.text$mn:0000276C
.text$mn:0000276C ; Segment type: Pure code
.text$mn:0000276C ; Segment permissions: Read/Execute
.text$mn:0000276C _text$mn        segment para public 'CODE' use32
.text$mn:0000276C                 assume cs:_text$mn
.text$mn:0000276C                 ;org 276Ch
.text$mn:0000276C ; COMDAT (pick any)
.text$mn:0000276C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000276C
.text$mn:0000276C ; =============== S U B R O U T I N E =======================================
.text$mn:0000276C
.text$mn:0000276C ; Attributes: bp-based frame
.text$mn:0000276C
.text$mn:0000276C ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:0000276C                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:0000276C ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:0000276C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:0000276C
.text$mn:0000276C var_4           = dword ptr -4
.text$mn:0000276C arg_0           = dword ptr  8
.text$mn:0000276C
.text$mn:0000276C                 push    ebp
.text$mn:0000276D                 mov     ebp, esp
.text$mn:0000276F                 push    ecx
.text$mn:00002770                 mov     [ebp+var_4], ecx
.text$mn:00002773                 mov     eax, [ebp+arg_0]
.text$mn:00002776                 push    eax             ; void *
.text$mn:00002777                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000277C                 add     esp, 4
.text$mn:0000277F                 mov     esp, ebp
.text$mn:00002781                 pop     ebp
.text$mn:00002782                 retn    8
.text$mn:00002782 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00002782
.text$mn:00002782 ; ---------------------------------------------------------------------------
.text$mn:00002785                 align 4
.text$mn:00002785 _text$mn        ends
.text$mn:00002785
.text$mn:00002788 ; ===========================================================================
.text$mn:00002788
.text$mn:00002788 ; Segment type: Pure code
.text$mn:00002788 ; Segment permissions: Read/Execute
.text$mn:00002788 _text$mn        segment para public 'CODE' use32
.text$mn:00002788                 assume cs:_text$mn
.text$mn:00002788                 ;org 2788h
.text$mn:00002788 ; COMDAT (pick any)
.text$mn:00002788                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002788
.text$mn:00002788 ; =============== S U B R O U T I N E =======================================
.text$mn:00002788
.text$mn:00002788 ; Attributes: bp-based frame
.text$mn:00002788
.text$mn:00002788 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00002788                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002788 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002788                                         ; DATA XREF: .rdata:000031ACo
.text$mn:00002788
.text$mn:00002788 var_4           = dword ptr -4
.text$mn:00002788 arg_0           = dword ptr  8
.text$mn:00002788 arg_4           = dword ptr  0Ch
.text$mn:00002788
.text$mn:00002788                 push    ebp
.text$mn:00002789                 mov     ebp, esp
.text$mn:0000278B                 push    ecx
.text$mn:0000278C                 mov     [ebp+var_4], ecx
.text$mn:0000278F                 mov     eax, [ebp+arg_4]
.text$mn:00002792                 push    eax             ; int
.text$mn:00002793                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002798                 add     esp, 4
.text$mn:0000279B                 test    eax, eax
.text$mn:0000279D                 jz      short loc_27B8
.text$mn:0000279F                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:000027A4                 push    eax             ; struct std::error_category *
.text$mn:000027A5                 mov     ecx, [ebp+arg_4]
.text$mn:000027A8                 push    ecx             ; int
.text$mn:000027A9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000027AC                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000027B1                 mov     eax, [ebp+arg_0]
.text$mn:000027B4                 jmp     short loc_27CD
.text$mn:000027B6 ; ---------------------------------------------------------------------------
.text$mn:000027B6                 jmp     short loc_27CD
.text$mn:000027B8 ; ---------------------------------------------------------------------------
.text$mn:000027B8
.text$mn:000027B8 loc_27B8:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:000027B8                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000027BD                 push    eax             ; struct std::error_category *
.text$mn:000027BE                 mov     edx, [ebp+arg_4]
.text$mn:000027C1                 push    edx             ; int
.text$mn:000027C2                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000027C5                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000027CA                 mov     eax, [ebp+arg_0]
.text$mn:000027CD
.text$mn:000027CD loc_27CD:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:000027CD                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:000027CD                 mov     esp, ebp
.text$mn:000027CF                 pop     ebp
.text$mn:000027D0                 retn    8
.text$mn:000027D0 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000027D0
.text$mn:000027D0 ; ---------------------------------------------------------------------------
.text$mn:000027D3                 align 4
.text$mn:000027D3 _text$mn        ends
.text$mn:000027D3
.text$mn:000027D4 ; ===========================================================================
.text$mn:000027D4
.text$mn:000027D4 ; Segment type: Pure code
.text$mn:000027D4 ; Segment permissions: Read/Execute
.text$mn:000027D4 _text$mn        segment para public 'CODE' use32
.text$mn:000027D4                 assume cs:_text$mn
.text$mn:000027D4                 ;org 27D4h
.text$mn:000027D4 ; COMDAT (pick any)
.text$mn:000027D4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027D4
.text$mn:000027D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027D4
.text$mn:000027D4 ; Attributes: bp-based frame
.text$mn:000027D4
.text$mn:000027D4 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:000027D4                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000027D4 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000027D4                                         ; DATA XREF: .rdata:0000311Co
.text$mn:000027D4                                         ; .rdata:00003138o ...
.text$mn:000027D4
.text$mn:000027D4 var_4           = dword ptr -4
.text$mn:000027D4 arg_0           = dword ptr  8
.text$mn:000027D4 arg_4           = dword ptr  0Ch
.text$mn:000027D4
.text$mn:000027D4                 push    ebp
.text$mn:000027D5                 mov     ebp, esp
.text$mn:000027D7                 push    ecx
.text$mn:000027D8                 mov     [ebp+var_4], ecx
.text$mn:000027DB                 mov     eax, [ebp+var_4]
.text$mn:000027DE                 push    eax             ; struct std::error_category *
.text$mn:000027DF                 mov     ecx, [ebp+arg_4]
.text$mn:000027E2                 push    ecx             ; int
.text$mn:000027E3                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000027E6                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000027EB                 mov     eax, [ebp+arg_0]
.text$mn:000027EE                 mov     esp, ebp
.text$mn:000027F0                 pop     ebp
.text$mn:000027F1                 retn    8
.text$mn:000027F1 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000027F1
.text$mn:000027F1 _text$mn        ends
.text$mn:000027F1
.text$mn:000027F4 ; ===========================================================================
.text$mn:000027F4
.text$mn:000027F4 ; Segment type: Pure code
.text$mn:000027F4 ; Segment permissions: Read/Execute
.text$mn:000027F4 _text$mn        segment para public 'CODE' use32
.text$mn:000027F4                 assume cs:_text$mn
.text$mn:000027F4                 ;org 27F4h
.text$mn:000027F4 ; COMDAT (pick any)
.text$mn:000027F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027F4
.text$mn:000027F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027F4
.text$mn:000027F4 ; Attributes: bp-based frame
.text$mn:000027F4
.text$mn:000027F4 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:000027F4                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:000027F4 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:000027F4                                         ; DATA XREF: .rdata:00003120o
.text$mn:000027F4                                         ; .rdata:0000313Co ...
.text$mn:000027F4
.text$mn:000027F4 var_8           = dword ptr -8
.text$mn:000027F4 var_4           = dword ptr -4
.text$mn:000027F4 arg_0           = dword ptr  8
.text$mn:000027F4 arg_4           = dword ptr  0Ch
.text$mn:000027F4
.text$mn:000027F4                 push    ebp
.text$mn:000027F5                 mov     ebp, esp
.text$mn:000027F7                 sub     esp, 8
.text$mn:000027FA                 mov     [ebp+var_8], ecx
.text$mn:000027FD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002800                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00002805                 push    eax
.text$mn:00002806                 mov     ecx, [ebp+var_8]
.text$mn:00002809                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000280E                 movzx   eax, al
.text$mn:00002811                 test    eax, eax
.text$mn:00002813                 jz      short loc_282B
.text$mn:00002815                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002818                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:0000281D                 cmp     eax, [ebp+arg_4]
.text$mn:00002820                 jnz     short loc_282B
.text$mn:00002822                 mov     [ebp+var_4], 1
.text$mn:00002829                 jmp     short loc_2832
.text$mn:0000282B ; ---------------------------------------------------------------------------
.text$mn:0000282B
.text$mn:0000282B loc_282B:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000282B                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000282B                 mov     [ebp+var_4], 0
.text$mn:00002832
.text$mn:00002832 loc_2832:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00002832                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002835                 mov     esp, ebp
.text$mn:00002837                 pop     ebp
.text$mn:00002838                 retn    8
.text$mn:00002838 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00002838
.text$mn:00002838 ; ---------------------------------------------------------------------------
.text$mn:0000283B                 align 4
.text$mn:0000283B _text$mn        ends
.text$mn:0000283B
.text$mn:0000283C ; ===========================================================================
.text$mn:0000283C
.text$mn:0000283C ; Segment type: Pure code
.text$mn:0000283C ; Segment permissions: Read/Execute
.text$mn:0000283C _text$mn        segment para public 'CODE' use32
.text$mn:0000283C                 assume cs:_text$mn
.text$mn:0000283C                 ;org 283Ch
.text$mn:0000283C ; COMDAT (pick any)
.text$mn:0000283C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000283C
.text$mn:0000283C ; =============== S U B R O U T I N E =======================================
.text$mn:0000283C
.text$mn:0000283C ; Attributes: bp-based frame
.text$mn:0000283C
.text$mn:0000283C ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:0000283C                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:0000283C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:0000283C                                         ; DATA XREF: .rdata:00003124o
.text$mn:0000283C                                         ; .rdata:00003140o ...
.text$mn:0000283C
.text$mn:0000283C var_C           = byte ptr -0Ch
.text$mn:0000283C var_4           = dword ptr -4
.text$mn:0000283C arg_0           = dword ptr  8
.text$mn:0000283C arg_4           = dword ptr  0Ch
.text$mn:0000283C
.text$mn:0000283C                 push    ebp
.text$mn:0000283D                 mov     ebp, esp
.text$mn:0000283F                 sub     esp, 0Ch
.text$mn:00002842                 mov     [ebp+var_4], ecx
.text$mn:00002845                 mov     eax, [ebp+arg_4]
.text$mn:00002848                 push    eax             ; std::error_condition *
.text$mn:00002849                 mov     ecx, [ebp+arg_0]
.text$mn:0000284C                 push    ecx
.text$mn:0000284D                 lea     edx, [ebp+var_C]
.text$mn:00002850                 push    edx
.text$mn:00002851                 mov     eax, [ebp+var_4]
.text$mn:00002854                 mov     edx, [eax]
.text$mn:00002856                 mov     ecx, [ebp+var_4]
.text$mn:00002859                 mov     eax, [edx+0Ch]
.text$mn:0000285C                 call    eax
.text$mn:0000285E                 mov     ecx, eax
.text$mn:00002860                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00002865                 mov     esp, ebp
.text$mn:00002867                 pop     ebp
.text$mn:00002868                 retn    8
.text$mn:00002868 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00002868
.text$mn:00002868 ; ---------------------------------------------------------------------------
.text$mn:0000286B                 align 4
.text$mn:0000286B _text$mn        ends
.text$mn:0000286B
.text$mn:0000286C ; ===========================================================================
.text$mn:0000286C
.text$mn:0000286C ; Segment type: Pure code
.text$mn:0000286C ; Segment permissions: Read/Execute
.text$mn:0000286C _text$mn        segment para public 'CODE' use32
.text$mn:0000286C                 assume cs:_text$mn
.text$mn:0000286C                 ;org 286Ch
.text$mn:0000286C ; COMDAT (pick any)
.text$mn:0000286C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000286C
.text$mn:0000286C ; =============== S U B R O U T I N E =======================================
.text$mn:0000286C
.text$mn:0000286C ; Attributes: bp-based frame
.text$mn:0000286C
.text$mn:0000286C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:0000286C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:0000286C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000286C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:0000286C
.text$mn:0000286C var_4           = dword ptr -4
.text$mn:0000286C arg_0           = dword ptr  8
.text$mn:0000286C
.text$mn:0000286C                 push    ebp
.text$mn:0000286D                 mov     ebp, esp
.text$mn:0000286F                 push    ecx
.text$mn:00002870                 mov     [ebp+var_4], ecx
.text$mn:00002873                 mov     eax, [ebp+var_4]
.text$mn:00002876                 mov     ecx, [eax+14h]
.text$mn:00002879                 cmp     ecx, [ebp+arg_0]
.text$mn:0000287C                 jnb     short loc_2886
.text$mn:0000287E                 mov     ecx, [ebp+var_4]
.text$mn:00002881                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002886
.text$mn:00002886 loc_2886:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00002886                 mov     edx, [ebp+arg_0]
.text$mn:00002889                 push    edx
.text$mn:0000288A                 mov     ecx, [ebp+var_4]
.text$mn:0000288D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002892                 mov     eax, [ebp+var_4]
.text$mn:00002895                 mov     esp, ebp
.text$mn:00002897                 pop     ebp
.text$mn:00002898                 retn    4
.text$mn:00002898 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00002898
.text$mn:00002898 ; ---------------------------------------------------------------------------
.text$mn:0000289B                 align 4
.text$mn:0000289B _text$mn        ends
.text$mn:0000289B
.text$mn:0000289C ; ===========================================================================
.text$mn:0000289C
.text$mn:0000289C ; Segment type: Pure code
.text$mn:0000289C ; Segment permissions: Read/Execute
.text$mn:0000289C _text$mn        segment para public 'CODE' use32
.text$mn:0000289C                 assume cs:_text$mn
.text$mn:0000289C                 ;org 289Ch
.text$mn:0000289C ; COMDAT (pick any)
.text$mn:0000289C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000289C
.text$mn:0000289C ; =============== S U B R O U T I N E =======================================
.text$mn:0000289C
.text$mn:0000289C ; Attributes: bp-based frame
.text$mn:0000289C
.text$mn:0000289C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:0000289C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:0000289C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000289C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:0000289C
.text$mn:0000289C var_C           = dword ptr -0Ch
.text$mn:0000289C Dst             = dword ptr -8
.text$mn:0000289C var_4           = dword ptr -4
.text$mn:0000289C arg_0           = dword ptr  8
.text$mn:0000289C arg_4           = dword ptr  0Ch
.text$mn:0000289C
.text$mn:0000289C                 push    ebp
.text$mn:0000289D                 mov     ebp, esp
.text$mn:0000289F                 sub     esp, 0Ch
.text$mn:000028A2                 mov     [ebp+var_4], ecx
.text$mn:000028A5                 mov     eax, [ebp+var_4]
.text$mn:000028A8                 mov     ecx, [eax+14h]
.text$mn:000028AB                 cmp     ecx, [ebp+arg_0]
.text$mn:000028AE                 jnb     short loc_28B8
.text$mn:000028B0                 mov     ecx, [ebp+var_4]
.text$mn:000028B3                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000028B8
.text$mn:000028B8 loc_28B8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:000028B8                 mov     edx, [ebp+var_4]
.text$mn:000028BB                 mov     eax, [edx+14h]
.text$mn:000028BE                 sub     eax, [ebp+arg_0]
.text$mn:000028C1                 cmp     eax, [ebp+arg_4]
.text$mn:000028C4                 ja      short loc_28D4
.text$mn:000028C6                 mov     ecx, [ebp+arg_0]
.text$mn:000028C9                 push    ecx
.text$mn:000028CA                 mov     ecx, [ebp+var_4]
.text$mn:000028CD                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000028D2                 jmp     short loc_291A
.text$mn:000028D4 ; ---------------------------------------------------------------------------
.text$mn:000028D4
.text$mn:000028D4 loc_28D4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:000028D4                 cmp     [ebp+arg_4], 0
.text$mn:000028D8                 jbe     short loc_291A
.text$mn:000028DA                 mov     ecx, [ebp+var_4]
.text$mn:000028DD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000028E2                 add     eax, [ebp+arg_0]
.text$mn:000028E5                 mov     [ebp+Dst], eax
.text$mn:000028E8                 mov     edx, [ebp+var_4]
.text$mn:000028EB                 mov     eax, [edx+14h]
.text$mn:000028EE                 sub     eax, [ebp+arg_4]
.text$mn:000028F1                 mov     [ebp+var_C], eax
.text$mn:000028F4                 mov     ecx, [ebp+var_C]
.text$mn:000028F7                 sub     ecx, [ebp+arg_0]
.text$mn:000028FA                 push    ecx             ; Size
.text$mn:000028FB                 mov     edx, [ebp+Dst]
.text$mn:000028FE                 add     edx, [ebp+arg_4]
.text$mn:00002901                 push    edx             ; Src
.text$mn:00002902                 mov     eax, [ebp+Dst]
.text$mn:00002905                 push    eax             ; Dst
.text$mn:00002906                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000290B                 add     esp, 0Ch
.text$mn:0000290E                 mov     ecx, [ebp+var_C]
.text$mn:00002911                 push    ecx
.text$mn:00002912                 mov     ecx, [ebp+var_4]
.text$mn:00002915                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000291A
.text$mn:0000291A loc_291A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000291A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000291A                 mov     eax, [ebp+var_4]
.text$mn:0000291D                 mov     esp, ebp
.text$mn:0000291F                 pop     ebp
.text$mn:00002920                 retn    8
.text$mn:00002920 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00002920
.text$mn:00002920 ; ---------------------------------------------------------------------------
.text$mn:00002923                 align 4
.text$mn:00002923 _text$mn        ends
.text$mn:00002923
.text$mn:00002924 ; ===========================================================================
.text$mn:00002924
.text$mn:00002924 ; Segment type: Pure code
.text$mn:00002924 ; Segment permissions: Read/Execute
.text$mn:00002924 _text$mn        segment para public 'CODE' use32
.text$mn:00002924                 assume cs:_text$mn
.text$mn:00002924                 ;org 2924h
.text$mn:00002924 ; COMDAT (pick any)
.text$mn:00002924                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002924
.text$mn:00002924 ; =============== S U B R O U T I N E =======================================
.text$mn:00002924
.text$mn:00002924 ; Attributes: bp-based frame
.text$mn:00002924
.text$mn:00002924 ; __int32 __thiscall ScintillaEditView::execute(ScintillaEditView *this, unsigned int, unsigned int, __int32)
.text$mn:00002924                 public ?execute@ScintillaEditView@@QBEJIIJ@Z
.text$mn:00002924 ?execute@ScintillaEditView@@QBEJIIJ@Z proc near
.text$mn:00002924                                         ; CODE XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+E9p
.text$mn:00002924                                         ; FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+240p ...
.text$mn:00002924
.text$mn:00002924 var_4           = dword ptr -4
.text$mn:00002924 arg_0           = dword ptr  8
.text$mn:00002924 arg_4           = dword ptr  0Ch
.text$mn:00002924 arg_8           = dword ptr  10h
.text$mn:00002924
.text$mn:00002924                 push    ebp
.text$mn:00002925                 mov     ebp, esp
.text$mn:00002927                 push    ecx
.text$mn:00002928                 mov     [ebp+var_4], ecx
.text$mn:0000292B                 mov     eax, [ebp+arg_8]
.text$mn:0000292E                 push    eax
.text$mn:0000292F                 mov     ecx, [ebp+arg_4]
.text$mn:00002932                 push    ecx
.text$mn:00002933                 mov     edx, [ebp+arg_0]
.text$mn:00002936                 push    edx
.text$mn:00002937                 mov     eax, [ebp+var_4]
.text$mn:0000293A                 mov     ecx, [eax+14h]
.text$mn:0000293D                 push    ecx
.text$mn:0000293E                 mov     edx, [ebp+var_4]
.text$mn:00002941                 mov     eax, [edx+10h]
.text$mn:00002944                 call    eax
.text$mn:00002946                 add     esp, 10h
.text$mn:00002949                 mov     esp, ebp
.text$mn:0000294B                 pop     ebp
.text$mn:0000294C                 retn    0Ch
.text$mn:0000294C ?execute@ScintillaEditView@@QBEJIIJ@Z endp
.text$mn:0000294C
.text$mn:0000294C ; ---------------------------------------------------------------------------
.text$mn:0000294F                 align 10h
.text$mn:0000294F _text$mn        ends
.text$mn:0000294F
.text$mn:00002950 ; ===========================================================================
.text$mn:00002950
.text$mn:00002950 ; Segment type: Pure code
.text$mn:00002950 ; Segment permissions: Read/Execute
.text$mn:00002950 _text$mn        segment para public 'CODE' use32
.text$mn:00002950                 assume cs:_text$mn
.text$mn:00002950                 ;org 2950h
.text$mn:00002950 ; COMDAT (pick any)
.text$mn:00002950                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002950
.text$mn:00002950 ; =============== S U B R O U T I N E =======================================
.text$mn:00002950
.text$mn:00002950 ; Attributes: bp-based frame
.text$mn:00002950
.text$mn:00002950 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00002950                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00002950 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002950                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00002950                 push    ebp
.text$mn:00002951                 mov     ebp, esp
.text$mn:00002953                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00002958                 pop     ebp
.text$mn:00002959                 retn
.text$mn:00002959 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002959
.text$mn:00002959 ; ---------------------------------------------------------------------------
.text$mn:0000295A                 align 4
.text$mn:0000295A _text$mn        ends
.text$mn:0000295A
.text$mn:0000295C ; ===========================================================================
.text$mn:0000295C
.text$mn:0000295C ; Segment type: Pure code
.text$mn:0000295C ; Segment permissions: Read/Execute
.text$mn:0000295C _text$mn        segment para public 'CODE' use32
.text$mn:0000295C                 assume cs:_text$mn
.text$mn:0000295C                 ;org 295Ch
.text$mn:0000295C ; COMDAT (pick any)
.text$mn:0000295C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000295C
.text$mn:0000295C ; =============== S U B R O U T I N E =======================================
.text$mn:0000295C
.text$mn:0000295C ; Attributes: bp-based frame
.text$mn:0000295C
.text$mn:0000295C ; int __thiscall ScintillaEditView::getCurrentDocLen(ScintillaEditView *__hidden this)
.text$mn:0000295C                 public ?getCurrentDocLen@ScintillaEditView@@QBEHXZ
.text$mn:0000295C ?getCurrentDocLen@ScintillaEditView@@QBEHXZ proc near
.text$mn:0000295C                                         ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+11p
.text$mn:0000295C
.text$mn:0000295C var_4           = dword ptr -4
.text$mn:0000295C
.text$mn:0000295C                 push    ebp
.text$mn:0000295D                 mov     ebp, esp
.text$mn:0000295F                 push    ecx
.text$mn:00002960                 mov     [ebp+var_4], ecx
.text$mn:00002963                 push    0               ; __int32
.text$mn:00002965                 push    0               ; unsigned int
.text$mn:00002967                 push    7D6h            ; unsigned int
.text$mn:0000296C                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000296F                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00002974                 mov     esp, ebp
.text$mn:00002976                 pop     ebp
.text$mn:00002977                 retn
.text$mn:00002977 ?getCurrentDocLen@ScintillaEditView@@QBEHXZ endp
.text$mn:00002977
.text$mn:00002977 _text$mn        ends
.text$mn:00002977
.text$mn:00002978 ; ===========================================================================
.text$mn:00002978
.text$mn:00002978 ; Segment type: Pure code
.text$mn:00002978 ; Segment permissions: Read/Execute
.text$mn:00002978 _text$mn        segment para public 'CODE' use32
.text$mn:00002978                 assume cs:_text$mn
.text$mn:00002978                 ;org 2978h
.text$mn:00002978 ; COMDAT (pick any)
.text$mn:00002978                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002978
.text$mn:00002978 ; =============== S U B R O U T I N E =======================================
.text$mn:00002978
.text$mn:00002978 ; Attributes: bp-based frame
.text$mn:00002978
.text$mn:00002978 ; bool __thiscall StaticDialog::isCheckedOrNot(StaticDialog *this, int)
.text$mn:00002978                 public ?isCheckedOrNot@StaticDialog@@QBE_NH@Z
.text$mn:00002978 ?isCheckedOrNot@StaticDialog@@QBE_NH@Z proc near
.text$mn:00002978                                         ; CODE XREF: FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)+11p
.text$mn:00002978                                         ; FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)+38p ...
.text$mn:00002978
.text$mn:00002978 var_8           = dword ptr -8
.text$mn:00002978 var_4           = dword ptr -4
.text$mn:00002978 nIDDlgItem      = dword ptr  8
.text$mn:00002978
.text$mn:00002978                 push    ebp
.text$mn:00002979                 mov     ebp, esp
.text$mn:0000297B                 sub     esp, 8
.text$mn:0000297E                 mov     [ebp+var_8], ecx
.text$mn:00002981                 push    0               ; lParam
.text$mn:00002983                 push    0               ; wParam
.text$mn:00002985                 push    0F0h ; '='      ; Msg
.text$mn:0000298A                 mov     eax, [ebp+nIDDlgItem]
.text$mn:0000298D                 push    eax             ; nIDDlgItem
.text$mn:0000298E                 mov     ecx, [ebp+var_8]
.text$mn:00002991                 mov     edx, [ecx+0Ch]
.text$mn:00002994                 push    edx             ; hDlg
.text$mn:00002995                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:0000299B                 push    eax             ; hWnd
.text$mn:0000299C                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000029A2                 cmp     eax, 1
.text$mn:000029A5                 jnz     short loc_29B0
.text$mn:000029A7                 mov     [ebp+var_4], 1
.text$mn:000029AE                 jmp     short loc_29B7
.text$mn:000029B0 ; ---------------------------------------------------------------------------
.text$mn:000029B0
.text$mn:000029B0 loc_29B0:                               ; CODE XREF: StaticDialog::isCheckedOrNot(int)+2Dj
.text$mn:000029B0                 mov     [ebp+var_4], 0
.text$mn:000029B7
.text$mn:000029B7 loc_29B7:                               ; CODE XREF: StaticDialog::isCheckedOrNot(int)+36j
.text$mn:000029B7                 mov     al, byte ptr [ebp+var_4]
.text$mn:000029BA                 mov     esp, ebp
.text$mn:000029BC                 pop     ebp
.text$mn:000029BD                 retn    4
.text$mn:000029BD ?isCheckedOrNot@StaticDialog@@QBE_NH@Z endp
.text$mn:000029BD
.text$mn:000029BD _text$mn        ends
.text$mn:000029BD
.text$mn:000029C0 ; ===========================================================================
.text$mn:000029C0
.text$mn:000029C0 ; Segment type: Pure code
.text$mn:000029C0 ; Segment permissions: Read/Execute
.text$mn:000029C0 _text$mn        segment para public 'CODE' use32
.text$mn:000029C0                 assume cs:_text$mn
.text$mn:000029C0                 ;org 29C0h
.text$mn:000029C0 ; COMDAT (pick any)
.text$mn:000029C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029C0
.text$mn:000029C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000029C0
.text$mn:000029C0 ; Attributes: bp-based frame
.text$mn:000029C0
.text$mn:000029C0 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:000029C0                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:000029C0 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:000029C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:000029C0
.text$mn:000029C0 var_4           = dword ptr -4
.text$mn:000029C0 Str             = dword ptr  8
.text$mn:000029C0
.text$mn:000029C0                 push    ebp
.text$mn:000029C1                 mov     ebp, esp
.text$mn:000029C3                 push    ecx
.text$mn:000029C4                 mov     eax, [ebp+Str]
.text$mn:000029C7                 movsx   ecx, byte ptr [eax]
.text$mn:000029CA                 test    ecx, ecx
.text$mn:000029CC                 jnz     short loc_29D7
.text$mn:000029CE                 mov     [ebp+var_4], 0
.text$mn:000029D5                 jmp     short loc_29E6
.text$mn:000029D7 ; ---------------------------------------------------------------------------
.text$mn:000029D7
.text$mn:000029D7 loc_29D7:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:000029D7                 mov     edx, [ebp+Str]
.text$mn:000029DA                 push    edx             ; Str
.text$mn:000029DB                 call    _strlen
.text$mn:000029E0                 add     esp, 4
.text$mn:000029E3                 mov     [ebp+var_4], eax
.text$mn:000029E6
.text$mn:000029E6 loc_29E6:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:000029E6                 mov     eax, [ebp+var_4]
.text$mn:000029E9                 mov     esp, ebp
.text$mn:000029EB                 pop     ebp
.text$mn:000029EC                 retn
.text$mn:000029EC ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:000029EC
.text$mn:000029EC ; ---------------------------------------------------------------------------
.text$mn:000029ED                 align 10h
.text$mn:000029ED _text$mn        ends
.text$mn:000029ED
.text$mn:000029F0 ; ===========================================================================
.text$mn:000029F0
.text$mn:000029F0 ; Segment type: Pure code
.text$mn:000029F0 ; Segment permissions: Read/Execute
.text$mn:000029F0 _text$mn        segment para public 'CODE' use32
.text$mn:000029F0                 assume cs:_text$mn
.text$mn:000029F0                 ;org 29F0h
.text$mn:000029F0 ; COMDAT (pick any)
.text$mn:000029F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029F0
.text$mn:000029F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000029F0
.text$mn:000029F0 ; Attributes: bp-based frame
.text$mn:000029F0
.text$mn:000029F0 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:000029F0                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:000029F0 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:000029F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:000029F0
.text$mn:000029F0 var_4           = dword ptr -4
.text$mn:000029F0
.text$mn:000029F0                 push    ebp
.text$mn:000029F1                 mov     ebp, esp
.text$mn:000029F3                 push    ecx
.text$mn:000029F4                 mov     [ebp+var_4], ecx
.text$mn:000029F7                 mov     eax, [ebp+var_4]
.text$mn:000029FA                 push    eax
.text$mn:000029FB                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00002A00                 add     esp, 4
.text$mn:00002A03                 mov     esp, ebp
.text$mn:00002A05                 pop     ebp
.text$mn:00002A06                 retn
.text$mn:00002A06 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00002A06
.text$mn:00002A06 ; ---------------------------------------------------------------------------
.text$mn:00002A07                 align 4
.text$mn:00002A07 _text$mn        ends
.text$mn:00002A07
.text$mn:00002A08 ; ===========================================================================
.text$mn:00002A08
.text$mn:00002A08 ; Segment type: Pure code
.text$mn:00002A08 ; Segment permissions: Read/Execute
.text$mn:00002A08 _text$mn        segment para public 'CODE' use32
.text$mn:00002A08                 assume cs:_text$mn
.text$mn:00002A08                 ;org 2A08h
.text$mn:00002A08 ; COMDAT (pick any)
.text$mn:00002A08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A08
.text$mn:00002A08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A08
.text$mn:00002A08 ; Attributes: bp-based frame
.text$mn:00002A08
.text$mn:00002A08 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00002A08                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00002A08 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00002A08                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00002A08
.text$mn:00002A08 var_4           = dword ptr -4
.text$mn:00002A08
.text$mn:00002A08                 push    ebp
.text$mn:00002A09                 mov     ebp, esp
.text$mn:00002A0B                 push    ecx
.text$mn:00002A0C                 mov     [ebp+var_4], ecx
.text$mn:00002A0F                 or      eax, 0FFFFFFFFh
.text$mn:00002A12                 mov     esp, ebp
.text$mn:00002A14                 pop     ebp
.text$mn:00002A15                 retn
.text$mn:00002A15 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00002A15
.text$mn:00002A15 ; ---------------------------------------------------------------------------
.text$mn:00002A16                 align 4
.text$mn:00002A16 _text$mn        ends
.text$mn:00002A16
.text$mn:00002A18 ; ===========================================================================
.text$mn:00002A18
.text$mn:00002A18 ; Segment type: Pure code
.text$mn:00002A18 ; Segment permissions: Read/Execute
.text$mn:00002A18 _text$mn        segment para public 'CODE' use32
.text$mn:00002A18                 assume cs:_text$mn
.text$mn:00002A18                 ;org 2A18h
.text$mn:00002A18 ; COMDAT (pick any)
.text$mn:00002A18                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A18
.text$mn:00002A18 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A18
.text$mn:00002A18 ; Attributes: bp-based frame
.text$mn:00002A18
.text$mn:00002A18 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00002A18                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00002A18 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00002A18                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00002A18
.text$mn:00002A18 arg_0           = dword ptr  8
.text$mn:00002A18
.text$mn:00002A18                 push    ebp
.text$mn:00002A19                 mov     ebp, esp
.text$mn:00002A1B                 mov     ecx, [ebp+arg_0]
.text$mn:00002A1E                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00002A23                 pop     ebp
.text$mn:00002A24                 retn
.text$mn:00002A24 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00002A24
.text$mn:00002A24 ; ---------------------------------------------------------------------------
.text$mn:00002A25                 align 4
.text$mn:00002A25 _text$mn        ends
.text$mn:00002A25
.text$mn:00002A28 ; ===========================================================================
.text$mn:00002A28
.text$mn:00002A28 ; Segment type: Pure code
.text$mn:00002A28 ; Segment permissions: Read/Execute
.text$mn:00002A28 _text$mn        segment para public 'CODE' use32
.text$mn:00002A28                 assume cs:_text$mn
.text$mn:00002A28                 ;org 2A28h
.text$mn:00002A28 ; COMDAT (pick any)
.text$mn:00002A28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A28
.text$mn:00002A28 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A28
.text$mn:00002A28 ; Attributes: bp-based frame
.text$mn:00002A28
.text$mn:00002A28 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00002A28                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002A28 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002A28                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00002A28                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00002A28
.text$mn:00002A28 var_10          = dword ptr -10h
.text$mn:00002A28 var_C           = dword ptr -0Ch
.text$mn:00002A28 var_8           = dword ptr -8
.text$mn:00002A28 var_1           = byte ptr -1
.text$mn:00002A28
.text$mn:00002A28                 push    ebp
.text$mn:00002A29                 mov     ebp, esp
.text$mn:00002A2B                 sub     esp, 10h
.text$mn:00002A2E                 mov     [ebp+var_10], ecx
.text$mn:00002A31                 lea     eax, [ebp+var_1]
.text$mn:00002A34                 push    eax
.text$mn:00002A35                 mov     ecx, [ebp+var_10]
.text$mn:00002A38                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002A3D                 mov     ecx, eax
.text$mn:00002A3F                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00002A44                 mov     [ebp+var_8], eax
.text$mn:00002A47                 cmp     [ebp+var_8], 1
.text$mn:00002A4B                 ja      short loc_2A56
.text$mn:00002A4D                 mov     [ebp+var_C], 1
.text$mn:00002A54                 jmp     short loc_2A5F
.text$mn:00002A56 ; ---------------------------------------------------------------------------
.text$mn:00002A56
.text$mn:00002A56 loc_2A56:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00002A56                 mov     ecx, [ebp+var_8]
.text$mn:00002A59                 sub     ecx, 1
.text$mn:00002A5C                 mov     [ebp+var_C], ecx
.text$mn:00002A5F
.text$mn:00002A5F loc_2A5F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00002A5F                 mov     eax, [ebp+var_C]
.text$mn:00002A62                 mov     esp, ebp
.text$mn:00002A64                 pop     ebp
.text$mn:00002A65                 retn
.text$mn:00002A65 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002A65
.text$mn:00002A65 ; ---------------------------------------------------------------------------
.text$mn:00002A66                 align 4
.text$mn:00002A66 _text$mn        ends
.text$mn:00002A66
.text$mn:00002A68 ; ===========================================================================
.text$mn:00002A68
.text$mn:00002A68 ; Segment type: Pure code
.text$mn:00002A68 ; Segment permissions: Read/Execute
.text$mn:00002A68 _text$mn        segment para public 'CODE' use32
.text$mn:00002A68                 assume cs:_text$mn
.text$mn:00002A68                 ;org 2A68h
.text$mn:00002A68 ; COMDAT (pick any)
.text$mn:00002A68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A68
.text$mn:00002A68 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A68
.text$mn:00002A68 ; Attributes: bp-based frame
.text$mn:00002A68
.text$mn:00002A68 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00002A68                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002A68 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002A68                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00002A68                                         ; DATA XREF: .rdata:00003134o
.text$mn:00002A68
.text$mn:00002A68 var_1C          = dword ptr -1Ch
.text$mn:00002A68 var_18          = dword ptr -18h
.text$mn:00002A68 Str             = dword ptr -14h
.text$mn:00002A68 var_10          = dword ptr -10h
.text$mn:00002A68 var_C           = dword ptr -0Ch
.text$mn:00002A68 var_4           = dword ptr -4
.text$mn:00002A68 arg_0           = dword ptr  8
.text$mn:00002A68 arg_4           = dword ptr  0Ch
.text$mn:00002A68
.text$mn:00002A68                 push    ebp
.text$mn:00002A69                 mov     ebp, esp
.text$mn:00002A6B                 push    0FFFFFFFFh
.text$mn:00002A6D                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002A72                 mov     eax, large fs:0
.text$mn:00002A78                 push    eax
.text$mn:00002A79                 sub     esp, 10h
.text$mn:00002A7C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002A81                 xor     eax, ebp
.text$mn:00002A83                 push    eax
.text$mn:00002A84                 lea     eax, [ebp+var_C]
.text$mn:00002A87                 mov     large fs:0, eax
.text$mn:00002A8D                 mov     [ebp+var_1C], ecx
.text$mn:00002A90                 mov     [ebp+var_18], 0
.text$mn:00002A97                 mov     eax, [ebp+arg_4]
.text$mn:00002A9A                 push    eax             ; int
.text$mn:00002A9B                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002AA0                 add     esp, 4
.text$mn:00002AA3                 mov     [ebp+var_10], eax
.text$mn:00002AA6                 cmp     [ebp+var_10], 0
.text$mn:00002AAA                 jz      short loc_2AB4
.text$mn:00002AAC                 mov     ecx, [ebp+var_10]
.text$mn:00002AAF                 mov     [ebp+Str], ecx
.text$mn:00002AB2                 jmp     short loc_2ABB
.text$mn:00002AB4 ; ---------------------------------------------------------------------------
.text$mn:00002AB4
.text$mn:00002AB4 loc_2AB4:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00002AB4                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002ABB
.text$mn:00002ABB loc_2ABB:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00002ABB                 mov     edx, [ebp+Str]
.text$mn:00002ABE                 push    edx             ; Str
.text$mn:00002ABF                 mov     ecx, [ebp+arg_0]
.text$mn:00002AC2                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002AC7                 mov     [ebp+var_4], 0
.text$mn:00002ACE                 mov     eax, [ebp+var_18]
.text$mn:00002AD1                 or      eax, 1
.text$mn:00002AD4                 mov     [ebp+var_18], eax
.text$mn:00002AD7                 mov     eax, [ebp+arg_0]
.text$mn:00002ADA                 mov     ecx, [ebp+var_C]
.text$mn:00002ADD                 mov     large fs:0, ecx
.text$mn:00002AE4                 pop     ecx
.text$mn:00002AE5                 mov     esp, ebp
.text$mn:00002AE7                 pop     ebp
.text$mn:00002AE8                 retn    8
.text$mn:00002AE8 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002AE8
.text$mn:00002AE8 ; ---------------------------------------------------------------------------
.text$mn:00002AEB                 align 4
.text$mn:00002AEB _text$mn        ends
.text$mn:00002AEB
.text$x:00002AEC ; ===========================================================================
.text$x:00002AEC
.text$x:00002AEC ; Segment type: Pure code
.text$x:00002AEC ; Segment permissions: Read/Execute
.text$x:00002AEC _text$x         segment para public 'CODE' use32
.text$x:00002AEC                 assume cs:_text$x
.text$x:00002AEC                 ;org 2AECh
.text$x:00002AEC ; COMDAT (pick associative to section at 2A68)
.text$x:00002AEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002AEC
.text$x:00002AEC ; =============== S U B R O U T I N E =======================================
.text$x:00002AEC
.text$x:00002AEC
.text$x:00002AEC __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002AEC                                         ; DATA XREF: .xdata$x:00002F54o
.text$x:00002AEC                 mov     eax, [ebp-18h]
.text$x:00002AEF                 and     eax, 1
.text$x:00002AF2                 jz      $LN6
.text$x:00002AF8                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002AFC                 mov     ecx, [ebp+8]
.text$x:00002AFF                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002B04 ; ---------------------------------------------------------------------------
.text$x:00002B04
.text$x:00002B04 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002B04                 retn
.text$x:00002B04 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002B04
.text$x:00002B05
.text$x:00002B05 ; =============== S U B R O U T I N E =======================================
.text$x:00002B05
.text$x:00002B05
.text$x:00002B05 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002B05                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00002B05
.text$x:00002B05 arg_4           = dword ptr  8
.text$x:00002B05
.text$x:00002B05                 mov     edx, [esp+arg_4]
.text$x:00002B09                 lea     eax, [edx+0Ch]
.text$x:00002B0C                 mov     ecx, [edx-14h]
.text$x:00002B0F                 xor     ecx, eax
.text$x:00002B11                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002B16                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002B1B                 jmp     ___CxxFrameHandler3
.text$x:00002B1B __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002B1B
.text$x:00002B1B _text$x         ends
.text$x:00002B1B
.text$mn:00002B20 ; ===========================================================================
.text$mn:00002B20
.text$mn:00002B20 ; Segment type: Pure code
.text$mn:00002B20 ; Segment permissions: Read/Execute
.text$mn:00002B20 _text$mn        segment para public 'CODE' use32
.text$mn:00002B20                 assume cs:_text$mn
.text$mn:00002B20                 ;org 2B20h
.text$mn:00002B20 ; COMDAT (pick any)
.text$mn:00002B20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B20
.text$mn:00002B20 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B20
.text$mn:00002B20 ; Attributes: bp-based frame
.text$mn:00002B20
.text$mn:00002B20 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00002B20                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002B20 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002B20                                         ; DATA XREF: .rdata:00003168o
.text$mn:00002B20
.text$mn:00002B20 var_14          = dword ptr -14h
.text$mn:00002B20 var_10          = dword ptr -10h
.text$mn:00002B20 var_C           = dword ptr -0Ch
.text$mn:00002B20 var_4           = dword ptr -4
.text$mn:00002B20 arg_0           = dword ptr  8
.text$mn:00002B20 arg_4           = dword ptr  0Ch
.text$mn:00002B20
.text$mn:00002B20                 push    ebp
.text$mn:00002B21                 mov     ebp, esp
.text$mn:00002B23                 push    0FFFFFFFFh
.text$mn:00002B25                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002B2A                 mov     eax, large fs:0
.text$mn:00002B30                 push    eax
.text$mn:00002B31                 sub     esp, 8
.text$mn:00002B34                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B39                 xor     eax, ebp
.text$mn:00002B3B                 push    eax
.text$mn:00002B3C                 lea     eax, [ebp+var_C]
.text$mn:00002B3F                 mov     large fs:0, eax
.text$mn:00002B45                 mov     [ebp+var_14], ecx
.text$mn:00002B48                 mov     [ebp+var_10], 0
.text$mn:00002B4F                 cmp     [ebp+arg_4], 1
.text$mn:00002B53                 jnz     short loc_2B79
.text$mn:00002B55                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00002B5A                 mov     ecx, [ebp+arg_0]
.text$mn:00002B5D                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002B62                 mov     [ebp+var_4], 0
.text$mn:00002B69                 mov     eax, [ebp+var_10]
.text$mn:00002B6C                 or      eax, 1
.text$mn:00002B6F                 mov     [ebp+var_10], eax
.text$mn:00002B72                 mov     eax, [ebp+arg_0]
.text$mn:00002B75                 jmp     short loc_2B9C
.text$mn:00002B77 ; ---------------------------------------------------------------------------
.text$mn:00002B77                 jmp     short loc_2B9C
.text$mn:00002B79 ; ---------------------------------------------------------------------------
.text$mn:00002B79
.text$mn:00002B79 loc_2B79:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00002B79                 mov     ecx, [ebp+arg_4]
.text$mn:00002B7C                 push    ecx
.text$mn:00002B7D                 mov     edx, [ebp+arg_0]
.text$mn:00002B80                 push    edx
.text$mn:00002B81                 mov     ecx, [ebp+var_14]
.text$mn:00002B84                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00002B89                 mov     [ebp+var_4], 0
.text$mn:00002B90                 mov     eax, [ebp+var_10]
.text$mn:00002B93                 or      eax, 1
.text$mn:00002B96                 mov     [ebp+var_10], eax
.text$mn:00002B99                 mov     eax, [ebp+arg_0]
.text$mn:00002B9C
.text$mn:00002B9C loc_2B9C:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00002B9C                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00002B9C                 mov     ecx, [ebp+var_C]
.text$mn:00002B9F                 mov     large fs:0, ecx
.text$mn:00002BA6                 pop     ecx
.text$mn:00002BA7                 mov     esp, ebp
.text$mn:00002BA9                 pop     ebp
.text$mn:00002BAA                 retn    8
.text$mn:00002BAA ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002BAA
.text$mn:00002BAA ; ---------------------------------------------------------------------------
.text$mn:00002BAD                 align 10h
.text$mn:00002BAD _text$mn        ends
.text$mn:00002BAD
.text$x:00002BB0 ; ===========================================================================
.text$x:00002BB0
.text$x:00002BB0 ; Segment type: Pure code
.text$x:00002BB0 ; Segment permissions: Read/Execute
.text$x:00002BB0 _text$x         segment para public 'CODE' use32
.text$x:00002BB0                 assume cs:_text$x
.text$x:00002BB0                 ;org 2BB0h
.text$x:00002BB0 ; COMDAT (pick associative to section at 2B20)
.text$x:00002BB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002BB0
.text$x:00002BB0 ; =============== S U B R O U T I N E =======================================
.text$x:00002BB0
.text$x:00002BB0
.text$x:00002BB0 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002BB0                                         ; DATA XREF: .xdata$x:00002FD8o
.text$x:00002BB0                 mov     eax, [ebp-10h]
.text$x:00002BB3                 and     eax, 1
.text$x:00002BB6                 jz      $LN6_0
.text$x:00002BBC                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002BC0                 mov     ecx, [ebp+8]
.text$x:00002BC3                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002BC8 ; ---------------------------------------------------------------------------
.text$x:00002BC8
.text$x:00002BC8 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002BC8                 retn
.text$x:00002BC8 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002BC8
.text$x:00002BC9
.text$x:00002BC9 ; =============== S U B R O U T I N E =======================================
.text$x:00002BC9
.text$x:00002BC9
.text$x:00002BC9 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002BC9                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00002BC9
.text$x:00002BC9 arg_4           = dword ptr  8
.text$x:00002BC9
.text$x:00002BC9                 mov     edx, [esp+arg_4]
.text$x:00002BCD                 lea     eax, [edx+0Ch]
.text$x:00002BD0                 mov     ecx, [edx-0Ch]
.text$x:00002BD3                 xor     ecx, eax
.text$x:00002BD5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BDA                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002BDF                 jmp     ___CxxFrameHandler3
.text$x:00002BDF __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002BDF
.text$x:00002BDF _text$x         ends
.text$x:00002BDF
.text$mn:00002BE4 ; ===========================================================================
.text$mn:00002BE4
.text$mn:00002BE4 ; Segment type: Pure code
.text$mn:00002BE4 ; Segment permissions: Read/Execute
.text$mn:00002BE4 _text$mn        segment para public 'CODE' use32
.text$mn:00002BE4                 assume cs:_text$mn
.text$mn:00002BE4                 ;org 2BE4h
.text$mn:00002BE4 ; COMDAT (pick any)
.text$mn:00002BE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002BE4
.text$mn:00002BE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BE4
.text$mn:00002BE4 ; Attributes: bp-based frame
.text$mn:00002BE4
.text$mn:00002BE4 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00002BE4                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002BE4 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002BE4                                         ; DATA XREF: .rdata:000031A8o
.text$mn:00002BE4
.text$mn:00002BE4 var_1C          = dword ptr -1Ch
.text$mn:00002BE4 var_18          = dword ptr -18h
.text$mn:00002BE4 Str             = dword ptr -14h
.text$mn:00002BE4 var_10          = dword ptr -10h
.text$mn:00002BE4 var_C           = dword ptr -0Ch
.text$mn:00002BE4 var_4           = dword ptr -4
.text$mn:00002BE4 arg_0           = dword ptr  8
.text$mn:00002BE4 arg_4           = dword ptr  0Ch
.text$mn:00002BE4
.text$mn:00002BE4                 push    ebp
.text$mn:00002BE5                 mov     ebp, esp
.text$mn:00002BE7                 push    0FFFFFFFFh
.text$mn:00002BE9                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002BEE                 mov     eax, large fs:0
.text$mn:00002BF4                 push    eax
.text$mn:00002BF5                 sub     esp, 10h
.text$mn:00002BF8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002BFD                 xor     eax, ebp
.text$mn:00002BFF                 push    eax
.text$mn:00002C00                 lea     eax, [ebp+var_C]
.text$mn:00002C03                 mov     large fs:0, eax
.text$mn:00002C09                 mov     [ebp+var_1C], ecx
.text$mn:00002C0C                 mov     [ebp+var_18], 0
.text$mn:00002C13                 mov     eax, [ebp+arg_4]
.text$mn:00002C16                 push    eax             ; int
.text$mn:00002C17                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00002C1C                 add     esp, 4
.text$mn:00002C1F                 mov     [ebp+var_10], eax
.text$mn:00002C22                 cmp     [ebp+var_10], 0
.text$mn:00002C26                 jz      short loc_2C30
.text$mn:00002C28                 mov     ecx, [ebp+var_10]
.text$mn:00002C2B                 mov     [ebp+Str], ecx
.text$mn:00002C2E                 jmp     short loc_2C37
.text$mn:00002C30 ; ---------------------------------------------------------------------------
.text$mn:00002C30
.text$mn:00002C30 loc_2C30:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00002C30                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002C37
.text$mn:00002C37 loc_2C37:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00002C37                 mov     edx, [ebp+Str]
.text$mn:00002C3A                 push    edx             ; Str
.text$mn:00002C3B                 mov     ecx, [ebp+arg_0]
.text$mn:00002C3E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002C43                 mov     [ebp+var_4], 0
.text$mn:00002C4A                 mov     eax, [ebp+var_18]
.text$mn:00002C4D                 or      eax, 1
.text$mn:00002C50                 mov     [ebp+var_18], eax
.text$mn:00002C53                 mov     eax, [ebp+arg_0]
.text$mn:00002C56                 mov     ecx, [ebp+var_C]
.text$mn:00002C59                 mov     large fs:0, ecx
.text$mn:00002C60                 pop     ecx
.text$mn:00002C61                 mov     esp, ebp
.text$mn:00002C63                 pop     ebp
.text$mn:00002C64                 retn    8
.text$mn:00002C64 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002C64
.text$mn:00002C64 ; ---------------------------------------------------------------------------
.text$mn:00002C67                 align 4
.text$mn:00002C67 _text$mn        ends
.text$mn:00002C67
.text$x:00002C68 ; ===========================================================================
.text$x:00002C68
.text$x:00002C68 ; Segment type: Pure code
.text$x:00002C68 ; Segment permissions: Read/Execute
.text$x:00002C68 _text$x         segment para public 'CODE' use32
.text$x:00002C68                 assume cs:_text$x
.text$x:00002C68                 ;org 2C68h
.text$x:00002C68 ; COMDAT (pick associative to section at 2BE4)
.text$x:00002C68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002C68
.text$x:00002C68 ; =============== S U B R O U T I N E =======================================
.text$x:00002C68
.text$x:00002C68
.text$x:00002C68 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002C68                                         ; DATA XREF: .xdata$x:0000305Co
.text$x:00002C68                 mov     eax, [ebp-18h]
.text$x:00002C6B                 and     eax, 1
.text$x:00002C6E                 jz      $LN6_1
.text$x:00002C74                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002C78                 mov     ecx, [ebp+8]
.text$x:00002C7B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002C80 ; ---------------------------------------------------------------------------
.text$x:00002C80
.text$x:00002C80 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002C80                 retn
.text$x:00002C80 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002C80
.text$x:00002C81
.text$x:00002C81 ; =============== S U B R O U T I N E =======================================
.text$x:00002C81
.text$x:00002C81
.text$x:00002C81 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002C81                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00002C81
.text$x:00002C81 arg_4           = dword ptr  8
.text$x:00002C81
.text$x:00002C81                 mov     edx, [esp+arg_4]
.text$x:00002C85                 lea     eax, [edx+0Ch]
.text$x:00002C88                 mov     ecx, [edx-14h]
.text$x:00002C8B                 xor     ecx, eax
.text$x:00002C8D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C92                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002C97                 jmp     ___CxxFrameHandler3
.text$x:00002C97 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002C97
.text$x:00002C97 _text$x         ends
.text$x:00002C97
.text$mn:00002C9C ; ===========================================================================
.text$mn:00002C9C
.text$mn:00002C9C ; Segment type: Pure code
.text$mn:00002C9C ; Segment permissions: Read/Execute
.text$mn:00002C9C _text$mn        segment para public 'CODE' use32
.text$mn:00002C9C                 assume cs:_text$mn
.text$mn:00002C9C                 ;org 2C9Ch
.text$mn:00002C9C ; COMDAT (pick any)
.text$mn:00002C9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002C9C
.text$mn:00002C9C ; =============== S U B R O U T I N E =======================================
.text$mn:00002C9C
.text$mn:00002C9C ; Attributes: bp-based frame
.text$mn:00002C9C
.text$mn:00002C9C ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00002C9C                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002C9C ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00002C9C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00002C9C
.text$mn:00002C9C var_4           = dword ptr -4
.text$mn:00002C9C Dst             = dword ptr  8
.text$mn:00002C9C Src             = dword ptr  0Ch
.text$mn:00002C9C Size            = dword ptr  10h
.text$mn:00002C9C
.text$mn:00002C9C                 push    ebp
.text$mn:00002C9D                 mov     ebp, esp
.text$mn:00002C9F                 push    ecx
.text$mn:00002CA0                 cmp     [ebp+Size], 0
.text$mn:00002CA4                 jnz     short loc_2CAE
.text$mn:00002CA6                 mov     eax, [ebp+Dst]
.text$mn:00002CA9                 mov     [ebp+var_4], eax
.text$mn:00002CAC                 jmp     short loc_2CC5
.text$mn:00002CAE ; ---------------------------------------------------------------------------
.text$mn:00002CAE
.text$mn:00002CAE loc_2CAE:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00002CAE                 mov     ecx, [ebp+Size]
.text$mn:00002CB1                 push    ecx             ; Size
.text$mn:00002CB2                 mov     edx, [ebp+Src]
.text$mn:00002CB5                 push    edx             ; Src
.text$mn:00002CB6                 mov     eax, [ebp+Dst]
.text$mn:00002CB9                 push    eax             ; Dst
.text$mn:00002CBA                 call    _memmove
.text$mn:00002CBF                 add     esp, 0Ch
.text$mn:00002CC2                 mov     [ebp+var_4], eax
.text$mn:00002CC5
.text$mn:00002CC5 loc_2CC5:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00002CC5                 mov     eax, [ebp+var_4]
.text$mn:00002CC8                 mov     esp, ebp
.text$mn:00002CCA                 pop     ebp
.text$mn:00002CCB                 retn
.text$mn:00002CCB ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002CCB
.text$mn:00002CCB _text$mn        ends
.text$mn:00002CCB
.text$mn:00002CCC ; ===========================================================================
.text$mn:00002CCC
.text$mn:00002CCC ; Segment type: Pure code
.text$mn:00002CCC ; Segment permissions: Read/Execute
.text$mn:00002CCC _text$mn        segment para public 'CODE' use32
.text$mn:00002CCC                 assume cs:_text$mn
.text$mn:00002CCC                 ;org 2CCCh
.text$mn:00002CCC ; COMDAT (pick any)
.text$mn:00002CCC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CCC
.text$mn:00002CCC ; =============== S U B R O U T I N E =======================================
.text$mn:00002CCC
.text$mn:00002CCC ; Attributes: bp-based frame
.text$mn:00002CCC
.text$mn:00002CCC ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00002CCC                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00002CCC ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00002CCC                                         ; DATA XREF: .rdata:00003130o
.text$mn:00002CCC
.text$mn:00002CCC var_4           = dword ptr -4
.text$mn:00002CCC
.text$mn:00002CCC                 push    ebp
.text$mn:00002CCD                 mov     ebp, esp
.text$mn:00002CCF                 push    ecx
.text$mn:00002CD0                 mov     [ebp+var_4], ecx
.text$mn:00002CD3                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00002CD8                 mov     esp, ebp
.text$mn:00002CDA                 pop     ebp
.text$mn:00002CDB                 retn
.text$mn:00002CDB ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00002CDB
.text$mn:00002CDB _text$mn        ends
.text$mn:00002CDB
.text$mn:00002CDC ; ===========================================================================
.text$mn:00002CDC
.text$mn:00002CDC ; Segment type: Pure code
.text$mn:00002CDC ; Segment permissions: Read/Execute
.text$mn:00002CDC _text$mn        segment para public 'CODE' use32
.text$mn:00002CDC                 assume cs:_text$mn
.text$mn:00002CDC                 ;org 2CDCh
.text$mn:00002CDC ; COMDAT (pick any)
.text$mn:00002CDC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CDC
.text$mn:00002CDC ; =============== S U B R O U T I N E =======================================
.text$mn:00002CDC
.text$mn:00002CDC ; Attributes: bp-based frame
.text$mn:00002CDC
.text$mn:00002CDC ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00002CDC                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00002CDC ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00002CDC                                         ; DATA XREF: .rdata:00003164o
.text$mn:00002CDC
.text$mn:00002CDC var_4           = dword ptr -4
.text$mn:00002CDC
.text$mn:00002CDC                 push    ebp
.text$mn:00002CDD                 mov     ebp, esp
.text$mn:00002CDF                 push    ecx
.text$mn:00002CE0                 mov     [ebp+var_4], ecx
.text$mn:00002CE3                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00002CE8                 mov     esp, ebp
.text$mn:00002CEA                 pop     ebp
.text$mn:00002CEB                 retn
.text$mn:00002CEB ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00002CEB
.text$mn:00002CEB _text$mn        ends
.text$mn:00002CEB
.text$mn:00002CEC ; ===========================================================================
.text$mn:00002CEC
.text$mn:00002CEC ; Segment type: Pure code
.text$mn:00002CEC ; Segment permissions: Read/Execute
.text$mn:00002CEC _text$mn        segment para public 'CODE' use32
.text$mn:00002CEC                 assume cs:_text$mn
.text$mn:00002CEC                 ;org 2CECh
.text$mn:00002CEC ; COMDAT (pick any)
.text$mn:00002CEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CEC
.text$mn:00002CEC ; =============== S U B R O U T I N E =======================================
.text$mn:00002CEC
.text$mn:00002CEC ; Attributes: bp-based frame
.text$mn:00002CEC
.text$mn:00002CEC ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00002CEC                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00002CEC ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00002CEC                                         ; DATA XREF: .rdata:000031A4o
.text$mn:00002CEC
.text$mn:00002CEC var_4           = dword ptr -4
.text$mn:00002CEC
.text$mn:00002CEC                 push    ebp
.text$mn:00002CED                 mov     ebp, esp
.text$mn:00002CEF                 push    ecx
.text$mn:00002CF0                 mov     [ebp+var_4], ecx
.text$mn:00002CF3                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00002CF8                 mov     esp, ebp
.text$mn:00002CFA                 pop     ebp
.text$mn:00002CFB                 retn
.text$mn:00002CFB ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00002CFB
.text$mn:00002CFB _text$mn        ends
.text$mn:00002CFB
.text$mn:00002CFC ; ===========================================================================
.text$mn:00002CFC
.text$mn:00002CFC ; Segment type: Pure code
.text$mn:00002CFC ; Segment permissions: Read/Execute
.text$mn:00002CFC _text$mn        segment para public 'CODE' use32
.text$mn:00002CFC                 assume cs:_text$mn
.text$mn:00002CFC                 ;org 2CFCh
.text$mn:00002CFC ; COMDAT (pick any)
.text$mn:00002CFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CFC
.text$mn:00002CFC ; =============== S U B R O U T I N E =======================================
.text$mn:00002CFC
.text$mn:00002CFC ; Attributes: bp-based frame
.text$mn:00002CFC
.text$mn:00002CFC ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00002CFC                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002CFC ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002CFC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00002CFC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00002CFC
.text$mn:00002CFC var_4           = dword ptr -4
.text$mn:00002CFC
.text$mn:00002CFC                 push    ebp
.text$mn:00002CFD                 mov     ebp, esp
.text$mn:00002CFF                 push    ecx
.text$mn:00002D00                 mov     [ebp+var_4], ecx
.text$mn:00002D03                 mov     eax, [ebp+var_4]
.text$mn:00002D06                 mov     eax, [eax+14h]
.text$mn:00002D09                 mov     esp, ebp
.text$mn:00002D0B                 pop     ebp
.text$mn:00002D0C                 retn
.text$mn:00002D0C ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002D0C
.text$mn:00002D0C ; ---------------------------------------------------------------------------
.text$mn:00002D0D                 align 10h
.text$mn:00002D0D _text$mn        ends
.text$mn:00002D0D
.text$mn:00002D10 ; ===========================================================================
.text$mn:00002D10
.text$mn:00002D10 ; Segment type: Pure code
.text$mn:00002D10 ; Segment permissions: Read/Execute
.text$mn:00002D10 _text$mn        segment para public 'CODE' use32
.text$mn:00002D10                 assume cs:_text$mn
.text$mn:00002D10                 ;org 2D10h
.text$mn:00002D10 ; COMDAT (pick any)
.text$mn:00002D10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D10
.text$mn:00002D10 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D10
.text$mn:00002D10 ; Attributes: bp-based frame
.text$mn:00002D10
.text$mn:00002D10 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00002D10                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00002D10 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002D10                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_27B8p
.text$mn:00002D10                 push    ebp
.text$mn:00002D11                 mov     ebp, esp
.text$mn:00002D13                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00002D18                 pop     ebp
.text$mn:00002D19                 retn
.text$mn:00002D19 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002D19
.text$mn:00002D19 ; ---------------------------------------------------------------------------
.text$mn:00002D1A                 align 4
.text$mn:00002D1A _text$mn        ends
.text$mn:00002D1A
.text$mn:00002D1C ; ===========================================================================
.text$mn:00002D1C
.text$mn:00002D1C ; Segment type: Pure code
.text$mn:00002D1C ; Segment permissions: Read/Execute
.text$mn:00002D1C _text$mn        segment para public 'CODE' use32
.text$mn:00002D1C                 assume cs:_text$mn
.text$mn:00002D1C                 ;org 2D1Ch
.text$mn:00002D1C ; COMDAT (pick any)
.text$mn:00002D1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D1C
.text$mn:00002D1C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D1C
.text$mn:00002D1C ; Attributes: bp-based frame
.text$mn:00002D1C
.text$mn:00002D1C ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00002D1C                 public ?value@error_code@std@@QBEHXZ
.text$mn:00002D1C ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00002D1C
.text$mn:00002D1C var_4           = dword ptr -4
.text$mn:00002D1C
.text$mn:00002D1C                 push    ebp
.text$mn:00002D1D                 mov     ebp, esp
.text$mn:00002D1F                 push    ecx
.text$mn:00002D20                 mov     [ebp+var_4], ecx
.text$mn:00002D23                 mov     eax, [ebp+var_4]
.text$mn:00002D26                 mov     eax, [eax]
.text$mn:00002D28                 mov     esp, ebp
.text$mn:00002D2A                 pop     ebp
.text$mn:00002D2B                 retn
.text$mn:00002D2B ?value@error_code@std@@QBEHXZ endp
.text$mn:00002D2B
.text$mn:00002D2B _text$mn        ends
.text$mn:00002D2B
.text$mn:00002D2C ; ===========================================================================
.text$mn:00002D2C
.text$mn:00002D2C ; Segment type: Pure code
.text$mn:00002D2C ; Segment permissions: Read/Execute
.text$mn:00002D2C _text$mn        segment para public 'CODE' use32
.text$mn:00002D2C                 assume cs:_text$mn
.text$mn:00002D2C                 ;org 2D2Ch
.text$mn:00002D2C ; COMDAT (pick any)
.text$mn:00002D2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D2C
.text$mn:00002D2C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D2C
.text$mn:00002D2C ; Attributes: bp-based frame
.text$mn:00002D2C
.text$mn:00002D2C ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00002D2C                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00002D2C ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00002D2C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00002D2C                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00002D2C
.text$mn:00002D2C var_4           = dword ptr -4
.text$mn:00002D2C
.text$mn:00002D2C                 push    ebp
.text$mn:00002D2D                 mov     ebp, esp
.text$mn:00002D2F                 push    ecx
.text$mn:00002D30                 mov     [ebp+var_4], ecx
.text$mn:00002D33                 mov     eax, [ebp+var_4]
.text$mn:00002D36                 mov     eax, [eax]
.text$mn:00002D38                 mov     esp, ebp
.text$mn:00002D3A                 pop     ebp
.text$mn:00002D3B                 retn
.text$mn:00002D3B ?value@error_condition@std@@QBEHXZ endp
.text$mn:00002D3B
.text$mn:00002D3B _text$mn        ends
.text$mn:00002D3B
.text$mn:00002D3C ; ===========================================================================
.text$mn:00002D3C
.text$mn:00002D3C ; Segment type: Pure code
.text$mn:00002D3C ; Segment permissions: Read/Execute
.text$mn:00002D3C _text$mn        segment para public 'CODE' use32
.text$mn:00002D3C                 assume cs:_text$mn
.text$mn:00002D3C                 ;org 2D3Ch
.text$mn:00002D3C ; COMDAT (pick any)
.text$mn:00002D3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D3C
.text$mn:00002D3C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D3C
.text$mn:00002D3C ; Attributes: bp-based frame
.text$mn:00002D3C
.text$mn:00002D3C                 public _hypot
.text$mn:00002D3C _hypot          proc near
.text$mn:00002D3C
.text$mn:00002D3C var_10          = qword ptr -10h
.text$mn:00002D3C var_8           = qword ptr -8
.text$mn:00002D3C arg_0           = qword ptr  8
.text$mn:00002D3C arg_8           = qword ptr  10h
.text$mn:00002D3C
.text$mn:00002D3C                 push    ebp
.text$mn:00002D3D                 mov     ebp, esp
.text$mn:00002D3F                 sub     esp, 8
.text$mn:00002D42                 movsd   xmm0, [ebp+arg_8]
.text$mn:00002D47                 movsd   [esp+8+var_8], xmm0
.text$mn:00002D4C                 sub     esp, 8
.text$mn:00002D4F                 movsd   xmm0, [ebp+arg_0]
.text$mn:00002D54                 movsd   [esp+10h+var_10], xmm0
.text$mn:00002D59                 call    __hypot
.text$mn:00002D5E                 add     esp, 10h
.text$mn:00002D61                 pop     ebp
.text$mn:00002D62                 retn
.text$mn:00002D62 _hypot          endp
.text$mn:00002D62
.text$mn:00002D62 ; ---------------------------------------------------------------------------
.text$mn:00002D63                 align 4
.text$mn:00002D63 _text$mn        ends
.text$mn:00002D63
.xdata$x:00002D64 ; ===========================================================================
.xdata$x:00002D64
.xdata$x:00002D64 ; Segment type: Pure data
.xdata$x:00002D64 ; Segment permissions: Read
.xdata$x:00002D64 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D64                 assume cs:_xdata$x
.xdata$x:00002D64                 ;org 2D64h
.xdata$x:00002D64 ; COMDAT (pick associative to section at 235C)
.xdata$x:00002D64 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00002D64                                         ; DATA XREF: .xdata$x:00002D74o
.xdata$x:00002D65                 db 0FFh
.xdata$x:00002D66                 db 0FFh
.xdata$x:00002D67                 db 0FFh
.xdata$x:00002D68                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00002D6C __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00002D6C                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00002D6D                 db    5
.xdata$x:00002D6E                 db  93h ; ô
.xdata$x:00002D6F                 db  19h
.xdata$x:00002D70                 db    1
.xdata$x:00002D71                 db    0
.xdata$x:00002D72                 db    0
.xdata$x:00002D73                 db    0
.xdata$x:00002D74                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00002D78                 db    0
.xdata$x:00002D79                 db    0
.xdata$x:00002D7A                 db    0
.xdata$x:00002D7B                 db    0
.xdata$x:00002D7C                 db    0
.xdata$x:00002D7D                 db    0
.xdata$x:00002D7E                 db    0
.xdata$x:00002D7F                 db    0
.xdata$x:00002D80                 db    0
.xdata$x:00002D81                 db    0
.xdata$x:00002D82                 db    0
.xdata$x:00002D83                 db    0
.xdata$x:00002D84                 db    0
.xdata$x:00002D85                 db    0
.xdata$x:00002D86                 db    0
.xdata$x:00002D87                 db    0
.xdata$x:00002D88                 db    0
.xdata$x:00002D89                 db    0
.xdata$x:00002D8A                 db    0
.xdata$x:00002D8B                 db    0
.xdata$x:00002D8C                 db    0
.xdata$x:00002D8D                 db    0
.xdata$x:00002D8E                 db    0
.xdata$x:00002D8F                 db    0
.xdata$x:00002D8F _xdata$x        ends
.xdata$x:00002D8F
.xdata$x:00002D90 ; ===========================================================================
.xdata$x:00002D90
.xdata$x:00002D90 ; Segment type: Pure data
.xdata$x:00002D90 ; Segment permissions: Read
.xdata$x:00002D90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002D90                 assume cs:_xdata$x
.xdata$x:00002D90                 ;org 2D90h
.xdata$x:00002D90 ; COMDAT (pick associative to section at 16CC)
.xdata$x:00002D90 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002D90                                         ; DATA XREF: .xdata$x:00002DA0o
.xdata$x:00002D91                 db 0FFh
.xdata$x:00002D92                 db 0FFh
.xdata$x:00002D93                 db 0FFh
.xdata$x:00002D94                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002D98 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002D98                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002D99                 db    5
.xdata$x:00002D9A                 db  93h ; ô
.xdata$x:00002D9B                 db  19h
.xdata$x:00002D9C                 db    1
.xdata$x:00002D9D                 db    0
.xdata$x:00002D9E                 db    0
.xdata$x:00002D9F                 db    0
.xdata$x:00002DA0                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002DA4                 db    0
.xdata$x:00002DA5                 db    0
.xdata$x:00002DA6                 db    0
.xdata$x:00002DA7                 db    0
.xdata$x:00002DA8                 db    0
.xdata$x:00002DA9                 db    0
.xdata$x:00002DAA                 db    0
.xdata$x:00002DAB                 db    0
.xdata$x:00002DAC                 db    0
.xdata$x:00002DAD                 db    0
.xdata$x:00002DAE                 db    0
.xdata$x:00002DAF                 db    0
.xdata$x:00002DB0                 db    0
.xdata$x:00002DB1                 db    0
.xdata$x:00002DB2                 db    0
.xdata$x:00002DB3                 db    0
.xdata$x:00002DB4                 db    0
.xdata$x:00002DB5                 db    0
.xdata$x:00002DB6                 db    0
.xdata$x:00002DB7                 db    0
.xdata$x:00002DB8                 db    0
.xdata$x:00002DB9                 db    0
.xdata$x:00002DBA                 db    0
.xdata$x:00002DBB                 db    0
.xdata$x:00002DBB _xdata$x        ends
.xdata$x:00002DBB
.xdata$x:00002DBC ; ===========================================================================
.xdata$x:00002DBC
.xdata$x:00002DBC ; Segment type: Pure data
.xdata$x:00002DBC ; Segment permissions: Read
.xdata$x:00002DBC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002DBC                 assume cs:_xdata$x
.xdata$x:00002DBC                 ;org 2DBCh
.xdata$x:00002DBC ; COMDAT (pick associative to section at 1AB0)
.xdata$x:00002DBC __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002DBC                                         ; DATA XREF: .xdata$x:00002DCCo
.xdata$x:00002DBD                 db 0FFh
.xdata$x:00002DBE                 db 0FFh
.xdata$x:00002DBF                 db 0FFh
.xdata$x:00002DC0                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002DC4 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002DC4                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002DC5                 db    5
.xdata$x:00002DC6                 db  93h ; ô
.xdata$x:00002DC7                 db  19h
.xdata$x:00002DC8                 db    1
.xdata$x:00002DC9                 db    0
.xdata$x:00002DCA                 db    0
.xdata$x:00002DCB                 db    0
.xdata$x:00002DCC                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002DD0                 db    0
.xdata$x:00002DD1                 db    0
.xdata$x:00002DD2                 db    0
.xdata$x:00002DD3                 db    0
.xdata$x:00002DD4                 db    0
.xdata$x:00002DD5                 db    0
.xdata$x:00002DD6                 db    0
.xdata$x:00002DD7                 db    0
.xdata$x:00002DD8                 db    0
.xdata$x:00002DD9                 db    0
.xdata$x:00002DDA                 db    0
.xdata$x:00002DDB                 db    0
.xdata$x:00002DDC                 db    0
.xdata$x:00002DDD                 db    0
.xdata$x:00002DDE                 db    0
.xdata$x:00002DDF                 db    0
.xdata$x:00002DE0                 db    0
.xdata$x:00002DE1                 db    0
.xdata$x:00002DE2                 db    0
.xdata$x:00002DE3                 db    0
.xdata$x:00002DE4                 db    0
.xdata$x:00002DE5                 db    0
.xdata$x:00002DE6                 db    0
.xdata$x:00002DE7                 db    0
.xdata$x:00002DE7 _xdata$x        ends
.xdata$x:00002DE7
.xdata$x:00002DE8 ; ===========================================================================
.xdata$x:00002DE8
.xdata$x:00002DE8 ; Segment type: Pure data
.xdata$x:00002DE8 ; Segment permissions: Read
.xdata$x:00002DE8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002DE8                 assume cs:_xdata$x
.xdata$x:00002DE8                 ;org 2DE8h
.xdata$x:00002DE8 ; COMDAT (pick associative to section at 1650)
.xdata$x:00002DE8 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00002DE8                                         ; DATA XREF: .xdata$x:00002DF8o
.xdata$x:00002DE9                 db 0FFh
.xdata$x:00002DEA                 db 0FFh
.xdata$x:00002DEB                 db 0FFh
.xdata$x:00002DEC                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00002DF0 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00002DF0                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00002DF1                 db    5
.xdata$x:00002DF2                 db  93h ; ô
.xdata$x:00002DF3                 db  19h
.xdata$x:00002DF4                 db    1
.xdata$x:00002DF5                 db    0
.xdata$x:00002DF6                 db    0
.xdata$x:00002DF7                 db    0
.xdata$x:00002DF8                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00002DFC                 db    0
.xdata$x:00002DFD                 db    0
.xdata$x:00002DFE                 db    0
.xdata$x:00002DFF                 db    0
.xdata$x:00002E00                 db    0
.xdata$x:00002E01                 db    0
.xdata$x:00002E02                 db    0
.xdata$x:00002E03                 db    0
.xdata$x:00002E04                 db    0
.xdata$x:00002E05                 db    0
.xdata$x:00002E06                 db    0
.xdata$x:00002E07                 db    0
.xdata$x:00002E08                 db    0
.xdata$x:00002E09                 db    0
.xdata$x:00002E0A                 db    0
.xdata$x:00002E0B                 db    0
.xdata$x:00002E0C                 db    0
.xdata$x:00002E0D                 db    0
.xdata$x:00002E0E                 db    0
.xdata$x:00002E0F                 db    0
.xdata$x:00002E10                 db    0
.xdata$x:00002E11                 db    0
.xdata$x:00002E12                 db    0
.xdata$x:00002E13                 db    0
.xdata$x:00002E13 _xdata$x        ends
.xdata$x:00002E13
.xdata$x:00002E14 ; ===========================================================================
.xdata$x:00002E14
.xdata$x:00002E14 ; Segment type: Pure data
.xdata$x:00002E14 ; Segment permissions: Read
.xdata$x:00002E14 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E14                 assume cs:_xdata$x
.xdata$x:00002E14                 ;org 2E14h
.xdata$x:00002E14 ; COMDAT (pick associative to section at 1A38)
.xdata$x:00002E14 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002E14                                         ; DATA XREF: .xdata$x:00002E24o
.xdata$x:00002E15                 db 0FFh
.xdata$x:00002E16                 db 0FFh
.xdata$x:00002E17                 db 0FFh
.xdata$x:00002E18                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00002E1C __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002E1C                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00002E1D                 db    5
.xdata$x:00002E1E                 db  93h ; ô
.xdata$x:00002E1F                 db  19h
.xdata$x:00002E20                 db    1
.xdata$x:00002E21                 db    0
.xdata$x:00002E22                 db    0
.xdata$x:00002E23                 db    0
.xdata$x:00002E24                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00002E28                 align 20h
.xdata$x:00002E28 _xdata$x        ends
.xdata$x:00002E28
.xdata$x:00002E40 ; ===========================================================================
.xdata$x:00002E40
.xdata$x:00002E40 ; Segment type: Pure data
.xdata$x:00002E40 ; Segment permissions: Read
.xdata$x:00002E40 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E40                 assume cs:_xdata$x
.xdata$x:00002E40                 ;org 2E40h
.xdata$x:00002E40 ; COMDAT (pick associative to section at 178C)
.xdata$x:00002E40 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002E40                                         ; DATA XREF: .xdata$x:00002E50o
.xdata$x:00002E41                 db 0FFh
.xdata$x:00002E42                 db 0FFh
.xdata$x:00002E43                 db 0FFh
.xdata$x:00002E44                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00002E48 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00002E48                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00002E49                 db    5
.xdata$x:00002E4A                 db  93h ; ô
.xdata$x:00002E4B                 db  19h
.xdata$x:00002E4C                 db    1
.xdata$x:00002E4D                 db    0
.xdata$x:00002E4E                 db    0
.xdata$x:00002E4F                 db    0
.xdata$x:00002E50                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00002E54                 db    0
.xdata$x:00002E55                 db    0
.xdata$x:00002E56                 db    0
.xdata$x:00002E57                 db    0
.xdata$x:00002E58                 db    0
.xdata$x:00002E59                 db    0
.xdata$x:00002E5A                 db    0
.xdata$x:00002E5B                 db    0
.xdata$x:00002E5C                 db    0
.xdata$x:00002E5D                 db    0
.xdata$x:00002E5E                 db    0
.xdata$x:00002E5F                 db    0
.xdata$x:00002E60                 db    0
.xdata$x:00002E61                 db    0
.xdata$x:00002E62                 db    0
.xdata$x:00002E63                 db    0
.xdata$x:00002E64                 db    0
.xdata$x:00002E65                 db    0
.xdata$x:00002E66                 db    0
.xdata$x:00002E67                 db    0
.xdata$x:00002E68                 db    0
.xdata$x:00002E69                 db    0
.xdata$x:00002E6A                 db    0
.xdata$x:00002E6B                 db    0
.xdata$x:00002E6B _xdata$x        ends
.xdata$x:00002E6B
.xdata$x:00002E6C ; ===========================================================================
.xdata$x:00002E6C
.xdata$x:00002E6C ; Segment type: Pure data
.xdata$x:00002E6C ; Segment permissions: Read
.xdata$x:00002E6C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E6C                 assume cs:_xdata$x
.xdata$x:00002E6C                 ;org 2E6Ch
.xdata$x:00002E6C ; COMDAT (pick associative to section at 1B20)
.xdata$x:00002E6C __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00002E6C                                         ; DATA XREF: .xdata$x:00002E7Co
.xdata$x:00002E6D                 db 0FFh
.xdata$x:00002E6E                 db 0FFh
.xdata$x:00002E6F                 db 0FFh
.xdata$x:00002E70                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00002E74 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00002E74                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00002E75                 db    5
.xdata$x:00002E76                 db  93h ; ô
.xdata$x:00002E77                 db  19h
.xdata$x:00002E78                 db    1
.xdata$x:00002E79                 db    0
.xdata$x:00002E7A                 db    0
.xdata$x:00002E7B                 db    0
.xdata$x:00002E7C                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00002E80                 db    0
.xdata$x:00002E81                 db    0
.xdata$x:00002E82                 db    0
.xdata$x:00002E83                 db    0
.xdata$x:00002E84                 db    0
.xdata$x:00002E85                 db    0
.xdata$x:00002E86                 db    0
.xdata$x:00002E87                 db    0
.xdata$x:00002E88                 db    0
.xdata$x:00002E89                 db    0
.xdata$x:00002E8A                 db    0
.xdata$x:00002E8B                 db    0
.xdata$x:00002E8C                 db    0
.xdata$x:00002E8D                 db    0
.xdata$x:00002E8E                 db    0
.xdata$x:00002E8F                 db    0
.xdata$x:00002E90                 db    0
.xdata$x:00002E91                 db    0
.xdata$x:00002E92                 db    0
.xdata$x:00002E93                 db    0
.xdata$x:00002E94                 db    0
.xdata$x:00002E95                 db    0
.xdata$x:00002E96                 db    0
.xdata$x:00002E97                 db    0
.xdata$x:00002E97 _xdata$x        ends
.xdata$x:00002E97
.xdata$x:00002E98 ; ===========================================================================
.xdata$x:00002E98
.xdata$x:00002E98 ; Segment type: Pure data
.xdata$x:00002E98 ; Segment permissions: Read
.xdata$x:00002E98 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E98                 assume cs:_xdata$x
.xdata$x:00002E98                 ;org 2E98h
.xdata$x:00002E98 ; COMDAT (pick associative to section at 1FB8)
.xdata$x:00002E98 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00002E98                                         ; DATA XREF: .xdata$x:00002F20o
.xdata$x:00002E99                 db    0
.xdata$x:00002E9A                 db    0
.xdata$x:00002E9B                 db    0
.xdata$x:00002E9C                 db    0
.xdata$x:00002E9D                 db    0
.xdata$x:00002E9E                 db    0
.xdata$x:00002E9F                 db    0
.xdata$x:00002EA0                 db    0
.xdata$x:00002EA1                 db    0
.xdata$x:00002EA2                 db    0
.xdata$x:00002EA3                 db    0
.xdata$x:00002EA4                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00002EA8 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00002EA8                                         ; DATA XREF: .xdata$x:00002F0Co
.xdata$x:00002EA9                 db    0
.xdata$x:00002EAA                 db    0
.xdata$x:00002EAB                 db    0
.xdata$x:00002EAC                 db    0
.xdata$x:00002EAD                 db    0
.xdata$x:00002EAE                 db    0
.xdata$x:00002EAF                 db    0
.xdata$x:00002EB0                 db    0
.xdata$x:00002EB1                 db    0
.xdata$x:00002EB2                 db    0
.xdata$x:00002EB3                 db    0
.xdata$x:00002EB4                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00002EB8 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002EB8                                         ; DATA XREF: .xdata$x:00002EE0o
.xdata$x:00002EB9                 db 0FFh
.xdata$x:00002EBA                 db 0FFh
.xdata$x:00002EBB                 db 0FFh
.xdata$x:00002EBC                 db    0
.xdata$x:00002EBD                 db    0
.xdata$x:00002EBE                 db    0
.xdata$x:00002EBF                 db    0
.xdata$x:00002EC0                 db 0FFh
.xdata$x:00002EC1                 db 0FFh
.xdata$x:00002EC2                 db 0FFh
.xdata$x:00002EC3                 db 0FFh
.xdata$x:00002EC4                 db    0
.xdata$x:00002EC5                 db    0
.xdata$x:00002EC6                 db    0
.xdata$x:00002EC7                 db    0
.xdata$x:00002EC8                 db    1
.xdata$x:00002EC9                 db    0
.xdata$x:00002ECA                 db    0
.xdata$x:00002ECB                 db    0
.xdata$x:00002ECC                 db    0
.xdata$x:00002ECD                 db    0
.xdata$x:00002ECE                 db    0
.xdata$x:00002ECF                 db    0
.xdata$x:00002ED0                 db    1
.xdata$x:00002ED1                 db    0
.xdata$x:00002ED2                 db    0
.xdata$x:00002ED3                 db    0
.xdata$x:00002ED4                 db    0
.xdata$x:00002ED5                 db    0
.xdata$x:00002ED6                 db    0
.xdata$x:00002ED7                 db    0
.xdata$x:00002ED8 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00002ED8                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00002ED9                 db    5
.xdata$x:00002EDA                 db  93h ; ô
.xdata$x:00002EDB                 db  19h
.xdata$x:00002EDC                 db    4
.xdata$x:00002EDD                 db    0
.xdata$x:00002EDE                 db    0
.xdata$x:00002EDF                 db    0
.xdata$x:00002EE0                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002EE4                 db    2
.xdata$x:00002EE5                 db    0
.xdata$x:00002EE6                 db    0
.xdata$x:00002EE7                 db    0
.xdata$x:00002EE8                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002EEC                 db    0
.xdata$x:00002EED                 db    0
.xdata$x:00002EEE                 db    0
.xdata$x:00002EEF                 db    0
.xdata$x:00002EF0                 db    0
.xdata$x:00002EF1                 db    0
.xdata$x:00002EF2                 db    0
.xdata$x:00002EF3                 db    0
.xdata$x:00002EF4                 db    0
.xdata$x:00002EF5                 db    0
.xdata$x:00002EF6                 db    0
.xdata$x:00002EF7                 db    0
.xdata$x:00002EF8                 db    0
.xdata$x:00002EF9                 db    0
.xdata$x:00002EFA                 db    0
.xdata$x:00002EFB                 db    0
.xdata$x:00002EFC __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00002EFC                                         ; DATA XREF: .xdata$x:00002EE8o
.xdata$x:00002EFD                 db    0
.xdata$x:00002EFE                 db    0
.xdata$x:00002EFF                 db    0
.xdata$x:00002F00                 db    2
.xdata$x:00002F01                 db    0
.xdata$x:00002F02                 db    0
.xdata$x:00002F03                 db    0
.xdata$x:00002F04                 db    3
.xdata$x:00002F05                 db    0
.xdata$x:00002F06                 db    0
.xdata$x:00002F07                 db    0
.xdata$x:00002F08                 db    1
.xdata$x:00002F09                 db    0
.xdata$x:00002F0A                 db    0
.xdata$x:00002F0B                 db    0
.xdata$x:00002F0C                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00002F10                 db    0
.xdata$x:00002F11                 db    0
.xdata$x:00002F12                 db    0
.xdata$x:00002F13                 db    0
.xdata$x:00002F14                 db    0
.xdata$x:00002F15                 db    0
.xdata$x:00002F16                 db    0
.xdata$x:00002F17                 db    0
.xdata$x:00002F18                 db    3
.xdata$x:00002F19                 db    0
.xdata$x:00002F1A                 db    0
.xdata$x:00002F1B                 db    0
.xdata$x:00002F1C                 db    1
.xdata$x:00002F1D                 db    0
.xdata$x:00002F1E                 db    0
.xdata$x:00002F1F                 db    0
.xdata$x:00002F20                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00002F20 _xdata$x        ends
.xdata$x:00002F20
.xdata$x:00002F24 ; ===========================================================================
.xdata$x:00002F24
.xdata$x:00002F24 ; Segment type: Pure data
.xdata$x:00002F24 ; Segment permissions: Read
.xdata$x:00002F24 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F24                 assume cs:_xdata$x
.xdata$x:00002F24                 ;org 2F24h
.xdata$x:00002F24 ; COMDAT (pick associative to section at 1860)
.xdata$x:00002F24 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002F24                                         ; DATA XREF: .xdata$x:00002F34o
.xdata$x:00002F25                 db 0FFh
.xdata$x:00002F26                 db 0FFh
.xdata$x:00002F27                 db 0FFh
.xdata$x:00002F28                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00002F2C __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002F2C                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00002F2D                 db    5
.xdata$x:00002F2E                 db  93h ; ô
.xdata$x:00002F2F                 db  19h
.xdata$x:00002F30                 db    1
.xdata$x:00002F31                 db    0
.xdata$x:00002F32                 db    0
.xdata$x:00002F33                 db    0
.xdata$x:00002F34                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00002F38                 db    0
.xdata$x:00002F39                 db    0
.xdata$x:00002F3A                 db    0
.xdata$x:00002F3B                 db    0
.xdata$x:00002F3C                 db    0
.xdata$x:00002F3D                 db    0
.xdata$x:00002F3E                 db    0
.xdata$x:00002F3F                 db    0
.xdata$x:00002F40                 db    0
.xdata$x:00002F41                 db    0
.xdata$x:00002F42                 db    0
.xdata$x:00002F43                 db    0
.xdata$x:00002F44                 db    0
.xdata$x:00002F45                 db    0
.xdata$x:00002F46                 db    0
.xdata$x:00002F47                 db    0
.xdata$x:00002F48                 db    0
.xdata$x:00002F49                 db    0
.xdata$x:00002F4A                 db    0
.xdata$x:00002F4B                 db    0
.xdata$x:00002F4C                 db    0
.xdata$x:00002F4D                 db    0
.xdata$x:00002F4E                 db    0
.xdata$x:00002F4F                 db    0
.xdata$x:00002F4F _xdata$x        ends
.xdata$x:00002F4F
.xdata$x:00002F50 ; ===========================================================================
.xdata$x:00002F50
.xdata$x:00002F50 ; Segment type: Pure data
.xdata$x:00002F50 ; Segment permissions: Read
.xdata$x:00002F50 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F50                 assume cs:_xdata$x
.xdata$x:00002F50                 ;org 2F50h
.xdata$x:00002F50 ; COMDAT (pick associative to section at 2A68)
.xdata$x:00002F50 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002F50                                         ; DATA XREF: .xdata$x:00002F60o
.xdata$x:00002F51                 db 0FFh
.xdata$x:00002F52                 db 0FFh
.xdata$x:00002F53                 db 0FFh
.xdata$x:00002F54                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002F58 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002F58                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002F59                 db    5
.xdata$x:00002F5A                 db  93h ; ô
.xdata$x:00002F5B                 db  19h
.xdata$x:00002F5C                 db    1
.xdata$x:00002F5D                 db    0
.xdata$x:00002F5E                 db    0
.xdata$x:00002F5F                 db    0
.xdata$x:00002F60                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002F64                 db    0
.xdata$x:00002F65                 db    0
.xdata$x:00002F66                 db    0
.xdata$x:00002F67                 db    0
.xdata$x:00002F68                 db    0
.xdata$x:00002F69                 db    0
.xdata$x:00002F6A                 db    0
.xdata$x:00002F6B                 db    0
.xdata$x:00002F6C                 db    0
.xdata$x:00002F6D                 db    0
.xdata$x:00002F6E                 db    0
.xdata$x:00002F6F                 db    0
.xdata$x:00002F70                 db    0
.xdata$x:00002F71                 db    0
.xdata$x:00002F72                 db    0
.xdata$x:00002F73                 db    0
.xdata$x:00002F74                 db    0
.xdata$x:00002F75                 db    0
.xdata$x:00002F76                 db    0
.xdata$x:00002F77                 db    0
.xdata$x:00002F78                 db    0
.xdata$x:00002F79                 db    0
.xdata$x:00002F7A                 db    0
.xdata$x:00002F7B                 db    0
.xdata$x:00002F7B _xdata$x        ends
.xdata$x:00002F7B
.xdata$x:00002F7C ; ===========================================================================
.xdata$x:00002F7C
.xdata$x:00002F7C ; Segment type: Pure data
.xdata$x:00002F7C ; Segment permissions: Read
.xdata$x:00002F7C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F7C                 assume cs:_xdata$x
.xdata$x:00002F7C                 ;org 2F7Ch
.xdata$x:00002F7C ; COMDAT (pick associative to section at 1BB0)
.xdata$x:00002F7C __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002F7C                                         ; DATA XREF: .xdata$x:00002F8Co
.xdata$x:00002F7D                 db 0FFh
.xdata$x:00002F7E                 db 0FFh
.xdata$x:00002F7F                 db 0FFh
.xdata$x:00002F80                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00002F84 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002F84                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00002F85                 db    5
.xdata$x:00002F86                 db  93h ; ô
.xdata$x:00002F87                 db  19h
.xdata$x:00002F88                 db    1
.xdata$x:00002F89                 db    0
.xdata$x:00002F8A                 db    0
.xdata$x:00002F8B                 db    0
.xdata$x:00002F8C                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00002F90                 db    0
.xdata$x:00002F91                 db    0
.xdata$x:00002F92                 db    0
.xdata$x:00002F93                 db    0
.xdata$x:00002F94                 db    0
.xdata$x:00002F95                 db    0
.xdata$x:00002F96                 db    0
.xdata$x:00002F97                 db    0
.xdata$x:00002F98                 db    0
.xdata$x:00002F99                 db    0
.xdata$x:00002F9A                 db    0
.xdata$x:00002F9B                 db    0
.xdata$x:00002F9C                 db    0
.xdata$x:00002F9D                 db    0
.xdata$x:00002F9E                 db    0
.xdata$x:00002F9F                 db    0
.xdata$x:00002FA0                 db    0
.xdata$x:00002FA1                 db    0
.xdata$x:00002FA2                 db    0
.xdata$x:00002FA3                 db    0
.xdata$x:00002FA4                 db    0
.xdata$x:00002FA5                 db    0
.xdata$x:00002FA6                 db    0
.xdata$x:00002FA7                 db    0
.xdata$x:00002FA7 _xdata$x        ends
.xdata$x:00002FA7
.xdata$x:00002FA8 ; ===========================================================================
.xdata$x:00002FA8
.xdata$x:00002FA8 ; Segment type: Pure data
.xdata$x:00002FA8 ; Segment permissions: Read
.xdata$x:00002FA8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002FA8                 assume cs:_xdata$x
.xdata$x:00002FA8                 ;org 2FA8h
.xdata$x:00002FA8 ; COMDAT (pick associative to section at 18EC)
.xdata$x:00002FA8 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002FA8                                         ; DATA XREF: .xdata$x:00002FB8o
.xdata$x:00002FA9                 db 0FFh
.xdata$x:00002FAA                 db 0FFh
.xdata$x:00002FAB                 db 0FFh
.xdata$x:00002FAC                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002FB0 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002FB0                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002FB1                 db    5
.xdata$x:00002FB2                 db  93h ; ô
.xdata$x:00002FB3                 db  19h
.xdata$x:00002FB4                 db    1
.xdata$x:00002FB5                 db    0
.xdata$x:00002FB6                 db    0
.xdata$x:00002FB7                 db    0
.xdata$x:00002FB8                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00002FBC                 db    0
.xdata$x:00002FBD                 db    0
.xdata$x:00002FBE                 db    0
.xdata$x:00002FBF                 db    0
.xdata$x:00002FC0                 db    0
.xdata$x:00002FC1                 db    0
.xdata$x:00002FC2                 db    0
.xdata$x:00002FC3                 db    0
.xdata$x:00002FC4                 db    0
.xdata$x:00002FC5                 db    0
.xdata$x:00002FC6                 db    0
.xdata$x:00002FC7                 db    0
.xdata$x:00002FC8                 db    0
.xdata$x:00002FC9                 db    0
.xdata$x:00002FCA                 db    0
.xdata$x:00002FCB                 db    0
.xdata$x:00002FCC                 db    0
.xdata$x:00002FCD                 db    0
.xdata$x:00002FCE                 db    0
.xdata$x:00002FCF                 db    0
.xdata$x:00002FD0                 db    0
.xdata$x:00002FD1                 db    0
.xdata$x:00002FD2                 db    0
.xdata$x:00002FD3                 db    0
.xdata$x:00002FD3 _xdata$x        ends
.xdata$x:00002FD3
.xdata$x:00002FD4 ; ===========================================================================
.xdata$x:00002FD4
.xdata$x:00002FD4 ; Segment type: Pure data
.xdata$x:00002FD4 ; Segment permissions: Read
.xdata$x:00002FD4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002FD4                 assume cs:_xdata$x
.xdata$x:00002FD4                 ;org 2FD4h
.xdata$x:00002FD4 ; COMDAT (pick associative to section at 2B20)
.xdata$x:00002FD4 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002FD4                                         ; DATA XREF: .xdata$x:00002FE4o
.xdata$x:00002FD5                 db 0FFh
.xdata$x:00002FD6                 db 0FFh
.xdata$x:00002FD7                 db 0FFh
.xdata$x:00002FD8                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002FDC __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002FDC                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002FDD                 db    5
.xdata$x:00002FDE                 db  93h ; ô
.xdata$x:00002FDF                 db  19h
.xdata$x:00002FE0                 db    1
.xdata$x:00002FE1                 db    0
.xdata$x:00002FE2                 db    0
.xdata$x:00002FE3                 db    0
.xdata$x:00002FE4                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002FE8                 align 20h
.xdata$x:00002FE8 _xdata$x        ends
.xdata$x:00002FE8
.xdata$x:00003000 ; ===========================================================================
.xdata$x:00003000
.xdata$x:00003000 ; Segment type: Pure data
.xdata$x:00003000 ; Segment permissions: Read
.xdata$x:00003000 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003000                 assume cs:_xdata$x
.xdata$x:00003000                 ;org 3000h
.xdata$x:00003000 ; COMDAT (pick associative to section at 1C20)
.xdata$x:00003000 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00003000                                         ; DATA XREF: .xdata$x:00003010o
.xdata$x:00003001                 db 0FFh
.xdata$x:00003002                 db 0FFh
.xdata$x:00003003                 db 0FFh
.xdata$x:00003004                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00003008 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00003008                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00003009                 db    5
.xdata$x:0000300A                 db  93h ; ô
.xdata$x:0000300B                 db  19h
.xdata$x:0000300C                 db    1
.xdata$x:0000300D                 db    0
.xdata$x:0000300E                 db    0
.xdata$x:0000300F                 db    0
.xdata$x:00003010                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00003014                 db    0
.xdata$x:00003015                 db    0
.xdata$x:00003016                 db    0
.xdata$x:00003017                 db    0
.xdata$x:00003018                 db    0
.xdata$x:00003019                 db    0
.xdata$x:0000301A                 db    0
.xdata$x:0000301B                 db    0
.xdata$x:0000301C                 db    0
.xdata$x:0000301D                 db    0
.xdata$x:0000301E                 db    0
.xdata$x:0000301F                 db    0
.xdata$x:00003020                 db    0
.xdata$x:00003021                 db    0
.xdata$x:00003022                 db    0
.xdata$x:00003023                 db    0
.xdata$x:00003024                 db    0
.xdata$x:00003025                 db    0
.xdata$x:00003026                 db    0
.xdata$x:00003027                 db    0
.xdata$x:00003028                 db    0
.xdata$x:00003029                 db    0
.xdata$x:0000302A                 db    0
.xdata$x:0000302B                 db    0
.xdata$x:0000302B _xdata$x        ends
.xdata$x:0000302B
.xdata$x:0000302C ; ===========================================================================
.xdata$x:0000302C
.xdata$x:0000302C ; Segment type: Pure data
.xdata$x:0000302C ; Segment permissions: Read
.xdata$x:0000302C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000302C                 assume cs:_xdata$x
.xdata$x:0000302C                 ;org 302Ch
.xdata$x:0000302C ; COMDAT (pick associative to section at 1968)
.xdata$x:0000302C __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000302C                                         ; DATA XREF: .xdata$x:0000303Co
.xdata$x:0000302D                 db 0FFh
.xdata$x:0000302E                 db 0FFh
.xdata$x:0000302F                 db 0FFh
.xdata$x:00003030                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00003034 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00003034                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00003035                 db    5
.xdata$x:00003036                 db  93h ; ô
.xdata$x:00003037                 db  19h
.xdata$x:00003038                 db    1
.xdata$x:00003039                 db    0
.xdata$x:0000303A                 db    0
.xdata$x:0000303B                 db    0
.xdata$x:0000303C                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00003040                 db    0
.xdata$x:00003041                 db    0
.xdata$x:00003042                 db    0
.xdata$x:00003043                 db    0
.xdata$x:00003044                 db    0
.xdata$x:00003045                 db    0
.xdata$x:00003046                 db    0
.xdata$x:00003047                 db    0
.xdata$x:00003048                 db    0
.xdata$x:00003049                 db    0
.xdata$x:0000304A                 db    0
.xdata$x:0000304B                 db    0
.xdata$x:0000304C                 db    0
.xdata$x:0000304D                 db    0
.xdata$x:0000304E                 db    0
.xdata$x:0000304F                 db    0
.xdata$x:00003050                 db    0
.xdata$x:00003051                 db    0
.xdata$x:00003052                 db    0
.xdata$x:00003053                 db    0
.xdata$x:00003054                 db    0
.xdata$x:00003055                 db    0
.xdata$x:00003056                 db    0
.xdata$x:00003057                 db    0
.xdata$x:00003057 _xdata$x        ends
.xdata$x:00003057
.xdata$x:00003058 ; ===========================================================================
.xdata$x:00003058
.xdata$x:00003058 ; Segment type: Pure data
.xdata$x:00003058 ; Segment permissions: Read
.xdata$x:00003058 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003058                 assume cs:_xdata$x
.xdata$x:00003058                 ;org 3058h
.xdata$x:00003058 ; COMDAT (pick associative to section at 2BE4)
.xdata$x:00003058 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00003058                                         ; DATA XREF: .xdata$x:00003068o
.xdata$x:00003059                 db 0FFh
.xdata$x:0000305A                 db 0FFh
.xdata$x:0000305B                 db 0FFh
.xdata$x:0000305C                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00003060 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00003060                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00003061                 db    5
.xdata$x:00003062                 db  93h ; ô
.xdata$x:00003063                 db  19h
.xdata$x:00003064                 db    1
.xdata$x:00003065                 db    0
.xdata$x:00003066                 db    0
.xdata$x:00003067                 db    0
.xdata$x:00003068                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000306C                 db    0
.xdata$x:0000306D                 db    0
.xdata$x:0000306E                 db    0
.xdata$x:0000306F                 db    0
.xdata$x:00003070                 db    0
.xdata$x:00003071                 db    0
.xdata$x:00003072                 db    0
.xdata$x:00003073                 db    0
.xdata$x:00003074                 db    0
.xdata$x:00003075                 db    0
.xdata$x:00003076                 db    0
.xdata$x:00003077                 db    0
.xdata$x:00003078                 db    0
.xdata$x:00003079                 db    0
.xdata$x:0000307A                 db    0
.xdata$x:0000307B                 db    0
.xdata$x:0000307C                 db    0
.xdata$x:0000307D                 db    0
.xdata$x:0000307E                 db    0
.xdata$x:0000307F                 db    0
.xdata$x:00003080                 db    0
.xdata$x:00003081                 db    0
.xdata$x:00003082                 db    0
.xdata$x:00003083                 db    0
.xdata$x:00003083 _xdata$x        ends
.xdata$x:00003083
.xdata$x:00003084 ; ===========================================================================
.xdata$x:00003084
.xdata$x:00003084 ; Segment type: Pure data
.xdata$x:00003084 ; Segment permissions: Read
.xdata$x:00003084 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003084                 assume cs:_xdata$x
.xdata$x:00003084                 ;org 3084h
.xdata$x:00003084 ; COMDAT (pick associative to section at 1C90)
.xdata$x:00003084 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00003084                                         ; DATA XREF: .xdata$x:00003094o
.xdata$x:00003085                 db 0FFh
.xdata$x:00003086                 db 0FFh
.xdata$x:00003087                 db 0FFh
.xdata$x:00003088                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:0000308C __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000308C                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:0000308D                 db    5
.xdata$x:0000308E                 db  93h ; ô
.xdata$x:0000308F                 db  19h
.xdata$x:00003090                 db    1
.xdata$x:00003091                 db    0
.xdata$x:00003092                 db    0
.xdata$x:00003093                 db    0
.xdata$x:00003094                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00003098                 db    0
.xdata$x:00003099                 db    0
.xdata$x:0000309A                 db    0
.xdata$x:0000309B                 db    0
.xdata$x:0000309C                 db    0
.xdata$x:0000309D                 db    0
.xdata$x:0000309E                 db    0
.xdata$x:0000309F                 db    0
.xdata$x:000030A0                 db    0
.xdata$x:000030A1                 db    0
.xdata$x:000030A2                 db    0
.xdata$x:000030A3                 db    0
.xdata$x:000030A4                 db    0
.xdata$x:000030A5                 db    0
.xdata$x:000030A6                 db    0
.xdata$x:000030A7                 db    0
.xdata$x:000030A8                 db    0
.xdata$x:000030A9                 db    0
.xdata$x:000030AA                 db    0
.xdata$x:000030AB                 db    0
.xdata$x:000030AC                 db    0
.xdata$x:000030AD                 db    0
.xdata$x:000030AE                 db    0
.xdata$x:000030AF                 db    0
.xdata$x:000030AF _xdata$x        ends
.xdata$x:000030AF
.xdata$x:000030B0 ; ===========================================================================
.xdata$x:000030B0
.xdata$x:000030B0 ; Segment type: Pure data
.xdata$x:000030B0 ; Segment permissions: Read
.xdata$x:000030B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000030B0                 assume cs:_xdata$x
.xdata$x:000030B0                 ;org 30B0h
.xdata$x:000030B0 ; COMDAT (pick associative to section at 1534)
.xdata$x:000030B0 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:000030B0                                         ; DATA XREF: .xdata$x:000030C0o
.xdata$x:000030B1                 db 0FFh
.xdata$x:000030B2                 db 0FFh
.xdata$x:000030B3                 db 0FFh
.xdata$x:000030B4                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:000030B8 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:000030B8                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:000030B9                 db    5
.xdata$x:000030BA                 db  93h ; ô
.xdata$x:000030BB                 db  19h
.xdata$x:000030BC                 db    1
.xdata$x:000030BD                 db    0
.xdata$x:000030BE                 db    0
.xdata$x:000030BF                 db    0
.xdata$x:000030C0                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:000030C4                 db    0
.xdata$x:000030C5                 db    0
.xdata$x:000030C6                 db    0
.xdata$x:000030C7                 db    0
.xdata$x:000030C8                 db    0
.xdata$x:000030C9                 db    0
.xdata$x:000030CA                 db    0
.xdata$x:000030CB                 db    0
.xdata$x:000030CC                 db    0
.xdata$x:000030CD                 db    0
.xdata$x:000030CE                 db    0
.xdata$x:000030CF                 db    0
.xdata$x:000030D0                 db    0
.xdata$x:000030D1                 db    0
.xdata$x:000030D2                 db    0
.xdata$x:000030D3                 db    0
.xdata$x:000030D4                 db    0
.xdata$x:000030D5                 db    0
.xdata$x:000030D6                 db    0
.xdata$x:000030D7                 db    0
.xdata$x:000030D8                 db    0
.xdata$x:000030D9                 db    0
.xdata$x:000030DA                 db    0
.xdata$x:000030DB                 db    0
.xdata$x:000030DB _xdata$x        ends
.xdata$x:000030DB
.xdata$x:000030DC ; ===========================================================================
.xdata$x:000030DC
.xdata$x:000030DC ; Segment type: Pure data
.xdata$x:000030DC ; Segment permissions: Read
.xdata$x:000030DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000030DC                 assume cs:_xdata$x
.xdata$x:000030DC                 ;org 30DCh
.xdata$x:000030DC ; COMDAT (pick associative to section at 1460)
.xdata$x:000030DC __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:000030DC                                         ; DATA XREF: .xdata$x:000030ECo
.xdata$x:000030DD                 db 0FFh
.xdata$x:000030DE                 db 0FFh
.xdata$x:000030DF                 db 0FFh
.xdata$x:000030E0                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:000030E4 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:000030E4                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:000030E5                 db    5
.xdata$x:000030E6                 db  93h ; ô
.xdata$x:000030E7                 db  19h
.xdata$x:000030E8                 db    1
.xdata$x:000030E9                 db    0
.xdata$x:000030EA                 db    0
.xdata$x:000030EB                 db    0
.xdata$x:000030EC                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:000030F0                 db    0
.xdata$x:000030F1                 db    0
.xdata$x:000030F2                 db    0
.xdata$x:000030F3                 db    0
.xdata$x:000030F4                 db    0
.xdata$x:000030F5                 db    0
.xdata$x:000030F6                 db    0
.xdata$x:000030F7                 db    0
.xdata$x:000030F8                 db    0
.xdata$x:000030F9                 db    0
.xdata$x:000030FA                 db    0
.xdata$x:000030FB                 db    0
.xdata$x:000030FC                 db    0
.xdata$x:000030FD                 db    0
.xdata$x:000030FE                 db    0
.xdata$x:000030FF                 db    0
.xdata$x:00003100                 db    0
.xdata$x:00003101                 db    0
.xdata$x:00003102                 db    0
.xdata$x:00003103                 db    0
.xdata$x:00003104                 db    0
.xdata$x:00003105                 db    0
.xdata$x:00003106                 db    0
.xdata$x:00003107                 db    0
.xdata$x:00003107 _xdata$x        ends
.xdata$x:00003107
.bss:00003108 ; ===========================================================================
.bss:00003108
.bss:00003108 ; Segment type: Uninitialized
.bss:00003108 ; Segment permissions: Read/Write
.bss:00003108 _bss            segment byte public 'BSS' use32
.bss:00003108                 assume cs:_bss
.bss:00003108                 ;org 3108h
.bss:00003108                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003108 __Tuple_alloc   db    ? ;
.bss:00003109 ; std::_Ignore ignore
.bss:00003109 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:0000310A _allocator_arg  db    ? ;
.bss:0000310B _piecewise_construct db    ? ;
.bss:0000310B _bss            ends
.bss:0000310B
.rdata:0000310C ; ===========================================================================
.rdata:0000310C
.rdata:0000310C ; Segment type: Pure data
.rdata:0000310C ; Segment permissions: Read
.rdata:0000310C _rdata          segment dword public 'DATA' use32
.rdata:0000310C                 assume cs:_rdata
.rdata:0000310C                 ;org 310Ch
.rdata:0000310C ; COMDAT (pick largest)
.rdata:0000310C                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00003110                 public ??_7error_category@std@@6B@
.rdata:00003110 ; const std::error_category::`vftable'
.rdata:00003110 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00003110                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00003110                                         ; std::error_category::~error_category(void)+Ao
.rdata:00003110                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00003114                 dd offset __purecall
.rdata:00003118                 dd offset __purecall
.rdata:0000311C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003120                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003124                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003124 _rdata          ends
.rdata:00003124
.rdata:00003128 ; ===========================================================================
.rdata:00003128
.rdata:00003128 ; Segment type: Pure data
.rdata:00003128 ; Segment permissions: Read
.rdata:00003128 _rdata          segment dword public 'DATA' use32
.rdata:00003128                 assume cs:_rdata
.rdata:00003128                 ;org 3128h
.rdata:00003128 ; COMDAT (pick largest)
.rdata:00003128                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000312C                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000312C ; const std::_Generic_error_category::`vftable'
.rdata:0000312C ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000312C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000312C                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00003130                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00003134                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00003138                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000313C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003140                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003140 _rdata          ends
.rdata:00003140
.rdata:00003144 ; ===========================================================================
.rdata:00003144
.rdata:00003144 ; Segment type: Pure data
.rdata:00003144 ; Segment permissions: Read
.rdata:00003144 _rdata          segment dword public 'DATA' use32
.rdata:00003144                 assume cs:_rdata
.rdata:00003144                 ;org 3144h
.rdata:00003144 ; COMDAT (pick any)
.rdata:00003144                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00003144 ; `string'
.rdata:00003144 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00003144                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00003144 _rdata          ends
.rdata:00003144
.rdata:0000314C ; ===========================================================================
.rdata:0000314C
.rdata:0000314C ; Segment type: Pure data
.rdata:0000314C ; Segment permissions: Read
.rdata:0000314C _rdata          segment dword public 'DATA' use32
.rdata:0000314C                 assume cs:_rdata
.rdata:0000314C                 ;org 314Ch
.rdata:0000314C ; COMDAT (pick any)
.rdata:0000314C                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000314C ; `string'
.rdata:0000314C ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000314C                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_2AB4o
.rdata:0000314C                                         ; std::_System_error_category::message(int):loc_2C30o
.rdata:0000315A                 align 4
.rdata:0000315A _rdata          ends
.rdata:0000315A
.rdata:0000315C ; ===========================================================================
.rdata:0000315C
.rdata:0000315C ; Segment type: Pure data
.rdata:0000315C ; Segment permissions: Read
.rdata:0000315C _rdata          segment dword public 'DATA' use32
.rdata:0000315C                 assume cs:_rdata
.rdata:0000315C                 ;org 315Ch
.rdata:0000315C ; COMDAT (pick largest)
.rdata:0000315C                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00003160                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00003160 ; const std::_Iostream_error_category::`vftable'
.rdata:00003160 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00003160                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00003160                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00003164                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00003168                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:0000316C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003170                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003174                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003174 _rdata          ends
.rdata:00003174
.rdata:00003178 ; ===========================================================================
.rdata:00003178
.rdata:00003178 ; Segment type: Pure data
.rdata:00003178 ; Segment permissions: Read
.rdata:00003178 _rdata          segment dword public 'DATA' use32
.rdata:00003178                 assume cs:_rdata
.rdata:00003178                 ;org 3178h
.rdata:00003178 ; COMDAT (pick any)
.rdata:00003178                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00003178 ; `string'
.rdata:00003178 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00003178                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00003181                 align 4
.rdata:00003181 _rdata          ends
.rdata:00003181
.rdata:00003184 ; ===========================================================================
.rdata:00003184
.rdata:00003184 ; Segment type: Pure data
.rdata:00003184 ; Segment permissions: Read
.rdata:00003184 _rdata          segment dword public 'DATA' use32
.rdata:00003184                 assume cs:_rdata
.rdata:00003184                 ;org 3184h
.rdata:00003184 ; COMDAT (pick any)
.rdata:00003184                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00003184 ; char `string'[]
.rdata:00003184 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00003184                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000319A                 align 4
.rdata:0000319A _rdata          ends
.rdata:0000319A
.rdata:0000319C ; ===========================================================================
.rdata:0000319C
.rdata:0000319C ; Segment type: Pure data
.rdata:0000319C ; Segment permissions: Read
.rdata:0000319C _rdata          segment dword public 'DATA' use32
.rdata:0000319C                 assume cs:_rdata
.rdata:0000319C                 ;org 319Ch
.rdata:0000319C ; COMDAT (pick largest)
.rdata:0000319C                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:000031A0                 public ??_7_System_error_category@std@@6B@
.rdata:000031A0 ; const std::_System_error_category::`vftable'
.rdata:000031A0 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:000031A0                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:000031A0                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:000031A4                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:000031A8                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:000031AC                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:000031B0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000031B4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000031B4 _rdata          ends
.rdata:000031B4
.rdata:000031B8 ; ===========================================================================
.rdata:000031B8
.rdata:000031B8 ; Segment type: Pure data
.rdata:000031B8 ; Segment permissions: Read
.rdata:000031B8 _rdata          segment dword public 'DATA' use32
.rdata:000031B8                 assume cs:_rdata
.rdata:000031B8                 ;org 31B8h
.rdata:000031B8 ; COMDAT (pick any)
.rdata:000031B8                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:000031B8 ; `string'
.rdata:000031B8 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:000031B8                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:000031BF                 align 10h
.rdata:000031BF _rdata          ends
.rdata:000031BF
.bss:000031C0 ; ===========================================================================
.bss:000031C0
.bss:000031C0 ; Segment type: Uninitialized
.bss:000031C0 ; Segment permissions: Read/Write
.bss:000031C0 _bss            segment dword public 'BSS' use32
.bss:000031C0                 assume cs:_bss
.bss:000031C0                 ;org 31C0h
.bss:000031C0 ; COMDAT (pick any)
.bss:000031C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000031C0                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:000031C0 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:000031C0 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:000031C0                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:000031C0                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:000031C1                 db    ? ;
.bss:000031C2                 db    ? ;
.bss:000031C3                 db    ? ;
.bss:000031C3 _bss            ends
.bss:000031C3
.bss:000031C4 ; ===========================================================================
.bss:000031C4
.bss:000031C4 ; Segment type: Uninitialized
.bss:000031C4 ; Segment permissions: Read/Write
.bss:000031C4 _bss            segment dword public 'BSS' use32
.bss:000031C4                 assume cs:_bss
.bss:000031C4                 ;org 31C4h
.bss:000031C4 ; COMDAT (pick any)
.bss:000031C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000031C4                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:000031C4 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:000031C4 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:000031C4                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000031C4                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000031C5                 db    ? ;
.bss:000031C6                 db    ? ;
.bss:000031C7                 db    ? ;
.bss:000031C7 _bss            ends
.bss:000031C7
.bss:000031C8 ; ===========================================================================
.bss:000031C8
.bss:000031C8 ; Segment type: Uninitialized
.bss:000031C8 ; Segment permissions: Read/Write
.bss:000031C8 _bss            segment dword public 'BSS' use32
.bss:000031C8                 assume cs:_bss
.bss:000031C8                 ;org 31C8h
.bss:000031C8 ; COMDAT (pick any)
.bss:000031C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000031C8                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:000031C8 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:000031C8 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:000031C8                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:000031C8                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:000031C9                 db    ? ;
.bss:000031CA                 db    ? ;
.bss:000031CB                 db    ? ;
.bss:000031CB _bss            ends
.bss:000031CB
.bss:000031CC ; ===========================================================================
.bss:000031CC
.bss:000031CC ; Segment type: Uninitialized
.bss:000031CC ; Segment permissions: Read/Write
.bss:000031CC _bss            segment dword public 'BSS' use32
.bss:000031CC                 assume cs:_bss
.bss:000031CC                 ;org 31CCh
.bss:000031CC ; COMDAT (pick any)
.bss:000031CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000031CC                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:000031CC ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:000031CC ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:000031CC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:000031CD                 db    ? ;
.bss:000031CE                 db    ? ;
.bss:000031CF                 db    ? ;
.bss:000031CF _bss            ends
.bss:000031CF
.bss:000031D0 ; ===========================================================================
.bss:000031D0
.bss:000031D0 ; Segment type: Uninitialized
.bss:000031D0 ; Segment permissions: Read/Write
.bss:000031D0 _bss            segment dword public 'BSS' use32
.bss:000031D0                 assume cs:_bss
.bss:000031D0                 ;org 31D0h
.bss:000031D0 ; COMDAT (pick any)
.bss:000031D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000031D0                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:000031D0 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:000031D0 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:000031D0                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:000031D1                 db    ? ;
.bss:000031D2                 db    ? ;
.bss:000031D3                 db    ? ;
.bss:000031D3 _bss            ends
.bss:000031D3
.rdata:000031D4 ; ===========================================================================
.rdata:000031D4
.rdata:000031D4 ; Segment type: Pure data
.rdata:000031D4 ; Segment permissions: Read
.rdata:000031D4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000031D4 _rdata          segment para public 'DATA' use32
.rdata:000031D4                 assume cs:_rdata
.rdata:000031D4                 ;org 31D4h
.rdata:000031D4 ; COMDAT (pick any)
.rdata:000031D4                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000031D4 ; wchar_t `string'
.rdata:000031D4 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000031D4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:000031D4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:000031D4                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:000031D4                 unicode 0, <clude\xstring>,0
.rdata:00003262                 align 4
.rdata:00003262 _rdata          ends
.rdata:00003262
.bss:00003264 ; ===========================================================================
.bss:00003264
.bss:00003264 ; Segment type: Uninitialized
.bss:00003264 ; Segment permissions: Read/Write
.bss:00003264 _bss            segment dword public 'BSS' use32
.bss:00003264                 assume cs:_bss
.bss:00003264                 ;org 3264h
.bss:00003264 ; COMDAT (pick any)
.bss:00003264                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003264                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00003264 ; std::locale::id std::numpunct<char>::id
.bss:00003264 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00003264                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00003265                 db    ? ;
.bss:00003266                 db    ? ;
.bss:00003267                 db    ? ;
.bss:00003267 _bss            ends
.bss:00003267
.bss:00003268 ; ===========================================================================
.bss:00003268
.bss:00003268 ; Segment type: Uninitialized
.bss:00003268 ; Segment permissions: Read/Write
.bss:00003268 _bss            segment dword public 'BSS' use32
.bss:00003268                 assume cs:_bss
.bss:00003268                 ;org 3268h
.bss:00003268 ; COMDAT (pick any)
.bss:00003268                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003268                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00003268 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00003268 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00003268                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00003269                 db    ? ;
.bss:0000326A                 db    ? ;
.bss:0000326B                 db    ? ;
.bss:0000326B _bss            ends
.bss:0000326B
.rdata:0000326C ; ===========================================================================
.rdata:0000326C
.rdata:0000326C ; Segment type: Pure data
.rdata:0000326C ; Segment permissions: Read
.rdata:0000326C _rdata          segment dword public 'DATA' use32
.rdata:0000326C                 assume cs:_rdata
.rdata:0000326C                 ;org 326Ch
.rdata:0000326C ; COMDAT (pick any)
.rdata:0000326C                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000326C ; char `string'[]
.rdata:0000326C ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000326C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000326C _rdata          ends
.rdata:0000326C
.rdata:0000327C ; ===========================================================================
.rdata:0000327C
.rdata:0000327C ; Segment type: Pure data
.rdata:0000327C ; Segment permissions: Read
.rdata:0000327C _rdata          segment dword public 'DATA' use32
.rdata:0000327C                 assume cs:_rdata
.rdata:0000327C                 ;org 327Ch
.rdata:0000327C ; COMDAT (pick any)
.rdata:0000327C                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000327C ; char `string'[]
.rdata:0000327C ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000327C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000327C _rdata          ends
.rdata:0000327C
.rdata:00003294 ; ===========================================================================
.rdata:00003294
.rdata:00003294 ; Segment type: Pure data
.rdata:00003294 ; Segment permissions: Read
.rdata:00003294 _rdata          segment dword public 'DATA' use32
.rdata:00003294                 assume cs:_rdata
.rdata:00003294                 ;org 3294h
.rdata:00003294 ; COMDAT (pick any)
.rdata:00003294                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00003294 ; wchar_t `string'
.rdata:00003294 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00003294                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00003294                 unicode 0, <invalid null pointer>,0
.rdata:000032BE                 align 10h
.rdata:000032BE _rdata          ends
.rdata:000032BE
.rdata$r:000032C0 ; ===========================================================================
.rdata$r:000032C0
.rdata$r:000032C0 ; Segment type: Pure data
.rdata$r:000032C0 ; Segment permissions: Read
.rdata$r:000032C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000032C0                 assume cs:_rdata$r
.rdata$r:000032C0                 ;org 32C0h
.rdata$r:000032C0 ; COMDAT (pick any)
.rdata$r:000032C0                 public ??_R4error_category@std@@6B@
.rdata$r:000032C0 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:000032C0 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:0000310Co
.rdata$r:000032C1                 db    0
.rdata$r:000032C2                 db    0
.rdata$r:000032C3                 db    0
.rdata$r:000032C4                 db    0
.rdata$r:000032C5                 db    0
.rdata$r:000032C6                 db    0
.rdata$r:000032C7                 db    0
.rdata$r:000032C8                 db    0
.rdata$r:000032C9                 db    0
.rdata$r:000032CA                 db    0
.rdata$r:000032CB                 db    0
.rdata$r:000032CC                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:000032D0                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000032D0 _rdata$r        ends
.rdata$r:000032D0
.data$r:000032D4 ; ===========================================================================
.data$r:000032D4
.data$r:000032D4 ; Segment type: Pure data
.data$r:000032D4 ; Segment permissions: Read/Write
.data$r:000032D4 _data$r         segment dword public 'DATA' use32
.data$r:000032D4                 assume cs:_data$r
.data$r:000032D4                 ;org 32D4h
.data$r:000032D4 ; COMDAT (pick any)
.data$r:000032D4                 public ??_R0?AVerror_category@std@@@8
.data$r:000032D4 ; class std::error_category `RTTI Type Descriptor'
.data$r:000032D4 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000032D4                                         ; DATA XREF: .rdata$r:000032CCo
.data$r:000032D4                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000032D4                                         ; const type_info::`vftable'
.data$r:000032D8                 db    0
.data$r:000032D9                 db    0
.data$r:000032DA                 db    0
.data$r:000032DB                 db    0
.data$r:000032DC                 db  2Eh ; .
.data$r:000032DD                 db  3Fh ; ?
.data$r:000032DE                 db  41h ; A
.data$r:000032DF                 db  56h ; V
.data$r:000032E0                 db  65h ; e
.data$r:000032E1                 db  72h ; r
.data$r:000032E2                 db  72h ; r
.data$r:000032E3                 db  6Fh ; o
.data$r:000032E4                 db  72h ; r
.data$r:000032E5                 db  5Fh ; _
.data$r:000032E6                 db  63h ; c
.data$r:000032E7                 db  61h ; a
.data$r:000032E8                 db  74h ; t
.data$r:000032E9                 db  65h ; e
.data$r:000032EA                 db  67h ; g
.data$r:000032EB                 db  6Fh ; o
.data$r:000032EC                 db  72h ; r
.data$r:000032ED                 db  79h ; y
.data$r:000032EE                 db  40h ; @
.data$r:000032EF                 db  73h ; s
.data$r:000032F0                 db  74h ; t
.data$r:000032F1                 db  64h ; d
.data$r:000032F2                 db  40h ; @
.data$r:000032F3                 db  40h ; @
.data$r:000032F4                 db    0
.data$r:000032F5                 align 4
.data$r:000032F5 _data$r         ends
.data$r:000032F5
.rdata$r:000032F8 ; ===========================================================================
.rdata$r:000032F8
.rdata$r:000032F8 ; Segment type: Pure data
.rdata$r:000032F8 ; Segment permissions: Read
.rdata$r:000032F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000032F8                 assume cs:_rdata$r
.rdata$r:000032F8                 ;org 32F8h
.rdata$r:000032F8 ; COMDAT (pick any)
.rdata$r:000032F8                 public ??_R3error_category@std@@8
.rdata$r:000032F8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000032F8 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:000032D0o
.rdata$r:000032F8                                         ; .rdata$r:00003328o
.rdata$r:000032F9                 db    0
.rdata$r:000032FA                 db    0
.rdata$r:000032FB                 db    0
.rdata$r:000032FC                 db    0
.rdata$r:000032FD                 db    0
.rdata$r:000032FE                 db    0
.rdata$r:000032FF                 db    0
.rdata$r:00003300                 db    1
.rdata$r:00003301                 db    0
.rdata$r:00003302                 db    0
.rdata$r:00003303                 db    0
.rdata$r:00003304                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00003304 _rdata$r        ends
.rdata$r:00003304
.rdata$r:00003308 ; ===========================================================================
.rdata$r:00003308
.rdata$r:00003308 ; Segment type: Pure data
.rdata$r:00003308 ; Segment permissions: Read
.rdata$r:00003308 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003308                 assume cs:_rdata$r
.rdata$r:00003308                 ;org 3308h
.rdata$r:00003308 ; COMDAT (pick any)
.rdata$r:00003308                 public ??_R2error_category@std@@8
.rdata$r:00003308 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00003308 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00003308                                         ; DATA XREF: .rdata$r:00003304o
.rdata$r:00003308                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000330C                 db    0
.rdata$r:0000330D                 align 10h
.rdata$r:0000330D _rdata$r        ends
.rdata$r:0000330D
.rdata$r:00003310 ; ===========================================================================
.rdata$r:00003310
.rdata$r:00003310 ; Segment type: Pure data
.rdata$r:00003310 ; Segment permissions: Read
.rdata$r:00003310 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003310                 assume cs:_rdata$r
.rdata$r:00003310                 ;org 3310h
.rdata$r:00003310 ; COMDAT (pick any)
.rdata$r:00003310                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00003310 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003310 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00003310                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00003310                                         ; .rdata$r:00003380o ...
.rdata$r:00003310                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00003314                 db    0
.rdata$r:00003315                 db    0
.rdata$r:00003316                 db    0
.rdata$r:00003317                 db    0
.rdata$r:00003318                 db    0
.rdata$r:00003319                 db    0
.rdata$r:0000331A                 db    0
.rdata$r:0000331B                 db    0
.rdata$r:0000331C                 db 0FFh
.rdata$r:0000331D                 db 0FFh
.rdata$r:0000331E                 db 0FFh
.rdata$r:0000331F                 db 0FFh
.rdata$r:00003320                 db    0
.rdata$r:00003321                 db    0
.rdata$r:00003322                 db    0
.rdata$r:00003323                 db    0
.rdata$r:00003324                 db  40h ; @
.rdata$r:00003325                 db    0
.rdata$r:00003326                 db    0
.rdata$r:00003327                 db    0
.rdata$r:00003328                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003328 _rdata$r        ends
.rdata$r:00003328
.rdata$r:0000332C ; ===========================================================================
.rdata$r:0000332C
.rdata$r:0000332C ; Segment type: Pure data
.rdata$r:0000332C ; Segment permissions: Read
.rdata$r:0000332C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000332C                 assume cs:_rdata$r
.rdata$r:0000332C                 ;org 332Ch
.rdata$r:0000332C ; COMDAT (pick any)
.rdata$r:0000332C                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:0000332C ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:0000332C ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:0000332C                                         ; DATA XREF: .rdata:00003128o
.rdata$r:0000332D                 db    0
.rdata$r:0000332E                 db    0
.rdata$r:0000332F                 db    0
.rdata$r:00003330                 db    0
.rdata$r:00003331                 db    0
.rdata$r:00003332                 db    0
.rdata$r:00003333                 db    0
.rdata$r:00003334                 db    0
.rdata$r:00003335                 db    0
.rdata$r:00003336                 db    0
.rdata$r:00003337                 db    0
.rdata$r:00003338                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000333C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000333C _rdata$r        ends
.rdata$r:0000333C
.data$r:00003340 ; ===========================================================================
.data$r:00003340
.data$r:00003340 ; Segment type: Pure data
.data$r:00003340 ; Segment permissions: Read/Write
.data$r:00003340 _data$r         segment dword public 'DATA' use32
.data$r:00003340                 assume cs:_data$r
.data$r:00003340                 ;org 3340h
.data$r:00003340 ; COMDAT (pick any)
.data$r:00003340                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00003340 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00003340 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003340                                         ; DATA XREF: .rdata$r:00003338o
.data$r:00003340                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003340                                         ; const type_info::`vftable'
.data$r:00003344                 align 8
.data$r:00003348 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:0000336A                 align 4
.data$r:0000336A _data$r         ends
.data$r:0000336A
.rdata$r:0000336C ; ===========================================================================
.rdata$r:0000336C
.rdata$r:0000336C ; Segment type: Pure data
.rdata$r:0000336C ; Segment permissions: Read
.rdata$r:0000336C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000336C                 assume cs:_rdata$r
.rdata$r:0000336C                 ;org 336Ch
.rdata$r:0000336C ; COMDAT (pick any)
.rdata$r:0000336C                 public ??_R3_Generic_error_category@std@@8
.rdata$r:0000336C ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000336C ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:0000336C                                         ; DATA XREF: .rdata$r:0000333Co
.rdata$r:0000336C                                         ; .rdata$r:000033A0o
.rdata$r:0000336D                 db    0
.rdata$r:0000336E                 db    0
.rdata$r:0000336F                 db    0
.rdata$r:00003370                 db    0
.rdata$r:00003371                 db    0
.rdata$r:00003372                 db    0
.rdata$r:00003373                 db    0
.rdata$r:00003374                 db    2
.rdata$r:00003375                 db    0
.rdata$r:00003376                 db    0
.rdata$r:00003377                 db    0
.rdata$r:00003378                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00003378 _rdata$r        ends
.rdata$r:00003378
.rdata$r:0000337C ; ===========================================================================
.rdata$r:0000337C
.rdata$r:0000337C ; Segment type: Pure data
.rdata$r:0000337C ; Segment permissions: Read
.rdata$r:0000337C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000337C                 assume cs:_rdata$r
.rdata$r:0000337C                 ;org 337Ch
.rdata$r:0000337C ; COMDAT (pick any)
.rdata$r:0000337C                 public ??_R2_Generic_error_category@std@@8
.rdata$r:0000337C ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000337C ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000337C                                         ; DATA XREF: .rdata$r:00003378o
.rdata$r:0000337C                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003380                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003384                 db    0
.rdata$r:00003385                 align 4
.rdata$r:00003385 _rdata$r        ends
.rdata$r:00003385
.rdata$r:00003388 ; ===========================================================================
.rdata$r:00003388
.rdata$r:00003388 ; Segment type: Pure data
.rdata$r:00003388 ; Segment permissions: Read
.rdata$r:00003388 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003388                 assume cs:_rdata$r
.rdata$r:00003388                 ;org 3388h
.rdata$r:00003388 ; COMDAT (pick any)
.rdata$r:00003388                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00003388 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003388 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00003388                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00003388                                         ; .rdata$r:000033F8o ...
.rdata$r:00003388                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000338C                 db    1
.rdata$r:0000338D                 db    0
.rdata$r:0000338E                 db    0
.rdata$r:0000338F                 db    0
.rdata$r:00003390                 db    0
.rdata$r:00003391                 db    0
.rdata$r:00003392                 db    0
.rdata$r:00003393                 db    0
.rdata$r:00003394                 db 0FFh
.rdata$r:00003395                 db 0FFh
.rdata$r:00003396                 db 0FFh
.rdata$r:00003397                 db 0FFh
.rdata$r:00003398                 db    0
.rdata$r:00003399                 db    0
.rdata$r:0000339A                 db    0
.rdata$r:0000339B                 db    0
.rdata$r:0000339C                 db  40h ; @
.rdata$r:0000339D                 db    0
.rdata$r:0000339E                 db    0
.rdata$r:0000339F                 db    0
.rdata$r:000033A0                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000033A0 _rdata$r        ends
.rdata$r:000033A0
.rdata$r:000033A4 ; ===========================================================================
.rdata$r:000033A4
.rdata$r:000033A4 ; Segment type: Pure data
.rdata$r:000033A4 ; Segment permissions: Read
.rdata$r:000033A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033A4                 assume cs:_rdata$r
.rdata$r:000033A4                 ;org 33A4h
.rdata$r:000033A4 ; COMDAT (pick any)
.rdata$r:000033A4                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:000033A4 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:000033A4 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:000033A4                                         ; DATA XREF: .rdata:0000315Co
.rdata$r:000033A5                 db    0
.rdata$r:000033A6                 db    0
.rdata$r:000033A7                 db    0
.rdata$r:000033A8                 db    0
.rdata$r:000033A9                 db    0
.rdata$r:000033AA                 db    0
.rdata$r:000033AB                 db    0
.rdata$r:000033AC                 db    0
.rdata$r:000033AD                 db    0
.rdata$r:000033AE                 db    0
.rdata$r:000033AF                 db    0
.rdata$r:000033B0                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000033B4                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000033B4 _rdata$r        ends
.rdata$r:000033B4
.data$r:000033B8 ; ===========================================================================
.data$r:000033B8
.data$r:000033B8 ; Segment type: Pure data
.data$r:000033B8 ; Segment permissions: Read/Write
.data$r:000033B8 _data$r         segment dword public 'DATA' use32
.data$r:000033B8                 assume cs:_data$r
.data$r:000033B8                 ;org 33B8h
.data$r:000033B8 ; COMDAT (pick any)
.data$r:000033B8                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:000033B8 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:000033B8 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000033B8                                         ; DATA XREF: .rdata$r:000033B0o
.data$r:000033B8                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000033B8                                         ; const type_info::`vftable'
.data$r:000033BC                 align 10h
.data$r:000033C0 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:000033E3                 align 4
.data$r:000033E3 _data$r         ends
.data$r:000033E3
.rdata$r:000033E4 ; ===========================================================================
.rdata$r:000033E4
.rdata$r:000033E4 ; Segment type: Pure data
.rdata$r:000033E4 ; Segment permissions: Read
.rdata$r:000033E4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033E4                 assume cs:_rdata$r
.rdata$r:000033E4                 ;org 33E4h
.rdata$r:000033E4 ; COMDAT (pick any)
.rdata$r:000033E4                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:000033E4 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000033E4 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:000033E4                                         ; DATA XREF: .rdata$r:000033B4o
.rdata$r:000033E4                                         ; .rdata$r:0000341Co
.rdata$r:000033E5                 db    0
.rdata$r:000033E6                 db    0
.rdata$r:000033E7                 db    0
.rdata$r:000033E8                 db    0
.rdata$r:000033E9                 db    0
.rdata$r:000033EA                 db    0
.rdata$r:000033EB                 db    0
.rdata$r:000033EC                 db    3
.rdata$r:000033ED                 db    0
.rdata$r:000033EE                 db    0
.rdata$r:000033EF                 db    0
.rdata$r:000033F0                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000033F0 _rdata$r        ends
.rdata$r:000033F0
.rdata$r:000033F4 ; ===========================================================================
.rdata$r:000033F4
.rdata$r:000033F4 ; Segment type: Pure data
.rdata$r:000033F4 ; Segment permissions: Read
.rdata$r:000033F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033F4                 assume cs:_rdata$r
.rdata$r:000033F4                 ;org 33F4h
.rdata$r:000033F4 ; COMDAT (pick any)
.rdata$r:000033F4                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:000033F4 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000033F4 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000033F4                                         ; DATA XREF: .rdata$r:000033F0o
.rdata$r:000033F4                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000033F8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000033FC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003400                 db    0
.rdata$r:00003401                 align 4
.rdata$r:00003401 _rdata$r        ends
.rdata$r:00003401
.rdata$r:00003404 ; ===========================================================================
.rdata$r:00003404
.rdata$r:00003404 ; Segment type: Pure data
.rdata$r:00003404 ; Segment permissions: Read
.rdata$r:00003404 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003404                 assume cs:_rdata$r
.rdata$r:00003404                 ;org 3404h
.rdata$r:00003404 ; COMDAT (pick any)
.rdata$r:00003404                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00003404 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003404 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00003404                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00003404                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00003408                 db    2
.rdata$r:00003409                 db    0
.rdata$r:0000340A                 db    0
.rdata$r:0000340B                 db    0
.rdata$r:0000340C                 db    0
.rdata$r:0000340D                 db    0
.rdata$r:0000340E                 db    0
.rdata$r:0000340F                 db    0
.rdata$r:00003410                 db 0FFh
.rdata$r:00003411                 db 0FFh
.rdata$r:00003412                 db 0FFh
.rdata$r:00003413                 db 0FFh
.rdata$r:00003414                 db    0
.rdata$r:00003415                 db    0
.rdata$r:00003416                 db    0
.rdata$r:00003417                 db    0
.rdata$r:00003418                 db  40h ; @
.rdata$r:00003419                 db    0
.rdata$r:0000341A                 db    0
.rdata$r:0000341B                 db    0
.rdata$r:0000341C                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000341C _rdata$r        ends
.rdata$r:0000341C
.rdata$r:00003420 ; ===========================================================================
.rdata$r:00003420
.rdata$r:00003420 ; Segment type: Pure data
.rdata$r:00003420 ; Segment permissions: Read
.rdata$r:00003420 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003420                 assume cs:_rdata$r
.rdata$r:00003420                 ;org 3420h
.rdata$r:00003420 ; COMDAT (pick any)
.rdata$r:00003420                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00003420 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00003420 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000319Co
.rdata$r:00003421                 db    0
.rdata$r:00003422                 db    0
.rdata$r:00003423                 db    0
.rdata$r:00003424                 db    0
.rdata$r:00003425                 db    0
.rdata$r:00003426                 db    0
.rdata$r:00003427                 db    0
.rdata$r:00003428                 db    0
.rdata$r:00003429                 db    0
.rdata$r:0000342A                 db    0
.rdata$r:0000342B                 db    0
.rdata$r:0000342C                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00003430                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003430 _rdata$r        ends
.rdata$r:00003430
.data$r:00003434 ; ===========================================================================
.data$r:00003434
.data$r:00003434 ; Segment type: Pure data
.data$r:00003434 ; Segment permissions: Read/Write
.data$r:00003434 _data$r         segment dword public 'DATA' use32
.data$r:00003434                 assume cs:_data$r
.data$r:00003434                 ;org 3434h
.data$r:00003434 ; COMDAT (pick any)
.data$r:00003434                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00003434 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00003434 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003434                                         ; DATA XREF: .rdata$r:0000342Co
.data$r:00003434                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003434                                         ; const type_info::`vftable'
.data$r:00003438                 db    0
.data$r:00003439                 db    0
.data$r:0000343A                 db    0
.data$r:0000343B                 db    0
.data$r:0000343C                 db  2Eh ; .
.data$r:0000343D                 db  3Fh ; ?
.data$r:0000343E                 db  41h ; A
.data$r:0000343F                 db  56h ; V
.data$r:00003440                 db  5Fh ; _
.data$r:00003441                 db  53h ; S
.data$r:00003442                 db  79h ; y
.data$r:00003443                 db  73h ; s
.data$r:00003444                 db  74h ; t
.data$r:00003445                 db  65h ; e
.data$r:00003446                 db  6Dh ; m
.data$r:00003447                 db  5Fh ; _
.data$r:00003448                 db  65h ; e
.data$r:00003449                 db  72h ; r
.data$r:0000344A                 db  72h ; r
.data$r:0000344B                 db  6Fh ; o
.data$r:0000344C                 db  72h ; r
.data$r:0000344D                 db  5Fh ; _
.data$r:0000344E                 db  63h ; c
.data$r:0000344F                 db  61h ; a
.data$r:00003450                 db  74h ; t
.data$r:00003451                 db  65h ; e
.data$r:00003452                 db  67h ; g
.data$r:00003453                 db  6Fh ; o
.data$r:00003454                 db  72h ; r
.data$r:00003455                 db  79h ; y
.data$r:00003456                 db  40h ; @
.data$r:00003457                 db  73h ; s
.data$r:00003458                 db  74h ; t
.data$r:00003459                 db  64h ; d
.data$r:0000345A                 db  40h ; @
.data$r:0000345B                 db  40h ; @
.data$r:0000345C                 db    0
.data$r:0000345D                 align 10h
.data$r:0000345D _data$r         ends
.data$r:0000345D
.rdata$r:00003460 ; ===========================================================================
.rdata$r:00003460
.rdata$r:00003460 ; Segment type: Pure data
.rdata$r:00003460 ; Segment permissions: Read
.rdata$r:00003460 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003460                 assume cs:_rdata$r
.rdata$r:00003460                 ;org 3460h
.rdata$r:00003460 ; COMDAT (pick any)
.rdata$r:00003460                 public ??_R3_System_error_category@std@@8
.rdata$r:00003460 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003460 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00003430o
.rdata$r:00003460                                         ; .rdata$r:00003498o
.rdata$r:00003461                 db    0
.rdata$r:00003462                 db    0
.rdata$r:00003463                 db    0
.rdata$r:00003464                 db    0
.rdata$r:00003465                 db    0
.rdata$r:00003466                 db    0
.rdata$r:00003467                 db    0
.rdata$r:00003468                 db    3
.rdata$r:00003469                 db    0
.rdata$r:0000346A                 db    0
.rdata$r:0000346B                 db    0
.rdata$r:0000346C                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000346C _rdata$r        ends
.rdata$r:0000346C
.rdata$r:00003470 ; ===========================================================================
.rdata$r:00003470
.rdata$r:00003470 ; Segment type: Pure data
.rdata$r:00003470 ; Segment permissions: Read
.rdata$r:00003470 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003470                 assume cs:_rdata$r
.rdata$r:00003470                 ;org 3470h
.rdata$r:00003470 ; COMDAT (pick any)
.rdata$r:00003470                 public ??_R2_System_error_category@std@@8
.rdata$r:00003470 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00003470 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00003470                                         ; DATA XREF: .rdata$r:0000346Co
.rdata$r:00003470                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003474                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003478                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000347C                 db    0
.rdata$r:0000347D                 align 10h
.rdata$r:0000347D _rdata$r        ends
.rdata$r:0000347D
.rdata$r:00003480 ; ===========================================================================
.rdata$r:00003480
.rdata$r:00003480 ; Segment type: Pure data
.rdata$r:00003480 ; Segment permissions: Read
.rdata$r:00003480 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003480                 assume cs:_rdata$r
.rdata$r:00003480                 ;org 3480h
.rdata$r:00003480 ; COMDAT (pick any)
.rdata$r:00003480                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00003480 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003480 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00003480                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00003480                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00003484                 db    2
.rdata$r:00003485                 db    0
.rdata$r:00003486                 db    0
.rdata$r:00003487                 db    0
.rdata$r:00003488                 db    0
.rdata$r:00003489                 db    0
.rdata$r:0000348A                 db    0
.rdata$r:0000348B                 db    0
.rdata$r:0000348C                 db 0FFh
.rdata$r:0000348D                 db 0FFh
.rdata$r:0000348E                 db 0FFh
.rdata$r:0000348F                 db 0FFh
.rdata$r:00003490                 db    0
.rdata$r:00003491                 db    0
.rdata$r:00003492                 db    0
.rdata$r:00003493                 db    0
.rdata$r:00003494                 db  40h ; @
.rdata$r:00003495                 db    0
.rdata$r:00003496                 db    0
.rdata$r:00003497                 db    0
.rdata$r:00003498                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003498 _rdata$r        ends
.rdata$r:00003498
.CRT$XCU:0000349C ; ===========================================================================
.CRT$XCU:0000349C
.CRT$XCU:0000349C ; Segment type: Pure data
.CRT$XCU:0000349C ; Segment permissions: Read
.CRT$XCU:0000349C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000349C                 assume cs:_CRT$XCU
.CRT$XCU:0000349C                 ;org 349Ch
.CRT$XCU:0000349C _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:000034A0 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:000034A4 _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:000034A8 __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:000034A8 _CRT$XCU        ends
.CRT$XCU:000034A8
.CRT$XCU:000034AC ; ===========================================================================
.CRT$XCU:000034AC
.CRT$XCU:000034AC ; Segment type: Pure data
.CRT$XCU:000034AC ; Segment permissions: Read
.CRT$XCU:000034AC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000034AC                 assume cs:_CRT$XCU
.CRT$XCU:000034AC                 ;org 34ACh
.CRT$XCU:000034AC ; COMDAT (pick associative to section at 31C0)
.CRT$XCU:000034AC ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:000034AC ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:000034AC _CRT$XCU        ends
.CRT$XCU:000034AC
.CRT$XCU:000034B0 ; ===========================================================================
.CRT$XCU:000034B0
.CRT$XCU:000034B0 ; Segment type: Pure data
.CRT$XCU:000034B0 ; Segment permissions: Read
.CRT$XCU:000034B0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000034B0                 assume cs:_CRT$XCU
.CRT$XCU:000034B0                 ;org 34B0h
.CRT$XCU:000034B0 ; COMDAT (pick associative to section at 31C4)
.CRT$XCU:000034B0 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:000034B0 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:000034B0 _CRT$XCU        ends
.CRT$XCU:000034B0
.CRT$XCU:000034B4 ; ===========================================================================
.CRT$XCU:000034B4
.CRT$XCU:000034B4 ; Segment type: Pure data
.CRT$XCU:000034B4 ; Segment permissions: Read
.CRT$XCU:000034B4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000034B4                 assume cs:_CRT$XCU
.CRT$XCU:000034B4                 ;org 34B4h
.CRT$XCU:000034B4 ; COMDAT (pick associative to section at 31C8)
.CRT$XCU:000034B4 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:000034B4 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:000034B4 _CRT$XCU        ends
.CRT$XCU:000034B4
.CRT$XCU:000034B8 ; ===========================================================================
.CRT$XCU:000034B8
.CRT$XCU:000034B8 ; Segment type: Pure data
.CRT$XCU:000034B8 ; Segment permissions: Read
.CRT$XCU:000034B8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000034B8                 assume cs:_CRT$XCU
.CRT$XCU:000034B8                 ;org 34B8h
.CRT$XCU:000034B8 ; COMDAT (pick associative to section at 31CC)
.CRT$XCU:000034B8 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:000034B8 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:000034B8 _CRT$XCU        ends
.CRT$XCU:000034B8
.CRT$XCU:000034BC ; ===========================================================================
.CRT$XCU:000034BC
.CRT$XCU:000034BC ; Segment type: Pure data
.CRT$XCU:000034BC ; Segment permissions: Read
.CRT$XCU:000034BC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000034BC                 assume cs:_CRT$XCU
.CRT$XCU:000034BC                 ;org 34BCh
.CRT$XCU:000034BC ; COMDAT (pick associative to section at 31D0)
.CRT$XCU:000034BC ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:000034BC ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:000034BC _CRT$XCU        ends
.CRT$XCU:000034BC
.CRT$XCU:000034C0 ; ===========================================================================
.CRT$XCU:000034C0
.CRT$XCU:000034C0 ; Segment type: Pure data
.CRT$XCU:000034C0 ; Segment permissions: Read
.CRT$XCU:000034C0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000034C0                 assume cs:_CRT$XCU
.CRT$XCU:000034C0                 ;org 34C0h
.CRT$XCU:000034C0 ; COMDAT (pick associative to section at 3264)
.CRT$XCU:000034C0 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:000034C0 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:000034C0 _CRT$XCU        ends
.CRT$XCU:000034C0
.CRT$XCU:000034C4 ; ===========================================================================
.CRT$XCU:000034C4
.CRT$XCU:000034C4 ; Segment type: Pure data
.CRT$XCU:000034C4 ; Segment permissions: Read
.CRT$XCU:000034C4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000034C4                 assume cs:_CRT$XCU
.CRT$XCU:000034C4                 ;org 34C4h
.CRT$XCU:000034C4 ; COMDAT (pick associative to section at 3268)
.CRT$XCU:000034C4 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:000034C4 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:000034C4 _CRT$XCU        ends
.CRT$XCU:000034C4
UNDEF:000034D0 ; ===========================================================================
UNDEF:000034D0
UNDEF:000034D0 ; Segment type: Externs
UNDEF:000034D0 ; UNDEF
UNDEF:000034D0                 extrn __purecall:near   ; DATA XREF: .rdata:00003114o
UNDEF:000034D0                                         ; .rdata:00003118o
UNDEF:000034D4 ; void *__cdecl operator new(unsigned int)
UNDEF:000034D4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:000034D4                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:000034D8 ; void __cdecl operator delete(void *)
UNDEF:000034D8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:000034D8                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:000034DC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:000034DC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:000034DC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:000034E0 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000034E0                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:000034E4 ; size_t __cdecl strlen(const char *Str)
UNDEF:000034E4                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:000034E8 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:000034E8                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:000034EC ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000034EC                 extrn __imp__SendMessageW@16:near
UNDEF:000034EC                                         ; CODE XREF: StaticDialog::isCheckedOrNot(int)+24p
UNDEF:000034EC                                         ; DATA XREF: StaticDialog::isCheckedOrNot(int)+24r
UNDEF:000034F0 ; HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem)
UNDEF:000034F0                 extrn __imp__GetDlgItem@8:near
UNDEF:000034F0                                         ; CODE XREF: StaticDialog::isCheckedOrNot(int)+1Dp
UNDEF:000034F0                                         ; DATA XREF: StaticDialog::isCheckedOrNot(int)+1Dr
UNDEF:000034F4 ; UINT __stdcall GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
UNDEF:000034F4                 extrn __imp__GetDlgItemInt@16:near
UNDEF:000034F4                                         ; CODE XREF: FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)+7Dp
UNDEF:000034F4                                         ; FindCharsInRangeDlg::getRangeFromUI(uchar &,uchar &)+98p
UNDEF:000034F4                                         ; DATA XREF: ...
UNDEF:000034F8 ; LRESULT __stdcall SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000034F8                 extrn __imp__SendDlgItemMessageW@20:near
UNDEF:000034F8                                         ; CODE XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+3Cp
UNDEF:000034F8                                         ; FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+57p ...
UNDEF:000034FC ; int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
UNDEF:000034FC                 extrn __imp__MessageBoxW@16:near
UNDEF:000034FC                                         ; CODE XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+12Bp
UNDEF:000034FC                                         ; DATA XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+12Br
UNDEF:00003500 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00003500                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00003500                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00003504 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00003504                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00003504                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00003504                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00003508                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000350C ; void __cdecl operator delete[](void *)
UNDEF:0000350C                 extrn ??_V@YAXPAX@Z:near
UNDEF:0000350C                                         ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+2CEp
UNDEF:00003510 ; void *__cdecl operator new[](unsigned int)
UNDEF:00003510                 extrn ??_U@YAPAXI@Z:near
UNDEF:00003510                                         ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+55p
UNDEF:00003514 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00003514                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00003514                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00003518 ; void __cdecl std::_Xbad_alloc()
UNDEF:00003518                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00003518                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_13BEp
UNDEF:00003518                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_1400p
UNDEF:0000351C ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000351C                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000351C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00003520 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00003520                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00003520                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00003524 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003524                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003524                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00003528 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00003528                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00003528                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00003528                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000352C ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000352C                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000352C                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00003530 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003530                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003530                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00003534 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003534                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003534                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00003538 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003538                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003538                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000353C ; void __thiscall StaticDialog::goToCenter(StaticDialog *__hidden this)
UNDEF:0000353C                 extrn ?goToCenter@StaticDialog@@QAEXXZ:near
UNDEF:0000353C                                         ; CODE XREF: FindCharsInRangeDlg::run_dlgProc(uint,uint,long)+96p
UNDEF:00003540 ; void __thiscall ScintillaEditView::getText(ScintillaEditView *__hidden this, char *, int, int)
UNDEF:00003540                 extrn ?getText@ScintillaEditView@@QBEXPADHH@Z:near
UNDEF:00003540                                         ; CODE XREF: FindCharsInRangeDlg::findCharInRange(uchar,uchar,int,bool,bool)+78p
UNDEF:00003544 ; __fastcall __security_check_cookie(x)
UNDEF:00003544                 extrn @__security_check_cookie@4:near
UNDEF:00003544                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp
UNDEF:00003544                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+Cp ...
UNDEF:00003548 ; __stdcall _CxxThrowException(x, x)
UNDEF:00003548                 extrn __CxxThrowException@8:near
UNDEF:00003548                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:0000354C                 extrn ___CxxFrameHandler3:near
UNDEF:0000354C                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:0000354C                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:00003550 ; const type_info::`vftable'
UNDEF:00003550                 extrn ??_7type_info@@6B@:near
UNDEF:00003550                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:00003550                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00003554                 extrn ___security_cookie:near
UNDEF:00003554                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r
UNDEF:00003554                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+14r ...
UNDEF:00003558                 extrn __fltused:near
UNDEF:00003558
UNDEF:00003558
UNDEF:00003558                 end