.bss:00000000 ;
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.bss:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.bss:00000000 ; |                      License info: 48-3677-7074-51                      |
.bss:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.bss:00000000 ; +-------------------------------------------------------------------------+
.bss:00000000 ;
.bss:00000000 ; Input MD5   : F7FB3ED9A30E73F20719FF84272B9DE2
.bss:00000000 ; Input CRC32 : 5347683A
.bss:00000000
.bss:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\Splitter.obj
.bss:00000000 ; Format      : COFF (X386MAGIC)
.bss:00000000 ; includelib "libcpmtd"
.bss:00000000 ; includelib "uuid.lib"
.bss:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00000000 ; includelib "LIBCMTD"
.bss:00000000 ; includelib "OLDNAMES"
.bss:00000000
.bss:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.bss:00000000
.bss:00000000                 .686p
.bss:00000000                 .mmx
.bss:00000000                 .model flat
.bss:00000000
.bss:00000000 ; ===========================================================================
.bss:00000000
.bss:00000000 ; Segment type: Uninitialized
.bss:00000000 ; Segment permissions: Read/Write
.bss:00000000 _bss            segment byte public 'BSS' use32
.bss:00000000                 assume cs:_bss
.bss:00000000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00000000                 public ?_isHorizontalRegistered@Splitter@@0_NA
.bss:00000000 ; private: static bool Splitter::_isHorizontalRegistered
.bss:00000000 ?_isHorizontalRegistered@Splitter@@0_NA db ?
.bss:00000000                                         ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+240r
.bss:00000000                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+255w
.bss:00000001                 public ?_isVerticalRegistered@Splitter@@0_NA
.bss:00000001 ; private: static bool Splitter::_isVerticalRegistered
.bss:00000001 ?_isVerticalRegistered@Splitter@@0_NA db ?
.bss:00000001                                         ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+270r
.bss:00000001                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+285w
.bss:00000002                 public ?_isHorizontalFixedRegistered@Splitter@@0_NA
.bss:00000002 ; private: static bool Splitter::_isHorizontalFixedRegistered
.bss:00000002 ?_isHorizontalFixedRegistered@Splitter@@0_NA db ?
.bss:00000002                                         ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+299r
.bss:00000002                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+2AEw
.bss:00000003                 public ?_isVerticalFixedRegistered@Splitter@@0_NA
.bss:00000003 ; private: static bool Splitter::_isVerticalFixedRegistered
.bss:00000003 ?_isVerticalFixedRegistered@Splitter@@0_NA db ?
.bss:00000003                                         ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+2C6r
.bss:00000003                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+2DBw
.bss:00000004 _allocator_arg  db    ? ;
.bss:00000005 _piecewise_construct db    ? ;
.bss:00000006                 align 4
.bss:00000006 _bss            ends
.bss:00000006
.rdata:00000008 ; ===========================================================================
.rdata:00000008
.rdata:00000008 ; Segment type: Pure data
.rdata:00000008 ; Segment permissions: Read
.rdata:00000008 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000008 _rdata          segment para public 'DATA' use32
.rdata:00000008                 assume cs:_rdata
.rdata:00000008                 ;org 8
.rdata:00000008 ; char _SG91470[9]
.rdata:00000008 $SG91470        db 'Splitter:'          ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+1Co
.rdata:00000011 ; HBRUSH__ hbr
.rdata:00000011 hbr             HBRUSH__ <696E693Ah>    ; DATA XREF: Splitter::drawSplitter(void)+25Co
.rdata:00000015 aTParameterHper db 't : Parameter hPere is null',0
.rdata:00000031                 align 8
.rdata:00000038 ; char _SG91474[]
.rdata:00000038 $SG91474        db 'Splitter::init : Parameter iSplitRatio shoulds be 0 < ratio < 100'
.rdata:00000038                                         ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+3Do
.rdata:00000038                 db 0
.rdata:0000007A                 align 4
.rdata:0000007C $SG91496:                               ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+1D3o
.rdata:0000007C                 unicode 0, <fxdnsspliter>,0
.rdata:00000096                 align 4
.rdata:00000098 ; char _SG91483[]
.rdata:00000098 $SG91483        db 'Splitter::init : Parameter iSplitRatio shoulds be 0 < ratio < 100'
.rdata:00000098                                         ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+ABo
.rdata:00000098                 db 0
.rdata:000000DA                 align 4
.rdata:000000DC $SG91498:                               ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong):loc_558o
.rdata:000000DC                 unicode 0, <fxdwespliter>,0
.rdata:000000F6                 align 4
.rdata:000000F8 $SG91504:                               ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+200o
.rdata:000000F8                 unicode 0, <nsspliter>,0
.rdata:0000010C $SG91509:                               ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+219o
.rdata:0000010C                 unicode 0, <wespliter>,0
.rdata:00000120 ; const WCHAR _SG91519
.rdata:00000120 $SG91519        dw 0                    ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+316o
.rdata:00000122                 align 4
.rdata:00000124 ; char _SG91523[]
.rdata:00000124 $SG91523        db 'Splitter::init : CreateWindowEx() function return null',0
.rdata:00000124                                         ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+338o
.rdata:0000015B                 align 4
.rdata:0000015B _rdata          ends
.rdata:0000015B
.text$mn:0000015C ; ===========================================================================
.text$mn:0000015C
.text$mn:0000015C ; Segment type: Pure code
.text$mn:0000015C ; Segment permissions: Read/Execute
.text$mn:0000015C _text$mn        segment para public 'CODE' use32
.text$mn:0000015C                 assume cs:_text$mn
.text$mn:0000015C                 ;org 15Ch
.text$mn:0000015C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000015C
.text$mn:0000015C ; =============== S U B R O U T I N E =======================================
.text$mn:0000015C
.text$mn:0000015C ; Attributes: bp-based frame
.text$mn:0000015C
.text$mn:0000015C ; public: __thiscall Splitter::Splitter(void)
.text$mn:0000015C                 public ??0Splitter@@QAE@XZ
.text$mn:0000015C ??0Splitter@@QAE@XZ proc near
.text$mn:0000015C
.text$mn:0000015C var_10          = dword ptr -10h
.text$mn:0000015C var_C           = dword ptr -0Ch
.text$mn:0000015C var_4           = dword ptr -4
.text$mn:0000015C
.text$mn:0000015C                 push    ebp
.text$mn:0000015D                 mov     ebp, esp
.text$mn:0000015F                 push    0FFFFFFFFh
.text$mn:00000161                 push    offset __ehhandler$??0Splitter@@QAE@XZ
.text$mn:00000166                 mov     eax, large fs:0
.text$mn:0000016C                 push    eax
.text$mn:0000016D                 push    ecx
.text$mn:0000016E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000173                 xor     eax, ebp
.text$mn:00000175                 push    eax
.text$mn:00000176                 lea     eax, [ebp+var_C]
.text$mn:00000179                 mov     large fs:0, eax
.text$mn:0000017F                 mov     [ebp+var_10], ecx
.text$mn:00000182                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000185                 call    ??0Window@@QAE@XZ ; Window::Window(void)
.text$mn:0000018A                 mov     [ebp+var_4], 0
.text$mn:00000191                 mov     eax, [ebp+var_10]
.text$mn:00000194                 mov     dword ptr [eax], offset ??_7Splitter@@6B@ ; const Splitter::`vftable'
.text$mn:0000019A                 mov     ecx, [ebp+var_10]
.text$mn:0000019D                 mov     dword ptr [ecx+10h], 0
.text$mn:000001A4                 mov     edx, [ebp+var_10]
.text$mn:000001A7                 mov     dword ptr [edx+14h], 0
.text$mn:000001AE                 mov     eax, [ebp+var_10]
.text$mn:000001B1                 mov     dword ptr [eax+18h], 0
.text$mn:000001B8                 mov     ecx, [ebp+var_10]
.text$mn:000001BB                 mov     dword ptr [ecx+1Ch], 0
.text$mn:000001C2                 mov     edx, [ebp+var_10]
.text$mn:000001C5                 mov     byte ptr [edx+30h], 0
.text$mn:000001C9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000001D0                 mov     eax, [ebp+var_10]
.text$mn:000001D3                 mov     ecx, [ebp+var_C]
.text$mn:000001D6                 mov     large fs:0, ecx
.text$mn:000001DD                 pop     ecx
.text$mn:000001DE                 mov     esp, ebp
.text$mn:000001E0                 pop     ebp
.text$mn:000001E1                 retn
.text$mn:000001E1 ??0Splitter@@QAE@XZ endp
.text$mn:000001E1
.text$mn:000001E1 ; ---------------------------------------------------------------------------
.text$mn:000001E2                 db 0Ah dup(0CCh)
.text$mn:000001EC
.text$mn:000001EC ; =============== S U B R O U T I N E =======================================
.text$mn:000001EC
.text$mn:000001EC ; Attributes: bp-based frame
.text$mn:000001EC
.text$mn:000001EC ; void __thiscall Splitter::resizeSpliter(Splitter *this, struct tagRECT *)
.text$mn:000001EC                 public ?resizeSpliter@Splitter@@QAEXPAUtagRECT@@@Z
.text$mn:000001EC ?resizeSpliter@Splitter@@QAEXPAUtagRECT@@@Z proc near
.text$mn:000001EC
.text$mn:000001EC var_28          = dword ptr -28h
.text$mn:000001EC var_24          = byte ptr -24h
.text$mn:000001EC var_1C          = dword ptr -1Ch
.text$mn:000001EC var_18          = dword ptr -18h
.text$mn:000001EC Rect            = tagRECT ptr -14h
.text$mn:000001EC var_4           = dword ptr -4
.text$mn:000001EC arg_0           = dword ptr  8
.text$mn:000001EC
.text$mn:000001EC                 push    ebp
.text$mn:000001ED                 mov     ebp, esp
.text$mn:000001EF                 sub     esp, 28h
.text$mn:000001F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000001F7                 xor     eax, ebp
.text$mn:000001F9                 mov     [ebp+var_4], eax
.text$mn:000001FC                 mov     [ebp+var_28], ecx
.text$mn:000001FF                 cmp     [ebp+arg_0], 0
.text$mn:00000203                 jz      short loc_221
.text$mn:00000205                 mov     eax, [ebp+arg_0]
.text$mn:00000208                 mov     ecx, [eax]
.text$mn:0000020A                 mov     [ebp+Rect.left], ecx
.text$mn:0000020D                 mov     edx, [eax+4]
.text$mn:00000210                 mov     [ebp+Rect.top], edx
.text$mn:00000213                 mov     ecx, [eax+8]
.text$mn:00000216                 mov     [ebp+Rect.right], ecx
.text$mn:00000219                 mov     edx, [eax+0Ch]
.text$mn:0000021C                 mov     [ebp+Rect.bottom], edx
.text$mn:0000021F                 jmp     short loc_232
.text$mn:00000221 ; ---------------------------------------------------------------------------
.text$mn:00000221
.text$mn:00000221 loc_221:                                ; CODE XREF: Splitter::resizeSpliter(tagRECT *)+17j
.text$mn:00000221                 lea     eax, [ebp+Rect]
.text$mn:00000224                 push    eax             ; lpRect
.text$mn:00000225                 mov     ecx, [ebp+var_28]
.text$mn:00000228                 mov     edx, [ecx+8]
.text$mn:0000022B                 push    edx             ; hWnd
.text$mn:0000022C                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00000232
.text$mn:00000232 loc_232:                                ; CODE XREF: Splitter::resizeSpliter(tagRECT *)+33j
.text$mn:00000232                 mov     eax, [ebp+var_28]
.text$mn:00000235                 mov     ecx, [eax+2Ch]
.text$mn:00000238                 and     ecx, 1
.text$mn:0000023B                 jz      short loc_27D
.text$mn:0000023D                 mov     edx, [ebp+var_28]
.text$mn:00000240                 mov     eax, [ebp+Rect.right]
.text$mn:00000243                 mov     [edx+18h], eax
.text$mn:00000246                 mov     ecx, [ebp+var_28]
.text$mn:00000249                 mov     edx, [ecx+2Ch]
.text$mn:0000024C                 and     edx, 20h
.text$mn:0000024F                 jz      short loc_26D
.text$mn:00000251                 mov     eax, [ebp+var_28]
.text$mn:00000254                 mov     ecx, [ebp+Rect.bottom]
.text$mn:00000257                 imul    ecx, [eax+20h]
.text$mn:0000025B                 mov     eax, ecx
.text$mn:0000025D                 cdq
.text$mn:0000025E                 mov     ecx, 64h ; 'd'
.text$mn:00000263                 idiv    ecx
.text$mn:00000265                 mov     edx, [ebp+var_28]
.text$mn:00000268                 mov     [edx+14h], eax
.text$mn:0000026B                 jmp     short loc_27B
.text$mn:0000026D ; ---------------------------------------------------------------------------
.text$mn:0000026D
.text$mn:0000026D loc_26D:                                ; CODE XREF: Splitter::resizeSpliter(tagRECT *)+63j
.text$mn:0000026D                 mov     ecx, [ebp+var_28] ; this
.text$mn:00000270                 call    ?getSplitterFixPosY@Splitter@@AAEHXZ ; Splitter::getSplitterFixPosY(void)
.text$mn:00000275                 mov     ecx, [ebp+var_28]
.text$mn:00000278                 mov     [ecx+14h], eax
.text$mn:0000027B
.text$mn:0000027B loc_27B:                                ; CODE XREF: Splitter::resizeSpliter(tagRECT *)+7Fj
.text$mn:0000027B                 jmp     short loc_2BB
.text$mn:0000027D ; ---------------------------------------------------------------------------
.text$mn:0000027D
.text$mn:0000027D loc_27D:                                ; CODE XREF: Splitter::resizeSpliter(tagRECT *)+4Fj
.text$mn:0000027D                 mov     edx, [ebp+var_28]
.text$mn:00000280                 mov     eax, [ebp+Rect.bottom]
.text$mn:00000283                 mov     [edx+1Ch], eax
.text$mn:00000286                 mov     ecx, [ebp+var_28]
.text$mn:00000289                 mov     edx, [ecx+2Ch]
.text$mn:0000028C                 and     edx, 20h
.text$mn:0000028F                 jz      short loc_2AD
.text$mn:00000291                 mov     eax, [ebp+var_28]
.text$mn:00000294                 mov     ecx, [ebp+Rect.right]
.text$mn:00000297                 imul    ecx, [eax+20h]
.text$mn:0000029B                 mov     eax, ecx
.text$mn:0000029D                 cdq
.text$mn:0000029E                 mov     ecx, 64h ; 'd'
.text$mn:000002A3                 idiv    ecx
.text$mn:000002A5                 mov     edx, [ebp+var_28]
.text$mn:000002A8                 mov     [edx+10h], eax
.text$mn:000002AB                 jmp     short loc_2BB
.text$mn:000002AD ; ---------------------------------------------------------------------------
.text$mn:000002AD
.text$mn:000002AD loc_2AD:                                ; CODE XREF: Splitter::resizeSpliter(tagRECT *)+A3j
.text$mn:000002AD                 mov     ecx, [ebp+var_28] ; this
.text$mn:000002B0                 call    ?getSplitterFixPosX@Splitter@@AAEHXZ ; Splitter::getSplitterFixPosX(void)
.text$mn:000002B5                 mov     ecx, [ebp+var_28]
.text$mn:000002B8                 mov     [ecx+10h], eax
.text$mn:000002BB
.text$mn:000002BB loc_2BB:                                ; CODE XREF: Splitter::resizeSpliter(tagRECT *):loc_27Bj
.text$mn:000002BB                                         ; Splitter::resizeSpliter(tagRECT *)+BFj
.text$mn:000002BB                 push    1               ; bRepaint
.text$mn:000002BD                 mov     edx, [ebp+var_28]
.text$mn:000002C0                 mov     eax, [edx+1Ch]
.text$mn:000002C3                 push    eax             ; nHeight
.text$mn:000002C4                 mov     ecx, [ebp+var_28]
.text$mn:000002C7                 mov     edx, [ecx+18h]
.text$mn:000002CA                 push    edx             ; nWidth
.text$mn:000002CB                 mov     eax, [ebp+var_28]
.text$mn:000002CE                 mov     ecx, [eax+14h]
.text$mn:000002D1                 push    ecx             ; Y
.text$mn:000002D2                 mov     edx, [ebp+var_28]
.text$mn:000002D5                 mov     eax, [edx+10h]
.text$mn:000002D8                 push    eax             ; X
.text$mn:000002D9                 mov     ecx, [ebp+var_28]
.text$mn:000002DC                 mov     edx, [ecx+0Ch]
.text$mn:000002DF                 push    edx             ; hWnd
.text$mn:000002E0                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:000002E6                 mov     eax, [ebp+var_28]
.text$mn:000002E9                 mov     ecx, [eax+14h]
.text$mn:000002EC                 push    ecx             ; lParam
.text$mn:000002ED                 mov     edx, [ebp+var_28]
.text$mn:000002F0                 mov     eax, [edx+10h]
.text$mn:000002F3                 push    eax             ; wParam
.text$mn:000002F4                 push    13A4h           ; Msg
.text$mn:000002F9                 mov     ecx, [ebp+var_28]
.text$mn:000002FC                 mov     edx, [ecx+8]
.text$mn:000002FF                 push    edx             ; hWnd
.text$mn:00000300                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000306                 lea     eax, [ebp+var_24]
.text$mn:00000309                 push    eax
.text$mn:0000030A                 mov     ecx, [ebp+var_28]
.text$mn:0000030D                 mov     edx, [ecx]
.text$mn:0000030F                 mov     ecx, [ebp+var_28]
.text$mn:00000312                 mov     eax, [edx+1Ch]
.text$mn:00000315                 call    eax
.text$mn:00000317                 push    1               ; bool
.text$mn:00000319                 mov     ecx, [ebp+var_28] ; this
.text$mn:0000031C                 call    ?getClickZone@Splitter@@AAEH_N@Z ; Splitter::getClickZone(bool)
.text$mn:00000321                 mov     ecx, [ebp+var_28]
.text$mn:00000324                 mov     [ecx+4Ch], eax
.text$mn:00000327                 push    0               ; bool
.text$mn:00000329                 mov     ecx, [ebp+var_28] ; this
.text$mn:0000032C                 call    ?getClickZone@Splitter@@AAEH_N@Z ; Splitter::getClickZone(bool)
.text$mn:00000331                 mov     edx, [ebp+var_28]
.text$mn:00000334                 mov     [edx+50h], eax
.text$mn:00000337                 mov     eax, [ebp+var_28]
.text$mn:0000033A                 mov     ecx, [ebp+var_1C]
.text$mn:0000033D                 sub     ecx, [eax+4Ch]
.text$mn:00000340                 mov     edx, [ebp+var_28]
.text$mn:00000343                 mov     [edx+44h], ecx
.text$mn:00000346                 mov     eax, [ebp+var_28]
.text$mn:00000349                 mov     ecx, [ebp+var_18]
.text$mn:0000034C                 sub     ecx, [eax+50h]
.text$mn:0000034F                 mov     edx, [ebp+var_28]
.text$mn:00000352                 mov     [edx+48h], ecx
.text$mn:00000355                 push    0
.text$mn:00000357                 mov     eax, [ebp+var_28]
.text$mn:0000035A                 mov     edx, [eax]
.text$mn:0000035C                 mov     ecx, [ebp+var_28]
.text$mn:0000035F                 mov     eax, [edx+18h]
.text$mn:00000362                 call    eax
.text$mn:00000364                 mov     ecx, [ebp+var_4]
.text$mn:00000367                 xor     ecx, ebp
.text$mn:00000369                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000036E                 mov     esp, ebp
.text$mn:00000370                 pop     ebp
.text$mn:00000371                 retn    4
.text$mn:00000371 ?resizeSpliter@Splitter@@QAEXPAUtagRECT@@@Z endp
.text$mn:00000371
.text$mn:00000371 ; ---------------------------------------------------------------------------
.text$mn:00000374                 db 8 dup(0CCh)
.text$mn:0000037C
.text$mn:0000037C ; =============== S U B R O U T I N E =======================================
.text$mn:0000037C
.text$mn:0000037C ; Attributes: bp-based frame
.text$mn:0000037C
.text$mn:0000037C ; void __thiscall Splitter::init(Splitter *this, HINSTANCE, HWND, int, int, unsigned __int32)
.text$mn:0000037C                 public ?init@Splitter@@QAEXPAUHINSTANCE__@@PAUHWND__@@HHK@Z
.text$mn:0000037C ?init@Splitter@@QAEXPAUHINSTANCE__@@PAUHWND__@@HHK@Z proc near
.text$mn:0000037C                                         ; CODE XREF: Splitter::rotate(void)+92p
.text$mn:0000037C
.text$mn:0000037C var_88          = byte ptr -88h
.text$mn:0000037C var_7C          = byte ptr -7Ch
.text$mn:0000037C var_70          = byte ptr -70h
.text$mn:0000037C var_64          = byte ptr -64h
.text$mn:0000037C dwExStyle       = dword ptr -58h
.text$mn:0000037C var_54          = WNDCLASSEXW ptr -54h
.text$mn:0000037C dwStyle         = dword ptr -24h
.text$mn:0000037C var_20          = dword ptr -20h
.text$mn:0000037C var_1C          = dword ptr -1Ch
.text$mn:0000037C lpParam         = dword ptr -18h
.text$mn:0000037C var_14          = dword ptr -14h
.text$mn:0000037C var_10          = dword ptr -10h
.text$mn:0000037C var_C           = dword ptr -0Ch
.text$mn:0000037C var_8           = dword ptr -8
.text$mn:0000037C var_4           = dword ptr -4
.text$mn:0000037C arg_0           = dword ptr  8
.text$mn:0000037C arg_4           = dword ptr  0Ch
.text$mn:0000037C arg_8           = dword ptr  10h
.text$mn:0000037C arg_C           = dword ptr  14h
.text$mn:0000037C arg_10          = dword ptr  18h
.text$mn:0000037C
.text$mn:0000037C                 push    ebp
.text$mn:0000037D                 mov     ebp, esp
.text$mn:0000037F                 sub     esp, 88h
.text$mn:00000385                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000038A                 xor     eax, ebp
.text$mn:0000038C                 mov     [ebp+var_4], eax
.text$mn:0000038F                 mov     [ebp+lpParam], ecx
.text$mn:00000392                 cmp     [ebp+arg_4], 0
.text$mn:00000396                 jnz     short loc_3B3
.text$mn:00000398                 push    offset $SG91470 ; "Splitter:"
.text$mn:0000039D                 lea     ecx, [ebp+var_64] ; this
.text$mn:000003A0                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:000003A5                 push    offset __TI2?AVruntime_error@std@@
.text$mn:000003AA                 lea     eax, [ebp+var_64]
.text$mn:000003AD                 push    eax
.text$mn:000003AE                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000003B3 ; ---------------------------------------------------------------------------
.text$mn:000003B3
.text$mn:000003B3 loc_3B3:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+1Aj
.text$mn:000003B3                 cmp     [ebp+arg_C], 0
.text$mn:000003B7                 jge     short loc_3D4
.text$mn:000003B9                 push    offset $SG91474 ; "Splitter::init : Parameter iSplitRatio "...
.text$mn:000003BE                 lea     ecx, [ebp+var_70] ; this
.text$mn:000003C1                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:000003C6                 push    offset __TI2?AVruntime_error@std@@
.text$mn:000003CB                 lea     ecx, [ebp+var_70]
.text$mn:000003CE                 push    ecx
.text$mn:000003CF                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000003D4 ; ---------------------------------------------------------------------------
.text$mn:000003D4
.text$mn:000003D4 loc_3D4:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+3Bj
.text$mn:000003D4                 mov     edx, [ebp+arg_4]
.text$mn:000003D7                 push    edx             ; HWND
.text$mn:000003D8                 mov     eax, [ebp+arg_0]
.text$mn:000003DB                 push    eax             ; HINSTANCE
.text$mn:000003DC                 mov     ecx, [ebp+lpParam] ; this
.text$mn:000003DF                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:000003E4                 mov     ecx, [ebp+lpParam]
.text$mn:000003E7                 mov     edx, [ebp+arg_8]
.text$mn:000003EA                 mov     [ecx+24h], edx
.text$mn:000003ED                 mov     [ebp+dwExStyle], 0
.text$mn:000003F4                 mov     [ebp+dwStyle], 50000000h
.text$mn:000003FB                 mov     eax, [ebp+lpParam]
.text$mn:000003FE                 mov     ecx, [ebp+arg_4]
.text$mn:00000401                 mov     [eax+8], ecx
.text$mn:00000404                 mov     edx, [ebp+lpParam]
.text$mn:00000407                 mov     eax, [ebp+arg_10]
.text$mn:0000040A                 mov     [edx+2Ch], eax
.text$mn:0000040D                 mov     ecx, [ebp+lpParam]
.text$mn:00000410                 mov     edx, [ecx+2Ch]
.text$mn:00000413                 and     edx, 4
.text$mn:00000416                 jz      short loc_421
.text$mn:00000418                 mov     eax, [ebp+lpParam]
.text$mn:0000041B                 mov     byte ptr [eax+30h], 1
.text$mn:0000041F                 jmp     short loc_448
.text$mn:00000421 ; ---------------------------------------------------------------------------
.text$mn:00000421
.text$mn:00000421 loc_421:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+9Aj
.text$mn:00000421                 cmp     [ebp+arg_C], 64h ; 'd'
.text$mn:00000425                 jl      short loc_448
.text$mn:00000427                 push    offset $SG91483 ; "Splitter::init : Parameter iSplitRatio "...
.text$mn:0000042C                 lea     ecx, [ebp+var_88] ; this
.text$mn:00000432                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:00000437                 push    offset __TI2?AVruntime_error@std@@
.text$mn:0000043C                 lea     ecx, [ebp+var_88]
.text$mn:00000442                 push    ecx
.text$mn:00000443                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000448 ; ---------------------------------------------------------------------------
.text$mn:00000448
.text$mn:00000448 loc_448:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+A3j
.text$mn:00000448                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+A9j
.text$mn:00000448                 mov     edx, [ebp+lpParam]
.text$mn:0000044B                 mov     eax, [ebp+arg_C]
.text$mn:0000044E                 mov     [edx+20h], eax
.text$mn:00000451                 mov     [ebp+var_54.cbSize], 30h ; '0'
.text$mn:00000458                 mov     [ebp+var_54.style], 3
.text$mn:0000045F                 mov     [ebp+var_54.lpfnWndProc], offset ?staticWndProc@Splitter@@CGJPAUHWND__@@IIJ@Z ; Splitter::staticWndProc(HWND__ *,uint,uint,long)
.text$mn:00000466                 mov     [ebp+var_54.cbClsExtra], 0
.text$mn:0000046D                 mov     [ebp+var_54.cbWndExtra], 0
.text$mn:00000474                 mov     ecx, [ebp+lpParam]
.text$mn:00000477                 mov     edx, [ecx+4]
.text$mn:0000047A                 mov     [ebp+var_54.hInstance], edx
.text$mn:0000047D                 mov     [ebp+var_54.hIcon], 0
.text$mn:00000484                 mov     eax, [ebp+lpParam]
.text$mn:00000487                 add     eax, 10h
.text$mn:0000048A                 push    eax             ; lpRect
.text$mn:0000048B                 mov     ecx, [ebp+lpParam]
.text$mn:0000048E                 mov     edx, [ecx+8]
.text$mn:00000491                 push    edx             ; hWnd
.text$mn:00000492                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00000498                 mov     eax, [ebp+lpParam]
.text$mn:0000049B                 mov     ecx, [eax+2Ch]
.text$mn:0000049E                 and     ecx, 1
.text$mn:000004A1                 jz      short loc_4D8
.text$mn:000004A3                 mov     edx, [ebp+lpParam]
.text$mn:000004A6                 mov     eax, [ebp+lpParam]
.text$mn:000004A9                 mov     ecx, [edx+1Ch]
.text$mn:000004AC                 imul    ecx, [eax+20h]
.text$mn:000004B0                 mov     eax, ecx
.text$mn:000004B2                 cdq
.text$mn:000004B3                 mov     ecx, 64h ; 'd'
.text$mn:000004B8                 idiv    ecx
.text$mn:000004BA                 mov     edx, [ebp+lpParam]
.text$mn:000004BD                 mov     [edx+14h], eax
.text$mn:000004C0                 mov     eax, [ebp+lpParam]
.text$mn:000004C3                 mov     dword ptr [eax+10h], 0
.text$mn:000004CA                 mov     ecx, [ebp+lpParam]
.text$mn:000004CD                 mov     edx, [ebp+lpParam]
.text$mn:000004D0                 mov     eax, [edx+24h]
.text$mn:000004D3                 mov     [ecx+1Ch], eax
.text$mn:000004D6                 jmp     short loc_4FF
.text$mn:000004D8 ; ---------------------------------------------------------------------------
.text$mn:000004D8
.text$mn:000004D8 loc_4D8:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+125j
.text$mn:000004D8                 mov     ecx, [ebp+lpParam]
.text$mn:000004DB                 mov     edx, [ebp+lpParam]
.text$mn:000004DE                 mov     eax, [ecx+18h]
.text$mn:000004E1                 imul    eax, [edx+20h]
.text$mn:000004E5                 cdq
.text$mn:000004E6                 mov     ecx, 64h ; 'd'
.text$mn:000004EB                 idiv    ecx
.text$mn:000004ED                 mov     edx, [ebp+lpParam]
.text$mn:000004F0                 mov     [edx+10h], eax
.text$mn:000004F3                 mov     eax, [ebp+lpParam]
.text$mn:000004F6                 mov     ecx, [ebp+lpParam]
.text$mn:000004F9                 mov     edx, [ecx+24h]
.text$mn:000004FC                 mov     [eax+18h], edx
.text$mn:000004FF
.text$mn:000004FF loc_4FF:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+15Aj
.text$mn:000004FF                 mov     eax, [ebp+lpParam]
.text$mn:00000502                 movzx   ecx, byte ptr [eax+30h]
.text$mn:00000506                 test    ecx, ecx
.text$mn:00000508                 jnz     short loc_529
.text$mn:0000050A                 mov     edx, [ebp+lpParam]
.text$mn:0000050D                 mov     eax, [edx+2Ch]
.text$mn:00000510                 and     eax, 8
.text$mn:00000513                 jnz     short loc_520
.text$mn:00000515                 mov     ecx, [ebp+lpParam]
.text$mn:00000518                 mov     edx, [ecx+2Ch]
.text$mn:0000051B                 and     edx, 10h
.text$mn:0000051E                 jz      short loc_529
.text$mn:00000520
.text$mn:00000520 loc_520:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+197j
.text$mn:00000520                 mov     eax, [ebp+var_54.style]
.text$mn:00000523                 or      eax, 8
.text$mn:00000526                 mov     [ebp+var_54.style], eax
.text$mn:00000529
.text$mn:00000529 loc_529:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+18Cj
.text$mn:00000529                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+1A2j
.text$mn:00000529                 mov     ecx, [ebp+lpParam]
.text$mn:0000052C                 movzx   edx, byte ptr [ecx+30h]
.text$mn:00000530                 test    edx, edx
.text$mn:00000532                 jz      short loc_561
.text$mn:00000534                 push    7F00h           ; lpCursorName
.text$mn:00000539                 push    0               ; hInstance
.text$mn:0000053B                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:00000541                 mov     [ebp+var_54.hCursor], eax
.text$mn:00000544                 mov     eax, [ebp+lpParam]
.text$mn:00000547                 mov     ecx, [eax+2Ch]
.text$mn:0000054A                 and     ecx, 1
.text$mn:0000054D                 jz      short loc_558
.text$mn:0000054F                 mov     [ebp+var_54.lpszClassName], offset $SG91496 ; "fxdnsspliter"
.text$mn:00000556                 jmp     short loc_55F
.text$mn:00000558 ; ---------------------------------------------------------------------------
.text$mn:00000558
.text$mn:00000558 loc_558:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+1D1j
.text$mn:00000558                 mov     [ebp+var_54.lpszClassName], offset $SG91498 ; "fxdwespliter"
.text$mn:0000055F
.text$mn:0000055F loc_55F:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+1DAj
.text$mn:0000055F                 jmp     short loc_59C
.text$mn:00000561 ; ---------------------------------------------------------------------------
.text$mn:00000561
.text$mn:00000561 loc_561:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+1B6j
.text$mn:00000561                 mov     edx, [ebp+lpParam]
.text$mn:00000564                 mov     eax, [edx+2Ch]
.text$mn:00000567                 and     eax, 1
.text$mn:0000056A                 jz      short loc_585
.text$mn:0000056C                 push    7F85h           ; lpCursorName
.text$mn:00000571                 push    0               ; hInstance
.text$mn:00000573                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:00000579                 mov     [ebp+var_54.hCursor], eax
.text$mn:0000057C                 mov     [ebp+var_54.lpszClassName], offset $SG91504 ; "nsspliter"
.text$mn:00000583                 jmp     short loc_59C
.text$mn:00000585 ; ---------------------------------------------------------------------------
.text$mn:00000585
.text$mn:00000585 loc_585:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+1EEj
.text$mn:00000585                 push    7F84h           ; lpCursorName
.text$mn:0000058A                 push    0               ; hInstance
.text$mn:0000058C                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:00000592                 mov     [ebp+var_54.hCursor], eax
.text$mn:00000595                 mov     [ebp+var_54.lpszClassName], offset $SG91509 ; "wespliter"
.text$mn:0000059C
.text$mn:0000059C loc_59C:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong):loc_55Fj
.text$mn:0000059C                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+207j
.text$mn:0000059C                 mov     [ebp+var_54.hbrBackground], 10h
.text$mn:000005A3                 mov     [ebp+var_54.lpszMenuName], 0
.text$mn:000005AA                 mov     [ebp+var_54.hIconSm], 0
.text$mn:000005B1                 mov     ecx, [ebp+lpParam]
.text$mn:000005B4                 mov     edx, [ecx+2Ch]
.text$mn:000005B7                 and     edx, 1
.text$mn:000005BA                 jz      short loc_5DD
.text$mn:000005BC                 movzx   eax, ds:?_isHorizontalRegistered@Splitter@@0_NA ; bool Splitter::_isHorizontalRegistered
.text$mn:000005C3                 test    eax, eax
.text$mn:000005C5                 jnz     short loc_5DD
.text$mn:000005C7                 lea     ecx, [ebp+var_54]
.text$mn:000005CA                 push    ecx             ; WNDCLASSEXW *
.text$mn:000005CB                 call    dword ptr ds:__imp__RegisterClassExW@4 ; RegisterClassExW(x)
.text$mn:000005D1                 mov     ds:?_isHorizontalRegistered@Splitter@@0_NA, 1 ; bool Splitter::_isHorizontalRegistered
.text$mn:000005D8                 jmp     loc_65E
.text$mn:000005DD ; ---------------------------------------------------------------------------
.text$mn:000005DD
.text$mn:000005DD loc_5DD:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+23Ej
.text$mn:000005DD                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+249j
.text$mn:000005DD                 mov     ecx, [ebp+lpParam] ; this
.text$mn:000005E0                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:000005E5                 movzx   edx, al
.text$mn:000005E8                 test    edx, edx
.text$mn:000005EA                 jz      short loc_60A
.text$mn:000005EC                 movzx   eax, ds:?_isVerticalRegistered@Splitter@@0_NA ; bool Splitter::_isVerticalRegistered
.text$mn:000005F3                 test    eax, eax
.text$mn:000005F5                 jnz     short loc_60A
.text$mn:000005F7                 lea     ecx, [ebp+var_54]
.text$mn:000005FA                 push    ecx             ; WNDCLASSEXW *
.text$mn:000005FB                 call    dword ptr ds:__imp__RegisterClassExW@4 ; RegisterClassExW(x)
.text$mn:00000601                 mov     ds:?_isVerticalRegistered@Splitter@@0_NA, 1 ; bool Splitter::_isVerticalRegistered
.text$mn:00000608                 jmp     short loc_65E
.text$mn:0000060A ; ---------------------------------------------------------------------------
.text$mn:0000060A
.text$mn:0000060A loc_60A:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+26Ej
.text$mn:0000060A                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+279j
.text$mn:0000060A                 mov     edx, [ebp+lpParam]
.text$mn:0000060D                 mov     eax, [edx+2Ch]
.text$mn:00000610                 and     eax, 1
.text$mn:00000613                 jz      short loc_633
.text$mn:00000615                 movzx   ecx, ds:?_isHorizontalFixedRegistered@Splitter@@0_NA ; bool Splitter::_isHorizontalFixedRegistered
.text$mn:0000061C                 test    ecx, ecx
.text$mn:0000061E                 jnz     short loc_633
.text$mn:00000620                 lea     edx, [ebp+var_54]
.text$mn:00000623                 push    edx             ; WNDCLASSEXW *
.text$mn:00000624                 call    dword ptr ds:__imp__RegisterClassExW@4 ; RegisterClassExW(x)
.text$mn:0000062A                 mov     ds:?_isHorizontalFixedRegistered@Splitter@@0_NA, 1 ; bool Splitter::_isHorizontalFixedRegistered
.text$mn:00000631                 jmp     short loc_65E
.text$mn:00000633 ; ---------------------------------------------------------------------------
.text$mn:00000633
.text$mn:00000633 loc_633:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+297j
.text$mn:00000633                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+2A2j
.text$mn:00000633                 mov     ecx, [ebp+lpParam] ; this
.text$mn:00000636                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:0000063B                 movzx   eax, al
.text$mn:0000063E                 test    eax, eax
.text$mn:00000640                 jz      short loc_65E
.text$mn:00000642                 movzx   ecx, ds:?_isVerticalFixedRegistered@Splitter@@0_NA ; bool Splitter::_isVerticalFixedRegistered
.text$mn:00000649                 test    ecx, ecx
.text$mn:0000064B                 jnz     short loc_65E
.text$mn:0000064D                 lea     edx, [ebp+var_54]
.text$mn:00000650                 push    edx             ; WNDCLASSEXW *
.text$mn:00000651                 call    dword ptr ds:__imp__RegisterClassExW@4 ; RegisterClassExW(x)
.text$mn:00000657                 mov     ds:?_isVerticalFixedRegistered@Splitter@@0_NA, 1 ; bool Splitter::_isVerticalFixedRegistered
.text$mn:0000065E
.text$mn:0000065E loc_65E:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+25Cj
.text$mn:0000065E                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+28Cj ...
.text$mn:0000065E                 mov     eax, [ebp+lpParam]
.text$mn:00000661                 push    eax             ; lpParam
.text$mn:00000662                 mov     ecx, [ebp+lpParam]
.text$mn:00000665                 mov     edx, [ecx+4]
.text$mn:00000668                 push    edx             ; hInstance
.text$mn:00000669                 push    0               ; hMenu
.text$mn:0000066B                 mov     eax, [ebp+lpParam]
.text$mn:0000066E                 mov     ecx, [eax+8]
.text$mn:00000671                 push    ecx             ; hWndParent
.text$mn:00000672                 mov     edx, [ebp+lpParam]
.text$mn:00000675                 mov     eax, [edx+1Ch]
.text$mn:00000678                 push    eax             ; nHeight
.text$mn:00000679                 mov     ecx, [ebp+lpParam]
.text$mn:0000067C                 mov     edx, [ecx+18h]
.text$mn:0000067F                 push    edx             ; nWidth
.text$mn:00000680                 mov     eax, [ebp+lpParam]
.text$mn:00000683                 mov     ecx, [eax+14h]
.text$mn:00000686                 push    ecx             ; Y
.text$mn:00000687                 mov     edx, [ebp+lpParam]
.text$mn:0000068A                 mov     eax, [edx+10h]
.text$mn:0000068D                 push    eax             ; X
.text$mn:0000068E                 mov     ecx, [ebp+dwStyle]
.text$mn:00000691                 push    ecx             ; dwStyle
.text$mn:00000692                 push    offset $SG91519 ; lpWindowName
.text$mn:00000697                 mov     edx, [ebp+var_54.lpszClassName]
.text$mn:0000069A                 push    edx             ; lpClassName
.text$mn:0000069B                 mov     eax, [ebp+dwExStyle]
.text$mn:0000069E                 push    eax             ; dwExStyle
.text$mn:0000069F                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:000006A5                 mov     ecx, [ebp+lpParam]
.text$mn:000006A8                 mov     [ecx+0Ch], eax
.text$mn:000006AB                 mov     edx, [ebp+lpParam]
.text$mn:000006AE                 cmp     dword ptr [edx+0Ch], 0
.text$mn:000006B2                 jnz     short loc_6CF
.text$mn:000006B4                 push    offset $SG91523 ; "Splitter::init : CreateWindowEx() funct"...
.text$mn:000006B9                 lea     ecx, [ebp+var_7C] ; this
.text$mn:000006BC                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:000006C1                 push    offset __TI2?AVruntime_error@std@@
.text$mn:000006C6                 lea     eax, [ebp+var_7C]
.text$mn:000006C9                 push    eax
.text$mn:000006CA                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000006CF ; ---------------------------------------------------------------------------
.text$mn:000006CF
.text$mn:000006CF loc_6CF:                                ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+336j
.text$mn:000006CF                 lea     ecx, [ebp+var_14]
.text$mn:000006D2                 push    ecx
.text$mn:000006D3                 mov     edx, [ebp+lpParam]
.text$mn:000006D6                 mov     eax, [edx]
.text$mn:000006D8                 mov     ecx, [ebp+lpParam]
.text$mn:000006DB                 mov     edx, [eax+1Ch]
.text$mn:000006DE                 call    edx
.text$mn:000006E0                 mov     eax, [ebp+lpParam]
.text$mn:000006E3                 mov     ecx, [ebp+var_14]
.text$mn:000006E6                 mov     [eax+34h], ecx
.text$mn:000006E9                 mov     edx, [ebp+lpParam]
.text$mn:000006EC                 mov     eax, [ebp+var_10]
.text$mn:000006EF                 mov     [edx+38h], eax
.text$mn:000006F2                 push    1               ; bool
.text$mn:000006F4                 mov     ecx, [ebp+lpParam] ; this
.text$mn:000006F7                 call    ?getClickZone@Splitter@@AAEH_N@Z ; Splitter::getClickZone(bool)
.text$mn:000006FC                 mov     [ebp+var_1C], eax
.text$mn:000006FF                 push    0               ; bool
.text$mn:00000701                 mov     ecx, [ebp+lpParam] ; this
.text$mn:00000704                 call    ?getClickZone@Splitter@@AAEH_N@Z ; Splitter::getClickZone(bool)
.text$mn:00000709                 mov     [ebp+var_20], eax
.text$mn:0000070C                 mov     ecx, [ebp+lpParam]
.text$mn:0000070F                 mov     edx, [ebp+var_1C]
.text$mn:00000712                 mov     [ecx+3Ch], edx
.text$mn:00000715                 mov     eax, [ebp+lpParam]
.text$mn:00000718                 mov     ecx, [ebp+var_20]
.text$mn:0000071B                 mov     [eax+40h], ecx
.text$mn:0000071E                 mov     edx, [ebp+var_C]
.text$mn:00000721                 sub     edx, [ebp+var_1C]
.text$mn:00000724                 mov     eax, [ebp+lpParam]
.text$mn:00000727                 mov     [eax+44h], edx
.text$mn:0000072A                 mov     ecx, [ebp+var_8]
.text$mn:0000072D                 sub     ecx, [ebp+var_20]
.text$mn:00000730                 mov     edx, [ebp+lpParam]
.text$mn:00000733                 mov     [edx+48h], ecx
.text$mn:00000736                 mov     eax, [ebp+lpParam]
.text$mn:00000739                 mov     ecx, [ebp+var_1C]
.text$mn:0000073C                 mov     [eax+4Ch], ecx
.text$mn:0000073F                 mov     edx, [ebp+lpParam]
.text$mn:00000742                 mov     eax, [ebp+var_20]
.text$mn:00000745                 mov     [edx+50h], eax
.text$mn:00000748                 push    1
.text$mn:0000074A                 mov     ecx, [ebp+lpParam]
.text$mn:0000074D                 mov     edx, [ecx]
.text$mn:0000074F                 mov     ecx, [ebp+lpParam]
.text$mn:00000752                 mov     eax, [edx+0Ch]
.text$mn:00000755                 call    eax
.text$mn:00000757                 mov     ecx, [ebp+lpParam]
.text$mn:0000075A                 mov     edx, [ecx+14h]
.text$mn:0000075D                 push    edx             ; lParam
.text$mn:0000075E                 mov     eax, [ebp+lpParam]
.text$mn:00000761                 mov     ecx, [eax+10h]
.text$mn:00000764                 push    ecx             ; wParam
.text$mn:00000765                 push    13A4h           ; Msg
.text$mn:0000076A                 mov     edx, [ebp+lpParam]
.text$mn:0000076D                 mov     eax, [edx+8]
.text$mn:00000770                 push    eax             ; hWnd
.text$mn:00000771                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000777                 mov     ecx, [ebp+var_4]
.text$mn:0000077A                 xor     ecx, ebp
.text$mn:0000077C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000781                 mov     esp, ebp
.text$mn:00000783                 pop     ebp
.text$mn:00000784                 retn    14h
.text$mn:00000784 ?init@Splitter@@QAEXPAUHINSTANCE__@@PAUHWND__@@HHK@Z endp
.text$mn:00000784
.text$mn:00000784 ; ---------------------------------------------------------------------------
.text$mn:00000787                 db 5 dup(0CCh)
.text$mn:0000078C
.text$mn:0000078C ; =============== S U B R O U T I N E =======================================
.text$mn:0000078C
.text$mn:0000078C ; Attributes: bp-based frame
.text$mn:0000078C
.text$mn:0000078C ; void __thiscall Splitter::rotate(Splitter *__hidden this)
.text$mn:0000078C                 public ?rotate@Splitter@@QAEXXZ
.text$mn:0000078C ?rotate@Splitter@@QAEXXZ proc near
.text$mn:0000078C
.text$mn:0000078C var_4           = dword ptr -4
.text$mn:0000078C
.text$mn:0000078C                 push    ebp
.text$mn:0000078D                 mov     ebp, esp
.text$mn:0000078F                 push    ecx
.text$mn:00000790                 mov     [ebp+var_4], ecx
.text$mn:00000793                 mov     eax, [ebp+var_4]
.text$mn:00000796                 movzx   ecx, byte ptr [eax+30h]
.text$mn:0000079A                 test    ecx, ecx
.text$mn:0000079C                 jnz     loc_823
.text$mn:000007A2                 mov     edx, [ebp+var_4]
.text$mn:000007A5                 mov     eax, [edx]
.text$mn:000007A7                 mov     ecx, [ebp+var_4]
.text$mn:000007AA                 mov     edx, [eax+8]
.text$mn:000007AD                 call    edx
.text$mn:000007AF                 mov     eax, [ebp+var_4]
.text$mn:000007B2                 mov     ecx, [eax+2Ch]
.text$mn:000007B5                 and     ecx, 1
.text$mn:000007B8                 jz      short loc_7DA
.text$mn:000007BA                 mov     edx, [ebp+var_4]
.text$mn:000007BD                 mov     eax, [edx+2Ch]
.text$mn:000007C0                 xor     eax, 1
.text$mn:000007C3                 mov     ecx, [ebp+var_4]
.text$mn:000007C6                 mov     [ecx+2Ch], eax
.text$mn:000007C9                 mov     edx, [ebp+var_4]
.text$mn:000007CC                 mov     eax, [edx+2Ch]
.text$mn:000007CF                 or      eax, 2
.text$mn:000007D2                 mov     ecx, [ebp+var_4]
.text$mn:000007D5                 mov     [ecx+2Ch], eax
.text$mn:000007D8                 jmp     short loc_7F8
.text$mn:000007DA ; ---------------------------------------------------------------------------
.text$mn:000007DA
.text$mn:000007DA loc_7DA:                                ; CODE XREF: Splitter::rotate(void)+2Cj
.text$mn:000007DA                 mov     edx, [ebp+var_4]
.text$mn:000007DD                 mov     eax, [edx+2Ch]
.text$mn:000007E0                 xor     eax, 2
.text$mn:000007E3                 mov     ecx, [ebp+var_4]
.text$mn:000007E6                 mov     [ecx+2Ch], eax
.text$mn:000007E9                 mov     edx, [ebp+var_4]
.text$mn:000007EC                 mov     eax, [edx+2Ch]
.text$mn:000007EF                 or      eax, 1
.text$mn:000007F2                 mov     ecx, [ebp+var_4]
.text$mn:000007F5                 mov     [ecx+2Ch], eax
.text$mn:000007F8
.text$mn:000007F8 loc_7F8:                                ; CODE XREF: Splitter::rotate(void)+4Cj
.text$mn:000007F8                 mov     edx, [ebp+var_4]
.text$mn:000007FB                 mov     eax, [edx+2Ch]
.text$mn:000007FE                 push    eax             ; unsigned __int32
.text$mn:000007FF                 mov     ecx, [ebp+var_4]
.text$mn:00000802                 mov     edx, [ecx+20h]
.text$mn:00000805                 push    edx             ; int
.text$mn:00000806                 mov     eax, [ebp+var_4]
.text$mn:00000809                 mov     ecx, [eax+24h]
.text$mn:0000080C                 push    ecx             ; int
.text$mn:0000080D                 mov     edx, [ebp+var_4]
.text$mn:00000810                 mov     eax, [edx+8]
.text$mn:00000813                 push    eax             ; HWND
.text$mn:00000814                 mov     ecx, [ebp+var_4]
.text$mn:00000817                 mov     edx, [ecx+4]
.text$mn:0000081A                 push    edx             ; HINSTANCE
.text$mn:0000081B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000081E                 call    ?init@Splitter@@QAEXPAUHINSTANCE__@@PAUHWND__@@HHK@Z ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)
.text$mn:00000823
.text$mn:00000823 loc_823:                                ; CODE XREF: Splitter::rotate(void)+10j
.text$mn:00000823                 mov     esp, ebp
.text$mn:00000825                 pop     ebp
.text$mn:00000826                 retn
.text$mn:00000826 ?rotate@Splitter@@QAEXXZ endp
.text$mn:00000826
.text$mn:00000826 ; ---------------------------------------------------------------------------
.text$mn:00000827                 db 5 dup(0CCh)
.text$mn:0000082C
.text$mn:0000082C ; =============== S U B R O U T I N E =======================================
.text$mn:0000082C
.text$mn:0000082C ; Attributes: bp-based frame
.text$mn:0000082C
.text$mn:0000082C ; __int32 __stdcall Splitter::staticWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
.text$mn:0000082C                 public ?staticWndProc@Splitter@@CGJPAUHWND__@@IIJ@Z
.text$mn:0000082C ?staticWndProc@Splitter@@CGJPAUHWND__@@IIJ@Z proc near
.text$mn:0000082C                                         ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+E3o
.text$mn:0000082C
.text$mn:0000082C var_C           = dword ptr -0Ch
.text$mn:0000082C var_8           = dword ptr -8
.text$mn:0000082C dwNewLong       = dword ptr -4
.text$mn:0000082C hWnd            = dword ptr  8
.text$mn:0000082C Msg             = dword ptr  0Ch
.text$mn:0000082C wParam          = dword ptr  10h
.text$mn:0000082C lParam          = dword ptr  14h
.text$mn:0000082C
.text$mn:0000082C                 push    ebp
.text$mn:0000082D                 mov     ebp, esp
.text$mn:0000082F                 sub     esp, 0Ch
.text$mn:00000832                 mov     eax, [ebp+Msg]
.text$mn:00000835                 mov     [ebp+var_C], eax
.text$mn:00000838                 cmp     [ebp+var_C], 81h ; 'ü'
.text$mn:0000083F                 jz      short loc_843
.text$mn:00000841                 jmp     short loc_86B
.text$mn:00000843 ; ---------------------------------------------------------------------------
.text$mn:00000843
.text$mn:00000843 loc_843:                                ; CODE XREF: Splitter::staticWndProc(HWND__ *,uint,uint,long)+13j
.text$mn:00000843                 mov     ecx, [ebp+lParam]
.text$mn:00000846                 mov     edx, [ecx]
.text$mn:00000848                 mov     [ebp+dwNewLong], edx
.text$mn:0000084B                 mov     eax, [ebp+dwNewLong]
.text$mn:0000084E                 mov     ecx, [ebp+hWnd]
.text$mn:00000851                 mov     [eax+0Ch], ecx
.text$mn:00000854                 mov     edx, [ebp+dwNewLong]
.text$mn:00000857                 push    edx             ; dwNewLong
.text$mn:00000858                 push    0FFFFFFEBh      ; nIndex
.text$mn:0000085A                 mov     eax, [ebp+hWnd]
.text$mn:0000085D                 push    eax             ; hWnd
.text$mn:0000085E                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:00000864                 mov     eax, 1
.text$mn:00000869                 jmp     short loc_8AD
.text$mn:0000086B ; ---------------------------------------------------------------------------
.text$mn:0000086B
.text$mn:0000086B loc_86B:                                ; CODE XREF: Splitter::staticWndProc(HWND__ *,uint,uint,long)+15j
.text$mn:0000086B                 push    0FFFFFFEBh      ; nIndex
.text$mn:0000086D                 mov     ecx, [ebp+hWnd]
.text$mn:00000870                 push    ecx             ; hWnd
.text$mn:00000871                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:00000877                 mov     [ebp+var_8], eax
.text$mn:0000087A                 cmp     [ebp+var_8], 0
.text$mn:0000087E                 jnz     short loc_898
.text$mn:00000880                 mov     edx, [ebp+lParam]
.text$mn:00000883                 push    edx             ; lParam
.text$mn:00000884                 mov     eax, [ebp+wParam]
.text$mn:00000887                 push    eax             ; wParam
.text$mn:00000888                 mov     ecx, [ebp+Msg]
.text$mn:0000088B                 push    ecx             ; Msg
.text$mn:0000088C                 mov     edx, [ebp+hWnd]
.text$mn:0000088F                 push    edx             ; hWnd
.text$mn:00000890                 call    dword ptr ds:__imp__DefWindowProcW@16 ; DefWindowProcW(x,x,x,x)
.text$mn:00000896                 jmp     short loc_8AD
.text$mn:00000898 ; ---------------------------------------------------------------------------
.text$mn:00000898
.text$mn:00000898 loc_898:                                ; CODE XREF: Splitter::staticWndProc(HWND__ *,uint,uint,long)+52j
.text$mn:00000898                 mov     eax, [ebp+lParam]
.text$mn:0000089B                 push    eax             ; lParam
.text$mn:0000089C                 mov     ecx, [ebp+wParam]
.text$mn:0000089F                 push    ecx             ; wParam
.text$mn:000008A0                 mov     edx, [ebp+Msg]
.text$mn:000008A3                 push    edx             ; Msg
.text$mn:000008A4                 mov     eax, [ebp+var_8]
.text$mn:000008A7                 push    eax             ; this
.text$mn:000008A8                 call    ?spliterWndProc@Splitter@@AAGJIIJ@Z ; Splitter::spliterWndProc(uint,uint,long)
.text$mn:000008AD
.text$mn:000008AD loc_8AD:                                ; CODE XREF: Splitter::staticWndProc(HWND__ *,uint,uint,long)+3Dj
.text$mn:000008AD                                         ; Splitter::staticWndProc(HWND__ *,uint,uint,long)+6Aj
.text$mn:000008AD                 mov     esp, ebp
.text$mn:000008AF                 pop     ebp
.text$mn:000008B0                 retn    10h
.text$mn:000008B0 ?staticWndProc@Splitter@@CGJPAUHWND__@@IIJ@Z endp
.text$mn:000008B0
.text$mn:000008B0 ; ---------------------------------------------------------------------------
.text$mn:000008B3                 db 9 dup(0CCh)
.text$mn:000008BC
.text$mn:000008BC ; =============== S U B R O U T I N E =======================================
.text$mn:000008BC
.text$mn:000008BC ; Attributes: bp-based frame
.text$mn:000008BC
.text$mn:000008BC ; __int32 __stdcall Splitter::spliterWndProc(Splitter *this, UINT Msg, WPARAM wParam, LPARAM lParam)
.text$mn:000008BC                 public ?spliterWndProc@Splitter@@AAGJIIJ@Z
.text$mn:000008BC ?spliterWndProc@Splitter@@AAGJIIJ@Z proc near
.text$mn:000008BC                                         ; CODE XREF: Splitter::staticWndProc(HWND__ *,uint,uint,long)+7Cp
.text$mn:000008BC
.text$mn:000008BC var_30          = tagPOINT ptr -30h
.text$mn:000008BC var_28          = tagPOINT ptr -28h
.text$mn:000008BC Point           = tagPOINT ptr -20h
.text$mn:000008BC var_18          = dword ptr -18h
.text$mn:000008BC Rect            = tagRECT ptr -14h
.text$mn:000008BC var_4           = dword ptr -4
.text$mn:000008BC this            = dword ptr  8
.text$mn:000008BC Msg             = dword ptr  0Ch
.text$mn:000008BC wParam          = dword ptr  10h
.text$mn:000008BC lParam          = dword ptr  14h
.text$mn:000008BC
.text$mn:000008BC                 push    ebp
.text$mn:000008BD                 mov     ebp, esp
.text$mn:000008BF                 sub     esp, 30h
.text$mn:000008C2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000008C7                 xor     eax, ebp
.text$mn:000008C9                 mov     [ebp+var_4], eax
.text$mn:000008CC                 mov     eax, [ebp+Msg]
.text$mn:000008CF                 mov     [ebp+var_18], eax
.text$mn:000008D2                 cmp     [ebp+var_18], 200h
.text$mn:000008D9                 ja      short loc_901
.text$mn:000008DB                 cmp     [ebp+var_18], 200h
.text$mn:000008E2                 jz      loc_9E8
.text$mn:000008E8                 cmp     [ebp+var_18], 0Fh
.text$mn:000008EC                 jz      loc_C3A
.text$mn:000008F2                 cmp     [ebp+var_18], 10h
.text$mn:000008F6                 jz      loc_C46
.text$mn:000008FC                 jmp     $LN26           ; jumptable 00000921 default case
.text$mn:00000901 ; ---------------------------------------------------------------------------
.text$mn:00000901
.text$mn:00000901 loc_901:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+1Dj
.text$mn:00000901                 mov     ecx, [ebp+var_18]
.text$mn:00000904                 sub     ecx, 201h
.text$mn:0000090A                 mov     [ebp+var_18], ecx
.text$mn:0000090D                 cmp     [ebp+var_18], 14h ; switch 21 cases
.text$mn:00000911                 ja      $LN26           ; jumptable 00000921 default case
.text$mn:00000917                 mov     edx, [ebp+var_18]
.text$mn:0000091A                 movzx   eax, ds:$LN31[edx]
.text$mn:00000921                 jmp     ds:$LN32[eax*4] ; switch jump
.text$mn:00000928 ; ---------------------------------------------------------------------------
.text$mn:00000928
.text$mn:00000928 $LN25:                                  ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+65j
.text$mn:00000928                                         ; DATA XREF: .text$mn:$LN32o
.text$mn:00000928                 mov     ecx, [ebp+lParam] ; jumptable 00000921 case 0
.text$mn:0000092B                 and     ecx, 0FFFFh
.text$mn:00000931                 movzx   edx, cx
.text$mn:00000934                 mov     [ebp+var_28.x], edx
.text$mn:00000937                 mov     eax, [ebp+lParam]
.text$mn:0000093A                 shr     eax, 10h
.text$mn:0000093D                 and     eax, 0FFFFh
.text$mn:00000942                 movzx   ecx, ax
.text$mn:00000945                 mov     [ebp+var_28.y], ecx
.text$mn:00000948                 lea     edx, [ebp+var_28]
.text$mn:0000094B                 push    edx             ; struct tagPOINT *
.text$mn:0000094C                 mov     ecx, [ebp+this] ; this
.text$mn:0000094F                 call    ?isInLeftTopZone@Splitter@@ABE_NABUtagPOINT@@@Z ; Splitter::isInLeftTopZone(tagPOINT const &)
.text$mn:00000954                 movzx   eax, al
.text$mn:00000957                 test    eax, eax
.text$mn:00000959                 jz      short loc_973
.text$mn:0000095B                 cmp     [ebp+wParam], 1
.text$mn:0000095F                 jnz     short loc_973
.text$mn:00000961                 mov     ecx, [ebp+this] ; this
.text$mn:00000964                 call    ?gotoTopLeft@Splitter@@AAEXXZ ; Splitter::gotoTopLeft(void)
.text$mn:00000969                 mov     eax, 1
.text$mn:0000096E                 jmp     loc_C70
.text$mn:00000973 ; ---------------------------------------------------------------------------
.text$mn:00000973
.text$mn:00000973 loc_973:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+9Dj
.text$mn:00000973                                         ; Splitter::spliterWndProc(uint,uint,long)+A3j
.text$mn:00000973                 lea     ecx, [ebp+var_28]
.text$mn:00000976                 push    ecx             ; struct tagPOINT *
.text$mn:00000977                 mov     ecx, [ebp+this] ; this
.text$mn:0000097A                 call    ?isInRightBottomZone@Splitter@@ABE_NABUtagPOINT@@@Z ; Splitter::isInRightBottomZone(tagPOINT const &)
.text$mn:0000097F                 movzx   edx, al
.text$mn:00000982                 test    edx, edx
.text$mn:00000984                 jz      short loc_99E
.text$mn:00000986                 cmp     [ebp+wParam], 1
.text$mn:0000098A                 jnz     short loc_99E
.text$mn:0000098C                 mov     ecx, [ebp+this] ; this
.text$mn:0000098F                 call    ?gotoRightBouuom@Splitter@@AAEXXZ ; Splitter::gotoRightBouuom(void)
.text$mn:00000994                 mov     eax, 1
.text$mn:00000999                 jmp     loc_C70
.text$mn:0000099E ; ---------------------------------------------------------------------------
.text$mn:0000099E
.text$mn:0000099E loc_99E:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+C8j
.text$mn:0000099E                                         ; Splitter::spliterWndProc(uint,uint,long)+CEj
.text$mn:0000099E                 mov     eax, [ebp+this]
.text$mn:000009A1                 movzx   ecx, byte ptr [eax+30h]
.text$mn:000009A5                 test    ecx, ecx
.text$mn:000009A7                 jnz     short loc_9BD
.text$mn:000009A9                 mov     edx, [ebp+this]
.text$mn:000009AC                 mov     eax, [edx+0Ch]
.text$mn:000009AF                 push    eax             ; hWnd
.text$mn:000009B0                 call    dword ptr ds:__imp__SetCapture@4 ; SetCapture(x)
.text$mn:000009B6                 mov     ecx, [ebp+this]
.text$mn:000009B9                 mov     byte ptr [ecx+28h], 1
.text$mn:000009BD
.text$mn:000009BD loc_9BD:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+EBj
.text$mn:000009BD                 xor     eax, eax
.text$mn:000009BF                 jmp     loc_C70
.text$mn:000009C4 ; ---------------------------------------------------------------------------
.text$mn:000009C4
.text$mn:000009C4 $LN21:                                  ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+65j
.text$mn:000009C4                                         ; DATA XREF: .text$mn:$LN32o
.text$mn:000009C4                 mov     edx, [ebp+lParam] ; jumptable 00000921 case 3
.text$mn:000009C7                 push    edx             ; lParam
.text$mn:000009C8                 mov     eax, [ebp+wParam]
.text$mn:000009CB                 push    eax             ; wParam
.text$mn:000009CC                 push    13A3h           ; Msg
.text$mn:000009D1                 mov     ecx, [ebp+this]
.text$mn:000009D4                 mov     edx, [ecx+8]
.text$mn:000009D7                 push    edx             ; hWnd
.text$mn:000009D8                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000009DE                 mov     eax, 1
.text$mn:000009E3                 jmp     loc_C70
.text$mn:000009E8 ; ---------------------------------------------------------------------------
.text$mn:000009E8
.text$mn:000009E8 loc_9E8:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+26j
.text$mn:000009E8                 mov     eax, [ebp+lParam]
.text$mn:000009EB                 and     eax, 0FFFFh
.text$mn:000009F0                 movzx   ecx, ax
.text$mn:000009F3                 mov     [ebp+var_30.x], ecx
.text$mn:000009F6                 mov     edx, [ebp+lParam]
.text$mn:000009F9                 shr     edx, 10h
.text$mn:000009FC                 and     edx, 0FFFFh
.text$mn:00000A02                 movzx   eax, dx
.text$mn:00000A05                 mov     [ebp+var_30.y], eax
.text$mn:00000A08                 lea     ecx, [ebp+var_30]
.text$mn:00000A0B                 push    ecx             ; struct tagPOINT *
.text$mn:00000A0C                 mov     ecx, [ebp+this] ; this
.text$mn:00000A0F                 call    ?isInLeftTopZone@Splitter@@ABE_NABUtagPOINT@@@Z ; Splitter::isInLeftTopZone(tagPOINT const &)
.text$mn:00000A14                 movzx   edx, al
.text$mn:00000A17                 test    edx, edx
.text$mn:00000A19                 jnz     short loc_A2E
.text$mn:00000A1B                 lea     eax, [ebp+var_30]
.text$mn:00000A1E                 push    eax             ; struct tagPOINT *
.text$mn:00000A1F                 mov     ecx, [ebp+this] ; this
.text$mn:00000A22                 call    ?isInRightBottomZone@Splitter@@ABE_NABUtagPOINT@@@Z ; Splitter::isInRightBottomZone(tagPOINT const &)
.text$mn:00000A27                 movzx   ecx, al
.text$mn:00000A2A                 test    ecx, ecx
.text$mn:00000A2C                 jz      short loc_A4C
.text$mn:00000A2E
.text$mn:00000A2E loc_A2E:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+15Dj
.text$mn:00000A2E                 push    7F00h           ; lpCursorName
.text$mn:00000A33                 push    0               ; hInstance
.text$mn:00000A35                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:00000A3B                 push    eax             ; hCursor
.text$mn:00000A3C                 call    dword ptr ds:__imp__SetCursor@4 ; SetCursor(x)
.text$mn:00000A42                 mov     eax, 1
.text$mn:00000A47                 jmp     loc_C70
.text$mn:00000A4C ; ---------------------------------------------------------------------------
.text$mn:00000A4C
.text$mn:00000A4C loc_A4C:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+170j
.text$mn:00000A4C                 mov     edx, [ebp+this]
.text$mn:00000A4F                 movzx   eax, byte ptr [edx+30h]
.text$mn:00000A53                 test    eax, eax
.text$mn:00000A55                 jnz     loc_BBA
.text$mn:00000A5B                 cmp     [ebp+wParam], 1
.text$mn:00000A5F                 jnz     loc_BBA
.text$mn:00000A65                 lea     ecx, [ebp+Rect]
.text$mn:00000A68                 push    ecx             ; lpRect
.text$mn:00000A69                 mov     edx, [ebp+this]
.text$mn:00000A6C                 mov     eax, [edx+8]
.text$mn:00000A6F                 push    eax             ; hWnd
.text$mn:00000A70                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00000A76                 lea     ecx, [ebp+Point]
.text$mn:00000A79                 push    ecx             ; lpPoint
.text$mn:00000A7A                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:00000A80                 lea     edx, [ebp+Point]
.text$mn:00000A83                 push    edx             ; lpPoint
.text$mn:00000A84                 mov     eax, [ebp+this]
.text$mn:00000A87                 mov     ecx, [eax+8]
.text$mn:00000A8A                 push    ecx             ; hWnd
.text$mn:00000A8B                 call    dword ptr ds:__imp__ScreenToClient@8 ; ScreenToClient(x,x)
.text$mn:00000A91                 mov     edx, [ebp+this]
.text$mn:00000A94                 mov     eax, [edx+2Ch]
.text$mn:00000A97                 and     eax, 1
.text$mn:00000A9A                 jz      short loc_AFF
.text$mn:00000A9C                 cmp     [ebp+Point.y], 1
.text$mn:00000AA0                 jg      short loc_AB8
.text$mn:00000AA2                 mov     ecx, [ebp+this]
.text$mn:00000AA5                 mov     dword ptr [ecx+14h], 1
.text$mn:00000AAC                 mov     edx, [ebp+this]
.text$mn:00000AAF                 mov     dword ptr [edx+20h], 1
.text$mn:00000AB6                 jmp     short loc_AFD
.text$mn:00000AB8 ; ---------------------------------------------------------------------------
.text$mn:00000AB8
.text$mn:00000AB8 loc_AB8:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+1E4j
.text$mn:00000AB8                 mov     eax, [ebp+Rect.bottom]
.text$mn:00000ABB                 sub     eax, 5
.text$mn:00000ABE                 cmp     [ebp+Point.y], eax
.text$mn:00000AC1                 jg      short loc_AE7
.text$mn:00000AC3                 mov     ecx, [ebp+this]
.text$mn:00000AC6                 mov     edx, [ebp+Point.y]
.text$mn:00000AC9                 mov     [ecx+14h], edx
.text$mn:00000ACC                 imul    eax, [ebp+Point.y], 64h
.text$mn:00000AD0                 cdq
.text$mn:00000AD1                 idiv    [ebp+Rect.bottom]
.text$mn:00000AD4                 imul    eax, 64h
.text$mn:00000AD7                 cdq
.text$mn:00000AD8                 mov     ecx, 64h ; 'd'
.text$mn:00000ADD                 idiv    ecx
.text$mn:00000ADF                 mov     edx, [ebp+this]
.text$mn:00000AE2                 mov     [edx+20h], eax
.text$mn:00000AE5                 jmp     short loc_AFD
.text$mn:00000AE7 ; ---------------------------------------------------------------------------
.text$mn:00000AE7
.text$mn:00000AE7 loc_AE7:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+205j
.text$mn:00000AE7                 mov     eax, [ebp+Rect.bottom]
.text$mn:00000AEA                 sub     eax, 5
.text$mn:00000AED                 mov     ecx, [ebp+this]
.text$mn:00000AF0                 mov     [ecx+14h], eax
.text$mn:00000AF3                 mov     edx, [ebp+this]
.text$mn:00000AF6                 mov     dword ptr [edx+20h], 63h ; 'c'
.text$mn:00000AFD
.text$mn:00000AFD loc_AFD:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+1FAj
.text$mn:00000AFD                                         ; Splitter::spliterWndProc(uint,uint,long)+229j
.text$mn:00000AFD                 jmp     short loc_B60
.text$mn:00000AFF ; ---------------------------------------------------------------------------
.text$mn:00000AFF
.text$mn:00000AFF loc_AFF:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+1DEj
.text$mn:00000AFF                 cmp     [ebp+Point.x], 1
.text$mn:00000B03                 jg      short loc_B1B
.text$mn:00000B05                 mov     eax, [ebp+this]
.text$mn:00000B08                 mov     dword ptr [eax+10h], 1
.text$mn:00000B0F                 mov     ecx, [ebp+this]
.text$mn:00000B12                 mov     dword ptr [ecx+20h], 1
.text$mn:00000B19                 jmp     short loc_B60
.text$mn:00000B1B ; ---------------------------------------------------------------------------
.text$mn:00000B1B
.text$mn:00000B1B loc_B1B:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+247j
.text$mn:00000B1B                 mov     edx, [ebp+Rect.right]
.text$mn:00000B1E                 sub     edx, 5
.text$mn:00000B21                 cmp     [ebp+Point.x], edx
.text$mn:00000B24                 jg      short loc_B4A
.text$mn:00000B26                 mov     eax, [ebp+this]
.text$mn:00000B29                 mov     ecx, [ebp+Point.x]
.text$mn:00000B2C                 mov     [eax+10h], ecx
.text$mn:00000B2F                 imul    eax, [ebp+Point.x], 64h
.text$mn:00000B33                 cdq
.text$mn:00000B34                 idiv    [ebp+Rect.right]
.text$mn:00000B37                 imul    eax, 64h
.text$mn:00000B3A                 cdq
.text$mn:00000B3B                 mov     ecx, 64h ; 'd'
.text$mn:00000B40                 idiv    ecx
.text$mn:00000B42                 mov     edx, [ebp+this]
.text$mn:00000B45                 mov     [edx+20h], eax
.text$mn:00000B48                 jmp     short loc_B60
.text$mn:00000B4A ; ---------------------------------------------------------------------------
.text$mn:00000B4A
.text$mn:00000B4A loc_B4A:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+268j
.text$mn:00000B4A                 mov     eax, [ebp+Rect.right]
.text$mn:00000B4D                 sub     eax, 5
.text$mn:00000B50                 mov     ecx, [ebp+this]
.text$mn:00000B53                 mov     [ecx+10h], eax
.text$mn:00000B56                 mov     edx, [ebp+this]
.text$mn:00000B59                 mov     dword ptr [edx+20h], 63h ; 'c'
.text$mn:00000B60
.text$mn:00000B60 loc_B60:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long):loc_AFDj
.text$mn:00000B60                                         ; Splitter::spliterWndProc(uint,uint,long)+25Dj ...
.text$mn:00000B60                 mov     eax, [ebp+this]
.text$mn:00000B63                 mov     ecx, [eax+14h]
.text$mn:00000B66                 push    ecx             ; lParam
.text$mn:00000B67                 mov     edx, [ebp+this]
.text$mn:00000B6A                 mov     eax, [edx+10h]
.text$mn:00000B6D                 push    eax             ; wParam
.text$mn:00000B6E                 push    13A4h           ; Msg
.text$mn:00000B73                 mov     ecx, [ebp+this]
.text$mn:00000B76                 mov     edx, [ecx+8]
.text$mn:00000B79                 push    edx             ; hWnd
.text$mn:00000B7A                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000B80                 push    0               ; bRepaint
.text$mn:00000B82                 mov     eax, [ebp+this]
.text$mn:00000B85                 mov     ecx, [eax+1Ch]
.text$mn:00000B88                 push    ecx             ; nHeight
.text$mn:00000B89                 mov     edx, [ebp+this]
.text$mn:00000B8C                 mov     eax, [edx+18h]
.text$mn:00000B8F                 push    eax             ; nWidth
.text$mn:00000B90                 mov     ecx, [ebp+this]
.text$mn:00000B93                 mov     edx, [ecx+14h]
.text$mn:00000B96                 push    edx             ; Y
.text$mn:00000B97                 mov     eax, [ebp+this]
.text$mn:00000B9A                 mov     ecx, [eax+10h]
.text$mn:00000B9D                 push    ecx             ; X
.text$mn:00000B9E                 mov     edx, [ebp+this]
.text$mn:00000BA1                 mov     eax, [edx+0Ch]
.text$mn:00000BA4                 push    eax             ; hWnd
.text$mn:00000BA5                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00000BAB                 push    0
.text$mn:00000BAD                 mov     ecx, [ebp+this]
.text$mn:00000BB0                 mov     edx, [ecx]
.text$mn:00000BB2                 mov     ecx, [ebp+this]
.text$mn:00000BB5                 mov     eax, [edx+18h]
.text$mn:00000BB8                 call    eax
.text$mn:00000BBA
.text$mn:00000BBA loc_BBA:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+199j
.text$mn:00000BBA                                         ; Splitter::spliterWndProc(uint,uint,long)+1A3j
.text$mn:00000BBA                 xor     eax, eax
.text$mn:00000BBC                 jmp     loc_C70
.text$mn:00000BC1 ; ---------------------------------------------------------------------------
.text$mn:00000BC1
.text$mn:00000BC1 $LN6_2:                                 ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+65j
.text$mn:00000BC1                                         ; DATA XREF: .text$mn:$LN32o
.text$mn:00000BC1                 mov     ecx, [ebp+this] ; jumptable 00000921 case 1
.text$mn:00000BC4                 movzx   edx, byte ptr [ecx+30h]
.text$mn:00000BC8                 test    edx, edx
.text$mn:00000BCA                 jnz     short loc_BD2
.text$mn:00000BCC                 call    dword ptr ds:__imp__ReleaseCapture@0 ; ReleaseCapture()
.text$mn:00000BD2
.text$mn:00000BD2 loc_BD2:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+30Ej
.text$mn:00000BD2                 xor     eax, eax
.text$mn:00000BD4                 jmp     loc_C70
.text$mn:00000BD9 ; ---------------------------------------------------------------------------
.text$mn:00000BD9
.text$mn:00000BD9 $LN4:                                   ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+65j
.text$mn:00000BD9                                         ; DATA XREF: .text$mn:$LN32o
.text$mn:00000BD9                 mov     eax, [ebp+this] ; jumptable 00000921 case 20
.text$mn:00000BDC                 movzx   ecx, byte ptr [eax+28h]
.text$mn:00000BE0                 test    ecx, ecx
.text$mn:00000BE2                 jz      short loc_C36
.text$mn:00000BE4                 mov     edx, [ebp+this]
.text$mn:00000BE7                 mov     eax, [edx+14h]
.text$mn:00000BEA                 push    eax             ; lParam
.text$mn:00000BEB                 mov     ecx, [ebp+this]
.text$mn:00000BEE                 mov     edx, [ecx+10h]
.text$mn:00000BF1                 push    edx             ; wParam
.text$mn:00000BF2                 push    13A4h           ; Msg
.text$mn:00000BF7                 mov     eax, [ebp+this]
.text$mn:00000BFA                 mov     ecx, [eax+8]
.text$mn:00000BFD                 push    ecx             ; hWnd
.text$mn:00000BFE                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000C04                 push    1               ; bRepaint
.text$mn:00000C06                 mov     edx, [ebp+this]
.text$mn:00000C09                 mov     eax, [edx+1Ch]
.text$mn:00000C0C                 push    eax             ; nHeight
.text$mn:00000C0D                 mov     ecx, [ebp+this]
.text$mn:00000C10                 mov     edx, [ecx+18h]
.text$mn:00000C13                 push    edx             ; nWidth
.text$mn:00000C14                 mov     eax, [ebp+this]
.text$mn:00000C17                 mov     ecx, [eax+14h]
.text$mn:00000C1A                 push    ecx             ; Y
.text$mn:00000C1B                 mov     edx, [ebp+this]
.text$mn:00000C1E                 mov     eax, [edx+10h]
.text$mn:00000C21                 push    eax             ; X
.text$mn:00000C22                 mov     ecx, [ebp+this]
.text$mn:00000C25                 mov     edx, [ecx+0Ch]
.text$mn:00000C28                 push    edx             ; hWnd
.text$mn:00000C29                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00000C2F                 mov     eax, [ebp+this]
.text$mn:00000C32                 mov     byte ptr [eax+28h], 0
.text$mn:00000C36
.text$mn:00000C36 loc_C36:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+326j
.text$mn:00000C36                 xor     eax, eax
.text$mn:00000C38                 jmp     short loc_C70
.text$mn:00000C3A ; ---------------------------------------------------------------------------
.text$mn:00000C3A
.text$mn:00000C3A loc_C3A:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+30j
.text$mn:00000C3A                 mov     ecx, [ebp+this] ; this
.text$mn:00000C3D                 call    ?drawSplitter@Splitter@@AAEXXZ ; Splitter::drawSplitter(void)
.text$mn:00000C42                 xor     eax, eax
.text$mn:00000C44                 jmp     short loc_C70
.text$mn:00000C46 ; ---------------------------------------------------------------------------
.text$mn:00000C46
.text$mn:00000C46 loc_C46:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+3Aj
.text$mn:00000C46                 mov     ecx, [ebp+this]
.text$mn:00000C49                 mov     edx, [ecx]
.text$mn:00000C4B                 mov     ecx, [ebp+this]
.text$mn:00000C4E                 mov     eax, [edx+8]
.text$mn:00000C51                 call    eax
.text$mn:00000C53                 xor     eax, eax
.text$mn:00000C55                 jmp     short loc_C70
.text$mn:00000C57 ; ---------------------------------------------------------------------------
.text$mn:00000C57
.text$mn:00000C57 $LN26:                                  ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+40j
.text$mn:00000C57                                         ; Splitter::spliterWndProc(uint,uint,long)+55j ...
.text$mn:00000C57                 mov     ecx, [ebp+lParam] ; jumptable 00000921 default case
.text$mn:00000C5A                 push    ecx             ; lParam
.text$mn:00000C5B                 mov     edx, [ebp+wParam]
.text$mn:00000C5E                 push    edx             ; wParam
.text$mn:00000C5F                 mov     eax, [ebp+Msg]
.text$mn:00000C62                 push    eax             ; Msg
.text$mn:00000C63                 mov     ecx, [ebp+this]
.text$mn:00000C66                 mov     edx, [ecx+0Ch]
.text$mn:00000C69                 push    edx             ; hWnd
.text$mn:00000C6A                 call    dword ptr ds:__imp__DefWindowProcW@16 ; DefWindowProcW(x,x,x,x)
.text$mn:00000C70
.text$mn:00000C70 loc_C70:                                ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+B2j
.text$mn:00000C70                                         ; Splitter::spliterWndProc(uint,uint,long)+DDj ...
.text$mn:00000C70                 mov     ecx, [ebp+var_4]
.text$mn:00000C73                 xor     ecx, ebp
.text$mn:00000C75                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000C7A                 mov     esp, ebp
.text$mn:00000C7C                 pop     ebp
.text$mn:00000C7D                 retn    10h
.text$mn:00000C7D ?spliterWndProc@Splitter@@AAGJIIJ@Z endp
.text$mn:00000C7D
.text$mn:00000C7D ; ---------------------------------------------------------------------------
.text$mn:00000C80 $LN32           dd offset $LN25         ; DATA XREF: Splitter::spliterWndProc(uint,uint,long)+65r
.text$mn:00000C80                 dd offset $LN6_2        ; jump table for switch statement
.text$mn:00000C80                 dd offset $LN21
.text$mn:00000C80                 dd offset $LN4
.text$mn:00000C80                 dd offset $LN26
.text$mn:00000C94 $LN31           db      0,     1,     4,     2
.text$mn:00000C94                                         ; DATA XREF: Splitter::spliterWndProc(uint,uint,long)+5Er
.text$mn:00000C94                 db      4,     4,     4,     4 ; indirect table for switch statement
.text$mn:00000C94                 db      4,     4,     4,     4
.text$mn:00000C94                 db      4,     4,     4,     4
.text$mn:00000C94                 db      4,     4,     4,     4
.text$mn:00000C94                 db      3
.text$mn:00000CA9                 align 4
.text$mn:00000CAC
.text$mn:00000CAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000CAC
.text$mn:00000CAC ; Attributes: bp-based frame
.text$mn:00000CAC
.text$mn:00000CAC ; int __thiscall Splitter::getClickZone(Splitter *this, bool)
.text$mn:00000CAC                 public ?getClickZone@Splitter@@AAEH_N@Z
.text$mn:00000CAC ?getClickZone@Splitter@@AAEH_N@Z proc near
.text$mn:00000CAC                                         ; CODE XREF: Splitter::resizeSpliter(tagRECT *)+130p
.text$mn:00000CAC                                         ; Splitter::resizeSpliter(tagRECT *)+140p ...
.text$mn:00000CAC
.text$mn:00000CAC var_1C          = dword ptr -1Ch
.text$mn:00000CAC var_18          = dword ptr -18h
.text$mn:00000CAC var_14          = dword ptr -14h
.text$mn:00000CAC var_10          = dword ptr -10h
.text$mn:00000CAC var_C           = dword ptr -0Ch
.text$mn:00000CAC var_8           = dword ptr -8
.text$mn:00000CAC var_4           = dword ptr -4
.text$mn:00000CAC arg_0           = byte ptr  8
.text$mn:00000CAC
.text$mn:00000CAC                 push    ebp
.text$mn:00000CAD                 mov     ebp, esp
.text$mn:00000CAF                 sub     esp, 1Ch
.text$mn:00000CB2                 mov     [ebp+var_4], ecx
.text$mn:00000CB5                 mov     eax, [ebp+var_4]
.text$mn:00000CB8                 cmp     dword ptr [eax+24h], 8
.text$mn:00000CBC                 jg      short loc_D18
.text$mn:00000CBE                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000CC1                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:00000CC6                 movzx   ecx, al
.text$mn:00000CC9                 test    ecx, ecx
.text$mn:00000CCB                 jz      short loc_CF0
.text$mn:00000CCD                 movzx   edx, [ebp+arg_0]
.text$mn:00000CD1                 cmp     edx, 1
.text$mn:00000CD4                 jnz     short loc_CE1
.text$mn:00000CD6                 mov     eax, [ebp+var_4]
.text$mn:00000CD9                 mov     ecx, [eax+24h]
.text$mn:00000CDC                 mov     [ebp+var_8], ecx
.text$mn:00000CDF                 jmp     short loc_CE8
.text$mn:00000CE1 ; ---------------------------------------------------------------------------
.text$mn:00000CE1
.text$mn:00000CE1 loc_CE1:                                ; CODE XREF: Splitter::getClickZone(bool)+28j
.text$mn:00000CE1                 mov     [ebp+var_8], 0Fh
.text$mn:00000CE8
.text$mn:00000CE8 loc_CE8:                                ; CODE XREF: Splitter::getClickZone(bool)+33j
.text$mn:00000CE8                 mov     edx, [ebp+var_8]
.text$mn:00000CEB                 mov     [ebp+var_10], edx
.text$mn:00000CEE                 jmp     short loc_D11
.text$mn:00000CF0 ; ---------------------------------------------------------------------------
.text$mn:00000CF0
.text$mn:00000CF0 loc_CF0:                                ; CODE XREF: Splitter::getClickZone(bool)+1Fj
.text$mn:00000CF0                 movzx   eax, [ebp+arg_0]
.text$mn:00000CF4                 cmp     eax, 1
.text$mn:00000CF7                 jnz     short loc_D02
.text$mn:00000CF9                 mov     [ebp+var_C], 0Fh
.text$mn:00000D00                 jmp     short loc_D0B
.text$mn:00000D02 ; ---------------------------------------------------------------------------
.text$mn:00000D02
.text$mn:00000D02 loc_D02:                                ; CODE XREF: Splitter::getClickZone(bool)+4Bj
.text$mn:00000D02                 mov     ecx, [ebp+var_4]
.text$mn:00000D05                 mov     edx, [ecx+24h]
.text$mn:00000D08                 mov     [ebp+var_C], edx
.text$mn:00000D0B
.text$mn:00000D0B loc_D0B:                                ; CODE XREF: Splitter::getClickZone(bool)+54j
.text$mn:00000D0B                 mov     eax, [ebp+var_C]
.text$mn:00000D0E                 mov     [ebp+var_10], eax
.text$mn:00000D11
.text$mn:00000D11 loc_D11:                                ; CODE XREF: Splitter::getClickZone(bool)+42j
.text$mn:00000D11                 mov     eax, [ebp+var_10]
.text$mn:00000D14                 jmp     short loc_D6A
.text$mn:00000D16 ; ---------------------------------------------------------------------------
.text$mn:00000D16                 jmp     short loc_D6A
.text$mn:00000D18 ; ---------------------------------------------------------------------------
.text$mn:00000D18
.text$mn:00000D18 loc_D18:                                ; CODE XREF: Splitter::getClickZone(bool)+10j
.text$mn:00000D18                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000D1B                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:00000D20                 movzx   ecx, al
.text$mn:00000D23                 test    ecx, ecx
.text$mn:00000D25                 jz      short loc_D48
.text$mn:00000D27                 movzx   edx, [ebp+arg_0]
.text$mn:00000D2B                 cmp     edx, 1
.text$mn:00000D2E                 jnz     short loc_D39
.text$mn:00000D30                 mov     [ebp+var_14], 8
.text$mn:00000D37                 jmp     short loc_D40
.text$mn:00000D39 ; ---------------------------------------------------------------------------
.text$mn:00000D39
.text$mn:00000D39 loc_D39:                                ; CODE XREF: Splitter::getClickZone(bool)+82j
.text$mn:00000D39                 mov     [ebp+var_14], 0Fh
.text$mn:00000D40
.text$mn:00000D40 loc_D40:                                ; CODE XREF: Splitter::getClickZone(bool)+8Bj
.text$mn:00000D40                 mov     eax, [ebp+var_14]
.text$mn:00000D43                 mov     [ebp+var_1C], eax
.text$mn:00000D46                 jmp     short loc_D67
.text$mn:00000D48 ; ---------------------------------------------------------------------------
.text$mn:00000D48
.text$mn:00000D48 loc_D48:                                ; CODE XREF: Splitter::getClickZone(bool)+79j
.text$mn:00000D48                 movzx   ecx, [ebp+arg_0]
.text$mn:00000D4C                 cmp     ecx, 1
.text$mn:00000D4F                 jnz     short loc_D5A
.text$mn:00000D51                 mov     [ebp+var_18], 0Fh
.text$mn:00000D58                 jmp     short loc_D61
.text$mn:00000D5A ; ---------------------------------------------------------------------------
.text$mn:00000D5A
.text$mn:00000D5A loc_D5A:                                ; CODE XREF: Splitter::getClickZone(bool)+A3j
.text$mn:00000D5A                 mov     [ebp+var_18], 8
.text$mn:00000D61
.text$mn:00000D61 loc_D61:                                ; CODE XREF: Splitter::getClickZone(bool)+ACj
.text$mn:00000D61                 mov     edx, [ebp+var_18]
.text$mn:00000D64                 mov     [ebp+var_1C], edx
.text$mn:00000D67
.text$mn:00000D67 loc_D67:                                ; CODE XREF: Splitter::getClickZone(bool)+9Aj
.text$mn:00000D67                 mov     eax, [ebp+var_1C]
.text$mn:00000D6A
.text$mn:00000D6A loc_D6A:                                ; CODE XREF: Splitter::getClickZone(bool)+68j
.text$mn:00000D6A                                         ; Splitter::getClickZone(bool)+6Aj
.text$mn:00000D6A                 mov     esp, ebp
.text$mn:00000D6C                 pop     ebp
.text$mn:00000D6D                 retn    4
.text$mn:00000D6D ?getClickZone@Splitter@@AAEH_N@Z endp
.text$mn:00000D6D
.text$mn:00000D6D ; ---------------------------------------------------------------------------
.text$mn:00000D70                 db 0Ch dup(0CCh)
.text$mn:00000D7C
.text$mn:00000D7C ; =============== S U B R O U T I N E =======================================
.text$mn:00000D7C
.text$mn:00000D7C ; Attributes: bp-based frame
.text$mn:00000D7C
.text$mn:00000D7C ; void __thiscall Splitter::adjustZoneToDraw(Splitter *this, struct tagRECT *, bool)
.text$mn:00000D7C                 public ?adjustZoneToDraw@Splitter@@AAEXAAUtagRECT@@_N@Z
.text$mn:00000D7C ?adjustZoneToDraw@Splitter@@AAEXAAUtagRECT@@_N@Z proc near
.text$mn:00000D7C                                         ; CODE XREF: Splitter::drawSplitter(void)+73p
.text$mn:00000D7C                                         ; Splitter::drawSplitter(void)+84p
.text$mn:00000D7C
.text$mn:00000D7C var_2C          = dword ptr -2Ch
.text$mn:00000D7C var_28          = dword ptr -28h
.text$mn:00000D7C var_24          = dword ptr -24h
.text$mn:00000D7C var_20          = dword ptr -20h
.text$mn:00000D7C var_1C          = dword ptr -1Ch
.text$mn:00000D7C var_18          = dword ptr -18h
.text$mn:00000D7C var_14          = dword ptr -14h
.text$mn:00000D7C var_10          = dword ptr -10h
.text$mn:00000D7C var_C           = dword ptr -0Ch
.text$mn:00000D7C var_8           = dword ptr -8
.text$mn:00000D7C var_4           = dword ptr -4
.text$mn:00000D7C arg_0           = dword ptr  8
.text$mn:00000D7C arg_4           = byte ptr  0Ch
.text$mn:00000D7C
.text$mn:00000D7C                 push    ebp
.text$mn:00000D7D                 mov     ebp, esp
.text$mn:00000D7F                 sub     esp, 2Ch
.text$mn:00000D82                 mov     [ebp+var_4], ecx
.text$mn:00000D85                 mov     eax, [ebp+var_4]
.text$mn:00000D88                 cmp     dword ptr [eax+24h], 4
.text$mn:00000D8C                 jge     short loc_D93
.text$mn:00000D8E                 jmp     loc_F2B
.text$mn:00000D93 ; ---------------------------------------------------------------------------
.text$mn:00000D93
.text$mn:00000D93 loc_D93:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+10j
.text$mn:00000D93                 mov     ecx, [ebp+var_4]
.text$mn:00000D96                 cmp     dword ptr [ecx+24h], 4
.text$mn:00000D9A                 jl      short loc_DF1
.text$mn:00000D9C                 mov     edx, [ebp+var_4]
.text$mn:00000D9F                 cmp     dword ptr [edx+24h], 8
.text$mn:00000DA3                 jg      short loc_DF1
.text$mn:00000DA5                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000DA8                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:00000DAD                 movzx   eax, al
.text$mn:00000DB0                 test    eax, eax
.text$mn:00000DB2                 jz      short loc_DBD
.text$mn:00000DB4                 mov     [ebp+var_18], 4
.text$mn:00000DBB                 jmp     short loc_DC4
.text$mn:00000DBD ; ---------------------------------------------------------------------------
.text$mn:00000DBD
.text$mn:00000DBD loc_DBD:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+36j
.text$mn:00000DBD                 mov     [ebp+var_18], 7
.text$mn:00000DC4
.text$mn:00000DC4 loc_DC4:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+3Fj
.text$mn:00000DC4                 mov     ecx, [ebp+var_18]
.text$mn:00000DC7                 mov     [ebp+var_8], ecx
.text$mn:00000DCA                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000DCD                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:00000DD2                 movzx   edx, al
.text$mn:00000DD5                 test    edx, edx
.text$mn:00000DD7                 jz      short loc_DE2
.text$mn:00000DD9                 mov     [ebp+var_1C], 7
.text$mn:00000DE0                 jmp     short loc_DE9
.text$mn:00000DE2 ; ---------------------------------------------------------------------------
.text$mn:00000DE2
.text$mn:00000DE2 loc_DE2:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+5Bj
.text$mn:00000DE2                 mov     [ebp+var_1C], 4
.text$mn:00000DE9
.text$mn:00000DE9 loc_DE9:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+64j
.text$mn:00000DE9                 mov     eax, [ebp+var_1C]
.text$mn:00000DEC                 mov     [ebp+var_C], eax
.text$mn:00000DEF                 jmp     short loc_E3B
.text$mn:00000DF1 ; ---------------------------------------------------------------------------
.text$mn:00000DF1
.text$mn:00000DF1 loc_DF1:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+1Ej
.text$mn:00000DF1                                         ; Splitter::adjustZoneToDraw(tagRECT &,bool)+27j
.text$mn:00000DF1                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000DF4                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:00000DF9                 movzx   ecx, al
.text$mn:00000DFC                 test    ecx, ecx
.text$mn:00000DFE                 jz      short loc_E09
.text$mn:00000E00                 mov     [ebp+var_20], 6
.text$mn:00000E07                 jmp     short loc_E10
.text$mn:00000E09 ; ---------------------------------------------------------------------------
.text$mn:00000E09
.text$mn:00000E09 loc_E09:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+82j
.text$mn:00000E09                 mov     [ebp+var_20], 0Bh
.text$mn:00000E10
.text$mn:00000E10 loc_E10:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+8Bj
.text$mn:00000E10                 mov     edx, [ebp+var_20]
.text$mn:00000E13                 mov     [ebp+var_8], edx
.text$mn:00000E16                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E19                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:00000E1E                 movzx   eax, al
.text$mn:00000E21                 test    eax, eax
.text$mn:00000E23                 jz      short loc_E2E
.text$mn:00000E25                 mov     [ebp+var_24], 0Bh
.text$mn:00000E2C                 jmp     short loc_E35
.text$mn:00000E2E ; ---------------------------------------------------------------------------
.text$mn:00000E2E
.text$mn:00000E2E loc_E2E:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+A7j
.text$mn:00000E2E                 mov     [ebp+var_24], 6
.text$mn:00000E35
.text$mn:00000E35 loc_E35:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+B0j
.text$mn:00000E35                 mov     ecx, [ebp+var_24]
.text$mn:00000E38                 mov     [ebp+var_C], ecx
.text$mn:00000E3B
.text$mn:00000E3B loc_E3B:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+73j
.text$mn:00000E3B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E3E                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:00000E43                 movzx   edx, al
.text$mn:00000E46                 test    edx, edx
.text$mn:00000E48                 jz      short loc_EAA
.text$mn:00000E4A                 movzx   eax, [ebp+arg_4]
.text$mn:00000E4E                 cmp     eax, 1
.text$mn:00000E51                 jnz     short loc_E6D
.text$mn:00000E53                 mov     [ebp+var_10], 0
.text$mn:00000E5A                 mov     ecx, [ebp+var_4]
.text$mn:00000E5D                 mov     eax, [ecx+40h]
.text$mn:00000E60                 sub     eax, [ebp+var_C]
.text$mn:00000E63                 cdq
.text$mn:00000E64                 sub     eax, edx
.text$mn:00000E66                 sar     eax, 1
.text$mn:00000E68                 mov     [ebp+var_14], eax
.text$mn:00000E6B                 jmp     short loc_E96
.text$mn:00000E6D ; ---------------------------------------------------------------------------
.text$mn:00000E6D
.text$mn:00000E6D loc_E6D:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+D5j
.text$mn:00000E6D                 mov     edx, [ebp+var_4]
.text$mn:00000E70                 mov     eax, [edx+44h]
.text$mn:00000E73                 mov     ecx, [ebp+var_4]
.text$mn:00000E76                 add     eax, [ecx+4Ch]
.text$mn:00000E79                 sub     eax, [ebp+var_8]
.text$mn:00000E7C                 mov     [ebp+var_10], eax
.text$mn:00000E7F                 mov     edx, [ebp+var_4]
.text$mn:00000E82                 mov     eax, [edx+50h]
.text$mn:00000E85                 sub     eax, [ebp+var_C]
.text$mn:00000E88                 cdq
.text$mn:00000E89                 sub     eax, edx
.text$mn:00000E8B                 sar     eax, 1
.text$mn:00000E8D                 mov     ecx, [ebp+var_4]
.text$mn:00000E90                 add     eax, [ecx+48h]
.text$mn:00000E93                 mov     [ebp+var_14], eax
.text$mn:00000E96
.text$mn:00000E96 loc_E96:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+EFj
.text$mn:00000E96                 mov     edx, [ebp+var_10]
.text$mn:00000E99                 add     edx, [ebp+var_8]
.text$mn:00000E9C                 mov     [ebp+var_28], edx
.text$mn:00000E9F                 mov     eax, [ebp+var_14]
.text$mn:00000EA2                 add     eax, [ebp+var_C]
.text$mn:00000EA5                 mov     [ebp+var_2C], eax
.text$mn:00000EA8                 jmp     short loc_F08
.text$mn:00000EAA ; ---------------------------------------------------------------------------
.text$mn:00000EAA
.text$mn:00000EAA loc_EAA:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+CCj
.text$mn:00000EAA                 movzx   ecx, [ebp+arg_4]
.text$mn:00000EAE                 cmp     ecx, 1
.text$mn:00000EB1                 jnz     short loc_ECD
.text$mn:00000EB3                 mov     edx, [ebp+var_4]
.text$mn:00000EB6                 mov     eax, [edx+3Ch]
.text$mn:00000EB9                 sub     eax, [ebp+var_8]
.text$mn:00000EBC                 cdq
.text$mn:00000EBD                 sub     eax, edx
.text$mn:00000EBF                 sar     eax, 1
.text$mn:00000EC1                 mov     [ebp+var_10], eax
.text$mn:00000EC4                 mov     [ebp+var_14], 0
.text$mn:00000ECB                 jmp     short loc_EF6
.text$mn:00000ECD ; ---------------------------------------------------------------------------
.text$mn:00000ECD
.text$mn:00000ECD loc_ECD:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+135j
.text$mn:00000ECD                 mov     eax, [ebp+var_4]
.text$mn:00000ED0                 mov     eax, [eax+4Ch]
.text$mn:00000ED3                 sub     eax, [ebp+var_8]
.text$mn:00000ED6                 cdq
.text$mn:00000ED7                 sub     eax, edx
.text$mn:00000ED9                 sar     eax, 1
.text$mn:00000EDB                 mov     ecx, [ebp+var_4]
.text$mn:00000EDE                 add     eax, [ecx+44h]
.text$mn:00000EE1                 mov     [ebp+var_10], eax
.text$mn:00000EE4                 mov     edx, [ebp+var_4]
.text$mn:00000EE7                 mov     eax, [edx+48h]
.text$mn:00000EEA                 mov     ecx, [ebp+var_4]
.text$mn:00000EED                 add     eax, [ecx+50h]
.text$mn:00000EF0                 sub     eax, [ebp+var_C]
.text$mn:00000EF3                 mov     [ebp+var_14], eax
.text$mn:00000EF6
.text$mn:00000EF6 loc_EF6:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+14Fj
.text$mn:00000EF6                 mov     edx, [ebp+var_10]
.text$mn:00000EF9                 add     edx, [ebp+var_8]
.text$mn:00000EFC                 mov     [ebp+var_28], edx
.text$mn:00000EFF                 mov     eax, [ebp+var_14]
.text$mn:00000F02                 add     eax, [ebp+var_C]
.text$mn:00000F05                 mov     [ebp+var_2C], eax
.text$mn:00000F08
.text$mn:00000F08 loc_F08:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+12Cj
.text$mn:00000F08                 mov     ecx, [ebp+arg_0]
.text$mn:00000F0B                 mov     edx, [ebp+var_10]
.text$mn:00000F0E                 mov     [ecx], edx
.text$mn:00000F10                 mov     eax, [ebp+arg_0]
.text$mn:00000F13                 mov     ecx, [ebp+var_14]
.text$mn:00000F16                 mov     [eax+4], ecx
.text$mn:00000F19                 mov     edx, [ebp+arg_0]
.text$mn:00000F1C                 mov     eax, [ebp+var_28]
.text$mn:00000F1F                 mov     [edx+8], eax
.text$mn:00000F22                 mov     ecx, [ebp+arg_0]
.text$mn:00000F25                 mov     edx, [ebp+var_2C]
.text$mn:00000F28                 mov     [ecx+0Ch], edx
.text$mn:00000F2B
.text$mn:00000F2B loc_F2B:                                ; CODE XREF: Splitter::adjustZoneToDraw(tagRECT &,bool)+12j
.text$mn:00000F2B                 mov     esp, ebp
.text$mn:00000F2D                 pop     ebp
.text$mn:00000F2E                 retn    8
.text$mn:00000F2E ?adjustZoneToDraw@Splitter@@AAEXAAUtagRECT@@_N@Z endp
.text$mn:00000F2E
.text$mn:00000F2E ; ---------------------------------------------------------------------------
.text$mn:00000F31                 db 0Bh dup(0CCh)
.text$mn:00000F3C
.text$mn:00000F3C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F3C
.text$mn:00000F3C ; Attributes: bp-based frame
.text$mn:00000F3C
.text$mn:00000F3C ; void __thiscall Splitter::drawSplitter(Splitter *__hidden this)
.text$mn:00000F3C                 public ?drawSplitter@Splitter@@AAEXXZ
.text$mn:00000F3C ?drawSplitter@Splitter@@AAEXXZ proc near
.text$mn:00000F3C                                         ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+381p
.text$mn:00000F3C
.text$mn:00000F3C var_B4          = dword ptr -0B4h
.text$mn:00000F3C var_B0          = dword ptr -0B0h
.text$mn:00000F3C var_AC          = dword ptr -0ACh
.text$mn:00000F3C var_A8          = dword ptr -0A8h
.text$mn:00000F3C var_A4          = dword ptr -0A4h
.text$mn:00000F3C var_A0          = dword ptr -0A0h
.text$mn:00000F3C hDC             = dword ptr -9Ch
.text$mn:00000F3C var_98          = dword ptr -98h
.text$mn:00000F3C Paint           = tagPAINTSTRUCT ptr -94h
.text$mn:00000F3C var_54          = tagRECT ptr -54h
.text$mn:00000F3C var_44          = tagRECT ptr -44h
.text$mn:00000F3C var_34          = byte ptr -34h
.text$mn:00000F3C var_2C          = dword ptr -2Ch
.text$mn:00000F3C var_28          = dword ptr -28h
.text$mn:00000F3C rc              = RECT ptr -24h
.text$mn:00000F3C var_14          = RECT ptr -14h
.text$mn:00000F3C var_4           = dword ptr -4
.text$mn:00000F3C
.text$mn:00000F3C                 push    ebp
.text$mn:00000F3D                 mov     ebp, esp
.text$mn:00000F3F                 sub     esp, 0B4h
.text$mn:00000F45                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F4A                 xor     eax, ebp
.text$mn:00000F4C                 mov     [ebp+var_4], eax
.text$mn:00000F4F                 mov     [ebp+var_98], ecx
.text$mn:00000F55                 lea     eax, [ebp+Paint]
.text$mn:00000F5B                 push    eax             ; lpPaint
.text$mn:00000F5C                 mov     ecx, [ebp+var_98]
.text$mn:00000F62                 mov     edx, [ecx+0Ch]
.text$mn:00000F65                 push    edx             ; hWnd
.text$mn:00000F66                 call    dword ptr ds:__imp__BeginPaint@8 ; BeginPaint(x,x)
.text$mn:00000F6C                 mov     [ebp+hDC], eax
.text$mn:00000F72                 lea     eax, [ebp+var_34]
.text$mn:00000F75                 push    eax
.text$mn:00000F76                 mov     ecx, [ebp+var_98]
.text$mn:00000F7C                 mov     edx, [ecx]
.text$mn:00000F7E                 mov     ecx, [ebp+var_98]
.text$mn:00000F84                 mov     eax, [edx+1Ch]
.text$mn:00000F87                 call    eax
.text$mn:00000F89                 mov     ecx, [ebp+var_98]
.text$mn:00000F8F                 cmp     dword ptr [ecx+24h], 4
.text$mn:00000F93                 jl      short loc_100A
.text$mn:00000F95                 mov     edx, [ebp+var_98]
.text$mn:00000F9B                 mov     eax, [edx+2Ch]
.text$mn:00000F9E                 and     eax, 20h
.text$mn:00000FA1                 jz      short loc_100A
.text$mn:00000FA3                 push    1               ; bool
.text$mn:00000FA5                 lea     ecx, [ebp+var_54]
.text$mn:00000FA8                 push    ecx             ; struct tagRECT *
.text$mn:00000FA9                 mov     ecx, [ebp+var_98] ; this
.text$mn:00000FAF                 call    ?adjustZoneToDraw@Splitter@@AAEXAAUtagRECT@@_N@Z ; Splitter::adjustZoneToDraw(tagRECT &,bool)
.text$mn:00000FB4                 push    0               ; bool
.text$mn:00000FB6                 lea     edx, [ebp+var_44]
.text$mn:00000FB9                 push    edx             ; struct tagRECT *
.text$mn:00000FBA                 mov     ecx, [ebp+var_98] ; this
.text$mn:00000FC0                 call    ?adjustZoneToDraw@Splitter@@AAEXAAUtagRECT@@_N@Z ; Splitter::adjustZoneToDraw(tagRECT &,bool)
.text$mn:00000FC5                 mov     ecx, [ebp+var_98] ; this
.text$mn:00000FCB                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:00000FD0                 movzx   eax, al
.text$mn:00000FD3                 test    eax, eax
.text$mn:00000FD5                 jz      short loc_FE3
.text$mn:00000FD7                 mov     [ebp+var_B0], 0
.text$mn:00000FE1                 jmp     short loc_FED
.text$mn:00000FE3 ; ---------------------------------------------------------------------------
.text$mn:00000FE3
.text$mn:00000FE3 loc_FE3:                                ; CODE XREF: Splitter::drawSplitter(void)+99j
.text$mn:00000FE3                 mov     [ebp+var_B0], 1
.text$mn:00000FED
.text$mn:00000FED loc_FED:                                ; CODE XREF: Splitter::drawSplitter(void)+A5j
.text$mn:00000FED                 mov     ecx, [ebp+var_B0]
.text$mn:00000FF3                 push    ecx
.text$mn:00000FF4                 lea     edx, [ebp+var_54]
.text$mn:00000FF7                 push    edx
.text$mn:00000FF8                 mov     eax, [ebp+hDC]
.text$mn:00000FFE                 push    eax
.text$mn:00000FFF                 mov     ecx, [ebp+var_98]
.text$mn:00001005                 call    ?paintArrow@Splitter@@AAEXPAUHDC__@@ABUtagRECT@@W4Arrow@@@Z ; Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)
.text$mn:0000100A
.text$mn:0000100A loc_100A:                               ; CODE XREF: Splitter::drawSplitter(void)+57j
.text$mn:0000100A                                         ; Splitter::drawSplitter(void)+65j
.text$mn:0000100A                 mov     ecx, [ebp+var_98] ; this
.text$mn:00001010                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:00001015                 movzx   ecx, al
.text$mn:00001018                 test    ecx, ecx
.text$mn:0000101A                 jz      short loc_106B
.text$mn:0000101C                 mov     edx, [ebp+var_98]
.text$mn:00001022                 mov     eax, [edx+2Ch]
.text$mn:00001025                 and     eax, 20h
.text$mn:00001028                 jz      short loc_103B
.text$mn:0000102A                 mov     ecx, [ebp+var_98]
.text$mn:00001030                 mov     edx, [ecx+40h]
.text$mn:00001033                 mov     [ebp+var_AC], edx
.text$mn:00001039                 jmp     short loc_1045
.text$mn:0000103B ; ---------------------------------------------------------------------------
.text$mn:0000103B
.text$mn:0000103B loc_103B:                               ; CODE XREF: Splitter::drawSplitter(void)+ECj
.text$mn:0000103B                 mov     [ebp+var_AC], 0
.text$mn:00001045
.text$mn:00001045 loc_1045:                               ; CODE XREF: Splitter::drawSplitter(void)+FDj
.text$mn:00001045                 mov     eax, [ebp+var_AC]
.text$mn:0000104B                 mov     [ebp+var_14.top], eax
.text$mn:0000104E                 mov     ecx, [ebp+var_14.top]
.text$mn:00001051                 add     ecx, 2
.text$mn:00001054                 mov     [ebp+var_14.bottom], ecx
.text$mn:00001057                 mov     edx, [ebp+var_14.top]
.text$mn:0000105A                 add     edx, 1
.text$mn:0000105D                 mov     [ebp+rc.top], edx
.text$mn:00001060                 mov     eax, [ebp+rc.top]
.text$mn:00001063                 add     eax, 2
.text$mn:00001066                 mov     [ebp+rc.bottom], eax
.text$mn:00001069                 jmp     short loc_1087
.text$mn:0000106B ; ---------------------------------------------------------------------------
.text$mn:0000106B
.text$mn:0000106B loc_106B:                               ; CODE XREF: Splitter::drawSplitter(void)+DEj
.text$mn:0000106B                 mov     [ebp+var_14.top], 1
.text$mn:00001072                 mov     [ebp+var_14.bottom], 3
.text$mn:00001079                 mov     [ebp+rc.top], 2
.text$mn:00001080                 mov     [ebp+rc.bottom], 4
.text$mn:00001087
.text$mn:00001087 loc_1087:                               ; CODE XREF: Splitter::drawSplitter(void)+12Dj
.text$mn:00001087                 mov     [ebp+var_A0], 0
.text$mn:00001091                 mov     ecx, [ebp+var_98]
.text$mn:00001097                 mov     edx, [ecx+2Ch]
.text$mn:0000109A                 and     edx, 20h
.text$mn:0000109D                 jz      short loc_10DC
.text$mn:0000109F                 mov     ecx, [ebp+var_98] ; this
.text$mn:000010A5                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:000010AA                 movzx   eax, al
.text$mn:000010AD                 test    eax, eax
.text$mn:000010AF                 jz      short loc_10C5
.text$mn:000010B1                 mov     ecx, [ebp+var_98]
.text$mn:000010B7                 mov     edx, [ebp+var_28]
.text$mn:000010BA                 sub     edx, [ecx+50h]
.text$mn:000010BD                 mov     [ebp+var_B4], edx
.text$mn:000010C3                 jmp     short loc_10CE
.text$mn:000010C5 ; ---------------------------------------------------------------------------
.text$mn:000010C5
.text$mn:000010C5 loc_10C5:                               ; CODE XREF: Splitter::drawSplitter(void)+173j
.text$mn:000010C5                 mov     eax, [ebp+var_28]
.text$mn:000010C8                 mov     [ebp+var_B4], eax
.text$mn:000010CE
.text$mn:000010CE loc_10CE:                               ; CODE XREF: Splitter::drawSplitter(void)+187j
.text$mn:000010CE                 mov     ecx, [ebp+var_B4]
.text$mn:000010D4                 mov     [ebp+var_A0], ecx
.text$mn:000010DA                 jmp     short loc_10E5
.text$mn:000010DC ; ---------------------------------------------------------------------------
.text$mn:000010DC
.text$mn:000010DC loc_10DC:                               ; CODE XREF: Splitter::drawSplitter(void)+161j
.text$mn:000010DC                 mov     edx, [ebp+var_28]
.text$mn:000010DF                 mov     [ebp+var_A0], edx
.text$mn:000010E5
.text$mn:000010E5 loc_10E5:                               ; CODE XREF: Splitter::drawSplitter(void)+19Ej
.text$mn:000010E5                                         ; Splitter::drawSplitter(void)+2BCj
.text$mn:000010E5                 mov     eax, [ebp+rc.bottom]
.text$mn:000010E8                 cmp     eax, [ebp+var_A0]
.text$mn:000010EE                 jg      loc_11FD
.text$mn:000010F4                 mov     ecx, [ebp+var_98] ; this
.text$mn:000010FA                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:000010FF                 movzx   ecx, al
.text$mn:00001102                 test    ecx, ecx
.text$mn:00001104                 jz      short loc_1124
.text$mn:00001106                 mov     [ebp+var_14.left], 1
.text$mn:0000110D                 mov     [ebp+var_14.right], 3
.text$mn:00001114                 mov     [ebp+rc.left], 2
.text$mn:0000111B                 mov     [ebp+rc.right], 4
.text$mn:00001122                 jmp     short loc_1148
.text$mn:00001124 ; ---------------------------------------------------------------------------
.text$mn:00001124
.text$mn:00001124 loc_1124:                               ; CODE XREF: Splitter::drawSplitter(void)+1C8j
.text$mn:00001124                 mov     edx, [ebp+var_98]
.text$mn:0000112A                 mov     eax, [edx+3Ch]
.text$mn:0000112D                 mov     [ebp+var_14.left], eax
.text$mn:00001130                 mov     ecx, [ebp+var_14.left]
.text$mn:00001133                 add     ecx, 2
.text$mn:00001136                 mov     [ebp+var_14.right], ecx
.text$mn:00001139                 mov     edx, [ebp+var_14.left]
.text$mn:0000113C                 mov     [ebp+rc.left], edx
.text$mn:0000113F                 mov     eax, [ebp+rc.left]
.text$mn:00001142                 add     eax, 2
.text$mn:00001145                 mov     [ebp+rc.right], eax
.text$mn:00001148
.text$mn:00001148 loc_1148:                               ; CODE XREF: Splitter::drawSplitter(void)+1E6j
.text$mn:00001148                                         ; Splitter::drawSplitter(void)+293j
.text$mn:00001148                 mov     ecx, [ebp+var_98] ; this
.text$mn:0000114E                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:00001153                 movzx   ecx, al
.text$mn:00001156                 test    ecx, ecx
.text$mn:00001158                 jz      short loc_1165
.text$mn:0000115A                 mov     edx, [ebp+var_2C]
.text$mn:0000115D                 mov     [ebp+var_A4], edx
.text$mn:00001163                 jmp     short loc_1177
.text$mn:00001165 ; ---------------------------------------------------------------------------
.text$mn:00001165
.text$mn:00001165 loc_1165:                               ; CODE XREF: Splitter::drawSplitter(void)+21Cj
.text$mn:00001165                 mov     eax, [ebp+var_98]
.text$mn:0000116B                 mov     ecx, [ebp+var_2C]
.text$mn:0000116E                 sub     ecx, [eax+4Ch]
.text$mn:00001171                 mov     [ebp+var_A4], ecx
.text$mn:00001177
.text$mn:00001177 loc_1177:                               ; CODE XREF: Splitter::drawSplitter(void)+227j
.text$mn:00001177                 mov     edx, [ebp+rc.right]
.text$mn:0000117A                 cmp     edx, [ebp+var_A4]
.text$mn:00001180                 jg      short loc_11D4
.text$mn:00001182                 push    0FFFFFFh        ; hbr
.text$mn:00001187                 lea     eax, [ebp+rc]
.text$mn:0000118A                 push    eax             ; lprc
.text$mn:0000118B                 mov     ecx, [ebp+hDC]
.text$mn:00001191                 push    ecx             ; hDC
.text$mn:00001192                 call    dword ptr ds:__imp__FillRect@12 ; FillRect(x,x,x)
.text$mn:00001198                 push    offset hbr      ; hbr
.text$mn:0000119A                 lea     edx, [ebp+var_14]
.text$mn:0000119D                 push    edx             ; lprc
.text$mn:0000119E                 mov     eax, [ebp+hDC]
.text$mn:000011A4                 push    eax             ; hDC
.text$mn:000011A5                 call    dword ptr ds:__imp__FillRect@12 ; FillRect(x,x,x)
.text$mn:000011AB                 mov     ecx, [ebp+var_14.left]
.text$mn:000011AE                 add     ecx, 4
.text$mn:000011B1                 mov     [ebp+var_14.left], ecx
.text$mn:000011B4                 mov     edx, [ebp+var_14.right]
.text$mn:000011B7                 add     edx, 4
.text$mn:000011BA                 mov     [ebp+var_14.right], edx
.text$mn:000011BD                 mov     eax, [ebp+rc.left]
.text$mn:000011C0                 add     eax, 4
.text$mn:000011C3                 mov     [ebp+rc.left], eax
.text$mn:000011C6                 mov     ecx, [ebp+rc.right]
.text$mn:000011C9                 add     ecx, 4
.text$mn:000011CC                 mov     [ebp+rc.right], ecx
.text$mn:000011CF                 jmp     loc_1148
.text$mn:000011D4 ; ---------------------------------------------------------------------------
.text$mn:000011D4
.text$mn:000011D4 loc_11D4:                               ; CODE XREF: Splitter::drawSplitter(void)+244j
.text$mn:000011D4                 mov     edx, [ebp+var_14.top]
.text$mn:000011D7                 add     edx, 4
.text$mn:000011DA                 mov     [ebp+var_14.top], edx
.text$mn:000011DD                 mov     eax, [ebp+var_14.bottom]
.text$mn:000011E0                 add     eax, 4
.text$mn:000011E3                 mov     [ebp+var_14.bottom], eax
.text$mn:000011E6                 mov     ecx, [ebp+rc.top]
.text$mn:000011E9                 add     ecx, 4
.text$mn:000011EC                 mov     [ebp+rc.top], ecx
.text$mn:000011EF                 mov     edx, [ebp+rc.bottom]
.text$mn:000011F2                 add     edx, 4
.text$mn:000011F5                 mov     [ebp+rc.bottom], edx
.text$mn:000011F8                 jmp     loc_10E5
.text$mn:000011FD ; ---------------------------------------------------------------------------
.text$mn:000011FD
.text$mn:000011FD loc_11FD:                               ; CODE XREF: Splitter::drawSplitter(void)+1B2j
.text$mn:000011FD                 mov     eax, [ebp+var_98]
.text$mn:00001203                 cmp     dword ptr [eax+24h], 4
.text$mn:00001207                 jl      short loc_125C
.text$mn:00001209                 mov     ecx, [ebp+var_98]
.text$mn:0000120F                 mov     edx, [ecx+2Ch]
.text$mn:00001212                 and     edx, 20h
.text$mn:00001215                 jz      short loc_125C
.text$mn:00001217                 mov     ecx, [ebp+var_98] ; this
.text$mn:0000121D                 call    ?isVertical@Splitter@@ABE_NXZ ; Splitter::isVertical(void)
.text$mn:00001222                 movzx   eax, al
.text$mn:00001225                 test    eax, eax
.text$mn:00001227                 jz      short loc_1235
.text$mn:00001229                 mov     [ebp+var_A8], 2
.text$mn:00001233                 jmp     short loc_123F
.text$mn:00001235 ; ---------------------------------------------------------------------------
.text$mn:00001235
.text$mn:00001235 loc_1235:                               ; CODE XREF: Splitter::drawSplitter(void)+2EBj
.text$mn:00001235                 mov     [ebp+var_A8], 3
.text$mn:0000123F
.text$mn:0000123F loc_123F:                               ; CODE XREF: Splitter::drawSplitter(void)+2F7j
.text$mn:0000123F                 mov     ecx, [ebp+var_A8]
.text$mn:00001245                 push    ecx
.text$mn:00001246                 lea     edx, [ebp+var_44]
.text$mn:00001249                 push    edx
.text$mn:0000124A                 mov     eax, [ebp+hDC]
.text$mn:00001250                 push    eax
.text$mn:00001251                 mov     ecx, [ebp+var_98]
.text$mn:00001257                 call    ?paintArrow@Splitter@@AAEXPAUHDC__@@ABUtagRECT@@W4Arrow@@@Z ; Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)
.text$mn:0000125C
.text$mn:0000125C loc_125C:                               ; CODE XREF: Splitter::drawSplitter(void)+2CBj
.text$mn:0000125C                                         ; Splitter::drawSplitter(void)+2D9j
.text$mn:0000125C                 lea     ecx, [ebp+Paint]
.text$mn:00001262                 push    ecx             ; lpPaint
.text$mn:00001263                 mov     edx, [ebp+var_98]
.text$mn:00001269                 mov     eax, [edx+0Ch]
.text$mn:0000126C                 push    eax             ; hWnd
.text$mn:0000126D                 call    dword ptr ds:__imp__EndPaint@8 ; EndPaint(x,x)
.text$mn:00001273                 mov     ecx, [ebp+var_4]
.text$mn:00001276                 xor     ecx, ebp
.text$mn:00001278                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000127D                 mov     esp, ebp
.text$mn:0000127F                 pop     ebp
.text$mn:00001280                 retn
.text$mn:00001280 ?drawSplitter@Splitter@@AAEXXZ endp
.text$mn:00001280
.text$mn:00001280 ; ---------------------------------------------------------------------------
.text$mn:00001281                 db 0Bh dup(0CCh)
.text$mn:0000128C
.text$mn:0000128C ; =============== S U B R O U T I N E =======================================
.text$mn:0000128C
.text$mn:0000128C ; Attributes: bp-based frame
.text$mn:0000128C
.text$mn:0000128C ; private: void __thiscall Splitter::paintArrow(struct HDC__ *, struct tagRECT const &, enum  Arrow)
.text$mn:0000128C                 public ?paintArrow@Splitter@@AAEXPAUHDC__@@ABUtagRECT@@W4Arrow@@@Z
.text$mn:0000128C ?paintArrow@Splitter@@AAEXPAUHDC__@@ABUtagRECT@@W4Arrow@@@Z proc near
.text$mn:0000128C                                         ; CODE XREF: Splitter::drawSplitter(void)+C9p
.text$mn:0000128C                                         ; Splitter::drawSplitter(void)+31Bp
.text$mn:0000128C
.text$mn:0000128C var_58          = dword ptr -58h
.text$mn:0000128C var_54          = dword ptr -54h
.text$mn:0000128C var_50          = dword ptr -50h
.text$mn:0000128C var_4C          = dword ptr -4Ch
.text$mn:0000128C var_48          = dword ptr -48h
.text$mn:0000128C var_44          = dword ptr -44h
.text$mn:0000128C var_40          = dword ptr -40h
.text$mn:0000128C var_3C          = dword ptr -3Ch
.text$mn:0000128C y               = dword ptr -38h
.text$mn:0000128C var_34          = dword ptr -34h
.text$mn:0000128C var_30          = dword ptr -30h
.text$mn:0000128C var_2C          = dword ptr -2Ch
.text$mn:0000128C var_28          = dword ptr -28h
.text$mn:0000128C var_24          = dword ptr -24h
.text$mn:0000128C x               = dword ptr -20h
.text$mn:0000128C var_1C          = dword ptr -1Ch
.text$mn:0000128C var_18          = dword ptr -18h
.text$mn:0000128C var_14          = dword ptr -14h
.text$mn:0000128C var_10          = dword ptr -10h
.text$mn:0000128C var_C           = dword ptr -0Ch
.text$mn:0000128C var_8           = dword ptr -8
.text$mn:0000128C var_4           = dword ptr -4
.text$mn:0000128C hdc             = dword ptr  8
.text$mn:0000128C arg_4           = dword ptr  0Ch
.text$mn:0000128C arg_8           = dword ptr  10h
.text$mn:0000128C
.text$mn:0000128C                 push    ebp
.text$mn:0000128D                 mov     ebp, esp
.text$mn:0000128F                 sub     esp, 58h
.text$mn:00001292                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001297                 xor     eax, ebp
.text$mn:00001299                 mov     [ebp+var_4], eax
.text$mn:0000129C                 mov     [ebp+var_58], ecx
.text$mn:0000129F                 mov     eax, [ebp+arg_4]
.text$mn:000012A2                 mov     ecx, [eax]
.text$mn:000012A4                 mov     [ebp+var_14], ecx
.text$mn:000012A7                 mov     edx, [ebp+arg_4]
.text$mn:000012AA                 mov     eax, [edx+4]
.text$mn:000012AD                 mov     [ebp+var_10], eax
.text$mn:000012B0                 mov     ecx, [ebp+arg_4]
.text$mn:000012B3                 mov     edx, [ecx+8]
.text$mn:000012B6                 mov     [ebp+var_C], edx
.text$mn:000012B9                 mov     eax, [ebp+arg_4]
.text$mn:000012BC                 mov     ecx, [eax+0Ch]
.text$mn:000012BF                 mov     [ebp+var_8], ecx
.text$mn:000012C2                 cmp     [ebp+arg_8], 0
.text$mn:000012C6                 jnz     short loc_133A
.text$mn:000012C8                 mov     edx, [ebp+var_C]
.text$mn:000012CB                 mov     [ebp+x], edx
.text$mn:000012CE                 mov     eax, [ebp+var_10]
.text$mn:000012D1                 mov     [ebp+var_28], eax
.text$mn:000012D4                 jmp     short loc_12DF
.text$mn:000012D6 ; ---------------------------------------------------------------------------
.text$mn:000012D6
.text$mn:000012D6 loc_12D6:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+A7j
.text$mn:000012D6                 mov     ecx, [ebp+x]
.text$mn:000012D9                 sub     ecx, 1
.text$mn:000012DC                 mov     [ebp+x], ecx
.text$mn:000012DF
.text$mn:000012DF loc_12DF:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+48j
.text$mn:000012DF                 mov     edx, [ebp+x]
.text$mn:000012E2                 cmp     edx, [ebp+var_14]
.text$mn:000012E5                 jle     short loc_1335
.text$mn:000012E7                 mov     eax, [ebp+var_28]
.text$mn:000012EA                 cmp     eax, [ebp+var_8]
.text$mn:000012ED                 jz      short loc_1335
.text$mn:000012EF                 mov     ecx, [ebp+var_28]
.text$mn:000012F2                 mov     [ebp+y], ecx
.text$mn:000012F5                 push    0               ; lppt
.text$mn:000012F7                 mov     edx, [ebp+y]
.text$mn:000012FA                 push    edx             ; y
.text$mn:000012FB                 mov     eax, [ebp+x]
.text$mn:000012FE                 push    eax             ; x
.text$mn:000012FF                 mov     ecx, [ebp+hdc]
.text$mn:00001302                 push    ecx             ; hdc
.text$mn:00001303                 call    dword ptr ds:__imp__MoveToEx@16 ; MoveToEx(x,x,x,x)
.text$mn:00001309                 mov     edx, [ebp+var_28]
.text$mn:0000130C                 add     edx, 1
.text$mn:0000130F                 mov     [ebp+var_28], edx
.text$mn:00001312                 mov     eax, [ebp+var_8]
.text$mn:00001315                 mov     [ebp+var_50], eax
.text$mn:00001318                 mov     ecx, [ebp+var_50]
.text$mn:0000131B                 push    ecx             ; y
.text$mn:0000131C                 mov     edx, [ebp+x]
.text$mn:0000131F                 push    edx             ; x
.text$mn:00001320                 mov     eax, [ebp+hdc]
.text$mn:00001323                 push    eax             ; hdc
.text$mn:00001324                 call    dword ptr ds:__imp__LineTo@12 ; LineTo(x,x,x)
.text$mn:0000132A                 mov     ecx, [ebp+var_8]
.text$mn:0000132D                 sub     ecx, 1
.text$mn:00001330                 mov     [ebp+var_8], ecx
.text$mn:00001333                 jmp     short loc_12D6
.text$mn:00001335 ; ---------------------------------------------------------------------------
.text$mn:00001335
.text$mn:00001335 loc_1335:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+59j
.text$mn:00001335                                         ; Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+61j
.text$mn:00001335                 jmp     loc_149A
.text$mn:0000133A ; ---------------------------------------------------------------------------
.text$mn:0000133A
.text$mn:0000133A loc_133A:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+3Aj
.text$mn:0000133A                 cmp     [ebp+arg_8], 2
.text$mn:0000133E                 jnz     short loc_13B2
.text$mn:00001340                 mov     edx, [ebp+var_14]
.text$mn:00001343                 mov     [ebp+var_24], edx
.text$mn:00001346                 mov     eax, [ebp+var_10]
.text$mn:00001349                 mov     [ebp+var_34], eax
.text$mn:0000134C                 jmp     short loc_1357
.text$mn:0000134E ; ---------------------------------------------------------------------------
.text$mn:0000134E
.text$mn:0000134E loc_134E:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+11Fj
.text$mn:0000134E                 mov     ecx, [ebp+var_24]
.text$mn:00001351                 add     ecx, 1
.text$mn:00001354                 mov     [ebp+var_24], ecx
.text$mn:00001357
.text$mn:00001357 loc_1357:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+C0j
.text$mn:00001357                 mov     edx, [ebp+var_24]
.text$mn:0000135A                 cmp     edx, [ebp+var_C]
.text$mn:0000135D                 jge     short loc_13AD
.text$mn:0000135F                 mov     eax, [ebp+var_34]
.text$mn:00001362                 cmp     eax, [ebp+var_8]
.text$mn:00001365                 jz      short loc_13AD
.text$mn:00001367                 mov     ecx, [ebp+var_34]
.text$mn:0000136A                 mov     [ebp+var_4C], ecx
.text$mn:0000136D                 push    0               ; lppt
.text$mn:0000136F                 mov     edx, [ebp+var_4C]
.text$mn:00001372                 push    edx             ; y
.text$mn:00001373                 mov     eax, [ebp+var_24]
.text$mn:00001376                 push    eax             ; x
.text$mn:00001377                 mov     ecx, [ebp+hdc]
.text$mn:0000137A                 push    ecx             ; hdc
.text$mn:0000137B                 call    dword ptr ds:__imp__MoveToEx@16 ; MoveToEx(x,x,x,x)
.text$mn:00001381                 mov     edx, [ebp+var_34]
.text$mn:00001384                 add     edx, 1
.text$mn:00001387                 mov     [ebp+var_34], edx
.text$mn:0000138A                 mov     eax, [ebp+var_8]
.text$mn:0000138D                 mov     [ebp+var_44], eax
.text$mn:00001390                 mov     ecx, [ebp+var_44]
.text$mn:00001393                 push    ecx             ; y
.text$mn:00001394                 mov     edx, [ebp+var_24]
.text$mn:00001397                 push    edx             ; x
.text$mn:00001398                 mov     eax, [ebp+hdc]
.text$mn:0000139B                 push    eax             ; hdc
.text$mn:0000139C                 call    dword ptr ds:__imp__LineTo@12 ; LineTo(x,x,x)
.text$mn:000013A2                 mov     ecx, [ebp+var_8]
.text$mn:000013A5                 sub     ecx, 1
.text$mn:000013A8                 mov     [ebp+var_8], ecx
.text$mn:000013AB                 jmp     short loc_134E
.text$mn:000013AD ; ---------------------------------------------------------------------------
.text$mn:000013AD
.text$mn:000013AD loc_13AD:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+D1j
.text$mn:000013AD                                         ; Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+D9j
.text$mn:000013AD                 jmp     loc_149A
.text$mn:000013B2 ; ---------------------------------------------------------------------------
.text$mn:000013B2
.text$mn:000013B2 loc_13B2:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+B2j
.text$mn:000013B2                 cmp     [ebp+arg_8], 1
.text$mn:000013B6                 jnz     short loc_1427
.text$mn:000013B8                 mov     edx, [ebp+var_14]
.text$mn:000013BB                 mov     [ebp+var_30], edx
.text$mn:000013BE                 mov     eax, [ebp+var_8]
.text$mn:000013C1                 mov     [ebp+var_18], eax
.text$mn:000013C4                 jmp     short loc_13CF
.text$mn:000013C6 ; ---------------------------------------------------------------------------
.text$mn:000013C6
.text$mn:000013C6 loc_13C6:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+197j
.text$mn:000013C6                 mov     ecx, [ebp+var_18]
.text$mn:000013C9                 sub     ecx, 1
.text$mn:000013CC                 mov     [ebp+var_18], ecx
.text$mn:000013CF
.text$mn:000013CF loc_13CF:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+138j
.text$mn:000013CF                 mov     edx, [ebp+var_18]
.text$mn:000013D2                 cmp     edx, [ebp+var_10]
.text$mn:000013D5                 jle     short loc_1425
.text$mn:000013D7                 mov     eax, [ebp+var_30]
.text$mn:000013DA                 cmp     eax, [ebp+var_C]
.text$mn:000013DD                 jz      short loc_1425
.text$mn:000013DF                 mov     ecx, [ebp+var_30]
.text$mn:000013E2                 mov     [ebp+var_54], ecx
.text$mn:000013E5                 push    0               ; lppt
.text$mn:000013E7                 mov     edx, [ebp+var_18]
.text$mn:000013EA                 push    edx             ; y
.text$mn:000013EB                 mov     eax, [ebp+var_54]
.text$mn:000013EE                 push    eax             ; x
.text$mn:000013EF                 mov     ecx, [ebp+hdc]
.text$mn:000013F2                 push    ecx             ; hdc
.text$mn:000013F3                 call    dword ptr ds:__imp__MoveToEx@16 ; MoveToEx(x,x,x,x)
.text$mn:000013F9                 mov     edx, [ebp+var_30]
.text$mn:000013FC                 add     edx, 1
.text$mn:000013FF                 mov     [ebp+var_30], edx
.text$mn:00001402                 mov     eax, [ebp+var_C]
.text$mn:00001405                 mov     [ebp+var_3C], eax
.text$mn:00001408                 mov     ecx, [ebp+var_18]
.text$mn:0000140B                 push    ecx             ; y
.text$mn:0000140C                 mov     edx, [ebp+var_3C]
.text$mn:0000140F                 push    edx             ; x
.text$mn:00001410                 mov     eax, [ebp+hdc]
.text$mn:00001413                 push    eax             ; hdc
.text$mn:00001414                 call    dword ptr ds:__imp__LineTo@12 ; LineTo(x,x,x)
.text$mn:0000141A                 mov     ecx, [ebp+var_C]
.text$mn:0000141D                 sub     ecx, 1
.text$mn:00001420                 mov     [ebp+var_C], ecx
.text$mn:00001423                 jmp     short loc_13C6
.text$mn:00001425 ; ---------------------------------------------------------------------------
.text$mn:00001425
.text$mn:00001425 loc_1425:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+149j
.text$mn:00001425                                         ; Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+151j
.text$mn:00001425                 jmp     short loc_149A
.text$mn:00001427 ; ---------------------------------------------------------------------------
.text$mn:00001427
.text$mn:00001427 loc_1427:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+12Aj
.text$mn:00001427                 cmp     [ebp+arg_8], 3
.text$mn:0000142B                 jnz     short loc_149A
.text$mn:0000142D                 mov     edx, [ebp+var_14]
.text$mn:00001430                 mov     [ebp+var_2C], edx
.text$mn:00001433                 mov     eax, [ebp+var_10]
.text$mn:00001436                 mov     [ebp+var_1C], eax
.text$mn:00001439                 jmp     short loc_1444
.text$mn:0000143B ; ---------------------------------------------------------------------------
.text$mn:0000143B
.text$mn:0000143B loc_143B:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+20Cj
.text$mn:0000143B                 mov     ecx, [ebp+var_1C]
.text$mn:0000143E                 add     ecx, 1
.text$mn:00001441                 mov     [ebp+var_1C], ecx
.text$mn:00001444
.text$mn:00001444 loc_1444:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+1ADj
.text$mn:00001444                 mov     edx, [ebp+var_1C]
.text$mn:00001447                 cmp     edx, [ebp+var_8]
.text$mn:0000144A                 jge     short loc_149A
.text$mn:0000144C                 mov     eax, [ebp+var_2C]
.text$mn:0000144F                 cmp     eax, [ebp+var_C]
.text$mn:00001452                 jz      short loc_149A
.text$mn:00001454                 mov     ecx, [ebp+var_2C]
.text$mn:00001457                 mov     [ebp+var_40], ecx
.text$mn:0000145A                 push    0               ; lppt
.text$mn:0000145C                 mov     edx, [ebp+var_1C]
.text$mn:0000145F                 push    edx             ; y
.text$mn:00001460                 mov     eax, [ebp+var_40]
.text$mn:00001463                 push    eax             ; x
.text$mn:00001464                 mov     ecx, [ebp+hdc]
.text$mn:00001467                 push    ecx             ; hdc
.text$mn:00001468                 call    dword ptr ds:__imp__MoveToEx@16 ; MoveToEx(x,x,x,x)
.text$mn:0000146E                 mov     edx, [ebp+var_2C]
.text$mn:00001471                 add     edx, 1
.text$mn:00001474                 mov     [ebp+var_2C], edx
.text$mn:00001477                 mov     eax, [ebp+var_C]
.text$mn:0000147A                 mov     [ebp+var_48], eax
.text$mn:0000147D                 mov     ecx, [ebp+var_1C]
.text$mn:00001480                 push    ecx             ; y
.text$mn:00001481                 mov     edx, [ebp+var_48]
.text$mn:00001484                 push    edx             ; x
.text$mn:00001485                 mov     eax, [ebp+hdc]
.text$mn:00001488                 push    eax             ; hdc
.text$mn:00001489                 call    dword ptr ds:__imp__LineTo@12 ; LineTo(x,x,x)
.text$mn:0000148F                 mov     ecx, [ebp+var_C]
.text$mn:00001492                 sub     ecx, 1
.text$mn:00001495                 mov     [ebp+var_C], ecx
.text$mn:00001498                 jmp     short loc_143B
.text$mn:0000149A ; ---------------------------------------------------------------------------
.text$mn:0000149A
.text$mn:0000149A loc_149A:                               ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow):loc_1335j
.text$mn:0000149A                                         ; Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow):loc_13ADj ...
.text$mn:0000149A                 mov     ecx, [ebp+var_4]
.text$mn:0000149D                 xor     ecx, ebp
.text$mn:0000149F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000014A4                 mov     esp, ebp
.text$mn:000014A6                 pop     ebp
.text$mn:000014A7                 retn    0Ch
.text$mn:000014A7 ?paintArrow@Splitter@@AAEXPAUHDC__@@ABUtagRECT@@W4Arrow@@@Z endp
.text$mn:000014A7
.text$mn:000014A7 ; ---------------------------------------------------------------------------
.text$mn:000014AA                 align 4
.text$mn:000014AC
.text$mn:000014AC ; =============== S U B R O U T I N E =======================================
.text$mn:000014AC
.text$mn:000014AC ; Attributes: bp-based frame
.text$mn:000014AC
.text$mn:000014AC ; void __thiscall Splitter::gotoTopLeft(Splitter *__hidden this)
.text$mn:000014AC                 public ?gotoTopLeft@Splitter@@AAEXXZ
.text$mn:000014AC ?gotoTopLeft@Splitter@@AAEXXZ proc near ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+A8p
.text$mn:000014AC
.text$mn:000014AC var_4           = dword ptr -4
.text$mn:000014AC
.text$mn:000014AC                 push    ebp
.text$mn:000014AD                 mov     ebp, esp
.text$mn:000014AF                 push    ecx
.text$mn:000014B0                 mov     [ebp+var_4], ecx
.text$mn:000014B3                 mov     eax, [ebp+var_4]
.text$mn:000014B6                 mov     ecx, [eax+2Ch]
.text$mn:000014B9                 and     ecx, 10h
.text$mn:000014BC                 jz      loc_1563
.text$mn:000014C2                 mov     edx, [ebp+var_4]
.text$mn:000014C5                 movzx   eax, byte ptr [edx+30h]
.text$mn:000014C9                 test    eax, eax
.text$mn:000014CB                 jnz     loc_1563
.text$mn:000014D1                 mov     ecx, [ebp+var_4]
.text$mn:000014D4                 cmp     dword ptr [ecx+20h], 1
.text$mn:000014D8                 jle     loc_1563
.text$mn:000014DE                 mov     edx, [ebp+var_4]
.text$mn:000014E1                 mov     eax, [edx+2Ch]
.text$mn:000014E4                 and     eax, 1
.text$mn:000014E7                 jz      short loc_14F5
.text$mn:000014E9                 mov     ecx, [ebp+var_4]
.text$mn:000014EC                 mov     dword ptr [ecx+14h], 1
.text$mn:000014F3                 jmp     short loc_14FF
.text$mn:000014F5 ; ---------------------------------------------------------------------------
.text$mn:000014F5
.text$mn:000014F5 loc_14F5:                               ; CODE XREF: Splitter::gotoTopLeft(void)+3Bj
.text$mn:000014F5                 mov     edx, [ebp+var_4]
.text$mn:000014F8                 mov     dword ptr [edx+10h], 1
.text$mn:000014FF
.text$mn:000014FF loc_14FF:                               ; CODE XREF: Splitter::gotoTopLeft(void)+47j
.text$mn:000014FF                 mov     eax, [ebp+var_4]
.text$mn:00001502                 mov     dword ptr [eax+20h], 1
.text$mn:00001509                 mov     ecx, [ebp+var_4]
.text$mn:0000150C                 mov     edx, [ecx+14h]
.text$mn:0000150F                 push    edx             ; lParam
.text$mn:00001510                 mov     eax, [ebp+var_4]
.text$mn:00001513                 mov     ecx, [eax+10h]
.text$mn:00001516                 push    ecx             ; wParam
.text$mn:00001517                 push    13A4h           ; Msg
.text$mn:0000151C                 mov     edx, [ebp+var_4]
.text$mn:0000151F                 mov     eax, [edx+8]
.text$mn:00001522                 push    eax             ; hWnd
.text$mn:00001523                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001529                 push    1               ; bRepaint
.text$mn:0000152B                 mov     ecx, [ebp+var_4]
.text$mn:0000152E                 mov     edx, [ecx+1Ch]
.text$mn:00001531                 push    edx             ; nHeight
.text$mn:00001532                 mov     eax, [ebp+var_4]
.text$mn:00001535                 mov     ecx, [eax+18h]
.text$mn:00001538                 push    ecx             ; nWidth
.text$mn:00001539                 mov     edx, [ebp+var_4]
.text$mn:0000153C                 mov     eax, [edx+14h]
.text$mn:0000153F                 push    eax             ; Y
.text$mn:00001540                 mov     ecx, [ebp+var_4]
.text$mn:00001543                 mov     edx, [ecx+10h]
.text$mn:00001546                 push    edx             ; X
.text$mn:00001547                 mov     eax, [ebp+var_4]
.text$mn:0000154A                 mov     ecx, [eax+0Ch]
.text$mn:0000154D                 push    ecx             ; hWnd
.text$mn:0000154E                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00001554                 push    0
.text$mn:00001556                 mov     edx, [ebp+var_4]
.text$mn:00001559                 mov     eax, [edx]
.text$mn:0000155B                 mov     ecx, [ebp+var_4]
.text$mn:0000155E                 mov     edx, [eax+18h]
.text$mn:00001561                 call    edx
.text$mn:00001563
.text$mn:00001563 loc_1563:                               ; CODE XREF: Splitter::gotoTopLeft(void)+10j
.text$mn:00001563                                         ; Splitter::gotoTopLeft(void)+1Fj ...
.text$mn:00001563                 mov     esp, ebp
.text$mn:00001565                 pop     ebp
.text$mn:00001566                 retn
.text$mn:00001566 ?gotoTopLeft@Splitter@@AAEXXZ endp
.text$mn:00001566
.text$mn:00001566 ; ---------------------------------------------------------------------------
.text$mn:00001567                 db 5 dup(0CCh)
.text$mn:0000156C
.text$mn:0000156C ; =============== S U B R O U T I N E =======================================
.text$mn:0000156C
.text$mn:0000156C ; Attributes: bp-based frame
.text$mn:0000156C
.text$mn:0000156C ; void __thiscall Splitter::gotoRightBouuom(Splitter *__hidden this)
.text$mn:0000156C                 public ?gotoRightBouuom@Splitter@@AAEXXZ
.text$mn:0000156C ?gotoRightBouuom@Splitter@@AAEXXZ proc near
.text$mn:0000156C                                         ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+D3p
.text$mn:0000156C
.text$mn:0000156C var_18          = dword ptr -18h
.text$mn:0000156C Rect            = tagRECT ptr -14h
.text$mn:0000156C var_4           = dword ptr -4
.text$mn:0000156C
.text$mn:0000156C                 push    ebp
.text$mn:0000156D                 mov     ebp, esp
.text$mn:0000156F                 sub     esp, 18h
.text$mn:00001572                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001577                 xor     eax, ebp
.text$mn:00001579                 mov     [ebp+var_4], eax
.text$mn:0000157C                 mov     [ebp+var_18], ecx
.text$mn:0000157F                 mov     eax, [ebp+var_18]
.text$mn:00001582                 mov     ecx, [eax+2Ch]
.text$mn:00001585                 and     ecx, 8
.text$mn:00001588                 jz      loc_164A
.text$mn:0000158E                 mov     edx, [ebp+var_18]
.text$mn:00001591                 movzx   eax, byte ptr [edx+30h]
.text$mn:00001595                 test    eax, eax
.text$mn:00001597                 jnz     loc_164A
.text$mn:0000159D                 mov     ecx, [ebp+var_18]
.text$mn:000015A0                 cmp     dword ptr [ecx+20h], 63h ; 'c'
.text$mn:000015A4                 jge     loc_164A
.text$mn:000015AA                 lea     edx, [ebp+Rect]
.text$mn:000015AD                 push    edx             ; lpRect
.text$mn:000015AE                 mov     eax, [ebp+var_18]
.text$mn:000015B1                 mov     ecx, [eax+8]
.text$mn:000015B4                 push    ecx             ; hWnd
.text$mn:000015B5                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:000015BB                 mov     edx, [ebp+var_18]
.text$mn:000015BE                 mov     eax, [edx+2Ch]
.text$mn:000015C1                 and     eax, 1
.text$mn:000015C4                 jz      short loc_15D7
.text$mn:000015C6                 mov     ecx, [ebp+var_18]
.text$mn:000015C9                 mov     edx, [ebp+Rect.bottom]
.text$mn:000015CC                 sub     edx, [ecx+24h]
.text$mn:000015CF                 mov     eax, [ebp+var_18]
.text$mn:000015D2                 mov     [eax+14h], edx
.text$mn:000015D5                 jmp     short loc_15E6
.text$mn:000015D7 ; ---------------------------------------------------------------------------
.text$mn:000015D7
.text$mn:000015D7 loc_15D7:                               ; CODE XREF: Splitter::gotoRightBouuom(void)+58j
.text$mn:000015D7                 mov     ecx, [ebp+var_18]
.text$mn:000015DA                 mov     edx, [ebp+Rect.right]
.text$mn:000015DD                 sub     edx, [ecx+24h]
.text$mn:000015E0                 mov     eax, [ebp+var_18]
.text$mn:000015E3                 mov     [eax+10h], edx
.text$mn:000015E6
.text$mn:000015E6 loc_15E6:                               ; CODE XREF: Splitter::gotoRightBouuom(void)+69j
.text$mn:000015E6                 mov     ecx, [ebp+var_18]
.text$mn:000015E9                 mov     dword ptr [ecx+20h], 63h ; 'c'
.text$mn:000015F0                 mov     edx, [ebp+var_18]
.text$mn:000015F3                 mov     eax, [edx+14h]
.text$mn:000015F6                 push    eax             ; lParam
.text$mn:000015F7                 mov     ecx, [ebp+var_18]
.text$mn:000015FA                 mov     edx, [ecx+10h]
.text$mn:000015FD                 push    edx             ; wParam
.text$mn:000015FE                 push    13A4h           ; Msg
.text$mn:00001603                 mov     eax, [ebp+var_18]
.text$mn:00001606                 mov     ecx, [eax+8]
.text$mn:00001609                 push    ecx             ; hWnd
.text$mn:0000160A                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001610                 push    1               ; bRepaint
.text$mn:00001612                 mov     edx, [ebp+var_18]
.text$mn:00001615                 mov     eax, [edx+1Ch]
.text$mn:00001618                 push    eax             ; nHeight
.text$mn:00001619                 mov     ecx, [ebp+var_18]
.text$mn:0000161C                 mov     edx, [ecx+18h]
.text$mn:0000161F                 push    edx             ; nWidth
.text$mn:00001620                 mov     eax, [ebp+var_18]
.text$mn:00001623                 mov     ecx, [eax+14h]
.text$mn:00001626                 push    ecx             ; Y
.text$mn:00001627                 mov     edx, [ebp+var_18]
.text$mn:0000162A                 mov     eax, [edx+10h]
.text$mn:0000162D                 push    eax             ; X
.text$mn:0000162E                 mov     ecx, [ebp+var_18]
.text$mn:00001631                 mov     edx, [ecx+0Ch]
.text$mn:00001634                 push    edx             ; hWnd
.text$mn:00001635                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:0000163B                 push    0
.text$mn:0000163D                 mov     eax, [ebp+var_18]
.text$mn:00001640                 mov     edx, [eax]
.text$mn:00001642                 mov     ecx, [ebp+var_18]
.text$mn:00001645                 mov     eax, [edx+18h]
.text$mn:00001648                 call    eax
.text$mn:0000164A
.text$mn:0000164A loc_164A:                               ; CODE XREF: Splitter::gotoRightBouuom(void)+1Cj
.text$mn:0000164A                                         ; Splitter::gotoRightBouuom(void)+2Bj ...
.text$mn:0000164A                 mov     ecx, [ebp+var_4]
.text$mn:0000164D                 xor     ecx, ebp
.text$mn:0000164F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001654                 mov     esp, ebp
.text$mn:00001656                 pop     ebp
.text$mn:00001657                 retn
.text$mn:00001657 ?gotoRightBouuom@Splitter@@AAEXXZ endp
.text$mn:00001657
.text$mn:00001657 _text$mn        ends
.text$mn:00001657
.text$x:00001658 ; ===========================================================================
.text$x:00001658
.text$x:00001658 ; Segment type: Pure code
.text$x:00001658 ; Segment permissions: Read/Execute
.text$x:00001658 _text$x         segment para public 'CODE' use32
.text$x:00001658                 assume cs:_text$x
.text$x:00001658                 ;org 1658h
.text$x:00001658                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001658
.text$x:00001658 ; =============== S U B R O U T I N E =======================================
.text$x:00001658
.text$x:00001658
.text$x:00001658 __unwindfunclet$??0Splitter@@QAE@XZ$0 proc near
.text$x:00001658                                         ; DATA XREF: .xdata$x:0000399Co
.text$x:00001658                 mov     ecx, [ebp-10h]  ; this
.text$x:0000165B                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:0000165B __unwindfunclet$??0Splitter@@QAE@XZ$0 endp
.text$x:0000165B
.text$x:00001660
.text$x:00001660 ; =============== S U B R O U T I N E =======================================
.text$x:00001660
.text$x:00001660
.text$x:00001660 __ehhandler$??0Splitter@@QAE@XZ proc near
.text$x:00001660                                         ; DATA XREF: Splitter::Splitter(void)+5o
.text$x:00001660
.text$x:00001660 arg_4           = dword ptr  8
.text$x:00001660
.text$x:00001660                 mov     edx, [esp+arg_4]
.text$x:00001664                 lea     eax, [edx+0Ch]
.text$x:00001667                 mov     ecx, [edx-8]
.text$x:0000166A                 xor     ecx, eax
.text$x:0000166C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001671                 mov     eax, offset __ehfuncinfo$??0Splitter@@QAE@XZ
.text$x:00001676                 jmp     ___CxxFrameHandler3
.text$x:00001676 __ehhandler$??0Splitter@@QAE@XZ endp
.text$x:00001676
.text$x:00001676 ; ---------------------------------------------------------------------------
.text$x:0000167B                 align 4
.text$x:0000167B _text$x         ends
.text$x:0000167B
.text$mn:0000167C ; ===========================================================================
.text$mn:0000167C
.text$mn:0000167C ; Segment type: Pure code
.text$mn:0000167C ; Segment permissions: Read/Execute
.text$mn:0000167C _text$mn        segment para public 'CODE' use32
.text$mn:0000167C                 assume cs:_text$mn
.text$mn:0000167C                 ;org 167Ch
.text$mn:0000167C ; COMDAT (pick any)
.text$mn:0000167C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000167C
.text$mn:0000167C ; =============== S U B R O U T I N E =======================================
.text$mn:0000167C
.text$mn:0000167C ; Attributes: bp-based frame
.text$mn:0000167C
.text$mn:0000167C ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:0000167C                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:0000167C ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:0000167C                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:0000167C
.text$mn:0000167C var_4           = dword ptr -4
.text$mn:0000167C arg_0           = dword ptr  8
.text$mn:0000167C
.text$mn:0000167C                 push    ebp
.text$mn:0000167D                 mov     ebp, esp
.text$mn:0000167F                 push    ecx
.text$mn:00001680                 mov     [ebp+var_4], 0
.text$mn:00001687                 cmp     [ebp+arg_0], 0
.text$mn:0000168B                 jnz     short loc_168F
.text$mn:0000168D                 jmp     short loc_16AF
.text$mn:0000168F ; ---------------------------------------------------------------------------
.text$mn:0000168F
.text$mn:0000168F loc_168F:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:0000168F                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00001693                 ja      short loc_16AA
.text$mn:00001695                 mov     eax, [ebp+arg_0]
.text$mn:00001698                 push    eax             ; unsigned int
.text$mn:00001699                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000169E                 add     esp, 4
.text$mn:000016A1                 mov     [ebp+var_4], eax
.text$mn:000016A4                 cmp     [ebp+var_4], 0
.text$mn:000016A8                 jnz     short loc_16AF
.text$mn:000016AA
.text$mn:000016AA loc_16AA:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000016AA                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000016AF
.text$mn:000016AF loc_16AF:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000016AF                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000016AF                 mov     eax, [ebp+var_4]
.text$mn:000016B2                 mov     esp, ebp
.text$mn:000016B4                 pop     ebp
.text$mn:000016B5                 retn
.text$mn:000016B5 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000016B5
.text$mn:000016B5 ; ---------------------------------------------------------------------------
.text$mn:000016B6                 align 4
.text$mn:000016B6 _text$mn        ends
.text$mn:000016B6
.text$mn:000016B8 ; ===========================================================================
.text$mn:000016B8
.text$mn:000016B8 ; Segment type: Pure code
.text$mn:000016B8 ; Segment permissions: Read/Execute
.text$mn:000016B8 _text$mn        segment para public 'CODE' use32
.text$mn:000016B8                 assume cs:_text$mn
.text$mn:000016B8                 ;org 16B8h
.text$mn:000016B8 ; COMDAT (pick any)
.text$mn:000016B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016B8
.text$mn:000016B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016B8
.text$mn:000016B8 ; Attributes: bp-based frame
.text$mn:000016B8
.text$mn:000016B8 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000016B8                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000016B8 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000016B8                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000016B8
.text$mn:000016B8 var_4           = dword ptr -4
.text$mn:000016B8 arg_0           = dword ptr  8
.text$mn:000016B8
.text$mn:000016B8                 push    ebp
.text$mn:000016B9                 mov     ebp, esp
.text$mn:000016BB                 push    ecx
.text$mn:000016BC                 mov     [ebp+var_4], 0
.text$mn:000016C3                 cmp     [ebp+arg_0], 0
.text$mn:000016C7                 jnz     short loc_16CB
.text$mn:000016C9                 jmp     short loc_16F1
.text$mn:000016CB ; ---------------------------------------------------------------------------
.text$mn:000016CB
.text$mn:000016CB loc_16CB:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000016CB                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000016D2                 ja      short loc_16EC
.text$mn:000016D4                 mov     eax, [ebp+arg_0]
.text$mn:000016D7                 shl     eax, 3
.text$mn:000016DA                 push    eax             ; unsigned int
.text$mn:000016DB                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000016E0                 add     esp, 4
.text$mn:000016E3                 mov     [ebp+var_4], eax
.text$mn:000016E6                 cmp     [ebp+var_4], 0
.text$mn:000016EA                 jnz     short loc_16F1
.text$mn:000016EC
.text$mn:000016EC loc_16EC:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000016EC                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000016F1
.text$mn:000016F1 loc_16F1:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000016F1                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000016F1                 mov     eax, [ebp+var_4]
.text$mn:000016F4                 mov     esp, ebp
.text$mn:000016F6                 pop     ebp
.text$mn:000016F7                 retn
.text$mn:000016F7 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000016F7
.text$mn:000016F7 _text$mn        ends
.text$mn:000016F7
.text$mn:000016F8 ; ===========================================================================
.text$mn:000016F8
.text$mn:000016F8 ; Segment type: Pure code
.text$mn:000016F8 ; Segment permissions: Read/Execute
.text$mn:000016F8 _text$mn        segment para public 'CODE' use32
.text$mn:000016F8                 assume cs:_text$mn
.text$mn:000016F8                 ;org 16F8h
.text$mn:000016F8 ; COMDAT (pick any)
.text$mn:000016F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016F8
.text$mn:000016F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016F8
.text$mn:000016F8 ; Attributes: bp-based frame
.text$mn:000016F8
.text$mn:000016F8 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000016F8                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000016F8 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000016F8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000016F8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000016F8
.text$mn:000016F8 arg_0           = dword ptr  8
.text$mn:000016F8 arg_4           = dword ptr  0Ch
.text$mn:000016F8 arg_8           = dword ptr  10h
.text$mn:000016F8
.text$mn:000016F8                 push    ebp
.text$mn:000016F9                 mov     ebp, esp
.text$mn:000016FB                 cmp     [ebp+arg_0], 0
.text$mn:000016FF                 jnz     short loc_1716
.text$mn:00001701                 mov     eax, [ebp+arg_8]
.text$mn:00001704                 push    eax             ; unsigned int
.text$mn:00001705                 mov     ecx, [ebp+arg_4]
.text$mn:00001708                 push    ecx             ; wchar_t *
.text$mn:00001709                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000170E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001713                 add     esp, 0Ch
.text$mn:00001716
.text$mn:00001716 loc_1716:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00001716                 pop     ebp
.text$mn:00001717                 retn
.text$mn:00001717 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00001717
.text$mn:00001717 _text$mn        ends
.text$mn:00001717
.text$mn:00001718 ; ===========================================================================
.text$mn:00001718
.text$mn:00001718 ; Segment type: Pure code
.text$mn:00001718 ; Segment permissions: Read/Execute
.text$mn:00001718 _text$mn        segment para public 'CODE' use32
.text$mn:00001718                 assume cs:_text$mn
.text$mn:00001718                 ;org 1718h
.text$mn:00001718 ; COMDAT (pick any)
.text$mn:00001718                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001718
.text$mn:00001718 ; =============== S U B R O U T I N E =======================================
.text$mn:00001718
.text$mn:00001718 ; Attributes: bp-based frame
.text$mn:00001718
.text$mn:00001718 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00001718                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00001718 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00001718                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00001718                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00001718
.text$mn:00001718 arg_0           = dword ptr  8
.text$mn:00001718
.text$mn:00001718                 push    ebp
.text$mn:00001719                 mov     ebp, esp
.text$mn:0000171B                 mov     eax, [ebp+arg_0]
.text$mn:0000171E                 pop     ebp
.text$mn:0000171F                 retn
.text$mn:0000171F ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:0000171F
.text$mn:0000171F _text$mn        ends
.text$mn:0000171F
.text$mn:00001720 ; ===========================================================================
.text$mn:00001720
.text$mn:00001720 ; Segment type: Pure code
.text$mn:00001720 ; Segment permissions: Read/Execute
.text$mn:00001720 _text$mn        segment para public 'CODE' use32
.text$mn:00001720                 assume cs:_text$mn
.text$mn:00001720                 ;org 1720h
.text$mn:00001720 ; COMDAT (pick any)
.text$mn:00001720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001720
.text$mn:00001720 ; =============== S U B R O U T I N E =======================================
.text$mn:00001720
.text$mn:00001720 ; Attributes: bp-based frame
.text$mn:00001720
.text$mn:00001720 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00001720                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00001720 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001720                                         ; CODE XREF: $LN19+4Bp
.text$mn:00001720
.text$mn:00001720 var_4           = dword ptr -4
.text$mn:00001720 arg_0           = dword ptr  8
.text$mn:00001720 arg_4           = dword ptr  0Ch
.text$mn:00001720
.text$mn:00001720                 push    ebp
.text$mn:00001721                 mov     ebp, esp
.text$mn:00001723                 push    ecx
.text$mn:00001724                 mov     [ebp+var_4], ecx
.text$mn:00001727                 mov     eax, [ebp+arg_4]
.text$mn:0000172A                 push    eax
.text$mn:0000172B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001730                 add     esp, 4
.text$mn:00001733                 push    eax             ; int
.text$mn:00001734                 mov     ecx, [ebp+arg_0]
.text$mn:00001737                 push    ecx             ; void *
.text$mn:00001738                 mov     edx, [ebp+var_4]
.text$mn:0000173B                 push    edx             ; int
.text$mn:0000173C                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00001741                 add     esp, 0Ch
.text$mn:00001744                 mov     esp, ebp
.text$mn:00001746                 pop     ebp
.text$mn:00001747                 retn    8
.text$mn:00001747 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00001747
.text$mn:00001747 ; ---------------------------------------------------------------------------
.text$mn:0000174A                 align 4
.text$mn:0000174A _text$mn        ends
.text$mn:0000174A
.text$mn:0000174C ; ===========================================================================
.text$mn:0000174C
.text$mn:0000174C ; Segment type: Pure code
.text$mn:0000174C ; Segment permissions: Read/Execute
.text$mn:0000174C _text$mn        segment para public 'CODE' use32
.text$mn:0000174C                 assume cs:_text$mn
.text$mn:0000174C                 ;org 174Ch
.text$mn:0000174C ; COMDAT (pick any)
.text$mn:0000174C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000174C
.text$mn:0000174C ; =============== S U B R O U T I N E =======================================
.text$mn:0000174C
.text$mn:0000174C ; Attributes: bp-based frame
.text$mn:0000174C
.text$mn:0000174C ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:0000174C                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000174C ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:0000174C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:0000174C
.text$mn:0000174C var_1C          = dword ptr -1Ch
.text$mn:0000174C var_18          = dword ptr -18h
.text$mn:0000174C var_14          = dword ptr -14h
.text$mn:0000174C var_10          = dword ptr -10h
.text$mn:0000174C var_C           = dword ptr -0Ch
.text$mn:0000174C var_4           = dword ptr -4
.text$mn:0000174C arg_0           = dword ptr  8
.text$mn:0000174C arg_4           = dword ptr  0Ch
.text$mn:0000174C
.text$mn:0000174C                 push    ebp
.text$mn:0000174D                 mov     ebp, esp
.text$mn:0000174F                 push    0FFFFFFFFh
.text$mn:00001751                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00001756                 mov     eax, large fs:0
.text$mn:0000175C                 push    eax
.text$mn:0000175D                 sub     esp, 10h
.text$mn:00001760                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001765                 xor     eax, ebp
.text$mn:00001767                 push    eax
.text$mn:00001768                 lea     eax, [ebp+var_C]
.text$mn:0000176B                 mov     large fs:0, eax
.text$mn:00001771                 mov     [ebp+var_18], ecx
.text$mn:00001774                 mov     eax, [ebp+arg_0]
.text$mn:00001777                 push    eax             ; void *
.text$mn:00001778                 push    4               ; unsigned int
.text$mn:0000177A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000177F                 add     esp, 8
.text$mn:00001782                 mov     [ebp+var_10], eax
.text$mn:00001785                 mov     [ebp+var_4], 0
.text$mn:0000178C                 cmp     [ebp+var_10], 0
.text$mn:00001790                 jz      short loc_17AD
.text$mn:00001792                 mov     ecx, [ebp+arg_4]
.text$mn:00001795                 push    ecx
.text$mn:00001796                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000179B                 add     esp, 4
.text$mn:0000179E                 mov     edx, [ebp+var_10]
.text$mn:000017A1                 mov     eax, [eax]
.text$mn:000017A3                 mov     [edx], eax
.text$mn:000017A5                 mov     ecx, [ebp+var_10]
.text$mn:000017A8                 mov     [ebp+var_14], ecx
.text$mn:000017AB                 jmp     short loc_17B4
.text$mn:000017AD ; ---------------------------------------------------------------------------
.text$mn:000017AD
.text$mn:000017AD loc_17AD:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000017AD                 mov     [ebp+var_14], 0
.text$mn:000017B4
.text$mn:000017B4 loc_17B4:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000017B4                 mov     edx, [ebp+var_14]
.text$mn:000017B7                 mov     [ebp+var_1C], edx
.text$mn:000017BA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000017C1                 mov     ecx, [ebp+var_C]
.text$mn:000017C4                 mov     large fs:0, ecx
.text$mn:000017CB                 pop     ecx
.text$mn:000017CC                 mov     esp, ebp
.text$mn:000017CE                 pop     ebp
.text$mn:000017CF                 retn    8
.text$mn:000017CF ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000017CF
.text$mn:000017CF ; ---------------------------------------------------------------------------
.text$mn:000017D2                 align 4
.text$mn:000017D2 _text$mn        ends
.text$mn:000017D2
.text$x:000017D4 ; ===========================================================================
.text$x:000017D4
.text$x:000017D4 ; Segment type: Pure code
.text$x:000017D4 ; Segment permissions: Read/Execute
.text$x:000017D4 _text$x         segment para public 'CODE' use32
.text$x:000017D4                 assume cs:_text$x
.text$x:000017D4                 ;org 17D4h
.text$x:000017D4 ; COMDAT (pick associative to section at 174C)
.text$x:000017D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000017D4
.text$x:000017D4 ; =============== S U B R O U T I N E =======================================
.text$x:000017D4
.text$x:000017D4
.text$x:000017D4 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000017D4                                         ; DATA XREF: .xdata$x:00003A20o
.text$x:000017D4                 mov     eax, [ebp+8]
.text$x:000017D7                 push    eax
.text$x:000017D8                 mov     eax, [ebp-10h]
.text$x:000017DB                 push    eax             ; void *
.text$x:000017DC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000017E1                 add     esp, 8
.text$x:000017E4                 retn
.text$x:000017E4 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000017E4
.text$x:000017E5
.text$x:000017E5 ; =============== S U B R O U T I N E =======================================
.text$x:000017E5
.text$x:000017E5
.text$x:000017E5 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000017E5                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000017E5
.text$x:000017E5 arg_4           = dword ptr  8
.text$x:000017E5
.text$x:000017E5                 mov     edx, [esp+arg_4]
.text$x:000017E9                 lea     eax, [edx+0Ch]
.text$x:000017EC                 mov     ecx, [edx-14h]
.text$x:000017EF                 xor     ecx, eax
.text$x:000017F1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000017F6                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000017FB                 jmp     ___CxxFrameHandler3
.text$x:000017FB __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000017FB
.text$x:000017FB _text$x         ends
.text$x:000017FB
.text$mn:00001800 ; ===========================================================================
.text$mn:00001800
.text$mn:00001800 ; Segment type: Pure code
.text$mn:00001800 ; Segment permissions: Read/Execute
.text$mn:00001800 _text$mn        segment para public 'CODE' use32
.text$mn:00001800                 assume cs:_text$mn
.text$mn:00001800                 ;org 1800h
.text$mn:00001800 ; COMDAT (pick any)
.text$mn:00001800                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001800
.text$mn:00001800 ; =============== S U B R O U T I N E =======================================
.text$mn:00001800
.text$mn:00001800 ; Attributes: bp-based frame
.text$mn:00001800
.text$mn:00001800 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00001800                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00001800 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00001800                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00001800
.text$mn:00001800 arg_0           = dword ptr  8
.text$mn:00001800 arg_4           = dword ptr  0Ch
.text$mn:00001800 arg_8           = dword ptr  10h
.text$mn:00001800
.text$mn:00001800                 push    ebp
.text$mn:00001801                 mov     ebp, esp
.text$mn:00001803                 mov     eax, [ebp+arg_8]
.text$mn:00001806                 push    eax
.text$mn:00001807                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000180C                 add     esp, 4
.text$mn:0000180F                 push    eax             ; int
.text$mn:00001810                 mov     ecx, [ebp+arg_4]
.text$mn:00001813                 push    ecx             ; void *
.text$mn:00001814                 mov     ecx, [ebp+arg_0]
.text$mn:00001817                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000181C                 pop     ebp
.text$mn:0000181D                 retn
.text$mn:0000181D ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:0000181D
.text$mn:0000181D ; ---------------------------------------------------------------------------
.text$mn:0000181E                 align 10h
.text$mn:0000181E _text$mn        ends
.text$mn:0000181E
.text$mn:00001820 ; ===========================================================================
.text$mn:00001820
.text$mn:00001820 ; Segment type: Pure code
.text$mn:00001820 ; Segment permissions: Read/Execute
.text$mn:00001820 _text$mn        segment para public 'CODE' use32
.text$mn:00001820                 assume cs:_text$mn
.text$mn:00001820                 ;org 1820h
.text$mn:00001820 ; COMDAT (pick any)
.text$mn:00001820                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001820
.text$mn:00001820 ; =============== S U B R O U T I N E =======================================
.text$mn:00001820
.text$mn:00001820 ; Attributes: bp-based frame
.text$mn:00001820
.text$mn:00001820 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00001820                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001820 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00001820                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00001820
.text$mn:00001820 var_1C          = dword ptr -1Ch
.text$mn:00001820 var_18          = dword ptr -18h
.text$mn:00001820 var_14          = dword ptr -14h
.text$mn:00001820 var_10          = dword ptr -10h
.text$mn:00001820 var_C           = dword ptr -0Ch
.text$mn:00001820 var_4           = dword ptr -4
.text$mn:00001820 arg_0           = dword ptr  8
.text$mn:00001820 arg_4           = dword ptr  0Ch
.text$mn:00001820
.text$mn:00001820                 push    ebp
.text$mn:00001821                 mov     ebp, esp
.text$mn:00001823                 push    0FFFFFFFFh
.text$mn:00001825                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000182A                 mov     eax, large fs:0
.text$mn:00001830                 push    eax
.text$mn:00001831                 sub     esp, 10h
.text$mn:00001834                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001839                 xor     eax, ebp
.text$mn:0000183B                 push    eax
.text$mn:0000183C                 lea     eax, [ebp+var_C]
.text$mn:0000183F                 mov     large fs:0, eax
.text$mn:00001845                 mov     [ebp+var_18], ecx
.text$mn:00001848                 mov     eax, [ebp+arg_0]
.text$mn:0000184B                 push    eax             ; void *
.text$mn:0000184C                 push    8               ; unsigned int
.text$mn:0000184E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001853                 add     esp, 8
.text$mn:00001856                 mov     [ebp+var_10], eax
.text$mn:00001859                 mov     [ebp+var_4], 0
.text$mn:00001860                 cmp     [ebp+var_10], 0
.text$mn:00001864                 jz      short loc_1887
.text$mn:00001866                 mov     ecx, [ebp+arg_4]
.text$mn:00001869                 push    ecx
.text$mn:0000186A                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000186F                 add     esp, 4
.text$mn:00001872                 mov     edx, [eax]
.text$mn:00001874                 mov     eax, [eax+4]
.text$mn:00001877                 mov     ecx, [ebp+var_10]
.text$mn:0000187A                 mov     [ecx], edx
.text$mn:0000187C                 mov     [ecx+4], eax
.text$mn:0000187F                 mov     edx, [ebp+var_10]
.text$mn:00001882                 mov     [ebp+var_14], edx
.text$mn:00001885                 jmp     short loc_188E
.text$mn:00001887 ; ---------------------------------------------------------------------------
.text$mn:00001887
.text$mn:00001887 loc_1887:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00001887                 mov     [ebp+var_14], 0
.text$mn:0000188E
.text$mn:0000188E loc_188E:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:0000188E                 mov     eax, [ebp+var_14]
.text$mn:00001891                 mov     [ebp+var_1C], eax
.text$mn:00001894                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000189B                 mov     ecx, [ebp+var_C]
.text$mn:0000189E                 mov     large fs:0, ecx
.text$mn:000018A5                 pop     ecx
.text$mn:000018A6                 mov     esp, ebp
.text$mn:000018A8                 pop     ebp
.text$mn:000018A9                 retn    8
.text$mn:000018A9 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000018A9
.text$mn:000018A9 _text$mn        ends
.text$mn:000018A9
.text$x:000018AC ; ===========================================================================
.text$x:000018AC
.text$x:000018AC ; Segment type: Pure code
.text$x:000018AC ; Segment permissions: Read/Execute
.text$x:000018AC _text$x         segment para public 'CODE' use32
.text$x:000018AC                 assume cs:_text$x
.text$x:000018AC                 ;org 18ACh
.text$x:000018AC ; COMDAT (pick associative to section at 1820)
.text$x:000018AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000018AC
.text$x:000018AC ; =============== S U B R O U T I N E =======================================
.text$x:000018AC
.text$x:000018AC
.text$x:000018AC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000018AC                                         ; DATA XREF: .xdata$x:000039F4o
.text$x:000018AC                 mov     eax, [ebp+8]
.text$x:000018AF                 push    eax
.text$x:000018B0                 mov     eax, [ebp-10h]
.text$x:000018B3                 push    eax             ; void *
.text$x:000018B4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000018B9                 add     esp, 8
.text$x:000018BC                 retn
.text$x:000018BC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:000018BC
.text$x:000018BD
.text$x:000018BD ; =============== S U B R O U T I N E =======================================
.text$x:000018BD
.text$x:000018BD
.text$x:000018BD __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:000018BD                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:000018BD
.text$x:000018BD arg_4           = dword ptr  8
.text$x:000018BD
.text$x:000018BD                 mov     edx, [esp+arg_4]
.text$x:000018C1                 lea     eax, [edx+0Ch]
.text$x:000018C4                 mov     ecx, [edx-14h]
.text$x:000018C7                 xor     ecx, eax
.text$x:000018C9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000018CE                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000018D3                 jmp     ___CxxFrameHandler3
.text$x:000018D3 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000018D3
.text$x:000018D3 _text$x         ends
.text$x:000018D3
.text$mn:000018D8 ; ===========================================================================
.text$mn:000018D8
.text$mn:000018D8 ; Segment type: Pure code
.text$mn:000018D8 ; Segment permissions: Read/Execute
.text$mn:000018D8 _text$mn        segment para public 'CODE' use32
.text$mn:000018D8                 assume cs:_text$mn
.text$mn:000018D8                 ;org 18D8h
.text$mn:000018D8 ; COMDAT (pick any)
.text$mn:000018D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018D8
.text$mn:000018D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000018D8
.text$mn:000018D8 ; Attributes: bp-based frame
.text$mn:000018D8
.text$mn:000018D8 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000018D8                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:000018D8 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:000018D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:000018D8
.text$mn:000018D8 var_4           = dword ptr -4
.text$mn:000018D8 arg_0           = dword ptr  8
.text$mn:000018D8
.text$mn:000018D8                 push    ebp
.text$mn:000018D9                 mov     ebp, esp
.text$mn:000018DB                 push    ecx
.text$mn:000018DC                 mov     [ebp+var_4], ecx
.text$mn:000018DF                 mov     eax, [ebp+arg_0]
.text$mn:000018E2                 push    eax
.text$mn:000018E3                 mov     ecx, [ebp+var_4]
.text$mn:000018E6                 push    ecx
.text$mn:000018E7                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:000018EC                 add     esp, 8
.text$mn:000018EF                 mov     esp, ebp
.text$mn:000018F1                 pop     ebp
.text$mn:000018F2                 retn    4
.text$mn:000018F2 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:000018F2
.text$mn:000018F2 ; ---------------------------------------------------------------------------
.text$mn:000018F5                 align 4
.text$mn:000018F5 _text$mn        ends
.text$mn:000018F5
.text$mn:000018F8 ; ===========================================================================
.text$mn:000018F8
.text$mn:000018F8 ; Segment type: Pure code
.text$mn:000018F8 ; Segment permissions: Read/Execute
.text$mn:000018F8 _text$mn        segment para public 'CODE' use32
.text$mn:000018F8                 assume cs:_text$mn
.text$mn:000018F8                 ;org 18F8h
.text$mn:000018F8 ; COMDAT (pick any)
.text$mn:000018F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018F8
.text$mn:000018F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000018F8
.text$mn:000018F8 ; Attributes: bp-based frame
.text$mn:000018F8
.text$mn:000018F8 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:000018F8                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:000018F8 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:000018F8                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:000018F8
.text$mn:000018F8 var_4           = dword ptr -4
.text$mn:000018F8
.text$mn:000018F8                 push    ebp
.text$mn:000018F9                 mov     ebp, esp
.text$mn:000018FB                 push    ecx
.text$mn:000018FC                 mov     [ebp+var_4], ecx
.text$mn:000018FF                 mov     esp, ebp
.text$mn:00001901                 pop     ebp
.text$mn:00001902                 retn    4
.text$mn:00001902 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00001902
.text$mn:00001902 ; ---------------------------------------------------------------------------
.text$mn:00001905                 align 4
.text$mn:00001905 _text$mn        ends
.text$mn:00001905
.text$mn:00001908 ; ===========================================================================
.text$mn:00001908
.text$mn:00001908 ; Segment type: Pure code
.text$mn:00001908 ; Segment permissions: Read/Execute
.text$mn:00001908 _text$mn        segment para public 'CODE' use32
.text$mn:00001908                 assume cs:_text$mn
.text$mn:00001908                 ;org 1908h
.text$mn:00001908 ; COMDAT (pick any)
.text$mn:00001908                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001908
.text$mn:00001908 ; =============== S U B R O U T I N E =======================================
.text$mn:00001908
.text$mn:00001908 ; Attributes: bp-based frame
.text$mn:00001908
.text$mn:00001908 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00001908                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00001908 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00001908                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00001908
.text$mn:00001908 arg_0           = dword ptr  8
.text$mn:00001908 arg_4           = dword ptr  0Ch
.text$mn:00001908
.text$mn:00001908                 push    ebp
.text$mn:00001909                 mov     ebp, esp
.text$mn:0000190B                 mov     eax, [ebp+arg_4]
.text$mn:0000190E                 push    eax
.text$mn:0000190F                 mov     ecx, [ebp+arg_0]
.text$mn:00001912                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00001917                 pop     ebp
.text$mn:00001918                 retn
.text$mn:00001918 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00001918
.text$mn:00001918 ; ---------------------------------------------------------------------------
.text$mn:00001919                 align 4
.text$mn:00001919 _text$mn        ends
.text$mn:00001919
.text$mn:0000191C ; ===========================================================================
.text$mn:0000191C
.text$mn:0000191C ; Segment type: Pure code
.text$mn:0000191C ; Segment permissions: Read/Execute
.text$mn:0000191C _text$mn        segment para public 'CODE' use32
.text$mn:0000191C                 assume cs:_text$mn
.text$mn:0000191C                 ;org 191Ch
.text$mn:0000191C ; COMDAT (pick any)
.text$mn:0000191C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000191C
.text$mn:0000191C ; =============== S U B R O U T I N E =======================================
.text$mn:0000191C
.text$mn:0000191C ; Attributes: bp-based frame
.text$mn:0000191C
.text$mn:0000191C ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:0000191C                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:0000191C ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:0000191C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:0000191C
.text$mn:0000191C var_4           = dword ptr -4
.text$mn:0000191C
.text$mn:0000191C                 push    ebp
.text$mn:0000191D                 mov     ebp, esp
.text$mn:0000191F                 push    ecx
.text$mn:00001920                 mov     [ebp+var_4], ecx
.text$mn:00001923                 mov     esp, ebp
.text$mn:00001925                 pop     ebp
.text$mn:00001926                 retn    4
.text$mn:00001926 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00001926
.text$mn:00001926 ; ---------------------------------------------------------------------------
.text$mn:00001929                 align 4
.text$mn:00001929 _text$mn        ends
.text$mn:00001929
.text$mn:0000192C ; ===========================================================================
.text$mn:0000192C
.text$mn:0000192C ; Segment type: Pure code
.text$mn:0000192C ; Segment permissions: Read/Execute
.text$mn:0000192C _text$mn        segment para public 'CODE' use32
.text$mn:0000192C                 assume cs:_text$mn
.text$mn:0000192C                 ;org 192Ch
.text$mn:0000192C ; COMDAT (pick any)
.text$mn:0000192C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000192C
.text$mn:0000192C ; =============== S U B R O U T I N E =======================================
.text$mn:0000192C
.text$mn:0000192C ; Attributes: bp-based frame
.text$mn:0000192C
.text$mn:0000192C ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:0000192C                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:0000192C ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:0000192C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:0000192C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:0000192C
.text$mn:0000192C arg_0           = dword ptr  8
.text$mn:0000192C
.text$mn:0000192C                 push    ebp
.text$mn:0000192D                 mov     ebp, esp
.text$mn:0000192F                 mov     eax, [ebp+arg_0]
.text$mn:00001932                 pop     ebp
.text$mn:00001933                 retn
.text$mn:00001933 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00001933
.text$mn:00001933 _text$mn        ends
.text$mn:00001933
.text$mn:00001934 ; ===========================================================================
.text$mn:00001934
.text$mn:00001934 ; Segment type: Pure code
.text$mn:00001934 ; Segment permissions: Read/Execute
.text$mn:00001934 _text$mn        segment para public 'CODE' use32
.text$mn:00001934                 assume cs:_text$mn
.text$mn:00001934                 ;org 1934h
.text$mn:00001934 ; COMDAT (pick any)
.text$mn:00001934                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001934
.text$mn:00001934 ; =============== S U B R O U T I N E =======================================
.text$mn:00001934
.text$mn:00001934 ; Attributes: bp-based frame
.text$mn:00001934
.text$mn:00001934 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00001934                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00001934 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00001934                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00001934
.text$mn:00001934 arg_0           = dword ptr  8
.text$mn:00001934
.text$mn:00001934                 push    ebp
.text$mn:00001935                 mov     ebp, esp
.text$mn:00001937                 mov     eax, [ebp+arg_0]
.text$mn:0000193A                 pop     ebp
.text$mn:0000193B                 retn
.text$mn:0000193B ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:0000193B
.text$mn:0000193B _text$mn        ends
.text$mn:0000193B
.text$mn:0000193C ; ===========================================================================
.text$mn:0000193C
.text$mn:0000193C ; Segment type: Pure code
.text$mn:0000193C ; Segment permissions: Read/Execute
.text$mn:0000193C _text$mn        segment para public 'CODE' use32
.text$mn:0000193C                 assume cs:_text$mn
.text$mn:0000193C                 ;org 193Ch
.text$mn:0000193C ; COMDAT (pick any)
.text$mn:0000193C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000193C
.text$mn:0000193C ; =============== S U B R O U T I N E =======================================
.text$mn:0000193C
.text$mn:0000193C ; Attributes: bp-based frame
.text$mn:0000193C
.text$mn:0000193C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:0000193C                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000193C ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:0000193C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:0000193C
.text$mn:0000193C var_10          = dword ptr -10h
.text$mn:0000193C var_C           = dword ptr -0Ch
.text$mn:0000193C var_4           = dword ptr -4
.text$mn:0000193C
.text$mn:0000193C                 push    ebp
.text$mn:0000193D                 mov     ebp, esp
.text$mn:0000193F                 push    0FFFFFFFFh
.text$mn:00001941                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00001946                 mov     eax, large fs:0
.text$mn:0000194C                 push    eax
.text$mn:0000194D                 push    ecx
.text$mn:0000194E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001953                 xor     eax, ebp
.text$mn:00001955                 push    eax
.text$mn:00001956                 lea     eax, [ebp+var_C]
.text$mn:00001959                 mov     large fs:0, eax
.text$mn:0000195F                 mov     [ebp+var_10], ecx
.text$mn:00001962                 mov     ecx, [ebp+var_10]
.text$mn:00001965                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:0000196A                 mov     [ebp+var_4], 0
.text$mn:00001971                 mov     ecx, [ebp+var_10]
.text$mn:00001974                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00001979                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001980                 mov     eax, [ebp+var_10]
.text$mn:00001983                 mov     ecx, [ebp+var_C]
.text$mn:00001986                 mov     large fs:0, ecx
.text$mn:0000198D                 pop     ecx
.text$mn:0000198E                 mov     esp, ebp
.text$mn:00001990                 pop     ebp
.text$mn:00001991                 retn    4
.text$mn:00001991 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00001991
.text$mn:00001991 _text$mn        ends
.text$mn:00001991
.text$x:00001994 ; ===========================================================================
.text$x:00001994
.text$x:00001994 ; Segment type: Pure code
.text$x:00001994 ; Segment permissions: Read/Execute
.text$x:00001994 _text$x         segment para public 'CODE' use32
.text$x:00001994                 assume cs:_text$x
.text$x:00001994                 ;org 1994h
.text$x:00001994 ; COMDAT (pick associative to section at 193C)
.text$x:00001994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001994
.text$x:00001994 ; =============== S U B R O U T I N E =======================================
.text$x:00001994
.text$x:00001994
.text$x:00001994 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00001994                                         ; DATA XREF: .xdata$x:00003650o
.text$x:00001994                 mov     ecx, [ebp-10h]
.text$x:00001997                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00001997 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00001997
.text$x:0000199C
.text$x:0000199C ; =============== S U B R O U T I N E =======================================
.text$x:0000199C
.text$x:0000199C
.text$x:0000199C __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:0000199C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:0000199C
.text$x:0000199C arg_4           = dword ptr  8
.text$x:0000199C
.text$x:0000199C                 mov     edx, [esp+arg_4]
.text$x:000019A0                 lea     eax, [edx+0Ch]
.text$x:000019A3                 mov     ecx, [edx-8]
.text$x:000019A6                 xor     ecx, eax
.text$x:000019A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019AD                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000019B2                 jmp     ___CxxFrameHandler3
.text$x:000019B2 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000019B2
.text$x:000019B2 ; ---------------------------------------------------------------------------
.text$x:000019B7                 align 4
.text$x:000019B7 _text$x         ends
.text$x:000019B7
.text$mn:000019B8 ; ===========================================================================
.text$mn:000019B8
.text$mn:000019B8 ; Segment type: Pure code
.text$mn:000019B8 ; Segment permissions: Read/Execute
.text$mn:000019B8 _text$mn        segment para public 'CODE' use32
.text$mn:000019B8                 assume cs:_text$mn
.text$mn:000019B8                 ;org 19B8h
.text$mn:000019B8 ; COMDAT (pick any)
.text$mn:000019B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019B8
.text$mn:000019B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000019B8
.text$mn:000019B8 ; Attributes: bp-based frame
.text$mn:000019B8
.text$mn:000019B8 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000019B8                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000019B8 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000019B8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:000019B8
.text$mn:000019B8 var_10          = dword ptr -10h
.text$mn:000019B8 var_C           = dword ptr -0Ch
.text$mn:000019B8 var_4           = dword ptr -4
.text$mn:000019B8
.text$mn:000019B8                 push    ebp
.text$mn:000019B9                 mov     ebp, esp
.text$mn:000019BB                 push    0FFFFFFFFh
.text$mn:000019BD                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000019C2                 mov     eax, large fs:0
.text$mn:000019C8                 push    eax
.text$mn:000019C9                 push    ecx
.text$mn:000019CA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000019CF                 xor     eax, ebp
.text$mn:000019D1                 push    eax
.text$mn:000019D2                 lea     eax, [ebp+var_C]
.text$mn:000019D5                 mov     large fs:0, eax
.text$mn:000019DB                 mov     [ebp+var_10], ecx
.text$mn:000019DE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000019E1                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000019E6                 mov     [ebp+var_4], 0
.text$mn:000019ED                 mov     eax, [ebp+var_10]
.text$mn:000019F0                 mov     dword ptr [eax+14h], 0
.text$mn:000019F7                 mov     ecx, [ebp+var_10]
.text$mn:000019FA                 mov     dword ptr [ecx+18h], 0
.text$mn:00001A01                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A08                 mov     eax, [ebp+var_10]
.text$mn:00001A0B                 mov     ecx, [ebp+var_C]
.text$mn:00001A0E                 mov     large fs:0, ecx
.text$mn:00001A15                 pop     ecx
.text$mn:00001A16                 mov     esp, ebp
.text$mn:00001A18                 pop     ebp
.text$mn:00001A19                 retn
.text$mn:00001A19 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00001A19
.text$mn:00001A19 ; ---------------------------------------------------------------------------
.text$mn:00001A1A                 align 4
.text$mn:00001A1A _text$mn        ends
.text$mn:00001A1A
.text$x:00001A1C ; ===========================================================================
.text$x:00001A1C
.text$x:00001A1C ; Segment type: Pure code
.text$x:00001A1C ; Segment permissions: Read/Execute
.text$x:00001A1C _text$x         segment para public 'CODE' use32
.text$x:00001A1C                 assume cs:_text$x
.text$x:00001A1C                 ;org 1A1Ch
.text$x:00001A1C ; COMDAT (pick associative to section at 19B8)
.text$x:00001A1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001A1C
.text$x:00001A1C ; =============== S U B R O U T I N E =======================================
.text$x:00001A1C
.text$x:00001A1C
.text$x:00001A1C __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001A1C                                         ; DATA XREF: .xdata$x:000035F8o
.text$x:00001A1C                 mov     ecx, [ebp-10h]  ; this
.text$x:00001A1F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001A1F __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001A1F
.text$x:00001A24
.text$x:00001A24 ; =============== S U B R O U T I N E =======================================
.text$x:00001A24
.text$x:00001A24
.text$x:00001A24 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001A24                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001A24
.text$x:00001A24 arg_4           = dword ptr  8
.text$x:00001A24
.text$x:00001A24                 mov     edx, [esp+arg_4]
.text$x:00001A28                 lea     eax, [edx+0Ch]
.text$x:00001A2B                 mov     ecx, [edx-8]
.text$x:00001A2E                 xor     ecx, eax
.text$x:00001A30                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A35                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00001A3A                 jmp     ___CxxFrameHandler3
.text$x:00001A3A __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00001A3A
.text$x:00001A3A ; ---------------------------------------------------------------------------
.text$x:00001A3F                 align 10h
.text$x:00001A3F _text$x         ends
.text$x:00001A3F
.text$mn:00001A40 ; ===========================================================================
.text$mn:00001A40
.text$mn:00001A40 ; Segment type: Pure code
.text$mn:00001A40 ; Segment permissions: Read/Execute
.text$mn:00001A40 _text$mn        segment para public 'CODE' use32
.text$mn:00001A40                 assume cs:_text$mn
.text$mn:00001A40                 ;org 1A40h
.text$mn:00001A40 ; COMDAT (pick any)
.text$mn:00001A40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A40
.text$mn:00001A40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A40
.text$mn:00001A40 ; Attributes: bp-based frame
.text$mn:00001A40
.text$mn:00001A40 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00001A40                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00001A40 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00001A40                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00001A40
.text$mn:00001A40 var_4           = dword ptr -4
.text$mn:00001A40
.text$mn:00001A40                 push    ebp
.text$mn:00001A41                 mov     ebp, esp
.text$mn:00001A43                 push    ecx
.text$mn:00001A44                 mov     [ebp+var_4], ecx
.text$mn:00001A47                 mov     ecx, [ebp+var_4]
.text$mn:00001A4A                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00001A4F                 mov     eax, [ebp+var_4]
.text$mn:00001A52                 mov     esp, ebp
.text$mn:00001A54                 pop     ebp
.text$mn:00001A55                 retn
.text$mn:00001A55 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00001A55
.text$mn:00001A55 ; ---------------------------------------------------------------------------
.text$mn:00001A56                 align 4
.text$mn:00001A56 _text$mn        ends
.text$mn:00001A56
.text$mn:00001A58 ; ===========================================================================
.text$mn:00001A58
.text$mn:00001A58 ; Segment type: Pure code
.text$mn:00001A58 ; Segment permissions: Read/Execute
.text$mn:00001A58 _text$mn        segment para public 'CODE' use32
.text$mn:00001A58                 assume cs:_text$mn
.text$mn:00001A58                 ;org 1A58h
.text$mn:00001A58 ; COMDAT (pick any)
.text$mn:00001A58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A58
.text$mn:00001A58 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A58
.text$mn:00001A58 ; Attributes: bp-based frame
.text$mn:00001A58
.text$mn:00001A58 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00001A58                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00001A58 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00001A58                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00001A58
.text$mn:00001A58 var_4           = dword ptr -4
.text$mn:00001A58
.text$mn:00001A58                 push    ebp
.text$mn:00001A59                 mov     ebp, esp
.text$mn:00001A5B                 push    ecx
.text$mn:00001A5C                 mov     [ebp+var_4], ecx
.text$mn:00001A5F                 mov     eax, [ebp+var_4]
.text$mn:00001A62                 mov     esp, ebp
.text$mn:00001A64                 pop     ebp
.text$mn:00001A65                 retn
.text$mn:00001A65 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00001A65
.text$mn:00001A65 ; ---------------------------------------------------------------------------
.text$mn:00001A66                 align 4
.text$mn:00001A66 _text$mn        ends
.text$mn:00001A66
.text$mn:00001A68 ; ===========================================================================
.text$mn:00001A68
.text$mn:00001A68 ; Segment type: Pure code
.text$mn:00001A68 ; Segment permissions: Read/Execute
.text$mn:00001A68 _text$mn        segment para public 'CODE' use32
.text$mn:00001A68                 assume cs:_text$mn
.text$mn:00001A68                 ;org 1A68h
.text$mn:00001A68 ; COMDAT (pick any)
.text$mn:00001A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A68
.text$mn:00001A68 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A68
.text$mn:00001A68 ; Attributes: bp-based frame
.text$mn:00001A68
.text$mn:00001A68 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00001A68                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00001A68 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00001A68                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00001A68                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:00001A68
.text$mn:00001A68 var_4           = dword ptr -4
.text$mn:00001A68
.text$mn:00001A68                 push    ebp
.text$mn:00001A69                 mov     ebp, esp
.text$mn:00001A6B                 push    ecx
.text$mn:00001A6C                 mov     [ebp+var_4], ecx
.text$mn:00001A6F                 mov     eax, [ebp+var_4]
.text$mn:00001A72                 mov     esp, ebp
.text$mn:00001A74                 pop     ebp
.text$mn:00001A75                 retn
.text$mn:00001A75 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00001A75
.text$mn:00001A75 ; ---------------------------------------------------------------------------
.text$mn:00001A76                 align 4
.text$mn:00001A76 _text$mn        ends
.text$mn:00001A76
.text$mn:00001A78 ; ===========================================================================
.text$mn:00001A78
.text$mn:00001A78 ; Segment type: Pure code
.text$mn:00001A78 ; Segment permissions: Read/Execute
.text$mn:00001A78 _text$mn        segment para public 'CODE' use32
.text$mn:00001A78                 assume cs:_text$mn
.text$mn:00001A78                 ;org 1A78h
.text$mn:00001A78 ; COMDAT (pick any)
.text$mn:00001A78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A78
.text$mn:00001A78 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A78
.text$mn:00001A78 ; Attributes: bp-based frame
.text$mn:00001A78
.text$mn:00001A78 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00001A78                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00001A78 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00001A78                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00001A78                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00001A78
.text$mn:00001A78 var_14          = dword ptr -14h
.text$mn:00001A78 var_D           = byte ptr -0Dh
.text$mn:00001A78 var_C           = dword ptr -0Ch
.text$mn:00001A78 var_4           = dword ptr -4
.text$mn:00001A78 Str             = dword ptr  8
.text$mn:00001A78
.text$mn:00001A78                 push    ebp
.text$mn:00001A79                 mov     ebp, esp
.text$mn:00001A7B                 push    0FFFFFFFFh
.text$mn:00001A7D                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00001A82                 mov     eax, large fs:0
.text$mn:00001A88                 push    eax
.text$mn:00001A89                 sub     esp, 8
.text$mn:00001A8C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A91                 xor     eax, ebp
.text$mn:00001A93                 push    eax
.text$mn:00001A94                 lea     eax, [ebp+var_C]
.text$mn:00001A97                 mov     large fs:0, eax
.text$mn:00001A9D                 mov     [ebp+var_14], ecx
.text$mn:00001AA0                 lea     ecx, [ebp+var_D]
.text$mn:00001AA3                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00001AA8                 push    eax
.text$mn:00001AA9                 mov     ecx, [ebp+var_14]
.text$mn:00001AAC                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00001AB1                 mov     [ebp+var_4], 0
.text$mn:00001AB8                 push    0               ; Size
.text$mn:00001ABA                 push    0               ; char
.text$mn:00001ABC                 mov     ecx, [ebp+var_14]
.text$mn:00001ABF                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001AC4                 mov     eax, [ebp+Str]
.text$mn:00001AC7                 push    eax             ; Str
.text$mn:00001AC8                 mov     ecx, [ebp+var_14]
.text$mn:00001ACB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00001AD0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001AD7                 mov     eax, [ebp+var_14]
.text$mn:00001ADA                 mov     ecx, [ebp+var_C]
.text$mn:00001ADD                 mov     large fs:0, ecx
.text$mn:00001AE4                 pop     ecx
.text$mn:00001AE5                 mov     esp, ebp
.text$mn:00001AE7                 pop     ebp
.text$mn:00001AE8                 retn    4
.text$mn:00001AE8 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00001AE8
.text$mn:00001AE8 ; ---------------------------------------------------------------------------
.text$mn:00001AEB                 align 4
.text$mn:00001AEB _text$mn        ends
.text$mn:00001AEB
.text$x:00001AEC ; ===========================================================================
.text$x:00001AEC
.text$x:00001AEC ; Segment type: Pure code
.text$x:00001AEC ; Segment permissions: Read/Execute
.text$x:00001AEC _text$x         segment para public 'CODE' use32
.text$x:00001AEC                 assume cs:_text$x
.text$x:00001AEC                 ;org 1AECh
.text$x:00001AEC ; COMDAT (pick associative to section at 1A78)
.text$x:00001AEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001AEC
.text$x:00001AEC ; =============== S U B R O U T I N E =======================================
.text$x:00001AEC
.text$x:00001AEC
.text$x:00001AEC __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00001AEC                                         ; DATA XREF: .xdata$x:000036A8o
.text$x:00001AEC                 mov     ecx, [ebp-14h]
.text$x:00001AEF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00001AEF __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00001AEF
.text$x:00001AF4
.text$x:00001AF4 ; =============== S U B R O U T I N E =======================================
.text$x:00001AF4
.text$x:00001AF4
.text$x:00001AF4 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00001AF4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00001AF4
.text$x:00001AF4 arg_4           = dword ptr  8
.text$x:00001AF4
.text$x:00001AF4                 mov     edx, [esp+arg_4]
.text$x:00001AF8                 lea     eax, [edx+0Ch]
.text$x:00001AFB                 mov     ecx, [edx-0Ch]
.text$x:00001AFE                 xor     ecx, eax
.text$x:00001B00                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B05                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00001B0A                 jmp     ___CxxFrameHandler3
.text$x:00001B0A __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00001B0A
.text$x:00001B0A ; ---------------------------------------------------------------------------
.text$x:00001B0F                 align 10h
.text$x:00001B0F _text$x         ends
.text$x:00001B0F
.text$mn:00001B10 ; ===========================================================================
.text$mn:00001B10
.text$mn:00001B10 ; Segment type: Pure code
.text$mn:00001B10 ; Segment permissions: Read/Execute
.text$mn:00001B10 _text$mn        segment para public 'CODE' use32
.text$mn:00001B10                 assume cs:_text$mn
.text$mn:00001B10                 ;org 1B10h
.text$mn:00001B10 ; COMDAT (pick any)
.text$mn:00001B10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B10
.text$mn:00001B10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B10
.text$mn:00001B10 ; Attributes: bp-based frame
.text$mn:00001B10
.text$mn:00001B10 ; _DWORD __thiscall Window::Window(Window *__hidden this)
.text$mn:00001B10                 public ??0Window@@QAE@XZ
.text$mn:00001B10 ??0Window@@QAE@XZ proc near             ; CODE XREF: Splitter::Splitter(void)+29p
.text$mn:00001B10
.text$mn:00001B10 var_4           = dword ptr -4
.text$mn:00001B10
.text$mn:00001B10                 push    ebp
.text$mn:00001B11                 mov     ebp, esp
.text$mn:00001B13                 push    ecx
.text$mn:00001B14                 mov     [ebp+var_4], ecx
.text$mn:00001B17                 mov     eax, [ebp+var_4]
.text$mn:00001B1A                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:00001B20                 mov     ecx, [ebp+var_4]
.text$mn:00001B23                 mov     dword ptr [ecx+4], 0
.text$mn:00001B2A                 mov     edx, [ebp+var_4]
.text$mn:00001B2D                 mov     dword ptr [edx+8], 0
.text$mn:00001B34                 mov     eax, [ebp+var_4]
.text$mn:00001B37                 mov     dword ptr [eax+0Ch], 0
.text$mn:00001B3E                 mov     eax, [ebp+var_4]
.text$mn:00001B41                 mov     esp, ebp
.text$mn:00001B43                 pop     ebp
.text$mn:00001B44                 retn
.text$mn:00001B44 ??0Window@@QAE@XZ endp
.text$mn:00001B44
.text$mn:00001B44 ; ---------------------------------------------------------------------------
.text$mn:00001B45                 align 4
.text$mn:00001B45 _text$mn        ends
.text$mn:00001B45
.text$mn:00001B48 ; ===========================================================================
.text$mn:00001B48
.text$mn:00001B48 ; Segment type: Pure code
.text$mn:00001B48 ; Segment permissions: Read/Execute
.text$mn:00001B48 _text$mn        segment para public 'CODE' use32
.text$mn:00001B48                 assume cs:_text$mn
.text$mn:00001B48                 ;org 1B48h
.text$mn:00001B48 ; COMDAT (pick any)
.text$mn:00001B48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B48
.text$mn:00001B48 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B48
.text$mn:00001B48 ; Attributes: bp-based frame
.text$mn:00001B48
.text$mn:00001B48 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001B48                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00001B48 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00001B48                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00001B48
.text$mn:00001B48 var_4           = dword ptr -4
.text$mn:00001B48
.text$mn:00001B48                 push    ebp
.text$mn:00001B49                 mov     ebp, esp
.text$mn:00001B4B                 push    ecx
.text$mn:00001B4C                 mov     [ebp+var_4], ecx
.text$mn:00001B4F                 mov     eax, [ebp+var_4]
.text$mn:00001B52                 mov     dword ptr [eax], 0
.text$mn:00001B58                 mov     eax, [ebp+var_4]
.text$mn:00001B5B                 mov     esp, ebp
.text$mn:00001B5D                 pop     ebp
.text$mn:00001B5E                 retn
.text$mn:00001B5E ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00001B5E
.text$mn:00001B5E ; ---------------------------------------------------------------------------
.text$mn:00001B5F                 align 10h
.text$mn:00001B5F _text$mn        ends
.text$mn:00001B5F
.text$mn:00001B60 ; ===========================================================================
.text$mn:00001B60
.text$mn:00001B60 ; Segment type: Pure code
.text$mn:00001B60 ; Segment permissions: Read/Execute
.text$mn:00001B60 _text$mn        segment para public 'CODE' use32
.text$mn:00001B60                 assume cs:_text$mn
.text$mn:00001B60                 ;org 1B60h
.text$mn:00001B60 ; COMDAT (pick any)
.text$mn:00001B60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B60
.text$mn:00001B60 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B60
.text$mn:00001B60 ; Attributes: bp-based frame
.text$mn:00001B60
.text$mn:00001B60 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00001B60                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00001B60 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00001B60                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00001B60
.text$mn:00001B60 var_4           = dword ptr -4
.text$mn:00001B60
.text$mn:00001B60                 push    ebp
.text$mn:00001B61                 mov     ebp, esp
.text$mn:00001B63                 push    ecx
.text$mn:00001B64                 mov     [ebp+var_4], ecx
.text$mn:00001B67                 mov     eax, [ebp+var_4]
.text$mn:00001B6A                 mov     dword ptr [eax], 0
.text$mn:00001B70                 mov     ecx, [ebp+var_4]
.text$mn:00001B73                 mov     dword ptr [ecx+4], 0
.text$mn:00001B7A                 mov     eax, [ebp+var_4]
.text$mn:00001B7D                 mov     esp, ebp
.text$mn:00001B7F                 pop     ebp
.text$mn:00001B80                 retn
.text$mn:00001B80 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00001B80
.text$mn:00001B80 ; ---------------------------------------------------------------------------
.text$mn:00001B81                 align 4
.text$mn:00001B81 _text$mn        ends
.text$mn:00001B81
.text$mn:00001B84 ; ===========================================================================
.text$mn:00001B84
.text$mn:00001B84 ; Segment type: Pure code
.text$mn:00001B84 ; Segment permissions: Read/Execute
.text$mn:00001B84 _text$mn        segment para public 'CODE' use32
.text$mn:00001B84                 assume cs:_text$mn
.text$mn:00001B84                 ;org 1B84h
.text$mn:00001B84 ; COMDAT (pick any)
.text$mn:00001B84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B84
.text$mn:00001B84 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B84
.text$mn:00001B84 ; Attributes: bp-based frame
.text$mn:00001B84
.text$mn:00001B84 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001B84                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00001B84 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00001B84                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00001B84                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00001B84
.text$mn:00001B84 var_10          = dword ptr -10h
.text$mn:00001B84 var_C           = dword ptr -0Ch
.text$mn:00001B84 var_4           = dword ptr -4
.text$mn:00001B84
.text$mn:00001B84                 push    ebp
.text$mn:00001B85                 mov     ebp, esp
.text$mn:00001B87                 push    0FFFFFFFFh
.text$mn:00001B89                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00001B8E                 mov     eax, large fs:0
.text$mn:00001B94                 push    eax
.text$mn:00001B95                 push    ecx
.text$mn:00001B96                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001B9B                 xor     eax, ebp
.text$mn:00001B9D                 push    eax
.text$mn:00001B9E                 lea     eax, [ebp+var_C]
.text$mn:00001BA1                 mov     large fs:0, eax
.text$mn:00001BA7                 mov     [ebp+var_10], ecx
.text$mn:00001BAA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001BAD                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00001BB2                 mov     [ebp+var_4], 0
.text$mn:00001BB9                 mov     eax, [ebp+var_10]
.text$mn:00001BBC                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00001BC2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001BC9                 mov     eax, [ebp+var_10]
.text$mn:00001BCC                 mov     ecx, [ebp+var_C]
.text$mn:00001BCF                 mov     large fs:0, ecx
.text$mn:00001BD6                 pop     ecx
.text$mn:00001BD7                 mov     esp, ebp
.text$mn:00001BD9                 pop     ebp
.text$mn:00001BDA                 retn
.text$mn:00001BDA ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00001BDA
.text$mn:00001BDA ; ---------------------------------------------------------------------------
.text$mn:00001BDB                 align 4
.text$mn:00001BDB _text$mn        ends
.text$mn:00001BDB
.text$x:00001BDC ; ===========================================================================
.text$x:00001BDC
.text$x:00001BDC ; Segment type: Pure code
.text$x:00001BDC ; Segment permissions: Read/Execute
.text$x:00001BDC _text$x         segment para public 'CODE' use32
.text$x:00001BDC                 assume cs:_text$x
.text$x:00001BDC                 ;org 1BDCh
.text$x:00001BDC ; COMDAT (pick associative to section at 1B84)
.text$x:00001BDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001BDC
.text$x:00001BDC ; =============== S U B R O U T I N E =======================================
.text$x:00001BDC
.text$x:00001BDC
.text$x:00001BDC __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00001BDC                                         ; DATA XREF: .xdata$x:00003810o
.text$x:00001BDC                 mov     ecx, [ebp-10h]  ; this
.text$x:00001BDF                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00001BDF __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00001BDF
.text$x:00001BE4
.text$x:00001BE4 ; =============== S U B R O U T I N E =======================================
.text$x:00001BE4
.text$x:00001BE4
.text$x:00001BE4 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00001BE4                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00001BE4
.text$x:00001BE4 arg_4           = dword ptr  8
.text$x:00001BE4
.text$x:00001BE4                 mov     edx, [esp+arg_4]
.text$x:00001BE8                 lea     eax, [edx+0Ch]
.text$x:00001BEB                 mov     ecx, [edx-8]
.text$x:00001BEE                 xor     ecx, eax
.text$x:00001BF0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001BF5                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00001BFA                 jmp     ___CxxFrameHandler3
.text$x:00001BFA __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00001BFA
.text$x:00001BFA ; ---------------------------------------------------------------------------
.text$x:00001BFF                 align 10h
.text$x:00001BFF _text$x         ends
.text$x:00001BFF
.text$mn:00001C00 ; ===========================================================================
.text$mn:00001C00
.text$mn:00001C00 ; Segment type: Pure code
.text$mn:00001C00 ; Segment permissions: Read/Execute
.text$mn:00001C00 _text$mn        segment para public 'CODE' use32
.text$mn:00001C00                 assume cs:_text$mn
.text$mn:00001C00                 ;org 1C00h
.text$mn:00001C00 ; COMDAT (pick any)
.text$mn:00001C00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C00
.text$mn:00001C00 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C00
.text$mn:00001C00 ; Attributes: bp-based frame
.text$mn:00001C00
.text$mn:00001C00 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00001C00                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00001C00 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00001C00                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00001C00
.text$mn:00001C00 var_10          = dword ptr -10h
.text$mn:00001C00 var_C           = dword ptr -0Ch
.text$mn:00001C00 var_4           = dword ptr -4
.text$mn:00001C00
.text$mn:00001C00                 push    ebp
.text$mn:00001C01                 mov     ebp, esp
.text$mn:00001C03                 push    0FFFFFFFFh
.text$mn:00001C05                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00001C0A                 mov     eax, large fs:0
.text$mn:00001C10                 push    eax
.text$mn:00001C11                 push    ecx
.text$mn:00001C12                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001C17                 xor     eax, ebp
.text$mn:00001C19                 push    eax
.text$mn:00001C1A                 lea     eax, [ebp+var_C]
.text$mn:00001C1D                 mov     large fs:0, eax
.text$mn:00001C23                 mov     [ebp+var_10], ecx
.text$mn:00001C26                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001C29                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00001C2E                 mov     [ebp+var_4], 0
.text$mn:00001C35                 mov     eax, [ebp+var_10]
.text$mn:00001C38                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00001C3E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001C45                 mov     eax, [ebp+var_10]
.text$mn:00001C48                 mov     ecx, [ebp+var_C]
.text$mn:00001C4B                 mov     large fs:0, ecx
.text$mn:00001C52                 pop     ecx
.text$mn:00001C53                 mov     esp, ebp
.text$mn:00001C55                 pop     ebp
.text$mn:00001C56                 retn
.text$mn:00001C56 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00001C56
.text$mn:00001C56 ; ---------------------------------------------------------------------------
.text$mn:00001C57                 align 4
.text$mn:00001C57 _text$mn        ends
.text$mn:00001C57
.text$x:00001C58 ; ===========================================================================
.text$x:00001C58
.text$x:00001C58 ; Segment type: Pure code
.text$x:00001C58 ; Segment permissions: Read/Execute
.text$x:00001C58 _text$x         segment para public 'CODE' use32
.text$x:00001C58                 assume cs:_text$x
.text$x:00001C58                 ;org 1C58h
.text$x:00001C58 ; COMDAT (pick associative to section at 1C00)
.text$x:00001C58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001C58
.text$x:00001C58 ; =============== S U B R O U T I N E =======================================
.text$x:00001C58
.text$x:00001C58
.text$x:00001C58 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00001C58                                         ; DATA XREF: .xdata$x:00003894o
.text$x:00001C58                 mov     ecx, [ebp-10h]  ; this
.text$x:00001C5B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001C5B __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00001C5B
.text$x:00001C60
.text$x:00001C60 ; =============== S U B R O U T I N E =======================================
.text$x:00001C60
.text$x:00001C60
.text$x:00001C60 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00001C60                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00001C60
.text$x:00001C60 arg_4           = dword ptr  8
.text$x:00001C60
.text$x:00001C60                 mov     edx, [esp+arg_4]
.text$x:00001C64                 lea     eax, [edx+0Ch]
.text$x:00001C67                 mov     ecx, [edx-8]
.text$x:00001C6A                 xor     ecx, eax
.text$x:00001C6C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C71                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00001C76                 jmp     ___CxxFrameHandler3
.text$x:00001C76 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00001C76
.text$x:00001C76 ; ---------------------------------------------------------------------------
.text$x:00001C7B                 align 4
.text$x:00001C7B _text$x         ends
.text$x:00001C7B
.text$mn:00001C7C ; ===========================================================================
.text$mn:00001C7C
.text$mn:00001C7C ; Segment type: Pure code
.text$mn:00001C7C ; Segment permissions: Read/Execute
.text$mn:00001C7C _text$mn        segment para public 'CODE' use32
.text$mn:00001C7C                 assume cs:_text$mn
.text$mn:00001C7C                 ;org 1C7Ch
.text$mn:00001C7C ; COMDAT (pick any)
.text$mn:00001C7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C7C
.text$mn:00001C7C ; =============== S U B R O U T I N E =======================================
.text$mn:00001C7C
.text$mn:00001C7C ; Attributes: bp-based frame
.text$mn:00001C7C
.text$mn:00001C7C ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001C7C                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00001C7C ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00001C7C                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001C7C
.text$mn:00001C7C var_10          = dword ptr -10h
.text$mn:00001C7C var_C           = dword ptr -0Ch
.text$mn:00001C7C var_4           = dword ptr -4
.text$mn:00001C7C
.text$mn:00001C7C                 push    ebp
.text$mn:00001C7D                 mov     ebp, esp
.text$mn:00001C7F                 push    0FFFFFFFFh
.text$mn:00001C81                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00001C86                 mov     eax, large fs:0
.text$mn:00001C8C                 push    eax
.text$mn:00001C8D                 push    ecx
.text$mn:00001C8E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001C93                 xor     eax, ebp
.text$mn:00001C95                 push    eax
.text$mn:00001C96                 lea     eax, [ebp+var_C]
.text$mn:00001C99                 mov     large fs:0, eax
.text$mn:00001C9F                 mov     [ebp+var_10], ecx
.text$mn:00001CA2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001CA5                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00001CAA                 mov     [ebp+var_4], 0
.text$mn:00001CB1                 mov     eax, [ebp+var_10]
.text$mn:00001CB4                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00001CBA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001CC1                 mov     eax, [ebp+var_10]
.text$mn:00001CC4                 mov     ecx, [ebp+var_C]
.text$mn:00001CC7                 mov     large fs:0, ecx
.text$mn:00001CCE                 pop     ecx
.text$mn:00001CCF                 mov     esp, ebp
.text$mn:00001CD1                 pop     ebp
.text$mn:00001CD2                 retn
.text$mn:00001CD2 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00001CD2
.text$mn:00001CD2 ; ---------------------------------------------------------------------------
.text$mn:00001CD3                 align 4
.text$mn:00001CD3 _text$mn        ends
.text$mn:00001CD3
.text$x:00001CD4 ; ===========================================================================
.text$x:00001CD4
.text$x:00001CD4 ; Segment type: Pure code
.text$x:00001CD4 ; Segment permissions: Read/Execute
.text$x:00001CD4 _text$x         segment para public 'CODE' use32
.text$x:00001CD4                 assume cs:_text$x
.text$x:00001CD4                 ;org 1CD4h
.text$x:00001CD4 ; COMDAT (pick associative to section at 1C7C)
.text$x:00001CD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001CD4
.text$x:00001CD4 ; =============== S U B R O U T I N E =======================================
.text$x:00001CD4
.text$x:00001CD4
.text$x:00001CD4 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00001CD4                                         ; DATA XREF: .xdata$x:00003918o
.text$x:00001CD4                 mov     ecx, [ebp-10h]  ; this
.text$x:00001CD7                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001CD7 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00001CD7
.text$x:00001CDC
.text$x:00001CDC ; =============== S U B R O U T I N E =======================================
.text$x:00001CDC
.text$x:00001CDC
.text$x:00001CDC __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00001CDC                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00001CDC
.text$x:00001CDC arg_4           = dword ptr  8
.text$x:00001CDC
.text$x:00001CDC                 mov     edx, [esp+arg_4]
.text$x:00001CE0                 lea     eax, [edx+0Ch]
.text$x:00001CE3                 mov     ecx, [edx-8]
.text$x:00001CE6                 xor     ecx, eax
.text$x:00001CE8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001CED                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00001CF2                 jmp     ___CxxFrameHandler3
.text$x:00001CF2 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00001CF2
.text$x:00001CF2 ; ---------------------------------------------------------------------------
.text$x:00001CF7                 align 4
.text$x:00001CF7 _text$x         ends
.text$x:00001CF7
.text$mn:00001CF8 ; ===========================================================================
.text$mn:00001CF8
.text$mn:00001CF8 ; Segment type: Pure code
.text$mn:00001CF8 ; Segment permissions: Read/Execute
.text$mn:00001CF8 _text$mn        segment para public 'CODE' use32
.text$mn:00001CF8                 assume cs:_text$mn
.text$mn:00001CF8                 ;org 1CF8h
.text$mn:00001CF8 ; COMDAT (pick any)
.text$mn:00001CF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CF8
.text$mn:00001CF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CF8
.text$mn:00001CF8 ; Attributes: bp-based frame
.text$mn:00001CF8
.text$mn:00001CF8 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00001CF8                 public ??0error_category@std@@QAE@XZ
.text$mn:00001CF8 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00001CF8
.text$mn:00001CF8 var_4           = dword ptr -4
.text$mn:00001CF8
.text$mn:00001CF8                 push    ebp
.text$mn:00001CF9                 mov     ebp, esp
.text$mn:00001CFB                 push    ecx
.text$mn:00001CFC                 mov     [ebp+var_4], ecx
.text$mn:00001CFF                 mov     eax, [ebp+var_4]
.text$mn:00001D02                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001D08                 mov     eax, [ebp+var_4]
.text$mn:00001D0B                 mov     esp, ebp
.text$mn:00001D0D                 pop     ebp
.text$mn:00001D0E                 retn
.text$mn:00001D0E ??0error_category@std@@QAE@XZ endp
.text$mn:00001D0E
.text$mn:00001D0E ; ---------------------------------------------------------------------------
.text$mn:00001D0F                 align 10h
.text$mn:00001D0F _text$mn        ends
.text$mn:00001D0F
.text$mn:00001D10 ; ===========================================================================
.text$mn:00001D10
.text$mn:00001D10 ; Segment type: Pure code
.text$mn:00001D10 ; Segment permissions: Read/Execute
.text$mn:00001D10 _text$mn        segment para public 'CODE' use32
.text$mn:00001D10                 assume cs:_text$mn
.text$mn:00001D10                 ;org 1D10h
.text$mn:00001D10 ; COMDAT (pick any)
.text$mn:00001D10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D10
.text$mn:00001D10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D10
.text$mn:00001D10 ; Attributes: bp-based frame
.text$mn:00001D10
.text$mn:00001D10 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00001D10                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00001D10 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00001D10                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00001D10                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00001D10
.text$mn:00001D10 var_4           = dword ptr -4
.text$mn:00001D10 arg_0           = dword ptr  8
.text$mn:00001D10 arg_4           = dword ptr  0Ch
.text$mn:00001D10
.text$mn:00001D10                 push    ebp
.text$mn:00001D11                 mov     ebp, esp
.text$mn:00001D13                 push    ecx
.text$mn:00001D14                 mov     [ebp+var_4], ecx
.text$mn:00001D17                 mov     eax, [ebp+var_4]
.text$mn:00001D1A                 mov     ecx, [ebp+arg_0]
.text$mn:00001D1D                 mov     [eax], ecx
.text$mn:00001D1F                 mov     edx, [ebp+var_4]
.text$mn:00001D22                 mov     eax, [ebp+arg_4]
.text$mn:00001D25                 mov     [edx+4], eax
.text$mn:00001D28                 mov     eax, [ebp+var_4]
.text$mn:00001D2B                 mov     esp, ebp
.text$mn:00001D2D                 pop     ebp
.text$mn:00001D2E                 retn    8
.text$mn:00001D2E ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00001D2E
.text$mn:00001D2E ; ---------------------------------------------------------------------------
.text$mn:00001D31                 align 4
.text$mn:00001D31 _text$mn        ends
.text$mn:00001D31
.text$mn:00001D34 ; ===========================================================================
.text$mn:00001D34
.text$mn:00001D34 ; Segment type: Pure code
.text$mn:00001D34 ; Segment permissions: Read/Execute
.text$mn:00001D34 _text$mn        segment para public 'CODE' use32
.text$mn:00001D34                 assume cs:_text$mn
.text$mn:00001D34                 ;org 1D34h
.text$mn:00001D34 ; COMDAT (pick any)
.text$mn:00001D34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D34
.text$mn:00001D34 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D34
.text$mn:00001D34 ; Attributes: bp-based frame
.text$mn:00001D34
.text$mn:00001D34 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:00001D34                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00001D34 ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:00001D34                                         ; DATA XREF: .xdata$x:00003AA8o
.text$mn:00001D34
.text$mn:00001D34 var_10          = dword ptr -10h
.text$mn:00001D34 var_C           = dword ptr -0Ch
.text$mn:00001D34 var_4           = dword ptr -4
.text$mn:00001D34 arg_0           = dword ptr  8
.text$mn:00001D34
.text$mn:00001D34                 push    ebp
.text$mn:00001D35                 mov     ebp, esp
.text$mn:00001D37                 push    0FFFFFFFFh
.text$mn:00001D39                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00001D3E                 mov     eax, large fs:0
.text$mn:00001D44                 push    eax
.text$mn:00001D45                 push    ecx
.text$mn:00001D46                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001D4B                 xor     eax, ebp
.text$mn:00001D4D                 push    eax
.text$mn:00001D4E                 lea     eax, [ebp+var_C]
.text$mn:00001D51                 mov     large fs:0, eax
.text$mn:00001D57                 mov     [ebp+var_10], ecx
.text$mn:00001D5A                 mov     eax, [ebp+arg_0]
.text$mn:00001D5D                 push    eax             ; struct std::exception *
.text$mn:00001D5E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001D61                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:00001D66                 mov     [ebp+var_4], 0
.text$mn:00001D6D                 mov     ecx, [ebp+var_10]
.text$mn:00001D70                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00001D76                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001D7D                 mov     eax, [ebp+var_10]
.text$mn:00001D80                 mov     ecx, [ebp+var_C]
.text$mn:00001D83                 mov     large fs:0, ecx
.text$mn:00001D8A                 pop     ecx
.text$mn:00001D8B                 mov     esp, ebp
.text$mn:00001D8D                 pop     ebp
.text$mn:00001D8E                 retn    4
.text$mn:00001D8E ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:00001D8E
.text$mn:00001D8E ; ---------------------------------------------------------------------------
.text$mn:00001D91                 align 4
.text$mn:00001D91 _text$mn        ends
.text$mn:00001D91
.text$x:00001D94 ; ===========================================================================
.text$x:00001D94
.text$x:00001D94 ; Segment type: Pure code
.text$x:00001D94 ; Segment permissions: Read/Execute
.text$x:00001D94 _text$x         segment para public 'CODE' use32
.text$x:00001D94                 assume cs:_text$x
.text$x:00001D94                 ;org 1D94h
.text$x:00001D94 ; COMDAT (pick associative to section at 1D34)
.text$x:00001D94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001D94
.text$x:00001D94 ; =============== S U B R O U T I N E =======================================
.text$x:00001D94
.text$x:00001D94
.text$x:00001D94 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:00001D94                                         ; DATA XREF: .xdata$x:000037E4o
.text$x:00001D94                 mov     ecx, [ebp-10h]  ; this
.text$x:00001D97                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00001D97 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:00001D97
.text$x:00001D9C
.text$x:00001D9C ; =============== S U B R O U T I N E =======================================
.text$x:00001D9C
.text$x:00001D9C
.text$x:00001D9C __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:00001D9C                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:00001D9C
.text$x:00001D9C arg_4           = dword ptr  8
.text$x:00001D9C
.text$x:00001D9C                 mov     edx, [esp+arg_4]
.text$x:00001DA0                 lea     eax, [edx+0Ch]
.text$x:00001DA3                 mov     ecx, [edx-8]
.text$x:00001DA6                 xor     ecx, eax
.text$x:00001DA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001DAD                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:00001DB2                 jmp     ___CxxFrameHandler3
.text$x:00001DB2 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:00001DB2
.text$x:00001DB2 ; ---------------------------------------------------------------------------
.text$x:00001DB7                 align 4
.text$x:00001DB7 _text$x         ends
.text$x:00001DB7
.text$mn:00001DB8 ; ===========================================================================
.text$mn:00001DB8
.text$mn:00001DB8 ; Segment type: Pure code
.text$mn:00001DB8 ; Segment permissions: Read/Execute
.text$mn:00001DB8 _text$mn        segment para public 'CODE' use32
.text$mn:00001DB8                 assume cs:_text$mn
.text$mn:00001DB8                 ;org 1DB8h
.text$mn:00001DB8 ; COMDAT (pick any)
.text$mn:00001DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DB8
.text$mn:00001DB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DB8
.text$mn:00001DB8 ; Attributes: bp-based frame
.text$mn:00001DB8
.text$mn:00001DB8 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:00001DB8                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:00001DB8 ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:00001DB8                                         ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+24p
.text$mn:00001DB8                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+45p ...
.text$mn:00001DB8
.text$mn:00001DB8 var_10          = dword ptr -10h
.text$mn:00001DB8 var_C           = dword ptr -0Ch
.text$mn:00001DB8 var_4           = dword ptr -4
.text$mn:00001DB8 arg_0           = dword ptr  8
.text$mn:00001DB8
.text$mn:00001DB8                 push    ebp
.text$mn:00001DB9                 mov     ebp, esp
.text$mn:00001DBB                 push    0FFFFFFFFh
.text$mn:00001DBD                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:00001DC2                 mov     eax, large fs:0
.text$mn:00001DC8                 push    eax
.text$mn:00001DC9                 push    ecx
.text$mn:00001DCA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001DCF                 xor     eax, ebp
.text$mn:00001DD1                 push    eax
.text$mn:00001DD2                 lea     eax, [ebp+var_C]
.text$mn:00001DD5                 mov     large fs:0, eax
.text$mn:00001DDB                 mov     [ebp+var_10], ecx
.text$mn:00001DDE                 lea     eax, [ebp+arg_0]
.text$mn:00001DE1                 push    eax             ; char **
.text$mn:00001DE2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001DE5                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:00001DEA                 mov     [ebp+var_4], 0
.text$mn:00001DF1                 mov     ecx, [ebp+var_10]
.text$mn:00001DF4                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00001DFA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001E01                 mov     eax, [ebp+var_10]
.text$mn:00001E04                 mov     ecx, [ebp+var_C]
.text$mn:00001E07                 mov     large fs:0, ecx
.text$mn:00001E0E                 pop     ecx
.text$mn:00001E0F                 mov     esp, ebp
.text$mn:00001E11                 pop     ebp
.text$mn:00001E12                 retn    4
.text$mn:00001E12 ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:00001E12
.text$mn:00001E12 ; ---------------------------------------------------------------------------
.text$mn:00001E15                 align 4
.text$mn:00001E15 _text$mn        ends
.text$mn:00001E15
.text$x:00001E18 ; ===========================================================================
.text$x:00001E18
.text$x:00001E18 ; Segment type: Pure code
.text$x:00001E18 ; Segment permissions: Read/Execute
.text$x:00001E18 _text$x         segment para public 'CODE' use32
.text$x:00001E18                 assume cs:_text$x
.text$x:00001E18                 ;org 1E18h
.text$x:00001E18 ; COMDAT (pick associative to section at 1DB8)
.text$x:00001E18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001E18
.text$x:00001E18 ; =============== S U B R O U T I N E =======================================
.text$x:00001E18
.text$x:00001E18
.text$x:00001E18 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:00001E18                                         ; DATA XREF: .xdata$x:0000378Co
.text$x:00001E18                 mov     ecx, [ebp-10h]  ; this
.text$x:00001E1B                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00001E1B __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:00001E1B
.text$x:00001E20
.text$x:00001E20 ; =============== S U B R O U T I N E =======================================
.text$x:00001E20
.text$x:00001E20
.text$x:00001E20 __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:00001E20                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:00001E20
.text$x:00001E20 arg_4           = dword ptr  8
.text$x:00001E20
.text$x:00001E20                 mov     edx, [esp+arg_4]
.text$x:00001E24                 lea     eax, [edx+0Ch]
.text$x:00001E27                 mov     ecx, [edx-8]
.text$x:00001E2A                 xor     ecx, eax
.text$x:00001E2C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E31                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:00001E36                 jmp     ___CxxFrameHandler3
.text$x:00001E36 __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:00001E36
.text$x:00001E36 ; ---------------------------------------------------------------------------
.text$x:00001E3B                 align 4
.text$x:00001E3B _text$x         ends
.text$x:00001E3B
.text$mn:00001E3C ; ===========================================================================
.text$mn:00001E3C
.text$mn:00001E3C ; Segment type: Pure code
.text$mn:00001E3C ; Segment permissions: Read/Execute
.text$mn:00001E3C _text$mn        segment para public 'CODE' use32
.text$mn:00001E3C                 assume cs:_text$mn
.text$mn:00001E3C                 ;org 1E3Ch
.text$mn:00001E3C ; COMDAT (pick any)
.text$mn:00001E3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E3C
.text$mn:00001E3C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E3C
.text$mn:00001E3C ; Attributes: bp-based frame
.text$mn:00001E3C
.text$mn:00001E3C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00001E3C                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001E3C ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00001E3C                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00001E3C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00001E3C
.text$mn:00001E3C var_10          = dword ptr -10h
.text$mn:00001E3C var_C           = dword ptr -0Ch
.text$mn:00001E3C var_4           = dword ptr -4
.text$mn:00001E3C
.text$mn:00001E3C                 push    ebp
.text$mn:00001E3D                 mov     ebp, esp
.text$mn:00001E3F                 push    0FFFFFFFFh
.text$mn:00001E41                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001E46                 mov     eax, large fs:0
.text$mn:00001E4C                 push    eax
.text$mn:00001E4D                 push    ecx
.text$mn:00001E4E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001E53                 xor     eax, ebp
.text$mn:00001E55                 push    eax
.text$mn:00001E56                 lea     eax, [ebp+var_C]
.text$mn:00001E59                 mov     large fs:0, eax
.text$mn:00001E5F                 mov     [ebp+var_10], ecx
.text$mn:00001E62                 mov     [ebp+var_4], 0
.text$mn:00001E69                 mov     ecx, [ebp+var_10]
.text$mn:00001E6C                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001E71                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001E78                 mov     ecx, [ebp+var_10]
.text$mn:00001E7B                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00001E80                 mov     ecx, [ebp+var_C]
.text$mn:00001E83                 mov     large fs:0, ecx
.text$mn:00001E8A                 pop     ecx
.text$mn:00001E8B                 mov     esp, ebp
.text$mn:00001E8D                 pop     ebp
.text$mn:00001E8E                 retn
.text$mn:00001E8E ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00001E8E
.text$mn:00001E8E ; ---------------------------------------------------------------------------
.text$mn:00001E8F                 align 10h
.text$mn:00001E8F _text$mn        ends
.text$mn:00001E8F
.text$x:00001E90 ; ===========================================================================
.text$x:00001E90
.text$x:00001E90 ; Segment type: Pure code
.text$x:00001E90 ; Segment permissions: Read/Execute
.text$x:00001E90 _text$x         segment para public 'CODE' use32
.text$x:00001E90                 assume cs:_text$x
.text$x:00001E90                 ;org 1E90h
.text$x:00001E90 ; COMDAT (pick associative to section at 1E3C)
.text$x:00001E90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001E90
.text$x:00001E90 ; =============== S U B R O U T I N E =======================================
.text$x:00001E90
.text$x:00001E90
.text$x:00001E90 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00001E90                                         ; DATA XREF: .xdata$x:0000367Co
.text$x:00001E90                 mov     ecx, [ebp-10h]
.text$x:00001E93                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00001E93 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00001E93
.text$x:00001E98
.text$x:00001E98 ; =============== S U B R O U T I N E =======================================
.text$x:00001E98
.text$x:00001E98
.text$x:00001E98 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00001E98                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00001E98
.text$x:00001E98 arg_4           = dword ptr  8
.text$x:00001E98
.text$x:00001E98                 mov     edx, [esp+arg_4]
.text$x:00001E9C                 lea     eax, [edx+0Ch]
.text$x:00001E9F                 mov     ecx, [edx-8]
.text$x:00001EA2                 xor     ecx, eax
.text$x:00001EA4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001EA9                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00001EAE                 jmp     ___CxxFrameHandler3
.text$x:00001EAE __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00001EAE
.text$x:00001EAE ; ---------------------------------------------------------------------------
.text$x:00001EB3                 align 4
.text$x:00001EB3 _text$x         ends
.text$x:00001EB3
.text$mn:00001EB4 ; ===========================================================================
.text$mn:00001EB4
.text$mn:00001EB4 ; Segment type: Pure code
.text$mn:00001EB4 ; Segment permissions: Read/Execute
.text$mn:00001EB4 _text$mn        segment para public 'CODE' use32
.text$mn:00001EB4                 assume cs:_text$mn
.text$mn:00001EB4                 ;org 1EB4h
.text$mn:00001EB4 ; COMDAT (pick any)
.text$mn:00001EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EB4
.text$mn:00001EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EB4
.text$mn:00001EB4 ; Attributes: bp-based frame
.text$mn:00001EB4
.text$mn:00001EB4 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001EB4                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001EB4 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001EB4                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00001EB4                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00001EB4
.text$mn:00001EB4 var_10          = dword ptr -10h
.text$mn:00001EB4 var_C           = dword ptr -0Ch
.text$mn:00001EB4 var_4           = dword ptr -4
.text$mn:00001EB4
.text$mn:00001EB4                 push    ebp
.text$mn:00001EB5                 mov     ebp, esp
.text$mn:00001EB7                 push    0FFFFFFFFh
.text$mn:00001EB9                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001EBE                 mov     eax, large fs:0
.text$mn:00001EC4                 push    eax
.text$mn:00001EC5                 push    ecx
.text$mn:00001EC6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001ECB                 xor     eax, ebp
.text$mn:00001ECD                 push    eax
.text$mn:00001ECE                 lea     eax, [ebp+var_C]
.text$mn:00001ED1                 mov     large fs:0, eax
.text$mn:00001ED7                 mov     [ebp+var_10], ecx
.text$mn:00001EDA                 mov     [ebp+var_4], 0
.text$mn:00001EE1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001EE8                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001EEB                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00001EF0                 mov     ecx, [ebp+var_C]
.text$mn:00001EF3                 mov     large fs:0, ecx
.text$mn:00001EFA                 pop     ecx
.text$mn:00001EFB                 mov     esp, ebp
.text$mn:00001EFD                 pop     ebp
.text$mn:00001EFE                 retn
.text$mn:00001EFE ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00001EFE
.text$mn:00001EFE ; ---------------------------------------------------------------------------
.text$mn:00001EFF                 align 10h
.text$mn:00001EFF _text$mn        ends
.text$mn:00001EFF
.text$x:00001F00 ; ===========================================================================
.text$x:00001F00
.text$x:00001F00 ; Segment type: Pure code
.text$x:00001F00 ; Segment permissions: Read/Execute
.text$x:00001F00 _text$x         segment para public 'CODE' use32
.text$x:00001F00                 assume cs:_text$x
.text$x:00001F00                 ;org 1F00h
.text$x:00001F00 ; COMDAT (pick associative to section at 1EB4)
.text$x:00001F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001F00
.text$x:00001F00 ; =============== S U B R O U T I N E =======================================
.text$x:00001F00
.text$x:00001F00
.text$x:00001F00 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001F00                                         ; DATA XREF: .xdata$x:00003624o
.text$x:00001F00                 mov     ecx, [ebp-10h]  ; this
.text$x:00001F03                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001F03 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001F03
.text$x:00001F08
.text$x:00001F08 ; =============== S U B R O U T I N E =======================================
.text$x:00001F08
.text$x:00001F08
.text$x:00001F08 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001F08                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001F08
.text$x:00001F08 arg_4           = dword ptr  8
.text$x:00001F08
.text$x:00001F08                 mov     edx, [esp+arg_4]
.text$x:00001F0C                 lea     eax, [edx+0Ch]
.text$x:00001F0F                 mov     ecx, [edx-8]
.text$x:00001F12                 xor     ecx, eax
.text$x:00001F14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001F19                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00001F1E                 jmp     ___CxxFrameHandler3
.text$x:00001F1E __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00001F1E
.text$x:00001F1E ; ---------------------------------------------------------------------------
.text$x:00001F23                 align 4
.text$x:00001F23 _text$x         ends
.text$x:00001F23
.text$mn:00001F24 ; ===========================================================================
.text$mn:00001F24
.text$mn:00001F24 ; Segment type: Pure code
.text$mn:00001F24 ; Segment permissions: Read/Execute
.text$mn:00001F24 _text$mn        segment para public 'CODE' use32
.text$mn:00001F24                 assume cs:_text$mn
.text$mn:00001F24                 ;org 1F24h
.text$mn:00001F24 ; COMDAT (pick any)
.text$mn:00001F24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F24
.text$mn:00001F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F24
.text$mn:00001F24 ; Attributes: bp-based frame
.text$mn:00001F24
.text$mn:00001F24 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00001F24                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001F24 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00001F24                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00001F24                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00001F24
.text$mn:00001F24 var_10          = dword ptr -10h
.text$mn:00001F24 var_C           = dword ptr -0Ch
.text$mn:00001F24 var_4           = dword ptr -4
.text$mn:00001F24
.text$mn:00001F24                 push    ebp
.text$mn:00001F25                 mov     ebp, esp
.text$mn:00001F27                 push    0FFFFFFFFh
.text$mn:00001F29                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001F2E                 mov     eax, large fs:0
.text$mn:00001F34                 push    eax
.text$mn:00001F35                 push    ecx
.text$mn:00001F36                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001F3B                 xor     eax, ebp
.text$mn:00001F3D                 push    eax
.text$mn:00001F3E                 lea     eax, [ebp+var_C]
.text$mn:00001F41                 mov     large fs:0, eax
.text$mn:00001F47                 mov     [ebp+var_10], ecx
.text$mn:00001F4A                 mov     [ebp+var_4], 0
.text$mn:00001F51                 push    0               ; Size
.text$mn:00001F53                 push    1               ; char
.text$mn:00001F55                 mov     ecx, [ebp+var_10]
.text$mn:00001F58                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001F5D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001F64                 mov     ecx, [ebp+var_10]
.text$mn:00001F67                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00001F6C                 mov     ecx, [ebp+var_C]
.text$mn:00001F6F                 mov     large fs:0, ecx
.text$mn:00001F76                 pop     ecx
.text$mn:00001F77                 mov     esp, ebp
.text$mn:00001F79                 pop     ebp
.text$mn:00001F7A                 retn
.text$mn:00001F7A ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00001F7A
.text$mn:00001F7A ; ---------------------------------------------------------------------------
.text$mn:00001F7B                 align 4
.text$mn:00001F7B _text$mn        ends
.text$mn:00001F7B
.text$x:00001F7C ; ===========================================================================
.text$x:00001F7C
.text$x:00001F7C ; Segment type: Pure code
.text$x:00001F7C ; Segment permissions: Read/Execute
.text$x:00001F7C _text$x         segment para public 'CODE' use32
.text$x:00001F7C                 assume cs:_text$x
.text$x:00001F7C                 ;org 1F7Ch
.text$x:00001F7C ; COMDAT (pick associative to section at 1F24)
.text$x:00001F7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001F7C
.text$x:00001F7C ; =============== S U B R O U T I N E =======================================
.text$x:00001F7C
.text$x:00001F7C
.text$x:00001F7C __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00001F7C                                         ; DATA XREF: .xdata$x:000036D4o
.text$x:00001F7C                 mov     ecx, [ebp-10h]
.text$x:00001F7F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00001F7F __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00001F7F
.text$x:00001F84
.text$x:00001F84 ; =============== S U B R O U T I N E =======================================
.text$x:00001F84
.text$x:00001F84
.text$x:00001F84 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00001F84                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00001F84
.text$x:00001F84 arg_4           = dword ptr  8
.text$x:00001F84
.text$x:00001F84                 mov     edx, [esp+arg_4]
.text$x:00001F88                 lea     eax, [edx+0Ch]
.text$x:00001F8B                 mov     ecx, [edx-8]
.text$x:00001F8E                 xor     ecx, eax
.text$x:00001F90                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001F95                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00001F9A                 jmp     ___CxxFrameHandler3
.text$x:00001F9A __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00001F9A
.text$x:00001F9A ; ---------------------------------------------------------------------------
.text$x:00001F9F                 align 10h
.text$x:00001F9F _text$x         ends
.text$x:00001F9F
.text$mn:00001FA0 ; ===========================================================================
.text$mn:00001FA0
.text$mn:00001FA0 ; Segment type: Pure code
.text$mn:00001FA0 ; Segment permissions: Read/Execute
.text$mn:00001FA0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FA0                 assume cs:_text$mn
.text$mn:00001FA0                 ;org 1FA0h
.text$mn:00001FA0 ; COMDAT (pick any)
.text$mn:00001FA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FA0
.text$mn:00001FA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FA0
.text$mn:00001FA0 ; Attributes: bp-based frame
.text$mn:00001FA0
.text$mn:00001FA0 ; _DWORD __thiscall Splitter::~Splitter(Splitter *__hidden this)
.text$mn:00001FA0                 public ??1Splitter@@UAE@XZ
.text$mn:00001FA0 ??1Splitter@@UAE@XZ proc near           ; CODE XREF: Splitter::`scalar deleting destructor'(uint)+Ap
.text$mn:00001FA0
.text$mn:00001FA0 var_10          = dword ptr -10h
.text$mn:00001FA0 var_C           = dword ptr -0Ch
.text$mn:00001FA0 var_4           = dword ptr -4
.text$mn:00001FA0
.text$mn:00001FA0                 push    ebp
.text$mn:00001FA1                 mov     ebp, esp
.text$mn:00001FA3                 push    0FFFFFFFFh
.text$mn:00001FA5                 push    offset __ehhandler$??1Splitter@@UAE@XZ
.text$mn:00001FAA                 mov     eax, large fs:0
.text$mn:00001FB0                 push    eax
.text$mn:00001FB1                 push    ecx
.text$mn:00001FB2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001FB7                 xor     eax, ebp
.text$mn:00001FB9                 push    eax
.text$mn:00001FBA                 lea     eax, [ebp+var_C]
.text$mn:00001FBD                 mov     large fs:0, eax
.text$mn:00001FC3                 mov     [ebp+var_10], ecx
.text$mn:00001FC6                 mov     eax, [ebp+var_10]
.text$mn:00001FC9                 mov     dword ptr [eax], offset ??_7Splitter@@6B@ ; const Splitter::`vftable'
.text$mn:00001FCF                 mov     [ebp+var_4], 0
.text$mn:00001FD6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001FDD                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001FE0                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:00001FE5                 mov     ecx, [ebp+var_C]
.text$mn:00001FE8                 mov     large fs:0, ecx
.text$mn:00001FEF                 pop     ecx
.text$mn:00001FF0                 mov     esp, ebp
.text$mn:00001FF2                 pop     ebp
.text$mn:00001FF3                 retn
.text$mn:00001FF3 ??1Splitter@@UAE@XZ endp
.text$mn:00001FF3
.text$mn:00001FF3 _text$mn        ends
.text$mn:00001FF3
.text$x:00001FF4 ; ===========================================================================
.text$x:00001FF4
.text$x:00001FF4 ; Segment type: Pure code
.text$x:00001FF4 ; Segment permissions: Read/Execute
.text$x:00001FF4 _text$x         segment para public 'CODE' use32
.text$x:00001FF4                 assume cs:_text$x
.text$x:00001FF4                 ;org 1FF4h
.text$x:00001FF4 ; COMDAT (pick associative to section at 1FA0)
.text$x:00001FF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001FF4
.text$x:00001FF4 ; =============== S U B R O U T I N E =======================================
.text$x:00001FF4
.text$x:00001FF4
.text$x:00001FF4 __unwindfunclet$??1Splitter@@UAE@XZ$0 proc near
.text$x:00001FF4                                         ; DATA XREF: .xdata$x:000039C8o
.text$x:00001FF4                 mov     ecx, [ebp-10h]  ; this
.text$x:00001FF7                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:00001FF7 __unwindfunclet$??1Splitter@@UAE@XZ$0 endp
.text$x:00001FF7
.text$x:00001FFC
.text$x:00001FFC ; =============== S U B R O U T I N E =======================================
.text$x:00001FFC
.text$x:00001FFC
.text$x:00001FFC __ehhandler$??1Splitter@@UAE@XZ proc near
.text$x:00001FFC                                         ; DATA XREF: Splitter::~Splitter(void)+5o
.text$x:00001FFC
.text$x:00001FFC arg_4           = dword ptr  8
.text$x:00001FFC
.text$x:00001FFC                 mov     edx, [esp+arg_4]
.text$x:00002000                 lea     eax, [edx+0Ch]
.text$x:00002003                 mov     ecx, [edx-8]
.text$x:00002006                 xor     ecx, eax
.text$x:00002008                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000200D                 mov     eax, offset __ehfuncinfo$??1Splitter@@UAE@XZ
.text$x:00002012                 jmp     ___CxxFrameHandler3
.text$x:00002012 __ehhandler$??1Splitter@@UAE@XZ endp
.text$x:00002012
.text$x:00002012 ; ---------------------------------------------------------------------------
.text$x:00002017                 align 4
.text$x:00002017 _text$x         ends
.text$x:00002017
.text$mn:00002018 ; ===========================================================================
.text$mn:00002018
.text$mn:00002018 ; Segment type: Pure code
.text$mn:00002018 ; Segment permissions: Read/Execute
.text$mn:00002018 _text$mn        segment para public 'CODE' use32
.text$mn:00002018                 assume cs:_text$mn
.text$mn:00002018                 ;org 2018h
.text$mn:00002018 ; COMDAT (pick any)
.text$mn:00002018                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002018
.text$mn:00002018 ; =============== S U B R O U T I N E =======================================
.text$mn:00002018
.text$mn:00002018 ; Attributes: bp-based frame
.text$mn:00002018
.text$mn:00002018 ; _DWORD __thiscall Window::~Window(Window *__hidden this)
.text$mn:00002018                 public ??1Window@@UAE@XZ
.text$mn:00002018 ??1Window@@UAE@XZ proc near             ; CODE XREF: __unwindfunclet$??0Splitter@@QAE@XZ$0+3j
.text$mn:00002018                                         ; Splitter::~Splitter(void)+40p ...
.text$mn:00002018
.text$mn:00002018 var_4           = dword ptr -4
.text$mn:00002018
.text$mn:00002018                 push    ebp
.text$mn:00002019                 mov     ebp, esp
.text$mn:0000201B                 push    ecx
.text$mn:0000201C                 mov     [ebp+var_4], ecx
.text$mn:0000201F                 mov     eax, [ebp+var_4]
.text$mn:00002022                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:00002028                 mov     esp, ebp
.text$mn:0000202A                 pop     ebp
.text$mn:0000202B                 retn
.text$mn:0000202B ??1Window@@UAE@XZ endp
.text$mn:0000202B
.text$mn:0000202B _text$mn        ends
.text$mn:0000202B
.text$mn:0000202C ; ===========================================================================
.text$mn:0000202C
.text$mn:0000202C ; Segment type: Pure code
.text$mn:0000202C ; Segment permissions: Read/Execute
.text$mn:0000202C _text$mn        segment para public 'CODE' use32
.text$mn:0000202C                 assume cs:_text$mn
.text$mn:0000202C                 ;org 202Ch
.text$mn:0000202C ; COMDAT (pick any)
.text$mn:0000202C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000202C
.text$mn:0000202C ; =============== S U B R O U T I N E =======================================
.text$mn:0000202C
.text$mn:0000202C ; Attributes: bp-based frame
.text$mn:0000202C
.text$mn:0000202C ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:0000202C                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:0000202C ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:0000202C                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:0000202C                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:0000202C
.text$mn:0000202C var_4           = dword ptr -4
.text$mn:0000202C
.text$mn:0000202C                 push    ebp
.text$mn:0000202D                 mov     ebp, esp
.text$mn:0000202F                 push    ecx
.text$mn:00002030                 mov     [ebp+var_4], ecx
.text$mn:00002033                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002036                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000203B                 mov     esp, ebp
.text$mn:0000203D                 pop     ebp
.text$mn:0000203E                 retn
.text$mn:0000203E ??1_Container_base12@std@@QAE@XZ endp
.text$mn:0000203E
.text$mn:0000203E ; ---------------------------------------------------------------------------
.text$mn:0000203F                 align 10h
.text$mn:0000203F _text$mn        ends
.text$mn:0000203F
.text$mn:00002040 ; ===========================================================================
.text$mn:00002040
.text$mn:00002040 ; Segment type: Pure code
.text$mn:00002040 ; Segment permissions: Read/Execute
.text$mn:00002040 _text$mn        segment para public 'CODE' use32
.text$mn:00002040                 assume cs:_text$mn
.text$mn:00002040                 ;org 2040h
.text$mn:00002040 ; COMDAT (pick any)
.text$mn:00002040                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002040
.text$mn:00002040 ; =============== S U B R O U T I N E =======================================
.text$mn:00002040
.text$mn:00002040 ; Attributes: bp-based frame
.text$mn:00002040
.text$mn:00002040 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00002040                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00002040 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00002040                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00002040                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00002040
.text$mn:00002040 var_10          = dword ptr -10h
.text$mn:00002040 var_C           = dword ptr -0Ch
.text$mn:00002040 var_4           = dword ptr -4
.text$mn:00002040
.text$mn:00002040                 push    ebp
.text$mn:00002041                 mov     ebp, esp
.text$mn:00002043                 push    0FFFFFFFFh
.text$mn:00002045                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000204A                 mov     eax, large fs:0
.text$mn:00002050                 push    eax
.text$mn:00002051                 push    ecx
.text$mn:00002052                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002057                 xor     eax, ebp
.text$mn:00002059                 push    eax
.text$mn:0000205A                 lea     eax, [ebp+var_C]
.text$mn:0000205D                 mov     large fs:0, eax
.text$mn:00002063                 mov     [ebp+var_10], ecx
.text$mn:00002066                 mov     [ebp+var_4], 0
.text$mn:0000206D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002074                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002077                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000207C                 mov     ecx, [ebp+var_C]
.text$mn:0000207F                 mov     large fs:0, ecx
.text$mn:00002086                 pop     ecx
.text$mn:00002087                 mov     esp, ebp
.text$mn:00002089                 pop     ebp
.text$mn:0000208A                 retn
.text$mn:0000208A ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:0000208A
.text$mn:0000208A ; ---------------------------------------------------------------------------
.text$mn:0000208B                 align 4
.text$mn:0000208B _text$mn        ends
.text$mn:0000208B
.text$x:0000208C ; ===========================================================================
.text$x:0000208C
.text$x:0000208C ; Segment type: Pure code
.text$x:0000208C ; Segment permissions: Read/Execute
.text$x:0000208C _text$x         segment para public 'CODE' use32
.text$x:0000208C                 assume cs:_text$x
.text$x:0000208C                 ;org 208Ch
.text$x:0000208C ; COMDAT (pick associative to section at 2040)
.text$x:0000208C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000208C
.text$x:0000208C ; =============== S U B R O U T I N E =======================================
.text$x:0000208C
.text$x:0000208C
.text$x:0000208C __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:0000208C                                         ; DATA XREF: .xdata$x:00003868o
.text$x:0000208C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000208F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000208F __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:0000208F
.text$x:00002094
.text$x:00002094 ; =============== S U B R O U T I N E =======================================
.text$x:00002094
.text$x:00002094
.text$x:00002094 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00002094                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00002094
.text$x:00002094 arg_4           = dword ptr  8
.text$x:00002094
.text$x:00002094                 mov     edx, [esp+arg_4]
.text$x:00002098                 lea     eax, [edx+0Ch]
.text$x:0000209B                 mov     ecx, [edx-8]
.text$x:0000209E                 xor     ecx, eax
.text$x:000020A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000020A5                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:000020AA                 jmp     ___CxxFrameHandler3
.text$x:000020AA __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:000020AA
.text$x:000020AA ; ---------------------------------------------------------------------------
.text$x:000020AF                 align 10h
.text$x:000020AF _text$x         ends
.text$x:000020AF
.text$mn:000020B0 ; ===========================================================================
.text$mn:000020B0
.text$mn:000020B0 ; Segment type: Pure code
.text$mn:000020B0 ; Segment permissions: Read/Execute
.text$mn:000020B0 _text$mn        segment para public 'CODE' use32
.text$mn:000020B0                 assume cs:_text$mn
.text$mn:000020B0                 ;org 20B0h
.text$mn:000020B0 ; COMDAT (pick any)
.text$mn:000020B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020B0
.text$mn:000020B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000020B0
.text$mn:000020B0 ; Attributes: bp-based frame
.text$mn:000020B0
.text$mn:000020B0 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000020B0                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000020B0 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:000020B0                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000020B0                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000020B0
.text$mn:000020B0 var_10          = dword ptr -10h
.text$mn:000020B0 var_C           = dword ptr -0Ch
.text$mn:000020B0 var_4           = dword ptr -4
.text$mn:000020B0
.text$mn:000020B0                 push    ebp
.text$mn:000020B1                 mov     ebp, esp
.text$mn:000020B3                 push    0FFFFFFFFh
.text$mn:000020B5                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000020BA                 mov     eax, large fs:0
.text$mn:000020C0                 push    eax
.text$mn:000020C1                 push    ecx
.text$mn:000020C2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000020C7                 xor     eax, ebp
.text$mn:000020C9                 push    eax
.text$mn:000020CA                 lea     eax, [ebp+var_C]
.text$mn:000020CD                 mov     large fs:0, eax
.text$mn:000020D3                 mov     [ebp+var_10], ecx
.text$mn:000020D6                 mov     [ebp+var_4], 0
.text$mn:000020DD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000020E4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000020E7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000020EC                 mov     ecx, [ebp+var_C]
.text$mn:000020EF                 mov     large fs:0, ecx
.text$mn:000020F6                 pop     ecx
.text$mn:000020F7                 mov     esp, ebp
.text$mn:000020F9                 pop     ebp
.text$mn:000020FA                 retn
.text$mn:000020FA ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:000020FA
.text$mn:000020FA ; ---------------------------------------------------------------------------
.text$mn:000020FB                 align 4
.text$mn:000020FB _text$mn        ends
.text$mn:000020FB
.text$x:000020FC ; ===========================================================================
.text$x:000020FC
.text$x:000020FC ; Segment type: Pure code
.text$x:000020FC ; Segment permissions: Read/Execute
.text$x:000020FC _text$x         segment para public 'CODE' use32
.text$x:000020FC                 assume cs:_text$x
.text$x:000020FC                 ;org 20FCh
.text$x:000020FC ; COMDAT (pick associative to section at 20B0)
.text$x:000020FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000020FC
.text$x:000020FC ; =============== S U B R O U T I N E =======================================
.text$x:000020FC
.text$x:000020FC
.text$x:000020FC __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:000020FC                                         ; DATA XREF: .xdata$x:000038ECo
.text$x:000020FC                 mov     ecx, [ebp-10h]  ; this
.text$x:000020FF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000020FF __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:000020FF
.text$x:00002104
.text$x:00002104 ; =============== S U B R O U T I N E =======================================
.text$x:00002104
.text$x:00002104
.text$x:00002104 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00002104                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00002104
.text$x:00002104 arg_4           = dword ptr  8
.text$x:00002104
.text$x:00002104                 mov     edx, [esp+arg_4]
.text$x:00002108                 lea     eax, [edx+0Ch]
.text$x:0000210B                 mov     ecx, [edx-8]
.text$x:0000210E                 xor     ecx, eax
.text$x:00002110                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002115                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:0000211A                 jmp     ___CxxFrameHandler3
.text$x:0000211A __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:0000211A
.text$x:0000211A ; ---------------------------------------------------------------------------
.text$x:0000211F                 align 10h
.text$x:0000211F _text$x         ends
.text$x:0000211F
.text$mn:00002120 ; ===========================================================================
.text$mn:00002120
.text$mn:00002120 ; Segment type: Pure code
.text$mn:00002120 ; Segment permissions: Read/Execute
.text$mn:00002120 _text$mn        segment para public 'CODE' use32
.text$mn:00002120                 assume cs:_text$mn
.text$mn:00002120                 ;org 2120h
.text$mn:00002120 ; COMDAT (pick any)
.text$mn:00002120                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002120
.text$mn:00002120 ; =============== S U B R O U T I N E =======================================
.text$mn:00002120
.text$mn:00002120 ; Attributes: bp-based frame
.text$mn:00002120
.text$mn:00002120 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00002120                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00002120 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00002120                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00002120                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00002120
.text$mn:00002120 var_10          = dword ptr -10h
.text$mn:00002120 var_C           = dword ptr -0Ch
.text$mn:00002120 var_4           = dword ptr -4
.text$mn:00002120
.text$mn:00002120                 push    ebp
.text$mn:00002121                 mov     ebp, esp
.text$mn:00002123                 push    0FFFFFFFFh
.text$mn:00002125                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:0000212A                 mov     eax, large fs:0
.text$mn:00002130                 push    eax
.text$mn:00002131                 push    ecx
.text$mn:00002132                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002137                 xor     eax, ebp
.text$mn:00002139                 push    eax
.text$mn:0000213A                 lea     eax, [ebp+var_C]
.text$mn:0000213D                 mov     large fs:0, eax
.text$mn:00002143                 mov     [ebp+var_10], ecx
.text$mn:00002146                 mov     [ebp+var_4], 0
.text$mn:0000214D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002154                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002157                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000215C                 mov     ecx, [ebp+var_C]
.text$mn:0000215F                 mov     large fs:0, ecx
.text$mn:00002166                 pop     ecx
.text$mn:00002167                 mov     esp, ebp
.text$mn:00002169                 pop     ebp
.text$mn:0000216A                 retn
.text$mn:0000216A ??1_System_error_category@std@@UAE@XZ endp
.text$mn:0000216A
.text$mn:0000216A ; ---------------------------------------------------------------------------
.text$mn:0000216B                 align 4
.text$mn:0000216B _text$mn        ends
.text$mn:0000216B
.text$x:0000216C ; ===========================================================================
.text$x:0000216C
.text$x:0000216C ; Segment type: Pure code
.text$x:0000216C ; Segment permissions: Read/Execute
.text$x:0000216C _text$x         segment para public 'CODE' use32
.text$x:0000216C                 assume cs:_text$x
.text$x:0000216C                 ;org 216Ch
.text$x:0000216C ; COMDAT (pick associative to section at 2120)
.text$x:0000216C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000216C
.text$x:0000216C ; =============== S U B R O U T I N E =======================================
.text$x:0000216C
.text$x:0000216C
.text$x:0000216C __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:0000216C                                         ; DATA XREF: .xdata$x:00003970o
.text$x:0000216C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000216F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000216F __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000216F
.text$x:00002174
.text$x:00002174 ; =============== S U B R O U T I N E =======================================
.text$x:00002174
.text$x:00002174
.text$x:00002174 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00002174                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00002174
.text$x:00002174 arg_4           = dword ptr  8
.text$x:00002174
.text$x:00002174                 mov     edx, [esp+arg_4]
.text$x:00002178                 lea     eax, [edx+0Ch]
.text$x:0000217B                 mov     ecx, [edx-8]
.text$x:0000217E                 xor     ecx, eax
.text$x:00002180                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002185                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:0000218A                 jmp     ___CxxFrameHandler3
.text$x:0000218A __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:0000218A
.text$x:0000218A ; ---------------------------------------------------------------------------
.text$x:0000218F                 align 10h
.text$x:0000218F _text$x         ends
.text$x:0000218F
.text$mn:00002190 ; ===========================================================================
.text$mn:00002190
.text$mn:00002190 ; Segment type: Pure code
.text$mn:00002190 ; Segment permissions: Read/Execute
.text$mn:00002190 _text$mn        segment para public 'CODE' use32
.text$mn:00002190                 assume cs:_text$mn
.text$mn:00002190                 ;org 2190h
.text$mn:00002190 ; COMDAT (pick any)
.text$mn:00002190                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002190
.text$mn:00002190 ; =============== S U B R O U T I N E =======================================
.text$mn:00002190
.text$mn:00002190 ; Attributes: bp-based frame
.text$mn:00002190
.text$mn:00002190 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00002190                 public ??1error_category@std@@UAE@XZ
.text$mn:00002190 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00002190                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00002190
.text$mn:00002190 var_4           = dword ptr -4
.text$mn:00002190
.text$mn:00002190                 push    ebp
.text$mn:00002191                 mov     ebp, esp
.text$mn:00002193                 push    ecx
.text$mn:00002194                 mov     [ebp+var_4], ecx
.text$mn:00002197                 mov     eax, [ebp+var_4]
.text$mn:0000219A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000021A0                 mov     esp, ebp
.text$mn:000021A2                 pop     ebp
.text$mn:000021A3                 retn
.text$mn:000021A3 ??1error_category@std@@UAE@XZ endp
.text$mn:000021A3
.text$mn:000021A3 _text$mn        ends
.text$mn:000021A3
.text$mn:000021A4 ; ===========================================================================
.text$mn:000021A4
.text$mn:000021A4 ; Segment type: Pure code
.text$mn:000021A4 ; Segment permissions: Read/Execute
.text$mn:000021A4 _text$mn        segment para public 'CODE' use32
.text$mn:000021A4                 assume cs:_text$mn
.text$mn:000021A4                 ;org 21A4h
.text$mn:000021A4 ; COMDAT (pick any)
.text$mn:000021A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021A4
.text$mn:000021A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000021A4
.text$mn:000021A4 ; Attributes: bp-based frame
.text$mn:000021A4
.text$mn:000021A4 ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:000021A4                 public ??1runtime_error@std@@UAE@XZ
.text$mn:000021A4 ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+Ap
.text$mn:000021A4                                         ; DATA XREF: .xdata$x:00003A58o
.text$mn:000021A4
.text$mn:000021A4 var_10          = dword ptr -10h
.text$mn:000021A4 var_C           = dword ptr -0Ch
.text$mn:000021A4 var_4           = dword ptr -4
.text$mn:000021A4
.text$mn:000021A4                 push    ebp
.text$mn:000021A5                 mov     ebp, esp
.text$mn:000021A7                 push    0FFFFFFFFh
.text$mn:000021A9                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:000021AE                 mov     eax, large fs:0
.text$mn:000021B4                 push    eax
.text$mn:000021B5                 push    ecx
.text$mn:000021B6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000021BB                 xor     eax, ebp
.text$mn:000021BD                 push    eax
.text$mn:000021BE                 lea     eax, [ebp+var_C]
.text$mn:000021C1                 mov     large fs:0, eax
.text$mn:000021C7                 mov     [ebp+var_10], ecx
.text$mn:000021CA                 mov     [ebp+var_4], 0
.text$mn:000021D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000021D8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000021DB                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:000021E0                 mov     ecx, [ebp+var_C]
.text$mn:000021E3                 mov     large fs:0, ecx
.text$mn:000021EA                 pop     ecx
.text$mn:000021EB                 mov     esp, ebp
.text$mn:000021ED                 pop     ebp
.text$mn:000021EE                 retn
.text$mn:000021EE ??1runtime_error@std@@UAE@XZ endp
.text$mn:000021EE
.text$mn:000021EE ; ---------------------------------------------------------------------------
.text$mn:000021EF                 align 10h
.text$mn:000021EF _text$mn        ends
.text$mn:000021EF
.text$x:000021F0 ; ===========================================================================
.text$x:000021F0
.text$x:000021F0 ; Segment type: Pure code
.text$x:000021F0 ; Segment permissions: Read/Execute
.text$x:000021F0 _text$x         segment para public 'CODE' use32
.text$x:000021F0                 assume cs:_text$x
.text$x:000021F0                 ;org 21F0h
.text$x:000021F0 ; COMDAT (pick associative to section at 21A4)
.text$x:000021F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000021F0
.text$x:000021F0 ; =============== S U B R O U T I N E =======================================
.text$x:000021F0
.text$x:000021F0
.text$x:000021F0 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:000021F0                                         ; DATA XREF: .xdata$x:000037B8o
.text$x:000021F0                 mov     ecx, [ebp-10h]  ; this
.text$x:000021F3                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:000021F3 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:000021F3
.text$x:000021F8
.text$x:000021F8 ; =============== S U B R O U T I N E =======================================
.text$x:000021F8
.text$x:000021F8
.text$x:000021F8 __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:000021F8                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:000021F8
.text$x:000021F8 arg_4           = dword ptr  8
.text$x:000021F8
.text$x:000021F8                 mov     edx, [esp+arg_4]
.text$x:000021FC                 lea     eax, [edx+0Ch]
.text$x:000021FF                 mov     ecx, [edx-8]
.text$x:00002202                 xor     ecx, eax
.text$x:00002204                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002209                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:0000220E                 jmp     ___CxxFrameHandler3
.text$x:0000220E __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:0000220E
.text$x:0000220E ; ---------------------------------------------------------------------------
.text$x:00002213                 align 4
.text$x:00002213 _text$x         ends
.text$x:00002213
.text$mn:00002214 ; ===========================================================================
.text$mn:00002214
.text$mn:00002214 ; Segment type: Pure code
.text$mn:00002214 ; Segment permissions: Read/Execute
.text$mn:00002214 _text$mn        segment para public 'CODE' use32
.text$mn:00002214                 assume cs:_text$mn
.text$mn:00002214                 ;org 2214h
.text$mn:00002214 ; COMDAT (pick any)
.text$mn:00002214                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002214
.text$mn:00002214 ; =============== S U B R O U T I N E =======================================
.text$mn:00002214
.text$mn:00002214 ; Attributes: bp-based frame
.text$mn:00002214
.text$mn:00002214 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00002214                 public ??2@YAPAXIPAX@Z
.text$mn:00002214 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00002214                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00002214
.text$mn:00002214 arg_4           = dword ptr  0Ch
.text$mn:00002214
.text$mn:00002214                 push    ebp
.text$mn:00002215                 mov     ebp, esp
.text$mn:00002217                 mov     eax, [ebp+arg_4]
.text$mn:0000221A                 pop     ebp
.text$mn:0000221B                 retn
.text$mn:0000221B ??2@YAPAXIPAX@Z endp
.text$mn:0000221B
.text$mn:0000221B _text$mn        ends
.text$mn:0000221B
.text$mn:0000221C ; ===========================================================================
.text$mn:0000221C
.text$mn:0000221C ; Segment type: Pure code
.text$mn:0000221C ; Segment permissions: Read/Execute
.text$mn:0000221C _text$mn        segment para public 'CODE' use32
.text$mn:0000221C                 assume cs:_text$mn
.text$mn:0000221C                 ;org 221Ch
.text$mn:0000221C ; COMDAT (pick any)
.text$mn:0000221C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000221C
.text$mn:0000221C ; =============== S U B R O U T I N E =======================================
.text$mn:0000221C
.text$mn:0000221C ; Attributes: bp-based frame
.text$mn:0000221C
.text$mn:0000221C ; void __cdecl operator delete(void *)
.text$mn:0000221C                 public ??3@YAXPAX0@Z
.text$mn:0000221C ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:0000221C                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:0000221C                 push    ebp
.text$mn:0000221D                 mov     ebp, esp
.text$mn:0000221F                 pop     ebp
.text$mn:00002220                 retn
.text$mn:00002220 ??3@YAXPAX0@Z   endp
.text$mn:00002220
.text$mn:00002220 ; ---------------------------------------------------------------------------
.text$mn:00002221                 align 4
.text$mn:00002221 _text$mn        ends
.text$mn:00002221
.text$mn:00002224 ; ===========================================================================
.text$mn:00002224
.text$mn:00002224 ; Segment type: Pure code
.text$mn:00002224 ; Segment permissions: Read/Execute
.text$mn:00002224 _text$mn        segment para public 'CODE' use32
.text$mn:00002224                 assume cs:_text$mn
.text$mn:00002224                 ;org 2224h
.text$mn:00002224 ; COMDAT (pick any)
.text$mn:00002224                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002224
.text$mn:00002224 ; =============== S U B R O U T I N E =======================================
.text$mn:00002224
.text$mn:00002224 ; Attributes: bp-based frame
.text$mn:00002224
.text$mn:00002224 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00002224                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00002224 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00002224                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00002224                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00002224
.text$mn:00002224 var_8           = dword ptr -8
.text$mn:00002224 var_4           = dword ptr -4
.text$mn:00002224 arg_0           = dword ptr  8
.text$mn:00002224
.text$mn:00002224                 push    ebp
.text$mn:00002225                 mov     ebp, esp
.text$mn:00002227                 sub     esp, 8
.text$mn:0000222A                 mov     [ebp+var_8], ecx
.text$mn:0000222D                 mov     eax, [ebp+var_8]
.text$mn:00002230                 cmp     eax, [ebp+arg_0]
.text$mn:00002233                 jnz     short loc_223E
.text$mn:00002235                 mov     [ebp+var_4], 1
.text$mn:0000223C                 jmp     short loc_2245
.text$mn:0000223E ; ---------------------------------------------------------------------------
.text$mn:0000223E
.text$mn:0000223E loc_223E:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:0000223E                 mov     [ebp+var_4], 0
.text$mn:00002245
.text$mn:00002245 loc_2245:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00002245                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002248                 mov     esp, ebp
.text$mn:0000224A                 pop     ebp
.text$mn:0000224B                 retn    4
.text$mn:0000224B ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:0000224B
.text$mn:0000224B ; ---------------------------------------------------------------------------
.text$mn:0000224E                 align 10h
.text$mn:0000224E _text$mn        ends
.text$mn:0000224E
.text$mn:00002250 ; ===========================================================================
.text$mn:00002250
.text$mn:00002250 ; Segment type: Pure code
.text$mn:00002250 ; Segment permissions: Read/Execute
.text$mn:00002250 _text$mn        segment para public 'CODE' use32
.text$mn:00002250                 assume cs:_text$mn
.text$mn:00002250                 ;org 2250h
.text$mn:00002250 ; COMDAT (pick any)
.text$mn:00002250                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002250
.text$mn:00002250 ; =============== S U B R O U T I N E =======================================
.text$mn:00002250
.text$mn:00002250 ; Attributes: bp-based frame
.text$mn:00002250
.text$mn:00002250 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00002250                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00002250 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00002250                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00002250
.text$mn:00002250 var_8           = dword ptr -8
.text$mn:00002250 var_4           = dword ptr -4
.text$mn:00002250 arg_0           = dword ptr  8
.text$mn:00002250
.text$mn:00002250                 push    ebp
.text$mn:00002251                 mov     ebp, esp
.text$mn:00002253                 sub     esp, 8
.text$mn:00002256                 push    esi
.text$mn:00002257                 mov     [ebp+var_4], ecx
.text$mn:0000225A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000225D                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00002262                 push    eax
.text$mn:00002263                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002266                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000226B                 mov     ecx, eax
.text$mn:0000226D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00002272                 movzx   eax, al
.text$mn:00002275                 test    eax, eax
.text$mn:00002277                 jz      short loc_2298
.text$mn:00002279                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000227C                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00002281                 mov     esi, eax
.text$mn:00002283                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002286                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:0000228B                 cmp     esi, eax
.text$mn:0000228D                 jnz     short loc_2298
.text$mn:0000228F                 mov     [ebp+var_8], 1
.text$mn:00002296                 jmp     short loc_229F
.text$mn:00002298 ; ---------------------------------------------------------------------------
.text$mn:00002298
.text$mn:00002298 loc_2298:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00002298                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00002298                 mov     [ebp+var_8], 0
.text$mn:0000229F
.text$mn:0000229F loc_229F:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:0000229F                 mov     al, byte ptr [ebp+var_8]
.text$mn:000022A2                 pop     esi
.text$mn:000022A3                 mov     esp, ebp
.text$mn:000022A5                 pop     ebp
.text$mn:000022A6                 retn    4
.text$mn:000022A6 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:000022A6
.text$mn:000022A6 ; ---------------------------------------------------------------------------
.text$mn:000022A9                 align 4
.text$mn:000022A9 _text$mn        ends
.text$mn:000022A9
.text$mn:000022AC ; ===========================================================================
.text$mn:000022AC
.text$mn:000022AC ; Segment type: Pure code
.text$mn:000022AC ; Segment permissions: Read/Execute
.text$mn:000022AC _text$mn        segment para public 'CODE' use32
.text$mn:000022AC                 assume cs:_text$mn
.text$mn:000022AC                 ;org 22ACh
.text$mn:000022AC ; COMDAT (pick any)
.text$mn:000022AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022AC
.text$mn:000022AC ; =============== S U B R O U T I N E =======================================
.text$mn:000022AC
.text$mn:000022AC ; Attributes: bp-based frame
.text$mn:000022AC
.text$mn:000022AC ; public: virtual void * __thiscall Splitter::`scalar deleting destructor'(unsigned int)
.text$mn:000022AC                 public ??_GSplitter@@UAEPAXI@Z
.text$mn:000022AC ??_GSplitter@@UAEPAXI@Z proc near
.text$mn:000022AC
.text$mn:000022AC var_4           = dword ptr -4
.text$mn:000022AC arg_0           = dword ptr  8
.text$mn:000022AC
.text$mn:000022AC                 push    ebp
.text$mn:000022AD                 mov     ebp, esp
.text$mn:000022AF                 push    ecx
.text$mn:000022B0                 mov     [ebp+var_4], ecx
.text$mn:000022B3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000022B6                 call    ??1Splitter@@UAE@XZ ; Splitter::~Splitter(void)
.text$mn:000022BB                 mov     eax, [ebp+arg_0]
.text$mn:000022BE                 and     eax, 1
.text$mn:000022C1                 jz      short loc_22CF
.text$mn:000022C3                 mov     ecx, [ebp+var_4]
.text$mn:000022C6                 push    ecx             ; void *
.text$mn:000022C7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000022CC                 add     esp, 4
.text$mn:000022CF
.text$mn:000022CF loc_22CF:                               ; CODE XREF: Splitter::`scalar deleting destructor'(uint)+15j
.text$mn:000022CF                 mov     eax, [ebp+var_4]
.text$mn:000022D2                 mov     esp, ebp
.text$mn:000022D4                 pop     ebp
.text$mn:000022D5                 retn    4
.text$mn:000022D5 ??_GSplitter@@UAEPAXI@Z endp
.text$mn:000022D5
.text$mn:000022D5 _text$mn        ends
.text$mn:000022D5
.text$mn:000022D8 ; ===========================================================================
.text$mn:000022D8
.text$mn:000022D8 ; Segment type: Pure code
.text$mn:000022D8 ; Segment permissions: Read/Execute
.text$mn:000022D8 _text$mn        segment para public 'CODE' use32
.text$mn:000022D8                 assume cs:_text$mn
.text$mn:000022D8                 ;org 22D8h
.text$mn:000022D8 ; COMDAT (pick any)
.text$mn:000022D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022D8
.text$mn:000022D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000022D8
.text$mn:000022D8 ; Attributes: bp-based frame
.text$mn:000022D8
.text$mn:000022D8 ; public: virtual void * __thiscall Window::`scalar deleting destructor'(unsigned int)
.text$mn:000022D8                 public ??_GWindow@@UAEPAXI@Z
.text$mn:000022D8 ??_GWindow@@UAEPAXI@Z proc near
.text$mn:000022D8
.text$mn:000022D8 var_4           = dword ptr -4
.text$mn:000022D8 arg_0           = dword ptr  8
.text$mn:000022D8
.text$mn:000022D8                 push    ebp
.text$mn:000022D9                 mov     ebp, esp
.text$mn:000022DB                 push    ecx
.text$mn:000022DC                 mov     [ebp+var_4], ecx
.text$mn:000022DF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000022E2                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:000022E7                 mov     eax, [ebp+arg_0]
.text$mn:000022EA                 and     eax, 1
.text$mn:000022ED                 jz      short loc_22FB
.text$mn:000022EF                 mov     ecx, [ebp+var_4]
.text$mn:000022F2                 push    ecx             ; void *
.text$mn:000022F3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000022F8                 add     esp, 4
.text$mn:000022FB
.text$mn:000022FB loc_22FB:                               ; CODE XREF: Window::`scalar deleting destructor'(uint)+15j
.text$mn:000022FB                 mov     eax, [ebp+var_4]
.text$mn:000022FE                 mov     esp, ebp
.text$mn:00002300                 pop     ebp
.text$mn:00002301                 retn    4
.text$mn:00002301 ??_GWindow@@UAEPAXI@Z endp
.text$mn:00002301
.text$mn:00002301 _text$mn        ends
.text$mn:00002301
.text$mn:00002304 ; ===========================================================================
.text$mn:00002304
.text$mn:00002304 ; Segment type: Pure code
.text$mn:00002304 ; Segment permissions: Read/Execute
.text$mn:00002304 _text$mn        segment para public 'CODE' use32
.text$mn:00002304                 assume cs:_text$mn
.text$mn:00002304                 ;org 2304h
.text$mn:00002304 ; COMDAT (pick any)
.text$mn:00002304                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002304
.text$mn:00002304 ; =============== S U B R O U T I N E =======================================
.text$mn:00002304
.text$mn:00002304 ; Attributes: bp-based frame
.text$mn:00002304
.text$mn:00002304 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00002304                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00002304 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00002304
.text$mn:00002304 var_4           = dword ptr -4
.text$mn:00002304 arg_0           = dword ptr  8
.text$mn:00002304
.text$mn:00002304                 push    ebp
.text$mn:00002305                 mov     ebp, esp
.text$mn:00002307                 push    ecx
.text$mn:00002308                 mov     [ebp+var_4], ecx
.text$mn:0000230B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000230E                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00002313                 mov     eax, [ebp+arg_0]
.text$mn:00002316                 and     eax, 1
.text$mn:00002319                 jz      short loc_2327
.text$mn:0000231B                 mov     ecx, [ebp+var_4]
.text$mn:0000231E                 push    ecx             ; void *
.text$mn:0000231F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002324                 add     esp, 4
.text$mn:00002327
.text$mn:00002327 loc_2327:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00002327                 mov     eax, [ebp+var_4]
.text$mn:0000232A                 mov     esp, ebp
.text$mn:0000232C                 pop     ebp
.text$mn:0000232D                 retn    4
.text$mn:0000232D ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:0000232D
.text$mn:0000232D _text$mn        ends
.text$mn:0000232D
.text$mn:00002330 ; ===========================================================================
.text$mn:00002330
.text$mn:00002330 ; Segment type: Pure code
.text$mn:00002330 ; Segment permissions: Read/Execute
.text$mn:00002330 _text$mn        segment para public 'CODE' use32
.text$mn:00002330                 assume cs:_text$mn
.text$mn:00002330                 ;org 2330h
.text$mn:00002330 ; COMDAT (pick any)
.text$mn:00002330                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002330
.text$mn:00002330 ; =============== S U B R O U T I N E =======================================
.text$mn:00002330
.text$mn:00002330 ; Attributes: bp-based frame
.text$mn:00002330
.text$mn:00002330 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00002330                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00002330 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00002330
.text$mn:00002330 var_4           = dword ptr -4
.text$mn:00002330 arg_0           = dword ptr  8
.text$mn:00002330
.text$mn:00002330                 push    ebp
.text$mn:00002331                 mov     ebp, esp
.text$mn:00002333                 push    ecx
.text$mn:00002334                 mov     [ebp+var_4], ecx
.text$mn:00002337                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000233A                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:0000233F                 mov     eax, [ebp+arg_0]
.text$mn:00002342                 and     eax, 1
.text$mn:00002345                 jz      short loc_2353
.text$mn:00002347                 mov     ecx, [ebp+var_4]
.text$mn:0000234A                 push    ecx             ; void *
.text$mn:0000234B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002350                 add     esp, 4
.text$mn:00002353
.text$mn:00002353 loc_2353:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00002353                 mov     eax, [ebp+var_4]
.text$mn:00002356                 mov     esp, ebp
.text$mn:00002358                 pop     ebp
.text$mn:00002359                 retn    4
.text$mn:00002359 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00002359
.text$mn:00002359 _text$mn        ends
.text$mn:00002359
.text$mn:0000235C ; ===========================================================================
.text$mn:0000235C
.text$mn:0000235C ; Segment type: Pure code
.text$mn:0000235C ; Segment permissions: Read/Execute
.text$mn:0000235C _text$mn        segment para public 'CODE' use32
.text$mn:0000235C                 assume cs:_text$mn
.text$mn:0000235C                 ;org 235Ch
.text$mn:0000235C ; COMDAT (pick any)
.text$mn:0000235C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000235C
.text$mn:0000235C ; =============== S U B R O U T I N E =======================================
.text$mn:0000235C
.text$mn:0000235C ; Attributes: bp-based frame
.text$mn:0000235C
.text$mn:0000235C ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000235C                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:0000235C ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000235C
.text$mn:0000235C var_4           = dword ptr -4
.text$mn:0000235C arg_0           = dword ptr  8
.text$mn:0000235C
.text$mn:0000235C                 push    ebp
.text$mn:0000235D                 mov     ebp, esp
.text$mn:0000235F                 push    ecx
.text$mn:00002360                 mov     [ebp+var_4], ecx
.text$mn:00002363                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002366                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:0000236B                 mov     eax, [ebp+arg_0]
.text$mn:0000236E                 and     eax, 1
.text$mn:00002371                 jz      short loc_237F
.text$mn:00002373                 mov     ecx, [ebp+var_4]
.text$mn:00002376                 push    ecx             ; void *
.text$mn:00002377                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000237C                 add     esp, 4
.text$mn:0000237F
.text$mn:0000237F loc_237F:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000237F                 mov     eax, [ebp+var_4]
.text$mn:00002382                 mov     esp, ebp
.text$mn:00002384                 pop     ebp
.text$mn:00002385                 retn    4
.text$mn:00002385 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00002385
.text$mn:00002385 _text$mn        ends
.text$mn:00002385
.text$mn:00002388 ; ===========================================================================
.text$mn:00002388
.text$mn:00002388 ; Segment type: Pure code
.text$mn:00002388 ; Segment permissions: Read/Execute
.text$mn:00002388 _text$mn        segment para public 'CODE' use32
.text$mn:00002388                 assume cs:_text$mn
.text$mn:00002388                 ;org 2388h
.text$mn:00002388 ; COMDAT (pick any)
.text$mn:00002388                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002388
.text$mn:00002388 ; =============== S U B R O U T I N E =======================================
.text$mn:00002388
.text$mn:00002388 ; Attributes: bp-based frame
.text$mn:00002388
.text$mn:00002388 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00002388                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00002388 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00002388
.text$mn:00002388 var_4           = dword ptr -4
.text$mn:00002388 arg_0           = dword ptr  8
.text$mn:00002388
.text$mn:00002388                 push    ebp
.text$mn:00002389                 mov     ebp, esp
.text$mn:0000238B                 push    ecx
.text$mn:0000238C                 mov     [ebp+var_4], ecx
.text$mn:0000238F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00002392                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00002397                 mov     eax, [ebp+arg_0]
.text$mn:0000239A                 and     eax, 1
.text$mn:0000239D                 jz      short loc_23AB
.text$mn:0000239F                 mov     ecx, [ebp+var_4]
.text$mn:000023A2                 push    ecx             ; void *
.text$mn:000023A3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000023A8                 add     esp, 4
.text$mn:000023AB
.text$mn:000023AB loc_23AB:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000023AB                 mov     eax, [ebp+var_4]
.text$mn:000023AE                 mov     esp, ebp
.text$mn:000023B0                 pop     ebp
.text$mn:000023B1                 retn    4
.text$mn:000023B1 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:000023B1
.text$mn:000023B1 _text$mn        ends
.text$mn:000023B1
.text$mn:000023B4 ; ===========================================================================
.text$mn:000023B4
.text$mn:000023B4 ; Segment type: Pure code
.text$mn:000023B4 ; Segment permissions: Read/Execute
.text$mn:000023B4 _text$mn        segment para public 'CODE' use32
.text$mn:000023B4                 assume cs:_text$mn
.text$mn:000023B4                 ;org 23B4h
.text$mn:000023B4 ; COMDAT (pick any)
.text$mn:000023B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023B4
.text$mn:000023B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023B4
.text$mn:000023B4 ; Attributes: bp-based frame
.text$mn:000023B4
.text$mn:000023B4 ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:000023B4                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:000023B4 ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:000023B4
.text$mn:000023B4 var_4           = dword ptr -4
.text$mn:000023B4 arg_0           = dword ptr  8
.text$mn:000023B4
.text$mn:000023B4                 push    ebp
.text$mn:000023B5                 mov     ebp, esp
.text$mn:000023B7                 push    ecx
.text$mn:000023B8                 mov     [ebp+var_4], ecx
.text$mn:000023BB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000023BE                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:000023C3                 mov     eax, [ebp+arg_0]
.text$mn:000023C6                 and     eax, 1
.text$mn:000023C9                 jz      short loc_23D7
.text$mn:000023CB                 mov     ecx, [ebp+var_4]
.text$mn:000023CE                 push    ecx             ; void *
.text$mn:000023CF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000023D4                 add     esp, 4
.text$mn:000023D7
.text$mn:000023D7 loc_23D7:                               ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:000023D7                 mov     eax, [ebp+var_4]
.text$mn:000023DA                 mov     esp, ebp
.text$mn:000023DC                 pop     ebp
.text$mn:000023DD                 retn    4
.text$mn:000023DD ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:000023DD
.text$mn:000023DD _text$mn        ends
.text$mn:000023DD
.text$di:000023E0 ; ===========================================================================
.text$di:000023E0
.text$di:000023E0 ; Segment type: Pure code
.text$di:000023E0 ; Segment permissions: Read/Execute
.text$di:000023E0 _text$di        segment para public 'CODE' use32
.text$di:000023E0                 assume cs:_text$di
.text$di:000023E0                 ;org 23E0h
.text$di:000023E0 ; COMDAT (pick any)
.text$di:000023E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000023E0
.text$di:000023E0 ; =============== S U B R O U T I N E =======================================
.text$di:000023E0
.text$di:000023E0 ; Attributes: bp-based frame
.text$di:000023E0
.text$di:000023E0 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:000023E0 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:000023E0                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:000023E0                 push    ebp
.text$di:000023E1                 mov     ebp, esp
.text$di:000023E3                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:000023E8                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:000023ED                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000023F2                 call    _atexit
.text$di:000023F7                 add     esp, 4
.text$di:000023FA                 pop     ebp
.text$di:000023FB                 retn
.text$di:000023FB ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:000023FB
.text$di:000023FB _text$di        ends
.text$di:000023FB
.text$di:000023FC ; ===========================================================================
.text$di:000023FC
.text$di:000023FC ; Segment type: Pure code
.text$di:000023FC ; Segment permissions: Read/Execute
.text$di:000023FC _text$di        segment para public 'CODE' use32
.text$di:000023FC                 assume cs:_text$di
.text$di:000023FC                 ;org 23FCh
.text$di:000023FC ; COMDAT (pick any)
.text$di:000023FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000023FC
.text$di:000023FC ; =============== S U B R O U T I N E =======================================
.text$di:000023FC
.text$di:000023FC ; Attributes: bp-based frame
.text$di:000023FC
.text$di:000023FC ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:000023FC ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:000023FC                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:000023FC                 push    ebp
.text$di:000023FD                 mov     ebp, esp
.text$di:000023FF                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00002404                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00002409                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000240E                 call    _atexit
.text$di:00002413                 add     esp, 4
.text$di:00002416                 pop     ebp
.text$di:00002417                 retn
.text$di:00002417 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00002417
.text$di:00002417 _text$di        ends
.text$di:00002417
.text$di:00002418 ; ===========================================================================
.text$di:00002418
.text$di:00002418 ; Segment type: Pure code
.text$di:00002418 ; Segment permissions: Read/Execute
.text$di:00002418 _text$di        segment para public 'CODE' use32
.text$di:00002418                 assume cs:_text$di
.text$di:00002418                 ;org 2418h
.text$di:00002418 ; COMDAT (pick any)
.text$di:00002418                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00002418
.text$di:00002418 ; =============== S U B R O U T I N E =======================================
.text$di:00002418
.text$di:00002418 ; Attributes: bp-based frame
.text$di:00002418
.text$di:00002418 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00002418 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00002418                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00002418                 push    ebp
.text$di:00002419                 mov     ebp, esp
.text$di:0000241B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00002420                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00002425                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000242A                 call    _atexit
.text$di:0000242F                 add     esp, 4
.text$di:00002432                 pop     ebp
.text$di:00002433                 retn
.text$di:00002433 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00002433
.text$di:00002433 _text$di        ends
.text$di:00002433
.text$di:00002434 ; ===========================================================================
.text$di:00002434
.text$di:00002434 ; Segment type: Pure code
.text$di:00002434 ; Segment permissions: Read/Execute
.text$di:00002434 _text$di        segment para public 'CODE' use32
.text$di:00002434                 assume cs:_text$di
.text$di:00002434                 ;org 2434h
.text$di:00002434 ; COMDAT (pick any)
.text$di:00002434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00002434
.text$di:00002434 ; =============== S U B R O U T I N E =======================================
.text$di:00002434
.text$di:00002434 ; Attributes: bp-based frame
.text$di:00002434
.text$di:00002434 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00002434 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00002434
.text$di:00002434 var_1           = byte ptr -1
.text$di:00002434
.text$di:00002434                 push    ebp
.text$di:00002435                 mov     ebp, esp
.text$di:00002437                 push    ecx
.text$di:00002438                 xor     eax, eax
.text$di:0000243A                 mov     [ebp+var_1], al
.text$di:0000243D                 mov     esp, ebp
.text$di:0000243F                 pop     ebp
.text$di:00002440                 retn
.text$di:00002440 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00002440
.text$di:00002440 ; ---------------------------------------------------------------------------
.text$di:00002441                 align 4
.text$di:00002441 _text$di        ends
.text$di:00002441
.text$di:00002444 ; ===========================================================================
.text$di:00002444
.text$di:00002444 ; Segment type: Pure code
.text$di:00002444 ; Segment permissions: Read/Execute
.text$di:00002444 _text$di        segment para public 'CODE' use32
.text$di:00002444                 assume cs:_text$di
.text$di:00002444                 ;org 2444h
.text$di:00002444 ; COMDAT (pick any)
.text$di:00002444                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00002444
.text$di:00002444 ; =============== S U B R O U T I N E =======================================
.text$di:00002444
.text$di:00002444 ; Attributes: bp-based frame
.text$di:00002444
.text$di:00002444 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00002444 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00002444                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00002444
.text$di:00002444 var_1           = byte ptr -1
.text$di:00002444
.text$di:00002444                 push    ebp
.text$di:00002445                 mov     ebp, esp
.text$di:00002447                 push    ecx
.text$di:00002448                 xor     eax, eax
.text$di:0000244A                 mov     [ebp+var_1], al
.text$di:0000244D                 mov     esp, ebp
.text$di:0000244F                 pop     ebp
.text$di:00002450                 retn
.text$di:00002450 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00002450
.text$di:00002450 ; ---------------------------------------------------------------------------
.text$di:00002451                 align 4
.text$di:00002451 _text$di        ends
.text$di:00002451
.text$yd:00002454 ; ===========================================================================
.text$yd:00002454
.text$yd:00002454 ; Segment type: Pure code
.text$yd:00002454 ; Segment permissions: Read/Execute
.text$yd:00002454 _text$yd        segment para public 'CODE' use32
.text$yd:00002454                 assume cs:_text$yd
.text$yd:00002454                 ;org 2454h
.text$yd:00002454 ; COMDAT (pick any)
.text$yd:00002454                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00002454
.text$yd:00002454 ; =============== S U B R O U T I N E =======================================
.text$yd:00002454
.text$yd:00002454 ; Attributes: bp-based frame
.text$yd:00002454
.text$yd:00002454 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00002454 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00002454                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00002454                 push    ebp
.text$yd:00002455                 mov     ebp, esp
.text$yd:00002457                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:0000245C                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00002461                 pop     ebp
.text$yd:00002462                 retn
.text$yd:00002462 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00002462
.text$yd:00002462 ; ---------------------------------------------------------------------------
.text$yd:00002463                 align 4
.text$yd:00002463 _text$yd        ends
.text$yd:00002463
.text$yd:00002464 ; ===========================================================================
.text$yd:00002464
.text$yd:00002464 ; Segment type: Pure code
.text$yd:00002464 ; Segment permissions: Read/Execute
.text$yd:00002464 _text$yd        segment para public 'CODE' use32
.text$yd:00002464                 assume cs:_text$yd
.text$yd:00002464                 ;org 2464h
.text$yd:00002464 ; COMDAT (pick any)
.text$yd:00002464                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00002464
.text$yd:00002464 ; =============== S U B R O U T I N E =======================================
.text$yd:00002464
.text$yd:00002464 ; Attributes: bp-based frame
.text$yd:00002464
.text$yd:00002464 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00002464 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00002464                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00002464                 push    ebp
.text$yd:00002465                 mov     ebp, esp
.text$yd:00002467                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:0000246C                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00002471                 pop     ebp
.text$yd:00002472                 retn
.text$yd:00002472 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00002472
.text$yd:00002472 ; ---------------------------------------------------------------------------
.text$yd:00002473                 align 4
.text$yd:00002473 _text$yd        ends
.text$yd:00002473
.text$yd:00002474 ; ===========================================================================
.text$yd:00002474
.text$yd:00002474 ; Segment type: Pure code
.text$yd:00002474 ; Segment permissions: Read/Execute
.text$yd:00002474 _text$yd        segment para public 'CODE' use32
.text$yd:00002474                 assume cs:_text$yd
.text$yd:00002474                 ;org 2474h
.text$yd:00002474 ; COMDAT (pick any)
.text$yd:00002474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00002474
.text$yd:00002474 ; =============== S U B R O U T I N E =======================================
.text$yd:00002474
.text$yd:00002474 ; Attributes: bp-based frame
.text$yd:00002474
.text$yd:00002474 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00002474 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00002474                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00002474                 push    ebp
.text$yd:00002475                 mov     ebp, esp
.text$yd:00002477                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:0000247C                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00002481                 pop     ebp
.text$yd:00002482                 retn
.text$yd:00002482 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00002482
.text$yd:00002482 ; ---------------------------------------------------------------------------
.text$yd:00002483                 align 4
.text$yd:00002483 _text$yd        ends
.text$yd:00002483
.text$mn:00002484 ; ===========================================================================
.text$mn:00002484
.text$mn:00002484 ; Segment type: Pure code
.text$mn:00002484 ; Segment permissions: Read/Execute
.text$mn:00002484 _text$mn        segment para public 'CODE' use32
.text$mn:00002484                 assume cs:_text$mn
.text$mn:00002484                 ;org 2484h
.text$mn:00002484 ; COMDAT (pick any)
.text$mn:00002484                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002484
.text$mn:00002484 ; =============== S U B R O U T I N E =======================================
.text$mn:00002484
.text$mn:00002484 ; Attributes: bp-based frame
.text$mn:00002484
.text$mn:00002484 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00002484                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00002484 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00002484                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00002484
.text$mn:00002484 var_10          = byte ptr -10h
.text$mn:00002484 var_8           = dword ptr -8
.text$mn:00002484 var_1           = byte ptr -1
.text$mn:00002484
.text$mn:00002484                 push    ebp
.text$mn:00002485                 mov     ebp, esp
.text$mn:00002487                 sub     esp, 10h
.text$mn:0000248A                 mov     [ebp+var_8], ecx
.text$mn:0000248D                 lea     ecx, [ebp+var_1]
.text$mn:00002490                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00002495                 push    1
.text$mn:00002497                 lea     ecx, [ebp+var_1]
.text$mn:0000249A                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:0000249F                 mov     ecx, [ebp+var_8]
.text$mn:000024A2                 mov     [ecx], eax
.text$mn:000024A4                 lea     ecx, [ebp+var_10] ; this
.text$mn:000024A7                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000024AC                 push    eax             ; int
.text$mn:000024AD                 mov     edx, [ebp+var_8]
.text$mn:000024B0                 mov     eax, [edx]
.text$mn:000024B2                 push    eax             ; void *
.text$mn:000024B3                 lea     ecx, [ebp+var_1]
.text$mn:000024B6                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000024BB                 mov     ecx, [ebp+var_8]
.text$mn:000024BE                 mov     edx, [ecx]
.text$mn:000024C0                 mov     eax, [ebp+var_8]
.text$mn:000024C3                 mov     [edx], eax
.text$mn:000024C5                 mov     esp, ebp
.text$mn:000024C7                 pop     ebp
.text$mn:000024C8                 retn
.text$mn:000024C8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000024C8
.text$mn:000024C8 ; ---------------------------------------------------------------------------
.text$mn:000024C9                 align 4
.text$mn:000024C9 _text$mn        ends
.text$mn:000024C9
.text$mn:000024CC ; ===========================================================================
.text$mn:000024CC
.text$mn:000024CC ; Segment type: Pure code
.text$mn:000024CC ; Segment permissions: Read/Execute
.text$mn:000024CC _text$mn        segment para public 'CODE' use32
.text$mn:000024CC                 assume cs:_text$mn
.text$mn:000024CC                 ;org 24CCh
.text$mn:000024CC ; COMDAT (pick any)
.text$mn:000024CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024CC
.text$mn:000024CC ; =============== S U B R O U T I N E =======================================
.text$mn:000024CC
.text$mn:000024CC ; Attributes: bp-based frame
.text$mn:000024CC
.text$mn:000024CC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:000024CC                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000024CC ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:000024CC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:000024CC
.text$mn:000024CC var_20          = dword ptr -20h
.text$mn:000024CC var_1C          = dword ptr -1Ch
.text$mn:000024CC var_18          = dword ptr -18h
.text$mn:000024CC var_11          = byte ptr -11h
.text$mn:000024CC var_10          = dword ptr -10h
.text$mn:000024CC var_C           = byte ptr -0Ch
.text$mn:000024CC var_4           = dword ptr -4
.text$mn:000024CC arg_0           = dword ptr  8
.text$mn:000024CC
.text$mn:000024CC ; FUNCTION CHUNK AT .text$mn:000025EE SIZE 00000009 BYTES
.text$mn:000024CC
.text$mn:000024CC                 push    ebp
.text$mn:000024CD                 mov     ebp, esp
.text$mn:000024CF                 push    0FFFFFFFFh
.text$mn:000024D1                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000024D6                 mov     eax, large fs:0
.text$mn:000024DC                 push    eax
.text$mn:000024DD                 push    ecx
.text$mn:000024DE                 sub     esp, 10h
.text$mn:000024E1                 push    ebx
.text$mn:000024E2                 push    esi
.text$mn:000024E3                 push    edi
.text$mn:000024E4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000024E9                 xor     eax, ebp
.text$mn:000024EB                 push    eax
.text$mn:000024EC                 lea     eax, [ebp+var_C]
.text$mn:000024EF                 mov     large fs:0, eax
.text$mn:000024F5                 mov     [ebp+var_10], esp
.text$mn:000024F8                 mov     [ebp+var_18], ecx
.text$mn:000024FB                 mov     eax, [ebp+arg_0]
.text$mn:000024FE                 or      eax, 0Fh
.text$mn:00002501                 mov     [ebp+var_1C], eax
.text$mn:00002504                 mov     ecx, [ebp+var_18]
.text$mn:00002507                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000250C                 cmp     eax, [ebp+var_1C]
.text$mn:0000250F                 jnb     short loc_2519
.text$mn:00002511                 mov     ecx, [ebp+arg_0]
.text$mn:00002514                 mov     [ebp+var_1C], ecx
.text$mn:00002517                 jmp     short loc_256B
.text$mn:00002519 ; ---------------------------------------------------------------------------
.text$mn:00002519
.text$mn:00002519 loc_2519:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00002519                 mov     edx, [ebp+var_18]
.text$mn:0000251C                 mov     ecx, [edx+18h]
.text$mn:0000251F                 shr     ecx, 1
.text$mn:00002521                 mov     eax, [ebp+var_1C]
.text$mn:00002524                 xor     edx, edx
.text$mn:00002526                 mov     esi, 3
.text$mn:0000252B                 div     esi
.text$mn:0000252D                 cmp     ecx, eax
.text$mn:0000252F                 ja      short loc_2533
.text$mn:00002531                 jmp     short loc_256B
.text$mn:00002533 ; ---------------------------------------------------------------------------
.text$mn:00002533
.text$mn:00002533 loc_2533:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00002533                 mov     ecx, [ebp+var_18]
.text$mn:00002536                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000253B                 mov     edx, [ebp+var_18]
.text$mn:0000253E                 mov     ecx, [edx+18h]
.text$mn:00002541                 shr     ecx, 1
.text$mn:00002543                 sub     eax, ecx
.text$mn:00002545                 mov     edx, [ebp+var_18]
.text$mn:00002548                 cmp     [edx+18h], eax
.text$mn:0000254B                 ja      short loc_2560
.text$mn:0000254D                 mov     eax, [ebp+var_18]
.text$mn:00002550                 mov     ecx, [eax+18h]
.text$mn:00002553                 shr     ecx, 1
.text$mn:00002555                 mov     edx, [ebp+var_18]
.text$mn:00002558                 add     ecx, [edx+18h]
.text$mn:0000255B                 mov     [ebp+var_1C], ecx
.text$mn:0000255E                 jmp     short loc_256B
.text$mn:00002560 ; ---------------------------------------------------------------------------
.text$mn:00002560
.text$mn:00002560 loc_2560:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00002560                 mov     ecx, [ebp+var_18]
.text$mn:00002563                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00002568                 mov     [ebp+var_1C], eax
.text$mn:0000256B
.text$mn:0000256B loc_256B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:0000256B                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:0000256B                 mov     [ebp+var_4], 0
.text$mn:00002572                 mov     eax, [ebp+var_1C]
.text$mn:00002575                 add     eax, 1
.text$mn:00002578                 push    eax
.text$mn:00002579                 lea     ecx, [ebp+var_11]
.text$mn:0000257C                 push    ecx
.text$mn:0000257D                 mov     ecx, [ebp+var_18]
.text$mn:00002580                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002585                 mov     ecx, eax
.text$mn:00002587                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:0000258C                 mov     [ebp+var_20], eax
.text$mn:0000258F                 jmp     short loc_25EE
.text$mn:0000258F ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:0000258F
.text$mn:00002591
.text$mn:00002591 ; =============== S U B R O U T I N E =======================================
.text$mn:00002591
.text$mn:00002591
.text$mn:00002591 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00002591                                         ; DATA XREF: .xdata$x:00003708o
.text$mn:00002591
.text$mn:00002591 ; FUNCTION CHUNK AT .text$mn:000025D8 SIZE 00000009 BYTES
.text$mn:00002591 ; FUNCTION CHUNK AT .text$mn:000025E8 SIZE 00000006 BYTES
.text$mn:00002591
.text$mn:00002591                 mov     [ebp-10h], esp
.text$mn:00002594                 mov     edx, [ebp+8]
.text$mn:00002597                 mov     [ebp-1Ch], edx
.text$mn:0000259A                 mov     byte ptr [ebp-4], 2
.text$mn:0000259E                 mov     eax, [ebp-1Ch]
.text$mn:000025A1                 add     eax, 1
.text$mn:000025A4                 push    eax
.text$mn:000025A5                 lea     ecx, [ebp-12h]
.text$mn:000025A8                 push    ecx
.text$mn:000025A9                 mov     ecx, [ebp-18h]
.text$mn:000025AC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000025B1                 mov     ecx, eax
.text$mn:000025B3                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000025B8                 mov     [ebp-20h], eax
.text$mn:000025BB                 jmp     short loc_25D8
.text$mn:000025BB __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:000025BB
.text$mn:000025BD
.text$mn:000025BD ; =============== S U B R O U T I N E =======================================
.text$mn:000025BD
.text$mn:000025BD ; Attributes: noreturn
.text$mn:000025BD
.text$mn:000025BD __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:000025BD                                         ; DATA XREF: .xdata$x:00003718o
.text$mn:000025BD                 push    0               ; Size
.text$mn:000025BF                 push    1               ; char
.text$mn:000025C1                 mov     ecx, [ebp-18h]
.text$mn:000025C4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000025C9                 push    0
.text$mn:000025CB                 push    0
.text$mn:000025CD                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000025CD __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:000025CD
.text$mn:000025D2 ; ---------------------------------------------------------------------------
.text$mn:000025D2                 mov     eax, offset $LN17
.text$mn:000025D7                 retn
.text$mn:000025D8 ; ---------------------------------------------------------------------------
.text$mn:000025D8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000025D8
.text$mn:000025D8 loc_25D8:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:000025D8                 mov     dword ptr [ebp-4], 1
.text$mn:000025DF                 jmp     short loc_25E8
.text$mn:000025DF ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000025E1
.text$mn:000025E1 ; =============== S U B R O U T I N E =======================================
.text$mn:000025E1
.text$mn:000025E1
.text$mn:000025E1 $LN17           proc near               ; DATA XREF: .text$mn:000025D2o
.text$mn:000025E1                 mov     dword ptr [ebp-4], 1
.text$mn:000025E1 $LN17           endp ; sp-analysis failed
.text$mn:000025E1
.text$mn:000025E8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000025E8
.text$mn:000025E8 loc_25E8:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:000025E8                 mov     eax, offset $LN19
.text$mn:000025ED                 retn
.text$mn:000025ED ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000025EE ; ---------------------------------------------------------------------------
.text$mn:000025EE ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000025EE
.text$mn:000025EE loc_25EE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:000025EE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000025F5                 jmp     short loc_25FE
.text$mn:000025F5 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000025F7
.text$mn:000025F7 ; =============== S U B R O U T I N E =======================================
.text$mn:000025F7
.text$mn:000025F7
.text$mn:000025F7 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_25E8o
.text$mn:000025F7                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000025FE
.text$mn:000025FE loc_25FE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:000025FE                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00002602                 jbe     short loc_261D
.text$mn:00002604                 mov     edx, [ebp+0Ch]
.text$mn:00002607                 push    edx             ; Size
.text$mn:00002608                 mov     ecx, [ebp-18h]
.text$mn:0000260B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002610                 push    eax             ; Src
.text$mn:00002611                 mov     eax, [ebp-20h]
.text$mn:00002614                 push    eax             ; Dst
.text$mn:00002615                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000261A                 add     esp, 0Ch
.text$mn:0000261D
.text$mn:0000261D loc_261D:                               ; CODE XREF: $LN19+Bj
.text$mn:0000261D                 push    0               ; Size
.text$mn:0000261F                 push    1               ; char
.text$mn:00002621                 mov     ecx, [ebp-18h]
.text$mn:00002624                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002629                 lea     ecx, [ebp-20h]
.text$mn:0000262C                 push    ecx             ; int
.text$mn:0000262D                 mov     edx, [ebp-18h]
.text$mn:00002630                 add     edx, 4
.text$mn:00002633                 push    edx             ; void *
.text$mn:00002634                 lea     eax, [ebp-13h]
.text$mn:00002637                 push    eax
.text$mn:00002638                 mov     ecx, [ebp-18h]
.text$mn:0000263B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002640                 mov     ecx, eax
.text$mn:00002642                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00002647                 mov     ecx, [ebp-18h]
.text$mn:0000264A                 mov     edx, [ebp-1Ch]
.text$mn:0000264D                 mov     [ecx+18h], edx
.text$mn:00002650                 mov     eax, [ebp+0Ch]
.text$mn:00002653                 push    eax
.text$mn:00002654                 mov     ecx, [ebp-18h]
.text$mn:00002657                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000265C                 mov     ecx, [ebp-0Ch]
.text$mn:0000265F                 mov     large fs:0, ecx
.text$mn:00002666                 pop     ecx
.text$mn:00002667                 pop     edi
.text$mn:00002668                 pop     esi
.text$mn:00002669                 pop     ebx
.text$mn:0000266A                 mov     esp, ebp
.text$mn:0000266C                 pop     ebp
.text$mn:0000266D                 retn    8
.text$mn:0000266D $LN19           endp ; sp-analysis failed
.text$mn:0000266D
.text$mn:0000266D _text$mn        ends
.text$mn:0000266D
.text$x:00002670 ; ===========================================================================
.text$x:00002670
.text$x:00002670 ; Segment type: Pure code
.text$x:00002670 ; Segment permissions: Read/Execute
.text$x:00002670 _text$x         segment para public 'CODE' use32
.text$x:00002670                 assume cs:_text$x
.text$x:00002670                 ;org 2670h
.text$x:00002670 ; COMDAT (pick associative to section at 24CC)
.text$x:00002670                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002670
.text$x:00002670 ; =============== S U B R O U T I N E =======================================
.text$x:00002670
.text$x:00002670
.text$x:00002670 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00002670                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00002670
.text$x:00002670 arg_4           = dword ptr  8
.text$x:00002670
.text$x:00002670                 mov     edx, [esp+arg_4]
.text$x:00002674                 lea     eax, [edx+0Ch]
.text$x:00002677                 mov     ecx, [edx-24h]
.text$x:0000267A                 xor     ecx, eax
.text$x:0000267C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002681                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00002686                 jmp     ___CxxFrameHandler3
.text$x:00002686 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00002686
.text$x:00002686 ; ---------------------------------------------------------------------------
.text$x:0000268B                 align 4
.text$x:0000268B _text$x         ends
.text$x:0000268B
.text$mn:0000268C ; ===========================================================================
.text$mn:0000268C
.text$mn:0000268C ; Segment type: Pure code
.text$mn:0000268C ; Segment permissions: Read/Execute
.text$mn:0000268C _text$mn        segment para public 'CODE' use32
.text$mn:0000268C                 assume cs:_text$mn
.text$mn:0000268C                 ;org 268Ch
.text$mn:0000268C ; COMDAT (pick any)
.text$mn:0000268C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000268C
.text$mn:0000268C ; =============== S U B R O U T I N E =======================================
.text$mn:0000268C
.text$mn:0000268C ; Attributes: bp-based frame
.text$mn:0000268C
.text$mn:0000268C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:0000268C                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:0000268C ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:0000268C                                         ; CODE XREF: $LN19+60p
.text$mn:0000268C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:0000268C
.text$mn:0000268C var_8           = dword ptr -8
.text$mn:0000268C var_1           = byte ptr -1
.text$mn:0000268C arg_0           = dword ptr  8
.text$mn:0000268C
.text$mn:0000268C                 push    ebp
.text$mn:0000268D                 mov     ebp, esp
.text$mn:0000268F                 sub     esp, 8
.text$mn:00002692                 mov     [ebp+var_8], ecx
.text$mn:00002695                 mov     [ebp+var_1], 0
.text$mn:00002699                 mov     eax, [ebp+var_8]
.text$mn:0000269C                 mov     ecx, [ebp+arg_0]
.text$mn:0000269F                 mov     [eax+14h], ecx
.text$mn:000026A2                 lea     edx, [ebp+var_1]
.text$mn:000026A5                 push    edx
.text$mn:000026A6                 mov     ecx, [ebp+var_8]
.text$mn:000026A9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000026AE                 add     eax, [ebp+arg_0]
.text$mn:000026B1                 push    eax
.text$mn:000026B2                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:000026B7                 add     esp, 8
.text$mn:000026BA                 mov     esp, ebp
.text$mn:000026BC                 pop     ebp
.text$mn:000026BD                 retn    4
.text$mn:000026BD ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:000026BD
.text$mn:000026BD _text$mn        ends
.text$mn:000026BD
.text$mn:000026C0 ; ===========================================================================
.text$mn:000026C0
.text$mn:000026C0 ; Segment type: Pure code
.text$mn:000026C0 ; Segment permissions: Read/Execute
.text$mn:000026C0 _text$mn        segment para public 'CODE' use32
.text$mn:000026C0                 assume cs:_text$mn
.text$mn:000026C0                 ;org 26C0h
.text$mn:000026C0 ; COMDAT (pick any)
.text$mn:000026C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026C0
.text$mn:000026C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000026C0
.text$mn:000026C0 ; Attributes: bp-based frame
.text$mn:000026C0
.text$mn:000026C0 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:000026C0                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000026C0 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000026C0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:000026C0
.text$mn:000026C0 var_8           = dword ptr -8
.text$mn:000026C0 var_1           = byte ptr -1
.text$mn:000026C0
.text$mn:000026C0                 push    ebp
.text$mn:000026C1                 mov     ebp, esp
.text$mn:000026C3                 sub     esp, 8
.text$mn:000026C6                 mov     [ebp+var_8], ecx
.text$mn:000026C9                 lea     ecx, [ebp+var_1]
.text$mn:000026CC                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000026D1                 mov     ecx, [ebp+var_8] ; this
.text$mn:000026D4                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000026D9                 mov     eax, [ebp+var_8]
.text$mn:000026DC                 mov     ecx, [eax]
.text$mn:000026DE                 push    ecx
.text$mn:000026DF                 lea     ecx, [ebp+var_1]
.text$mn:000026E2                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000026E7                 push    1               ; int
.text$mn:000026E9                 mov     edx, [ebp+var_8]
.text$mn:000026EC                 mov     eax, [edx]
.text$mn:000026EE                 push    eax             ; void *
.text$mn:000026EF                 lea     ecx, [ebp+var_1]
.text$mn:000026F2                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:000026F7                 mov     ecx, [ebp+var_8]
.text$mn:000026FA                 mov     dword ptr [ecx], 0
.text$mn:00002700                 mov     esp, ebp
.text$mn:00002702                 pop     ebp
.text$mn:00002703                 retn
.text$mn:00002703 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00002703
.text$mn:00002703 _text$mn        ends
.text$mn:00002703
.text$mn:00002704 ; ===========================================================================
.text$mn:00002704
.text$mn:00002704 ; Segment type: Pure code
.text$mn:00002704 ; Segment permissions: Read/Execute
.text$mn:00002704 _text$mn        segment para public 'CODE' use32
.text$mn:00002704                 assume cs:_text$mn
.text$mn:00002704                 ;org 2704h
.text$mn:00002704 ; COMDAT (pick any)
.text$mn:00002704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002704
.text$mn:00002704 ; =============== S U B R O U T I N E =======================================
.text$mn:00002704
.text$mn:00002704 ; Attributes: bp-based frame
.text$mn:00002704
.text$mn:00002704 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00002704                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00002704 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00002704                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00002704                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00002704
.text$mn:00002704 var_4           = dword ptr -4
.text$mn:00002704 arg_0           = dword ptr  8
.text$mn:00002704
.text$mn:00002704                 push    ebp
.text$mn:00002705                 mov     ebp, esp
.text$mn:00002707                 push    ecx
.text$mn:00002708                 mov     [ebp+var_4], ecx
.text$mn:0000270B                 mov     ecx, [ebp+arg_0]
.text$mn:0000270E                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00002713                 mov     eax, [ebp+arg_0]
.text$mn:00002716                 mov     esp, ebp
.text$mn:00002718                 pop     ebp
.text$mn:00002719                 retn    4
.text$mn:00002719 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00002719
.text$mn:00002719 _text$mn        ends
.text$mn:00002719
.text$mn:0000271C ; ===========================================================================
.text$mn:0000271C
.text$mn:0000271C ; Segment type: Pure code
.text$mn:0000271C ; Segment permissions: Read/Execute
.text$mn:0000271C _text$mn        segment para public 'CODE' use32
.text$mn:0000271C                 assume cs:_text$mn
.text$mn:0000271C                 ;org 271Ch
.text$mn:0000271C ; COMDAT (pick any)
.text$mn:0000271C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000271C
.text$mn:0000271C ; =============== S U B R O U T I N E =======================================
.text$mn:0000271C
.text$mn:0000271C ; Attributes: bp-based frame
.text$mn:0000271C
.text$mn:0000271C ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:0000271C                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:0000271C ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:0000271C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:0000271C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:0000271C
.text$mn:0000271C var_C           = dword ptr -0Ch
.text$mn:0000271C Size            = dword ptr -8
.text$mn:0000271C var_4           = dword ptr -4
.text$mn:0000271C arg_0           = dword ptr  8
.text$mn:0000271C arg_4           = byte ptr  0Ch
.text$mn:0000271C
.text$mn:0000271C                 push    ebp
.text$mn:0000271D                 mov     ebp, esp
.text$mn:0000271F                 sub     esp, 0Ch
.text$mn:00002722                 mov     [ebp+var_4], ecx
.text$mn:00002725                 mov     ecx, [ebp+var_4]
.text$mn:00002728                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000272D                 cmp     eax, [ebp+arg_0]
.text$mn:00002730                 jnb     short loc_273A
.text$mn:00002732                 mov     ecx, [ebp+var_4]
.text$mn:00002735                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000273A
.text$mn:0000273A loc_273A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:0000273A                 mov     eax, [ebp+var_4]
.text$mn:0000273D                 mov     ecx, [eax+18h]
.text$mn:00002740                 cmp     ecx, [ebp+arg_0]
.text$mn:00002743                 jnb     short loc_275A
.text$mn:00002745                 mov     edx, [ebp+var_4]
.text$mn:00002748                 mov     eax, [edx+14h]
.text$mn:0000274B                 push    eax
.text$mn:0000274C                 mov     ecx, [ebp+arg_0]
.text$mn:0000274F                 push    ecx
.text$mn:00002750                 mov     ecx, [ebp+var_4]
.text$mn:00002753                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00002758                 jmp     short loc_27A4
.text$mn:0000275A ; ---------------------------------------------------------------------------
.text$mn:0000275A
.text$mn:0000275A loc_275A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:0000275A                 movzx   edx, [ebp+arg_4]
.text$mn:0000275E                 test    edx, edx
.text$mn:00002760                 jz      short loc_2794
.text$mn:00002762                 cmp     [ebp+arg_0], 10h
.text$mn:00002766                 jnb     short loc_2794
.text$mn:00002768                 mov     eax, [ebp+var_4]
.text$mn:0000276B                 mov     ecx, [ebp+arg_0]
.text$mn:0000276E                 cmp     ecx, [eax+14h]
.text$mn:00002771                 jnb     short loc_277B
.text$mn:00002773                 mov     edx, [ebp+arg_0]
.text$mn:00002776                 mov     [ebp+Size], edx
.text$mn:00002779                 jmp     short loc_2784
.text$mn:0000277B ; ---------------------------------------------------------------------------
.text$mn:0000277B
.text$mn:0000277B loc_277B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:0000277B                 mov     eax, [ebp+var_4]
.text$mn:0000277E                 mov     ecx, [eax+14h]
.text$mn:00002781                 mov     [ebp+Size], ecx
.text$mn:00002784
.text$mn:00002784 loc_2784:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00002784                 mov     edx, [ebp+Size]
.text$mn:00002787                 push    edx             ; Size
.text$mn:00002788                 push    1               ; char
.text$mn:0000278A                 mov     ecx, [ebp+var_4]
.text$mn:0000278D                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002792                 jmp     short loc_27A4
.text$mn:00002794 ; ---------------------------------------------------------------------------
.text$mn:00002794
.text$mn:00002794 loc_2794:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00002794                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00002794                 cmp     [ebp+arg_0], 0
.text$mn:00002798                 jnz     short loc_27A4
.text$mn:0000279A                 push    0
.text$mn:0000279C                 mov     ecx, [ebp+var_4]
.text$mn:0000279F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000027A4
.text$mn:000027A4 loc_27A4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:000027A4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:000027A4                 cmp     [ebp+arg_0], 0
.text$mn:000027A8                 jbe     short loc_27B3
.text$mn:000027AA                 mov     [ebp+var_C], 1
.text$mn:000027B1                 jmp     short loc_27BA
.text$mn:000027B3 ; ---------------------------------------------------------------------------
.text$mn:000027B3
.text$mn:000027B3 loc_27B3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:000027B3                 mov     [ebp+var_C], 0
.text$mn:000027BA
.text$mn:000027BA loc_27BA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:000027BA                 mov     al, byte ptr [ebp+var_C]
.text$mn:000027BD                 mov     esp, ebp
.text$mn:000027BF                 pop     ebp
.text$mn:000027C0                 retn    8
.text$mn:000027C0 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:000027C0
.text$mn:000027C0 ; ---------------------------------------------------------------------------
.text$mn:000027C3                 align 4
.text$mn:000027C3 _text$mn        ends
.text$mn:000027C3
.text$mn:000027C4 ; ===========================================================================
.text$mn:000027C4
.text$mn:000027C4 ; Segment type: Pure code
.text$mn:000027C4 ; Segment permissions: Read/Execute
.text$mn:000027C4 _text$mn        segment para public 'CODE' use32
.text$mn:000027C4                 assume cs:_text$mn
.text$mn:000027C4                 ;org 27C4h
.text$mn:000027C4 ; COMDAT (pick any)
.text$mn:000027C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027C4
.text$mn:000027C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000027C4
.text$mn:000027C4 ; Attributes: bp-based frame
.text$mn:000027C4
.text$mn:000027C4 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000027C4                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000027C4 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000027C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000027C4
.text$mn:000027C4 var_4           = dword ptr -4
.text$mn:000027C4 arg_0           = dword ptr  8
.text$mn:000027C4
.text$mn:000027C4                 push    ebp
.text$mn:000027C5                 mov     ebp, esp
.text$mn:000027C7                 push    ecx
.text$mn:000027C8                 mov     [ebp+var_4], ecx
.text$mn:000027CB                 cmp     [ebp+arg_0], 0
.text$mn:000027CF                 jz      short loc_27F1
.text$mn:000027D1                 mov     ecx, [ebp+var_4]
.text$mn:000027D4                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000027D9                 cmp     [ebp+arg_0], eax
.text$mn:000027DC                 jb      short loc_27F1
.text$mn:000027DE                 mov     ecx, [ebp+var_4]
.text$mn:000027E1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000027E6                 mov     ecx, [ebp+var_4]
.text$mn:000027E9                 add     eax, [ecx+14h]
.text$mn:000027EC                 cmp     eax, [ebp+arg_0]
.text$mn:000027EF                 ja      short loc_27F7
.text$mn:000027F1
.text$mn:000027F1 loc_27F1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:000027F1                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:000027F1                 xor     al, al
.text$mn:000027F3                 jmp     short loc_27F9
.text$mn:000027F5 ; ---------------------------------------------------------------------------
.text$mn:000027F5                 jmp     short loc_27F9
.text$mn:000027F7 ; ---------------------------------------------------------------------------
.text$mn:000027F7
.text$mn:000027F7 loc_27F7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:000027F7                 mov     al, 1
.text$mn:000027F9
.text$mn:000027F9 loc_27F9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000027F9                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000027F9                 mov     esp, ebp
.text$mn:000027FB                 pop     ebp
.text$mn:000027FC                 retn    4
.text$mn:000027FC ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000027FC
.text$mn:000027FC ; ---------------------------------------------------------------------------
.text$mn:000027FF                 align 10h
.text$mn:000027FF _text$mn        ends
.text$mn:000027FF
.text$mn:00002800 ; ===========================================================================
.text$mn:00002800
.text$mn:00002800 ; Segment type: Pure code
.text$mn:00002800 ; Segment permissions: Read/Execute
.text$mn:00002800 _text$mn        segment para public 'CODE' use32
.text$mn:00002800                 assume cs:_text$mn
.text$mn:00002800                 ;org 2800h
.text$mn:00002800 ; COMDAT (pick any)
.text$mn:00002800                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002800
.text$mn:00002800 ; =============== S U B R O U T I N E =======================================
.text$mn:00002800
.text$mn:00002800 ; Attributes: bp-based frame
.text$mn:00002800
.text$mn:00002800 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002800                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00002800 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00002800                                         ; CODE XREF: $LN19+14p
.text$mn:00002800                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00002800
.text$mn:00002800 var_8           = dword ptr -8
.text$mn:00002800 var_4           = dword ptr -4
.text$mn:00002800
.text$mn:00002800                 push    ebp
.text$mn:00002801                 mov     ebp, esp
.text$mn:00002803                 sub     esp, 8
.text$mn:00002806                 mov     [ebp+var_4], ecx
.text$mn:00002809                 mov     eax, [ebp+var_4]
.text$mn:0000280C                 cmp     dword ptr [eax+18h], 10h
.text$mn:00002810                 jb      short loc_2826
.text$mn:00002812                 mov     ecx, [ebp+var_4]
.text$mn:00002815                 mov     edx, [ecx+4]
.text$mn:00002818                 push    edx
.text$mn:00002819                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000281E                 add     esp, 4
.text$mn:00002821                 mov     [ebp+var_8], eax
.text$mn:00002824                 jmp     short loc_282F
.text$mn:00002826 ; ---------------------------------------------------------------------------
.text$mn:00002826
.text$mn:00002826 loc_2826:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00002826                 mov     eax, [ebp+var_4]
.text$mn:00002829                 add     eax, 4
.text$mn:0000282C                 mov     [ebp+var_8], eax
.text$mn:0000282F
.text$mn:0000282F loc_282F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000282F                 mov     eax, [ebp+var_8]
.text$mn:00002832                 mov     esp, ebp
.text$mn:00002834                 pop     ebp
.text$mn:00002835                 retn
.text$mn:00002835 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00002835
.text$mn:00002835 ; ---------------------------------------------------------------------------
.text$mn:00002836                 align 4
.text$mn:00002836 _text$mn        ends
.text$mn:00002836
.text$mn:00002838 ; ===========================================================================
.text$mn:00002838
.text$mn:00002838 ; Segment type: Pure code
.text$mn:00002838 ; Segment permissions: Read/Execute
.text$mn:00002838 _text$mn        segment para public 'CODE' use32
.text$mn:00002838                 assume cs:_text$mn
.text$mn:00002838                 ;org 2838h
.text$mn:00002838 ; COMDAT (pick any)
.text$mn:00002838                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002838
.text$mn:00002838 ; =============== S U B R O U T I N E =======================================
.text$mn:00002838
.text$mn:00002838 ; Attributes: bp-based frame
.text$mn:00002838
.text$mn:00002838 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00002838                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00002838 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00002838                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00002838
.text$mn:00002838 var_8           = dword ptr -8
.text$mn:00002838 var_4           = dword ptr -4
.text$mn:00002838
.text$mn:00002838                 push    ebp
.text$mn:00002839                 mov     ebp, esp
.text$mn:0000283B                 sub     esp, 8
.text$mn:0000283E                 mov     [ebp+var_4], ecx
.text$mn:00002841                 mov     eax, [ebp+var_4]
.text$mn:00002844                 cmp     dword ptr [eax+18h], 10h
.text$mn:00002848                 jb      short loc_285E
.text$mn:0000284A                 mov     ecx, [ebp+var_4]
.text$mn:0000284D                 mov     edx, [ecx+4]
.text$mn:00002850                 push    edx
.text$mn:00002851                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002856                 add     esp, 4
.text$mn:00002859                 mov     [ebp+var_8], eax
.text$mn:0000285C                 jmp     short loc_2867
.text$mn:0000285E ; ---------------------------------------------------------------------------
.text$mn:0000285E
.text$mn:0000285E loc_285E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000285E                 mov     eax, [ebp+var_4]
.text$mn:00002861                 add     eax, 4
.text$mn:00002864                 mov     [ebp+var_8], eax
.text$mn:00002867
.text$mn:00002867 loc_2867:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00002867                 mov     eax, [ebp+var_8]
.text$mn:0000286A                 mov     esp, ebp
.text$mn:0000286C                 pop     ebp
.text$mn:0000286D                 retn
.text$mn:0000286D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:0000286D
.text$mn:0000286D ; ---------------------------------------------------------------------------
.text$mn:0000286E                 align 10h
.text$mn:0000286E _text$mn        ends
.text$mn:0000286E
.text$mn:00002870 ; ===========================================================================
.text$mn:00002870
.text$mn:00002870 ; Segment type: Pure code
.text$mn:00002870 ; Segment permissions: Read/Execute
.text$mn:00002870 _text$mn        segment para public 'CODE' use32
.text$mn:00002870                 assume cs:_text$mn
.text$mn:00002870                 ;org 2870h
.text$mn:00002870 ; COMDAT (pick any)
.text$mn:00002870                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002870
.text$mn:00002870 ; =============== S U B R O U T I N E =======================================
.text$mn:00002870
.text$mn:00002870 ; Attributes: bp-based frame
.text$mn:00002870
.text$mn:00002870 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00002870                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00002870 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00002870                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00002870                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:00002870
.text$mn:00002870 var_18          = byte ptr -18h
.text$mn:00002870 var_14          = dword ptr -14h
.text$mn:00002870 var_10          = dword ptr -10h
.text$mn:00002870 var_C           = dword ptr -0Ch
.text$mn:00002870 var_4           = dword ptr -4
.text$mn:00002870
.text$mn:00002870                 push    ebp
.text$mn:00002871                 mov     ebp, esp
.text$mn:00002873                 push    0FFFFFFFFh
.text$mn:00002875                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000287A                 mov     eax, large fs:0
.text$mn:00002880                 push    eax
.text$mn:00002881                 sub     esp, 0Ch
.text$mn:00002884                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002889                 xor     eax, ebp
.text$mn:0000288B                 push    eax
.text$mn:0000288C                 lea     eax, [ebp+var_C]
.text$mn:0000288F                 mov     large fs:0, eax
.text$mn:00002895                 mov     [ebp+var_14], ecx
.text$mn:00002898                 mov     eax, [ebp+var_14]
.text$mn:0000289B                 cmp     dword ptr [eax], 0
.text$mn:0000289E                 jz      short loc_28FB
.text$mn:000028A0                 push    3               ; int
.text$mn:000028A2                 lea     ecx, [ebp+var_18] ; this
.text$mn:000028A5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000028AA                 mov     [ebp+var_4], 0
.text$mn:000028B1                 mov     ecx, [ebp+var_14]
.text$mn:000028B4                 mov     edx, [ecx]
.text$mn:000028B6                 add     edx, 4
.text$mn:000028B9                 mov     [ebp+var_10], edx
.text$mn:000028BC                 jmp     short loc_28CB
.text$mn:000028BE ; ---------------------------------------------------------------------------
.text$mn:000028BE
.text$mn:000028BE loc_28BE:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:000028BE                 mov     eax, [ebp+var_10]
.text$mn:000028C1                 mov     ecx, [eax]
.text$mn:000028C3                 mov     edx, [ebp+var_10]
.text$mn:000028C6                 mov     eax, [ecx+4]
.text$mn:000028C9                 mov     [edx], eax
.text$mn:000028CB
.text$mn:000028CB loc_28CB:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:000028CB                 mov     ecx, [ebp+var_10]
.text$mn:000028CE                 cmp     dword ptr [ecx], 0
.text$mn:000028D1                 jz      short loc_28E0
.text$mn:000028D3                 mov     edx, [ebp+var_10]
.text$mn:000028D6                 mov     eax, [edx]
.text$mn:000028D8                 mov     dword ptr [eax], 0
.text$mn:000028DE                 jmp     short loc_28BE
.text$mn:000028E0 ; ---------------------------------------------------------------------------
.text$mn:000028E0
.text$mn:000028E0 loc_28E0:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:000028E0                 mov     ecx, [ebp+var_14]
.text$mn:000028E3                 mov     edx, [ecx]
.text$mn:000028E5                 mov     dword ptr [edx+4], 0
.text$mn:000028EC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000028F3                 lea     ecx, [ebp+var_18] ; this
.text$mn:000028F6                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000028FB
.text$mn:000028FB loc_28FB:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000028FB                 mov     ecx, [ebp+var_C]
.text$mn:000028FE                 mov     large fs:0, ecx
.text$mn:00002905                 pop     ecx
.text$mn:00002906                 mov     esp, ebp
.text$mn:00002908                 pop     ebp
.text$mn:00002909                 retn
.text$mn:00002909 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00002909
.text$mn:00002909 ; ---------------------------------------------------------------------------
.text$mn:0000290A                 align 4
.text$mn:0000290A _text$mn        ends
.text$mn:0000290A
.text$x:0000290C ; ===========================================================================
.text$x:0000290C
.text$x:0000290C ; Segment type: Pure code
.text$x:0000290C ; Segment permissions: Read/Execute
.text$x:0000290C _text$x         segment para public 'CODE' use32
.text$x:0000290C                 assume cs:_text$x
.text$x:0000290C                 ;org 290Ch
.text$x:0000290C ; COMDAT (pick associative to section at 2870)
.text$x:0000290C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000290C
.text$x:0000290C ; =============== S U B R O U T I N E =======================================
.text$x:0000290C
.text$x:0000290C
.text$x:0000290C __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:0000290C                                         ; DATA XREF: .xdata$x:000035CCo
.text$x:0000290C                 lea     ecx, [ebp-18h]  ; this
.text$x:0000290F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000290F __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:0000290F
.text$x:00002914
.text$x:00002914 ; =============== S U B R O U T I N E =======================================
.text$x:00002914
.text$x:00002914
.text$x:00002914 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00002914                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00002914
.text$x:00002914 arg_4           = dword ptr  8
.text$x:00002914
.text$x:00002914                 mov     edx, [esp+arg_4]
.text$x:00002918                 lea     eax, [edx+0Ch]
.text$x:0000291B                 mov     ecx, [edx-10h]
.text$x:0000291E                 xor     ecx, eax
.text$x:00002920                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002925                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:0000292A                 jmp     ___CxxFrameHandler3
.text$x:0000292A __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:0000292A
.text$x:0000292A ; ---------------------------------------------------------------------------
.text$x:0000292F                 align 10h
.text$x:0000292F _text$x         ends
.text$x:0000292F
.text$mn:00002930 ; ===========================================================================
.text$mn:00002930
.text$mn:00002930 ; Segment type: Pure code
.text$mn:00002930 ; Segment permissions: Read/Execute
.text$mn:00002930 _text$mn        segment para public 'CODE' use32
.text$mn:00002930                 assume cs:_text$mn
.text$mn:00002930                 ;org 2930h
.text$mn:00002930 ; COMDAT (pick any)
.text$mn:00002930                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002930
.text$mn:00002930 ; =============== S U B R O U T I N E =======================================
.text$mn:00002930
.text$mn:00002930 ; Attributes: bp-based frame
.text$mn:00002930
.text$mn:00002930 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00002930                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00002930 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00002930                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00002930                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00002930
.text$mn:00002930 var_C           = dword ptr -0Ch
.text$mn:00002930 var_8           = dword ptr -8
.text$mn:00002930 var_2           = byte ptr -2
.text$mn:00002930 var_1           = byte ptr -1
.text$mn:00002930 arg_0           = byte ptr  8
.text$mn:00002930 Size            = dword ptr  0Ch
.text$mn:00002930
.text$mn:00002930                 push    ebp
.text$mn:00002931                 mov     ebp, esp
.text$mn:00002933                 sub     esp, 0Ch
.text$mn:00002936                 mov     [ebp+var_8], ecx
.text$mn:00002939                 movzx   eax, [ebp+arg_0]
.text$mn:0000293D                 test    eax, eax
.text$mn:0000293F                 jnz     short loc_2943
.text$mn:00002941                 jmp     short loc_29B6
.text$mn:00002943 ; ---------------------------------------------------------------------------
.text$mn:00002943
.text$mn:00002943 loc_2943:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00002943                 mov     ecx, [ebp+var_8]
.text$mn:00002946                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000294A                 jb      short loc_29B6
.text$mn:0000294C                 mov     edx, [ebp+var_8]
.text$mn:0000294F                 mov     eax, [edx+4]
.text$mn:00002952                 mov     [ebp+var_C], eax
.text$mn:00002955                 mov     ecx, [ebp+var_8]
.text$mn:00002958                 add     ecx, 4
.text$mn:0000295B                 push    ecx
.text$mn:0000295C                 lea     edx, [ebp+var_1]
.text$mn:0000295F                 push    edx
.text$mn:00002960                 mov     ecx, [ebp+var_8]
.text$mn:00002963                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002968                 mov     ecx, eax
.text$mn:0000296A                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000296F                 cmp     [ebp+Size], 0
.text$mn:00002973                 jbe     short loc_2995
.text$mn:00002975                 mov     eax, [ebp+Size]
.text$mn:00002978                 push    eax             ; Size
.text$mn:00002979                 mov     ecx, [ebp+var_C]
.text$mn:0000297C                 push    ecx
.text$mn:0000297D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002982                 add     esp, 4
.text$mn:00002985                 push    eax             ; Src
.text$mn:00002986                 mov     edx, [ebp+var_8]
.text$mn:00002989                 add     edx, 4
.text$mn:0000298C                 push    edx             ; Dst
.text$mn:0000298D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002992                 add     esp, 0Ch
.text$mn:00002995
.text$mn:00002995 loc_2995:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00002995                 mov     eax, [ebp+var_8]
.text$mn:00002998                 mov     ecx, [eax+18h]
.text$mn:0000299B                 add     ecx, 1
.text$mn:0000299E                 push    ecx             ; int
.text$mn:0000299F                 mov     edx, [ebp+var_C]
.text$mn:000029A2                 push    edx             ; void *
.text$mn:000029A3                 lea     eax, [ebp+var_2]
.text$mn:000029A6                 push    eax
.text$mn:000029A7                 mov     ecx, [ebp+var_8]
.text$mn:000029AA                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000029AF                 mov     ecx, eax
.text$mn:000029B1                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000029B6
.text$mn:000029B6 loc_29B6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000029B6                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000029B6                 mov     ecx, [ebp+var_8]
.text$mn:000029B9                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:000029C0                 mov     edx, [ebp+Size]
.text$mn:000029C3                 push    edx
.text$mn:000029C4                 mov     ecx, [ebp+var_8]
.text$mn:000029C7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000029CC                 mov     esp, ebp
.text$mn:000029CE                 pop     ebp
.text$mn:000029CF                 retn    8
.text$mn:000029CF ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:000029CF
.text$mn:000029CF ; ---------------------------------------------------------------------------
.text$mn:000029D2                 align 4
.text$mn:000029D2 _text$mn        ends
.text$mn:000029D2
.text$mn:000029D4 ; ===========================================================================
.text$mn:000029D4
.text$mn:000029D4 ; Segment type: Pure code
.text$mn:000029D4 ; Segment permissions: Read/Execute
.text$mn:000029D4 _text$mn        segment para public 'CODE' use32
.text$mn:000029D4                 assume cs:_text$mn
.text$mn:000029D4                 ;org 29D4h
.text$mn:000029D4 ; COMDAT (pick any)
.text$mn:000029D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029D4
.text$mn:000029D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029D4
.text$mn:000029D4 ; Attributes: bp-based frame
.text$mn:000029D4
.text$mn:000029D4 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:000029D4                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000029D4 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000029D4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:000029D4
.text$mn:000029D4 var_4           = dword ptr -4
.text$mn:000029D4
.text$mn:000029D4                 push    ebp
.text$mn:000029D5                 mov     ebp, esp
.text$mn:000029D7                 push    ecx
.text$mn:000029D8                 mov     [ebp+var_4], ecx
.text$mn:000029DB                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000029E0                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000029E5                 mov     esp, ebp
.text$mn:000029E7                 pop     ebp
.text$mn:000029E8                 retn
.text$mn:000029E8 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000029E8
.text$mn:000029E8 ; ---------------------------------------------------------------------------
.text$mn:000029E9                 align 4
.text$mn:000029E9 _text$mn        ends
.text$mn:000029E9
.text$mn:000029EC ; ===========================================================================
.text$mn:000029EC
.text$mn:000029EC ; Segment type: Pure code
.text$mn:000029EC ; Segment permissions: Read/Execute
.text$mn:000029EC _text$mn        segment para public 'CODE' use32
.text$mn:000029EC                 assume cs:_text$mn
.text$mn:000029EC                 ;org 29ECh
.text$mn:000029EC ; COMDAT (pick any)
.text$mn:000029EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029EC
.text$mn:000029EC ; =============== S U B R O U T I N E =======================================
.text$mn:000029EC
.text$mn:000029EC ; Attributes: bp-based frame
.text$mn:000029EC
.text$mn:000029EC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000029EC                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000029EC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000029EC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000029EC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:000029EC
.text$mn:000029EC var_4           = dword ptr -4
.text$mn:000029EC
.text$mn:000029EC                 push    ebp
.text$mn:000029ED                 mov     ebp, esp
.text$mn:000029EF                 push    ecx
.text$mn:000029F0                 mov     [ebp+var_4], ecx
.text$mn:000029F3                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000029F8                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000029FD                 mov     esp, ebp
.text$mn:000029FF                 pop     ebp
.text$mn:00002A00                 retn
.text$mn:00002A00 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00002A00
.text$mn:00002A00 ; ---------------------------------------------------------------------------
.text$mn:00002A01                 align 4
.text$mn:00002A01 _text$mn        ends
.text$mn:00002A01
.text$mn:00002A04 ; ===========================================================================
.text$mn:00002A04
.text$mn:00002A04 ; Segment type: Pure code
.text$mn:00002A04 ; Segment permissions: Read/Execute
.text$mn:00002A04 _text$mn        segment para public 'CODE' use32
.text$mn:00002A04                 assume cs:_text$mn
.text$mn:00002A04                 ;org 2A04h
.text$mn:00002A04 ; COMDAT (pick any)
.text$mn:00002A04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A04
.text$mn:00002A04 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A04
.text$mn:00002A04 ; Attributes: bp-based frame
.text$mn:00002A04
.text$mn:00002A04 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00002A04                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00002A04 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00002A04                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00002A04                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00002A04
.text$mn:00002A04 var_4           = dword ptr -4
.text$mn:00002A04 arg_0           = dword ptr  8
.text$mn:00002A04
.text$mn:00002A04                 push    ebp
.text$mn:00002A05                 mov     ebp, esp
.text$mn:00002A07                 push    ecx
.text$mn:00002A08                 mov     [ebp+var_4], ecx
.text$mn:00002A0B                 mov     eax, [ebp+arg_0]
.text$mn:00002A0E                 push    eax
.text$mn:00002A0F                 mov     ecx, [ebp+var_4]
.text$mn:00002A12                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00002A17                 mov     esp, ebp
.text$mn:00002A19                 pop     ebp
.text$mn:00002A1A                 retn    4
.text$mn:00002A1A ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00002A1A
.text$mn:00002A1A ; ---------------------------------------------------------------------------
.text$mn:00002A1D                 align 10h
.text$mn:00002A1D _text$mn        ends
.text$mn:00002A1D
.text$mn:00002A20 ; ===========================================================================
.text$mn:00002A20
.text$mn:00002A20 ; Segment type: Pure code
.text$mn:00002A20 ; Segment permissions: Read/Execute
.text$mn:00002A20 _text$mn        segment para public 'CODE' use32
.text$mn:00002A20                 assume cs:_text$mn
.text$mn:00002A20                 ;org 2A20h
.text$mn:00002A20 ; COMDAT (pick any)
.text$mn:00002A20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A20
.text$mn:00002A20 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A20
.text$mn:00002A20 ; Attributes: bp-based frame
.text$mn:00002A20
.text$mn:00002A20 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00002A20                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00002A20 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00002A20                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00002A20
.text$mn:00002A20 var_4           = dword ptr -4
.text$mn:00002A20 arg_0           = dword ptr  8
.text$mn:00002A20
.text$mn:00002A20                 push    ebp
.text$mn:00002A21                 mov     ebp, esp
.text$mn:00002A23                 push    ecx
.text$mn:00002A24                 mov     [ebp+var_4], ecx
.text$mn:00002A27                 push    0
.text$mn:00002A29                 mov     eax, [ebp+arg_0]
.text$mn:00002A2C                 push    eax
.text$mn:00002A2D                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00002A32                 add     esp, 8
.text$mn:00002A35                 mov     esp, ebp
.text$mn:00002A37                 pop     ebp
.text$mn:00002A38                 retn    4
.text$mn:00002A38 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00002A38
.text$mn:00002A38 ; ---------------------------------------------------------------------------
.text$mn:00002A3B                 align 4
.text$mn:00002A3B _text$mn        ends
.text$mn:00002A3B
.text$mn:00002A3C ; ===========================================================================
.text$mn:00002A3C
.text$mn:00002A3C ; Segment type: Pure code
.text$mn:00002A3C ; Segment permissions: Read/Execute
.text$mn:00002A3C _text$mn        segment para public 'CODE' use32
.text$mn:00002A3C                 assume cs:_text$mn
.text$mn:00002A3C                 ;org 2A3Ch
.text$mn:00002A3C ; COMDAT (pick any)
.text$mn:00002A3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A3C
.text$mn:00002A3C ; =============== S U B R O U T I N E =======================================
.text$mn:00002A3C
.text$mn:00002A3C ; Attributes: bp-based frame
.text$mn:00002A3C
.text$mn:00002A3C ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00002A3C                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00002A3C ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00002A3C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00002A3C
.text$mn:00002A3C var_4           = dword ptr -4
.text$mn:00002A3C arg_0           = dword ptr  8
.text$mn:00002A3C
.text$mn:00002A3C                 push    ebp
.text$mn:00002A3D                 mov     ebp, esp
.text$mn:00002A3F                 push    ecx
.text$mn:00002A40                 mov     [ebp+var_4], ecx
.text$mn:00002A43                 push    0
.text$mn:00002A45                 mov     eax, [ebp+arg_0]
.text$mn:00002A48                 push    eax
.text$mn:00002A49                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00002A4E                 add     esp, 8
.text$mn:00002A51                 mov     esp, ebp
.text$mn:00002A53                 pop     ebp
.text$mn:00002A54                 retn    4
.text$mn:00002A54 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00002A54
.text$mn:00002A54 ; ---------------------------------------------------------------------------
.text$mn:00002A57                 align 4
.text$mn:00002A57 _text$mn        ends
.text$mn:00002A57
.text$mn:00002A58 ; ===========================================================================
.text$mn:00002A58
.text$mn:00002A58 ; Segment type: Pure code
.text$mn:00002A58 ; Segment permissions: Read/Execute
.text$mn:00002A58 _text$mn        segment para public 'CODE' use32
.text$mn:00002A58                 assume cs:_text$mn
.text$mn:00002A58                 ;org 2A58h
.text$mn:00002A58 ; COMDAT (pick any)
.text$mn:00002A58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A58
.text$mn:00002A58 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A58
.text$mn:00002A58 ; Attributes: bp-based frame
.text$mn:00002A58
.text$mn:00002A58 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00002A58                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00002A58 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00002A58                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00002A58
.text$mn:00002A58 Size            = dword ptr -8
.text$mn:00002A58 var_4           = dword ptr -4
.text$mn:00002A58 arg_0           = dword ptr  8
.text$mn:00002A58 arg_4           = dword ptr  0Ch
.text$mn:00002A58 arg_8           = dword ptr  10h
.text$mn:00002A58
.text$mn:00002A58                 push    ebp
.text$mn:00002A59                 mov     ebp, esp
.text$mn:00002A5B                 sub     esp, 8
.text$mn:00002A5E                 mov     [ebp+var_4], ecx
.text$mn:00002A61                 mov     ecx, [ebp+arg_0]
.text$mn:00002A64                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00002A69                 cmp     eax, [ebp+arg_4]
.text$mn:00002A6C                 jnb     short loc_2A76
.text$mn:00002A6E                 mov     ecx, [ebp+var_4]
.text$mn:00002A71                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002A76
.text$mn:00002A76 loc_2A76:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00002A76                 mov     ecx, [ebp+arg_0]
.text$mn:00002A79                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00002A7E                 sub     eax, [ebp+arg_4]
.text$mn:00002A81                 mov     [ebp+Size], eax
.text$mn:00002A84                 mov     eax, [ebp+arg_8]
.text$mn:00002A87                 cmp     eax, [ebp+Size]
.text$mn:00002A8A                 jnb     short loc_2A92
.text$mn:00002A8C                 mov     ecx, [ebp+arg_8]
.text$mn:00002A8F                 mov     [ebp+Size], ecx
.text$mn:00002A92
.text$mn:00002A92 loc_2A92:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00002A92                 mov     edx, [ebp+var_4]
.text$mn:00002A95                 cmp     edx, [ebp+arg_0]
.text$mn:00002A98                 jnz     short loc_2AB9
.text$mn:00002A9A                 mov     eax, [ebp+arg_4]
.text$mn:00002A9D                 add     eax, [ebp+Size]
.text$mn:00002AA0                 push    eax
.text$mn:00002AA1                 mov     ecx, [ebp+var_4]
.text$mn:00002AA4                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00002AA9                 mov     ecx, [ebp+arg_4]
.text$mn:00002AAC                 push    ecx
.text$mn:00002AAD                 push    0
.text$mn:00002AAF                 mov     ecx, [ebp+var_4]
.text$mn:00002AB2                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00002AB7                 jmp     short loc_2AFB
.text$mn:00002AB9 ; ---------------------------------------------------------------------------
.text$mn:00002AB9
.text$mn:00002AB9 loc_2AB9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00002AB9                 push    0
.text$mn:00002ABB                 mov     edx, [ebp+Size]
.text$mn:00002ABE                 push    edx
.text$mn:00002ABF                 mov     ecx, [ebp+var_4]
.text$mn:00002AC2                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00002AC7                 movzx   eax, al
.text$mn:00002ACA                 test    eax, eax
.text$mn:00002ACC                 jz      short loc_2AFB
.text$mn:00002ACE                 mov     ecx, [ebp+Size]
.text$mn:00002AD1                 push    ecx             ; Size
.text$mn:00002AD2                 mov     ecx, [ebp+arg_0]
.text$mn:00002AD5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002ADA                 add     eax, [ebp+arg_4]
.text$mn:00002ADD                 push    eax             ; Src
.text$mn:00002ADE                 mov     ecx, [ebp+var_4]
.text$mn:00002AE1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002AE6                 push    eax             ; Dst
.text$mn:00002AE7                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002AEC                 add     esp, 0Ch
.text$mn:00002AEF                 mov     edx, [ebp+Size]
.text$mn:00002AF2                 push    edx
.text$mn:00002AF3                 mov     ecx, [ebp+var_4]
.text$mn:00002AF6                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002AFB
.text$mn:00002AFB loc_2AFB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00002AFB                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00002AFB                 mov     eax, [ebp+var_4]
.text$mn:00002AFE                 mov     esp, ebp
.text$mn:00002B00                 pop     ebp
.text$mn:00002B01                 retn    0Ch
.text$mn:00002B01 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00002B01
.text$mn:00002B01 _text$mn        ends
.text$mn:00002B01
.text$mn:00002B04 ; ===========================================================================
.text$mn:00002B04
.text$mn:00002B04 ; Segment type: Pure code
.text$mn:00002B04 ; Segment permissions: Read/Execute
.text$mn:00002B04 _text$mn        segment para public 'CODE' use32
.text$mn:00002B04                 assume cs:_text$mn
.text$mn:00002B04                 ;org 2B04h
.text$mn:00002B04 ; COMDAT (pick any)
.text$mn:00002B04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B04
.text$mn:00002B04 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B04
.text$mn:00002B04 ; Attributes: bp-based frame
.text$mn:00002B04
.text$mn:00002B04 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00002B04                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00002B04 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00002B04                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00002B04
.text$mn:00002B04 var_4           = dword ptr -4
.text$mn:00002B04 Str             = dword ptr  8
.text$mn:00002B04
.text$mn:00002B04                 push    ebp
.text$mn:00002B05                 mov     ebp, esp
.text$mn:00002B07                 push    ecx
.text$mn:00002B08                 mov     [ebp+var_4], ecx
.text$mn:00002B0B                 push    490h            ; unsigned int
.text$mn:00002B10                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002B15                 mov     eax, [ebp+Str]
.text$mn:00002B18                 push    eax             ; int
.text$mn:00002B19                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00002B1E                 add     esp, 0Ch
.text$mn:00002B21                 mov     ecx, [ebp+Str]
.text$mn:00002B24                 push    ecx             ; Str
.text$mn:00002B25                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00002B2A                 add     esp, 4
.text$mn:00002B2D                 push    eax             ; Size
.text$mn:00002B2E                 mov     edx, [ebp+Str]
.text$mn:00002B31                 push    edx             ; Src
.text$mn:00002B32                 mov     ecx, [ebp+var_4]
.text$mn:00002B35                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00002B3A                 mov     esp, ebp
.text$mn:00002B3C                 pop     ebp
.text$mn:00002B3D                 retn    4
.text$mn:00002B3D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00002B3D
.text$mn:00002B3D _text$mn        ends
.text$mn:00002B3D
.text$mn:00002B40 ; ===========================================================================
.text$mn:00002B40
.text$mn:00002B40 ; Segment type: Pure code
.text$mn:00002B40 ; Segment permissions: Read/Execute
.text$mn:00002B40 _text$mn        segment para public 'CODE' use32
.text$mn:00002B40                 assume cs:_text$mn
.text$mn:00002B40                 ;org 2B40h
.text$mn:00002B40 ; COMDAT (pick any)
.text$mn:00002B40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B40
.text$mn:00002B40 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B40
.text$mn:00002B40 ; Attributes: bp-based frame
.text$mn:00002B40
.text$mn:00002B40 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00002B40                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00002B40 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00002B40                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00002B40
.text$mn:00002B40 var_4           = dword ptr -4
.text$mn:00002B40 Src             = dword ptr  8
.text$mn:00002B40 Size            = dword ptr  0Ch
.text$mn:00002B40
.text$mn:00002B40                 push    ebp
.text$mn:00002B41                 mov     ebp, esp
.text$mn:00002B43                 push    ecx
.text$mn:00002B44                 mov     [ebp+var_4], ecx
.text$mn:00002B47                 cmp     [ebp+Size], 0
.text$mn:00002B4B                 jz      short loc_2B63
.text$mn:00002B4D                 push    47Fh            ; unsigned int
.text$mn:00002B52                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002B57                 mov     eax, [ebp+Src]
.text$mn:00002B5A                 push    eax             ; int
.text$mn:00002B5B                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00002B60                 add     esp, 0Ch
.text$mn:00002B63
.text$mn:00002B63 loc_2B63:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00002B63                 mov     ecx, [ebp+Src]
.text$mn:00002B66                 push    ecx
.text$mn:00002B67                 mov     ecx, [ebp+var_4]
.text$mn:00002B6A                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00002B6F                 movzx   edx, al
.text$mn:00002B72                 test    edx, edx
.text$mn:00002B74                 jz      short loc_2B96
.text$mn:00002B76                 mov     eax, [ebp+Size]
.text$mn:00002B79                 push    eax
.text$mn:00002B7A                 mov     ecx, [ebp+var_4]
.text$mn:00002B7D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002B82                 mov     ecx, [ebp+Src]
.text$mn:00002B85                 sub     ecx, eax
.text$mn:00002B87                 push    ecx
.text$mn:00002B88                 mov     edx, [ebp+var_4]
.text$mn:00002B8B                 push    edx
.text$mn:00002B8C                 mov     ecx, [ebp+var_4]
.text$mn:00002B8F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00002B94                 jmp     short loc_2BD3
.text$mn:00002B96 ; ---------------------------------------------------------------------------
.text$mn:00002B96
.text$mn:00002B96 loc_2B96:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00002B96                 push    0
.text$mn:00002B98                 mov     eax, [ebp+Size]
.text$mn:00002B9B                 push    eax
.text$mn:00002B9C                 mov     ecx, [ebp+var_4]
.text$mn:00002B9F                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00002BA4                 movzx   ecx, al
.text$mn:00002BA7                 test    ecx, ecx
.text$mn:00002BA9                 jz      short loc_2BD0
.text$mn:00002BAB                 mov     edx, [ebp+Size]
.text$mn:00002BAE                 push    edx             ; Size
.text$mn:00002BAF                 mov     eax, [ebp+Src]
.text$mn:00002BB2                 push    eax             ; Src
.text$mn:00002BB3                 mov     ecx, [ebp+var_4]
.text$mn:00002BB6                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002BBB                 push    eax             ; Dst
.text$mn:00002BBC                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002BC1                 add     esp, 0Ch
.text$mn:00002BC4                 mov     ecx, [ebp+Size]
.text$mn:00002BC7                 push    ecx
.text$mn:00002BC8                 mov     ecx, [ebp+var_4]
.text$mn:00002BCB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002BD0
.text$mn:00002BD0 loc_2BD0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00002BD0                 mov     eax, [ebp+var_4]
.text$mn:00002BD3
.text$mn:00002BD3 loc_2BD3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00002BD3                 mov     esp, ebp
.text$mn:00002BD5                 pop     ebp
.text$mn:00002BD6                 retn    8
.text$mn:00002BD6 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00002BD6
.text$mn:00002BD6 ; ---------------------------------------------------------------------------
.text$mn:00002BD9                 align 4
.text$mn:00002BD9 _text$mn        ends
.text$mn:00002BD9
.text$mn:00002BDC ; ===========================================================================
.text$mn:00002BDC
.text$mn:00002BDC ; Segment type: Pure code
.text$mn:00002BDC ; Segment permissions: Read/Execute
.text$mn:00002BDC _text$mn        segment para public 'CODE' use32
.text$mn:00002BDC                 assume cs:_text$mn
.text$mn:00002BDC                 ;org 2BDCh
.text$mn:00002BDC ; COMDAT (pick any)
.text$mn:00002BDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BDC
.text$mn:00002BDC ; =============== S U B R O U T I N E =======================================
.text$mn:00002BDC
.text$mn:00002BDC ; Attributes: bp-based frame
.text$mn:00002BDC
.text$mn:00002BDC ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00002BDC                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00002BDC ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00002BDC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00002BDC
.text$mn:00002BDC arg_0           = dword ptr  8
.text$mn:00002BDC arg_4           = dword ptr  0Ch
.text$mn:00002BDC
.text$mn:00002BDC                 push    ebp
.text$mn:00002BDD                 mov     ebp, esp
.text$mn:00002BDF                 mov     eax, [ebp+arg_0]
.text$mn:00002BE2                 mov     ecx, [ebp+arg_4]
.text$mn:00002BE5                 mov     dl, [ecx]
.text$mn:00002BE7                 mov     [eax], dl
.text$mn:00002BE9                 pop     ebp
.text$mn:00002BEA                 retn
.text$mn:00002BEA ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00002BEA
.text$mn:00002BEA ; ---------------------------------------------------------------------------
.text$mn:00002BEB                 align 4
.text$mn:00002BEB _text$mn        ends
.text$mn:00002BEB
.text$mn:00002BEC ; ===========================================================================
.text$mn:00002BEC
.text$mn:00002BEC ; Segment type: Pure code
.text$mn:00002BEC ; Segment permissions: Read/Execute
.text$mn:00002BEC _text$mn        segment para public 'CODE' use32
.text$mn:00002BEC                 assume cs:_text$mn
.text$mn:00002BEC                 ;org 2BECh
.text$mn:00002BEC ; COMDAT (pick any)
.text$mn:00002BEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BEC
.text$mn:00002BEC ; =============== S U B R O U T I N E =======================================
.text$mn:00002BEC
.text$mn:00002BEC ; Attributes: bp-based frame
.text$mn:00002BEC
.text$mn:00002BEC ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00002BEC                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00002BEC ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00002BEC                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00002BEC
.text$mn:00002BEC var_4           = dword ptr -4
.text$mn:00002BEC
.text$mn:00002BEC                 push    ebp
.text$mn:00002BED                 mov     ebp, esp
.text$mn:00002BEF                 push    ecx
.text$mn:00002BF0                 mov     [ebp+var_4], ecx
.text$mn:00002BF3                 mov     eax, [ebp+var_4]
.text$mn:00002BF6                 mov     eax, [eax+4]
.text$mn:00002BF9                 mov     esp, ebp
.text$mn:00002BFB                 pop     ebp
.text$mn:00002BFC                 retn
.text$mn:00002BFC ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00002BFC
.text$mn:00002BFC ; ---------------------------------------------------------------------------
.text$mn:00002BFD                 align 10h
.text$mn:00002BFD _text$mn        ends
.text$mn:00002BFD
.text$mn:00002C00 ; ===========================================================================
.text$mn:00002C00
.text$mn:00002C00 ; Segment type: Pure code
.text$mn:00002C00 ; Segment permissions: Read/Execute
.text$mn:00002C00 _text$mn        segment para public 'CODE' use32
.text$mn:00002C00                 assume cs:_text$mn
.text$mn:00002C00                 ;org 2C00h
.text$mn:00002C00 ; COMDAT (pick any)
.text$mn:00002C00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C00
.text$mn:00002C00 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C00
.text$mn:00002C00 ; Attributes: bp-based frame
.text$mn:00002C00
.text$mn:00002C00 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00002C00                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00002C00 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00002C00                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00002C00                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00002C00
.text$mn:00002C00 var_4           = dword ptr -4
.text$mn:00002C00
.text$mn:00002C00                 push    ebp
.text$mn:00002C01                 mov     ebp, esp
.text$mn:00002C03                 push    ecx
.text$mn:00002C04                 mov     [ebp+var_4], ecx
.text$mn:00002C07                 mov     eax, [ebp+var_4]
.text$mn:00002C0A                 mov     eax, [eax+4]
.text$mn:00002C0D                 mov     esp, ebp
.text$mn:00002C0F                 pop     ebp
.text$mn:00002C10                 retn
.text$mn:00002C10 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00002C10
.text$mn:00002C10 ; ---------------------------------------------------------------------------
.text$mn:00002C11                 align 4
.text$mn:00002C11 _text$mn        ends
.text$mn:00002C11
.text$mn:00002C14 ; ===========================================================================
.text$mn:00002C14
.text$mn:00002C14 ; Segment type: Pure code
.text$mn:00002C14 ; Segment permissions: Read/Execute
.text$mn:00002C14 _text$mn        segment para public 'CODE' use32
.text$mn:00002C14                 assume cs:_text$mn
.text$mn:00002C14                 ;org 2C14h
.text$mn:00002C14 ; COMDAT (pick any)
.text$mn:00002C14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C14
.text$mn:00002C14 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C14
.text$mn:00002C14 ; Attributes: bp-based frame
.text$mn:00002C14
.text$mn:00002C14 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00002C14                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002C14 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00002C14                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00002C14
.text$mn:00002C14 var_4           = dword ptr -4
.text$mn:00002C14 Dst             = dword ptr  8
.text$mn:00002C14 Src             = dword ptr  0Ch
.text$mn:00002C14 Size            = dword ptr  10h
.text$mn:00002C14
.text$mn:00002C14                 push    ebp
.text$mn:00002C15                 mov     ebp, esp
.text$mn:00002C17                 push    ecx
.text$mn:00002C18                 cmp     [ebp+Size], 0
.text$mn:00002C1C                 jnz     short loc_2C26
.text$mn:00002C1E                 mov     eax, [ebp+Dst]
.text$mn:00002C21                 mov     [ebp+var_4], eax
.text$mn:00002C24                 jmp     short loc_2C3D
.text$mn:00002C26 ; ---------------------------------------------------------------------------
.text$mn:00002C26
.text$mn:00002C26 loc_2C26:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00002C26                 mov     ecx, [ebp+Size]
.text$mn:00002C29                 push    ecx             ; Size
.text$mn:00002C2A                 mov     edx, [ebp+Src]
.text$mn:00002C2D                 push    edx             ; Src
.text$mn:00002C2E                 mov     eax, [ebp+Dst]
.text$mn:00002C31                 push    eax             ; Dst
.text$mn:00002C32                 call    _memcpy
.text$mn:00002C37                 add     esp, 0Ch
.text$mn:00002C3A                 mov     [ebp+var_4], eax
.text$mn:00002C3D
.text$mn:00002C3D loc_2C3D:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00002C3D                 mov     eax, [ebp+var_4]
.text$mn:00002C40                 mov     esp, ebp
.text$mn:00002C42                 pop     ebp
.text$mn:00002C43                 retn
.text$mn:00002C43 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002C43
.text$mn:00002C43 _text$mn        ends
.text$mn:00002C43
.text$mn:00002C44 ; ===========================================================================
.text$mn:00002C44
.text$mn:00002C44 ; Segment type: Pure code
.text$mn:00002C44 ; Segment permissions: Read/Execute
.text$mn:00002C44 _text$mn        segment para public 'CODE' use32
.text$mn:00002C44                 assume cs:_text$mn
.text$mn:00002C44                 ;org 2C44h
.text$mn:00002C44 ; COMDAT (pick any)
.text$mn:00002C44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C44
.text$mn:00002C44 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C44
.text$mn:00002C44 ; Attributes: bp-based frame
.text$mn:00002C44
.text$mn:00002C44 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00002C44                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00002C44 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00002C44                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00002C44
.text$mn:00002C44 var_4           = dword ptr -4
.text$mn:00002C44 arg_0           = dword ptr  8
.text$mn:00002C44 arg_4           = dword ptr  0Ch
.text$mn:00002C44
.text$mn:00002C44                 push    ebp
.text$mn:00002C45                 mov     ebp, esp
.text$mn:00002C47                 push    ecx
.text$mn:00002C48                 mov     [ebp+var_4], ecx
.text$mn:00002C4B                 mov     eax, [ebp+arg_4]
.text$mn:00002C4E                 push    eax             ; int
.text$mn:00002C4F                 mov     ecx, [ebp+arg_0]
.text$mn:00002C52                 push    ecx             ; void *
.text$mn:00002C53                 mov     ecx, [ebp+var_4]
.text$mn:00002C56                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00002C5B                 mov     esp, ebp
.text$mn:00002C5D                 pop     ebp
.text$mn:00002C5E                 retn    8
.text$mn:00002C5E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00002C5E
.text$mn:00002C5E ; ---------------------------------------------------------------------------
.text$mn:00002C61                 align 4
.text$mn:00002C61 _text$mn        ends
.text$mn:00002C61
.text$mn:00002C64 ; ===========================================================================
.text$mn:00002C64
.text$mn:00002C64 ; Segment type: Pure code
.text$mn:00002C64 ; Segment permissions: Read/Execute
.text$mn:00002C64 _text$mn        segment para public 'CODE' use32
.text$mn:00002C64                 assume cs:_text$mn
.text$mn:00002C64                 ;org 2C64h
.text$mn:00002C64 ; COMDAT (pick any)
.text$mn:00002C64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C64
.text$mn:00002C64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C64
.text$mn:00002C64 ; Attributes: bp-based frame
.text$mn:00002C64
.text$mn:00002C64 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00002C64                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00002C64 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00002C64                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00002C64
.text$mn:00002C64 var_4           = dword ptr -4
.text$mn:00002C64 arg_0           = dword ptr  8
.text$mn:00002C64
.text$mn:00002C64                 push    ebp
.text$mn:00002C65                 mov     ebp, esp
.text$mn:00002C67                 push    ecx
.text$mn:00002C68                 mov     [ebp+var_4], ecx
.text$mn:00002C6B                 mov     eax, [ebp+arg_0]
.text$mn:00002C6E                 push    eax             ; void *
.text$mn:00002C6F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002C74                 add     esp, 4
.text$mn:00002C77                 mov     esp, ebp
.text$mn:00002C79                 pop     ebp
.text$mn:00002C7A                 retn    8
.text$mn:00002C7A ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00002C7A
.text$mn:00002C7A ; ---------------------------------------------------------------------------
.text$mn:00002C7D                 align 10h
.text$mn:00002C7D _text$mn        ends
.text$mn:00002C7D
.text$mn:00002C80 ; ===========================================================================
.text$mn:00002C80
.text$mn:00002C80 ; Segment type: Pure code
.text$mn:00002C80 ; Segment permissions: Read/Execute
.text$mn:00002C80 _text$mn        segment para public 'CODE' use32
.text$mn:00002C80                 assume cs:_text$mn
.text$mn:00002C80                 ;org 2C80h
.text$mn:00002C80 ; COMDAT (pick any)
.text$mn:00002C80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C80
.text$mn:00002C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C80
.text$mn:00002C80 ; Attributes: bp-based frame
.text$mn:00002C80
.text$mn:00002C80 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00002C80                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00002C80 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00002C80                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00002C80
.text$mn:00002C80 var_4           = dword ptr -4
.text$mn:00002C80 arg_0           = dword ptr  8
.text$mn:00002C80
.text$mn:00002C80                 push    ebp
.text$mn:00002C81                 mov     ebp, esp
.text$mn:00002C83                 push    ecx
.text$mn:00002C84                 mov     [ebp+var_4], ecx
.text$mn:00002C87                 mov     eax, [ebp+arg_0]
.text$mn:00002C8A                 push    eax             ; void *
.text$mn:00002C8B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002C90                 add     esp, 4
.text$mn:00002C93                 mov     esp, ebp
.text$mn:00002C95                 pop     ebp
.text$mn:00002C96                 retn    8
.text$mn:00002C96 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00002C96
.text$mn:00002C96 ; ---------------------------------------------------------------------------
.text$mn:00002C99                 align 4
.text$mn:00002C99 _text$mn        ends
.text$mn:00002C99
.text$mn:00002C9C ; ===========================================================================
.text$mn:00002C9C
.text$mn:00002C9C ; Segment type: Pure code
.text$mn:00002C9C ; Segment permissions: Read/Execute
.text$mn:00002C9C _text$mn        segment para public 'CODE' use32
.text$mn:00002C9C                 assume cs:_text$mn
.text$mn:00002C9C                 ;org 2C9Ch
.text$mn:00002C9C ; COMDAT (pick any)
.text$mn:00002C9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C9C
.text$mn:00002C9C ; =============== S U B R O U T I N E =======================================
.text$mn:00002C9C
.text$mn:00002C9C ; Attributes: bp-based frame
.text$mn:00002C9C
.text$mn:00002C9C ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00002C9C                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002C9C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002C9C                                         ; DATA XREF: .rdata:00003B84o
.text$mn:00002C9C
.text$mn:00002C9C var_4           = dword ptr -4
.text$mn:00002C9C arg_0           = dword ptr  8
.text$mn:00002C9C arg_4           = dword ptr  0Ch
.text$mn:00002C9C
.text$mn:00002C9C                 push    ebp
.text$mn:00002C9D                 mov     ebp, esp
.text$mn:00002C9F                 push    ecx
.text$mn:00002CA0                 mov     [ebp+var_4], ecx
.text$mn:00002CA3                 mov     eax, [ebp+arg_4]
.text$mn:00002CA6                 push    eax             ; int
.text$mn:00002CA7                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002CAC                 add     esp, 4
.text$mn:00002CAF                 test    eax, eax
.text$mn:00002CB1                 jz      short loc_2CCC
.text$mn:00002CB3                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00002CB8                 push    eax             ; struct std::error_category *
.text$mn:00002CB9                 mov     ecx, [ebp+arg_4]
.text$mn:00002CBC                 push    ecx             ; int
.text$mn:00002CBD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002CC0                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002CC5                 mov     eax, [ebp+arg_0]
.text$mn:00002CC8                 jmp     short loc_2CE1
.text$mn:00002CCA ; ---------------------------------------------------------------------------
.text$mn:00002CCA                 jmp     short loc_2CE1
.text$mn:00002CCC ; ---------------------------------------------------------------------------
.text$mn:00002CCC
.text$mn:00002CCC loc_2CCC:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00002CCC                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00002CD1                 push    eax             ; struct std::error_category *
.text$mn:00002CD2                 mov     edx, [ebp+arg_4]
.text$mn:00002CD5                 push    edx             ; int
.text$mn:00002CD6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002CD9                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002CDE                 mov     eax, [ebp+arg_0]
.text$mn:00002CE1
.text$mn:00002CE1 loc_2CE1:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00002CE1                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00002CE1                 mov     esp, ebp
.text$mn:00002CE3                 pop     ebp
.text$mn:00002CE4                 retn    8
.text$mn:00002CE4 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002CE4
.text$mn:00002CE4 ; ---------------------------------------------------------------------------
.text$mn:00002CE7                 align 4
.text$mn:00002CE7 _text$mn        ends
.text$mn:00002CE7
.text$mn:00002CE8 ; ===========================================================================
.text$mn:00002CE8
.text$mn:00002CE8 ; Segment type: Pure code
.text$mn:00002CE8 ; Segment permissions: Read/Execute
.text$mn:00002CE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002CE8                 assume cs:_text$mn
.text$mn:00002CE8                 ;org 2CE8h
.text$mn:00002CE8 ; COMDAT (pick any)
.text$mn:00002CE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CE8
.text$mn:00002CE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CE8
.text$mn:00002CE8 ; Attributes: bp-based frame
.text$mn:00002CE8
.text$mn:00002CE8 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00002CE8                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002CE8 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002CE8                                         ; DATA XREF: .rdata:00003AF4o
.text$mn:00002CE8                                         ; .rdata:00003B10o ...
.text$mn:00002CE8
.text$mn:00002CE8 var_4           = dword ptr -4
.text$mn:00002CE8 arg_0           = dword ptr  8
.text$mn:00002CE8 arg_4           = dword ptr  0Ch
.text$mn:00002CE8
.text$mn:00002CE8                 push    ebp
.text$mn:00002CE9                 mov     ebp, esp
.text$mn:00002CEB                 push    ecx
.text$mn:00002CEC                 mov     [ebp+var_4], ecx
.text$mn:00002CEF                 mov     eax, [ebp+var_4]
.text$mn:00002CF2                 push    eax             ; struct std::error_category *
.text$mn:00002CF3                 mov     ecx, [ebp+arg_4]
.text$mn:00002CF6                 push    ecx             ; int
.text$mn:00002CF7                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002CFA                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002CFF                 mov     eax, [ebp+arg_0]
.text$mn:00002D02                 mov     esp, ebp
.text$mn:00002D04                 pop     ebp
.text$mn:00002D05                 retn    8
.text$mn:00002D05 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002D05
.text$mn:00002D05 _text$mn        ends
.text$mn:00002D05
.text$mn:00002D08 ; ===========================================================================
.text$mn:00002D08
.text$mn:00002D08 ; Segment type: Pure code
.text$mn:00002D08 ; Segment permissions: Read/Execute
.text$mn:00002D08 _text$mn        segment para public 'CODE' use32
.text$mn:00002D08                 assume cs:_text$mn
.text$mn:00002D08                 ;org 2D08h
.text$mn:00002D08 ; COMDAT (pick any)
.text$mn:00002D08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D08
.text$mn:00002D08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D08
.text$mn:00002D08 ; Attributes: bp-based frame
.text$mn:00002D08
.text$mn:00002D08 ; void __thiscall Splitter::destroy(Splitter *__hidden this)
.text$mn:00002D08                 public ?destroy@Splitter@@UAEXXZ
.text$mn:00002D08 ?destroy@Splitter@@UAEXXZ proc near     ; DATA XREF: .rdata:00003BE4o
.text$mn:00002D08
.text$mn:00002D08 var_4           = dword ptr -4
.text$mn:00002D08
.text$mn:00002D08                 push    ebp
.text$mn:00002D09                 mov     ebp, esp
.text$mn:00002D0B                 push    ecx
.text$mn:00002D0C                 mov     [ebp+var_4], ecx
.text$mn:00002D0F                 mov     eax, [ebp+var_4]
.text$mn:00002D12                 mov     ecx, [eax+0Ch]
.text$mn:00002D15                 push    ecx             ; hWnd
.text$mn:00002D16                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:00002D1C                 mov     esp, ebp
.text$mn:00002D1E                 pop     ebp
.text$mn:00002D1F                 retn
.text$mn:00002D1F ?destroy@Splitter@@UAEXXZ endp
.text$mn:00002D1F
.text$mn:00002D1F _text$mn        ends
.text$mn:00002D1F
.text$mn:00002D20 ; ===========================================================================
.text$mn:00002D20
.text$mn:00002D20 ; Segment type: Pure code
.text$mn:00002D20 ; Segment permissions: Read/Execute
.text$mn:00002D20 _text$mn        segment para public 'CODE' use32
.text$mn:00002D20                 assume cs:_text$mn
.text$mn:00002D20                 ;org 2D20h
.text$mn:00002D20 ; COMDAT (pick any)
.text$mn:00002D20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D20
.text$mn:00002D20 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D20
.text$mn:00002D20 ; Attributes: bp-based frame
.text$mn:00002D20
.text$mn:00002D20 ; void __thiscall Window::display(Window *this, bool)
.text$mn:00002D20                 public ?display@Window@@UBEX_N@Z
.text$mn:00002D20 ?display@Window@@UBEX_N@Z proc near     ; DATA XREF: .rdata:00003BB4o
.text$mn:00002D20                                         ; .rdata:00003BE8o
.text$mn:00002D20
.text$mn:00002D20 var_8           = dword ptr -8
.text$mn:00002D20 nCmdShow        = dword ptr -4
.text$mn:00002D20 arg_0           = byte ptr  8
.text$mn:00002D20
.text$mn:00002D20                 push    ebp
.text$mn:00002D21                 mov     ebp, esp
.text$mn:00002D23                 sub     esp, 8
.text$mn:00002D26                 mov     [ebp+var_8], ecx
.text$mn:00002D29                 movzx   eax, [ebp+arg_0]
.text$mn:00002D2D                 test    eax, eax
.text$mn:00002D2F                 jz      short loc_2D3A
.text$mn:00002D31                 mov     [ebp+nCmdShow], 5
.text$mn:00002D38                 jmp     short loc_2D41
.text$mn:00002D3A ; ---------------------------------------------------------------------------
.text$mn:00002D3A
.text$mn:00002D3A loc_2D3A:                               ; CODE XREF: Window::display(bool)+Fj
.text$mn:00002D3A                 mov     [ebp+nCmdShow], 0
.text$mn:00002D41
.text$mn:00002D41 loc_2D41:                               ; CODE XREF: Window::display(bool)+18j
.text$mn:00002D41                 mov     ecx, [ebp+nCmdShow]
.text$mn:00002D44                 push    ecx             ; nCmdShow
.text$mn:00002D45                 mov     edx, [ebp+var_8]
.text$mn:00002D48                 mov     eax, [edx+0Ch]
.text$mn:00002D4B                 push    eax             ; hWnd
.text$mn:00002D4C                 call    dword ptr ds:__imp__ShowWindow@8 ; ShowWindow(x,x)
.text$mn:00002D52                 mov     esp, ebp
.text$mn:00002D54                 pop     ebp
.text$mn:00002D55                 retn    4
.text$mn:00002D55 ?display@Window@@UBEX_N@Z endp
.text$mn:00002D55
.text$mn:00002D55 _text$mn        ends
.text$mn:00002D55
.text$mn:00002D58 ; ===========================================================================
.text$mn:00002D58
.text$mn:00002D58 ; Segment type: Pure code
.text$mn:00002D58 ; Segment permissions: Read/Execute
.text$mn:00002D58 _text$mn        segment para public 'CODE' use32
.text$mn:00002D58                 assume cs:_text$mn
.text$mn:00002D58                 ;org 2D58h
.text$mn:00002D58 ; COMDAT (pick any)
.text$mn:00002D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D58
.text$mn:00002D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D58
.text$mn:00002D58 ; Attributes: bp-based frame
.text$mn:00002D58
.text$mn:00002D58 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00002D58                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00002D58 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00002D58                                         ; DATA XREF: .rdata:00003AF8o
.text$mn:00002D58                                         ; .rdata:00003B14o ...
.text$mn:00002D58
.text$mn:00002D58 var_8           = dword ptr -8
.text$mn:00002D58 var_4           = dword ptr -4
.text$mn:00002D58 arg_0           = dword ptr  8
.text$mn:00002D58 arg_4           = dword ptr  0Ch
.text$mn:00002D58
.text$mn:00002D58                 push    ebp
.text$mn:00002D59                 mov     ebp, esp
.text$mn:00002D5B                 sub     esp, 8
.text$mn:00002D5E                 mov     [ebp+var_8], ecx
.text$mn:00002D61                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002D64                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00002D69                 push    eax
.text$mn:00002D6A                 mov     ecx, [ebp+var_8]
.text$mn:00002D6D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00002D72                 movzx   eax, al
.text$mn:00002D75                 test    eax, eax
.text$mn:00002D77                 jz      short loc_2D8F
.text$mn:00002D79                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002D7C                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00002D81                 cmp     eax, [ebp+arg_4]
.text$mn:00002D84                 jnz     short loc_2D8F
.text$mn:00002D86                 mov     [ebp+var_4], 1
.text$mn:00002D8D                 jmp     short loc_2D96
.text$mn:00002D8F ; ---------------------------------------------------------------------------
.text$mn:00002D8F
.text$mn:00002D8F loc_2D8F:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00002D8F                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00002D8F                 mov     [ebp+var_4], 0
.text$mn:00002D96
.text$mn:00002D96 loc_2D96:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00002D96                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002D99                 mov     esp, ebp
.text$mn:00002D9B                 pop     ebp
.text$mn:00002D9C                 retn    8
.text$mn:00002D9C ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00002D9C
.text$mn:00002D9C ; ---------------------------------------------------------------------------
.text$mn:00002D9F                 align 10h
.text$mn:00002D9F _text$mn        ends
.text$mn:00002D9F
.text$mn:00002DA0 ; ===========================================================================
.text$mn:00002DA0
.text$mn:00002DA0 ; Segment type: Pure code
.text$mn:00002DA0 ; Segment permissions: Read/Execute
.text$mn:00002DA0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DA0                 assume cs:_text$mn
.text$mn:00002DA0                 ;org 2DA0h
.text$mn:00002DA0 ; COMDAT (pick any)
.text$mn:00002DA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DA0
.text$mn:00002DA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DA0
.text$mn:00002DA0 ; Attributes: bp-based frame
.text$mn:00002DA0
.text$mn:00002DA0 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00002DA0                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00002DA0 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00002DA0                                         ; DATA XREF: .rdata:00003AFCo
.text$mn:00002DA0                                         ; .rdata:00003B18o ...
.text$mn:00002DA0
.text$mn:00002DA0 var_C           = byte ptr -0Ch
.text$mn:00002DA0 var_4           = dword ptr -4
.text$mn:00002DA0 arg_0           = dword ptr  8
.text$mn:00002DA0 arg_4           = dword ptr  0Ch
.text$mn:00002DA0
.text$mn:00002DA0                 push    ebp
.text$mn:00002DA1                 mov     ebp, esp
.text$mn:00002DA3                 sub     esp, 0Ch
.text$mn:00002DA6                 mov     [ebp+var_4], ecx
.text$mn:00002DA9                 mov     eax, [ebp+arg_4]
.text$mn:00002DAC                 push    eax             ; std::error_condition *
.text$mn:00002DAD                 mov     ecx, [ebp+arg_0]
.text$mn:00002DB0                 push    ecx
.text$mn:00002DB1                 lea     edx, [ebp+var_C]
.text$mn:00002DB4                 push    edx
.text$mn:00002DB5                 mov     eax, [ebp+var_4]
.text$mn:00002DB8                 mov     edx, [eax]
.text$mn:00002DBA                 mov     ecx, [ebp+var_4]
.text$mn:00002DBD                 mov     eax, [edx+0Ch]
.text$mn:00002DC0                 call    eax
.text$mn:00002DC2                 mov     ecx, eax
.text$mn:00002DC4                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00002DC9                 mov     esp, ebp
.text$mn:00002DCB                 pop     ebp
.text$mn:00002DCC                 retn    8
.text$mn:00002DCC ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00002DCC
.text$mn:00002DCC ; ---------------------------------------------------------------------------
.text$mn:00002DCF                 align 10h
.text$mn:00002DCF _text$mn        ends
.text$mn:00002DCF
.text$mn:00002DD0 ; ===========================================================================
.text$mn:00002DD0
.text$mn:00002DD0 ; Segment type: Pure code
.text$mn:00002DD0 ; Segment permissions: Read/Execute
.text$mn:00002DD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DD0                 assume cs:_text$mn
.text$mn:00002DD0                 ;org 2DD0h
.text$mn:00002DD0 ; COMDAT (pick any)
.text$mn:00002DD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DD0
.text$mn:00002DD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DD0
.text$mn:00002DD0 ; Attributes: bp-based frame
.text$mn:00002DD0
.text$mn:00002DD0 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00002DD0                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00002DD0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00002DD0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00002DD0
.text$mn:00002DD0 var_4           = dword ptr -4
.text$mn:00002DD0 arg_0           = dword ptr  8
.text$mn:00002DD0
.text$mn:00002DD0                 push    ebp
.text$mn:00002DD1                 mov     ebp, esp
.text$mn:00002DD3                 push    ecx
.text$mn:00002DD4                 mov     [ebp+var_4], ecx
.text$mn:00002DD7                 mov     eax, [ebp+var_4]
.text$mn:00002DDA                 mov     ecx, [eax+14h]
.text$mn:00002DDD                 cmp     ecx, [ebp+arg_0]
.text$mn:00002DE0                 jnb     short loc_2DEA
.text$mn:00002DE2                 mov     ecx, [ebp+var_4]
.text$mn:00002DE5                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002DEA
.text$mn:00002DEA loc_2DEA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00002DEA                 mov     edx, [ebp+arg_0]
.text$mn:00002DED                 push    edx
.text$mn:00002DEE                 mov     ecx, [ebp+var_4]
.text$mn:00002DF1                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002DF6                 mov     eax, [ebp+var_4]
.text$mn:00002DF9                 mov     esp, ebp
.text$mn:00002DFB                 pop     ebp
.text$mn:00002DFC                 retn    4
.text$mn:00002DFC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00002DFC
.text$mn:00002DFC ; ---------------------------------------------------------------------------
.text$mn:00002DFF                 align 10h
.text$mn:00002DFF _text$mn        ends
.text$mn:00002DFF
.text$mn:00002E00 ; ===========================================================================
.text$mn:00002E00
.text$mn:00002E00 ; Segment type: Pure code
.text$mn:00002E00 ; Segment permissions: Read/Execute
.text$mn:00002E00 _text$mn        segment para public 'CODE' use32
.text$mn:00002E00                 assume cs:_text$mn
.text$mn:00002E00                 ;org 2E00h
.text$mn:00002E00 ; COMDAT (pick any)
.text$mn:00002E00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E00
.text$mn:00002E00 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E00
.text$mn:00002E00 ; Attributes: bp-based frame
.text$mn:00002E00
.text$mn:00002E00 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00002E00                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00002E00 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00002E00                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00002E00
.text$mn:00002E00 var_C           = dword ptr -0Ch
.text$mn:00002E00 Dst             = dword ptr -8
.text$mn:00002E00 var_4           = dword ptr -4
.text$mn:00002E00 arg_0           = dword ptr  8
.text$mn:00002E00 arg_4           = dword ptr  0Ch
.text$mn:00002E00
.text$mn:00002E00                 push    ebp
.text$mn:00002E01                 mov     ebp, esp
.text$mn:00002E03                 sub     esp, 0Ch
.text$mn:00002E06                 mov     [ebp+var_4], ecx
.text$mn:00002E09                 mov     eax, [ebp+var_4]
.text$mn:00002E0C                 mov     ecx, [eax+14h]
.text$mn:00002E0F                 cmp     ecx, [ebp+arg_0]
.text$mn:00002E12                 jnb     short loc_2E1C
.text$mn:00002E14                 mov     ecx, [ebp+var_4]
.text$mn:00002E17                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002E1C
.text$mn:00002E1C loc_2E1C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00002E1C                 mov     edx, [ebp+var_4]
.text$mn:00002E1F                 mov     eax, [edx+14h]
.text$mn:00002E22                 sub     eax, [ebp+arg_0]
.text$mn:00002E25                 cmp     eax, [ebp+arg_4]
.text$mn:00002E28                 ja      short loc_2E38
.text$mn:00002E2A                 mov     ecx, [ebp+arg_0]
.text$mn:00002E2D                 push    ecx
.text$mn:00002E2E                 mov     ecx, [ebp+var_4]
.text$mn:00002E31                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002E36                 jmp     short loc_2E7E
.text$mn:00002E38 ; ---------------------------------------------------------------------------
.text$mn:00002E38
.text$mn:00002E38 loc_2E38:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00002E38                 cmp     [ebp+arg_4], 0
.text$mn:00002E3C                 jbe     short loc_2E7E
.text$mn:00002E3E                 mov     ecx, [ebp+var_4]
.text$mn:00002E41                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002E46                 add     eax, [ebp+arg_0]
.text$mn:00002E49                 mov     [ebp+Dst], eax
.text$mn:00002E4C                 mov     edx, [ebp+var_4]
.text$mn:00002E4F                 mov     eax, [edx+14h]
.text$mn:00002E52                 sub     eax, [ebp+arg_4]
.text$mn:00002E55                 mov     [ebp+var_C], eax
.text$mn:00002E58                 mov     ecx, [ebp+var_C]
.text$mn:00002E5B                 sub     ecx, [ebp+arg_0]
.text$mn:00002E5E                 push    ecx             ; Size
.text$mn:00002E5F                 mov     edx, [ebp+Dst]
.text$mn:00002E62                 add     edx, [ebp+arg_4]
.text$mn:00002E65                 push    edx             ; Src
.text$mn:00002E66                 mov     eax, [ebp+Dst]
.text$mn:00002E69                 push    eax             ; Dst
.text$mn:00002E6A                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00002E6F                 add     esp, 0Ch
.text$mn:00002E72                 mov     ecx, [ebp+var_C]
.text$mn:00002E75                 push    ecx
.text$mn:00002E76                 mov     ecx, [ebp+var_4]
.text$mn:00002E79                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002E7E
.text$mn:00002E7E loc_2E7E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00002E7E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00002E7E                 mov     eax, [ebp+var_4]
.text$mn:00002E81                 mov     esp, ebp
.text$mn:00002E83                 pop     ebp
.text$mn:00002E84                 retn    8
.text$mn:00002E84 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00002E84
.text$mn:00002E84 ; ---------------------------------------------------------------------------
.text$mn:00002E87                 align 4
.text$mn:00002E87 _text$mn        ends
.text$mn:00002E87
.text$mn:00002E88 ; ===========================================================================
.text$mn:00002E88
.text$mn:00002E88 ; Segment type: Pure code
.text$mn:00002E88 ; Segment permissions: Read/Execute
.text$mn:00002E88 _text$mn        segment para public 'CODE' use32
.text$mn:00002E88                 assume cs:_text$mn
.text$mn:00002E88                 ;org 2E88h
.text$mn:00002E88 ; COMDAT (pick any)
.text$mn:00002E88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E88
.text$mn:00002E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E88
.text$mn:00002E88 ; Attributes: bp-based frame
.text$mn:00002E88
.text$mn:00002E88 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00002E88                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00002E88 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002E88                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00002E88                 push    ebp
.text$mn:00002E89                 mov     ebp, esp
.text$mn:00002E8B                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00002E90                 pop     ebp
.text$mn:00002E91                 retn
.text$mn:00002E91 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002E91
.text$mn:00002E91 ; ---------------------------------------------------------------------------
.text$mn:00002E92                 align 4
.text$mn:00002E92 _text$mn        ends
.text$mn:00002E92
.text$mn:00002E94 ; ===========================================================================
.text$mn:00002E94
.text$mn:00002E94 ; Segment type: Pure code
.text$mn:00002E94 ; Segment permissions: Read/Execute
.text$mn:00002E94 _text$mn        segment para public 'CODE' use32
.text$mn:00002E94                 assume cs:_text$mn
.text$mn:00002E94                 ;org 2E94h
.text$mn:00002E94 ; COMDAT (pick any)
.text$mn:00002E94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E94
.text$mn:00002E94 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E94
.text$mn:00002E94 ; Attributes: bp-based frame
.text$mn:00002E94
.text$mn:00002E94 ; void __thiscall Window::getClientRect(Window *this, struct tagRECT *)
.text$mn:00002E94                 public ?getClientRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:00002E94 ?getClientRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:00002E94                                         ; DATA XREF: .rdata:00003BC4o
.text$mn:00002E94                                         ; .rdata:00003BF8o
.text$mn:00002E94
.text$mn:00002E94 var_4           = dword ptr -4
.text$mn:00002E94 lpRect          = dword ptr  8
.text$mn:00002E94
.text$mn:00002E94                 push    ebp
.text$mn:00002E95                 mov     ebp, esp
.text$mn:00002E97                 push    ecx
.text$mn:00002E98                 mov     [ebp+var_4], ecx
.text$mn:00002E9B                 mov     eax, [ebp+lpRect]
.text$mn:00002E9E                 push    eax             ; lpRect
.text$mn:00002E9F                 mov     ecx, [ebp+var_4]
.text$mn:00002EA2                 mov     edx, [ecx+0Ch]
.text$mn:00002EA5                 push    edx             ; hWnd
.text$mn:00002EA6                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00002EAC                 mov     esp, ebp
.text$mn:00002EAE                 pop     ebp
.text$mn:00002EAF                 retn    4
.text$mn:00002EAF ?getClientRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:00002EAF
.text$mn:00002EAF ; ---------------------------------------------------------------------------
.text$mn:00002EB2                 align 4
.text$mn:00002EB2 _text$mn        ends
.text$mn:00002EB2
.text$mn:00002EB4 ; ===========================================================================
.text$mn:00002EB4
.text$mn:00002EB4 ; Segment type: Pure code
.text$mn:00002EB4 ; Segment permissions: Read/Execute
.text$mn:00002EB4 _text$mn        segment para public 'CODE' use32
.text$mn:00002EB4                 assume cs:_text$mn
.text$mn:00002EB4                 ;org 2EB4h
.text$mn:00002EB4 ; COMDAT (pick any)
.text$mn:00002EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002EB4
.text$mn:00002EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EB4
.text$mn:00002EB4 ; Attributes: bp-based frame
.text$mn:00002EB4
.text$mn:00002EB4 ; int __thiscall Window::getHeight(Window *__hidden this)
.text$mn:00002EB4                 public ?getHeight@Window@@UBEHXZ
.text$mn:00002EB4 ?getHeight@Window@@UBEHXZ proc near     ; DATA XREF: .rdata:00003BD0o
.text$mn:00002EB4                                         ; .rdata:00003C04o
.text$mn:00002EB4
.text$mn:00002EB4 var_18          = dword ptr -18h
.text$mn:00002EB4 Rect            = tagRECT ptr -14h
.text$mn:00002EB4 var_4           = dword ptr -4
.text$mn:00002EB4
.text$mn:00002EB4                 push    ebp
.text$mn:00002EB5                 mov     ebp, esp
.text$mn:00002EB7                 sub     esp, 18h
.text$mn:00002EBA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002EBF                 xor     eax, ebp
.text$mn:00002EC1                 mov     [ebp+var_4], eax
.text$mn:00002EC4                 mov     [ebp+var_18], ecx
.text$mn:00002EC7                 lea     eax, [ebp+Rect]
.text$mn:00002ECA                 push    eax             ; lpRect
.text$mn:00002ECB                 mov     ecx, [ebp+var_18]
.text$mn:00002ECE                 mov     edx, [ecx+0Ch]
.text$mn:00002ED1                 push    edx             ; hWnd
.text$mn:00002ED2                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00002ED8                 mov     eax, [ebp+var_18]
.text$mn:00002EDB                 mov     ecx, [eax+0Ch]
.text$mn:00002EDE                 push    ecx             ; hWnd
.text$mn:00002EDF                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:00002EE5                 cmp     eax, 1
.text$mn:00002EE8                 jnz     short loc_2EF2
.text$mn:00002EEA                 mov     eax, [ebp+Rect.bottom]
.text$mn:00002EED                 sub     eax, [ebp+Rect.top]
.text$mn:00002EF0                 jmp     short loc_2EF4
.text$mn:00002EF2 ; ---------------------------------------------------------------------------
.text$mn:00002EF2
.text$mn:00002EF2 loc_2EF2:                               ; CODE XREF: Window::getHeight(void)+34j
.text$mn:00002EF2                 xor     eax, eax
.text$mn:00002EF4
.text$mn:00002EF4 loc_2EF4:                               ; CODE XREF: Window::getHeight(void)+3Cj
.text$mn:00002EF4                 mov     ecx, [ebp+var_4]
.text$mn:00002EF7                 xor     ecx, ebp
.text$mn:00002EF9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002EFE                 mov     esp, ebp
.text$mn:00002F00                 pop     ebp
.text$mn:00002F01                 retn
.text$mn:00002F01 ?getHeight@Window@@UBEHXZ endp
.text$mn:00002F01
.text$mn:00002F01 ; ---------------------------------------------------------------------------
.text$mn:00002F02                 align 4
.text$mn:00002F02 _text$mn        ends
.text$mn:00002F02
.text$mn:00002F04 ; ===========================================================================
.text$mn:00002F04
.text$mn:00002F04 ; Segment type: Pure code
.text$mn:00002F04 ; Segment permissions: Read/Execute
.text$mn:00002F04 _text$mn        segment para public 'CODE' use32
.text$mn:00002F04                 assume cs:_text$mn
.text$mn:00002F04                 ;org 2F04h
.text$mn:00002F04 ; COMDAT (pick any)
.text$mn:00002F04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F04
.text$mn:00002F04 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F04
.text$mn:00002F04 ; Attributes: bp-based frame
.text$mn:00002F04
.text$mn:00002F04 ; int __thiscall Splitter::getSplitterFixPosX(Splitter *__hidden this)
.text$mn:00002F04                 public ?getSplitterFixPosX@Splitter@@AAEHXZ
.text$mn:00002F04 ?getSplitterFixPosX@Splitter@@AAEHXZ proc near
.text$mn:00002F04                                         ; CODE XREF: Splitter::resizeSpliter(tagRECT *)+C4p
.text$mn:00002F04
.text$mn:00002F04 var_C           = dword ptr -0Ch
.text$mn:00002F04 var_8           = dword ptr -8
.text$mn:00002F04 var_4           = dword ptr -4
.text$mn:00002F04
.text$mn:00002F04                 push    ebp
.text$mn:00002F05                 mov     ebp, esp
.text$mn:00002F07                 sub     esp, 0Ch
.text$mn:00002F0A                 mov     [ebp+var_4], ecx
.text$mn:00002F0D                 push    0               ; lParam
.text$mn:00002F0F                 push    0               ; wParam
.text$mn:00002F11                 push    13A1h           ; Msg
.text$mn:00002F16                 mov     eax, [ebp+var_4]
.text$mn:00002F19                 mov     ecx, [eax+8]
.text$mn:00002F1C                 push    ecx             ; hWnd
.text$mn:00002F1D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00002F23                 mov     [ebp+var_8], eax
.text$mn:00002F26                 mov     edx, [ebp+var_8]
.text$mn:00002F29                 shr     edx, 10h
.text$mn:00002F2C                 and     edx, 0FFFFh
.text$mn:00002F32                 movzx   eax, dx
.text$mn:00002F35                 cmp     eax, 2
.text$mn:00002F38                 jnz     short loc_2F45
.text$mn:00002F3A                 mov     ecx, [ebp+var_4]
.text$mn:00002F3D                 mov     edx, [ecx+24h]
.text$mn:00002F40                 mov     [ebp+var_C], edx
.text$mn:00002F43                 jmp     short loc_2F4C
.text$mn:00002F45 ; ---------------------------------------------------------------------------
.text$mn:00002F45
.text$mn:00002F45 loc_2F45:                               ; CODE XREF: Splitter::getSplitterFixPosX(void)+34j
.text$mn:00002F45                 mov     [ebp+var_C], 0
.text$mn:00002F4C
.text$mn:00002F4C loc_2F4C:                               ; CODE XREF: Splitter::getSplitterFixPosX(void)+3Fj
.text$mn:00002F4C                 mov     eax, [ebp+var_8]
.text$mn:00002F4F                 and     eax, 0FFFFh
.text$mn:00002F54                 movzx   eax, ax
.text$mn:00002F57                 sub     eax, [ebp+var_C]
.text$mn:00002F5A                 mov     esp, ebp
.text$mn:00002F5C                 pop     ebp
.text$mn:00002F5D                 retn
.text$mn:00002F5D ?getSplitterFixPosX@Splitter@@AAEHXZ endp
.text$mn:00002F5D
.text$mn:00002F5D ; ---------------------------------------------------------------------------
.text$mn:00002F5E                 align 10h
.text$mn:00002F5E _text$mn        ends
.text$mn:00002F5E
.text$mn:00002F60 ; ===========================================================================
.text$mn:00002F60
.text$mn:00002F60 ; Segment type: Pure code
.text$mn:00002F60 ; Segment permissions: Read/Execute
.text$mn:00002F60 _text$mn        segment para public 'CODE' use32
.text$mn:00002F60                 assume cs:_text$mn
.text$mn:00002F60                 ;org 2F60h
.text$mn:00002F60 ; COMDAT (pick any)
.text$mn:00002F60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F60
.text$mn:00002F60 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F60
.text$mn:00002F60 ; Attributes: bp-based frame
.text$mn:00002F60
.text$mn:00002F60 ; int __thiscall Splitter::getSplitterFixPosY(Splitter *__hidden this)
.text$mn:00002F60                 public ?getSplitterFixPosY@Splitter@@AAEHXZ
.text$mn:00002F60 ?getSplitterFixPosY@Splitter@@AAEHXZ proc near
.text$mn:00002F60                                         ; CODE XREF: Splitter::resizeSpliter(tagRECT *)+84p
.text$mn:00002F60
.text$mn:00002F60 var_C           = dword ptr -0Ch
.text$mn:00002F60 var_8           = dword ptr -8
.text$mn:00002F60 var_4           = dword ptr -4
.text$mn:00002F60
.text$mn:00002F60                 push    ebp
.text$mn:00002F61                 mov     ebp, esp
.text$mn:00002F63                 sub     esp, 0Ch
.text$mn:00002F66                 mov     [ebp+var_4], ecx
.text$mn:00002F69                 push    0               ; lParam
.text$mn:00002F6B                 push    0               ; wParam
.text$mn:00002F6D                 push    13A2h           ; Msg
.text$mn:00002F72                 mov     eax, [ebp+var_4]
.text$mn:00002F75                 mov     ecx, [eax+8]
.text$mn:00002F78                 push    ecx             ; hWnd
.text$mn:00002F79                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00002F7F                 mov     [ebp+var_8], eax
.text$mn:00002F82                 mov     edx, [ebp+var_8]
.text$mn:00002F85                 shr     edx, 10h
.text$mn:00002F88                 and     edx, 0FFFFh
.text$mn:00002F8E                 movzx   eax, dx
.text$mn:00002F91                 cmp     eax, 2
.text$mn:00002F94                 jnz     short loc_2FA1
.text$mn:00002F96                 mov     ecx, [ebp+var_4]
.text$mn:00002F99                 mov     edx, [ecx+24h]
.text$mn:00002F9C                 mov     [ebp+var_C], edx
.text$mn:00002F9F                 jmp     short loc_2FA8
.text$mn:00002FA1 ; ---------------------------------------------------------------------------
.text$mn:00002FA1
.text$mn:00002FA1 loc_2FA1:                               ; CODE XREF: Splitter::getSplitterFixPosY(void)+34j
.text$mn:00002FA1                 mov     [ebp+var_C], 0
.text$mn:00002FA8
.text$mn:00002FA8 loc_2FA8:                               ; CODE XREF: Splitter::getSplitterFixPosY(void)+3Fj
.text$mn:00002FA8                 mov     eax, [ebp+var_8]
.text$mn:00002FAB                 and     eax, 0FFFFh
.text$mn:00002FB0                 movzx   eax, ax
.text$mn:00002FB3                 sub     eax, [ebp+var_C]
.text$mn:00002FB6                 mov     esp, ebp
.text$mn:00002FB8                 pop     ebp
.text$mn:00002FB9                 retn
.text$mn:00002FB9 ?getSplitterFixPosY@Splitter@@AAEHXZ endp
.text$mn:00002FB9
.text$mn:00002FB9 ; ---------------------------------------------------------------------------
.text$mn:00002FBA                 align 4
.text$mn:00002FBA _text$mn        ends
.text$mn:00002FBA
.text$mn:00002FBC ; ===========================================================================
.text$mn:00002FBC
.text$mn:00002FBC ; Segment type: Pure code
.text$mn:00002FBC ; Segment permissions: Read/Execute
.text$mn:00002FBC _text$mn        segment para public 'CODE' use32
.text$mn:00002FBC                 assume cs:_text$mn
.text$mn:00002FBC                 ;org 2FBCh
.text$mn:00002FBC ; COMDAT (pick any)
.text$mn:00002FBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FBC
.text$mn:00002FBC ; =============== S U B R O U T I N E =======================================
.text$mn:00002FBC
.text$mn:00002FBC ; Attributes: bp-based frame
.text$mn:00002FBC
.text$mn:00002FBC ; int __thiscall Window::getWidth(Window *__hidden this)
.text$mn:00002FBC                 public ?getWidth@Window@@UBEHXZ
.text$mn:00002FBC ?getWidth@Window@@UBEHXZ proc near      ; DATA XREF: .rdata:00003BCCo
.text$mn:00002FBC                                         ; .rdata:00003C00o
.text$mn:00002FBC
.text$mn:00002FBC var_18          = dword ptr -18h
.text$mn:00002FBC Rect            = tagRECT ptr -14h
.text$mn:00002FBC var_4           = dword ptr -4
.text$mn:00002FBC
.text$mn:00002FBC                 push    ebp
.text$mn:00002FBD                 mov     ebp, esp
.text$mn:00002FBF                 sub     esp, 18h
.text$mn:00002FC2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002FC7                 xor     eax, ebp
.text$mn:00002FC9                 mov     [ebp+var_4], eax
.text$mn:00002FCC                 mov     [ebp+var_18], ecx
.text$mn:00002FCF                 lea     eax, [ebp+Rect]
.text$mn:00002FD2                 push    eax             ; lpRect
.text$mn:00002FD3                 mov     ecx, [ebp+var_18]
.text$mn:00002FD6                 mov     edx, [ecx+0Ch]
.text$mn:00002FD9                 push    edx             ; hWnd
.text$mn:00002FDA                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00002FE0                 mov     eax, [ebp+Rect.right]
.text$mn:00002FE3                 sub     eax, [ebp+Rect.left]
.text$mn:00002FE6                 mov     ecx, [ebp+var_4]
.text$mn:00002FE9                 xor     ecx, ebp
.text$mn:00002FEB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00002FF0                 mov     esp, ebp
.text$mn:00002FF2                 pop     ebp
.text$mn:00002FF3                 retn
.text$mn:00002FF3 ?getWidth@Window@@UBEHXZ endp
.text$mn:00002FF3
.text$mn:00002FF3 _text$mn        ends
.text$mn:00002FF3
.text$mn:00002FF4 ; ===========================================================================
.text$mn:00002FF4
.text$mn:00002FF4 ; Segment type: Pure code
.text$mn:00002FF4 ; Segment permissions: Read/Execute
.text$mn:00002FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00002FF4                 assume cs:_text$mn
.text$mn:00002FF4                 ;org 2FF4h
.text$mn:00002FF4 ; COMDAT (pick any)
.text$mn:00002FF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FF4
.text$mn:00002FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FF4
.text$mn:00002FF4 ; Attributes: bp-based frame
.text$mn:00002FF4
.text$mn:00002FF4 ; void __thiscall Window::getWindowRect(Window *this, struct tagRECT *)
.text$mn:00002FF4                 public ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:00002FF4 ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:00002FF4                                         ; DATA XREF: .rdata:00003BC8o
.text$mn:00002FF4                                         ; .rdata:00003BFCo
.text$mn:00002FF4
.text$mn:00002FF4 var_4           = dword ptr -4
.text$mn:00002FF4 lpRect          = dword ptr  8
.text$mn:00002FF4
.text$mn:00002FF4                 push    ebp
.text$mn:00002FF5                 mov     ebp, esp
.text$mn:00002FF7                 push    ecx
.text$mn:00002FF8                 mov     [ebp+var_4], ecx
.text$mn:00002FFB                 mov     eax, [ebp+lpRect]
.text$mn:00002FFE                 push    eax             ; lpRect
.text$mn:00002FFF                 mov     ecx, [ebp+var_4]
.text$mn:00003002                 mov     edx, [ecx+0Ch]
.text$mn:00003005                 push    edx             ; hWnd
.text$mn:00003006                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:0000300C                 mov     esp, ebp
.text$mn:0000300E                 pop     ebp
.text$mn:0000300F                 retn    4
.text$mn:0000300F ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:0000300F
.text$mn:0000300F ; ---------------------------------------------------------------------------
.text$mn:00003012                 align 4
.text$mn:00003012 _text$mn        ends
.text$mn:00003012
.text$mn:00003014 ; ===========================================================================
.text$mn:00003014
.text$mn:00003014 ; Segment type: Pure code
.text$mn:00003014 ; Segment permissions: Read/Execute
.text$mn:00003014 _text$mn        segment para public 'CODE' use32
.text$mn:00003014                 assume cs:_text$mn
.text$mn:00003014                 ;org 3014h
.text$mn:00003014 ; COMDAT (pick any)
.text$mn:00003014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003014
.text$mn:00003014 ; =============== S U B R O U T I N E =======================================
.text$mn:00003014
.text$mn:00003014 ; Attributes: bp-based frame
.text$mn:00003014
.text$mn:00003014 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:00003014                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00003014 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00003014                                         ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+63p
.text$mn:00003014                                         ; DATA XREF: .rdata:00003BACo ...
.text$mn:00003014
.text$mn:00003014 var_4           = dword ptr -4
.text$mn:00003014 arg_0           = dword ptr  8
.text$mn:00003014 arg_4           = dword ptr  0Ch
.text$mn:00003014
.text$mn:00003014                 push    ebp
.text$mn:00003015                 mov     ebp, esp
.text$mn:00003017                 push    ecx
.text$mn:00003018                 mov     [ebp+var_4], ecx
.text$mn:0000301B                 mov     eax, [ebp+var_4]
.text$mn:0000301E                 mov     ecx, [ebp+arg_0]
.text$mn:00003021                 mov     [eax+4], ecx
.text$mn:00003024                 mov     edx, [ebp+var_4]
.text$mn:00003027                 mov     eax, [ebp+arg_4]
.text$mn:0000302A                 mov     [edx+8], eax
.text$mn:0000302D                 mov     esp, ebp
.text$mn:0000302F                 pop     ebp
.text$mn:00003030                 retn    8
.text$mn:00003030 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:00003030
.text$mn:00003030 ; ---------------------------------------------------------------------------
.text$mn:00003033                 align 4
.text$mn:00003033 _text$mn        ends
.text$mn:00003033
.text$mn:00003034 ; ===========================================================================
.text$mn:00003034
.text$mn:00003034 ; Segment type: Pure code
.text$mn:00003034 ; Segment permissions: Read/Execute
.text$mn:00003034 _text$mn        segment para public 'CODE' use32
.text$mn:00003034                 assume cs:_text$mn
.text$mn:00003034                 ;org 3034h
.text$mn:00003034 ; COMDAT (pick any)
.text$mn:00003034                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003034
.text$mn:00003034 ; =============== S U B R O U T I N E =======================================
.text$mn:00003034
.text$mn:00003034 ; Attributes: bp-based frame
.text$mn:00003034
.text$mn:00003034 ; bool __thiscall Splitter::isInLeftTopZone(Splitter *this, const struct tagPOINT *)
.text$mn:00003034                 public ?isInLeftTopZone@Splitter@@ABE_NABUtagPOINT@@@Z
.text$mn:00003034 ?isInLeftTopZone@Splitter@@ABE_NABUtagPOINT@@@Z proc near
.text$mn:00003034                                         ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+93p
.text$mn:00003034                                         ; Splitter::spliterWndProc(uint,uint,long)+153p
.text$mn:00003034
.text$mn:00003034 var_8           = dword ptr -8
.text$mn:00003034 var_4           = dword ptr -4
.text$mn:00003034 arg_0           = dword ptr  8
.text$mn:00003034
.text$mn:00003034                 push    ebp
.text$mn:00003035                 mov     ebp, esp
.text$mn:00003037                 sub     esp, 8
.text$mn:0000303A                 mov     [ebp+var_4], ecx
.text$mn:0000303D                 mov     eax, [ebp+arg_0]
.text$mn:00003040                 mov     ecx, [ebp+var_4]
.text$mn:00003043                 mov     edx, [eax]
.text$mn:00003045                 cmp     edx, [ecx+34h]
.text$mn:00003048                 jl      short loc_3088
.text$mn:0000304A                 mov     eax, [ebp+var_4]
.text$mn:0000304D                 mov     ecx, [eax+34h]
.text$mn:00003050                 mov     edx, [ebp+var_4]
.text$mn:00003053                 add     ecx, [edx+3Ch]
.text$mn:00003056                 mov     eax, [ebp+arg_0]
.text$mn:00003059                 cmp     [eax], ecx
.text$mn:0000305B                 jg      short loc_3088
.text$mn:0000305D                 mov     ecx, [ebp+arg_0]
.text$mn:00003060                 mov     edx, [ebp+var_4]
.text$mn:00003063                 mov     eax, [ecx+4]
.text$mn:00003066                 cmp     eax, [edx+38h]
.text$mn:00003069                 jl      short loc_3088
.text$mn:0000306B                 mov     ecx, [ebp+var_4]
.text$mn:0000306E                 mov     edx, [ecx+38h]
.text$mn:00003071                 mov     eax, [ebp+var_4]
.text$mn:00003074                 add     edx, [eax+40h]
.text$mn:00003077                 mov     ecx, [ebp+arg_0]
.text$mn:0000307A                 cmp     [ecx+4], edx
.text$mn:0000307D                 jg      short loc_3088
.text$mn:0000307F                 mov     [ebp+var_8], 1
.text$mn:00003086                 jmp     short loc_308F
.text$mn:00003088 ; ---------------------------------------------------------------------------
.text$mn:00003088
.text$mn:00003088 loc_3088:                               ; CODE XREF: Splitter::isInLeftTopZone(tagPOINT const &)+14j
.text$mn:00003088                                         ; Splitter::isInLeftTopZone(tagPOINT const &)+27j ...
.text$mn:00003088                 mov     [ebp+var_8], 0
.text$mn:0000308F
.text$mn:0000308F loc_308F:                               ; CODE XREF: Splitter::isInLeftTopZone(tagPOINT const &)+52j
.text$mn:0000308F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00003092                 mov     esp, ebp
.text$mn:00003094                 pop     ebp
.text$mn:00003095                 retn    4
.text$mn:00003095 ?isInLeftTopZone@Splitter@@ABE_NABUtagPOINT@@@Z endp
.text$mn:00003095
.text$mn:00003095 _text$mn        ends
.text$mn:00003095
.text$mn:00003098 ; ===========================================================================
.text$mn:00003098
.text$mn:00003098 ; Segment type: Pure code
.text$mn:00003098 ; Segment permissions: Read/Execute
.text$mn:00003098 _text$mn        segment para public 'CODE' use32
.text$mn:00003098                 assume cs:_text$mn
.text$mn:00003098                 ;org 3098h
.text$mn:00003098 ; COMDAT (pick any)
.text$mn:00003098                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003098
.text$mn:00003098 ; =============== S U B R O U T I N E =======================================
.text$mn:00003098
.text$mn:00003098 ; Attributes: bp-based frame
.text$mn:00003098
.text$mn:00003098 ; bool __thiscall Splitter::isInRightBottomZone(Splitter *this, const struct tagPOINT *)
.text$mn:00003098                 public ?isInRightBottomZone@Splitter@@ABE_NABUtagPOINT@@@Z
.text$mn:00003098 ?isInRightBottomZone@Splitter@@ABE_NABUtagPOINT@@@Z proc near
.text$mn:00003098                                         ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+BEp
.text$mn:00003098                                         ; Splitter::spliterWndProc(uint,uint,long)+166p
.text$mn:00003098
.text$mn:00003098 var_8           = dword ptr -8
.text$mn:00003098 var_4           = dword ptr -4
.text$mn:00003098 arg_0           = dword ptr  8
.text$mn:00003098
.text$mn:00003098                 push    ebp
.text$mn:00003099                 mov     ebp, esp
.text$mn:0000309B                 sub     esp, 8
.text$mn:0000309E                 mov     [ebp+var_4], ecx
.text$mn:000030A1                 mov     eax, [ebp+arg_0]
.text$mn:000030A4                 mov     ecx, [ebp+var_4]
.text$mn:000030A7                 mov     edx, [eax]
.text$mn:000030A9                 cmp     edx, [ecx+44h]
.text$mn:000030AC                 jl      short loc_30EC
.text$mn:000030AE                 mov     eax, [ebp+var_4]
.text$mn:000030B1                 mov     ecx, [eax+44h]
.text$mn:000030B4                 mov     edx, [ebp+var_4]
.text$mn:000030B7                 add     ecx, [edx+4Ch]
.text$mn:000030BA                 mov     eax, [ebp+arg_0]
.text$mn:000030BD                 cmp     [eax], ecx
.text$mn:000030BF                 jg      short loc_30EC
.text$mn:000030C1                 mov     ecx, [ebp+arg_0]
.text$mn:000030C4                 mov     edx, [ebp+var_4]
.text$mn:000030C7                 mov     eax, [ecx+4]
.text$mn:000030CA                 cmp     eax, [edx+48h]
.text$mn:000030CD                 jl      short loc_30EC
.text$mn:000030CF                 mov     ecx, [ebp+var_4]
.text$mn:000030D2                 mov     edx, [ecx+48h]
.text$mn:000030D5                 mov     eax, [ebp+var_4]
.text$mn:000030D8                 add     edx, [eax+50h]
.text$mn:000030DB                 mov     ecx, [ebp+arg_0]
.text$mn:000030DE                 cmp     [ecx+4], edx
.text$mn:000030E1                 jg      short loc_30EC
.text$mn:000030E3                 mov     [ebp+var_8], 1
.text$mn:000030EA                 jmp     short loc_30F3
.text$mn:000030EC ; ---------------------------------------------------------------------------
.text$mn:000030EC
.text$mn:000030EC loc_30EC:                               ; CODE XREF: Splitter::isInRightBottomZone(tagPOINT const &)+14j
.text$mn:000030EC                                         ; Splitter::isInRightBottomZone(tagPOINT const &)+27j ...
.text$mn:000030EC                 mov     [ebp+var_8], 0
.text$mn:000030F3
.text$mn:000030F3 loc_30F3:                               ; CODE XREF: Splitter::isInRightBottomZone(tagPOINT const &)+52j
.text$mn:000030F3                 mov     al, byte ptr [ebp+var_8]
.text$mn:000030F6                 mov     esp, ebp
.text$mn:000030F8                 pop     ebp
.text$mn:000030F9                 retn    4
.text$mn:000030F9 ?isInRightBottomZone@Splitter@@ABE_NABUtagPOINT@@@Z endp
.text$mn:000030F9
.text$mn:000030F9 _text$mn        ends
.text$mn:000030F9
.text$mn:000030FC ; ===========================================================================
.text$mn:000030FC
.text$mn:000030FC ; Segment type: Pure code
.text$mn:000030FC ; Segment permissions: Read/Execute
.text$mn:000030FC _text$mn        segment para public 'CODE' use32
.text$mn:000030FC                 assume cs:_text$mn
.text$mn:000030FC                 ;org 30FCh
.text$mn:000030FC ; COMDAT (pick any)
.text$mn:000030FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030FC
.text$mn:000030FC ; =============== S U B R O U T I N E =======================================
.text$mn:000030FC
.text$mn:000030FC ; Attributes: bp-based frame
.text$mn:000030FC
.text$mn:000030FC ; bool __thiscall Splitter::isVertical(Splitter *__hidden this)
.text$mn:000030FC                 public ?isVertical@Splitter@@ABE_NXZ
.text$mn:000030FC ?isVertical@Splitter@@ABE_NXZ proc near ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+264p
.text$mn:000030FC                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+2BAp ...
.text$mn:000030FC
.text$mn:000030FC var_8           = dword ptr -8
.text$mn:000030FC var_4           = dword ptr -4
.text$mn:000030FC
.text$mn:000030FC                 push    ebp
.text$mn:000030FD                 mov     ebp, esp
.text$mn:000030FF                 sub     esp, 8
.text$mn:00003102                 mov     [ebp+var_8], ecx
.text$mn:00003105                 mov     eax, [ebp+var_8]
.text$mn:00003108                 mov     ecx, [eax+2Ch]
.text$mn:0000310B                 and     ecx, 2
.text$mn:0000310E                 jz      short loc_3119
.text$mn:00003110                 mov     [ebp+var_4], 1
.text$mn:00003117                 jmp     short loc_3120
.text$mn:00003119 ; ---------------------------------------------------------------------------
.text$mn:00003119
.text$mn:00003119 loc_3119:                               ; CODE XREF: Splitter::isVertical(void)+12j
.text$mn:00003119                 mov     [ebp+var_4], 0
.text$mn:00003120
.text$mn:00003120 loc_3120:                               ; CODE XREF: Splitter::isVertical(void)+1Bj
.text$mn:00003120                 mov     al, byte ptr [ebp+var_4]
.text$mn:00003123                 mov     esp, ebp
.text$mn:00003125                 pop     ebp
.text$mn:00003126                 retn
.text$mn:00003126 ?isVertical@Splitter@@ABE_NXZ endp
.text$mn:00003126
.text$mn:00003126 ; ---------------------------------------------------------------------------
.text$mn:00003127                 align 4
.text$mn:00003127 _text$mn        ends
.text$mn:00003127
.text$mn:00003128 ; ===========================================================================
.text$mn:00003128
.text$mn:00003128 ; Segment type: Pure code
.text$mn:00003128 ; Segment permissions: Read/Execute
.text$mn:00003128 _text$mn        segment para public 'CODE' use32
.text$mn:00003128                 assume cs:_text$mn
.text$mn:00003128                 ;org 3128h
.text$mn:00003128 ; COMDAT (pick any)
.text$mn:00003128                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003128
.text$mn:00003128 ; =============== S U B R O U T I N E =======================================
.text$mn:00003128
.text$mn:00003128 ; Attributes: bp-based frame
.text$mn:00003128
.text$mn:00003128 ; bool __thiscall Window::isVisible(Window *__hidden this)
.text$mn:00003128                 public ?isVisible@Window@@UBE_NXZ
.text$mn:00003128 ?isVisible@Window@@UBE_NXZ proc near    ; DATA XREF: .rdata:00003BD4o
.text$mn:00003128                                         ; .rdata:00003C08o
.text$mn:00003128
.text$mn:00003128 var_8           = dword ptr -8
.text$mn:00003128 var_1           = byte ptr -1
.text$mn:00003128
.text$mn:00003128                 push    ebp
.text$mn:00003129                 mov     ebp, esp
.text$mn:0000312B                 sub     esp, 8
.text$mn:0000312E                 mov     [ebp+var_8], ecx
.text$mn:00003131                 mov     eax, [ebp+var_8]
.text$mn:00003134                 mov     ecx, [eax+0Ch]
.text$mn:00003137                 push    ecx             ; hWnd
.text$mn:00003138                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:0000313E                 test    eax, eax
.text$mn:00003140                 jz      short loc_3148
.text$mn:00003142                 mov     [ebp+var_1], 1
.text$mn:00003146                 jmp     short loc_314C
.text$mn:00003148 ; ---------------------------------------------------------------------------
.text$mn:00003148
.text$mn:00003148 loc_3148:                               ; CODE XREF: Window::isVisible(void)+18j
.text$mn:00003148                 mov     [ebp+var_1], 0
.text$mn:0000314C
.text$mn:0000314C loc_314C:                               ; CODE XREF: Window::isVisible(void)+1Ej
.text$mn:0000314C                 mov     al, [ebp+var_1]
.text$mn:0000314F                 mov     esp, ebp
.text$mn:00003151                 pop     ebp
.text$mn:00003152                 retn
.text$mn:00003152 ?isVisible@Window@@UBE_NXZ endp
.text$mn:00003152
.text$mn:00003152 ; ---------------------------------------------------------------------------
.text$mn:00003153                 align 4
.text$mn:00003153 _text$mn        ends
.text$mn:00003153
.text$mn:00003154 ; ===========================================================================
.text$mn:00003154
.text$mn:00003154 ; Segment type: Pure code
.text$mn:00003154 ; Segment permissions: Read/Execute
.text$mn:00003154 _text$mn        segment para public 'CODE' use32
.text$mn:00003154                 assume cs:_text$mn
.text$mn:00003154                 ;org 3154h
.text$mn:00003154 ; COMDAT (pick any)
.text$mn:00003154                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003154
.text$mn:00003154 ; =============== S U B R O U T I N E =======================================
.text$mn:00003154
.text$mn:00003154 ; Attributes: bp-based frame
.text$mn:00003154
.text$mn:00003154 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00003154                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00003154 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00003154                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00003154
.text$mn:00003154 var_4           = dword ptr -4
.text$mn:00003154 Str             = dword ptr  8
.text$mn:00003154
.text$mn:00003154                 push    ebp
.text$mn:00003155                 mov     ebp, esp
.text$mn:00003157                 push    ecx
.text$mn:00003158                 mov     eax, [ebp+Str]
.text$mn:0000315B                 movsx   ecx, byte ptr [eax]
.text$mn:0000315E                 test    ecx, ecx
.text$mn:00003160                 jnz     short loc_316B
.text$mn:00003162                 mov     [ebp+var_4], 0
.text$mn:00003169                 jmp     short loc_317A
.text$mn:0000316B ; ---------------------------------------------------------------------------
.text$mn:0000316B
.text$mn:0000316B loc_316B:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000316B                 mov     edx, [ebp+Str]
.text$mn:0000316E                 push    edx             ; Str
.text$mn:0000316F                 call    _strlen
.text$mn:00003174                 add     esp, 4
.text$mn:00003177                 mov     [ebp+var_4], eax
.text$mn:0000317A
.text$mn:0000317A loc_317A:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000317A                 mov     eax, [ebp+var_4]
.text$mn:0000317D                 mov     esp, ebp
.text$mn:0000317F                 pop     ebp
.text$mn:00003180                 retn
.text$mn:00003180 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00003180
.text$mn:00003180 ; ---------------------------------------------------------------------------
.text$mn:00003181                 align 4
.text$mn:00003181 _text$mn        ends
.text$mn:00003181
.text$mn:00003184 ; ===========================================================================
.text$mn:00003184
.text$mn:00003184 ; Segment type: Pure code
.text$mn:00003184 ; Segment permissions: Read/Execute
.text$mn:00003184 _text$mn        segment para public 'CODE' use32
.text$mn:00003184                 assume cs:_text$mn
.text$mn:00003184                 ;org 3184h
.text$mn:00003184 ; COMDAT (pick any)
.text$mn:00003184                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003184
.text$mn:00003184 ; =============== S U B R O U T I N E =======================================
.text$mn:00003184
.text$mn:00003184 ; Attributes: bp-based frame
.text$mn:00003184
.text$mn:00003184 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00003184                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00003184 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00003184                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00003184
.text$mn:00003184 var_4           = dword ptr -4
.text$mn:00003184
.text$mn:00003184                 push    ebp
.text$mn:00003185                 mov     ebp, esp
.text$mn:00003187                 push    ecx
.text$mn:00003188                 mov     [ebp+var_4], ecx
.text$mn:0000318B                 mov     eax, [ebp+var_4]
.text$mn:0000318E                 push    eax
.text$mn:0000318F                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00003194                 add     esp, 4
.text$mn:00003197                 mov     esp, ebp
.text$mn:00003199                 pop     ebp
.text$mn:0000319A                 retn
.text$mn:0000319A ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000319A
.text$mn:0000319A ; ---------------------------------------------------------------------------
.text$mn:0000319B                 align 4
.text$mn:0000319B _text$mn        ends
.text$mn:0000319B
.text$mn:0000319C ; ===========================================================================
.text$mn:0000319C
.text$mn:0000319C ; Segment type: Pure code
.text$mn:0000319C ; Segment permissions: Read/Execute
.text$mn:0000319C _text$mn        segment para public 'CODE' use32
.text$mn:0000319C                 assume cs:_text$mn
.text$mn:0000319C                 ;org 319Ch
.text$mn:0000319C ; COMDAT (pick any)
.text$mn:0000319C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000319C
.text$mn:0000319C ; =============== S U B R O U T I N E =======================================
.text$mn:0000319C
.text$mn:0000319C ; Attributes: bp-based frame
.text$mn:0000319C
.text$mn:0000319C ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:0000319C                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:0000319C ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:0000319C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:0000319C
.text$mn:0000319C var_4           = dword ptr -4
.text$mn:0000319C
.text$mn:0000319C                 push    ebp
.text$mn:0000319D                 mov     ebp, esp
.text$mn:0000319F                 push    ecx
.text$mn:000031A0                 mov     [ebp+var_4], ecx
.text$mn:000031A3                 or      eax, 0FFFFFFFFh
.text$mn:000031A6                 mov     esp, ebp
.text$mn:000031A8                 pop     ebp
.text$mn:000031A9                 retn
.text$mn:000031A9 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:000031A9
.text$mn:000031A9 ; ---------------------------------------------------------------------------
.text$mn:000031AA                 align 4
.text$mn:000031AA _text$mn        ends
.text$mn:000031AA
.text$mn:000031AC ; ===========================================================================
.text$mn:000031AC
.text$mn:000031AC ; Segment type: Pure code
.text$mn:000031AC ; Segment permissions: Read/Execute
.text$mn:000031AC _text$mn        segment para public 'CODE' use32
.text$mn:000031AC                 assume cs:_text$mn
.text$mn:000031AC                 ;org 31ACh
.text$mn:000031AC ; COMDAT (pick any)
.text$mn:000031AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031AC
.text$mn:000031AC ; =============== S U B R O U T I N E =======================================
.text$mn:000031AC
.text$mn:000031AC ; Attributes: bp-based frame
.text$mn:000031AC
.text$mn:000031AC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:000031AC                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:000031AC ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:000031AC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:000031AC
.text$mn:000031AC arg_0           = dword ptr  8
.text$mn:000031AC
.text$mn:000031AC                 push    ebp
.text$mn:000031AD                 mov     ebp, esp
.text$mn:000031AF                 mov     ecx, [ebp+arg_0]
.text$mn:000031B2                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000031B7                 pop     ebp
.text$mn:000031B8                 retn
.text$mn:000031B8 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000031B8
.text$mn:000031B8 ; ---------------------------------------------------------------------------
.text$mn:000031B9                 align 4
.text$mn:000031B9 _text$mn        ends
.text$mn:000031B9
.text$mn:000031BC ; ===========================================================================
.text$mn:000031BC
.text$mn:000031BC ; Segment type: Pure code
.text$mn:000031BC ; Segment permissions: Read/Execute
.text$mn:000031BC _text$mn        segment para public 'CODE' use32
.text$mn:000031BC                 assume cs:_text$mn
.text$mn:000031BC                 ;org 31BCh
.text$mn:000031BC ; COMDAT (pick any)
.text$mn:000031BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031BC
.text$mn:000031BC ; =============== S U B R O U T I N E =======================================
.text$mn:000031BC
.text$mn:000031BC ; Attributes: bp-based frame
.text$mn:000031BC
.text$mn:000031BC ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000031BC                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000031BC ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000031BC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000031BC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000031BC
.text$mn:000031BC var_10          = dword ptr -10h
.text$mn:000031BC var_C           = dword ptr -0Ch
.text$mn:000031BC var_8           = dword ptr -8
.text$mn:000031BC var_1           = byte ptr -1
.text$mn:000031BC
.text$mn:000031BC                 push    ebp
.text$mn:000031BD                 mov     ebp, esp
.text$mn:000031BF                 sub     esp, 10h
.text$mn:000031C2                 mov     [ebp+var_10], ecx
.text$mn:000031C5                 lea     eax, [ebp+var_1]
.text$mn:000031C8                 push    eax
.text$mn:000031C9                 mov     ecx, [ebp+var_10]
.text$mn:000031CC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000031D1                 mov     ecx, eax
.text$mn:000031D3                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000031D8                 mov     [ebp+var_8], eax
.text$mn:000031DB                 cmp     [ebp+var_8], 1
.text$mn:000031DF                 ja      short loc_31EA
.text$mn:000031E1                 mov     [ebp+var_C], 1
.text$mn:000031E8                 jmp     short loc_31F3
.text$mn:000031EA ; ---------------------------------------------------------------------------
.text$mn:000031EA
.text$mn:000031EA loc_31EA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000031EA                 mov     ecx, [ebp+var_8]
.text$mn:000031ED                 sub     ecx, 1
.text$mn:000031F0                 mov     [ebp+var_C], ecx
.text$mn:000031F3
.text$mn:000031F3 loc_31F3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:000031F3                 mov     eax, [ebp+var_C]
.text$mn:000031F6                 mov     esp, ebp
.text$mn:000031F8                 pop     ebp
.text$mn:000031F9                 retn
.text$mn:000031F9 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:000031F9
.text$mn:000031F9 ; ---------------------------------------------------------------------------
.text$mn:000031FA                 align 4
.text$mn:000031FA _text$mn        ends
.text$mn:000031FA
.text$mn:000031FC ; ===========================================================================
.text$mn:000031FC
.text$mn:000031FC ; Segment type: Pure code
.text$mn:000031FC ; Segment permissions: Read/Execute
.text$mn:000031FC _text$mn        segment para public 'CODE' use32
.text$mn:000031FC                 assume cs:_text$mn
.text$mn:000031FC                 ;org 31FCh
.text$mn:000031FC ; COMDAT (pick any)
.text$mn:000031FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031FC
.text$mn:000031FC ; =============== S U B R O U T I N E =======================================
.text$mn:000031FC
.text$mn:000031FC ; Attributes: bp-based frame
.text$mn:000031FC
.text$mn:000031FC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:000031FC                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000031FC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000031FC                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:000031FC                                         ; DATA XREF: .rdata:00003B0Co
.text$mn:000031FC
.text$mn:000031FC var_1C          = dword ptr -1Ch
.text$mn:000031FC var_18          = dword ptr -18h
.text$mn:000031FC Str             = dword ptr -14h
.text$mn:000031FC var_10          = dword ptr -10h
.text$mn:000031FC var_C           = dword ptr -0Ch
.text$mn:000031FC var_4           = dword ptr -4
.text$mn:000031FC arg_0           = dword ptr  8
.text$mn:000031FC arg_4           = dword ptr  0Ch
.text$mn:000031FC
.text$mn:000031FC                 push    ebp
.text$mn:000031FD                 mov     ebp, esp
.text$mn:000031FF                 push    0FFFFFFFFh
.text$mn:00003201                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003206                 mov     eax, large fs:0
.text$mn:0000320C                 push    eax
.text$mn:0000320D                 sub     esp, 10h
.text$mn:00003210                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003215                 xor     eax, ebp
.text$mn:00003217                 push    eax
.text$mn:00003218                 lea     eax, [ebp+var_C]
.text$mn:0000321B                 mov     large fs:0, eax
.text$mn:00003221                 mov     [ebp+var_1C], ecx
.text$mn:00003224                 mov     [ebp+var_18], 0
.text$mn:0000322B                 mov     eax, [ebp+arg_4]
.text$mn:0000322E                 push    eax             ; int
.text$mn:0000322F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00003234                 add     esp, 4
.text$mn:00003237                 mov     [ebp+var_10], eax
.text$mn:0000323A                 cmp     [ebp+var_10], 0
.text$mn:0000323E                 jz      short loc_3248
.text$mn:00003240                 mov     ecx, [ebp+var_10]
.text$mn:00003243                 mov     [ebp+Str], ecx
.text$mn:00003246                 jmp     short loc_324F
.text$mn:00003248 ; ---------------------------------------------------------------------------
.text$mn:00003248
.text$mn:00003248 loc_3248:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00003248                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000324F
.text$mn:0000324F loc_324F:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:0000324F                 mov     edx, [ebp+Str]
.text$mn:00003252                 push    edx             ; Str
.text$mn:00003253                 mov     ecx, [ebp+arg_0]
.text$mn:00003256                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000325B                 mov     [ebp+var_4], 0
.text$mn:00003262                 mov     eax, [ebp+var_18]
.text$mn:00003265                 or      eax, 1
.text$mn:00003268                 mov     [ebp+var_18], eax
.text$mn:0000326B                 mov     eax, [ebp+arg_0]
.text$mn:0000326E                 mov     ecx, [ebp+var_C]
.text$mn:00003271                 mov     large fs:0, ecx
.text$mn:00003278                 pop     ecx
.text$mn:00003279                 mov     esp, ebp
.text$mn:0000327B                 pop     ebp
.text$mn:0000327C                 retn    8
.text$mn:0000327C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000327C
.text$mn:0000327C ; ---------------------------------------------------------------------------
.text$mn:0000327F                 align 10h
.text$mn:0000327F _text$mn        ends
.text$mn:0000327F
.text$x:00003280 ; ===========================================================================
.text$x:00003280
.text$x:00003280 ; Segment type: Pure code
.text$x:00003280 ; Segment permissions: Read/Execute
.text$x:00003280 _text$x         segment para public 'CODE' use32
.text$x:00003280                 assume cs:_text$x
.text$x:00003280                 ;org 3280h
.text$x:00003280 ; COMDAT (pick associative to section at 31FC)
.text$x:00003280                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003280
.text$x:00003280 ; =============== S U B R O U T I N E =======================================
.text$x:00003280
.text$x:00003280
.text$x:00003280 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00003280                                         ; DATA XREF: .xdata$x:0000383Co
.text$x:00003280                 mov     eax, [ebp-18h]
.text$x:00003283                 and     eax, 1
.text$x:00003286                 jz      $LN6
.text$x:0000328C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00003290                 mov     ecx, [ebp+8]
.text$x:00003293                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003298 ; ---------------------------------------------------------------------------
.text$x:00003298
.text$x:00003298 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00003298                 retn
.text$x:00003298 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00003298
.text$x:00003299
.text$x:00003299 ; =============== S U B R O U T I N E =======================================
.text$x:00003299
.text$x:00003299
.text$x:00003299 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00003299                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00003299
.text$x:00003299 arg_4           = dword ptr  8
.text$x:00003299
.text$x:00003299                 mov     edx, [esp+arg_4]
.text$x:0000329D                 lea     eax, [edx+0Ch]
.text$x:000032A0                 mov     ecx, [edx-14h]
.text$x:000032A3                 xor     ecx, eax
.text$x:000032A5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000032AA                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000032AF                 jmp     ___CxxFrameHandler3
.text$x:000032AF __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000032AF
.text$x:000032AF _text$x         ends
.text$x:000032AF
.text$mn:000032B4 ; ===========================================================================
.text$mn:000032B4
.text$mn:000032B4 ; Segment type: Pure code
.text$mn:000032B4 ; Segment permissions: Read/Execute
.text$mn:000032B4 _text$mn        segment para public 'CODE' use32
.text$mn:000032B4                 assume cs:_text$mn
.text$mn:000032B4                 ;org 32B4h
.text$mn:000032B4 ; COMDAT (pick any)
.text$mn:000032B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032B4
.text$mn:000032B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000032B4
.text$mn:000032B4 ; Attributes: bp-based frame
.text$mn:000032B4
.text$mn:000032B4 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:000032B4                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000032B4 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000032B4                                         ; DATA XREF: .rdata:00003B40o
.text$mn:000032B4
.text$mn:000032B4 var_14          = dword ptr -14h
.text$mn:000032B4 var_10          = dword ptr -10h
.text$mn:000032B4 var_C           = dword ptr -0Ch
.text$mn:000032B4 var_4           = dword ptr -4
.text$mn:000032B4 arg_0           = dword ptr  8
.text$mn:000032B4 arg_4           = dword ptr  0Ch
.text$mn:000032B4
.text$mn:000032B4                 push    ebp
.text$mn:000032B5                 mov     ebp, esp
.text$mn:000032B7                 push    0FFFFFFFFh
.text$mn:000032B9                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000032BE                 mov     eax, large fs:0
.text$mn:000032C4                 push    eax
.text$mn:000032C5                 sub     esp, 8
.text$mn:000032C8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000032CD                 xor     eax, ebp
.text$mn:000032CF                 push    eax
.text$mn:000032D0                 lea     eax, [ebp+var_C]
.text$mn:000032D3                 mov     large fs:0, eax
.text$mn:000032D9                 mov     [ebp+var_14], ecx
.text$mn:000032DC                 mov     [ebp+var_10], 0
.text$mn:000032E3                 cmp     [ebp+arg_4], 1
.text$mn:000032E7                 jnz     short loc_330D
.text$mn:000032E9                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:000032EE                 mov     ecx, [ebp+arg_0]
.text$mn:000032F1                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000032F6                 mov     [ebp+var_4], 0
.text$mn:000032FD                 mov     eax, [ebp+var_10]
.text$mn:00003300                 or      eax, 1
.text$mn:00003303                 mov     [ebp+var_10], eax
.text$mn:00003306                 mov     eax, [ebp+arg_0]
.text$mn:00003309                 jmp     short loc_3330
.text$mn:0000330B ; ---------------------------------------------------------------------------
.text$mn:0000330B                 jmp     short loc_3330
.text$mn:0000330D ; ---------------------------------------------------------------------------
.text$mn:0000330D
.text$mn:0000330D loc_330D:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:0000330D                 mov     ecx, [ebp+arg_4]
.text$mn:00003310                 push    ecx
.text$mn:00003311                 mov     edx, [ebp+arg_0]
.text$mn:00003314                 push    edx
.text$mn:00003315                 mov     ecx, [ebp+var_14]
.text$mn:00003318                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:0000331D                 mov     [ebp+var_4], 0
.text$mn:00003324                 mov     eax, [ebp+var_10]
.text$mn:00003327                 or      eax, 1
.text$mn:0000332A                 mov     [ebp+var_10], eax
.text$mn:0000332D                 mov     eax, [ebp+arg_0]
.text$mn:00003330
.text$mn:00003330 loc_3330:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00003330                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00003330                 mov     ecx, [ebp+var_C]
.text$mn:00003333                 mov     large fs:0, ecx
.text$mn:0000333A                 pop     ecx
.text$mn:0000333B                 mov     esp, ebp
.text$mn:0000333D                 pop     ebp
.text$mn:0000333E                 retn    8
.text$mn:0000333E ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000333E
.text$mn:0000333E ; ---------------------------------------------------------------------------
.text$mn:00003341                 align 4
.text$mn:00003341 _text$mn        ends
.text$mn:00003341
.text$x:00003344 ; ===========================================================================
.text$x:00003344
.text$x:00003344 ; Segment type: Pure code
.text$x:00003344 ; Segment permissions: Read/Execute
.text$x:00003344 _text$x         segment para public 'CODE' use32
.text$x:00003344                 assume cs:_text$x
.text$x:00003344                 ;org 3344h
.text$x:00003344 ; COMDAT (pick associative to section at 32B4)
.text$x:00003344                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003344
.text$x:00003344 ; =============== S U B R O U T I N E =======================================
.text$x:00003344
.text$x:00003344
.text$x:00003344 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00003344                                         ; DATA XREF: .xdata$x:000038C0o
.text$x:00003344                 mov     eax, [ebp-10h]
.text$x:00003347                 and     eax, 1
.text$x:0000334A                 jz      $LN6_0
.text$x:00003350                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00003354                 mov     ecx, [ebp+8]
.text$x:00003357                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000335C ; ---------------------------------------------------------------------------
.text$x:0000335C
.text$x:0000335C $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000335C                 retn
.text$x:0000335C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000335C
.text$x:0000335D
.text$x:0000335D ; =============== S U B R O U T I N E =======================================
.text$x:0000335D
.text$x:0000335D
.text$x:0000335D __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000335D                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:0000335D
.text$x:0000335D arg_4           = dword ptr  8
.text$x:0000335D
.text$x:0000335D                 mov     edx, [esp+arg_4]
.text$x:00003361                 lea     eax, [edx+0Ch]
.text$x:00003364                 mov     ecx, [edx-0Ch]
.text$x:00003367                 xor     ecx, eax
.text$x:00003369                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000336E                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00003373                 jmp     ___CxxFrameHandler3
.text$x:00003373 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00003373
.text$x:00003373 _text$x         ends
.text$x:00003373
.text$mn:00003378 ; ===========================================================================
.text$mn:00003378
.text$mn:00003378 ; Segment type: Pure code
.text$mn:00003378 ; Segment permissions: Read/Execute
.text$mn:00003378 _text$mn        segment para public 'CODE' use32
.text$mn:00003378                 assume cs:_text$mn
.text$mn:00003378                 ;org 3378h
.text$mn:00003378 ; COMDAT (pick any)
.text$mn:00003378                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003378
.text$mn:00003378 ; =============== S U B R O U T I N E =======================================
.text$mn:00003378
.text$mn:00003378 ; Attributes: bp-based frame
.text$mn:00003378
.text$mn:00003378 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00003378                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003378 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00003378                                         ; DATA XREF: .rdata:00003B80o
.text$mn:00003378
.text$mn:00003378 var_1C          = dword ptr -1Ch
.text$mn:00003378 var_18          = dword ptr -18h
.text$mn:00003378 Str             = dword ptr -14h
.text$mn:00003378 var_10          = dword ptr -10h
.text$mn:00003378 var_C           = dword ptr -0Ch
.text$mn:00003378 var_4           = dword ptr -4
.text$mn:00003378 arg_0           = dword ptr  8
.text$mn:00003378 arg_4           = dword ptr  0Ch
.text$mn:00003378
.text$mn:00003378                 push    ebp
.text$mn:00003379                 mov     ebp, esp
.text$mn:0000337B                 push    0FFFFFFFFh
.text$mn:0000337D                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003382                 mov     eax, large fs:0
.text$mn:00003388                 push    eax
.text$mn:00003389                 sub     esp, 10h
.text$mn:0000338C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003391                 xor     eax, ebp
.text$mn:00003393                 push    eax
.text$mn:00003394                 lea     eax, [ebp+var_C]
.text$mn:00003397                 mov     large fs:0, eax
.text$mn:0000339D                 mov     [ebp+var_1C], ecx
.text$mn:000033A0                 mov     [ebp+var_18], 0
.text$mn:000033A7                 mov     eax, [ebp+arg_4]
.text$mn:000033AA                 push    eax             ; int
.text$mn:000033AB                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:000033B0                 add     esp, 4
.text$mn:000033B3                 mov     [ebp+var_10], eax
.text$mn:000033B6                 cmp     [ebp+var_10], 0
.text$mn:000033BA                 jz      short loc_33C4
.text$mn:000033BC                 mov     ecx, [ebp+var_10]
.text$mn:000033BF                 mov     [ebp+Str], ecx
.text$mn:000033C2                 jmp     short loc_33CB
.text$mn:000033C4 ; ---------------------------------------------------------------------------
.text$mn:000033C4
.text$mn:000033C4 loc_33C4:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:000033C4                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000033CB
.text$mn:000033CB loc_33CB:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:000033CB                 mov     edx, [ebp+Str]
.text$mn:000033CE                 push    edx             ; Str
.text$mn:000033CF                 mov     ecx, [ebp+arg_0]
.text$mn:000033D2                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000033D7                 mov     [ebp+var_4], 0
.text$mn:000033DE                 mov     eax, [ebp+var_18]
.text$mn:000033E1                 or      eax, 1
.text$mn:000033E4                 mov     [ebp+var_18], eax
.text$mn:000033E7                 mov     eax, [ebp+arg_0]
.text$mn:000033EA                 mov     ecx, [ebp+var_C]
.text$mn:000033ED                 mov     large fs:0, ecx
.text$mn:000033F4                 pop     ecx
.text$mn:000033F5                 mov     esp, ebp
.text$mn:000033F7                 pop     ebp
.text$mn:000033F8                 retn    8
.text$mn:000033F8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000033F8
.text$mn:000033F8 ; ---------------------------------------------------------------------------
.text$mn:000033FB                 align 4
.text$mn:000033FB _text$mn        ends
.text$mn:000033FB
.text$x:000033FC ; ===========================================================================
.text$x:000033FC
.text$x:000033FC ; Segment type: Pure code
.text$x:000033FC ; Segment permissions: Read/Execute
.text$x:000033FC _text$x         segment para public 'CODE' use32
.text$x:000033FC                 assume cs:_text$x
.text$x:000033FC                 ;org 33FCh
.text$x:000033FC ; COMDAT (pick associative to section at 3378)
.text$x:000033FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000033FC
.text$x:000033FC ; =============== S U B R O U T I N E =======================================
.text$x:000033FC
.text$x:000033FC
.text$x:000033FC __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000033FC                                         ; DATA XREF: .xdata$x:00003944o
.text$x:000033FC                 mov     eax, [ebp-18h]
.text$x:000033FF                 and     eax, 1
.text$x:00003402                 jz      $LN6_1
.text$x:00003408                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000340C                 mov     ecx, [ebp+8]
.text$x:0000340F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003414 ; ---------------------------------------------------------------------------
.text$x:00003414
.text$x:00003414 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00003414                 retn
.text$x:00003414 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00003414
.text$x:00003415
.text$x:00003415 ; =============== S U B R O U T I N E =======================================
.text$x:00003415
.text$x:00003415
.text$x:00003415 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00003415                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00003415
.text$x:00003415 arg_4           = dword ptr  8
.text$x:00003415
.text$x:00003415                 mov     edx, [esp+arg_4]
.text$x:00003419                 lea     eax, [edx+0Ch]
.text$x:0000341C                 mov     ecx, [edx-14h]
.text$x:0000341F                 xor     ecx, eax
.text$x:00003421                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003426                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000342B                 jmp     ___CxxFrameHandler3
.text$x:0000342B __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000342B
.text$x:0000342B _text$x         ends
.text$x:0000342B
.text$mn:00003430 ; ===========================================================================
.text$mn:00003430
.text$mn:00003430 ; Segment type: Pure code
.text$mn:00003430 ; Segment permissions: Read/Execute
.text$mn:00003430 _text$mn        segment para public 'CODE' use32
.text$mn:00003430                 assume cs:_text$mn
.text$mn:00003430                 ;org 3430h
.text$mn:00003430 ; COMDAT (pick any)
.text$mn:00003430                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003430
.text$mn:00003430 ; =============== S U B R O U T I N E =======================================
.text$mn:00003430
.text$mn:00003430 ; Attributes: bp-based frame
.text$mn:00003430
.text$mn:00003430 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00003430                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00003430 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00003430                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00003430
.text$mn:00003430 var_4           = dword ptr -4
.text$mn:00003430 Dst             = dword ptr  8
.text$mn:00003430 Src             = dword ptr  0Ch
.text$mn:00003430 Size            = dword ptr  10h
.text$mn:00003430
.text$mn:00003430                 push    ebp
.text$mn:00003431                 mov     ebp, esp
.text$mn:00003433                 push    ecx
.text$mn:00003434                 cmp     [ebp+Size], 0
.text$mn:00003438                 jnz     short loc_3442
.text$mn:0000343A                 mov     eax, [ebp+Dst]
.text$mn:0000343D                 mov     [ebp+var_4], eax
.text$mn:00003440                 jmp     short loc_3459
.text$mn:00003442 ; ---------------------------------------------------------------------------
.text$mn:00003442
.text$mn:00003442 loc_3442:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00003442                 mov     ecx, [ebp+Size]
.text$mn:00003445                 push    ecx             ; Size
.text$mn:00003446                 mov     edx, [ebp+Src]
.text$mn:00003449                 push    edx             ; Src
.text$mn:0000344A                 mov     eax, [ebp+Dst]
.text$mn:0000344D                 push    eax             ; Dst
.text$mn:0000344E                 call    _memmove
.text$mn:00003453                 add     esp, 0Ch
.text$mn:00003456                 mov     [ebp+var_4], eax
.text$mn:00003459
.text$mn:00003459 loc_3459:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00003459                 mov     eax, [ebp+var_4]
.text$mn:0000345C                 mov     esp, ebp
.text$mn:0000345E                 pop     ebp
.text$mn:0000345F                 retn
.text$mn:0000345F ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000345F
.text$mn:0000345F _text$mn        ends
.text$mn:0000345F
.text$mn:00003460 ; ===========================================================================
.text$mn:00003460
.text$mn:00003460 ; Segment type: Pure code
.text$mn:00003460 ; Segment permissions: Read/Execute
.text$mn:00003460 _text$mn        segment para public 'CODE' use32
.text$mn:00003460                 assume cs:_text$mn
.text$mn:00003460                 ;org 3460h
.text$mn:00003460 ; COMDAT (pick any)
.text$mn:00003460                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003460
.text$mn:00003460 ; =============== S U B R O U T I N E =======================================
.text$mn:00003460
.text$mn:00003460 ; Attributes: bp-based frame
.text$mn:00003460
.text$mn:00003460 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00003460                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00003460 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00003460                                         ; DATA XREF: .rdata:00003B08o
.text$mn:00003460
.text$mn:00003460 var_4           = dword ptr -4
.text$mn:00003460
.text$mn:00003460                 push    ebp
.text$mn:00003461                 mov     ebp, esp
.text$mn:00003463                 push    ecx
.text$mn:00003464                 mov     [ebp+var_4], ecx
.text$mn:00003467                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:0000346C                 mov     esp, ebp
.text$mn:0000346E                 pop     ebp
.text$mn:0000346F                 retn
.text$mn:0000346F ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000346F
.text$mn:0000346F _text$mn        ends
.text$mn:0000346F
.text$mn:00003470 ; ===========================================================================
.text$mn:00003470
.text$mn:00003470 ; Segment type: Pure code
.text$mn:00003470 ; Segment permissions: Read/Execute
.text$mn:00003470 _text$mn        segment para public 'CODE' use32
.text$mn:00003470                 assume cs:_text$mn
.text$mn:00003470                 ;org 3470h
.text$mn:00003470 ; COMDAT (pick any)
.text$mn:00003470                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003470
.text$mn:00003470 ; =============== S U B R O U T I N E =======================================
.text$mn:00003470
.text$mn:00003470 ; Attributes: bp-based frame
.text$mn:00003470
.text$mn:00003470 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00003470                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00003470 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00003470                                         ; DATA XREF: .rdata:00003B3Co
.text$mn:00003470
.text$mn:00003470 var_4           = dword ptr -4
.text$mn:00003470
.text$mn:00003470                 push    ebp
.text$mn:00003471                 mov     ebp, esp
.text$mn:00003473                 push    ecx
.text$mn:00003474                 mov     [ebp+var_4], ecx
.text$mn:00003477                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:0000347C                 mov     esp, ebp
.text$mn:0000347E                 pop     ebp
.text$mn:0000347F                 retn
.text$mn:0000347F ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000347F
.text$mn:0000347F _text$mn        ends
.text$mn:0000347F
.text$mn:00003480 ; ===========================================================================
.text$mn:00003480
.text$mn:00003480 ; Segment type: Pure code
.text$mn:00003480 ; Segment permissions: Read/Execute
.text$mn:00003480 _text$mn        segment para public 'CODE' use32
.text$mn:00003480                 assume cs:_text$mn
.text$mn:00003480                 ;org 3480h
.text$mn:00003480 ; COMDAT (pick any)
.text$mn:00003480                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003480
.text$mn:00003480 ; =============== S U B R O U T I N E =======================================
.text$mn:00003480
.text$mn:00003480 ; Attributes: bp-based frame
.text$mn:00003480
.text$mn:00003480 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00003480                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00003480 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00003480                                         ; DATA XREF: .rdata:00003B7Co
.text$mn:00003480
.text$mn:00003480 var_4           = dword ptr -4
.text$mn:00003480
.text$mn:00003480                 push    ebp
.text$mn:00003481                 mov     ebp, esp
.text$mn:00003483                 push    ecx
.text$mn:00003484                 mov     [ebp+var_4], ecx
.text$mn:00003487                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:0000348C                 mov     esp, ebp
.text$mn:0000348E                 pop     ebp
.text$mn:0000348F                 retn
.text$mn:0000348F ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000348F
.text$mn:0000348F _text$mn        ends
.text$mn:0000348F
.text$mn:00003490 ; ===========================================================================
.text$mn:00003490
.text$mn:00003490 ; Segment type: Pure code
.text$mn:00003490 ; Segment permissions: Read/Execute
.text$mn:00003490 _text$mn        segment para public 'CODE' use32
.text$mn:00003490                 assume cs:_text$mn
.text$mn:00003490                 ;org 3490h
.text$mn:00003490 ; COMDAT (pick any)
.text$mn:00003490                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003490
.text$mn:00003490 ; =============== S U B R O U T I N E =======================================
.text$mn:00003490
.text$mn:00003490 ; Attributes: bp-based frame
.text$mn:00003490
.text$mn:00003490 ; void __thiscall Window::reSizeTo(Window *this, struct tagRECT *)
.text$mn:00003490                 public ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z
.text$mn:00003490 ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:00003490                                         ; DATA XREF: .rdata:00003BB8o
.text$mn:00003490                                         ; .rdata:00003BECo
.text$mn:00003490
.text$mn:00003490 var_4           = dword ptr -4
.text$mn:00003490 arg_0           = dword ptr  8
.text$mn:00003490
.text$mn:00003490                 push    ebp
.text$mn:00003491                 mov     ebp, esp
.text$mn:00003493                 push    ecx
.text$mn:00003494                 mov     [ebp+var_4], ecx
.text$mn:00003497                 push    1               ; bRepaint
.text$mn:00003499                 mov     eax, [ebp+arg_0]
.text$mn:0000349C                 mov     ecx, [eax+0Ch]
.text$mn:0000349F                 push    ecx             ; nHeight
.text$mn:000034A0                 mov     edx, [ebp+arg_0]
.text$mn:000034A3                 mov     eax, [edx+8]
.text$mn:000034A6                 push    eax             ; nWidth
.text$mn:000034A7                 mov     ecx, [ebp+arg_0]
.text$mn:000034AA                 mov     edx, [ecx+4]
.text$mn:000034AD                 push    edx             ; Y
.text$mn:000034AE                 mov     eax, [ebp+arg_0]
.text$mn:000034B1                 mov     ecx, [eax]
.text$mn:000034B3                 push    ecx             ; X
.text$mn:000034B4                 mov     edx, [ebp+var_4]
.text$mn:000034B7                 mov     eax, [edx+0Ch]
.text$mn:000034BA                 push    eax             ; hWnd
.text$mn:000034BB                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:000034C1                 push    0
.text$mn:000034C3                 mov     ecx, [ebp+var_4]
.text$mn:000034C6                 mov     edx, [ecx]
.text$mn:000034C8                 mov     ecx, [ebp+var_4]
.text$mn:000034CB                 mov     eax, [edx+18h]
.text$mn:000034CE                 call    eax
.text$mn:000034D0                 mov     esp, ebp
.text$mn:000034D2                 pop     ebp
.text$mn:000034D3                 retn    4
.text$mn:000034D3 ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:000034D3
.text$mn:000034D3 ; ---------------------------------------------------------------------------
.text$mn:000034D6                 align 4
.text$mn:000034D6 _text$mn        ends
.text$mn:000034D6
.text$mn:000034D8 ; ===========================================================================
.text$mn:000034D8
.text$mn:000034D8 ; Segment type: Pure code
.text$mn:000034D8 ; Segment permissions: Read/Execute
.text$mn:000034D8 _text$mn        segment para public 'CODE' use32
.text$mn:000034D8                 assume cs:_text$mn
.text$mn:000034D8                 ;org 34D8h
.text$mn:000034D8 ; COMDAT (pick any)
.text$mn:000034D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034D8
.text$mn:000034D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000034D8
.text$mn:000034D8 ; Attributes: bp-based frame
.text$mn:000034D8
.text$mn:000034D8 ; void __thiscall Window::reSizeToWH(Window *this, struct tagRECT *)
.text$mn:000034D8                 public ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z
.text$mn:000034D8 ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:000034D8                                         ; DATA XREF: .rdata:00003BBCo
.text$mn:000034D8                                         ; .rdata:00003BF0o
.text$mn:000034D8
.text$mn:000034D8 var_4           = dword ptr -4
.text$mn:000034D8 arg_0           = dword ptr  8
.text$mn:000034D8
.text$mn:000034D8                 push    ebp
.text$mn:000034D9                 mov     ebp, esp
.text$mn:000034DB                 push    ecx
.text$mn:000034DC                 mov     [ebp+var_4], ecx
.text$mn:000034DF                 push    1               ; bRepaint
.text$mn:000034E1                 mov     eax, [ebp+arg_0]
.text$mn:000034E4                 mov     ecx, [ebp+arg_0]
.text$mn:000034E7                 mov     edx, [eax+0Ch]
.text$mn:000034EA                 sub     edx, [ecx+4]
.text$mn:000034ED                 push    edx             ; nHeight
.text$mn:000034EE                 mov     eax, [ebp+arg_0]
.text$mn:000034F1                 mov     ecx, [ebp+arg_0]
.text$mn:000034F4                 mov     edx, [eax+8]
.text$mn:000034F7                 sub     edx, [ecx]
.text$mn:000034F9                 push    edx             ; nWidth
.text$mn:000034FA                 mov     eax, [ebp+arg_0]
.text$mn:000034FD                 mov     ecx, [eax+4]
.text$mn:00003500                 push    ecx             ; Y
.text$mn:00003501                 mov     edx, [ebp+arg_0]
.text$mn:00003504                 mov     eax, [edx]
.text$mn:00003506                 push    eax             ; X
.text$mn:00003507                 mov     ecx, [ebp+var_4]
.text$mn:0000350A                 mov     edx, [ecx+0Ch]
.text$mn:0000350D                 push    edx             ; hWnd
.text$mn:0000350E                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00003514                 push    0
.text$mn:00003516                 mov     eax, [ebp+var_4]
.text$mn:00003519                 mov     edx, [eax]
.text$mn:0000351B                 mov     ecx, [ebp+var_4]
.text$mn:0000351E                 mov     eax, [edx+18h]
.text$mn:00003521                 call    eax
.text$mn:00003523                 mov     esp, ebp
.text$mn:00003525                 pop     ebp
.text$mn:00003526                 retn    4
.text$mn:00003526 ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:00003526
.text$mn:00003526 ; ---------------------------------------------------------------------------
.text$mn:00003529                 align 4
.text$mn:00003529 _text$mn        ends
.text$mn:00003529
.text$mn:0000352C ; ===========================================================================
.text$mn:0000352C
.text$mn:0000352C ; Segment type: Pure code
.text$mn:0000352C ; Segment permissions: Read/Execute
.text$mn:0000352C _text$mn        segment para public 'CODE' use32
.text$mn:0000352C                 assume cs:_text$mn
.text$mn:0000352C                 ;org 352Ch
.text$mn:0000352C ; COMDAT (pick any)
.text$mn:0000352C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000352C
.text$mn:0000352C ; =============== S U B R O U T I N E =======================================
.text$mn:0000352C
.text$mn:0000352C ; Attributes: bp-based frame
.text$mn:0000352C
.text$mn:0000352C ; void __thiscall Window::redraw(Window *this, bool)
.text$mn:0000352C                 public ?redraw@Window@@UBEX_N@Z
.text$mn:0000352C ?redraw@Window@@UBEX_N@Z proc near      ; DATA XREF: .rdata:00003BC0o
.text$mn:0000352C                                         ; .rdata:00003BF4o
.text$mn:0000352C
.text$mn:0000352C var_4           = dword ptr -4
.text$mn:0000352C arg_0           = byte ptr  8
.text$mn:0000352C
.text$mn:0000352C                 push    ebp
.text$mn:0000352D                 mov     ebp, esp
.text$mn:0000352F                 push    ecx
.text$mn:00003530                 mov     [ebp+var_4], ecx
.text$mn:00003533                 push    1               ; bErase
.text$mn:00003535                 push    0               ; lpRect
.text$mn:00003537                 mov     eax, [ebp+var_4]
.text$mn:0000353A                 mov     ecx, [eax+0Ch]
.text$mn:0000353D                 push    ecx             ; hWnd
.text$mn:0000353E                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:00003544                 movzx   edx, [ebp+arg_0]
.text$mn:00003548                 test    edx, edx
.text$mn:0000354A                 jz      short loc_3559
.text$mn:0000354C                 mov     eax, [ebp+var_4]
.text$mn:0000354F                 mov     ecx, [eax+0Ch]
.text$mn:00003552                 push    ecx             ; hWnd
.text$mn:00003553                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:00003559
.text$mn:00003559 loc_3559:                               ; CODE XREF: Window::redraw(bool)+1Ej
.text$mn:00003559                 mov     esp, ebp
.text$mn:0000355B                 pop     ebp
.text$mn:0000355C                 retn    4
.text$mn:0000355C ?redraw@Window@@UBEX_N@Z endp
.text$mn:0000355C
.text$mn:0000355C ; ---------------------------------------------------------------------------
.text$mn:0000355F                 align 10h
.text$mn:0000355F _text$mn        ends
.text$mn:0000355F
.text$mn:00003560 ; ===========================================================================
.text$mn:00003560
.text$mn:00003560 ; Segment type: Pure code
.text$mn:00003560 ; Segment permissions: Read/Execute
.text$mn:00003560 _text$mn        segment para public 'CODE' use32
.text$mn:00003560                 assume cs:_text$mn
.text$mn:00003560                 ;org 3560h
.text$mn:00003560 ; COMDAT (pick any)
.text$mn:00003560                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003560
.text$mn:00003560 ; =============== S U B R O U T I N E =======================================
.text$mn:00003560
.text$mn:00003560 ; Attributes: bp-based frame
.text$mn:00003560
.text$mn:00003560 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00003560                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00003560 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00003560                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00003560                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00003560
.text$mn:00003560 var_4           = dword ptr -4
.text$mn:00003560
.text$mn:00003560                 push    ebp
.text$mn:00003561                 mov     ebp, esp
.text$mn:00003563                 push    ecx
.text$mn:00003564                 mov     [ebp+var_4], ecx
.text$mn:00003567                 mov     eax, [ebp+var_4]
.text$mn:0000356A                 mov     eax, [eax+14h]
.text$mn:0000356D                 mov     esp, ebp
.text$mn:0000356F                 pop     ebp
.text$mn:00003570                 retn
.text$mn:00003570 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00003570
.text$mn:00003570 ; ---------------------------------------------------------------------------
.text$mn:00003571                 align 4
.text$mn:00003571 _text$mn        ends
.text$mn:00003571
.text$mn:00003574 ; ===========================================================================
.text$mn:00003574
.text$mn:00003574 ; Segment type: Pure code
.text$mn:00003574 ; Segment permissions: Read/Execute
.text$mn:00003574 _text$mn        segment para public 'CODE' use32
.text$mn:00003574                 assume cs:_text$mn
.text$mn:00003574                 ;org 3574h
.text$mn:00003574 ; COMDAT (pick any)
.text$mn:00003574                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003574
.text$mn:00003574 ; =============== S U B R O U T I N E =======================================
.text$mn:00003574
.text$mn:00003574 ; Attributes: bp-based frame
.text$mn:00003574
.text$mn:00003574 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00003574                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00003574 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00003574                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_2CCCp
.text$mn:00003574                 push    ebp
.text$mn:00003575                 mov     ebp, esp
.text$mn:00003577                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:0000357C                 pop     ebp
.text$mn:0000357D                 retn
.text$mn:0000357D ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:0000357D
.text$mn:0000357D ; ---------------------------------------------------------------------------
.text$mn:0000357E                 align 10h
.text$mn:0000357E _text$mn        ends
.text$mn:0000357E
.text$mn:00003580 ; ===========================================================================
.text$mn:00003580
.text$mn:00003580 ; Segment type: Pure code
.text$mn:00003580 ; Segment permissions: Read/Execute
.text$mn:00003580 _text$mn        segment para public 'CODE' use32
.text$mn:00003580                 assume cs:_text$mn
.text$mn:00003580                 ;org 3580h
.text$mn:00003580 ; COMDAT (pick any)
.text$mn:00003580                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003580
.text$mn:00003580 ; =============== S U B R O U T I N E =======================================
.text$mn:00003580
.text$mn:00003580 ; Attributes: bp-based frame
.text$mn:00003580
.text$mn:00003580 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00003580                 public ?value@error_code@std@@QBEHXZ
.text$mn:00003580 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00003580
.text$mn:00003580 var_4           = dword ptr -4
.text$mn:00003580
.text$mn:00003580                 push    ebp
.text$mn:00003581                 mov     ebp, esp
.text$mn:00003583                 push    ecx
.text$mn:00003584                 mov     [ebp+var_4], ecx
.text$mn:00003587                 mov     eax, [ebp+var_4]
.text$mn:0000358A                 mov     eax, [eax]
.text$mn:0000358C                 mov     esp, ebp
.text$mn:0000358E                 pop     ebp
.text$mn:0000358F                 retn
.text$mn:0000358F ?value@error_code@std@@QBEHXZ endp
.text$mn:0000358F
.text$mn:0000358F _text$mn        ends
.text$mn:0000358F
.text$mn:00003590 ; ===========================================================================
.text$mn:00003590
.text$mn:00003590 ; Segment type: Pure code
.text$mn:00003590 ; Segment permissions: Read/Execute
.text$mn:00003590 _text$mn        segment para public 'CODE' use32
.text$mn:00003590                 assume cs:_text$mn
.text$mn:00003590                 ;org 3590h
.text$mn:00003590 ; COMDAT (pick any)
.text$mn:00003590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003590
.text$mn:00003590 ; =============== S U B R O U T I N E =======================================
.text$mn:00003590
.text$mn:00003590 ; Attributes: bp-based frame
.text$mn:00003590
.text$mn:00003590 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00003590                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00003590 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00003590                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00003590                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00003590
.text$mn:00003590 var_4           = dword ptr -4
.text$mn:00003590
.text$mn:00003590                 push    ebp
.text$mn:00003591                 mov     ebp, esp
.text$mn:00003593                 push    ecx
.text$mn:00003594                 mov     [ebp+var_4], ecx
.text$mn:00003597                 mov     eax, [ebp+var_4]
.text$mn:0000359A                 mov     eax, [eax]
.text$mn:0000359C                 mov     esp, ebp
.text$mn:0000359E                 pop     ebp
.text$mn:0000359F                 retn
.text$mn:0000359F ?value@error_condition@std@@QBEHXZ endp
.text$mn:0000359F
.text$mn:0000359F _text$mn        ends
.text$mn:0000359F
.text$mn:000035A0 ; ===========================================================================
.text$mn:000035A0
.text$mn:000035A0 ; Segment type: Pure code
.text$mn:000035A0 ; Segment permissions: Read/Execute
.text$mn:000035A0 _text$mn        segment para public 'CODE' use32
.text$mn:000035A0                 assume cs:_text$mn
.text$mn:000035A0                 ;org 35A0h
.text$mn:000035A0 ; COMDAT (pick any)
.text$mn:000035A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000035A0
.text$mn:000035A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000035A0
.text$mn:000035A0 ; Attributes: bp-based frame
.text$mn:000035A0
.text$mn:000035A0                 public _hypot
.text$mn:000035A0 _hypot          proc near
.text$mn:000035A0
.text$mn:000035A0 var_10          = qword ptr -10h
.text$mn:000035A0 var_8           = qword ptr -8
.text$mn:000035A0 arg_0           = qword ptr  8
.text$mn:000035A0 arg_8           = qword ptr  10h
.text$mn:000035A0
.text$mn:000035A0                 push    ebp
.text$mn:000035A1                 mov     ebp, esp
.text$mn:000035A3                 sub     esp, 8
.text$mn:000035A6                 movsd   xmm0, [ebp+arg_8]
.text$mn:000035AB                 movsd   [esp+8+var_8], xmm0
.text$mn:000035B0                 sub     esp, 8
.text$mn:000035B3                 movsd   xmm0, [ebp+arg_0]
.text$mn:000035B8                 movsd   [esp+10h+var_10], xmm0
.text$mn:000035BD                 call    __hypot
.text$mn:000035C2                 add     esp, 10h
.text$mn:000035C5                 pop     ebp
.text$mn:000035C6                 retn
.text$mn:000035C6 _hypot          endp
.text$mn:000035C6
.text$mn:000035C6 ; ---------------------------------------------------------------------------
.text$mn:000035C7                 align 4
.text$mn:000035C7 _text$mn        ends
.text$mn:000035C7
.xdata$x:000035C8 ; ===========================================================================
.xdata$x:000035C8
.xdata$x:000035C8 ; Segment type: Pure data
.xdata$x:000035C8 ; Segment permissions: Read
.xdata$x:000035C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000035C8                 assume cs:_xdata$x
.xdata$x:000035C8                 ;org 35C8h
.xdata$x:000035C8 ; COMDAT (pick associative to section at 2870)
.xdata$x:000035C8 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:000035C8                                         ; DATA XREF: .xdata$x:000035D8o
.xdata$x:000035C9                 db 0FFh
.xdata$x:000035CA                 db 0FFh
.xdata$x:000035CB                 db 0FFh
.xdata$x:000035CC                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:000035D0 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:000035D0                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:000035D1                 db    5
.xdata$x:000035D2                 db  93h ; ô
.xdata$x:000035D3                 db  19h
.xdata$x:000035D4                 db    1
.xdata$x:000035D5                 db    0
.xdata$x:000035D6                 db    0
.xdata$x:000035D7                 db    0
.xdata$x:000035D8                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:000035DC                 db    0
.xdata$x:000035DD                 db    0
.xdata$x:000035DE                 db    0
.xdata$x:000035DF                 db    0
.xdata$x:000035E0                 db    0
.xdata$x:000035E1                 db    0
.xdata$x:000035E2                 db    0
.xdata$x:000035E3                 db    0
.xdata$x:000035E4                 db    0
.xdata$x:000035E5                 db    0
.xdata$x:000035E6                 db    0
.xdata$x:000035E7                 db    0
.xdata$x:000035E8                 db    0
.xdata$x:000035E9                 db    0
.xdata$x:000035EA                 db    0
.xdata$x:000035EB                 db    0
.xdata$x:000035EC                 db    0
.xdata$x:000035ED                 db    0
.xdata$x:000035EE                 db    0
.xdata$x:000035EF                 db    0
.xdata$x:000035F0                 db    0
.xdata$x:000035F1                 db    0
.xdata$x:000035F2                 db    0
.xdata$x:000035F3                 db    0
.xdata$x:000035F3 _xdata$x        ends
.xdata$x:000035F3
.xdata$x:000035F4 ; ===========================================================================
.xdata$x:000035F4
.xdata$x:000035F4 ; Segment type: Pure data
.xdata$x:000035F4 ; Segment permissions: Read
.xdata$x:000035F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000035F4                 assume cs:_xdata$x
.xdata$x:000035F4                 ;org 35F4h
.xdata$x:000035F4 ; COMDAT (pick associative to section at 19B8)
.xdata$x:000035F4 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000035F4                                         ; DATA XREF: .xdata$x:00003604o
.xdata$x:000035F5                 db 0FFh
.xdata$x:000035F6                 db 0FFh
.xdata$x:000035F7                 db 0FFh
.xdata$x:000035F8                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000035FC __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000035FC                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000035FD                 db    5
.xdata$x:000035FE                 db  93h ; ô
.xdata$x:000035FF                 db  19h
.xdata$x:00003600                 db    1
.xdata$x:00003601                 db    0
.xdata$x:00003602                 db    0
.xdata$x:00003603                 db    0
.xdata$x:00003604                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00003608                 align 20h
.xdata$x:00003608 _xdata$x        ends
.xdata$x:00003608
.xdata$x:00003620 ; ===========================================================================
.xdata$x:00003620
.xdata$x:00003620 ; Segment type: Pure data
.xdata$x:00003620 ; Segment permissions: Read
.xdata$x:00003620 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003620                 assume cs:_xdata$x
.xdata$x:00003620                 ;org 3620h
.xdata$x:00003620 ; COMDAT (pick associative to section at 1EB4)
.xdata$x:00003620 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003620                                         ; DATA XREF: .xdata$x:00003630o
.xdata$x:00003621                 db 0FFh
.xdata$x:00003622                 db 0FFh
.xdata$x:00003623                 db 0FFh
.xdata$x:00003624                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00003628 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003628                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00003629                 db    5
.xdata$x:0000362A                 db  93h ; ô
.xdata$x:0000362B                 db  19h
.xdata$x:0000362C                 db    1
.xdata$x:0000362D                 db    0
.xdata$x:0000362E                 db    0
.xdata$x:0000362F                 db    0
.xdata$x:00003630                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00003634                 db    0
.xdata$x:00003635                 db    0
.xdata$x:00003636                 db    0
.xdata$x:00003637                 db    0
.xdata$x:00003638                 db    0
.xdata$x:00003639                 db    0
.xdata$x:0000363A                 db    0
.xdata$x:0000363B                 db    0
.xdata$x:0000363C                 db    0
.xdata$x:0000363D                 db    0
.xdata$x:0000363E                 db    0
.xdata$x:0000363F                 db    0
.xdata$x:00003640                 db    0
.xdata$x:00003641                 db    0
.xdata$x:00003642                 db    0
.xdata$x:00003643                 db    0
.xdata$x:00003644                 db    0
.xdata$x:00003645                 db    0
.xdata$x:00003646                 db    0
.xdata$x:00003647                 db    0
.xdata$x:00003648                 db    0
.xdata$x:00003649                 db    0
.xdata$x:0000364A                 db    0
.xdata$x:0000364B                 db    0
.xdata$x:0000364B _xdata$x        ends
.xdata$x:0000364B
.xdata$x:0000364C ; ===========================================================================
.xdata$x:0000364C
.xdata$x:0000364C ; Segment type: Pure data
.xdata$x:0000364C ; Segment permissions: Read
.xdata$x:0000364C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000364C                 assume cs:_xdata$x
.xdata$x:0000364C                 ;org 364Ch
.xdata$x:0000364C ; COMDAT (pick associative to section at 193C)
.xdata$x:0000364C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:0000364C                                         ; DATA XREF: .xdata$x:0000365Co
.xdata$x:0000364D                 db 0FFh
.xdata$x:0000364E                 db 0FFh
.xdata$x:0000364F                 db 0FFh
.xdata$x:00003650                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00003654 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00003654                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00003655                 db    5
.xdata$x:00003656                 db  93h ; ô
.xdata$x:00003657                 db  19h
.xdata$x:00003658                 db    1
.xdata$x:00003659                 db    0
.xdata$x:0000365A                 db    0
.xdata$x:0000365B                 db    0
.xdata$x:0000365C                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00003660                 db    0
.xdata$x:00003661                 db    0
.xdata$x:00003662                 db    0
.xdata$x:00003663                 db    0
.xdata$x:00003664                 db    0
.xdata$x:00003665                 db    0
.xdata$x:00003666                 db    0
.xdata$x:00003667                 db    0
.xdata$x:00003668                 db    0
.xdata$x:00003669                 db    0
.xdata$x:0000366A                 db    0
.xdata$x:0000366B                 db    0
.xdata$x:0000366C                 db    0
.xdata$x:0000366D                 db    0
.xdata$x:0000366E                 db    0
.xdata$x:0000366F                 db    0
.xdata$x:00003670                 db    0
.xdata$x:00003671                 db    0
.xdata$x:00003672                 db    0
.xdata$x:00003673                 db    0
.xdata$x:00003674                 db    0
.xdata$x:00003675                 db    0
.xdata$x:00003676                 db    0
.xdata$x:00003677                 db    0
.xdata$x:00003677 _xdata$x        ends
.xdata$x:00003677
.xdata$x:00003678 ; ===========================================================================
.xdata$x:00003678
.xdata$x:00003678 ; Segment type: Pure data
.xdata$x:00003678 ; Segment permissions: Read
.xdata$x:00003678 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003678                 assume cs:_xdata$x
.xdata$x:00003678                 ;org 3678h
.xdata$x:00003678 ; COMDAT (pick associative to section at 1E3C)
.xdata$x:00003678 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003678                                         ; DATA XREF: .xdata$x:00003688o
.xdata$x:00003679                 db 0FFh
.xdata$x:0000367A                 db 0FFh
.xdata$x:0000367B                 db 0FFh
.xdata$x:0000367C                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00003680 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003680                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00003681                 db    5
.xdata$x:00003682                 db  93h ; ô
.xdata$x:00003683                 db  19h
.xdata$x:00003684                 db    1
.xdata$x:00003685                 db    0
.xdata$x:00003686                 db    0
.xdata$x:00003687                 db    0
.xdata$x:00003688                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:0000368C                 db    0
.xdata$x:0000368D                 db    0
.xdata$x:0000368E                 db    0
.xdata$x:0000368F                 db    0
.xdata$x:00003690                 db    0
.xdata$x:00003691                 db    0
.xdata$x:00003692                 db    0
.xdata$x:00003693                 db    0
.xdata$x:00003694                 db    0
.xdata$x:00003695                 db    0
.xdata$x:00003696                 db    0
.xdata$x:00003697                 db    0
.xdata$x:00003698                 db    0
.xdata$x:00003699                 db    0
.xdata$x:0000369A                 db    0
.xdata$x:0000369B                 db    0
.xdata$x:0000369C                 db    0
.xdata$x:0000369D                 db    0
.xdata$x:0000369E                 db    0
.xdata$x:0000369F                 db    0
.xdata$x:000036A0                 db    0
.xdata$x:000036A1                 db    0
.xdata$x:000036A2                 db    0
.xdata$x:000036A3                 db    0
.xdata$x:000036A3 _xdata$x        ends
.xdata$x:000036A3
.xdata$x:000036A4 ; ===========================================================================
.xdata$x:000036A4
.xdata$x:000036A4 ; Segment type: Pure data
.xdata$x:000036A4 ; Segment permissions: Read
.xdata$x:000036A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000036A4                 assume cs:_xdata$x
.xdata$x:000036A4                 ;org 36A4h
.xdata$x:000036A4 ; COMDAT (pick associative to section at 1A78)
.xdata$x:000036A4 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:000036A4                                         ; DATA XREF: .xdata$x:000036B4o
.xdata$x:000036A5                 db 0FFh
.xdata$x:000036A6                 db 0FFh
.xdata$x:000036A7                 db 0FFh
.xdata$x:000036A8                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:000036AC __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:000036AC                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:000036AD                 db    5
.xdata$x:000036AE                 db  93h ; ô
.xdata$x:000036AF                 db  19h
.xdata$x:000036B0                 db    1
.xdata$x:000036B1                 db    0
.xdata$x:000036B2                 db    0
.xdata$x:000036B3                 db    0
.xdata$x:000036B4                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:000036B8                 db    0
.xdata$x:000036B9                 db    0
.xdata$x:000036BA                 db    0
.xdata$x:000036BB                 db    0
.xdata$x:000036BC                 db    0
.xdata$x:000036BD                 db    0
.xdata$x:000036BE                 db    0
.xdata$x:000036BF                 db    0
.xdata$x:000036C0                 db    0
.xdata$x:000036C1                 db    0
.xdata$x:000036C2                 db    0
.xdata$x:000036C3                 db    0
.xdata$x:000036C4                 db    0
.xdata$x:000036C5                 db    0
.xdata$x:000036C6                 db    0
.xdata$x:000036C7                 db    0
.xdata$x:000036C8                 db    0
.xdata$x:000036C9                 db    0
.xdata$x:000036CA                 db    0
.xdata$x:000036CB                 db    0
.xdata$x:000036CC                 db    0
.xdata$x:000036CD                 db    0
.xdata$x:000036CE                 db    0
.xdata$x:000036CF                 db    0
.xdata$x:000036CF _xdata$x        ends
.xdata$x:000036CF
.xdata$x:000036D0 ; ===========================================================================
.xdata$x:000036D0
.xdata$x:000036D0 ; Segment type: Pure data
.xdata$x:000036D0 ; Segment permissions: Read
.xdata$x:000036D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000036D0                 assume cs:_xdata$x
.xdata$x:000036D0                 ;org 36D0h
.xdata$x:000036D0 ; COMDAT (pick associative to section at 1F24)
.xdata$x:000036D0 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:000036D0                                         ; DATA XREF: .xdata$x:000036E0o
.xdata$x:000036D1                 db 0FFh
.xdata$x:000036D2                 db 0FFh
.xdata$x:000036D3                 db 0FFh
.xdata$x:000036D4                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:000036D8 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000036D8                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:000036D9                 db    5
.xdata$x:000036DA                 db  93h ; ô
.xdata$x:000036DB                 db  19h
.xdata$x:000036DC                 db    1
.xdata$x:000036DD                 db    0
.xdata$x:000036DE                 db    0
.xdata$x:000036DF                 db    0
.xdata$x:000036E0                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:000036E4                 db    0
.xdata$x:000036E5                 db    0
.xdata$x:000036E6                 db    0
.xdata$x:000036E7                 db    0
.xdata$x:000036E8                 db    0
.xdata$x:000036E9                 db    0
.xdata$x:000036EA                 db    0
.xdata$x:000036EB                 db    0
.xdata$x:000036EC                 db    0
.xdata$x:000036ED                 db    0
.xdata$x:000036EE                 db    0
.xdata$x:000036EF                 db    0
.xdata$x:000036F0                 db    0
.xdata$x:000036F1                 db    0
.xdata$x:000036F2                 db    0
.xdata$x:000036F3                 db    0
.xdata$x:000036F4                 db    0
.xdata$x:000036F5                 db    0
.xdata$x:000036F6                 db    0
.xdata$x:000036F7                 db    0
.xdata$x:000036F8                 db    0
.xdata$x:000036F9                 db    0
.xdata$x:000036FA                 db    0
.xdata$x:000036FB                 db    0
.xdata$x:000036FB _xdata$x        ends
.xdata$x:000036FB
.xdata$x:000036FC ; ===========================================================================
.xdata$x:000036FC
.xdata$x:000036FC ; Segment type: Pure data
.xdata$x:000036FC ; Segment permissions: Read
.xdata$x:000036FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000036FC                 assume cs:_xdata$x
.xdata$x:000036FC                 ;org 36FCh
.xdata$x:000036FC ; COMDAT (pick associative to section at 24CC)
.xdata$x:000036FC __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:000036FC                                         ; DATA XREF: .xdata$x:00003784o
.xdata$x:000036FD                 db    0
.xdata$x:000036FE                 db    0
.xdata$x:000036FF                 db    0
.xdata$x:00003700                 db    0
.xdata$x:00003701                 db    0
.xdata$x:00003702                 db    0
.xdata$x:00003703                 db    0
.xdata$x:00003704                 db    0
.xdata$x:00003705                 db    0
.xdata$x:00003706                 db    0
.xdata$x:00003707                 db    0
.xdata$x:00003708                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:0000370C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000370C                                         ; DATA XREF: .xdata$x:00003770o
.xdata$x:0000370D                 db    0
.xdata$x:0000370E                 db    0
.xdata$x:0000370F                 db    0
.xdata$x:00003710                 db    0
.xdata$x:00003711                 db    0
.xdata$x:00003712                 db    0
.xdata$x:00003713                 db    0
.xdata$x:00003714                 db    0
.xdata$x:00003715                 db    0
.xdata$x:00003716                 db    0
.xdata$x:00003717                 db    0
.xdata$x:00003718                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:0000371C __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000371C                                         ; DATA XREF: .xdata$x:00003744o
.xdata$x:0000371D                 db 0FFh
.xdata$x:0000371E                 db 0FFh
.xdata$x:0000371F                 db 0FFh
.xdata$x:00003720                 db    0
.xdata$x:00003721                 db    0
.xdata$x:00003722                 db    0
.xdata$x:00003723                 db    0
.xdata$x:00003724                 db 0FFh
.xdata$x:00003725                 db 0FFh
.xdata$x:00003726                 db 0FFh
.xdata$x:00003727                 db 0FFh
.xdata$x:00003728                 db    0
.xdata$x:00003729                 db    0
.xdata$x:0000372A                 db    0
.xdata$x:0000372B                 db    0
.xdata$x:0000372C                 db    1
.xdata$x:0000372D                 db    0
.xdata$x:0000372E                 db    0
.xdata$x:0000372F                 db    0
.xdata$x:00003730                 db    0
.xdata$x:00003731                 db    0
.xdata$x:00003732                 db    0
.xdata$x:00003733                 db    0
.xdata$x:00003734                 db    1
.xdata$x:00003735                 db    0
.xdata$x:00003736                 db    0
.xdata$x:00003737                 db    0
.xdata$x:00003738                 db    0
.xdata$x:00003739                 db    0
.xdata$x:0000373A                 db    0
.xdata$x:0000373B                 db    0
.xdata$x:0000373C __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000373C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:0000373D                 db    5
.xdata$x:0000373E                 db  93h ; ô
.xdata$x:0000373F                 db  19h
.xdata$x:00003740                 db    4
.xdata$x:00003741                 db    0
.xdata$x:00003742                 db    0
.xdata$x:00003743                 db    0
.xdata$x:00003744                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00003748                 db    2
.xdata$x:00003749                 db    0
.xdata$x:0000374A                 db    0
.xdata$x:0000374B                 db    0
.xdata$x:0000374C                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00003750                 align 20h
.xdata$x:00003760 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00003760                                         ; DATA XREF: .xdata$x:0000374Co
.xdata$x:00003761                 db    0
.xdata$x:00003762                 db    0
.xdata$x:00003763                 db    0
.xdata$x:00003764                 db    2
.xdata$x:00003765                 db    0
.xdata$x:00003766                 db    0
.xdata$x:00003767                 db    0
.xdata$x:00003768                 db    3
.xdata$x:00003769                 db    0
.xdata$x:0000376A                 db    0
.xdata$x:0000376B                 db    0
.xdata$x:0000376C                 db    1
.xdata$x:0000376D                 db    0
.xdata$x:0000376E                 db    0
.xdata$x:0000376F                 db    0
.xdata$x:00003770                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00003774                 db    0
.xdata$x:00003775                 db    0
.xdata$x:00003776                 db    0
.xdata$x:00003777                 db    0
.xdata$x:00003778                 db    0
.xdata$x:00003779                 db    0
.xdata$x:0000377A                 db    0
.xdata$x:0000377B                 db    0
.xdata$x:0000377C                 db    3
.xdata$x:0000377D                 db    0
.xdata$x:0000377E                 db    0
.xdata$x:0000377F                 db    0
.xdata$x:00003780                 db    1
.xdata$x:00003781                 db    0
.xdata$x:00003782                 db    0
.xdata$x:00003783                 db    0
.xdata$x:00003784                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00003784 _xdata$x        ends
.xdata$x:00003784
.xdata$x:00003788 ; ===========================================================================
.xdata$x:00003788
.xdata$x:00003788 ; Segment type: Pure data
.xdata$x:00003788 ; Segment permissions: Read
.xdata$x:00003788 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003788                 assume cs:_xdata$x
.xdata$x:00003788                 ;org 3788h
.xdata$x:00003788 ; COMDAT (pick associative to section at 1DB8)
.xdata$x:00003788 __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:00003788                                         ; DATA XREF: .xdata$x:00003798o
.xdata$x:00003789                 db 0FFh
.xdata$x:0000378A                 db 0FFh
.xdata$x:0000378B                 db 0FFh
.xdata$x:0000378C                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:00003790 __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00003790                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:00003791                 db    5
.xdata$x:00003792                 db  93h ; ô
.xdata$x:00003793                 db  19h
.xdata$x:00003794                 db    1
.xdata$x:00003795                 db    0
.xdata$x:00003796                 db    0
.xdata$x:00003797                 db    0
.xdata$x:00003798                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:0000379C                 db    0
.xdata$x:0000379D                 db    0
.xdata$x:0000379E                 db    0
.xdata$x:0000379F                 db    0
.xdata$x:000037A0                 db    0
.xdata$x:000037A1                 db    0
.xdata$x:000037A2                 db    0
.xdata$x:000037A3                 db    0
.xdata$x:000037A4                 db    0
.xdata$x:000037A5                 db    0
.xdata$x:000037A6                 db    0
.xdata$x:000037A7                 db    0
.xdata$x:000037A8                 db    0
.xdata$x:000037A9                 db    0
.xdata$x:000037AA                 db    0
.xdata$x:000037AB                 db    0
.xdata$x:000037AC                 db    0
.xdata$x:000037AD                 db    0
.xdata$x:000037AE                 db    0
.xdata$x:000037AF                 db    0
.xdata$x:000037B0                 db    0
.xdata$x:000037B1                 db    0
.xdata$x:000037B2                 db    0
.xdata$x:000037B3                 db    0
.xdata$x:000037B3 _xdata$x        ends
.xdata$x:000037B3
.xdata$x:000037B4 ; ===========================================================================
.xdata$x:000037B4
.xdata$x:000037B4 ; Segment type: Pure data
.xdata$x:000037B4 ; Segment permissions: Read
.xdata$x:000037B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000037B4                 assume cs:_xdata$x
.xdata$x:000037B4                 ;org 37B4h
.xdata$x:000037B4 ; COMDAT (pick associative to section at 21A4)
.xdata$x:000037B4 __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:000037B4                                         ; DATA XREF: .xdata$x:000037C4o
.xdata$x:000037B5                 db 0FFh
.xdata$x:000037B6                 db 0FFh
.xdata$x:000037B7                 db 0FFh
.xdata$x:000037B8                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:000037BC __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:000037BC                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:000037BD                 db    5
.xdata$x:000037BE                 db  93h ; ô
.xdata$x:000037BF                 db  19h
.xdata$x:000037C0                 db    1
.xdata$x:000037C1                 db    0
.xdata$x:000037C2                 db    0
.xdata$x:000037C3                 db    0
.xdata$x:000037C4                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:000037C8                 align 20h
.xdata$x:000037C8 _xdata$x        ends
.xdata$x:000037C8
.xdata$x:000037E0 ; ===========================================================================
.xdata$x:000037E0
.xdata$x:000037E0 ; Segment type: Pure data
.xdata$x:000037E0 ; Segment permissions: Read
.xdata$x:000037E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000037E0                 assume cs:_xdata$x
.xdata$x:000037E0                 ;org 37E0h
.xdata$x:000037E0 ; COMDAT (pick associative to section at 1D34)
.xdata$x:000037E0 __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:000037E0                                         ; DATA XREF: .xdata$x:000037F0o
.xdata$x:000037E1                 db 0FFh
.xdata$x:000037E2                 db 0FFh
.xdata$x:000037E3                 db 0FFh
.xdata$x:000037E4                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:000037E8 __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:000037E8                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:000037E9                 db    5
.xdata$x:000037EA                 db  93h ; ô
.xdata$x:000037EB                 db  19h
.xdata$x:000037EC                 db    1
.xdata$x:000037ED                 db    0
.xdata$x:000037EE                 db    0
.xdata$x:000037EF                 db    0
.xdata$x:000037F0                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:000037F4                 db    0
.xdata$x:000037F5                 db    0
.xdata$x:000037F6                 db    0
.xdata$x:000037F7                 db    0
.xdata$x:000037F8                 db    0
.xdata$x:000037F9                 db    0
.xdata$x:000037FA                 db    0
.xdata$x:000037FB                 db    0
.xdata$x:000037FC                 db    0
.xdata$x:000037FD                 db    0
.xdata$x:000037FE                 db    0
.xdata$x:000037FF                 db    0
.xdata$x:00003800                 db    0
.xdata$x:00003801                 db    0
.xdata$x:00003802                 db    0
.xdata$x:00003803                 db    0
.xdata$x:00003804                 db    0
.xdata$x:00003805                 db    0
.xdata$x:00003806                 db    0
.xdata$x:00003807                 db    0
.xdata$x:00003808                 db    0
.xdata$x:00003809                 db    0
.xdata$x:0000380A                 db    0
.xdata$x:0000380B                 db    0
.xdata$x:0000380B _xdata$x        ends
.xdata$x:0000380B
.xdata$x:0000380C ; ===========================================================================
.xdata$x:0000380C
.xdata$x:0000380C ; Segment type: Pure data
.xdata$x:0000380C ; Segment permissions: Read
.xdata$x:0000380C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000380C                 assume cs:_xdata$x
.xdata$x:0000380C                 ;org 380Ch
.xdata$x:0000380C ; COMDAT (pick associative to section at 1B84)
.xdata$x:0000380C __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000380C                                         ; DATA XREF: .xdata$x:0000381Co
.xdata$x:0000380D                 db 0FFh
.xdata$x:0000380E                 db 0FFh
.xdata$x:0000380F                 db 0FFh
.xdata$x:00003810                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00003814 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00003814                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00003815                 db    5
.xdata$x:00003816                 db  93h ; ô
.xdata$x:00003817                 db  19h
.xdata$x:00003818                 db    1
.xdata$x:00003819                 db    0
.xdata$x:0000381A                 db    0
.xdata$x:0000381B                 db    0
.xdata$x:0000381C                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00003820                 db    0
.xdata$x:00003821                 db    0
.xdata$x:00003822                 db    0
.xdata$x:00003823                 db    0
.xdata$x:00003824                 db    0
.xdata$x:00003825                 db    0
.xdata$x:00003826                 db    0
.xdata$x:00003827                 db    0
.xdata$x:00003828                 db    0
.xdata$x:00003829                 db    0
.xdata$x:0000382A                 db    0
.xdata$x:0000382B                 db    0
.xdata$x:0000382C                 db    0
.xdata$x:0000382D                 db    0
.xdata$x:0000382E                 db    0
.xdata$x:0000382F                 db    0
.xdata$x:00003830                 db    0
.xdata$x:00003831                 db    0
.xdata$x:00003832                 db    0
.xdata$x:00003833                 db    0
.xdata$x:00003834                 db    0
.xdata$x:00003835                 db    0
.xdata$x:00003836                 db    0
.xdata$x:00003837                 db    0
.xdata$x:00003837 _xdata$x        ends
.xdata$x:00003837
.xdata$x:00003838 ; ===========================================================================
.xdata$x:00003838
.xdata$x:00003838 ; Segment type: Pure data
.xdata$x:00003838 ; Segment permissions: Read
.xdata$x:00003838 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003838                 assume cs:_xdata$x
.xdata$x:00003838                 ;org 3838h
.xdata$x:00003838 ; COMDAT (pick associative to section at 31FC)
.xdata$x:00003838 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00003838                                         ; DATA XREF: .xdata$x:00003848o
.xdata$x:00003839                 db 0FFh
.xdata$x:0000383A                 db 0FFh
.xdata$x:0000383B                 db 0FFh
.xdata$x:0000383C                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00003840 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00003840                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00003841                 db    5
.xdata$x:00003842                 db  93h ; ô
.xdata$x:00003843                 db  19h
.xdata$x:00003844                 db    1
.xdata$x:00003845                 db    0
.xdata$x:00003846                 db    0
.xdata$x:00003847                 db    0
.xdata$x:00003848                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000384C                 db    0
.xdata$x:0000384D                 db    0
.xdata$x:0000384E                 db    0
.xdata$x:0000384F                 db    0
.xdata$x:00003850                 db    0
.xdata$x:00003851                 db    0
.xdata$x:00003852                 db    0
.xdata$x:00003853                 db    0
.xdata$x:00003854                 db    0
.xdata$x:00003855                 db    0
.xdata$x:00003856                 db    0
.xdata$x:00003857                 db    0
.xdata$x:00003858                 db    0
.xdata$x:00003859                 db    0
.xdata$x:0000385A                 db    0
.xdata$x:0000385B                 db    0
.xdata$x:0000385C                 db    0
.xdata$x:0000385D                 db    0
.xdata$x:0000385E                 db    0
.xdata$x:0000385F                 db    0
.xdata$x:00003860                 db    0
.xdata$x:00003861                 db    0
.xdata$x:00003862                 db    0
.xdata$x:00003863                 db    0
.xdata$x:00003863 _xdata$x        ends
.xdata$x:00003863
.xdata$x:00003864 ; ===========================================================================
.xdata$x:00003864
.xdata$x:00003864 ; Segment type: Pure data
.xdata$x:00003864 ; Segment permissions: Read
.xdata$x:00003864 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003864                 assume cs:_xdata$x
.xdata$x:00003864                 ;org 3864h
.xdata$x:00003864 ; COMDAT (pick associative to section at 2040)
.xdata$x:00003864 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00003864                                         ; DATA XREF: .xdata$x:00003874o
.xdata$x:00003865                 db 0FFh
.xdata$x:00003866                 db 0FFh
.xdata$x:00003867                 db 0FFh
.xdata$x:00003868                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:0000386C __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000386C                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:0000386D                 db    5
.xdata$x:0000386E                 db  93h ; ô
.xdata$x:0000386F                 db  19h
.xdata$x:00003870                 db    1
.xdata$x:00003871                 db    0
.xdata$x:00003872                 db    0
.xdata$x:00003873                 db    0
.xdata$x:00003874                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00003878                 db    0
.xdata$x:00003879                 db    0
.xdata$x:0000387A                 db    0
.xdata$x:0000387B                 db    0
.xdata$x:0000387C                 db    0
.xdata$x:0000387D                 db    0
.xdata$x:0000387E                 db    0
.xdata$x:0000387F                 db    0
.xdata$x:00003880                 db    0
.xdata$x:00003881                 db    0
.xdata$x:00003882                 db    0
.xdata$x:00003883                 db    0
.xdata$x:00003884                 db    0
.xdata$x:00003885                 db    0
.xdata$x:00003886                 db    0
.xdata$x:00003887                 db    0
.xdata$x:00003888                 db    0
.xdata$x:00003889                 db    0
.xdata$x:0000388A                 db    0
.xdata$x:0000388B                 db    0
.xdata$x:0000388C                 db    0
.xdata$x:0000388D                 db    0
.xdata$x:0000388E                 db    0
.xdata$x:0000388F                 db    0
.xdata$x:0000388F _xdata$x        ends
.xdata$x:0000388F
.xdata$x:00003890 ; ===========================================================================
.xdata$x:00003890
.xdata$x:00003890 ; Segment type: Pure data
.xdata$x:00003890 ; Segment permissions: Read
.xdata$x:00003890 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003890                 assume cs:_xdata$x
.xdata$x:00003890                 ;org 3890h
.xdata$x:00003890 ; COMDAT (pick associative to section at 1C00)
.xdata$x:00003890 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00003890                                         ; DATA XREF: .xdata$x:000038A0o
.xdata$x:00003891                 db 0FFh
.xdata$x:00003892                 db 0FFh
.xdata$x:00003893                 db 0FFh
.xdata$x:00003894                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00003898 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00003898                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00003899                 db    5
.xdata$x:0000389A                 db  93h ; ô
.xdata$x:0000389B                 db  19h
.xdata$x:0000389C                 db    1
.xdata$x:0000389D                 db    0
.xdata$x:0000389E                 db    0
.xdata$x:0000389F                 db    0
.xdata$x:000038A0                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:000038A4                 db    0
.xdata$x:000038A5                 db    0
.xdata$x:000038A6                 db    0
.xdata$x:000038A7                 db    0
.xdata$x:000038A8                 db    0
.xdata$x:000038A9                 db    0
.xdata$x:000038AA                 db    0
.xdata$x:000038AB                 db    0
.xdata$x:000038AC                 db    0
.xdata$x:000038AD                 db    0
.xdata$x:000038AE                 db    0
.xdata$x:000038AF                 db    0
.xdata$x:000038B0                 db    0
.xdata$x:000038B1                 db    0
.xdata$x:000038B2                 db    0
.xdata$x:000038B3                 db    0
.xdata$x:000038B4                 db    0
.xdata$x:000038B5                 db    0
.xdata$x:000038B6                 db    0
.xdata$x:000038B7                 db    0
.xdata$x:000038B8                 db    0
.xdata$x:000038B9                 db    0
.xdata$x:000038BA                 db    0
.xdata$x:000038BB                 db    0
.xdata$x:000038BB _xdata$x        ends
.xdata$x:000038BB
.xdata$x:000038BC ; ===========================================================================
.xdata$x:000038BC
.xdata$x:000038BC ; Segment type: Pure data
.xdata$x:000038BC ; Segment permissions: Read
.xdata$x:000038BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000038BC                 assume cs:_xdata$x
.xdata$x:000038BC                 ;org 38BCh
.xdata$x:000038BC ; COMDAT (pick associative to section at 32B4)
.xdata$x:000038BC __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000038BC                                         ; DATA XREF: .xdata$x:000038CCo
.xdata$x:000038BD                 db 0FFh
.xdata$x:000038BE                 db 0FFh
.xdata$x:000038BF                 db 0FFh
.xdata$x:000038C0                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000038C4 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000038C4                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000038C5                 db    5
.xdata$x:000038C6                 db  93h ; ô
.xdata$x:000038C7                 db  19h
.xdata$x:000038C8                 db    1
.xdata$x:000038C9                 db    0
.xdata$x:000038CA                 db    0
.xdata$x:000038CB                 db    0
.xdata$x:000038CC                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000038D0                 db    0
.xdata$x:000038D1                 db    0
.xdata$x:000038D2                 db    0
.xdata$x:000038D3                 db    0
.xdata$x:000038D4                 db    0
.xdata$x:000038D5                 db    0
.xdata$x:000038D6                 db    0
.xdata$x:000038D7                 db    0
.xdata$x:000038D8                 db    0
.xdata$x:000038D9                 db    0
.xdata$x:000038DA                 db    0
.xdata$x:000038DB                 db    0
.xdata$x:000038DC                 db    0
.xdata$x:000038DD                 db    0
.xdata$x:000038DE                 db    0
.xdata$x:000038DF                 db    0
.xdata$x:000038E0                 db    0
.xdata$x:000038E1                 db    0
.xdata$x:000038E2                 db    0
.xdata$x:000038E3                 db    0
.xdata$x:000038E4                 db    0
.xdata$x:000038E5                 db    0
.xdata$x:000038E6                 db    0
.xdata$x:000038E7                 db    0
.xdata$x:000038E7 _xdata$x        ends
.xdata$x:000038E7
.xdata$x:000038E8 ; ===========================================================================
.xdata$x:000038E8
.xdata$x:000038E8 ; Segment type: Pure data
.xdata$x:000038E8 ; Segment permissions: Read
.xdata$x:000038E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000038E8                 assume cs:_xdata$x
.xdata$x:000038E8                 ;org 38E8h
.xdata$x:000038E8 ; COMDAT (pick associative to section at 20B0)
.xdata$x:000038E8 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000038E8                                         ; DATA XREF: .xdata$x:000038F8o
.xdata$x:000038E9                 db 0FFh
.xdata$x:000038EA                 db 0FFh
.xdata$x:000038EB                 db 0FFh
.xdata$x:000038EC                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:000038F0 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000038F0                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:000038F1                 db    5
.xdata$x:000038F2                 db  93h ; ô
.xdata$x:000038F3                 db  19h
.xdata$x:000038F4                 db    1
.xdata$x:000038F5                 db    0
.xdata$x:000038F6                 db    0
.xdata$x:000038F7                 db    0
.xdata$x:000038F8                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000038FC                 db    0
.xdata$x:000038FD                 db    0
.xdata$x:000038FE                 db    0
.xdata$x:000038FF                 db    0
.xdata$x:00003900                 db    0
.xdata$x:00003901                 db    0
.xdata$x:00003902                 db    0
.xdata$x:00003903                 db    0
.xdata$x:00003904                 db    0
.xdata$x:00003905                 db    0
.xdata$x:00003906                 db    0
.xdata$x:00003907                 db    0
.xdata$x:00003908                 db    0
.xdata$x:00003909                 db    0
.xdata$x:0000390A                 db    0
.xdata$x:0000390B                 db    0
.xdata$x:0000390C                 db    0
.xdata$x:0000390D                 db    0
.xdata$x:0000390E                 db    0
.xdata$x:0000390F                 db    0
.xdata$x:00003910                 db    0
.xdata$x:00003911                 db    0
.xdata$x:00003912                 db    0
.xdata$x:00003913                 db    0
.xdata$x:00003913 _xdata$x        ends
.xdata$x:00003913
.xdata$x:00003914 ; ===========================================================================
.xdata$x:00003914
.xdata$x:00003914 ; Segment type: Pure data
.xdata$x:00003914 ; Segment permissions: Read
.xdata$x:00003914 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003914                 assume cs:_xdata$x
.xdata$x:00003914                 ;org 3914h
.xdata$x:00003914 ; COMDAT (pick associative to section at 1C7C)
.xdata$x:00003914 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00003914                                         ; DATA XREF: .xdata$x:00003924o
.xdata$x:00003915                 db 0FFh
.xdata$x:00003916                 db 0FFh
.xdata$x:00003917                 db 0FFh
.xdata$x:00003918                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:0000391C __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000391C                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:0000391D                 db    5
.xdata$x:0000391E                 db  93h ; ô
.xdata$x:0000391F                 db  19h
.xdata$x:00003920                 db    1
.xdata$x:00003921                 db    0
.xdata$x:00003922                 db    0
.xdata$x:00003923                 db    0
.xdata$x:00003924                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00003928                 align 20h
.xdata$x:00003928 _xdata$x        ends
.xdata$x:00003928
.xdata$x:00003940 ; ===========================================================================
.xdata$x:00003940
.xdata$x:00003940 ; Segment type: Pure data
.xdata$x:00003940 ; Segment permissions: Read
.xdata$x:00003940 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003940                 assume cs:_xdata$x
.xdata$x:00003940                 ;org 3940h
.xdata$x:00003940 ; COMDAT (pick associative to section at 3378)
.xdata$x:00003940 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00003940                                         ; DATA XREF: .xdata$x:00003950o
.xdata$x:00003941                 db 0FFh
.xdata$x:00003942                 db 0FFh
.xdata$x:00003943                 db 0FFh
.xdata$x:00003944                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00003948 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00003948                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00003949                 db    5
.xdata$x:0000394A                 db  93h ; ô
.xdata$x:0000394B                 db  19h
.xdata$x:0000394C                 db    1
.xdata$x:0000394D                 db    0
.xdata$x:0000394E                 db    0
.xdata$x:0000394F                 db    0
.xdata$x:00003950                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00003954                 db    0
.xdata$x:00003955                 db    0
.xdata$x:00003956                 db    0
.xdata$x:00003957                 db    0
.xdata$x:00003958                 db    0
.xdata$x:00003959                 db    0
.xdata$x:0000395A                 db    0
.xdata$x:0000395B                 db    0
.xdata$x:0000395C                 db    0
.xdata$x:0000395D                 db    0
.xdata$x:0000395E                 db    0
.xdata$x:0000395F                 db    0
.xdata$x:00003960                 db    0
.xdata$x:00003961                 db    0
.xdata$x:00003962                 db    0
.xdata$x:00003963                 db    0
.xdata$x:00003964                 db    0
.xdata$x:00003965                 db    0
.xdata$x:00003966                 db    0
.xdata$x:00003967                 db    0
.xdata$x:00003968                 db    0
.xdata$x:00003969                 db    0
.xdata$x:0000396A                 db    0
.xdata$x:0000396B                 db    0
.xdata$x:0000396B _xdata$x        ends
.xdata$x:0000396B
.xdata$x:0000396C ; ===========================================================================
.xdata$x:0000396C
.xdata$x:0000396C ; Segment type: Pure data
.xdata$x:0000396C ; Segment permissions: Read
.xdata$x:0000396C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000396C                 assume cs:_xdata$x
.xdata$x:0000396C                 ;org 396Ch
.xdata$x:0000396C ; COMDAT (pick associative to section at 2120)
.xdata$x:0000396C __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000396C                                         ; DATA XREF: .xdata$x:0000397Co
.xdata$x:0000396D                 db 0FFh
.xdata$x:0000396E                 db 0FFh
.xdata$x:0000396F                 db 0FFh
.xdata$x:00003970                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00003974 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00003974                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00003975                 db    5
.xdata$x:00003976                 db  93h ; ô
.xdata$x:00003977                 db  19h
.xdata$x:00003978                 db    1
.xdata$x:00003979                 db    0
.xdata$x:0000397A                 db    0
.xdata$x:0000397B                 db    0
.xdata$x:0000397C                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00003980                 db    0
.xdata$x:00003981                 db    0
.xdata$x:00003982                 db    0
.xdata$x:00003983                 db    0
.xdata$x:00003984                 db    0
.xdata$x:00003985                 db    0
.xdata$x:00003986                 db    0
.xdata$x:00003987                 db    0
.xdata$x:00003988                 db    0
.xdata$x:00003989                 db    0
.xdata$x:0000398A                 db    0
.xdata$x:0000398B                 db    0
.xdata$x:0000398C                 db    0
.xdata$x:0000398D                 db    0
.xdata$x:0000398E                 db    0
.xdata$x:0000398F                 db    0
.xdata$x:00003990                 db    0
.xdata$x:00003991                 db    0
.xdata$x:00003992                 db    0
.xdata$x:00003993                 db    0
.xdata$x:00003994                 db    0
.xdata$x:00003995                 db    0
.xdata$x:00003996                 db    0
.xdata$x:00003997                 db    0
.xdata$x:00003997 _xdata$x        ends
.xdata$x:00003997
.xdata$x:00003998 ; ===========================================================================
.xdata$x:00003998
.xdata$x:00003998 ; Segment type: Pure data
.xdata$x:00003998 ; Segment permissions: Read
.xdata$x:00003998 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003998                 assume cs:_xdata$x
.xdata$x:00003998                 ;org 3998h
.xdata$x:00003998 __unwindtable$??0Splitter@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:000039A8o
.xdata$x:00003999                 db 0FFh
.xdata$x:0000399A                 db 0FFh
.xdata$x:0000399B                 db 0FFh
.xdata$x:0000399C                 dd offset __unwindfunclet$??0Splitter@@QAE@XZ$0
.xdata$x:000039A0 __ehfuncinfo$??0Splitter@@QAE@XZ db  22h ; "
.xdata$x:000039A0                                         ; DATA XREF: __ehhandler$??0Splitter@@QAE@XZ+11o
.xdata$x:000039A1                 db    5
.xdata$x:000039A2                 db  93h ; ô
.xdata$x:000039A3                 db  19h
.xdata$x:000039A4                 db    1
.xdata$x:000039A5                 db    0
.xdata$x:000039A6                 db    0
.xdata$x:000039A7                 db    0
.xdata$x:000039A8                 dd offset __unwindtable$??0Splitter@@QAE@XZ
.xdata$x:000039AC                 db    0
.xdata$x:000039AD                 db    0
.xdata$x:000039AE                 db    0
.xdata$x:000039AF                 db    0
.xdata$x:000039B0                 db    0
.xdata$x:000039B1                 db    0
.xdata$x:000039B2                 db    0
.xdata$x:000039B3                 db    0
.xdata$x:000039B4                 db    0
.xdata$x:000039B5                 db    0
.xdata$x:000039B6                 db    0
.xdata$x:000039B7                 db    0
.xdata$x:000039B8                 db    0
.xdata$x:000039B9                 db    0
.xdata$x:000039BA                 db    0
.xdata$x:000039BB                 db    0
.xdata$x:000039BC                 db    0
.xdata$x:000039BD                 db    0
.xdata$x:000039BE                 db    0
.xdata$x:000039BF                 db    0
.xdata$x:000039C0                 db    0
.xdata$x:000039C1                 db    0
.xdata$x:000039C2                 db    0
.xdata$x:000039C3                 db    0
.xdata$x:000039C3 _xdata$x        ends
.xdata$x:000039C3
.xdata$x:000039C4 ; ===========================================================================
.xdata$x:000039C4
.xdata$x:000039C4 ; Segment type: Pure data
.xdata$x:000039C4 ; Segment permissions: Read
.xdata$x:000039C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000039C4                 assume cs:_xdata$x
.xdata$x:000039C4                 ;org 39C4h
.xdata$x:000039C4 ; COMDAT (pick associative to section at 1FA0)
.xdata$x:000039C4 __unwindtable$??1Splitter@@UAE@XZ db 0FFh ; DATA XREF: .xdata$x:000039D4o
.xdata$x:000039C5                 db 0FFh
.xdata$x:000039C6                 db 0FFh
.xdata$x:000039C7                 db 0FFh
.xdata$x:000039C8                 dd offset __unwindfunclet$??1Splitter@@UAE@XZ$0
.xdata$x:000039CC __ehfuncinfo$??1Splitter@@UAE@XZ db  22h ; "
.xdata$x:000039CC                                         ; DATA XREF: __ehhandler$??1Splitter@@UAE@XZ+11o
.xdata$x:000039CD                 db    5
.xdata$x:000039CE                 db  93h ; ô
.xdata$x:000039CF                 db  19h
.xdata$x:000039D0                 db    1
.xdata$x:000039D1                 db    0
.xdata$x:000039D2                 db    0
.xdata$x:000039D3                 db    0
.xdata$x:000039D4                 dd offset __unwindtable$??1Splitter@@UAE@XZ
.xdata$x:000039D8                 db    0
.xdata$x:000039D9                 db    0
.xdata$x:000039DA                 db    0
.xdata$x:000039DB                 db    0
.xdata$x:000039DC                 db    0
.xdata$x:000039DD                 db    0
.xdata$x:000039DE                 db    0
.xdata$x:000039DF                 db    0
.xdata$x:000039E0                 db    0
.xdata$x:000039E1                 db    0
.xdata$x:000039E2                 db    0
.xdata$x:000039E3                 db    0
.xdata$x:000039E4                 db    0
.xdata$x:000039E5                 db    0
.xdata$x:000039E6                 db    0
.xdata$x:000039E7                 db    0
.xdata$x:000039E8                 db    0
.xdata$x:000039E9                 db    0
.xdata$x:000039EA                 db    0
.xdata$x:000039EB                 db    0
.xdata$x:000039EC                 db    0
.xdata$x:000039ED                 db    0
.xdata$x:000039EE                 db    0
.xdata$x:000039EF                 db    0
.xdata$x:000039EF _xdata$x        ends
.xdata$x:000039EF
.xdata$x:000039F0 ; ===========================================================================
.xdata$x:000039F0
.xdata$x:000039F0 ; Segment type: Pure data
.xdata$x:000039F0 ; Segment permissions: Read
.xdata$x:000039F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000039F0                 assume cs:_xdata$x
.xdata$x:000039F0                 ;org 39F0h
.xdata$x:000039F0 ; COMDAT (pick associative to section at 1820)
.xdata$x:000039F0 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:000039F0                                         ; DATA XREF: .xdata$x:00003A00o
.xdata$x:000039F1                 db 0FFh
.xdata$x:000039F2                 db 0FFh
.xdata$x:000039F3                 db 0FFh
.xdata$x:000039F4                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:000039F8 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:000039F8                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:000039F9                 db    5
.xdata$x:000039FA                 db  93h ; ô
.xdata$x:000039FB                 db  19h
.xdata$x:000039FC                 db    1
.xdata$x:000039FD                 db    0
.xdata$x:000039FE                 db    0
.xdata$x:000039FF                 db    0
.xdata$x:00003A00                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00003A04                 db    0
.xdata$x:00003A05                 db    0
.xdata$x:00003A06                 db    0
.xdata$x:00003A07                 db    0
.xdata$x:00003A08                 db    0
.xdata$x:00003A09                 db    0
.xdata$x:00003A0A                 db    0
.xdata$x:00003A0B                 db    0
.xdata$x:00003A0C                 db    0
.xdata$x:00003A0D                 db    0
.xdata$x:00003A0E                 db    0
.xdata$x:00003A0F                 db    0
.xdata$x:00003A10                 db    0
.xdata$x:00003A11                 db    0
.xdata$x:00003A12                 db    0
.xdata$x:00003A13                 db    0
.xdata$x:00003A14                 db    0
.xdata$x:00003A15                 db    0
.xdata$x:00003A16                 db    0
.xdata$x:00003A17                 db    0
.xdata$x:00003A18                 db    0
.xdata$x:00003A19                 db    0
.xdata$x:00003A1A                 db    0
.xdata$x:00003A1B                 db    0
.xdata$x:00003A1B _xdata$x        ends
.xdata$x:00003A1B
.xdata$x:00003A1C ; ===========================================================================
.xdata$x:00003A1C
.xdata$x:00003A1C ; Segment type: Pure data
.xdata$x:00003A1C ; Segment permissions: Read
.xdata$x:00003A1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003A1C                 assume cs:_xdata$x
.xdata$x:00003A1C                 ;org 3A1Ch
.xdata$x:00003A1C ; COMDAT (pick associative to section at 174C)
.xdata$x:00003A1C __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00003A1C                                         ; DATA XREF: .xdata$x:00003A2Co
.xdata$x:00003A1D                 db 0FFh
.xdata$x:00003A1E                 db 0FFh
.xdata$x:00003A1F                 db 0FFh
.xdata$x:00003A20                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00003A24 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00003A24                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00003A25                 db    5
.xdata$x:00003A26                 db  93h ; ô
.xdata$x:00003A27                 db  19h
.xdata$x:00003A28                 db    1
.xdata$x:00003A29                 db    0
.xdata$x:00003A2A                 db    0
.xdata$x:00003A2B                 db    0
.xdata$x:00003A2C                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00003A30                 db    0
.xdata$x:00003A31                 db    0
.xdata$x:00003A32                 db    0
.xdata$x:00003A33                 db    0
.xdata$x:00003A34                 db    0
.xdata$x:00003A35                 db    0
.xdata$x:00003A36                 db    0
.xdata$x:00003A37                 db    0
.xdata$x:00003A38                 db    0
.xdata$x:00003A39                 db    0
.xdata$x:00003A3A                 db    0
.xdata$x:00003A3B                 db    0
.xdata$x:00003A3C                 db    0
.xdata$x:00003A3D                 db    0
.xdata$x:00003A3E                 db    0
.xdata$x:00003A3F                 db    0
.xdata$x:00003A40                 db    0
.xdata$x:00003A41                 db    0
.xdata$x:00003A42                 db    0
.xdata$x:00003A43                 db    0
.xdata$x:00003A44                 db    0
.xdata$x:00003A45                 db    0
.xdata$x:00003A46                 db    0
.xdata$x:00003A47                 db    0
.xdata$x:00003A47 _xdata$x        ends
.xdata$x:00003A47
.rdata:00003A48 ; ===========================================================================
.rdata:00003A48
.rdata:00003A48 ; Segment type: Pure data
.rdata:00003A48 ; Segment permissions: Read
.rdata:00003A48 _rdata          segment dword public 'DATA' use32
.rdata:00003A48                 assume cs:_rdata
.rdata:00003A48                 ;org 3A48h
.rdata:00003A48 ; COMDAT (pick largest)
.rdata:00003A48                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:00003A4C                 public ??_7runtime_error@std@@6B@
.rdata:00003A4C ; const std::runtime_error::`vftable'
.rdata:00003A4C ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:00003A4C                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:00003A4C                                         ; std::runtime_error::runtime_error(char const *)+3Co
.rdata:00003A4C                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:00003A50                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:00003A50 _rdata          ends
.rdata:00003A50
.xdata$x:00003A54 ; ===========================================================================
.xdata$x:00003A54
.xdata$x:00003A54 ; Segment type: Pure data
.xdata$x:00003A54 ; Segment permissions: Read
.xdata$x:00003A54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003A54                 assume cs:_xdata$x
.xdata$x:00003A54                 ;org 3A54h
.xdata$x:00003A54 ; COMDAT (pick any)
.xdata$x:00003A54                 public __TI2?AVruntime_error@std@@
.xdata$x:00003A54 __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+29o
.xdata$x:00003A54                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+4Ao ...
.xdata$x:00003A55                 db    0
.xdata$x:00003A56                 db    0
.xdata$x:00003A57                 db    0
.xdata$x:00003A58                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:00003A5C                 align 10h
.xdata$x:00003A60                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:00003A60 _xdata$x        ends
.xdata$x:00003A60
.xdata$x:00003A64 ; ===========================================================================
.xdata$x:00003A64
.xdata$x:00003A64 ; Segment type: Pure data
.xdata$x:00003A64 ; Segment permissions: Read
.xdata$x:00003A64 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003A64                 assume cs:_xdata$x
.xdata$x:00003A64                 ;org 3A64h
.xdata$x:00003A64 ; COMDAT (pick any)
.xdata$x:00003A64                 public __CTA2?AVruntime_error@std@@
.xdata$x:00003A64 __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:00003A60o
.xdata$x:00003A65                 db    0
.xdata$x:00003A66                 db    0
.xdata$x:00003A67                 db    0
.xdata$x:00003A68                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00003A6C                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00003A6C _xdata$x        ends
.xdata$x:00003A6C
.data$r:00003A70 ; ===========================================================================
.data$r:00003A70
.data$r:00003A70 ; Segment type: Pure data
.data$r:00003A70 ; Segment permissions: Read/Write
.data$r:00003A70 _data$r         segment dword public 'DATA' use32
.data$r:00003A70                 assume cs:_data$r
.data$r:00003A70                 ;org 3A70h
.data$r:00003A70 ; COMDAT (pick any)
.data$r:00003A70                 public ??_R0?AVruntime_error@std@@@8
.data$r:00003A70 ; class std::runtime_error `RTTI Type Descriptor'
.data$r:00003A70 ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003A70                                         ; DATA XREF: .xdata$x:00003A94o
.data$r:00003A70                                         ; .rdata$r:00003D30o ...
.data$r:00003A70                                         ; const type_info::`vftable'
.data$r:00003A74                 align 8
.data$r:00003A78 a_?avruntime_er db '.?AVruntime_error@std@@',0
.data$r:00003A78 _data$r         ends
.data$r:00003A78
.xdata$x:00003A90 ; ===========================================================================
.xdata$x:00003A90
.xdata$x:00003A90 ; Segment type: Pure data
.xdata$x:00003A90 ; Segment permissions: Read
.xdata$x:00003A90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003A90                 assume cs:_xdata$x
.xdata$x:00003A90                 ;org 3A90h
.xdata$x:00003A90 ; COMDAT (pick any)
.xdata$x:00003A90                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00003A90 __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00003A90                                         ; DATA XREF: .xdata$x:00003A68o
.xdata$x:00003A91                 db    0
.xdata$x:00003A92                 db    0
.xdata$x:00003A93                 db    0
.xdata$x:00003A94                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:00003A98                 db    0
.xdata$x:00003A99                 db    0
.xdata$x:00003A9A                 db    0
.xdata$x:00003A9B                 db    0
.xdata$x:00003A9C                 db 0FFh
.xdata$x:00003A9D                 db 0FFh
.xdata$x:00003A9E                 db 0FFh
.xdata$x:00003A9F                 db 0FFh
.xdata$x:00003AA0                 db    0
.xdata$x:00003AA1                 db    0
.xdata$x:00003AA2                 db    0
.xdata$x:00003AA3                 db    0
.xdata$x:00003AA4                 db  0Ch
.xdata$x:00003AA5                 db    0
.xdata$x:00003AA6                 db    0
.xdata$x:00003AA7                 db    0
.xdata$x:00003AA8                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:00003AA8 _xdata$x        ends
.xdata$x:00003AA8
.data$r:00003AAC ; ===========================================================================
.data$r:00003AAC
.data$r:00003AAC ; Segment type: Pure data
.data$r:00003AAC ; Segment permissions: Read/Write
.data$r:00003AAC _data$r         segment dword public 'DATA' use32
.data$r:00003AAC                 assume cs:_data$r
.data$r:00003AAC                 ;org 3AACh
.data$r:00003AAC ; COMDAT (pick any)
.data$r:00003AAC                 public ??_R0?AVexception@std@@@8
.data$r:00003AAC ; class std::exception `RTTI Type Descriptor'
.data$r:00003AAC ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003AAC                                         ; DATA XREF: .xdata$x:00003ACCo
.data$r:00003AAC                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003AAC                                         ; const type_info::`vftable'
.data$r:00003AB0                 db    0
.data$r:00003AB1                 db    0
.data$r:00003AB2                 db    0
.data$r:00003AB3                 db    0
.data$r:00003AB4                 db  2Eh ; .
.data$r:00003AB5                 db  3Fh ; ?
.data$r:00003AB6                 db  41h ; A
.data$r:00003AB7                 db  56h ; V
.data$r:00003AB8                 db  65h ; e
.data$r:00003AB9                 db  78h ; x
.data$r:00003ABA                 db  63h ; c
.data$r:00003ABB                 db  65h ; e
.data$r:00003ABC                 db  70h ; p
.data$r:00003ABD                 db  74h ; t
.data$r:00003ABE                 db  69h ; i
.data$r:00003ABF                 db  6Fh ; o
.data$r:00003AC0                 db  6Eh ; n
.data$r:00003AC1                 db  40h ; @
.data$r:00003AC2                 db  73h ; s
.data$r:00003AC3                 db  74h ; t
.data$r:00003AC4                 db  64h ; d
.data$r:00003AC5                 db  40h ; @
.data$r:00003AC6                 db  40h ; @
.data$r:00003AC7                 db    0
.data$r:00003AC7 _data$r         ends
.data$r:00003AC7
.xdata$x:00003AC8 ; ===========================================================================
.xdata$x:00003AC8
.xdata$x:00003AC8 ; Segment type: Pure data
.xdata$x:00003AC8 ; Segment permissions: Read
.xdata$x:00003AC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003AC8                 assume cs:_xdata$x
.xdata$x:00003AC8                 ;org 3AC8h
.xdata$x:00003AC8 ; COMDAT (pick any)
.xdata$x:00003AC8                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00003AC8 __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00003AC8                                         ; DATA XREF: .xdata$x:00003A6Co
.xdata$x:00003AC9                 db    0
.xdata$x:00003ACA                 db    0
.xdata$x:00003ACB                 db    0
.xdata$x:00003ACC                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:00003AD0                 db    0
.xdata$x:00003AD1                 db    0
.xdata$x:00003AD2                 db    0
.xdata$x:00003AD3                 db    0
.xdata$x:00003AD4                 db 0FFh
.xdata$x:00003AD5                 db 0FFh
.xdata$x:00003AD6                 db 0FFh
.xdata$x:00003AD7                 db 0FFh
.xdata$x:00003AD8                 db    0
.xdata$x:00003AD9                 db    0
.xdata$x:00003ADA                 db    0
.xdata$x:00003ADB                 db    0
.xdata$x:00003ADC                 db  0Ch
.xdata$x:00003ADD                 db    0
.xdata$x:00003ADE                 db    0
.xdata$x:00003ADF                 db    0
.xdata$x:00003AE0                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:00003AE0 _xdata$x        ends
.xdata$x:00003AE0
.rdata:00003AE4 ; ===========================================================================
.rdata:00003AE4
.rdata:00003AE4 ; Segment type: Pure data
.rdata:00003AE4 ; Segment permissions: Read
.rdata:00003AE4 _rdata          segment dword public 'DATA' use32
.rdata:00003AE4                 assume cs:_rdata
.rdata:00003AE4                 ;org 3AE4h
.rdata:00003AE4 ; COMDAT (pick largest)
.rdata:00003AE4                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00003AE8                 public ??_7error_category@std@@6B@
.rdata:00003AE8 ; const std::error_category::`vftable'
.rdata:00003AE8 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00003AE8                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00003AE8                                         ; std::error_category::~error_category(void)+Ao
.rdata:00003AE8                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00003AEC                 dd offset __purecall
.rdata:00003AF0                 dd offset __purecall
.rdata:00003AF4                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003AF8                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003AFC                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003AFC _rdata          ends
.rdata:00003AFC
.rdata:00003B00 ; ===========================================================================
.rdata:00003B00
.rdata:00003B00 ; Segment type: Pure data
.rdata:00003B00 ; Segment permissions: Read
.rdata:00003B00 _rdata          segment dword public 'DATA' use32
.rdata:00003B00                 assume cs:_rdata
.rdata:00003B00                 ;org 3B00h
.rdata:00003B00 ; COMDAT (pick largest)
.rdata:00003B00                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00003B04                 public ??_7_Generic_error_category@std@@6B@
.rdata:00003B04 ; const std::_Generic_error_category::`vftable'
.rdata:00003B04 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00003B04                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00003B04                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00003B08                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00003B0C                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00003B10                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003B14                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003B18                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003B18 _rdata          ends
.rdata:00003B18
.rdata:00003B1C ; ===========================================================================
.rdata:00003B1C
.rdata:00003B1C ; Segment type: Pure data
.rdata:00003B1C ; Segment permissions: Read
.rdata:00003B1C _rdata          segment dword public 'DATA' use32
.rdata:00003B1C                 assume cs:_rdata
.rdata:00003B1C                 ;org 3B1Ch
.rdata:00003B1C ; COMDAT (pick any)
.rdata:00003B1C                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00003B1C ; `string'
.rdata:00003B1C ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00003B1C                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00003B1C _rdata          ends
.rdata:00003B1C
.rdata:00003B24 ; ===========================================================================
.rdata:00003B24
.rdata:00003B24 ; Segment type: Pure data
.rdata:00003B24 ; Segment permissions: Read
.rdata:00003B24 _rdata          segment dword public 'DATA' use32
.rdata:00003B24                 assume cs:_rdata
.rdata:00003B24                 ;org 3B24h
.rdata:00003B24 ; COMDAT (pick any)
.rdata:00003B24                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00003B24 ; `string'
.rdata:00003B24 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00003B24                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_3248o
.rdata:00003B24                                         ; std::_System_error_category::message(int):loc_33C4o
.rdata:00003B32                 align 4
.rdata:00003B32 _rdata          ends
.rdata:00003B32
.rdata:00003B34 ; ===========================================================================
.rdata:00003B34
.rdata:00003B34 ; Segment type: Pure data
.rdata:00003B34 ; Segment permissions: Read
.rdata:00003B34 _rdata          segment dword public 'DATA' use32
.rdata:00003B34                 assume cs:_rdata
.rdata:00003B34                 ;org 3B34h
.rdata:00003B34 ; COMDAT (pick largest)
.rdata:00003B34                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00003B38                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00003B38 ; const std::_Iostream_error_category::`vftable'
.rdata:00003B38 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00003B38                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00003B38                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00003B3C                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00003B40                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00003B44                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003B48                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003B4C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003B4C _rdata          ends
.rdata:00003B4C
.rdata:00003B50 ; ===========================================================================
.rdata:00003B50
.rdata:00003B50 ; Segment type: Pure data
.rdata:00003B50 ; Segment permissions: Read
.rdata:00003B50 _rdata          segment dword public 'DATA' use32
.rdata:00003B50                 assume cs:_rdata
.rdata:00003B50                 ;org 3B50h
.rdata:00003B50 ; COMDAT (pick any)
.rdata:00003B50                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00003B50 ; `string'
.rdata:00003B50 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00003B50                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00003B59                 align 4
.rdata:00003B59 _rdata          ends
.rdata:00003B59
.rdata:00003B5C ; ===========================================================================
.rdata:00003B5C
.rdata:00003B5C ; Segment type: Pure data
.rdata:00003B5C ; Segment permissions: Read
.rdata:00003B5C _rdata          segment dword public 'DATA' use32
.rdata:00003B5C                 assume cs:_rdata
.rdata:00003B5C                 ;org 3B5Ch
.rdata:00003B5C ; COMDAT (pick any)
.rdata:00003B5C                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00003B5C ; char `string'[]
.rdata:00003B5C ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00003B5C                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00003B72                 align 4
.rdata:00003B72 _rdata          ends
.rdata:00003B72
.rdata:00003B74 ; ===========================================================================
.rdata:00003B74
.rdata:00003B74 ; Segment type: Pure data
.rdata:00003B74 ; Segment permissions: Read
.rdata:00003B74 _rdata          segment dword public 'DATA' use32
.rdata:00003B74                 assume cs:_rdata
.rdata:00003B74                 ;org 3B74h
.rdata:00003B74 ; COMDAT (pick largest)
.rdata:00003B74                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00003B78                 public ??_7_System_error_category@std@@6B@
.rdata:00003B78 ; const std::_System_error_category::`vftable'
.rdata:00003B78 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00003B78                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00003B78                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00003B7C                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00003B80                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00003B84                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00003B88                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003B8C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003B8C _rdata          ends
.rdata:00003B8C
.rdata:00003B90 ; ===========================================================================
.rdata:00003B90
.rdata:00003B90 ; Segment type: Pure data
.rdata:00003B90 ; Segment permissions: Read
.rdata:00003B90 _rdata          segment dword public 'DATA' use32
.rdata:00003B90                 assume cs:_rdata
.rdata:00003B90                 ;org 3B90h
.rdata:00003B90 ; COMDAT (pick any)
.rdata:00003B90                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00003B90 ; `string'
.rdata:00003B90 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00003B90                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00003B97                 align 4
.rdata:00003B97 _rdata          ends
.rdata:00003B97
.bss:00003B98 ; ===========================================================================
.bss:00003B98
.bss:00003B98 ; Segment type: Uninitialized
.bss:00003B98 ; Segment permissions: Read/Write
.bss:00003B98 _bss            segment dword public 'BSS' use32
.bss:00003B98                 assume cs:_bss
.bss:00003B98                 ;org 3B98h
.bss:00003B98 ; COMDAT (pick any)
.bss:00003B98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003B98                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00003B98 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00003B98 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00003B98                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00003B98                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00003B99                 db    ? ;
.bss:00003B9A                 db    ? ;
.bss:00003B9B                 db    ? ;
.bss:00003B9B _bss            ends
.bss:00003B9B
.bss:00003B9C ; ===========================================================================
.bss:00003B9C
.bss:00003B9C ; Segment type: Uninitialized
.bss:00003B9C ; Segment permissions: Read/Write
.bss:00003B9C _bss            segment dword public 'BSS' use32
.bss:00003B9C                 assume cs:_bss
.bss:00003B9C                 ;org 3B9Ch
.bss:00003B9C ; COMDAT (pick any)
.bss:00003B9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003B9C                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00003B9C ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00003B9C ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00003B9C                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00003B9C                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00003B9D                 db    ? ;
.bss:00003B9E                 db    ? ;
.bss:00003B9F                 db    ? ;
.bss:00003B9F _bss            ends
.bss:00003B9F
.bss:00003BA0 ; ===========================================================================
.bss:00003BA0
.bss:00003BA0 ; Segment type: Uninitialized
.bss:00003BA0 ; Segment permissions: Read/Write
.bss:00003BA0 _bss            segment dword public 'BSS' use32
.bss:00003BA0                 assume cs:_bss
.bss:00003BA0                 ;org 3BA0h
.bss:00003BA0 ; COMDAT (pick any)
.bss:00003BA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003BA0                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00003BA0 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00003BA0 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00003BA0                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00003BA0                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00003BA1                 db    ? ;
.bss:00003BA2                 db    ? ;
.bss:00003BA3                 db    ? ;
.bss:00003BA3 _bss            ends
.bss:00003BA3
.rdata:00003BA4 ; ===========================================================================
.rdata:00003BA4
.rdata:00003BA4 ; Segment type: Pure data
.rdata:00003BA4 ; Segment permissions: Read
.rdata:00003BA4 _rdata          segment dword public 'DATA' use32
.rdata:00003BA4                 assume cs:_rdata
.rdata:00003BA4                 ;org 3BA4h
.rdata:00003BA4 ; COMDAT (pick largest)
.rdata:00003BA4                 dd offset ??_R4Window@@6B@ ; const Window::`RTTI Complete Object Locator'
.rdata:00003BA8                 public ??_7Window@@6B@
.rdata:00003BA8 ; const Window::`vftable'
.rdata:00003BA8 ??_7Window@@6B@ dd offset ??_EWindow@@UAEPAXI@Z
.rdata:00003BA8                                         ; DATA XREF: Window::Window(void)+Ao
.rdata:00003BA8                                         ; Window::~Window(void)+Ao
.rdata:00003BA8                                         ; Window::`vector deleting destructor'(uint)
.rdata:00003BAC                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:00003BB0                 dd offset __purecall
.rdata:00003BB4                 dd offset ?display@Window@@UBEX_N@Z ; Window::display(bool)
.rdata:00003BB8                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:00003BBC                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:00003BC0                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:00003BC4                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:00003BC8                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:00003BCC                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:00003BD0                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:00003BD4                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:00003BD4 _rdata          ends
.rdata:00003BD4
.rdata:00003BD8 ; ===========================================================================
.rdata:00003BD8
.rdata:00003BD8 ; Segment type: Pure data
.rdata:00003BD8 ; Segment permissions: Read
.rdata:00003BD8 _rdata          segment dword public 'DATA' use32
.rdata:00003BD8                 assume cs:_rdata
.rdata:00003BD8                 ;org 3BD8h
.rdata:00003BD8 ; COMDAT (pick largest)
.rdata:00003BD8                 dd offset ??_R4Splitter@@6B@ ; const Splitter::`RTTI Complete Object Locator'
.rdata:00003BDC                 public ??_7Splitter@@6B@
.rdata:00003BDC ; const Splitter::`vftable'
.rdata:00003BDC ??_7Splitter@@6B@ dd offset ??_ESplitter@@UAEPAXI@Z
.rdata:00003BDC                                         ; DATA XREF: Splitter::Splitter(void)+38o
.rdata:00003BDC                                         ; Splitter::~Splitter(void)+29o
.rdata:00003BDC                                         ; Splitter::`vector deleting destructor'(uint)
.rdata:00003BE0                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:00003BE4                 dd offset ?destroy@Splitter@@UAEXXZ ; Splitter::destroy(void)
.rdata:00003BE8                 dd offset ?display@Window@@UBEX_N@Z ; Window::display(bool)
.rdata:00003BEC                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:00003BF0                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:00003BF4                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:00003BF8                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:00003BFC                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:00003C00                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:00003C04                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:00003C08                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:00003C08 _rdata          ends
.rdata:00003C08
.rdata:00003C0C ; ===========================================================================
.rdata:00003C0C
.rdata:00003C0C ; Segment type: Pure data
.rdata:00003C0C ; Segment permissions: Read
.rdata:00003C0C ; Segment alignment 'qword' can not be represented in assembly
.rdata:00003C0C _rdata          segment para public 'DATA' use32
.rdata:00003C0C                 assume cs:_rdata
.rdata:00003C0C                 ;org 3C0Ch
.rdata:00003C0C ; COMDAT (pick any)
.rdata:00003C0C                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00003C0C ; wchar_t `string'
.rdata:00003C0C ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00003C0C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00003C0C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00003C0C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00003C0C                 unicode 0, <clude\xstring>,0
.rdata:00003C9A                 align 4
.rdata:00003C9A _rdata          ends
.rdata:00003C9A
.rdata:00003C9C ; ===========================================================================
.rdata:00003C9C
.rdata:00003C9C ; Segment type: Pure data
.rdata:00003C9C ; Segment permissions: Read
.rdata:00003C9C _rdata          segment dword public 'DATA' use32
.rdata:00003C9C                 assume cs:_rdata
.rdata:00003C9C                 ;org 3C9Ch
.rdata:00003C9C ; COMDAT (pick any)
.rdata:00003C9C                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00003C9C ; char `string'[]
.rdata:00003C9C ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00003C9C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00003C9C _rdata          ends
.rdata:00003C9C
.rdata:00003CAC ; ===========================================================================
.rdata:00003CAC
.rdata:00003CAC ; Segment type: Pure data
.rdata:00003CAC ; Segment permissions: Read
.rdata:00003CAC _rdata          segment dword public 'DATA' use32
.rdata:00003CAC                 assume cs:_rdata
.rdata:00003CAC                 ;org 3CACh
.rdata:00003CAC ; COMDAT (pick any)
.rdata:00003CAC                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00003CAC ; char `string'[]
.rdata:00003CAC ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00003CAC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00003CAC _rdata          ends
.rdata:00003CAC
.rdata:00003CC4 ; ===========================================================================
.rdata:00003CC4
.rdata:00003CC4 ; Segment type: Pure data
.rdata:00003CC4 ; Segment permissions: Read
.rdata:00003CC4 _rdata          segment dword public 'DATA' use32
.rdata:00003CC4                 assume cs:_rdata
.rdata:00003CC4                 ;org 3CC4h
.rdata:00003CC4 ; COMDAT (pick any)
.rdata:00003CC4                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00003CC4 ; wchar_t `string'
.rdata:00003CC4 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00003CC4                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00003CC4                 unicode 0, <invalid null pointer>,0
.rdata:00003CEE                 align 10h
.rdata:00003CEE _rdata          ends
.rdata:00003CEE
.rdata$r:00003CF0 ; ===========================================================================
.rdata$r:00003CF0
.rdata$r:00003CF0 ; Segment type: Pure data
.rdata$r:00003CF0 ; Segment permissions: Read
.rdata$r:00003CF0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003CF0                 assume cs:_rdata$r
.rdata$r:00003CF0                 ;org 3CF0h
.rdata$r:00003CF0 ; COMDAT (pick any)
.rdata$r:00003CF0                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00003CF0 ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003CF0 ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:00003CF0                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:00003CF0                                         ; .rdata$r:00003D4Co
.rdata$r:00003CF0                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:00003CF4                 db    0
.rdata$r:00003CF5                 db    0
.rdata$r:00003CF6                 db    0
.rdata$r:00003CF7                 db    0
.rdata$r:00003CF8                 db    0
.rdata$r:00003CF9                 db    0
.rdata$r:00003CFA                 db    0
.rdata$r:00003CFB                 db    0
.rdata$r:00003CFC                 db 0FFh
.rdata$r:00003CFD                 db 0FFh
.rdata$r:00003CFE                 db 0FFh
.rdata$r:00003CFF                 db 0FFh
.rdata$r:00003D00                 db    0
.rdata$r:00003D01                 db    0
.rdata$r:00003D02                 db    0
.rdata$r:00003D03                 db    0
.rdata$r:00003D04                 db  40h ; @
.rdata$r:00003D05                 db    0
.rdata$r:00003D06                 db    0
.rdata$r:00003D07                 db    0
.rdata$r:00003D08                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003D08 _rdata$r        ends
.rdata$r:00003D08
.rdata$r:00003D0C ; ===========================================================================
.rdata$r:00003D0C
.rdata$r:00003D0C ; Segment type: Pure data
.rdata$r:00003D0C ; Segment permissions: Read
.rdata$r:00003D0C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003D0C                 assume cs:_rdata$r
.rdata$r:00003D0C                 ;org 3D0Ch
.rdata$r:00003D0C ; COMDAT (pick any)
.rdata$r:00003D0C                 public ??_R3exception@std@@8
.rdata$r:00003D0C ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003D0C ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:00003D08o
.rdata$r:00003D0D                 db    0
.rdata$r:00003D0E                 db    0
.rdata$r:00003D0F                 db    0
.rdata$r:00003D10                 db    0
.rdata$r:00003D11                 db    0
.rdata$r:00003D12                 db    0
.rdata$r:00003D13                 db    0
.rdata$r:00003D14                 db    1
.rdata$r:00003D15                 db    0
.rdata$r:00003D16                 db    0
.rdata$r:00003D17                 db    0
.rdata$r:00003D18                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:00003D18 _rdata$r        ends
.rdata$r:00003D18
.rdata$r:00003D1C ; ===========================================================================
.rdata$r:00003D1C
.rdata$r:00003D1C ; Segment type: Pure data
.rdata$r:00003D1C ; Segment permissions: Read
.rdata$r:00003D1C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003D1C                 assume cs:_rdata$r
.rdata$r:00003D1C                 ;org 3D1Ch
.rdata$r:00003D1C ; COMDAT (pick any)
.rdata$r:00003D1C                 public ??_R2exception@std@@8
.rdata$r:00003D1C ; std::exception::`RTTI Base Class Array'
.rdata$r:00003D1C ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00003D1C                                         ; DATA XREF: .rdata$r:00003D18o
.rdata$r:00003D1C                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003D20                 db    0
.rdata$r:00003D21                 align 4
.rdata$r:00003D21 _rdata$r        ends
.rdata$r:00003D21
.rdata$r:00003D24 ; ===========================================================================
.rdata$r:00003D24
.rdata$r:00003D24 ; Segment type: Pure data
.rdata$r:00003D24 ; Segment permissions: Read
.rdata$r:00003D24 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003D24                 assume cs:_rdata$r
.rdata$r:00003D24                 ;org 3D24h
.rdata$r:00003D24 ; COMDAT (pick any)
.rdata$r:00003D24                 public ??_R4runtime_error@std@@6B@
.rdata$r:00003D24 ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:00003D24 ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:00003A48o
.rdata$r:00003D25                 db    0
.rdata$r:00003D26                 db    0
.rdata$r:00003D27                 db    0
.rdata$r:00003D28                 db    0
.rdata$r:00003D29                 db    0
.rdata$r:00003D2A                 db    0
.rdata$r:00003D2B                 db    0
.rdata$r:00003D2C                 db    0
.rdata$r:00003D2D                 db    0
.rdata$r:00003D2E                 db    0
.rdata$r:00003D2F                 db    0
.rdata$r:00003D30                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00003D34                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003D34 _rdata$r        ends
.rdata$r:00003D34
.rdata$r:00003D38 ; ===========================================================================
.rdata$r:00003D38
.rdata$r:00003D38 ; Segment type: Pure data
.rdata$r:00003D38 ; Segment permissions: Read
.rdata$r:00003D38 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003D38                 assume cs:_rdata$r
.rdata$r:00003D38                 ;org 3D38h
.rdata$r:00003D38 ; COMDAT (pick any)
.rdata$r:00003D38                 public ??_R3runtime_error@std@@8
.rdata$r:00003D38 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003D38 ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:00003D34o
.rdata$r:00003D38                                         ; .rdata$r:00003D6Co
.rdata$r:00003D39                 db    0
.rdata$r:00003D3A                 db    0
.rdata$r:00003D3B                 db    0
.rdata$r:00003D3C                 db    0
.rdata$r:00003D3D                 db    0
.rdata$r:00003D3E                 db    0
.rdata$r:00003D3F                 db    0
.rdata$r:00003D40                 db    2
.rdata$r:00003D41                 db    0
.rdata$r:00003D42                 db    0
.rdata$r:00003D43                 db    0
.rdata$r:00003D44                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00003D44 _rdata$r        ends
.rdata$r:00003D44
.rdata$r:00003D48 ; ===========================================================================
.rdata$r:00003D48
.rdata$r:00003D48 ; Segment type: Pure data
.rdata$r:00003D48 ; Segment permissions: Read
.rdata$r:00003D48 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003D48                 assume cs:_rdata$r
.rdata$r:00003D48                 ;org 3D48h
.rdata$r:00003D48 ; COMDAT (pick any)
.rdata$r:00003D48                 public ??_R2runtime_error@std@@8
.rdata$r:00003D48 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00003D48 ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00003D48                                         ; DATA XREF: .rdata$r:00003D44o
.rdata$r:00003D48                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003D4C                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003D50                 db    0
.rdata$r:00003D51                 align 4
.rdata$r:00003D51 _rdata$r        ends
.rdata$r:00003D51
.rdata$r:00003D54 ; ===========================================================================
.rdata$r:00003D54
.rdata$r:00003D54 ; Segment type: Pure data
.rdata$r:00003D54 ; Segment permissions: Read
.rdata$r:00003D54 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003D54                 assume cs:_rdata$r
.rdata$r:00003D54                 ;org 3D54h
.rdata$r:00003D54 ; COMDAT (pick any)
.rdata$r:00003D54                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00003D54 ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003D54 ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:00003D54                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:00003D54                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00003D58                 db    1
.rdata$r:00003D59                 db    0
.rdata$r:00003D5A                 db    0
.rdata$r:00003D5B                 db    0
.rdata$r:00003D5C                 db    0
.rdata$r:00003D5D                 db    0
.rdata$r:00003D5E                 db    0
.rdata$r:00003D5F                 db    0
.rdata$r:00003D60                 db 0FFh
.rdata$r:00003D61                 db 0FFh
.rdata$r:00003D62                 db 0FFh
.rdata$r:00003D63                 db 0FFh
.rdata$r:00003D64                 db    0
.rdata$r:00003D65                 db    0
.rdata$r:00003D66                 db    0
.rdata$r:00003D67                 db    0
.rdata$r:00003D68                 db  40h ; @
.rdata$r:00003D69                 db    0
.rdata$r:00003D6A                 db    0
.rdata$r:00003D6B                 db    0
.rdata$r:00003D6C                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003D6C _rdata$r        ends
.rdata$r:00003D6C
.rdata$r:00003D70 ; ===========================================================================
.rdata$r:00003D70
.rdata$r:00003D70 ; Segment type: Pure data
.rdata$r:00003D70 ; Segment permissions: Read
.rdata$r:00003D70 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003D70                 assume cs:_rdata$r
.rdata$r:00003D70                 ;org 3D70h
.rdata$r:00003D70 ; COMDAT (pick any)
.rdata$r:00003D70                 public ??_R4error_category@std@@6B@
.rdata$r:00003D70 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00003D70 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00003AE4o
.rdata$r:00003D71                 db    0
.rdata$r:00003D72                 db    0
.rdata$r:00003D73                 db    0
.rdata$r:00003D74                 db    0
.rdata$r:00003D75                 db    0
.rdata$r:00003D76                 db    0
.rdata$r:00003D77                 db    0
.rdata$r:00003D78                 db    0
.rdata$r:00003D79                 db    0
.rdata$r:00003D7A                 db    0
.rdata$r:00003D7B                 db    0
.rdata$r:00003D7C                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00003D80                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003D80 _rdata$r        ends
.rdata$r:00003D80
.data$r:00003D84 ; ===========================================================================
.data$r:00003D84
.data$r:00003D84 ; Segment type: Pure data
.data$r:00003D84 ; Segment permissions: Read/Write
.data$r:00003D84 _data$r         segment dword public 'DATA' use32
.data$r:00003D84                 assume cs:_data$r
.data$r:00003D84                 ;org 3D84h
.data$r:00003D84 ; COMDAT (pick any)
.data$r:00003D84                 public ??_R0?AVerror_category@std@@@8
.data$r:00003D84 ; class std::error_category `RTTI Type Descriptor'
.data$r:00003D84 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003D84                                         ; DATA XREF: .rdata$r:00003D7Co
.data$r:00003D84                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003D84                                         ; const type_info::`vftable'
.data$r:00003D88                 db    0
.data$r:00003D89                 db    0
.data$r:00003D8A                 db    0
.data$r:00003D8B                 db    0
.data$r:00003D8C                 db  2Eh ; .
.data$r:00003D8D                 db  3Fh ; ?
.data$r:00003D8E                 db  41h ; A
.data$r:00003D8F                 db  56h ; V
.data$r:00003D90                 db  65h ; e
.data$r:00003D91                 db  72h ; r
.data$r:00003D92                 db  72h ; r
.data$r:00003D93                 db  6Fh ; o
.data$r:00003D94                 db  72h ; r
.data$r:00003D95                 db  5Fh ; _
.data$r:00003D96                 db  63h ; c
.data$r:00003D97                 db  61h ; a
.data$r:00003D98                 db  74h ; t
.data$r:00003D99                 db  65h ; e
.data$r:00003D9A                 db  67h ; g
.data$r:00003D9B                 db  6Fh ; o
.data$r:00003D9C                 db  72h ; r
.data$r:00003D9D                 db  79h ; y
.data$r:00003D9E                 db  40h ; @
.data$r:00003D9F                 db  73h ; s
.data$r:00003DA0                 db  74h ; t
.data$r:00003DA1                 db  64h ; d
.data$r:00003DA2                 db  40h ; @
.data$r:00003DA3                 db  40h ; @
.data$r:00003DA4                 db    0
.data$r:00003DA5                 align 4
.data$r:00003DA5 _data$r         ends
.data$r:00003DA5
.rdata$r:00003DA8 ; ===========================================================================
.rdata$r:00003DA8
.rdata$r:00003DA8 ; Segment type: Pure data
.rdata$r:00003DA8 ; Segment permissions: Read
.rdata$r:00003DA8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003DA8                 assume cs:_rdata$r
.rdata$r:00003DA8                 ;org 3DA8h
.rdata$r:00003DA8 ; COMDAT (pick any)
.rdata$r:00003DA8                 public ??_R3error_category@std@@8
.rdata$r:00003DA8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003DA8 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00003D80o
.rdata$r:00003DA8                                         ; .rdata$r:00003DD8o
.rdata$r:00003DA9                 db    0
.rdata$r:00003DAA                 db    0
.rdata$r:00003DAB                 db    0
.rdata$r:00003DAC                 db    0
.rdata$r:00003DAD                 db    0
.rdata$r:00003DAE                 db    0
.rdata$r:00003DAF                 db    0
.rdata$r:00003DB0                 db    1
.rdata$r:00003DB1                 db    0
.rdata$r:00003DB2                 db    0
.rdata$r:00003DB3                 db    0
.rdata$r:00003DB4                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00003DB4 _rdata$r        ends
.rdata$r:00003DB4
.rdata$r:00003DB8 ; ===========================================================================
.rdata$r:00003DB8
.rdata$r:00003DB8 ; Segment type: Pure data
.rdata$r:00003DB8 ; Segment permissions: Read
.rdata$r:00003DB8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003DB8                 assume cs:_rdata$r
.rdata$r:00003DB8                 ;org 3DB8h
.rdata$r:00003DB8 ; COMDAT (pick any)
.rdata$r:00003DB8                 public ??_R2error_category@std@@8
.rdata$r:00003DB8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00003DB8 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00003DB8                                         ; DATA XREF: .rdata$r:00003DB4o
.rdata$r:00003DB8                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003DBC                 db    0
.rdata$r:00003DBD                 align 10h
.rdata$r:00003DBD _rdata$r        ends
.rdata$r:00003DBD
.rdata$r:00003DC0 ; ===========================================================================
.rdata$r:00003DC0
.rdata$r:00003DC0 ; Segment type: Pure data
.rdata$r:00003DC0 ; Segment permissions: Read
.rdata$r:00003DC0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003DC0                 assume cs:_rdata$r
.rdata$r:00003DC0                 ;org 3DC0h
.rdata$r:00003DC0 ; COMDAT (pick any)
.rdata$r:00003DC0                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00003DC0 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003DC0 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00003DC0                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00003DC0                                         ; .rdata$r:00003E30o ...
.rdata$r:00003DC0                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00003DC4                 db    0
.rdata$r:00003DC5                 db    0
.rdata$r:00003DC6                 db    0
.rdata$r:00003DC7                 db    0
.rdata$r:00003DC8                 db    0
.rdata$r:00003DC9                 db    0
.rdata$r:00003DCA                 db    0
.rdata$r:00003DCB                 db    0
.rdata$r:00003DCC                 db 0FFh
.rdata$r:00003DCD                 db 0FFh
.rdata$r:00003DCE                 db 0FFh
.rdata$r:00003DCF                 db 0FFh
.rdata$r:00003DD0                 db    0
.rdata$r:00003DD1                 db    0
.rdata$r:00003DD2                 db    0
.rdata$r:00003DD3                 db    0
.rdata$r:00003DD4                 db  40h ; @
.rdata$r:00003DD5                 db    0
.rdata$r:00003DD6                 db    0
.rdata$r:00003DD7                 db    0
.rdata$r:00003DD8                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003DD8 _rdata$r        ends
.rdata$r:00003DD8
.rdata$r:00003DDC ; ===========================================================================
.rdata$r:00003DDC
.rdata$r:00003DDC ; Segment type: Pure data
.rdata$r:00003DDC ; Segment permissions: Read
.rdata$r:00003DDC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003DDC                 assume cs:_rdata$r
.rdata$r:00003DDC                 ;org 3DDCh
.rdata$r:00003DDC ; COMDAT (pick any)
.rdata$r:00003DDC                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00003DDC ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00003DDC ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00003DDC                                         ; DATA XREF: .rdata:00003B00o
.rdata$r:00003DDD                 db    0
.rdata$r:00003DDE                 db    0
.rdata$r:00003DDF                 db    0
.rdata$r:00003DE0                 db    0
.rdata$r:00003DE1                 db    0
.rdata$r:00003DE2                 db    0
.rdata$r:00003DE3                 db    0
.rdata$r:00003DE4                 db    0
.rdata$r:00003DE5                 db    0
.rdata$r:00003DE6                 db    0
.rdata$r:00003DE7                 db    0
.rdata$r:00003DE8                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00003DEC                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003DEC _rdata$r        ends
.rdata$r:00003DEC
.data$r:00003DF0 ; ===========================================================================
.data$r:00003DF0
.data$r:00003DF0 ; Segment type: Pure data
.data$r:00003DF0 ; Segment permissions: Read/Write
.data$r:00003DF0 _data$r         segment dword public 'DATA' use32
.data$r:00003DF0                 assume cs:_data$r
.data$r:00003DF0                 ;org 3DF0h
.data$r:00003DF0 ; COMDAT (pick any)
.data$r:00003DF0                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00003DF0 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00003DF0 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003DF0                                         ; DATA XREF: .rdata$r:00003DE8o
.data$r:00003DF0                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003DF0                                         ; const type_info::`vftable'
.data$r:00003DF4                 align 8
.data$r:00003DF8 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:00003E1A                 align 4
.data$r:00003E1A _data$r         ends
.data$r:00003E1A
.rdata$r:00003E1C ; ===========================================================================
.rdata$r:00003E1C
.rdata$r:00003E1C ; Segment type: Pure data
.rdata$r:00003E1C ; Segment permissions: Read
.rdata$r:00003E1C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003E1C                 assume cs:_rdata$r
.rdata$r:00003E1C                 ;org 3E1Ch
.rdata$r:00003E1C ; COMDAT (pick any)
.rdata$r:00003E1C                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00003E1C ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003E1C ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00003E1C                                         ; DATA XREF: .rdata$r:00003DECo
.rdata$r:00003E1C                                         ; .rdata$r:00003E50o
.rdata$r:00003E1D                 db    0
.rdata$r:00003E1E                 db    0
.rdata$r:00003E1F                 db    0
.rdata$r:00003E20                 db    0
.rdata$r:00003E21                 db    0
.rdata$r:00003E22                 db    0
.rdata$r:00003E23                 db    0
.rdata$r:00003E24                 db    2
.rdata$r:00003E25                 db    0
.rdata$r:00003E26                 db    0
.rdata$r:00003E27                 db    0
.rdata$r:00003E28                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00003E28 _rdata$r        ends
.rdata$r:00003E28
.rdata$r:00003E2C ; ===========================================================================
.rdata$r:00003E2C
.rdata$r:00003E2C ; Segment type: Pure data
.rdata$r:00003E2C ; Segment permissions: Read
.rdata$r:00003E2C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003E2C                 assume cs:_rdata$r
.rdata$r:00003E2C                 ;org 3E2Ch
.rdata$r:00003E2C ; COMDAT (pick any)
.rdata$r:00003E2C                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00003E2C ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00003E2C ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00003E2C                                         ; DATA XREF: .rdata$r:00003E28o
.rdata$r:00003E2C                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003E30                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003E34                 db    0
.rdata$r:00003E35                 align 4
.rdata$r:00003E35 _rdata$r        ends
.rdata$r:00003E35
.rdata$r:00003E38 ; ===========================================================================
.rdata$r:00003E38
.rdata$r:00003E38 ; Segment type: Pure data
.rdata$r:00003E38 ; Segment permissions: Read
.rdata$r:00003E38 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003E38                 assume cs:_rdata$r
.rdata$r:00003E38                 ;org 3E38h
.rdata$r:00003E38 ; COMDAT (pick any)
.rdata$r:00003E38                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00003E38 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003E38 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00003E38                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00003E38                                         ; .rdata$r:00003EA8o ...
.rdata$r:00003E38                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00003E3C                 db    1
.rdata$r:00003E3D                 db    0
.rdata$r:00003E3E                 db    0
.rdata$r:00003E3F                 db    0
.rdata$r:00003E40                 db    0
.rdata$r:00003E41                 db    0
.rdata$r:00003E42                 db    0
.rdata$r:00003E43                 db    0
.rdata$r:00003E44                 db 0FFh
.rdata$r:00003E45                 db 0FFh
.rdata$r:00003E46                 db 0FFh
.rdata$r:00003E47                 db 0FFh
.rdata$r:00003E48                 db    0
.rdata$r:00003E49                 db    0
.rdata$r:00003E4A                 db    0
.rdata$r:00003E4B                 db    0
.rdata$r:00003E4C                 db  40h ; @
.rdata$r:00003E4D                 db    0
.rdata$r:00003E4E                 db    0
.rdata$r:00003E4F                 db    0
.rdata$r:00003E50                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003E50 _rdata$r        ends
.rdata$r:00003E50
.rdata$r:00003E54 ; ===========================================================================
.rdata$r:00003E54
.rdata$r:00003E54 ; Segment type: Pure data
.rdata$r:00003E54 ; Segment permissions: Read
.rdata$r:00003E54 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003E54                 assume cs:_rdata$r
.rdata$r:00003E54                 ;org 3E54h
.rdata$r:00003E54 ; COMDAT (pick any)
.rdata$r:00003E54                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00003E54 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00003E54 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00003E54                                         ; DATA XREF: .rdata:00003B34o
.rdata$r:00003E55                 db    0
.rdata$r:00003E56                 db    0
.rdata$r:00003E57                 db    0
.rdata$r:00003E58                 db    0
.rdata$r:00003E59                 db    0
.rdata$r:00003E5A                 db    0
.rdata$r:00003E5B                 db    0
.rdata$r:00003E5C                 db    0
.rdata$r:00003E5D                 db    0
.rdata$r:00003E5E                 db    0
.rdata$r:00003E5F                 db    0
.rdata$r:00003E60                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00003E64                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003E64 _rdata$r        ends
.rdata$r:00003E64
.data$r:00003E68 ; ===========================================================================
.data$r:00003E68
.data$r:00003E68 ; Segment type: Pure data
.data$r:00003E68 ; Segment permissions: Read/Write
.data$r:00003E68 _data$r         segment dword public 'DATA' use32
.data$r:00003E68                 assume cs:_data$r
.data$r:00003E68                 ;org 3E68h
.data$r:00003E68 ; COMDAT (pick any)
.data$r:00003E68                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00003E68 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00003E68 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003E68                                         ; DATA XREF: .rdata$r:00003E60o
.data$r:00003E68                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003E68                                         ; const type_info::`vftable'
.data$r:00003E6C                 align 10h
.data$r:00003E70 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:00003E93                 align 4
.data$r:00003E93 _data$r         ends
.data$r:00003E93
.rdata$r:00003E94 ; ===========================================================================
.rdata$r:00003E94
.rdata$r:00003E94 ; Segment type: Pure data
.rdata$r:00003E94 ; Segment permissions: Read
.rdata$r:00003E94 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003E94                 assume cs:_rdata$r
.rdata$r:00003E94                 ;org 3E94h
.rdata$r:00003E94 ; COMDAT (pick any)
.rdata$r:00003E94                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00003E94 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003E94 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00003E94                                         ; DATA XREF: .rdata$r:00003E64o
.rdata$r:00003E94                                         ; .rdata$r:00003ECCo
.rdata$r:00003E95                 db    0
.rdata$r:00003E96                 db    0
.rdata$r:00003E97                 db    0
.rdata$r:00003E98                 db    0
.rdata$r:00003E99                 db    0
.rdata$r:00003E9A                 db    0
.rdata$r:00003E9B                 db    0
.rdata$r:00003E9C                 db    3
.rdata$r:00003E9D                 db    0
.rdata$r:00003E9E                 db    0
.rdata$r:00003E9F                 db    0
.rdata$r:00003EA0                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00003EA0 _rdata$r        ends
.rdata$r:00003EA0
.rdata$r:00003EA4 ; ===========================================================================
.rdata$r:00003EA4
.rdata$r:00003EA4 ; Segment type: Pure data
.rdata$r:00003EA4 ; Segment permissions: Read
.rdata$r:00003EA4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003EA4                 assume cs:_rdata$r
.rdata$r:00003EA4                 ;org 3EA4h
.rdata$r:00003EA4 ; COMDAT (pick any)
.rdata$r:00003EA4                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00003EA4 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00003EA4 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00003EA4                                         ; DATA XREF: .rdata$r:00003EA0o
.rdata$r:00003EA4                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003EA8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003EAC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003EB0                 db    0
.rdata$r:00003EB1                 align 4
.rdata$r:00003EB1 _rdata$r        ends
.rdata$r:00003EB1
.rdata$r:00003EB4 ; ===========================================================================
.rdata$r:00003EB4
.rdata$r:00003EB4 ; Segment type: Pure data
.rdata$r:00003EB4 ; Segment permissions: Read
.rdata$r:00003EB4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003EB4                 assume cs:_rdata$r
.rdata$r:00003EB4                 ;org 3EB4h
.rdata$r:00003EB4 ; COMDAT (pick any)
.rdata$r:00003EB4                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00003EB4 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003EB4 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00003EB4                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00003EB4                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00003EB8                 db    2
.rdata$r:00003EB9                 db    0
.rdata$r:00003EBA                 db    0
.rdata$r:00003EBB                 db    0
.rdata$r:00003EBC                 db    0
.rdata$r:00003EBD                 db    0
.rdata$r:00003EBE                 db    0
.rdata$r:00003EBF                 db    0
.rdata$r:00003EC0                 db 0FFh
.rdata$r:00003EC1                 db 0FFh
.rdata$r:00003EC2                 db 0FFh
.rdata$r:00003EC3                 db 0FFh
.rdata$r:00003EC4                 db    0
.rdata$r:00003EC5                 db    0
.rdata$r:00003EC6                 db    0
.rdata$r:00003EC7                 db    0
.rdata$r:00003EC8                 db  40h ; @
.rdata$r:00003EC9                 db    0
.rdata$r:00003ECA                 db    0
.rdata$r:00003ECB                 db    0
.rdata$r:00003ECC                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003ECC _rdata$r        ends
.rdata$r:00003ECC
.rdata$r:00003ED0 ; ===========================================================================
.rdata$r:00003ED0
.rdata$r:00003ED0 ; Segment type: Pure data
.rdata$r:00003ED0 ; Segment permissions: Read
.rdata$r:00003ED0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003ED0                 assume cs:_rdata$r
.rdata$r:00003ED0                 ;org 3ED0h
.rdata$r:00003ED0 ; COMDAT (pick any)
.rdata$r:00003ED0                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00003ED0 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00003ED0 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00003B74o
.rdata$r:00003ED1                 db    0
.rdata$r:00003ED2                 db    0
.rdata$r:00003ED3                 db    0
.rdata$r:00003ED4                 db    0
.rdata$r:00003ED5                 db    0
.rdata$r:00003ED6                 db    0
.rdata$r:00003ED7                 db    0
.rdata$r:00003ED8                 db    0
.rdata$r:00003ED9                 db    0
.rdata$r:00003EDA                 db    0
.rdata$r:00003EDB                 db    0
.rdata$r:00003EDC                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00003EE0                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003EE0 _rdata$r        ends
.rdata$r:00003EE0
.data$r:00003EE4 ; ===========================================================================
.data$r:00003EE4
.data$r:00003EE4 ; Segment type: Pure data
.data$r:00003EE4 ; Segment permissions: Read/Write
.data$r:00003EE4 _data$r         segment dword public 'DATA' use32
.data$r:00003EE4                 assume cs:_data$r
.data$r:00003EE4                 ;org 3EE4h
.data$r:00003EE4 ; COMDAT (pick any)
.data$r:00003EE4                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00003EE4 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00003EE4 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003EE4                                         ; DATA XREF: .rdata$r:00003EDCo
.data$r:00003EE4                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003EE4                                         ; const type_info::`vftable'
.data$r:00003EE8                 db    0
.data$r:00003EE9                 db    0
.data$r:00003EEA                 db    0
.data$r:00003EEB                 db    0
.data$r:00003EEC                 db  2Eh ; .
.data$r:00003EED                 db  3Fh ; ?
.data$r:00003EEE                 db  41h ; A
.data$r:00003EEF                 db  56h ; V
.data$r:00003EF0                 db  5Fh ; _
.data$r:00003EF1                 db  53h ; S
.data$r:00003EF2                 db  79h ; y
.data$r:00003EF3                 db  73h ; s
.data$r:00003EF4                 db  74h ; t
.data$r:00003EF5                 db  65h ; e
.data$r:00003EF6                 db  6Dh ; m
.data$r:00003EF7                 db  5Fh ; _
.data$r:00003EF8                 db  65h ; e
.data$r:00003EF9                 db  72h ; r
.data$r:00003EFA                 db  72h ; r
.data$r:00003EFB                 db  6Fh ; o
.data$r:00003EFC                 db  72h ; r
.data$r:00003EFD                 db  5Fh ; _
.data$r:00003EFE                 db  63h ; c
.data$r:00003EFF                 db  61h ; a
.data$r:00003F00                 db  74h ; t
.data$r:00003F01                 db  65h ; e
.data$r:00003F02                 db  67h ; g
.data$r:00003F03                 db  6Fh ; o
.data$r:00003F04                 db  72h ; r
.data$r:00003F05                 db  79h ; y
.data$r:00003F06                 db  40h ; @
.data$r:00003F07                 db  73h ; s
.data$r:00003F08                 db  74h ; t
.data$r:00003F09                 db  64h ; d
.data$r:00003F0A                 db  40h ; @
.data$r:00003F0B                 db  40h ; @
.data$r:00003F0C                 db    0
.data$r:00003F0D                 align 10h
.data$r:00003F0D _data$r         ends
.data$r:00003F0D
.rdata$r:00003F10 ; ===========================================================================
.rdata$r:00003F10
.rdata$r:00003F10 ; Segment type: Pure data
.rdata$r:00003F10 ; Segment permissions: Read
.rdata$r:00003F10 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003F10                 assume cs:_rdata$r
.rdata$r:00003F10                 ;org 3F10h
.rdata$r:00003F10 ; COMDAT (pick any)
.rdata$r:00003F10                 public ??_R3_System_error_category@std@@8
.rdata$r:00003F10 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003F10 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00003EE0o
.rdata$r:00003F10                                         ; .rdata$r:00003F48o
.rdata$r:00003F11                 db    0
.rdata$r:00003F12                 db    0
.rdata$r:00003F13                 db    0
.rdata$r:00003F14                 db    0
.rdata$r:00003F15                 db    0
.rdata$r:00003F16                 db    0
.rdata$r:00003F17                 db    0
.rdata$r:00003F18                 db    3
.rdata$r:00003F19                 db    0
.rdata$r:00003F1A                 db    0
.rdata$r:00003F1B                 db    0
.rdata$r:00003F1C                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00003F1C _rdata$r        ends
.rdata$r:00003F1C
.rdata$r:00003F20 ; ===========================================================================
.rdata$r:00003F20
.rdata$r:00003F20 ; Segment type: Pure data
.rdata$r:00003F20 ; Segment permissions: Read
.rdata$r:00003F20 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003F20                 assume cs:_rdata$r
.rdata$r:00003F20                 ;org 3F20h
.rdata$r:00003F20 ; COMDAT (pick any)
.rdata$r:00003F20                 public ??_R2_System_error_category@std@@8
.rdata$r:00003F20 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00003F20 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00003F20                                         ; DATA XREF: .rdata$r:00003F1Co
.rdata$r:00003F20                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003F24                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003F28                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003F2C                 db    0
.rdata$r:00003F2D                 align 10h
.rdata$r:00003F2D _rdata$r        ends
.rdata$r:00003F2D
.rdata$r:00003F30 ; ===========================================================================
.rdata$r:00003F30
.rdata$r:00003F30 ; Segment type: Pure data
.rdata$r:00003F30 ; Segment permissions: Read
.rdata$r:00003F30 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003F30                 assume cs:_rdata$r
.rdata$r:00003F30                 ;org 3F30h
.rdata$r:00003F30 ; COMDAT (pick any)
.rdata$r:00003F30                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00003F30 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003F30 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00003F30                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00003F30                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00003F34                 db    2
.rdata$r:00003F35                 db    0
.rdata$r:00003F36                 db    0
.rdata$r:00003F37                 db    0
.rdata$r:00003F38                 db    0
.rdata$r:00003F39                 db    0
.rdata$r:00003F3A                 db    0
.rdata$r:00003F3B                 db    0
.rdata$r:00003F3C                 db 0FFh
.rdata$r:00003F3D                 db 0FFh
.rdata$r:00003F3E                 db 0FFh
.rdata$r:00003F3F                 db 0FFh
.rdata$r:00003F40                 db    0
.rdata$r:00003F41                 db    0
.rdata$r:00003F42                 db    0
.rdata$r:00003F43                 db    0
.rdata$r:00003F44                 db  40h ; @
.rdata$r:00003F45                 db    0
.rdata$r:00003F46                 db    0
.rdata$r:00003F47                 db    0
.rdata$r:00003F48                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003F48 _rdata$r        ends
.rdata$r:00003F48
.rdata$r:00003F4C ; ===========================================================================
.rdata$r:00003F4C
.rdata$r:00003F4C ; Segment type: Pure data
.rdata$r:00003F4C ; Segment permissions: Read
.rdata$r:00003F4C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003F4C                 assume cs:_rdata$r
.rdata$r:00003F4C                 ;org 3F4Ch
.rdata$r:00003F4C ; COMDAT (pick any)
.rdata$r:00003F4C                 public ??_R4Window@@6B@
.rdata$r:00003F4C ; const Window::`RTTI Complete Object Locator'
.rdata$r:00003F4C ??_R4Window@@6B@ db    0                ; DATA XREF: .rdata:00003BA4o
.rdata$r:00003F4D                 db    0
.rdata$r:00003F4E                 db    0
.rdata$r:00003F4F                 db    0
.rdata$r:00003F50                 db    0
.rdata$r:00003F51                 db    0
.rdata$r:00003F52                 db    0
.rdata$r:00003F53                 db    0
.rdata$r:00003F54                 db    0
.rdata$r:00003F55                 db    0
.rdata$r:00003F56                 db    0
.rdata$r:00003F57                 db    0
.rdata$r:00003F58                 dd offset ??_R0?AVWindow@@@8 ; Window `RTTI Type Descriptor'
.rdata$r:00003F5C                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003F5C _rdata$r        ends
.rdata$r:00003F5C
.data$r:00003F60 ; ===========================================================================
.data$r:00003F60
.data$r:00003F60 ; Segment type: Pure data
.data$r:00003F60 ; Segment permissions: Read/Write
.data$r:00003F60 _data$r         segment dword public 'DATA' use32
.data$r:00003F60                 assume cs:_data$r
.data$r:00003F60                 ;org 3F60h
.data$r:00003F60 ; COMDAT (pick any)
.data$r:00003F60                 public ??_R0?AVWindow@@@8
.data$r:00003F60 ; class Window `RTTI Type Descriptor'
.data$r:00003F60 ??_R0?AVWindow@@@8 dd offset ??_7type_info@@6B@
.data$r:00003F60                                         ; DATA XREF: .rdata$r:00003F58o
.data$r:00003F60                                         ; .rdata$r:Window::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003F60                                         ; const type_info::`vftable'
.data$r:00003F64                 align 8
.data$r:00003F68 a_?avwindow@@   db '.?AVWindow@@',0
.data$r:00003F75                 align 4
.data$r:00003F75 _data$r         ends
.data$r:00003F75
.rdata$r:00003F78 ; ===========================================================================
.rdata$r:00003F78
.rdata$r:00003F78 ; Segment type: Pure data
.rdata$r:00003F78 ; Segment permissions: Read
.rdata$r:00003F78 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003F78                 assume cs:_rdata$r
.rdata$r:00003F78                 ;org 3F78h
.rdata$r:00003F78 ; COMDAT (pick any)
.rdata$r:00003F78                 public ??_R3Window@@8
.rdata$r:00003F78 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003F78 ??_R3Window@@8  db    0                 ; DATA XREF: .rdata$r:00003F5Co
.rdata$r:00003F78                                         ; .rdata$r:00003FA8o
.rdata$r:00003F79                 db    0
.rdata$r:00003F7A                 db    0
.rdata$r:00003F7B                 db    0
.rdata$r:00003F7C                 db    0
.rdata$r:00003F7D                 db    0
.rdata$r:00003F7E                 db    0
.rdata$r:00003F7F                 db    0
.rdata$r:00003F80                 db    1
.rdata$r:00003F81                 db    0
.rdata$r:00003F82                 db    0
.rdata$r:00003F83                 db    0
.rdata$r:00003F84                 dd offset ??_R2Window@@8 ; Window::`RTTI Base Class Array'
.rdata$r:00003F84 _rdata$r        ends
.rdata$r:00003F84
.rdata$r:00003F88 ; ===========================================================================
.rdata$r:00003F88
.rdata$r:00003F88 ; Segment type: Pure data
.rdata$r:00003F88 ; Segment permissions: Read
.rdata$r:00003F88 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003F88                 assume cs:_rdata$r
.rdata$r:00003F88                 ;org 3F88h
.rdata$r:00003F88 ; COMDAT (pick any)
.rdata$r:00003F88                 public ??_R2Window@@8
.rdata$r:00003F88 ; Window::`RTTI Base Class Array'
.rdata$r:00003F88 ??_R2Window@@8  dd offset ??_R1A@?0A@EA@Window@@8
.rdata$r:00003F88                                         ; DATA XREF: .rdata$r:00003F84o
.rdata$r:00003F88                                         ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003F8C                 db    0
.rdata$r:00003F8D                 align 10h
.rdata$r:00003F8D _rdata$r        ends
.rdata$r:00003F8D
.rdata$r:00003F90 ; ===========================================================================
.rdata$r:00003F90
.rdata$r:00003F90 ; Segment type: Pure data
.rdata$r:00003F90 ; Segment permissions: Read
.rdata$r:00003F90 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003F90                 assume cs:_rdata$r
.rdata$r:00003F90                 ;org 3F90h
.rdata$r:00003F90 ; COMDAT (pick any)
.rdata$r:00003F90                 public ??_R1A@?0A@EA@Window@@8
.rdata$r:00003F90 ; Window::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003F90 ??_R1A@?0A@EA@Window@@8 dd offset ??_R0?AVWindow@@@8
.rdata$r:00003F90                                         ; DATA XREF: .rdata$r:Window::`RTTI Base Class Array'o
.rdata$r:00003F90                                         ; .rdata$r:00003FECo
.rdata$r:00003F90                                         ; Window `RTTI Type Descriptor'
.rdata$r:00003F94                 db    0
.rdata$r:00003F95                 db    0
.rdata$r:00003F96                 db    0
.rdata$r:00003F97                 db    0
.rdata$r:00003F98                 db    0
.rdata$r:00003F99                 db    0
.rdata$r:00003F9A                 db    0
.rdata$r:00003F9B                 db    0
.rdata$r:00003F9C                 db 0FFh
.rdata$r:00003F9D                 db 0FFh
.rdata$r:00003F9E                 db 0FFh
.rdata$r:00003F9F                 db 0FFh
.rdata$r:00003FA0                 db    0
.rdata$r:00003FA1                 db    0
.rdata$r:00003FA2                 db    0
.rdata$r:00003FA3                 db    0
.rdata$r:00003FA4                 db  40h ; @
.rdata$r:00003FA5                 db    0
.rdata$r:00003FA6                 db    0
.rdata$r:00003FA7                 db    0
.rdata$r:00003FA8                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003FA8 _rdata$r        ends
.rdata$r:00003FA8
.rdata$r:00003FAC ; ===========================================================================
.rdata$r:00003FAC
.rdata$r:00003FAC ; Segment type: Pure data
.rdata$r:00003FAC ; Segment permissions: Read
.rdata$r:00003FAC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003FAC                 assume cs:_rdata$r
.rdata$r:00003FAC                 ;org 3FACh
.rdata$r:00003FAC ; COMDAT (pick any)
.rdata$r:00003FAC                 public ??_R4Splitter@@6B@
.rdata$r:00003FAC ; const Splitter::`RTTI Complete Object Locator'
.rdata$r:00003FAC ??_R4Splitter@@6B@ db    0              ; DATA XREF: .rdata:00003BD8o
.rdata$r:00003FAD                 db    0
.rdata$r:00003FAE                 db    0
.rdata$r:00003FAF                 db    0
.rdata$r:00003FB0                 db    0
.rdata$r:00003FB1                 db    0
.rdata$r:00003FB2                 db    0
.rdata$r:00003FB3                 db    0
.rdata$r:00003FB4                 db    0
.rdata$r:00003FB5                 db    0
.rdata$r:00003FB6                 db    0
.rdata$r:00003FB7                 db    0
.rdata$r:00003FB8                 dd offset ??_R0?AVSplitter@@@8 ; Splitter `RTTI Type Descriptor'
.rdata$r:00003FBC                 dd offset ??_R3Splitter@@8 ; Splitter::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003FBC _rdata$r        ends
.rdata$r:00003FBC
.data$r:00003FC0 ; ===========================================================================
.data$r:00003FC0
.data$r:00003FC0 ; Segment type: Pure data
.data$r:00003FC0 ; Segment permissions: Read/Write
.data$r:00003FC0 _data$r         segment dword public 'DATA' use32
.data$r:00003FC0                 assume cs:_data$r
.data$r:00003FC0                 ;org 3FC0h
.data$r:00003FC0 ; COMDAT (pick any)
.data$r:00003FC0                 public ??_R0?AVSplitter@@@8
.data$r:00003FC0 ; class Splitter `RTTI Type Descriptor'
.data$r:00003FC0 ??_R0?AVSplitter@@@8 dd offset ??_7type_info@@6B@
.data$r:00003FC0                                         ; DATA XREF: .rdata$r:00003FB8o
.data$r:00003FC0                                         ; .rdata$r:Splitter::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003FC0                                         ; const type_info::`vftable'
.data$r:00003FC4                 align 8
.data$r:00003FC8 a_?avsplitter@@ db '.?AVSplitter@@',0
.data$r:00003FD7                 align 4
.data$r:00003FD7 _data$r         ends
.data$r:00003FD7
.rdata$r:00003FD8 ; ===========================================================================
.rdata$r:00003FD8
.rdata$r:00003FD8 ; Segment type: Pure data
.rdata$r:00003FD8 ; Segment permissions: Read
.rdata$r:00003FD8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003FD8                 assume cs:_rdata$r
.rdata$r:00003FD8                 ;org 3FD8h
.rdata$r:00003FD8 ; COMDAT (pick any)
.rdata$r:00003FD8                 public ??_R3Splitter@@8
.rdata$r:00003FD8 ; Splitter::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003FD8 ??_R3Splitter@@8 db    0                ; DATA XREF: .rdata$r:00003FBCo
.rdata$r:00003FD8                                         ; .rdata$r:0000400Co
.rdata$r:00003FD9                 db    0
.rdata$r:00003FDA                 db    0
.rdata$r:00003FDB                 db    0
.rdata$r:00003FDC                 db    0
.rdata$r:00003FDD                 db    0
.rdata$r:00003FDE                 db    0
.rdata$r:00003FDF                 db    0
.rdata$r:00003FE0                 db    2
.rdata$r:00003FE1                 db    0
.rdata$r:00003FE2                 db    0
.rdata$r:00003FE3                 db    0
.rdata$r:00003FE4                 dd offset ??_R2Splitter@@8 ; Splitter::`RTTI Base Class Array'
.rdata$r:00003FE4 _rdata$r        ends
.rdata$r:00003FE4
.rdata$r:00003FE8 ; ===========================================================================
.rdata$r:00003FE8
.rdata$r:00003FE8 ; Segment type: Pure data
.rdata$r:00003FE8 ; Segment permissions: Read
.rdata$r:00003FE8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003FE8                 assume cs:_rdata$r
.rdata$r:00003FE8                 ;org 3FE8h
.rdata$r:00003FE8 ; COMDAT (pick any)
.rdata$r:00003FE8                 public ??_R2Splitter@@8
.rdata$r:00003FE8 ; Splitter::`RTTI Base Class Array'
.rdata$r:00003FE8 ??_R2Splitter@@8 dd offset ??_R1A@?0A@EA@Splitter@@8
.rdata$r:00003FE8                                         ; DATA XREF: .rdata$r:00003FE4o
.rdata$r:00003FE8                                         ; Splitter::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003FEC                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003FF0                 db    0
.rdata$r:00003FF1                 align 4
.rdata$r:00003FF1 _rdata$r        ends
.rdata$r:00003FF1
.rdata$r:00003FF4 ; ===========================================================================
.rdata$r:00003FF4
.rdata$r:00003FF4 ; Segment type: Pure data
.rdata$r:00003FF4 ; Segment permissions: Read
.rdata$r:00003FF4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003FF4                 assume cs:_rdata$r
.rdata$r:00003FF4                 ;org 3FF4h
.rdata$r:00003FF4 ; COMDAT (pick any)
.rdata$r:00003FF4                 public ??_R1A@?0A@EA@Splitter@@8
.rdata$r:00003FF4 ; Splitter::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003FF4 ??_R1A@?0A@EA@Splitter@@8 dd offset ??_R0?AVSplitter@@@8
.rdata$r:00003FF4                                         ; DATA XREF: .rdata$r:Splitter::`RTTI Base Class Array'o
.rdata$r:00003FF4                                         ; Splitter `RTTI Type Descriptor'
.rdata$r:00003FF8                 db    1
.rdata$r:00003FF9                 db    0
.rdata$r:00003FFA                 db    0
.rdata$r:00003FFB                 db    0
.rdata$r:00003FFC                 db    0
.rdata$r:00003FFD                 db    0
.rdata$r:00003FFE                 db    0
.rdata$r:00003FFF                 db    0
.rdata$r:00004000                 db 0FFh
.rdata$r:00004001                 db 0FFh
.rdata$r:00004002                 db 0FFh
.rdata$r:00004003                 db 0FFh
.rdata$r:00004004                 db    0
.rdata$r:00004005                 db    0
.rdata$r:00004006                 db    0
.rdata$r:00004007                 db    0
.rdata$r:00004008                 db  40h ; @
.rdata$r:00004009                 db    0
.rdata$r:0000400A                 db    0
.rdata$r:0000400B                 db    0
.rdata$r:0000400C                 dd offset ??_R3Splitter@@8 ; Splitter::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000400C _rdata$r        ends
.rdata$r:0000400C
.CRT$XCU:00004010 ; ===========================================================================
.CRT$XCU:00004010
.CRT$XCU:00004010 ; Segment type: Pure data
.CRT$XCU:00004010 ; Segment permissions: Read
.CRT$XCU:00004010 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004010                 assume cs:_CRT$XCU
.CRT$XCU:00004010                 ;org 4010h
.CRT$XCU:00004010 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00004014 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00004014 _CRT$XCU        ends
.CRT$XCU:00004014
.CRT$XCU:00004018 ; ===========================================================================
.CRT$XCU:00004018
.CRT$XCU:00004018 ; Segment type: Pure data
.CRT$XCU:00004018 ; Segment permissions: Read
.CRT$XCU:00004018 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004018                 assume cs:_CRT$XCU
.CRT$XCU:00004018                 ;org 4018h
.CRT$XCU:00004018 ; COMDAT (pick associative to section at 3B98)
.CRT$XCU:00004018 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00004018 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00004018 _CRT$XCU        ends
.CRT$XCU:00004018
.CRT$XCU:0000401C ; ===========================================================================
.CRT$XCU:0000401C
.CRT$XCU:0000401C ; Segment type: Pure data
.CRT$XCU:0000401C ; Segment permissions: Read
.CRT$XCU:0000401C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000401C                 assume cs:_CRT$XCU
.CRT$XCU:0000401C                 ;org 401Ch
.CRT$XCU:0000401C ; COMDAT (pick associative to section at 3B9C)
.CRT$XCU:0000401C ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000401C ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000401C _CRT$XCU        ends
.CRT$XCU:0000401C
.CRT$XCU:00004020 ; ===========================================================================
.CRT$XCU:00004020
.CRT$XCU:00004020 ; Segment type: Pure data
.CRT$XCU:00004020 ; Segment permissions: Read
.CRT$XCU:00004020 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004020                 assume cs:_CRT$XCU
.CRT$XCU:00004020                 ;org 4020h
.CRT$XCU:00004020 ; COMDAT (pick associative to section at 3BA0)
.CRT$XCU:00004020 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00004020 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00004020 _CRT$XCU        ends
.CRT$XCU:00004020
UNDEF:00004030 ; ===========================================================================
UNDEF:00004030
UNDEF:00004030 ; Segment type: Externs
UNDEF:00004030 ; UNDEF
UNDEF:00004030                 extrn __purecall:near   ; DATA XREF: .rdata:00003AECo
UNDEF:00004030                                         ; .rdata:00003AF0o ...
UNDEF:00004034 ; void *__cdecl operator new(unsigned int)
UNDEF:00004034                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00004034                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00004038 ; void __cdecl operator delete(void *)
UNDEF:00004038                 extrn ??3@YAXPAX@Z:near ; CODE XREF: Splitter::`scalar deleting destructor'(uint)+1Bp
UNDEF:00004038                                         ; Window::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000403C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000403C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000403C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00004040 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00004040                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00004040                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00004044 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00004044                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00004044                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00004044                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00004048                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000404C ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000404C                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00004050 ; size_t __cdecl strlen(const char *Str)
UNDEF:00004050                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00004054 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00004054                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00004058 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:00004058                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:00004058                                         ; CODE XREF: std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:0000405C ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:0000405C                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:0000405C                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:0000405C                                         ; DATA XREF: .xdata$x:00003AE0o
UNDEF:00004060 ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:00004060                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:00004060                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:00004060                                         ; __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0+3j ...
UNDEF:00004064 ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:00004064                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:00004064                                         ; DATA XREF: .rdata:00003A50o
UNDEF:00004068 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00004068                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00004068                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000406C ; void __cdecl std::_Xbad_alloc()
UNDEF:0000406C                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000406C                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_16AAp
UNDEF:0000406C                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_16ECp
UNDEF:00004070 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00004070                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00004070                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00004074 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00004074                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00004074                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00004078 ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:00004078                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:00004078                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:0000407C ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000407C                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000407C                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00004080 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00004080                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00004080                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00004080                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00004084 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00004084                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00004084                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00004088 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004088                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004088                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000408C ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000408C                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000408C                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00004090 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004090                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004090                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00004094 ; BOOL __stdcall LineTo(HDC hdc, int x, int y)
UNDEF:00004094                 extrn __imp__LineTo@12:near
UNDEF:00004094                                         ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+98p
UNDEF:00004094                                         ; Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+110p ...
UNDEF:00004098 ; BOOL __stdcall MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
UNDEF:00004098                 extrn __imp__MoveToEx@16:near
UNDEF:00004098                                         ; CODE XREF: Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+77p
UNDEF:00004098                                         ; Splitter::paintArrow(HDC__ *,tagRECT const &,Arrow)+EFp ...
UNDEF:0000409C ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000409C                 extrn __imp__SendMessageW@16:near
UNDEF:0000409C                                         ; CODE XREF: Splitter::resizeSpliter(tagRECT *)+114p
UNDEF:0000409C                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+3F5p ...
UNDEF:000040A0 ; LRESULT __stdcall DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000040A0                 extrn __imp__DefWindowProcW@16:near
UNDEF:000040A0                                         ; CODE XREF: Splitter::staticWndProc(HWND__ *,uint,uint,long)+64p
UNDEF:000040A0                                         ; Splitter::spliterWndProc(uint,uint,long)+3AEp
UNDEF:000040A0                                         ; DATA XREF: ...
UNDEF:000040A4 ; ATOM __stdcall RegisterClassExW(const WNDCLASSEXW *)
UNDEF:000040A4                 extrn __imp__RegisterClassExW@4:near
UNDEF:000040A4                                         ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+24Fp
UNDEF:000040A4                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+27Fp ...
UNDEF:000040A8 ; HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
UNDEF:000040A8                 extrn __imp__CreateWindowExW@48:near
UNDEF:000040A8                                         ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+323p
UNDEF:000040A8                                         ; DATA XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+323r
UNDEF:000040AC ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:000040AC                 extrn __imp__DestroyWindow@4:near
UNDEF:000040AC                                         ; CODE XREF: Splitter::destroy(void)+Ep
UNDEF:000040AC                                         ; DATA XREF: Splitter::destroy(void)+Er
UNDEF:000040B0 ; BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow)
UNDEF:000040B0                 extrn __imp__ShowWindow@8:near
UNDEF:000040B0                                         ; CODE XREF: Window::display(bool)+2Cp
UNDEF:000040B0                                         ; DATA XREF: Window::display(bool)+2Cr
UNDEF:000040B4 ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:000040B4                 extrn __imp__MoveWindow@24:near
UNDEF:000040B4                                         ; CODE XREF: Splitter::resizeSpliter(tagRECT *)+F4p
UNDEF:000040B4                                         ; Splitter::spliterWndProc(uint,uint,long)+2E9p ...
UNDEF:000040B8 ; BOOL __stdcall IsWindowVisible(HWND hWnd)
UNDEF:000040B8                 extrn __imp__IsWindowVisible@4:near
UNDEF:000040B8                                         ; CODE XREF: Window::getHeight(void)+2Bp
UNDEF:000040B8                                         ; Window::isVisible(void)+10p
UNDEF:000040B8                                         ; DATA XREF: ...
UNDEF:000040BC ; HWND __stdcall SetCapture(HWND hWnd)
UNDEF:000040BC                 extrn __imp__SetCapture@4:near
UNDEF:000040BC                                         ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+F4p
UNDEF:000040BC                                         ; DATA XREF: Splitter::spliterWndProc(uint,uint,long)+F4r
UNDEF:000040C0 ; BOOL __stdcall ReleaseCapture()
UNDEF:000040C0                 extrn __imp__ReleaseCapture@0:near
UNDEF:000040C0                                         ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+310p
UNDEF:000040C0                                         ; DATA XREF: Splitter::spliterWndProc(uint,uint,long)+310r
UNDEF:000040C4 ; BOOL __stdcall UpdateWindow(HWND hWnd)
UNDEF:000040C4                 extrn __imp__UpdateWindow@4:near
UNDEF:000040C4                                         ; CODE XREF: Window::redraw(bool)+27p
UNDEF:000040C4                                         ; DATA XREF: Window::redraw(bool)+27r
UNDEF:000040C8 ; HDC __stdcall BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint)
UNDEF:000040C8                 extrn __imp__BeginPaint@8:near
UNDEF:000040C8                                         ; CODE XREF: Splitter::drawSplitter(void)+2Ap
UNDEF:000040C8                                         ; DATA XREF: Splitter::drawSplitter(void)+2Ar
UNDEF:000040CC ; BOOL __stdcall EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint)
UNDEF:000040CC                 extrn __imp__EndPaint@8:near
UNDEF:000040CC                                         ; CODE XREF: Splitter::drawSplitter(void)+331p
UNDEF:000040CC                                         ; DATA XREF: Splitter::drawSplitter(void)+331r
UNDEF:000040D0 ; BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
UNDEF:000040D0                 extrn __imp__InvalidateRect@12:near
UNDEF:000040D0                                         ; CODE XREF: Window::redraw(bool)+12p
UNDEF:000040D0                                         ; DATA XREF: Window::redraw(bool)+12r
UNDEF:000040D4 ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:000040D4                 extrn __imp__GetClientRect@8:near
UNDEF:000040D4                                         ; CODE XREF: Splitter::resizeSpliter(tagRECT *)+40p
UNDEF:000040D4                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+116p ...
UNDEF:000040D8 ; BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect)
UNDEF:000040D8                 extrn __imp__GetWindowRect@8:near
UNDEF:000040D8                                         ; CODE XREF: Window::getWindowRect(tagRECT &)+12p
UNDEF:000040D8                                         ; DATA XREF: Window::getWindowRect(tagRECT &)+12r
UNDEF:000040DC ; HCURSOR __stdcall SetCursor(HCURSOR hCursor)
UNDEF:000040DC                 extrn __imp__SetCursor@4:near
UNDEF:000040DC                                         ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+180p
UNDEF:000040DC                                         ; DATA XREF: Splitter::spliterWndProc(uint,uint,long)+180r
UNDEF:000040E0 ; BOOL __stdcall GetCursorPos(LPPOINT lpPoint)
UNDEF:000040E0                 extrn __imp__GetCursorPos@4:near
UNDEF:000040E0                                         ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+1BEp
UNDEF:000040E0                                         ; DATA XREF: Splitter::spliterWndProc(uint,uint,long)+1BEr
UNDEF:000040E4 ; BOOL __stdcall ScreenToClient(HWND hWnd, LPPOINT lpPoint)
UNDEF:000040E4                 extrn __imp__ScreenToClient@8:near
UNDEF:000040E4                                         ; CODE XREF: Splitter::spliterWndProc(uint,uint,long)+1CFp
UNDEF:000040E4                                         ; DATA XREF: Splitter::spliterWndProc(uint,uint,long)+1CFr
UNDEF:000040E8 ; int __stdcall FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
UNDEF:000040E8                 extrn __imp__FillRect@12:near
UNDEF:000040E8                                         ; CODE XREF: Splitter::drawSplitter(void)+256p
UNDEF:000040E8                                         ; Splitter::drawSplitter(void)+269p
UNDEF:000040E8                                         ; DATA XREF: ...
UNDEF:000040EC ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:000040EC                 extrn __imp__GetWindowLongW@8:near
UNDEF:000040EC                                         ; CODE XREF: Splitter::staticWndProc(HWND__ *,uint,uint,long)+45p
UNDEF:000040EC                                         ; DATA XREF: Splitter::staticWndProc(HWND__ *,uint,uint,long)+45r
UNDEF:000040F0 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:000040F0                 extrn __imp__SetWindowLongW@12:near
UNDEF:000040F0                                         ; CODE XREF: Splitter::staticWndProc(HWND__ *,uint,uint,long)+32p
UNDEF:000040F0                                         ; DATA XREF: Splitter::staticWndProc(HWND__ *,uint,uint,long)+32r
UNDEF:000040F4 ; HCURSOR __stdcall LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName)
UNDEF:000040F4                 extrn __imp__LoadCursorW@8:near
UNDEF:000040F4                                         ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+1BFp
UNDEF:000040F4                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+1F7p ...
UNDEF:000040F8 ; public: virtual void * __thiscall Window::`vector deleting destructor'(unsigned int)
UNDEF:000040F8                 extrn ??_EWindow@@UAEPAXI@Z:near ; weak
UNDEF:000040F8                                         ; DATA XREF: .rdata:const Window::`vftable'o
UNDEF:000040FC ; public: virtual void * __thiscall Splitter::`vector deleting destructor'(unsigned int)
UNDEF:000040FC                 extrn ??_ESplitter@@UAEPAXI@Z:near ; weak
UNDEF:000040FC                                         ; DATA XREF: .rdata:const Splitter::`vftable'o
UNDEF:00004100 ; __fastcall __security_check_cookie(x)
UNDEF:00004100                 extrn @__security_check_cookie@4:near
UNDEF:00004100                                         ; CODE XREF: Splitter::resizeSpliter(tagRECT *)+17Dp
UNDEF:00004100                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+400p ...
UNDEF:00004104 ; __stdcall _CxxThrowException(x, x)
UNDEF:00004104                 extrn __CxxThrowException@8:near
UNDEF:00004104                                         ; CODE XREF: Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+32p
UNDEF:00004104                                         ; Splitter::init(HINSTANCE__ *,HWND__ *,int,int,ulong)+53p ...
UNDEF:00004108                 extrn ___CxxFrameHandler3:near
UNDEF:00004108                                         ; CODE XREF: __ehhandler$??0Splitter@@QAE@XZ+16j
UNDEF:00004108                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j ...
UNDEF:0000410C ; const type_info::`vftable'
UNDEF:0000410C                 extrn ??_7type_info@@6B@:near
UNDEF:0000410C                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:0000410C                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:00004110                 extrn ___security_cookie:near
UNDEF:00004110                                         ; DATA XREF: Splitter::Splitter(void)+12r
UNDEF:00004110                                         ; Splitter::resizeSpliter(tagRECT *)+6r ...
UNDEF:00004114                 extrn __fltused:near
UNDEF:00004114
UNDEF:00004114
UNDEF:00004114                 end