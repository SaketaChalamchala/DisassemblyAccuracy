.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : B50F1C9A0C9FEF3BCE217F3DAEB65666
.data:00000000 ; Input CRC32 : 3348B2D3
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\ColourPopup.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 ; Segment alignment 'qword' can not be represented in assembly
.data:00000000 _data           segment para public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000                 public ?colourItems@@3PAKA
.data:00000000 ; LPARAM colourItems
.data:00000000 ?colourItems@@3PAKA dd 0                ; DATA XREF: ColourPopup::run_dlgProc(uint,uint,long)+97r
.data:00000004                 dd offset unk_40
.data:00000008                 dd offset unk_80
.data:0000000C                 db  80h ; Ç
.data:0000000D                 db  40h ; @
.data:0000000E                 db  40h ; @
.data:0000000F                 db    0
.data:00000010                 db 0FFh
.data:00000011                 db    0
.data:00000012                 db    0
.data:00000013                 db    0
.data:00000014                 db 0FFh
.data:00000015                 db  80h ; Ç
.data:00000016                 db  80h ; Ç
.data:00000017                 db    0
.data:00000018                 db 0FFh
.data:00000019                 db 0FFh
.data:0000001A                 db  80h ; Ç
.data:0000001B                 db    0
.data:0000001C                 db 0FFh
.data:0000001D                 db 0FFh
.data:0000001E                 db    0
.data:0000001F                 db    0
.data:00000020                 db 0FFh
.data:00000021                 db  80h ; Ç
.data:00000022                 db  40h ; @
.data:00000023                 db    0
.data:00000024                 db 0FFh
.data:00000025                 db  80h ; Ç
.data:00000026                 db    0
.data:00000027                 db    0
.data:00000028                 db  80h ; Ç
.data:00000029                 db  40h ; @
.data:0000002A                 db    0
.data:0000002B                 db    0
.data:0000002C                 db  80h ; Ç
.data:0000002D                 db  80h ; Ç
.data:0000002E                 db    0
.data:0000002F                 db    0
.data:00000030                 db  80h ; Ç
.data:00000031                 db  80h ; Ç
.data:00000032                 db  40h ; @
.data:00000033                 db    0
.data:00000034                 db    0
.data:00000035                 db  40h ; @
.data:00000036                 db    0
.data:00000037                 db    0
.data:00000038                 db    0
.data:00000039                 db  80h ; Ç
.data:0000003A                 db    0
.data:0000003B                 db    0
.data:0000003C                 db    0
.data:0000003D                 db 0FFh
.data:0000003E                 db    0
.data:0000003F                 db    0
.data:00000040 unk_40          db  80h ; Ç             ; DATA XREF: .data:00000004o
.data:00000041                 db 0FFh
.data:00000042                 db    0
.data:00000043                 db    0
.data:00000044                 db  80h ; Ç
.data:00000045                 db 0FFh
.data:00000046                 db  80h ; Ç
.data:00000047                 db    0
.data:00000048                 db    0
.data:00000049                 db 0FFh
.data:0000004A                 db  80h ; Ç
.data:0000004B                 db    0
.data:0000004C                 db    0
.data:0000004D                 db 0FFh
.data:0000004E                 db  40h ; @
.data:0000004F                 db    0
.data:00000050                 db    0
.data:00000051                 db  80h ; Ç
.data:00000052                 db  80h ; Ç
.data:00000053                 db    0
.data:00000054                 db    0
.data:00000055                 db  80h ; Ç
.data:00000056                 db  40h ; @
.data:00000057                 db    0
.data:00000058                 db    0
.data:00000059                 db  40h ; @
.data:0000005A                 db  40h ; @
.data:0000005B                 db    0
.data:0000005C                 db  80h ; Ç
.data:0000005D                 db  80h ; Ç
.data:0000005E                 db  80h ; Ç
.data:0000005F                 db    0
.data:00000060                 db  40h ; @
.data:00000061                 db  80h ; Ç
.data:00000062                 db  80h ; Ç
.data:00000063                 db    0
.data:00000064                 db    0
.data:00000065                 db    0
.data:00000066                 db  80h ; Ç
.data:00000067                 db    0
.data:00000068                 db    0
.data:00000069                 db    0
.data:0000006A                 db 0FFh
.data:0000006B                 db    0
.data:0000006C                 db    0
.data:0000006D                 db  40h ; @
.data:0000006E                 db  80h ; Ç
.data:0000006F                 db    0
.data:00000070                 db    0
.data:00000071                 db 0FFh
.data:00000072                 db 0FFh
.data:00000073                 db    0
.data:00000074                 db  80h ; Ç
.data:00000075                 db 0FFh
.data:00000076                 db 0FFh
.data:00000077                 db    0
.data:00000078                 db    0
.data:00000079                 db  80h ; Ç
.data:0000007A                 db 0FFh
.data:0000007B                 db    0
.data:0000007C                 db    0
.data:0000007D                 db  80h ; Ç
.data:0000007E                 db 0C0h ; +
.data:0000007F                 db    0
.data:00000080 unk_80          db  80h ; Ç             ; DATA XREF: .data:00000008o
.data:00000081                 db  80h ; Ç
.data:00000082                 db 0FFh
.data:00000083                 db    0
.data:00000084                 db    0
.data:00000085                 db    0
.data:00000086                 db 0A0h ; á
.data:00000087                 db    0
.data:00000088                 db    0
.data:00000089                 db    0
.data:0000008A                 db  40h ; @
.data:0000008B                 db    0
.data:0000008C                 db 0C0h ; +
.data:0000008D                 db 0C0h ; +
.data:0000008E                 db 0C0h ; +
.data:0000008F                 db    0
.data:00000090                 db  40h ; @
.data:00000091                 db    0
.data:00000092                 db  40h ; @
.data:00000093                 db    0
.data:00000094                 db  40h ; @
.data:00000095                 db    0
.data:00000096                 db  40h ; @
.data:00000097                 db    0
.data:00000098                 db  80h ; Ç
.data:00000099                 db    0
.data:0000009A                 db  80h ; Ç
.data:0000009B                 db    0
.data:0000009C                 db  80h ; Ç
.data:0000009D                 db    0
.data:0000009E                 db  40h ; @
.data:0000009F                 db    0
.data:000000A0                 db  80h ; Ç
.data:000000A1                 db  80h ; Ç
.data:000000A2                 db 0C0h ; +
.data:000000A3                 db    0
.data:000000A4                 db 0FFh
.data:000000A5                 db  80h ; Ç
.data:000000A6                 db 0C0h ; +
.data:000000A7                 db    0
.data:000000A8                 db 0FFh
.data:000000A9                 db  80h ; Ç
.data:000000AA                 db 0FFh
.data:000000AB                 db    0
.data:000000AC                 db 0FFh
.data:000000AD                 db    0
.data:000000AE                 db 0FFh
.data:000000AF                 db    0
.data:000000B0                 db 0FFh
.data:000000B1                 db    0
.data:000000B2                 db  80h ; Ç
.data:000000B3                 db    0
.data:000000B4                 db  80h ; Ç
.data:000000B5                 db    0
.data:000000B6                 db 0FFh
.data:000000B7                 db    0
.data:000000B8                 db  40h ; @
.data:000000B9                 db    0
.data:000000BA                 db  80h ; Ç
.data:000000BB                 db    0
.data:000000BC                 db 0FFh
.data:000000BD                 db 0FFh
.data:000000BE                 db 0FFh
.data:000000BF                 db    0
.data:000000BF _data           ends
.data:000000BF
.rdata:000000C0 ; ===========================================================================
.rdata:000000C0
.rdata:000000C0 ; Segment type: Pure data
.rdata:000000C0 ; Segment permissions: Read
.rdata:000000C0 _rdata          segment dword public 'DATA' use32
.rdata:000000C0                 assume cs:_rdata
.rdata:000000C0                 ;org 0C0h
.rdata:000000C0 ; char _SG91700[]
.rdata:000000C0 $SG91700        db 'ColourPopup::create : CreateDialogParam() function return null',0
.rdata:000000C0                                         ; DATA XREF: ColourPopup::create(int)+3Ao
.rdata:000000FF $SG91740        db    0                 ; DATA XREF: ColourPopup::run_dlgProc(uint,uint,long)+74o
.rdata:000000FF _rdata          ends
.rdata:000000FF
.text$mn:00000100 ; ===========================================================================
.text$mn:00000100
.text$mn:00000100 ; Segment type: Pure code
.text$mn:00000100 ; Segment permissions: Read/Execute
.text$mn:00000100 _text$mn        segment para public 'CODE' use32
.text$mn:00000100                 assume cs:_text$mn
.text$mn:00000100                 ;org 100h
.text$mn:00000100                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000100
.text$mn:00000100 ; =============== S U B R O U T I N E =======================================
.text$mn:00000100
.text$mn:00000100 ; Attributes: bp-based frame
.text$mn:00000100
.text$mn:00000100 ; void __thiscall ColourPopup::create(ColourPopup *this, int)
.text$mn:00000100                 public ?create@ColourPopup@@QAEXH@Z
.text$mn:00000100 ?create@ColourPopup@@QAEXH@Z proc near
.text$mn:00000100
.text$mn:00000100 var_10          = byte ptr -10h
.text$mn:00000100 dwInitParam     = dword ptr -4
.text$mn:00000100 arg_0           = dword ptr  8
.text$mn:00000100
.text$mn:00000100                 push    ebp
.text$mn:00000101                 mov     ebp, esp
.text$mn:00000103                 sub     esp, 10h
.text$mn:00000106                 mov     [ebp+dwInitParam], ecx
.text$mn:00000109                 mov     eax, [ebp+dwInitParam]
.text$mn:0000010C                 push    eax             ; dwInitParam
.text$mn:0000010D                 push    offset ?dlgProc@ColourPopup@@CGHPAUHWND__@@IIJ@Z ; lpDialogFunc
.text$mn:00000112                 mov     ecx, [ebp+dwInitParam]
.text$mn:00000115                 mov     edx, [ecx+8]
.text$mn:00000118                 push    edx             ; hWndParent
.text$mn:00000119                 movzx   eax, word ptr [ebp+arg_0]
.text$mn:0000011D                 push    eax             ; lpTemplateName
.text$mn:0000011E                 mov     ecx, [ebp+dwInitParam]
.text$mn:00000121                 mov     edx, [ecx+4]
.text$mn:00000124                 push    edx             ; hInstance
.text$mn:00000125                 call    dword ptr ds:__imp__CreateDialogParamW@20 ; CreateDialogParamW(x,x,x,x,x)
.text$mn:0000012B                 mov     ecx, [ebp+dwInitParam]
.text$mn:0000012E                 mov     [ecx+0Ch], eax
.text$mn:00000131                 mov     edx, [ebp+dwInitParam]
.text$mn:00000134                 cmp     dword ptr [edx+0Ch], 0
.text$mn:00000138                 jnz     short loc_155
.text$mn:0000013A                 push    offset $SG91700 ; "ColourPopup::create : CreateDialogParam"...
.text$mn:0000013F                 lea     ecx, [ebp+var_10] ; this
.text$mn:00000142                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:00000147                 push    offset __TI2?AVruntime_error@std@@
.text$mn:0000014C                 lea     eax, [ebp+var_10]
.text$mn:0000014F                 push    eax
.text$mn:00000150                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000155 ; ---------------------------------------------------------------------------
.text$mn:00000155
.text$mn:00000155 loc_155:                                ; CODE XREF: ColourPopup::create(int)+38j
.text$mn:00000155                 mov     ecx, [ebp+dwInitParam]
.text$mn:00000158                 add     ecx, 10h
.text$mn:0000015B                 push    ecx             ; struct tagRECT *
.text$mn:0000015C                 mov     ecx, [ebp+dwInitParam] ; this
.text$mn:0000015F                 call    ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.text$mn:00000164                 push    1
.text$mn:00000166                 mov     edx, [ebp+dwInitParam]
.text$mn:00000169                 mov     eax, [edx]
.text$mn:0000016B                 mov     ecx, [ebp+dwInitParam]
.text$mn:0000016E                 mov     edx, [eax+0Ch]
.text$mn:00000171                 call    edx
.text$mn:00000173                 mov     esp, ebp
.text$mn:00000175                 pop     ebp
.text$mn:00000176                 retn    4
.text$mn:00000176 ?create@ColourPopup@@QAEXH@Z endp
.text$mn:00000176
.text$mn:00000176 ; ---------------------------------------------------------------------------
.text$mn:00000179                 align 10h
.text$mn:00000180
.text$mn:00000180 ; =============== S U B R O U T I N E =======================================
.text$mn:00000180
.text$mn:00000180 ; Attributes: bp-based frame
.text$mn:00000180
.text$mn:00000180 ; INT_PTR __stdcall ColourPopup::dlgProc(HWND, UINT, WPARAM, LPARAM)
.text$mn:00000180                 public ?dlgProc@ColourPopup@@CGHPAUHWND__@@IIJ@Z
.text$mn:00000180 ?dlgProc@ColourPopup@@CGHPAUHWND__@@IIJ@Z proc near
.text$mn:00000180                                         ; DATA XREF: ColourPopup::create(int)+Do
.text$mn:00000180
.text$mn:00000180 var_24          = dword ptr -24h
.text$mn:00000180 var_20          = dword ptr -20h
.text$mn:00000180 var_1C          = dword ptr -1Ch
.text$mn:00000180 var_18          = dword ptr -18h
.text$mn:00000180 Rect            = tagRECT ptr -14h
.text$mn:00000180 var_4           = dword ptr -4
.text$mn:00000180 hDlg            = dword ptr  8
.text$mn:00000180 arg_4           = dword ptr  0Ch
.text$mn:00000180 arg_8           = dword ptr  10h
.text$mn:00000180 dwNewLong       = dword ptr  14h
.text$mn:00000180
.text$mn:00000180                 push    ebp
.text$mn:00000181                 mov     ebp, esp
.text$mn:00000183                 sub     esp, 24h
.text$mn:00000186                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000018B                 xor     eax, ebp
.text$mn:0000018D                 mov     [ebp+var_4], eax
.text$mn:00000190                 mov     eax, [ebp+arg_4]
.text$mn:00000193                 mov     [ebp+var_24], eax
.text$mn:00000196                 cmp     [ebp+var_24], 2Ch ; ','
.text$mn:0000019A                 jz      short loc_1AA
.text$mn:0000019C                 cmp     [ebp+var_24], 110h
.text$mn:000001A3                 jz      short loc_1FC
.text$mn:000001A5                 jmp     loc_237
.text$mn:000001AA ; ---------------------------------------------------------------------------
.text$mn:000001AA
.text$mn:000001AA loc_1AA:                                ; CODE XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+1Aj
.text$mn:000001AA                 mov     ecx, [ebp+dwNewLong]
.text$mn:000001AD                 mov     [ebp+var_18], ecx
.text$mn:000001B0                 lea     edx, [ebp+Rect]
.text$mn:000001B3                 push    edx             ; lpRect
.text$mn:000001B4                 mov     eax, [ebp+var_18]
.text$mn:000001B7                 mov     ecx, [eax+4]
.text$mn:000001BA                 push    ecx             ; nIDDlgItem
.text$mn:000001BB                 mov     edx, [ebp+hDlg]
.text$mn:000001BE                 push    edx             ; hDlg
.text$mn:000001BF                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:000001C5                 push    eax             ; hWnd
.text$mn:000001C6                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:000001CC                 mov     eax, [ebp+Rect.bottom]
.text$mn:000001CF                 sub     eax, [ebp+Rect.top]
.text$mn:000001D2                 cdq
.text$mn:000001D3                 mov     ecx, 6
.text$mn:000001D8                 idiv    ecx
.text$mn:000001DA                 mov     edx, [ebp+var_18]
.text$mn:000001DD                 mov     [edx+10h], eax
.text$mn:000001E0                 mov     eax, [ebp+Rect.right]
.text$mn:000001E3                 sub     eax, [ebp+Rect.left]
.text$mn:000001E6                 cdq
.text$mn:000001E7                 and     edx, 7
.text$mn:000001EA                 add     eax, edx
.text$mn:000001EC                 sar     eax, 3
.text$mn:000001EF                 mov     ecx, [ebp+var_18]
.text$mn:000001F2                 mov     [ecx+0Ch], eax
.text$mn:000001F5                 mov     eax, 1
.text$mn:000001FA                 jmp     short loc_265
.text$mn:000001FC ; ---------------------------------------------------------------------------
.text$mn:000001FC
.text$mn:000001FC loc_1FC:                                ; CODE XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+23j
.text$mn:000001FC                 mov     edx, [ebp+dwNewLong]
.text$mn:000001FF                 mov     [ebp+var_1C], edx
.text$mn:00000202                 mov     eax, [ebp+var_1C]
.text$mn:00000205                 mov     ecx, [ebp+hDlg]
.text$mn:00000208                 mov     [eax+0Ch], ecx
.text$mn:0000020B                 mov     edx, [ebp+dwNewLong]
.text$mn:0000020E                 push    edx             ; dwNewLong
.text$mn:0000020F                 push    0FFFFFFEBh      ; nIndex
.text$mn:00000211                 mov     eax, [ebp+hDlg]
.text$mn:00000214                 push    eax             ; hWnd
.text$mn:00000215                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:0000021B                 mov     ecx, [ebp+dwNewLong]
.text$mn:0000021E                 push    ecx             ; hWnd
.text$mn:0000021F                 mov     edx, [ebp+arg_8]
.text$mn:00000222                 push    edx             ; unsigned int
.text$mn:00000223                 mov     eax, [ebp+arg_4]
.text$mn:00000226                 push    eax             ; unsigned int
.text$mn:00000227                 mov     ecx, [ebp+var_1C]
.text$mn:0000022A                 push    ecx             ; this
.text$mn:0000022B                 call    ?run_dlgProc@ColourPopup@@AAGHIIJ@Z ; ColourPopup::run_dlgProc(uint,uint,long)
.text$mn:00000230                 mov     eax, 1
.text$mn:00000235                 jmp     short loc_265
.text$mn:00000237 ; ---------------------------------------------------------------------------
.text$mn:00000237
.text$mn:00000237 loc_237:                                ; CODE XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+25j
.text$mn:00000237                 push    0FFFFFFEBh      ; nIndex
.text$mn:00000239                 mov     edx, [ebp+hDlg]
.text$mn:0000023C                 push    edx             ; hWnd
.text$mn:0000023D                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:00000243                 mov     [ebp+var_20], eax
.text$mn:00000246                 cmp     [ebp+var_20], 0
.text$mn:0000024A                 jnz     short loc_250
.text$mn:0000024C                 xor     eax, eax
.text$mn:0000024E                 jmp     short loc_265
.text$mn:00000250 ; ---------------------------------------------------------------------------
.text$mn:00000250
.text$mn:00000250 loc_250:                                ; CODE XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+CAj
.text$mn:00000250                 mov     eax, [ebp+dwNewLong]
.text$mn:00000253                 push    eax             ; hWnd
.text$mn:00000254                 mov     ecx, [ebp+arg_8]
.text$mn:00000257                 push    ecx             ; unsigned int
.text$mn:00000258                 mov     edx, [ebp+arg_4]
.text$mn:0000025B                 push    edx             ; unsigned int
.text$mn:0000025C                 mov     eax, [ebp+var_20]
.text$mn:0000025F                 push    eax             ; this
.text$mn:00000260                 call    ?run_dlgProc@ColourPopup@@AAGHIIJ@Z ; ColourPopup::run_dlgProc(uint,uint,long)
.text$mn:00000265
.text$mn:00000265 loc_265:                                ; CODE XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+7Aj
.text$mn:00000265                                         ; ColourPopup::dlgProc(HWND__ *,uint,uint,long)+B5j ...
.text$mn:00000265                 mov     ecx, [ebp+var_4]
.text$mn:00000268                 xor     ecx, ebp
.text$mn:0000026A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000026F                 mov     esp, ebp
.text$mn:00000271                 pop     ebp
.text$mn:00000272                 retn    10h
.text$mn:00000272 ?dlgProc@ColourPopup@@CGHPAUHWND__@@IIJ@Z endp
.text$mn:00000272
.text$mn:00000272 ; ---------------------------------------------------------------------------
.text$mn:00000275                 align 10h
.text$mn:00000280
.text$mn:00000280 ; =============== S U B R O U T I N E =======================================
.text$mn:00000280
.text$mn:00000280 ; Attributes: bp-based frame
.text$mn:00000280
.text$mn:00000280 ; int __stdcall ColourPopup::run_dlgProc(ColourPopup *this, unsigned int, unsigned int, HWND hWnd)
.text$mn:00000280                 public ?run_dlgProc@ColourPopup@@AAGHIIJ@Z
.text$mn:00000280 ?run_dlgProc@ColourPopup@@AAGHIIJ@Z proc near
.text$mn:00000280                                         ; CODE XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+ABp
.text$mn:00000280                                         ; ColourPopup::dlgProc(HWND__ *,uint,uint,long)+E0p
.text$mn:00000280
.text$mn:00000280 Dst             = dword ptr -68h
.text$mn:00000280 var_64          = dword ptr -64h
.text$mn:00000280 var_5C          = dword ptr -5Ch
.text$mn:00000280 var_58          = dword ptr -58h
.text$mn:00000280 var_54          = dword ptr -54h
.text$mn:00000280 var_44          = dword ptr -44h
.text$mn:00000280 var_40          = dword ptr -40h
.text$mn:00000280 color           = dword ptr -3Ch
.text$mn:00000280 var_38          = dword ptr -38h
.text$mn:00000280 var_34          = dword ptr -34h
.text$mn:00000280 var_30          = dword ptr -30h
.text$mn:00000280 h               = dword ptr -2Ch
.text$mn:00000280 hbr             = dword ptr -28h
.text$mn:00000280 var_24          = dword ptr -24h
.text$mn:00000280 wParam          = dword ptr -20h
.text$mn:00000280 var_1C          = dword ptr -1Ch
.text$mn:00000280 hdc             = dword ptr -18h
.text$mn:00000280 rc              = tagRECT ptr -14h
.text$mn:00000280 var_4           = dword ptr -4
.text$mn:00000280 this            = dword ptr  8
.text$mn:00000280 arg_4           = dword ptr  0Ch
.text$mn:00000280 arg_8           = dword ptr  10h
.text$mn:00000280 hWnd            = dword ptr  14h
.text$mn:00000280
.text$mn:00000280                 push    ebp
.text$mn:00000281                 mov     ebp, esp
.text$mn:00000283                 sub     esp, 68h
.text$mn:00000286                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000028B                 xor     eax, ebp
.text$mn:0000028D                 mov     [ebp+var_4], eax
.text$mn:00000290                 mov     eax, [ebp+arg_4]
.text$mn:00000293                 mov     [ebp+var_24], eax
.text$mn:00000296                 cmp     [ebp+var_24], 110h
.text$mn:0000029D                 ja      short loc_2C1
.text$mn:0000029F                 cmp     [ebp+var_24], 110h
.text$mn:000002A6                 jz      short loc_2DC
.text$mn:000002A8                 cmp     [ebp+var_24], 6
.text$mn:000002AC                 jz      loc_700
.text$mn:000002B2                 cmp     [ebp+var_24], 2Bh ; '+'
.text$mn:000002B6                 jz      loc_35A
.text$mn:000002BC                 jmp     loc_72C
.text$mn:000002C1 ; ---------------------------------------------------------------------------
.text$mn:000002C1
.text$mn:000002C1 loc_2C1:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+1Dj
.text$mn:000002C1                 cmp     [ebp+var_24], 111h
.text$mn:000002C8                 jz      loc_5DF
.text$mn:000002CE                 cmp     [ebp+var_24], 134h
.text$mn:000002D5                 jz      short loc_346
.text$mn:000002D7                 jmp     loc_72C
.text$mn:000002DC ; ---------------------------------------------------------------------------
.text$mn:000002DC
.text$mn:000002DC loc_2DC:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+26j
.text$mn:000002DC                 mov     [ebp+wParam], 0
.text$mn:000002E3                 jmp     short loc_2EE
.text$mn:000002E5 ; ---------------------------------------------------------------------------
.text$mn:000002E5
.text$mn:000002E5 loc_2E5:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+BAj
.text$mn:000002E5                 mov     ecx, [ebp+wParam]
.text$mn:000002E8                 add     ecx, 1
.text$mn:000002EB                 mov     [ebp+wParam], ecx
.text$mn:000002EE
.text$mn:000002EE loc_2EE:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+63j
.text$mn:000002EE                 cmp     [ebp+wParam], 30h ; '0'
.text$mn:000002F2                 jge     short loc_33C
.text$mn:000002F4                 push    offset $SG91740 ; lParam
.text$mn:000002F9                 mov     edx, [ebp+wParam]
.text$mn:000002FC                 push    edx             ; wParam
.text$mn:000002FD                 push    180h            ; Msg
.text$mn:00000302                 push    835h            ; nIDDlgItem
.text$mn:00000307                 mov     eax, [ebp+this]
.text$mn:0000030A                 mov     ecx, [eax+0Ch]
.text$mn:0000030D                 push    ecx             ; hDlg
.text$mn:0000030E                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00000314                 mov     edx, [ebp+wParam]
.text$mn:00000317                 mov     eax, ?colourItems@@3PAKA[edx*4] ; ulong * colourItems
.text$mn:0000031E                 push    eax             ; lParam
.text$mn:0000031F                 mov     ecx, [ebp+wParam]
.text$mn:00000322                 push    ecx             ; wParam
.text$mn:00000323                 push    19Ah            ; Msg
.text$mn:00000328                 push    835h            ; nIDDlgItem
.text$mn:0000032D                 mov     edx, [ebp+this]
.text$mn:00000330                 mov     eax, [edx+0Ch]
.text$mn:00000333                 push    eax             ; hDlg
.text$mn:00000334                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:0000033A                 jmp     short loc_2E5
.text$mn:0000033C ; ---------------------------------------------------------------------------
.text$mn:0000033C
.text$mn:0000033C loc_33C:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+72j
.text$mn:0000033C                 mov     eax, 1
.text$mn:00000341                 jmp     loc_72E
.text$mn:00000346 ; ---------------------------------------------------------------------------
.text$mn:00000346
.text$mn:00000346 loc_346:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+55j
.text$mn:00000346                 push    0Fh             ; nIndex
.text$mn:00000348                 call    dword ptr ds:__imp__GetSysColor@4 ; GetSysColor(x)
.text$mn:0000034E                 push    eax             ; color
.text$mn:0000034F                 call    dword ptr ds:__imp__CreateSolidBrush@4 ; CreateSolidBrush(x)
.text$mn:00000355                 jmp     loc_72E
.text$mn:0000035A ; ---------------------------------------------------------------------------
.text$mn:0000035A
.text$mn:0000035A loc_35A:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+36j
.text$mn:0000035A                 mov     ecx, [ebp+hWnd]
.text$mn:0000035D                 mov     [ebp+var_1C], ecx
.text$mn:00000360                 mov     edx, [ebp+var_1C]
.text$mn:00000363                 mov     eax, [edx+18h]
.text$mn:00000366                 mov     [ebp+hdc], eax
.text$mn:00000369                 mov     ecx, [ebp+var_1C]
.text$mn:0000036C                 add     ecx, 1Ch
.text$mn:0000036F                 mov     edx, [ecx]
.text$mn:00000371                 mov     [ebp+rc.left], edx
.text$mn:00000374                 mov     eax, [ecx+4]
.text$mn:00000377                 mov     [ebp+rc.top], eax
.text$mn:0000037A                 mov     edx, [ecx+8]
.text$mn:0000037D                 mov     [ebp+rc.right], edx
.text$mn:00000380                 mov     eax, [ecx+0Ch]
.text$mn:00000383                 mov     [ebp+rc.bottom], eax
.text$mn:00000386                 push    1               ; mode
.text$mn:00000388                 mov     ecx, [ebp+hdc]
.text$mn:0000038B                 push    ecx             ; hdc
.text$mn:0000038C                 call    dword ptr ds:__imp__SetBkMode@8 ; SetBkMode(x,x)
.text$mn:00000392                 mov     edx, [ebp+var_1C]
.text$mn:00000395                 cmp     dword ptr [edx+8], 0FFFFFFFFh
.text$mn:00000399                 jnz     short loc_3A2
.text$mn:0000039B                 xor     eax, eax
.text$mn:0000039D                 jmp     loc_72E
.text$mn:000003A2 ; ---------------------------------------------------------------------------
.text$mn:000003A2
.text$mn:000003A2 loc_3A2:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+119j
.text$mn:000003A2                 mov     eax, [ebp+var_1C]
.text$mn:000003A5                 mov     ecx, [eax+0Ch]
.text$mn:000003A8                 mov     [ebp+var_30], ecx
.text$mn:000003AB                 cmp     [ebp+var_30], 1
.text$mn:000003AF                 jz      short loc_3CA
.text$mn:000003B1                 cmp     [ebp+var_30], 2
.text$mn:000003B5                 jz      loc_452
.text$mn:000003BB                 cmp     [ebp+var_30], 4
.text$mn:000003BF                 jz      loc_59C
.text$mn:000003C5                 jmp     loc_5D5
.text$mn:000003CA ; ---------------------------------------------------------------------------
.text$mn:000003CA
.text$mn:000003CA loc_3CA:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+12Fj
.text$mn:000003CA                 mov     edx, [ebp+var_1C]
.text$mn:000003CD                 mov     eax, [edx+4]
.text$mn:000003D0                 mov     [ebp+var_40], eax
.text$mn:000003D3                 cmp     [ebp+var_40], 835h
.text$mn:000003DA                 jz      short loc_3DE
.text$mn:000003DC                 jmp     short loc_452
.text$mn:000003DE ; ---------------------------------------------------------------------------
.text$mn:000003DE
.text$mn:000003DE loc_3DE:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+15Aj
.text$mn:000003DE                 mov     ecx, [ebp+var_1C]
.text$mn:000003E1                 add     ecx, 1Ch
.text$mn:000003E4                 mov     edx, [ecx]
.text$mn:000003E6                 mov     [ebp+rc.left], edx
.text$mn:000003E9                 mov     eax, [ecx+4]
.text$mn:000003EC                 mov     [ebp+rc.top], eax
.text$mn:000003EF                 mov     edx, [ecx+8]
.text$mn:000003F2                 mov     [ebp+rc.right], edx
.text$mn:000003F5                 mov     eax, [ecx+0Ch]
.text$mn:000003F8                 mov     [ebp+rc.bottom], eax
.text$mn:000003FB                 mov     ecx, [ebp+var_1C]
.text$mn:000003FE                 mov     edx, [ecx+2Ch]
.text$mn:00000401                 mov     [ebp+color], edx
.text$mn:00000404                 push    0FFFFFFFDh      ; dy
.text$mn:00000406                 push    0FFFFFFFDh      ; dx
.text$mn:00000408                 lea     eax, [ebp+rc]
.text$mn:0000040B                 push    eax             ; lprc
.text$mn:0000040C                 call    dword ptr ds:__imp__InflateRect@12 ; InflateRect(x,x,x)
.text$mn:00000412                 mov     ecx, [ebp+color]
.text$mn:00000415                 push    ecx             ; color
.text$mn:00000416                 call    dword ptr ds:__imp__CreateSolidBrush@4 ; CreateSolidBrush(x)
.text$mn:0000041C                 mov     [ebp+hbr], eax
.text$mn:0000041F                 mov     edx, [ebp+hbr]
.text$mn:00000422                 push    edx             ; hbr
.text$mn:00000423                 lea     eax, [ebp+rc]
.text$mn:00000426                 push    eax             ; lprc
.text$mn:00000427                 mov     ecx, [ebp+hdc]
.text$mn:0000042A                 push    ecx             ; hDC
.text$mn:0000042B                 call    dword ptr ds:__imp__FillRect@12 ; FillRect(x,x,x)
.text$mn:00000431                 mov     edx, [ebp+hbr]
.text$mn:00000434                 push    edx             ; ho
.text$mn:00000435                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:0000043B                 push    2               ; i
.text$mn:0000043D                 call    dword ptr ds:__imp__GetStockObject@4 ; GetStockObject(x)
.text$mn:00000443                 push    eax             ; hbr
.text$mn:00000444                 lea     eax, [ebp+rc]
.text$mn:00000447                 push    eax             ; lprc
.text$mn:00000448                 mov     ecx, [ebp+hdc]
.text$mn:0000044B                 push    ecx             ; hDC
.text$mn:0000044C                 call    dword ptr ds:__imp__FrameRect@12 ; FrameRect(x,x,x)
.text$mn:00000452
.text$mn:00000452 loc_452:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+135j
.text$mn:00000452                                         ; ColourPopup::run_dlgProc(uint,uint,long)+15Cj
.text$mn:00000452                 mov     edx, [ebp+var_1C]
.text$mn:00000455                 add     edx, 1Ch
.text$mn:00000458                 mov     eax, [edx]
.text$mn:0000045A                 mov     [ebp+rc.left], eax
.text$mn:0000045D                 mov     ecx, [edx+4]
.text$mn:00000460                 mov     [ebp+rc.top], ecx
.text$mn:00000463                 mov     eax, [edx+8]
.text$mn:00000466                 mov     [ebp+rc.right], eax
.text$mn:00000469                 mov     ecx, [edx+0Ch]
.text$mn:0000046C                 mov     [ebp+rc.bottom], ecx
.text$mn:0000046F                 mov     edx, [ebp+var_1C]
.text$mn:00000472                 mov     eax, [edx+10h]
.text$mn:00000475                 and     eax, 1
.text$mn:00000478                 jz      loc_56C
.text$mn:0000047E                 mov     ecx, [ebp+rc.bottom]
.text$mn:00000481                 sub     ecx, 1
.text$mn:00000484                 mov     [ebp+rc.bottom], ecx
.text$mn:00000487                 mov     edx, [ebp+rc.right]
.text$mn:0000048A                 sub     edx, 1
.text$mn:0000048D                 mov     [ebp+rc.right], edx
.text$mn:00000490                 push    10h             ; nIndex
.text$mn:00000492                 call    dword ptr ds:__imp__GetSysColor@4 ; GetSysColor(x)
.text$mn:00000498                 push    eax             ; color
.text$mn:00000499                 push    1               ; cWidth
.text$mn:0000049B                 push    0               ; iStyle
.text$mn:0000049D                 call    dword ptr ds:__imp__CreatePen@12 ; CreatePen(x,x,x)
.text$mn:000004A3                 mov     [ebp+h], eax
.text$mn:000004A6                 mov     eax, [ebp+h]
.text$mn:000004A9                 push    eax             ; h
.text$mn:000004AA                 mov     ecx, [ebp+hdc]
.text$mn:000004AD                 push    ecx             ; hdc
.text$mn:000004AE                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:000004B4                 mov     [ebp+var_34], eax
.text$mn:000004B7                 push    0               ; lppt
.text$mn:000004B9                 mov     edx, [ebp+rc.bottom]
.text$mn:000004BC                 push    edx             ; y
.text$mn:000004BD                 mov     eax, [ebp+rc.left]
.text$mn:000004C0                 push    eax             ; x
.text$mn:000004C1                 mov     ecx, [ebp+hdc]
.text$mn:000004C4                 push    ecx             ; hdc
.text$mn:000004C5                 call    dword ptr ds:__imp__MoveToEx@16 ; MoveToEx(x,x,x,x)
.text$mn:000004CB                 mov     edx, [ebp+rc.top]
.text$mn:000004CE                 push    edx             ; y
.text$mn:000004CF                 mov     eax, [ebp+rc.left]
.text$mn:000004D2                 push    eax             ; x
.text$mn:000004D3                 mov     ecx, [ebp+hdc]
.text$mn:000004D6                 push    ecx             ; hdc
.text$mn:000004D7                 call    dword ptr ds:__imp__LineTo@12 ; LineTo(x,x,x)
.text$mn:000004DD                 mov     edx, [ebp+rc.top]
.text$mn:000004E0                 push    edx             ; y
.text$mn:000004E1                 mov     eax, [ebp+rc.right]
.text$mn:000004E4                 push    eax             ; x
.text$mn:000004E5                 mov     ecx, [ebp+hdc]
.text$mn:000004E8                 push    ecx             ; hdc
.text$mn:000004E9                 call    dword ptr ds:__imp__LineTo@12 ; LineTo(x,x,x)
.text$mn:000004EF                 mov     edx, [ebp+var_34]
.text$mn:000004F2                 push    edx             ; h
.text$mn:000004F3                 mov     eax, [ebp+hdc]
.text$mn:000004F6                 push    eax             ; hdc
.text$mn:000004F7                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:000004FD                 mov     ecx, [ebp+h]
.text$mn:00000500                 push    ecx             ; ho
.text$mn:00000501                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00000507                 push    14h             ; nIndex
.text$mn:00000509                 call    dword ptr ds:__imp__GetSysColor@4 ; GetSysColor(x)
.text$mn:0000050F                 push    eax             ; color
.text$mn:00000510                 push    1               ; cWidth
.text$mn:00000512                 push    0               ; iStyle
.text$mn:00000514                 call    dword ptr ds:__imp__CreatePen@12 ; CreatePen(x,x,x)
.text$mn:0000051A                 mov     [ebp+h], eax
.text$mn:0000051D                 mov     edx, [ebp+h]
.text$mn:00000520                 push    edx             ; h
.text$mn:00000521                 mov     eax, [ebp+hdc]
.text$mn:00000524                 push    eax             ; hdc
.text$mn:00000525                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:0000052B                 mov     [ebp+var_34], eax
.text$mn:0000052E                 mov     ecx, [ebp+rc.bottom]
.text$mn:00000531                 push    ecx             ; y
.text$mn:00000532                 mov     edx, [ebp+rc.right]
.text$mn:00000535                 push    edx             ; x
.text$mn:00000536                 mov     eax, [ebp+hdc]
.text$mn:00000539                 push    eax             ; hdc
.text$mn:0000053A                 call    dword ptr ds:__imp__LineTo@12 ; LineTo(x,x,x)
.text$mn:00000540                 mov     ecx, [ebp+rc.bottom]
.text$mn:00000543                 push    ecx             ; y
.text$mn:00000544                 mov     edx, [ebp+rc.left]
.text$mn:00000547                 push    edx             ; x
.text$mn:00000548                 mov     eax, [ebp+hdc]
.text$mn:0000054B                 push    eax             ; hdc
.text$mn:0000054C                 call    dword ptr ds:__imp__LineTo@12 ; LineTo(x,x,x)
.text$mn:00000552                 mov     ecx, [ebp+var_34]
.text$mn:00000555                 push    ecx             ; h
.text$mn:00000556                 mov     edx, [ebp+hdc]
.text$mn:00000559                 push    edx             ; hdc
.text$mn:0000055A                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:00000560                 mov     eax, [ebp+h]
.text$mn:00000563                 push    eax             ; ho
.text$mn:00000564                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:0000056A                 jmp     short loc_59A
.text$mn:0000056C ; ---------------------------------------------------------------------------
.text$mn:0000056C
.text$mn:0000056C loc_56C:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+1F8j
.text$mn:0000056C                 push    0Fh             ; nIndex
.text$mn:0000056E                 call    dword ptr ds:__imp__GetSysColor@4 ; GetSysColor(x)
.text$mn:00000574                 push    eax             ; color
.text$mn:00000575                 call    dword ptr ds:__imp__CreateSolidBrush@4 ; CreateSolidBrush(x)
.text$mn:0000057B                 mov     [ebp+hbr], eax
.text$mn:0000057E                 mov     ecx, [ebp+hbr]
.text$mn:00000581                 push    ecx             ; hbr
.text$mn:00000582                 lea     edx, [ebp+rc]
.text$mn:00000585                 push    edx             ; lprc
.text$mn:00000586                 mov     eax, [ebp+hdc]
.text$mn:00000589                 push    eax             ; hDC
.text$mn:0000058A                 call    dword ptr ds:__imp__FrameRect@12 ; FrameRect(x,x,x)
.text$mn:00000590                 mov     ecx, [ebp+hbr]
.text$mn:00000593                 push    ecx             ; ho
.text$mn:00000594                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:0000059A
.text$mn:0000059A loc_59A:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+2EAj
.text$mn:0000059A                 jmp     short loc_5D5
.text$mn:0000059C ; ---------------------------------------------------------------------------
.text$mn:0000059C
.text$mn:0000059C loc_59C:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+13Fj
.text$mn:0000059C                 mov     edx, [ebp+var_1C]
.text$mn:0000059F                 add     edx, 1Ch
.text$mn:000005A2                 mov     eax, [edx]
.text$mn:000005A4                 mov     [ebp+rc.left], eax
.text$mn:000005A7                 mov     ecx, [edx+4]
.text$mn:000005AA                 mov     [ebp+rc.top], ecx
.text$mn:000005AD                 mov     eax, [edx+8]
.text$mn:000005B0                 mov     [ebp+rc.right], eax
.text$mn:000005B3                 mov     ecx, [edx+0Ch]
.text$mn:000005B6                 mov     [ebp+rc.bottom], ecx
.text$mn:000005B9                 push    0FFFFFFFEh      ; dy
.text$mn:000005BB                 push    0FFFFFFFEh      ; dx
.text$mn:000005BD                 lea     edx, [ebp+rc]
.text$mn:000005C0                 push    edx             ; lprc
.text$mn:000005C1                 call    dword ptr ds:__imp__InflateRect@12 ; InflateRect(x,x,x)
.text$mn:000005C7                 lea     eax, [ebp+rc]
.text$mn:000005CA                 push    eax             ; lprc
.text$mn:000005CB                 mov     ecx, [ebp+hdc]
.text$mn:000005CE                 push    ecx             ; hDC
.text$mn:000005CF                 call    dword ptr ds:__imp__DrawFocusRect@8 ; DrawFocusRect(x,x)
.text$mn:000005D5
.text$mn:000005D5 loc_5D5:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+145j
.text$mn:000005D5                                         ; ColourPopup::run_dlgProc(uint,uint,long):loc_59Aj
.text$mn:000005D5                 mov     eax, 1
.text$mn:000005DA                 jmp     loc_72E
.text$mn:000005DF ; ---------------------------------------------------------------------------
.text$mn:000005DF
.text$mn:000005DF loc_5DF:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+48j
.text$mn:000005DF                 mov     edx, [ebp+arg_8]
.text$mn:000005E2                 and     edx, 0FFFFh
.text$mn:000005E8                 movzx   eax, dx
.text$mn:000005EB                 mov     [ebp+var_38], eax
.text$mn:000005EE                 cmp     [ebp+var_38], 1
.text$mn:000005F2                 jz      short loc_606
.text$mn:000005F4                 cmp     [ebp+var_38], 835h
.text$mn:000005FB                 jz      loc_695
.text$mn:00000601                 jmp     loc_6FC
.text$mn:00000606 ; ---------------------------------------------------------------------------
.text$mn:00000606
.text$mn:00000606 loc_606:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+372j
.text$mn:00000606                 push    24h ; '$'       ; Size
.text$mn:00000608                 push    0               ; Val
.text$mn:0000060A                 lea     ecx, [ebp+Dst]
.text$mn:0000060D                 push    ecx             ; Dst
.text$mn:0000060E                 call    _memset
.text$mn:00000613                 add     esp, 0Ch
.text$mn:00000616                 mov     [ebp+Dst], 24h ; '$'
.text$mn:0000061D                 mov     edx, [ebp+this]
.text$mn:00000620                 mov     eax, [edx+8]
.text$mn:00000623                 mov     [ebp+var_64], eax
.text$mn:00000626                 mov     [ebp+var_58], offset ?acrCustClr@?BG@??run_dlgProc@ColourPopup@@AAGHIIJ@Z@4PAKA ; ulong * `ColourPopup::run_dlgProc(uint,uint,long)'::`22'::acrCustClr
.text$mn:0000062D                 mov     ecx, [ebp+this]
.text$mn:00000630                 mov     edx, [ecx+20h]
.text$mn:00000633                 mov     [ebp+var_5C], edx
.text$mn:00000636                 mov     [ebp+var_54], 3
.text$mn:0000063D                 push    0
.text$mn:0000063F                 mov     eax, [ebp+this]
.text$mn:00000642                 mov     edx, [eax]
.text$mn:00000644                 mov     ecx, [ebp+this]
.text$mn:00000647                 mov     eax, [edx+0Ch]
.text$mn:0000064A                 call    eax
.text$mn:0000064C                 lea     ecx, [ebp+Dst]
.text$mn:0000064F                 push    ecx             ; LPCHOOSECOLORW
.text$mn:00000650                 call    dword ptr ds:__imp__ChooseColorW@4 ; ChooseColorW(x)
.text$mn:00000656                 cmp     eax, 1
.text$mn:00000659                 jnz     short loc_675
.text$mn:0000065B                 push    0               ; lParam
.text$mn:0000065D                 mov     edx, [ebp+var_5C]
.text$mn:00000660                 push    edx             ; wParam
.text$mn:00000661                 push    1B71h           ; Msg
.text$mn:00000666                 mov     eax, [ebp+this]
.text$mn:00000669                 mov     ecx, [eax+8]
.text$mn:0000066C                 push    ecx             ; hWnd
.text$mn:0000066D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000673                 jmp     short loc_68B
.text$mn:00000675 ; ---------------------------------------------------------------------------
.text$mn:00000675
.text$mn:00000675 loc_675:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+3D9j
.text$mn:00000675                 push    0               ; lParam
.text$mn:00000677                 push    0               ; wParam
.text$mn:00000679                 push    1B72h           ; Msg
.text$mn:0000067E                 mov     edx, [ebp+this]
.text$mn:00000681                 mov     eax, [edx+8]
.text$mn:00000684                 push    eax             ; hWnd
.text$mn:00000685                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000068B
.text$mn:0000068B loc_68B:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+3F3j
.text$mn:0000068B                 mov     eax, 1
.text$mn:00000690                 jmp     loc_72E
.text$mn:00000695 ; ---------------------------------------------------------------------------
.text$mn:00000695
.text$mn:00000695 loc_695:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+37Bj
.text$mn:00000695                 mov     ecx, [ebp+arg_8]
.text$mn:00000698                 shr     ecx, 10h
.text$mn:0000069B                 and     ecx, 0FFFFh
.text$mn:000006A1                 movzx   edx, cx
.text$mn:000006A4                 cmp     edx, 1
.text$mn:000006A7                 jnz     short loc_6FC
.text$mn:000006A9                 push    0               ; lParam
.text$mn:000006AB                 push    0               ; wParam
.text$mn:000006AD                 push    188h            ; Msg
.text$mn:000006B2                 mov     eax, [ebp+hWnd]
.text$mn:000006B5                 push    eax             ; hWnd
.text$mn:000006B6                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000006BC                 mov     [ebp+var_44], eax
.text$mn:000006BF                 push    0               ; lParam
.text$mn:000006C1                 mov     ecx, [ebp+var_44]
.text$mn:000006C4                 push    ecx             ; wParam
.text$mn:000006C5                 push    199h            ; Msg
.text$mn:000006CA                 mov     edx, [ebp+hWnd]
.text$mn:000006CD                 push    edx             ; hWnd
.text$mn:000006CE                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000006D4                 mov     ecx, [ebp+this]
.text$mn:000006D7                 mov     [ecx+20h], eax
.text$mn:000006DA                 push    0               ; lParam
.text$mn:000006DC                 mov     edx, [ebp+this]
.text$mn:000006DF                 mov     eax, [edx+20h]
.text$mn:000006E2                 push    eax             ; wParam
.text$mn:000006E3                 push    1B71h           ; Msg
.text$mn:000006E8                 mov     ecx, [ebp+this]
.text$mn:000006EB                 mov     edx, [ecx+8]
.text$mn:000006EE                 push    edx             ; hWnd
.text$mn:000006EF                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000006F5                 mov     eax, 1
.text$mn:000006FA                 jmp     short loc_72E
.text$mn:000006FC ; ---------------------------------------------------------------------------
.text$mn:000006FC
.text$mn:000006FC loc_6FC:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+381j
.text$mn:000006FC                                         ; ColourPopup::run_dlgProc(uint,uint,long)+427j
.text$mn:000006FC                 xor     eax, eax
.text$mn:000006FE                 jmp     short loc_72E
.text$mn:00000700 ; ---------------------------------------------------------------------------
.text$mn:00000700
.text$mn:00000700 loc_700:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+2Cj
.text$mn:00000700                 mov     eax, [ebp+arg_8]
.text$mn:00000703                 and     eax, 0FFFFh
.text$mn:00000708                 movzx   ecx, ax
.text$mn:0000070B                 test    ecx, ecx
.text$mn:0000070D                 jnz     short loc_725
.text$mn:0000070F                 push    0               ; lParam
.text$mn:00000711                 push    0               ; wParam
.text$mn:00000713                 push    1B72h           ; Msg
.text$mn:00000718                 mov     edx, [ebp+this]
.text$mn:0000071B                 mov     eax, [edx+8]
.text$mn:0000071E                 push    eax             ; hWnd
.text$mn:0000071F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000725
.text$mn:00000725 loc_725:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+48Dj
.text$mn:00000725                 mov     eax, 1
.text$mn:0000072A                 jmp     short loc_72E
.text$mn:0000072C ; ---------------------------------------------------------------------------
.text$mn:0000072C
.text$mn:0000072C loc_72C:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+3Cj
.text$mn:0000072C                                         ; ColourPopup::run_dlgProc(uint,uint,long)+57j
.text$mn:0000072C                 xor     eax, eax
.text$mn:0000072E
.text$mn:0000072E loc_72E:                                ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+C1j
.text$mn:0000072E                                         ; ColourPopup::run_dlgProc(uint,uint,long)+D5j ...
.text$mn:0000072E                 mov     ecx, [ebp+var_4]
.text$mn:00000731                 xor     ecx, ebp
.text$mn:00000733                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000738                 mov     esp, ebp
.text$mn:0000073A                 pop     ebp
.text$mn:0000073B                 retn    10h
.text$mn:0000073B ?run_dlgProc@ColourPopup@@AAGHIIJ@Z endp
.text$mn:0000073B
.text$mn:0000073B ; ---------------------------------------------------------------------------
.text$mn:0000073E                 align 10h
.text$mn:0000073E _text$mn        ends
.text$mn:0000073E
.text$mn:00000740 ; ===========================================================================
.text$mn:00000740
.text$mn:00000740 ; Segment type: Pure code
.text$mn:00000740 ; Segment permissions: Read/Execute
.text$mn:00000740 _text$mn        segment para public 'CODE' use32
.text$mn:00000740                 assume cs:_text$mn
.text$mn:00000740                 ;org 740h
.text$mn:00000740 ; COMDAT (pick any)
.text$mn:00000740                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000740
.text$mn:00000740 ; =============== S U B R O U T I N E =======================================
.text$mn:00000740
.text$mn:00000740 ; Attributes: bp-based frame
.text$mn:00000740
.text$mn:00000740 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00000740                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00000740 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00000740                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00000740
.text$mn:00000740 var_4           = dword ptr -4
.text$mn:00000740 arg_0           = dword ptr  8
.text$mn:00000740
.text$mn:00000740                 push    ebp
.text$mn:00000741                 mov     ebp, esp
.text$mn:00000743                 push    ecx
.text$mn:00000744                 mov     [ebp+var_4], 0
.text$mn:0000074B                 cmp     [ebp+arg_0], 0
.text$mn:0000074F                 jnz     short loc_753
.text$mn:00000751                 jmp     short loc_773
.text$mn:00000753 ; ---------------------------------------------------------------------------
.text$mn:00000753
.text$mn:00000753 loc_753:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00000753                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00000757                 ja      short loc_76E
.text$mn:00000759                 mov     eax, [ebp+arg_0]
.text$mn:0000075C                 push    eax             ; unsigned int
.text$mn:0000075D                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000762                 add     esp, 4
.text$mn:00000765                 mov     [ebp+var_4], eax
.text$mn:00000768                 cmp     [ebp+var_4], 0
.text$mn:0000076C                 jnz     short loc_773
.text$mn:0000076E
.text$mn:0000076E loc_76E:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:0000076E                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000773
.text$mn:00000773 loc_773:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00000773                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00000773                 mov     eax, [ebp+var_4]
.text$mn:00000776                 mov     esp, ebp
.text$mn:00000778                 pop     ebp
.text$mn:00000779                 retn
.text$mn:00000779 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00000779
.text$mn:00000779 ; ---------------------------------------------------------------------------
.text$mn:0000077A                 align 4
.text$mn:0000077A _text$mn        ends
.text$mn:0000077A
.text$mn:0000077C ; ===========================================================================
.text$mn:0000077C
.text$mn:0000077C ; Segment type: Pure code
.text$mn:0000077C ; Segment permissions: Read/Execute
.text$mn:0000077C _text$mn        segment para public 'CODE' use32
.text$mn:0000077C                 assume cs:_text$mn
.text$mn:0000077C                 ;org 77Ch
.text$mn:0000077C ; COMDAT (pick any)
.text$mn:0000077C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000077C
.text$mn:0000077C ; =============== S U B R O U T I N E =======================================
.text$mn:0000077C
.text$mn:0000077C ; Attributes: bp-based frame
.text$mn:0000077C
.text$mn:0000077C ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:0000077C                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:0000077C ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:0000077C                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:0000077C
.text$mn:0000077C var_4           = dword ptr -4
.text$mn:0000077C arg_0           = dword ptr  8
.text$mn:0000077C
.text$mn:0000077C                 push    ebp
.text$mn:0000077D                 mov     ebp, esp
.text$mn:0000077F                 push    ecx
.text$mn:00000780                 mov     [ebp+var_4], 0
.text$mn:00000787                 cmp     [ebp+arg_0], 0
.text$mn:0000078B                 jnz     short loc_78F
.text$mn:0000078D                 jmp     short loc_7B5
.text$mn:0000078F ; ---------------------------------------------------------------------------
.text$mn:0000078F
.text$mn:0000078F loc_78F:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:0000078F                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00000796                 ja      short loc_7B0
.text$mn:00000798                 mov     eax, [ebp+arg_0]
.text$mn:0000079B                 shl     eax, 3
.text$mn:0000079E                 push    eax             ; unsigned int
.text$mn:0000079F                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000007A4                 add     esp, 4
.text$mn:000007A7                 mov     [ebp+var_4], eax
.text$mn:000007AA                 cmp     [ebp+var_4], 0
.text$mn:000007AE                 jnz     short loc_7B5
.text$mn:000007B0
.text$mn:000007B0 loc_7B0:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000007B0                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000007B5
.text$mn:000007B5 loc_7B5:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000007B5                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000007B5                 mov     eax, [ebp+var_4]
.text$mn:000007B8                 mov     esp, ebp
.text$mn:000007BA                 pop     ebp
.text$mn:000007BB                 retn
.text$mn:000007BB ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000007BB
.text$mn:000007BB _text$mn        ends
.text$mn:000007BB
.text$mn:000007BC ; ===========================================================================
.text$mn:000007BC
.text$mn:000007BC ; Segment type: Pure code
.text$mn:000007BC ; Segment permissions: Read/Execute
.text$mn:000007BC _text$mn        segment para public 'CODE' use32
.text$mn:000007BC                 assume cs:_text$mn
.text$mn:000007BC                 ;org 7BCh
.text$mn:000007BC ; COMDAT (pick any)
.text$mn:000007BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000007BC
.text$mn:000007BC ; =============== S U B R O U T I N E =======================================
.text$mn:000007BC
.text$mn:000007BC ; Attributes: bp-based frame
.text$mn:000007BC
.text$mn:000007BC ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000007BC                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000007BC ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000007BC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000007BC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000007BC
.text$mn:000007BC arg_0           = dword ptr  8
.text$mn:000007BC arg_4           = dword ptr  0Ch
.text$mn:000007BC arg_8           = dword ptr  10h
.text$mn:000007BC
.text$mn:000007BC                 push    ebp
.text$mn:000007BD                 mov     ebp, esp
.text$mn:000007BF                 cmp     [ebp+arg_0], 0
.text$mn:000007C3                 jnz     short loc_7DA
.text$mn:000007C5                 mov     eax, [ebp+arg_8]
.text$mn:000007C8                 push    eax             ; unsigned int
.text$mn:000007C9                 mov     ecx, [ebp+arg_4]
.text$mn:000007CC                 push    ecx             ; wchar_t *
.text$mn:000007CD                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000007D2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000007D7                 add     esp, 0Ch
.text$mn:000007DA
.text$mn:000007DA loc_7DA:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000007DA                 pop     ebp
.text$mn:000007DB                 retn
.text$mn:000007DB ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000007DB
.text$mn:000007DB _text$mn        ends
.text$mn:000007DB
.text$mn:000007DC ; ===========================================================================
.text$mn:000007DC
.text$mn:000007DC ; Segment type: Pure code
.text$mn:000007DC ; Segment permissions: Read/Execute
.text$mn:000007DC _text$mn        segment para public 'CODE' use32
.text$mn:000007DC                 assume cs:_text$mn
.text$mn:000007DC                 ;org 7DCh
.text$mn:000007DC ; COMDAT (pick any)
.text$mn:000007DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000007DC
.text$mn:000007DC ; =============== S U B R O U T I N E =======================================
.text$mn:000007DC
.text$mn:000007DC ; Attributes: bp-based frame
.text$mn:000007DC
.text$mn:000007DC ; char * __cdecl std::addressof<char>(char &)
.text$mn:000007DC                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000007DC ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000007DC                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000007DC                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000007DC
.text$mn:000007DC arg_0           = dword ptr  8
.text$mn:000007DC
.text$mn:000007DC                 push    ebp
.text$mn:000007DD                 mov     ebp, esp
.text$mn:000007DF                 mov     eax, [ebp+arg_0]
.text$mn:000007E2                 pop     ebp
.text$mn:000007E3                 retn
.text$mn:000007E3 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000007E3
.text$mn:000007E3 _text$mn        ends
.text$mn:000007E3
.text$mn:000007E4 ; ===========================================================================
.text$mn:000007E4
.text$mn:000007E4 ; Segment type: Pure code
.text$mn:000007E4 ; Segment permissions: Read/Execute
.text$mn:000007E4 _text$mn        segment para public 'CODE' use32
.text$mn:000007E4                 assume cs:_text$mn
.text$mn:000007E4                 ;org 7E4h
.text$mn:000007E4 ; COMDAT (pick any)
.text$mn:000007E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000007E4
.text$mn:000007E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000007E4
.text$mn:000007E4 ; Attributes: bp-based frame
.text$mn:000007E4
.text$mn:000007E4 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000007E4                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000007E4 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000007E4                                         ; CODE XREF: $LN19+4Bp
.text$mn:000007E4
.text$mn:000007E4 var_4           = dword ptr -4
.text$mn:000007E4 arg_0           = dword ptr  8
.text$mn:000007E4 arg_4           = dword ptr  0Ch
.text$mn:000007E4
.text$mn:000007E4                 push    ebp
.text$mn:000007E5                 mov     ebp, esp
.text$mn:000007E7                 push    ecx
.text$mn:000007E8                 mov     [ebp+var_4], ecx
.text$mn:000007EB                 mov     eax, [ebp+arg_4]
.text$mn:000007EE                 push    eax
.text$mn:000007EF                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000007F4                 add     esp, 4
.text$mn:000007F7                 push    eax             ; int
.text$mn:000007F8                 mov     ecx, [ebp+arg_0]
.text$mn:000007FB                 push    ecx             ; void *
.text$mn:000007FC                 mov     edx, [ebp+var_4]
.text$mn:000007FF                 push    edx             ; int
.text$mn:00000800                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00000805                 add     esp, 0Ch
.text$mn:00000808                 mov     esp, ebp
.text$mn:0000080A                 pop     ebp
.text$mn:0000080B                 retn    8
.text$mn:0000080B ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000080B
.text$mn:0000080B ; ---------------------------------------------------------------------------
.text$mn:0000080E                 align 10h
.text$mn:0000080E _text$mn        ends
.text$mn:0000080E
.text$mn:00000810 ; ===========================================================================
.text$mn:00000810
.text$mn:00000810 ; Segment type: Pure code
.text$mn:00000810 ; Segment permissions: Read/Execute
.text$mn:00000810 _text$mn        segment para public 'CODE' use32
.text$mn:00000810                 assume cs:_text$mn
.text$mn:00000810                 ;org 810h
.text$mn:00000810 ; COMDAT (pick any)
.text$mn:00000810                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000810
.text$mn:00000810 ; =============== S U B R O U T I N E =======================================
.text$mn:00000810
.text$mn:00000810 ; Attributes: bp-based frame
.text$mn:00000810
.text$mn:00000810 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00000810                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000810 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000810                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00000810
.text$mn:00000810 var_1C          = dword ptr -1Ch
.text$mn:00000810 var_18          = dword ptr -18h
.text$mn:00000810 var_14          = dword ptr -14h
.text$mn:00000810 var_10          = dword ptr -10h
.text$mn:00000810 var_C           = dword ptr -0Ch
.text$mn:00000810 var_4           = dword ptr -4
.text$mn:00000810 arg_0           = dword ptr  8
.text$mn:00000810 arg_4           = dword ptr  0Ch
.text$mn:00000810
.text$mn:00000810                 push    ebp
.text$mn:00000811                 mov     ebp, esp
.text$mn:00000813                 push    0FFFFFFFFh
.text$mn:00000815                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000081A                 mov     eax, large fs:0
.text$mn:00000820                 push    eax
.text$mn:00000821                 sub     esp, 10h
.text$mn:00000824                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000829                 xor     eax, ebp
.text$mn:0000082B                 push    eax
.text$mn:0000082C                 lea     eax, [ebp+var_C]
.text$mn:0000082F                 mov     large fs:0, eax
.text$mn:00000835                 mov     [ebp+var_18], ecx
.text$mn:00000838                 mov     eax, [ebp+arg_0]
.text$mn:0000083B                 push    eax             ; void *
.text$mn:0000083C                 push    4               ; unsigned int
.text$mn:0000083E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000843                 add     esp, 8
.text$mn:00000846                 mov     [ebp+var_10], eax
.text$mn:00000849                 mov     [ebp+var_4], 0
.text$mn:00000850                 cmp     [ebp+var_10], 0
.text$mn:00000854                 jz      short loc_871
.text$mn:00000856                 mov     ecx, [ebp+arg_4]
.text$mn:00000859                 push    ecx
.text$mn:0000085A                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000085F                 add     esp, 4
.text$mn:00000862                 mov     edx, [ebp+var_10]
.text$mn:00000865                 mov     eax, [eax]
.text$mn:00000867                 mov     [edx], eax
.text$mn:00000869                 mov     ecx, [ebp+var_10]
.text$mn:0000086C                 mov     [ebp+var_14], ecx
.text$mn:0000086F                 jmp     short loc_878
.text$mn:00000871 ; ---------------------------------------------------------------------------
.text$mn:00000871
.text$mn:00000871 loc_871:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00000871                 mov     [ebp+var_14], 0
.text$mn:00000878
.text$mn:00000878 loc_878:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00000878                 mov     edx, [ebp+var_14]
.text$mn:0000087B                 mov     [ebp+var_1C], edx
.text$mn:0000087E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000885                 mov     ecx, [ebp+var_C]
.text$mn:00000888                 mov     large fs:0, ecx
.text$mn:0000088F                 pop     ecx
.text$mn:00000890                 mov     esp, ebp
.text$mn:00000892                 pop     ebp
.text$mn:00000893                 retn    8
.text$mn:00000893 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000893
.text$mn:00000893 ; ---------------------------------------------------------------------------
.text$mn:00000896                 align 4
.text$mn:00000896 _text$mn        ends
.text$mn:00000896
.text$x:00000898 ; ===========================================================================
.text$x:00000898
.text$x:00000898 ; Segment type: Pure code
.text$x:00000898 ; Segment permissions: Read/Execute
.text$x:00000898 _text$x         segment para public 'CODE' use32
.text$x:00000898                 assume cs:_text$x
.text$x:00000898                 ;org 898h
.text$x:00000898 ; COMDAT (pick associative to section at 810)
.text$x:00000898                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000898
.text$x:00000898 ; =============== S U B R O U T I N E =======================================
.text$x:00000898
.text$x:00000898
.text$x:00000898 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00000898                                         ; DATA XREF: .xdata$x:000025B0o
.text$x:00000898                 mov     eax, [ebp+8]
.text$x:0000089B                 push    eax
.text$x:0000089C                 mov     eax, [ebp-10h]
.text$x:0000089F                 push    eax             ; void *
.text$x:000008A0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000008A5                 add     esp, 8
.text$x:000008A8                 retn
.text$x:000008A8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000008A8
.text$x:000008A9
.text$x:000008A9 ; =============== S U B R O U T I N E =======================================
.text$x:000008A9
.text$x:000008A9
.text$x:000008A9 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000008A9                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000008A9
.text$x:000008A9 arg_4           = dword ptr  8
.text$x:000008A9
.text$x:000008A9                 mov     edx, [esp+arg_4]
.text$x:000008AD                 lea     eax, [edx+0Ch]
.text$x:000008B0                 mov     ecx, [edx-14h]
.text$x:000008B3                 xor     ecx, eax
.text$x:000008B5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000008BA                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000008BF                 jmp     ___CxxFrameHandler3
.text$x:000008BF __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000008BF
.text$x:000008BF _text$x         ends
.text$x:000008BF
.text$mn:000008C4 ; ===========================================================================
.text$mn:000008C4
.text$mn:000008C4 ; Segment type: Pure code
.text$mn:000008C4 ; Segment permissions: Read/Execute
.text$mn:000008C4 _text$mn        segment para public 'CODE' use32
.text$mn:000008C4                 assume cs:_text$mn
.text$mn:000008C4                 ;org 8C4h
.text$mn:000008C4 ; COMDAT (pick any)
.text$mn:000008C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000008C4
.text$mn:000008C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000008C4
.text$mn:000008C4 ; Attributes: bp-based frame
.text$mn:000008C4
.text$mn:000008C4 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000008C4                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000008C4 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000008C4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000008C4
.text$mn:000008C4 arg_0           = dword ptr  8
.text$mn:000008C4 arg_4           = dword ptr  0Ch
.text$mn:000008C4 arg_8           = dword ptr  10h
.text$mn:000008C4
.text$mn:000008C4                 push    ebp
.text$mn:000008C5                 mov     ebp, esp
.text$mn:000008C7                 mov     eax, [ebp+arg_8]
.text$mn:000008CA                 push    eax
.text$mn:000008CB                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000008D0                 add     esp, 4
.text$mn:000008D3                 push    eax             ; int
.text$mn:000008D4                 mov     ecx, [ebp+arg_4]
.text$mn:000008D7                 push    ecx             ; void *
.text$mn:000008D8                 mov     ecx, [ebp+arg_0]
.text$mn:000008DB                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:000008E0                 pop     ebp
.text$mn:000008E1                 retn
.text$mn:000008E1 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:000008E1
.text$mn:000008E1 ; ---------------------------------------------------------------------------
.text$mn:000008E2                 align 4
.text$mn:000008E2 _text$mn        ends
.text$mn:000008E2
.text$mn:000008E4 ; ===========================================================================
.text$mn:000008E4
.text$mn:000008E4 ; Segment type: Pure code
.text$mn:000008E4 ; Segment permissions: Read/Execute
.text$mn:000008E4 _text$mn        segment para public 'CODE' use32
.text$mn:000008E4                 assume cs:_text$mn
.text$mn:000008E4                 ;org 8E4h
.text$mn:000008E4 ; COMDAT (pick any)
.text$mn:000008E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000008E4
.text$mn:000008E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000008E4
.text$mn:000008E4 ; Attributes: bp-based frame
.text$mn:000008E4
.text$mn:000008E4 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000008E4                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000008E4 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000008E4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:000008E4
.text$mn:000008E4 var_1C          = dword ptr -1Ch
.text$mn:000008E4 var_18          = dword ptr -18h
.text$mn:000008E4 var_14          = dword ptr -14h
.text$mn:000008E4 var_10          = dword ptr -10h
.text$mn:000008E4 var_C           = dword ptr -0Ch
.text$mn:000008E4 var_4           = dword ptr -4
.text$mn:000008E4 arg_0           = dword ptr  8
.text$mn:000008E4 arg_4           = dword ptr  0Ch
.text$mn:000008E4
.text$mn:000008E4                 push    ebp
.text$mn:000008E5                 mov     ebp, esp
.text$mn:000008E7                 push    0FFFFFFFFh
.text$mn:000008E9                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000008EE                 mov     eax, large fs:0
.text$mn:000008F4                 push    eax
.text$mn:000008F5                 sub     esp, 10h
.text$mn:000008F8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000008FD                 xor     eax, ebp
.text$mn:000008FF                 push    eax
.text$mn:00000900                 lea     eax, [ebp+var_C]
.text$mn:00000903                 mov     large fs:0, eax
.text$mn:00000909                 mov     [ebp+var_18], ecx
.text$mn:0000090C                 mov     eax, [ebp+arg_0]
.text$mn:0000090F                 push    eax             ; void *
.text$mn:00000910                 push    8               ; unsigned int
.text$mn:00000912                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000917                 add     esp, 8
.text$mn:0000091A                 mov     [ebp+var_10], eax
.text$mn:0000091D                 mov     [ebp+var_4], 0
.text$mn:00000924                 cmp     [ebp+var_10], 0
.text$mn:00000928                 jz      short loc_94B
.text$mn:0000092A                 mov     ecx, [ebp+arg_4]
.text$mn:0000092D                 push    ecx
.text$mn:0000092E                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00000933                 add     esp, 4
.text$mn:00000936                 mov     edx, [eax]
.text$mn:00000938                 mov     eax, [eax+4]
.text$mn:0000093B                 mov     ecx, [ebp+var_10]
.text$mn:0000093E                 mov     [ecx], edx
.text$mn:00000940                 mov     [ecx+4], eax
.text$mn:00000943                 mov     edx, [ebp+var_10]
.text$mn:00000946                 mov     [ebp+var_14], edx
.text$mn:00000949                 jmp     short loc_952
.text$mn:0000094B ; ---------------------------------------------------------------------------
.text$mn:0000094B
.text$mn:0000094B loc_94B:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:0000094B                 mov     [ebp+var_14], 0
.text$mn:00000952
.text$mn:00000952 loc_952:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00000952                 mov     eax, [ebp+var_14]
.text$mn:00000955                 mov     [ebp+var_1C], eax
.text$mn:00000958                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000095F                 mov     ecx, [ebp+var_C]
.text$mn:00000962                 mov     large fs:0, ecx
.text$mn:00000969                 pop     ecx
.text$mn:0000096A                 mov     esp, ebp
.text$mn:0000096C                 pop     ebp
.text$mn:0000096D                 retn    8
.text$mn:0000096D ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:0000096D
.text$mn:0000096D _text$mn        ends
.text$mn:0000096D
.text$x:00000970 ; ===========================================================================
.text$x:00000970
.text$x:00000970 ; Segment type: Pure code
.text$x:00000970 ; Segment permissions: Read/Execute
.text$x:00000970 _text$x         segment para public 'CODE' use32
.text$x:00000970                 assume cs:_text$x
.text$x:00000970                 ;org 970h
.text$x:00000970 ; COMDAT (pick associative to section at 8E4)
.text$x:00000970                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000970
.text$x:00000970 ; =============== S U B R O U T I N E =======================================
.text$x:00000970
.text$x:00000970
.text$x:00000970 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00000970                                         ; DATA XREF: .xdata$x:00002584o
.text$x:00000970                 mov     eax, [ebp+8]
.text$x:00000973                 push    eax
.text$x:00000974                 mov     eax, [ebp-10h]
.text$x:00000977                 push    eax             ; void *
.text$x:00000978                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:0000097D                 add     esp, 8
.text$x:00000980                 retn
.text$x:00000980 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00000980
.text$x:00000981
.text$x:00000981 ; =============== S U B R O U T I N E =======================================
.text$x:00000981
.text$x:00000981
.text$x:00000981 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00000981                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00000981
.text$x:00000981 arg_4           = dword ptr  8
.text$x:00000981
.text$x:00000981                 mov     edx, [esp+arg_4]
.text$x:00000985                 lea     eax, [edx+0Ch]
.text$x:00000988                 mov     ecx, [edx-14h]
.text$x:0000098B                 xor     ecx, eax
.text$x:0000098D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000992                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00000997                 jmp     ___CxxFrameHandler3
.text$x:00000997 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00000997
.text$x:00000997 _text$x         ends
.text$x:00000997
.text$mn:0000099C ; ===========================================================================
.text$mn:0000099C
.text$mn:0000099C ; Segment type: Pure code
.text$mn:0000099C ; Segment permissions: Read/Execute
.text$mn:0000099C _text$mn        segment para public 'CODE' use32
.text$mn:0000099C                 assume cs:_text$mn
.text$mn:0000099C                 ;org 99Ch
.text$mn:0000099C ; COMDAT (pick any)
.text$mn:0000099C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000099C
.text$mn:0000099C ; =============== S U B R O U T I N E =======================================
.text$mn:0000099C
.text$mn:0000099C ; Attributes: bp-based frame
.text$mn:0000099C
.text$mn:0000099C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000099C                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:0000099C ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:0000099C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:0000099C
.text$mn:0000099C var_4           = dword ptr -4
.text$mn:0000099C arg_0           = dword ptr  8
.text$mn:0000099C
.text$mn:0000099C                 push    ebp
.text$mn:0000099D                 mov     ebp, esp
.text$mn:0000099F                 push    ecx
.text$mn:000009A0                 mov     [ebp+var_4], ecx
.text$mn:000009A3                 mov     eax, [ebp+arg_0]
.text$mn:000009A6                 push    eax
.text$mn:000009A7                 mov     ecx, [ebp+var_4]
.text$mn:000009AA                 push    ecx
.text$mn:000009AB                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:000009B0                 add     esp, 8
.text$mn:000009B3                 mov     esp, ebp
.text$mn:000009B5                 pop     ebp
.text$mn:000009B6                 retn    4
.text$mn:000009B6 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:000009B6
.text$mn:000009B6 ; ---------------------------------------------------------------------------
.text$mn:000009B9                 align 4
.text$mn:000009B9 _text$mn        ends
.text$mn:000009B9
.text$mn:000009BC ; ===========================================================================
.text$mn:000009BC
.text$mn:000009BC ; Segment type: Pure code
.text$mn:000009BC ; Segment permissions: Read/Execute
.text$mn:000009BC _text$mn        segment para public 'CODE' use32
.text$mn:000009BC                 assume cs:_text$mn
.text$mn:000009BC                 ;org 9BCh
.text$mn:000009BC ; COMDAT (pick any)
.text$mn:000009BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000009BC
.text$mn:000009BC ; =============== S U B R O U T I N E =======================================
.text$mn:000009BC
.text$mn:000009BC ; Attributes: bp-based frame
.text$mn:000009BC
.text$mn:000009BC ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:000009BC                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:000009BC ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:000009BC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:000009BC
.text$mn:000009BC var_4           = dword ptr -4
.text$mn:000009BC
.text$mn:000009BC                 push    ebp
.text$mn:000009BD                 mov     ebp, esp
.text$mn:000009BF                 push    ecx
.text$mn:000009C0                 mov     [ebp+var_4], ecx
.text$mn:000009C3                 mov     esp, ebp
.text$mn:000009C5                 pop     ebp
.text$mn:000009C6                 retn    4
.text$mn:000009C6 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:000009C6
.text$mn:000009C6 ; ---------------------------------------------------------------------------
.text$mn:000009C9                 align 4
.text$mn:000009C9 _text$mn        ends
.text$mn:000009C9
.text$mn:000009CC ; ===========================================================================
.text$mn:000009CC
.text$mn:000009CC ; Segment type: Pure code
.text$mn:000009CC ; Segment permissions: Read/Execute
.text$mn:000009CC _text$mn        segment para public 'CODE' use32
.text$mn:000009CC                 assume cs:_text$mn
.text$mn:000009CC                 ;org 9CCh
.text$mn:000009CC ; COMDAT (pick any)
.text$mn:000009CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000009CC
.text$mn:000009CC ; =============== S U B R O U T I N E =======================================
.text$mn:000009CC
.text$mn:000009CC ; Attributes: bp-based frame
.text$mn:000009CC
.text$mn:000009CC ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:000009CC                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:000009CC ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:000009CC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:000009CC
.text$mn:000009CC arg_0           = dword ptr  8
.text$mn:000009CC arg_4           = dword ptr  0Ch
.text$mn:000009CC
.text$mn:000009CC                 push    ebp
.text$mn:000009CD                 mov     ebp, esp
.text$mn:000009CF                 mov     eax, [ebp+arg_4]
.text$mn:000009D2                 push    eax
.text$mn:000009D3                 mov     ecx, [ebp+arg_0]
.text$mn:000009D6                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:000009DB                 pop     ebp
.text$mn:000009DC                 retn
.text$mn:000009DC ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:000009DC
.text$mn:000009DC ; ---------------------------------------------------------------------------
.text$mn:000009DD                 align 10h
.text$mn:000009DD _text$mn        ends
.text$mn:000009DD
.text$mn:000009E0 ; ===========================================================================
.text$mn:000009E0
.text$mn:000009E0 ; Segment type: Pure code
.text$mn:000009E0 ; Segment permissions: Read/Execute
.text$mn:000009E0 _text$mn        segment para public 'CODE' use32
.text$mn:000009E0                 assume cs:_text$mn
.text$mn:000009E0                 ;org 9E0h
.text$mn:000009E0 ; COMDAT (pick any)
.text$mn:000009E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000009E0
.text$mn:000009E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000009E0
.text$mn:000009E0 ; Attributes: bp-based frame
.text$mn:000009E0
.text$mn:000009E0 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:000009E0                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:000009E0 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:000009E0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:000009E0
.text$mn:000009E0 var_4           = dword ptr -4
.text$mn:000009E0
.text$mn:000009E0                 push    ebp
.text$mn:000009E1                 mov     ebp, esp
.text$mn:000009E3                 push    ecx
.text$mn:000009E4                 mov     [ebp+var_4], ecx
.text$mn:000009E7                 mov     esp, ebp
.text$mn:000009E9                 pop     ebp
.text$mn:000009EA                 retn    4
.text$mn:000009EA ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:000009EA
.text$mn:000009EA ; ---------------------------------------------------------------------------
.text$mn:000009ED                 align 10h
.text$mn:000009ED _text$mn        ends
.text$mn:000009ED
.text$mn:000009F0 ; ===========================================================================
.text$mn:000009F0
.text$mn:000009F0 ; Segment type: Pure code
.text$mn:000009F0 ; Segment permissions: Read/Execute
.text$mn:000009F0 _text$mn        segment para public 'CODE' use32
.text$mn:000009F0                 assume cs:_text$mn
.text$mn:000009F0                 ;org 9F0h
.text$mn:000009F0 ; COMDAT (pick any)
.text$mn:000009F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000009F0
.text$mn:000009F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000009F0
.text$mn:000009F0 ; Attributes: bp-based frame
.text$mn:000009F0
.text$mn:000009F0 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:000009F0                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:000009F0 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:000009F0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:000009F0                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:000009F0
.text$mn:000009F0 arg_0           = dword ptr  8
.text$mn:000009F0
.text$mn:000009F0                 push    ebp
.text$mn:000009F1                 mov     ebp, esp
.text$mn:000009F3                 mov     eax, [ebp+arg_0]
.text$mn:000009F6                 pop     ebp
.text$mn:000009F7                 retn
.text$mn:000009F7 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:000009F7
.text$mn:000009F7 _text$mn        ends
.text$mn:000009F7
.text$mn:000009F8 ; ===========================================================================
.text$mn:000009F8
.text$mn:000009F8 ; Segment type: Pure code
.text$mn:000009F8 ; Segment permissions: Read/Execute
.text$mn:000009F8 _text$mn        segment para public 'CODE' use32
.text$mn:000009F8                 assume cs:_text$mn
.text$mn:000009F8                 ;org 9F8h
.text$mn:000009F8 ; COMDAT (pick any)
.text$mn:000009F8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000009F8
.text$mn:000009F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000009F8
.text$mn:000009F8 ; Attributes: bp-based frame
.text$mn:000009F8
.text$mn:000009F8 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:000009F8                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:000009F8 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:000009F8                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:000009F8
.text$mn:000009F8 arg_0           = dword ptr  8
.text$mn:000009F8
.text$mn:000009F8                 push    ebp
.text$mn:000009F9                 mov     ebp, esp
.text$mn:000009FB                 mov     eax, [ebp+arg_0]
.text$mn:000009FE                 pop     ebp
.text$mn:000009FF                 retn
.text$mn:000009FF ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:000009FF
.text$mn:000009FF _text$mn        ends
.text$mn:000009FF
.text$mn:00000A00 ; ===========================================================================
.text$mn:00000A00
.text$mn:00000A00 ; Segment type: Pure code
.text$mn:00000A00 ; Segment permissions: Read/Execute
.text$mn:00000A00 _text$mn        segment para public 'CODE' use32
.text$mn:00000A00                 assume cs:_text$mn
.text$mn:00000A00                 ;org 0A00h
.text$mn:00000A00 ; COMDAT (pick any)
.text$mn:00000A00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000A00
.text$mn:00000A00 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A00
.text$mn:00000A00 ; Attributes: bp-based frame
.text$mn:00000A00
.text$mn:00000A00 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00000A00                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000A00 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00000A00                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00000A00
.text$mn:00000A00 var_10          = dword ptr -10h
.text$mn:00000A00 var_C           = dword ptr -0Ch
.text$mn:00000A00 var_4           = dword ptr -4
.text$mn:00000A00
.text$mn:00000A00                 push    ebp
.text$mn:00000A01                 mov     ebp, esp
.text$mn:00000A03                 push    0FFFFFFFFh
.text$mn:00000A05                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000A0A                 mov     eax, large fs:0
.text$mn:00000A10                 push    eax
.text$mn:00000A11                 push    ecx
.text$mn:00000A12                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A17                 xor     eax, ebp
.text$mn:00000A19                 push    eax
.text$mn:00000A1A                 lea     eax, [ebp+var_C]
.text$mn:00000A1D                 mov     large fs:0, eax
.text$mn:00000A23                 mov     [ebp+var_10], ecx
.text$mn:00000A26                 mov     ecx, [ebp+var_10]
.text$mn:00000A29                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00000A2E                 mov     [ebp+var_4], 0
.text$mn:00000A35                 mov     ecx, [ebp+var_10]
.text$mn:00000A38                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000A3D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A44                 mov     eax, [ebp+var_10]
.text$mn:00000A47                 mov     ecx, [ebp+var_C]
.text$mn:00000A4A                 mov     large fs:0, ecx
.text$mn:00000A51                 pop     ecx
.text$mn:00000A52                 mov     esp, ebp
.text$mn:00000A54                 pop     ebp
.text$mn:00000A55                 retn    4
.text$mn:00000A55 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00000A55
.text$mn:00000A55 _text$mn        ends
.text$mn:00000A55
.text$x:00000A58 ; ===========================================================================
.text$x:00000A58
.text$x:00000A58 ; Segment type: Pure code
.text$x:00000A58 ; Segment permissions: Read/Execute
.text$x:00000A58 _text$x         segment para public 'CODE' use32
.text$x:00000A58                 assume cs:_text$x
.text$x:00000A58                 ;org 0A58h
.text$x:00000A58 ; COMDAT (pick associative to section at A00)
.text$x:00000A58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000A58
.text$x:00000A58 ; =============== S U B R O U T I N E =======================================
.text$x:00000A58
.text$x:00000A58
.text$x:00000A58 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000A58                                         ; DATA XREF: .xdata$x:00002238o
.text$x:00000A58                 mov     ecx, [ebp-10h]
.text$x:00000A5B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000A5B __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00000A5B
.text$x:00000A60
.text$x:00000A60 ; =============== S U B R O U T I N E =======================================
.text$x:00000A60
.text$x:00000A60
.text$x:00000A60 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00000A60                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00000A60
.text$x:00000A60 arg_4           = dword ptr  8
.text$x:00000A60
.text$x:00000A60                 mov     edx, [esp+arg_4]
.text$x:00000A64                 lea     eax, [edx+0Ch]
.text$x:00000A67                 mov     ecx, [edx-8]
.text$x:00000A6A                 xor     ecx, eax
.text$x:00000A6C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A71                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00000A76                 jmp     ___CxxFrameHandler3
.text$x:00000A76 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00000A76
.text$x:00000A76 ; ---------------------------------------------------------------------------
.text$x:00000A7B                 align 4
.text$x:00000A7B _text$x         ends
.text$x:00000A7B
.text$mn:00000A7C ; ===========================================================================
.text$mn:00000A7C
.text$mn:00000A7C ; Segment type: Pure code
.text$mn:00000A7C ; Segment permissions: Read/Execute
.text$mn:00000A7C _text$mn        segment para public 'CODE' use32
.text$mn:00000A7C                 assume cs:_text$mn
.text$mn:00000A7C                 ;org 0A7Ch
.text$mn:00000A7C ; COMDAT (pick any)
.text$mn:00000A7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000A7C
.text$mn:00000A7C ; =============== S U B R O U T I N E =======================================
.text$mn:00000A7C
.text$mn:00000A7C ; Attributes: bp-based frame
.text$mn:00000A7C
.text$mn:00000A7C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000A7C                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000A7C ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000A7C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00000A7C
.text$mn:00000A7C var_10          = dword ptr -10h
.text$mn:00000A7C var_C           = dword ptr -0Ch
.text$mn:00000A7C var_4           = dword ptr -4
.text$mn:00000A7C
.text$mn:00000A7C                 push    ebp
.text$mn:00000A7D                 mov     ebp, esp
.text$mn:00000A7F                 push    0FFFFFFFFh
.text$mn:00000A81                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000A86                 mov     eax, large fs:0
.text$mn:00000A8C                 push    eax
.text$mn:00000A8D                 push    ecx
.text$mn:00000A8E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A93                 xor     eax, ebp
.text$mn:00000A95                 push    eax
.text$mn:00000A96                 lea     eax, [ebp+var_C]
.text$mn:00000A99                 mov     large fs:0, eax
.text$mn:00000A9F                 mov     [ebp+var_10], ecx
.text$mn:00000AA2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000AA5                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00000AAA                 mov     [ebp+var_4], 0
.text$mn:00000AB1                 mov     eax, [ebp+var_10]
.text$mn:00000AB4                 mov     dword ptr [eax+14h], 0
.text$mn:00000ABB                 mov     ecx, [ebp+var_10]
.text$mn:00000ABE                 mov     dword ptr [ecx+18h], 0
.text$mn:00000AC5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000ACC                 mov     eax, [ebp+var_10]
.text$mn:00000ACF                 mov     ecx, [ebp+var_C]
.text$mn:00000AD2                 mov     large fs:0, ecx
.text$mn:00000AD9                 pop     ecx
.text$mn:00000ADA                 mov     esp, ebp
.text$mn:00000ADC                 pop     ebp
.text$mn:00000ADD                 retn
.text$mn:00000ADD ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000ADD
.text$mn:00000ADD ; ---------------------------------------------------------------------------
.text$mn:00000ADE                 align 10h
.text$mn:00000ADE _text$mn        ends
.text$mn:00000ADE
.text$x:00000AE0 ; ===========================================================================
.text$x:00000AE0
.text$x:00000AE0 ; Segment type: Pure code
.text$x:00000AE0 ; Segment permissions: Read/Execute
.text$x:00000AE0 _text$x         segment para public 'CODE' use32
.text$x:00000AE0                 assume cs:_text$x
.text$x:00000AE0                 ;org 0AE0h
.text$x:00000AE0 ; COMDAT (pick associative to section at A7C)
.text$x:00000AE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000AE0
.text$x:00000AE0 ; =============== S U B R O U T I N E =======================================
.text$x:00000AE0
.text$x:00000AE0
.text$x:00000AE0 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000AE0                                         ; DATA XREF: .xdata$x:000021E0o
.text$x:00000AE0                 mov     ecx, [ebp-10h]  ; this
.text$x:00000AE3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000AE3 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000AE3
.text$x:00000AE8
.text$x:00000AE8 ; =============== S U B R O U T I N E =======================================
.text$x:00000AE8
.text$x:00000AE8
.text$x:00000AE8 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000AE8                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000AE8
.text$x:00000AE8 arg_4           = dword ptr  8
.text$x:00000AE8
.text$x:00000AE8                 mov     edx, [esp+arg_4]
.text$x:00000AEC                 lea     eax, [edx+0Ch]
.text$x:00000AEF                 mov     ecx, [edx-8]
.text$x:00000AF2                 xor     ecx, eax
.text$x:00000AF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000AF9                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000AFE                 jmp     ___CxxFrameHandler3
.text$x:00000AFE __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000AFE
.text$x:00000AFE ; ---------------------------------------------------------------------------
.text$x:00000B03                 align 4
.text$x:00000B03 _text$x         ends
.text$x:00000B03
.text$mn:00000B04 ; ===========================================================================
.text$mn:00000B04
.text$mn:00000B04 ; Segment type: Pure code
.text$mn:00000B04 ; Segment permissions: Read/Execute
.text$mn:00000B04 _text$mn        segment para public 'CODE' use32
.text$mn:00000B04                 assume cs:_text$mn
.text$mn:00000B04                 ;org 0B04h
.text$mn:00000B04 ; COMDAT (pick any)
.text$mn:00000B04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000B04
.text$mn:00000B04 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B04
.text$mn:00000B04 ; Attributes: bp-based frame
.text$mn:00000B04
.text$mn:00000B04 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00000B04                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00000B04 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00000B04                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00000B04
.text$mn:00000B04 var_4           = dword ptr -4
.text$mn:00000B04
.text$mn:00000B04                 push    ebp
.text$mn:00000B05                 mov     ebp, esp
.text$mn:00000B07                 push    ecx
.text$mn:00000B08                 mov     [ebp+var_4], ecx
.text$mn:00000B0B                 mov     ecx, [ebp+var_4]
.text$mn:00000B0E                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000B13                 mov     eax, [ebp+var_4]
.text$mn:00000B16                 mov     esp, ebp
.text$mn:00000B18                 pop     ebp
.text$mn:00000B19                 retn
.text$mn:00000B19 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00000B19
.text$mn:00000B19 ; ---------------------------------------------------------------------------
.text$mn:00000B1A                 align 4
.text$mn:00000B1A _text$mn        ends
.text$mn:00000B1A
.text$mn:00000B1C ; ===========================================================================
.text$mn:00000B1C
.text$mn:00000B1C ; Segment type: Pure code
.text$mn:00000B1C ; Segment permissions: Read/Execute
.text$mn:00000B1C _text$mn        segment para public 'CODE' use32
.text$mn:00000B1C                 assume cs:_text$mn
.text$mn:00000B1C                 ;org 0B1Ch
.text$mn:00000B1C ; COMDAT (pick any)
.text$mn:00000B1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000B1C
.text$mn:00000B1C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B1C
.text$mn:00000B1C ; Attributes: bp-based frame
.text$mn:00000B1C
.text$mn:00000B1C ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00000B1C                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00000B1C ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00000B1C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00000B1C
.text$mn:00000B1C var_4           = dword ptr -4
.text$mn:00000B1C
.text$mn:00000B1C                 push    ebp
.text$mn:00000B1D                 mov     ebp, esp
.text$mn:00000B1F                 push    ecx
.text$mn:00000B20                 mov     [ebp+var_4], ecx
.text$mn:00000B23                 mov     eax, [ebp+var_4]
.text$mn:00000B26                 mov     esp, ebp
.text$mn:00000B28                 pop     ebp
.text$mn:00000B29                 retn
.text$mn:00000B29 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00000B29
.text$mn:00000B29 ; ---------------------------------------------------------------------------
.text$mn:00000B2A                 align 4
.text$mn:00000B2A _text$mn        ends
.text$mn:00000B2A
.text$mn:00000B2C ; ===========================================================================
.text$mn:00000B2C
.text$mn:00000B2C ; Segment type: Pure code
.text$mn:00000B2C ; Segment permissions: Read/Execute
.text$mn:00000B2C _text$mn        segment para public 'CODE' use32
.text$mn:00000B2C                 assume cs:_text$mn
.text$mn:00000B2C                 ;org 0B2Ch
.text$mn:00000B2C ; COMDAT (pick any)
.text$mn:00000B2C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000B2C
.text$mn:00000B2C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B2C
.text$mn:00000B2C ; Attributes: bp-based frame
.text$mn:00000B2C
.text$mn:00000B2C ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00000B2C                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00000B2C ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00000B2C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00000B2C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:00000B2C
.text$mn:00000B2C var_4           = dword ptr -4
.text$mn:00000B2C
.text$mn:00000B2C                 push    ebp
.text$mn:00000B2D                 mov     ebp, esp
.text$mn:00000B2F                 push    ecx
.text$mn:00000B30                 mov     [ebp+var_4], ecx
.text$mn:00000B33                 mov     eax, [ebp+var_4]
.text$mn:00000B36                 mov     esp, ebp
.text$mn:00000B38                 pop     ebp
.text$mn:00000B39                 retn
.text$mn:00000B39 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00000B39
.text$mn:00000B39 ; ---------------------------------------------------------------------------
.text$mn:00000B3A                 align 4
.text$mn:00000B3A _text$mn        ends
.text$mn:00000B3A
.text$mn:00000B3C ; ===========================================================================
.text$mn:00000B3C
.text$mn:00000B3C ; Segment type: Pure code
.text$mn:00000B3C ; Segment permissions: Read/Execute
.text$mn:00000B3C _text$mn        segment para public 'CODE' use32
.text$mn:00000B3C                 assume cs:_text$mn
.text$mn:00000B3C                 ;org 0B3Ch
.text$mn:00000B3C ; COMDAT (pick any)
.text$mn:00000B3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000B3C
.text$mn:00000B3C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B3C
.text$mn:00000B3C ; Attributes: bp-based frame
.text$mn:00000B3C
.text$mn:00000B3C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00000B3C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000B3C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00000B3C                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00000B3C                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00000B3C
.text$mn:00000B3C var_14          = dword ptr -14h
.text$mn:00000B3C var_D           = byte ptr -0Dh
.text$mn:00000B3C var_C           = dword ptr -0Ch
.text$mn:00000B3C var_4           = dword ptr -4
.text$mn:00000B3C Str             = dword ptr  8
.text$mn:00000B3C
.text$mn:00000B3C                 push    ebp
.text$mn:00000B3D                 mov     ebp, esp
.text$mn:00000B3F                 push    0FFFFFFFFh
.text$mn:00000B41                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000B46                 mov     eax, large fs:0
.text$mn:00000B4C                 push    eax
.text$mn:00000B4D                 sub     esp, 8
.text$mn:00000B50                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000B55                 xor     eax, ebp
.text$mn:00000B57                 push    eax
.text$mn:00000B58                 lea     eax, [ebp+var_C]
.text$mn:00000B5B                 mov     large fs:0, eax
.text$mn:00000B61                 mov     [ebp+var_14], ecx
.text$mn:00000B64                 lea     ecx, [ebp+var_D]
.text$mn:00000B67                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000B6C                 push    eax
.text$mn:00000B6D                 mov     ecx, [ebp+var_14]
.text$mn:00000B70                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00000B75                 mov     [ebp+var_4], 0
.text$mn:00000B7C                 push    0               ; Size
.text$mn:00000B7E                 push    0               ; char
.text$mn:00000B80                 mov     ecx, [ebp+var_14]
.text$mn:00000B83                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000B88                 mov     eax, [ebp+Str]
.text$mn:00000B8B                 push    eax             ; Str
.text$mn:00000B8C                 mov     ecx, [ebp+var_14]
.text$mn:00000B8F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00000B94                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B9B                 mov     eax, [ebp+var_14]
.text$mn:00000B9E                 mov     ecx, [ebp+var_C]
.text$mn:00000BA1                 mov     large fs:0, ecx
.text$mn:00000BA8                 pop     ecx
.text$mn:00000BA9                 mov     esp, ebp
.text$mn:00000BAB                 pop     ebp
.text$mn:00000BAC                 retn    4
.text$mn:00000BAC ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00000BAC
.text$mn:00000BAC ; ---------------------------------------------------------------------------
.text$mn:00000BAF                 align 10h
.text$mn:00000BAF _text$mn        ends
.text$mn:00000BAF
.text$x:00000BB0 ; ===========================================================================
.text$x:00000BB0
.text$x:00000BB0 ; Segment type: Pure code
.text$x:00000BB0 ; Segment permissions: Read/Execute
.text$x:00000BB0 _text$x         segment para public 'CODE' use32
.text$x:00000BB0                 assume cs:_text$x
.text$x:00000BB0                 ;org 0BB0h
.text$x:00000BB0 ; COMDAT (pick associative to section at B3C)
.text$x:00000BB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000BB0
.text$x:00000BB0 ; =============== S U B R O U T I N E =======================================
.text$x:00000BB0
.text$x:00000BB0
.text$x:00000BB0 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00000BB0                                         ; DATA XREF: .xdata$x:00002290o
.text$x:00000BB0                 mov     ecx, [ebp-14h]
.text$x:00000BB3                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000BB3 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00000BB3
.text$x:00000BB8
.text$x:00000BB8 ; =============== S U B R O U T I N E =======================================
.text$x:00000BB8
.text$x:00000BB8
.text$x:00000BB8 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00000BB8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00000BB8
.text$x:00000BB8 arg_4           = dword ptr  8
.text$x:00000BB8
.text$x:00000BB8                 mov     edx, [esp+arg_4]
.text$x:00000BBC                 lea     eax, [edx+0Ch]
.text$x:00000BBF                 mov     ecx, [edx-0Ch]
.text$x:00000BC2                 xor     ecx, eax
.text$x:00000BC4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000BC9                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00000BCE                 jmp     ___CxxFrameHandler3
.text$x:00000BCE __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00000BCE
.text$x:00000BCE ; ---------------------------------------------------------------------------
.text$x:00000BD3                 align 4
.text$x:00000BD3 _text$x         ends
.text$x:00000BD3
.text$mn:00000BD4 ; ===========================================================================
.text$mn:00000BD4
.text$mn:00000BD4 ; Segment type: Pure code
.text$mn:00000BD4 ; Segment permissions: Read/Execute
.text$mn:00000BD4 _text$mn        segment para public 'CODE' use32
.text$mn:00000BD4                 assume cs:_text$mn
.text$mn:00000BD4                 ;org 0BD4h
.text$mn:00000BD4 ; COMDAT (pick any)
.text$mn:00000BD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000BD4
.text$mn:00000BD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BD4
.text$mn:00000BD4 ; Attributes: bp-based frame
.text$mn:00000BD4
.text$mn:00000BD4 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000BD4                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00000BD4 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00000BD4                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00000BD4
.text$mn:00000BD4 var_4           = dword ptr -4
.text$mn:00000BD4
.text$mn:00000BD4                 push    ebp
.text$mn:00000BD5                 mov     ebp, esp
.text$mn:00000BD7                 push    ecx
.text$mn:00000BD8                 mov     [ebp+var_4], ecx
.text$mn:00000BDB                 mov     eax, [ebp+var_4]
.text$mn:00000BDE                 mov     dword ptr [eax], 0
.text$mn:00000BE4                 mov     eax, [ebp+var_4]
.text$mn:00000BE7                 mov     esp, ebp
.text$mn:00000BE9                 pop     ebp
.text$mn:00000BEA                 retn
.text$mn:00000BEA ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00000BEA
.text$mn:00000BEA ; ---------------------------------------------------------------------------
.text$mn:00000BEB                 align 4
.text$mn:00000BEB _text$mn        ends
.text$mn:00000BEB
.text$mn:00000BEC ; ===========================================================================
.text$mn:00000BEC
.text$mn:00000BEC ; Segment type: Pure code
.text$mn:00000BEC ; Segment permissions: Read/Execute
.text$mn:00000BEC _text$mn        segment para public 'CODE' use32
.text$mn:00000BEC                 assume cs:_text$mn
.text$mn:00000BEC                 ;org 0BECh
.text$mn:00000BEC ; COMDAT (pick any)
.text$mn:00000BEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000BEC
.text$mn:00000BEC ; =============== S U B R O U T I N E =======================================
.text$mn:00000BEC
.text$mn:00000BEC ; Attributes: bp-based frame
.text$mn:00000BEC
.text$mn:00000BEC ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00000BEC                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00000BEC ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00000BEC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00000BEC
.text$mn:00000BEC var_4           = dword ptr -4
.text$mn:00000BEC
.text$mn:00000BEC                 push    ebp
.text$mn:00000BED                 mov     ebp, esp
.text$mn:00000BEF                 push    ecx
.text$mn:00000BF0                 mov     [ebp+var_4], ecx
.text$mn:00000BF3                 mov     eax, [ebp+var_4]
.text$mn:00000BF6                 mov     dword ptr [eax], 0
.text$mn:00000BFC                 mov     ecx, [ebp+var_4]
.text$mn:00000BFF                 mov     dword ptr [ecx+4], 0
.text$mn:00000C06                 mov     eax, [ebp+var_4]
.text$mn:00000C09                 mov     esp, ebp
.text$mn:00000C0B                 pop     ebp
.text$mn:00000C0C                 retn
.text$mn:00000C0C ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00000C0C
.text$mn:00000C0C ; ---------------------------------------------------------------------------
.text$mn:00000C0D                 align 10h
.text$mn:00000C0D _text$mn        ends
.text$mn:00000C0D
.text$mn:00000C10 ; ===========================================================================
.text$mn:00000C10
.text$mn:00000C10 ; Segment type: Pure code
.text$mn:00000C10 ; Segment permissions: Read/Execute
.text$mn:00000C10 _text$mn        segment para public 'CODE' use32
.text$mn:00000C10                 assume cs:_text$mn
.text$mn:00000C10                 ;org 0C10h
.text$mn:00000C10 ; COMDAT (pick any)
.text$mn:00000C10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000C10
.text$mn:00000C10 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C10
.text$mn:00000C10 ; Attributes: bp-based frame
.text$mn:00000C10
.text$mn:00000C10 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000C10                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000C10 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00000C10                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00000C10                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00000C10
.text$mn:00000C10 var_10          = dword ptr -10h
.text$mn:00000C10 var_C           = dword ptr -0Ch
.text$mn:00000C10 var_4           = dword ptr -4
.text$mn:00000C10
.text$mn:00000C10                 push    ebp
.text$mn:00000C11                 mov     ebp, esp
.text$mn:00000C13                 push    0FFFFFFFFh
.text$mn:00000C15                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000C1A                 mov     eax, large fs:0
.text$mn:00000C20                 push    eax
.text$mn:00000C21                 push    ecx
.text$mn:00000C22                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C27                 xor     eax, ebp
.text$mn:00000C29                 push    eax
.text$mn:00000C2A                 lea     eax, [ebp+var_C]
.text$mn:00000C2D                 mov     large fs:0, eax
.text$mn:00000C33                 mov     [ebp+var_10], ecx
.text$mn:00000C36                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000C39                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00000C3E                 mov     [ebp+var_4], 0
.text$mn:00000C45                 mov     eax, [ebp+var_10]
.text$mn:00000C48                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00000C4E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C55                 mov     eax, [ebp+var_10]
.text$mn:00000C58                 mov     ecx, [ebp+var_C]
.text$mn:00000C5B                 mov     large fs:0, ecx
.text$mn:00000C62                 pop     ecx
.text$mn:00000C63                 mov     esp, ebp
.text$mn:00000C65                 pop     ebp
.text$mn:00000C66                 retn
.text$mn:00000C66 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00000C66
.text$mn:00000C66 ; ---------------------------------------------------------------------------
.text$mn:00000C67                 align 4
.text$mn:00000C67 _text$mn        ends
.text$mn:00000C67
.text$x:00000C68 ; ===========================================================================
.text$x:00000C68
.text$x:00000C68 ; Segment type: Pure code
.text$x:00000C68 ; Segment permissions: Read/Execute
.text$x:00000C68 _text$x         segment para public 'CODE' use32
.text$x:00000C68                 assume cs:_text$x
.text$x:00000C68                 ;org 0C68h
.text$x:00000C68 ; COMDAT (pick associative to section at C10)
.text$x:00000C68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000C68
.text$x:00000C68 ; =============== S U B R O U T I N E =======================================
.text$x:00000C68
.text$x:00000C68
.text$x:00000C68 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00000C68                                         ; DATA XREF: .xdata$x:000023F8o
.text$x:00000C68                 mov     ecx, [ebp-10h]  ; this
.text$x:00000C6B                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000C6B __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00000C6B
.text$x:00000C70
.text$x:00000C70 ; =============== S U B R O U T I N E =======================================
.text$x:00000C70
.text$x:00000C70
.text$x:00000C70 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00000C70                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00000C70
.text$x:00000C70 arg_4           = dword ptr  8
.text$x:00000C70
.text$x:00000C70                 mov     edx, [esp+arg_4]
.text$x:00000C74                 lea     eax, [edx+0Ch]
.text$x:00000C77                 mov     ecx, [edx-8]
.text$x:00000C7A                 xor     ecx, eax
.text$x:00000C7C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C81                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00000C86                 jmp     ___CxxFrameHandler3
.text$x:00000C86 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00000C86
.text$x:00000C86 ; ---------------------------------------------------------------------------
.text$x:00000C8B                 align 4
.text$x:00000C8B _text$x         ends
.text$x:00000C8B
.text$mn:00000C8C ; ===========================================================================
.text$mn:00000C8C
.text$mn:00000C8C ; Segment type: Pure code
.text$mn:00000C8C ; Segment permissions: Read/Execute
.text$mn:00000C8C _text$mn        segment para public 'CODE' use32
.text$mn:00000C8C                 assume cs:_text$mn
.text$mn:00000C8C                 ;org 0C8Ch
.text$mn:00000C8C ; COMDAT (pick any)
.text$mn:00000C8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000C8C
.text$mn:00000C8C ; =============== S U B R O U T I N E =======================================
.text$mn:00000C8C
.text$mn:00000C8C ; Attributes: bp-based frame
.text$mn:00000C8C
.text$mn:00000C8C ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000C8C                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000C8C ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00000C8C                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000C8C
.text$mn:00000C8C var_10          = dword ptr -10h
.text$mn:00000C8C var_C           = dword ptr -0Ch
.text$mn:00000C8C var_4           = dword ptr -4
.text$mn:00000C8C
.text$mn:00000C8C                 push    ebp
.text$mn:00000C8D                 mov     ebp, esp
.text$mn:00000C8F                 push    0FFFFFFFFh
.text$mn:00000C91                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000C96                 mov     eax, large fs:0
.text$mn:00000C9C                 push    eax
.text$mn:00000C9D                 push    ecx
.text$mn:00000C9E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000CA3                 xor     eax, ebp
.text$mn:00000CA5                 push    eax
.text$mn:00000CA6                 lea     eax, [ebp+var_C]
.text$mn:00000CA9                 mov     large fs:0, eax
.text$mn:00000CAF                 mov     [ebp+var_10], ecx
.text$mn:00000CB2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000CB5                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000CBA                 mov     [ebp+var_4], 0
.text$mn:00000CC1                 mov     eax, [ebp+var_10]
.text$mn:00000CC4                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00000CCA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000CD1                 mov     eax, [ebp+var_10]
.text$mn:00000CD4                 mov     ecx, [ebp+var_C]
.text$mn:00000CD7                 mov     large fs:0, ecx
.text$mn:00000CDE                 pop     ecx
.text$mn:00000CDF                 mov     esp, ebp
.text$mn:00000CE1                 pop     ebp
.text$mn:00000CE2                 retn
.text$mn:00000CE2 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00000CE2
.text$mn:00000CE2 ; ---------------------------------------------------------------------------
.text$mn:00000CE3                 align 4
.text$mn:00000CE3 _text$mn        ends
.text$mn:00000CE3
.text$x:00000CE4 ; ===========================================================================
.text$x:00000CE4
.text$x:00000CE4 ; Segment type: Pure code
.text$x:00000CE4 ; Segment permissions: Read/Execute
.text$x:00000CE4 _text$x         segment para public 'CODE' use32
.text$x:00000CE4                 assume cs:_text$x
.text$x:00000CE4                 ;org 0CE4h
.text$x:00000CE4 ; COMDAT (pick associative to section at C8C)
.text$x:00000CE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000CE4
.text$x:00000CE4 ; =============== S U B R O U T I N E =======================================
.text$x:00000CE4
.text$x:00000CE4
.text$x:00000CE4 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00000CE4                                         ; DATA XREF: .xdata$x:0000247Co
.text$x:00000CE4                 mov     ecx, [ebp-10h]  ; this
.text$x:00000CE7                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000CE7 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00000CE7
.text$x:00000CEC
.text$x:00000CEC ; =============== S U B R O U T I N E =======================================
.text$x:00000CEC
.text$x:00000CEC
.text$x:00000CEC __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00000CEC                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00000CEC
.text$x:00000CEC arg_4           = dword ptr  8
.text$x:00000CEC
.text$x:00000CEC                 mov     edx, [esp+arg_4]
.text$x:00000CF0                 lea     eax, [edx+0Ch]
.text$x:00000CF3                 mov     ecx, [edx-8]
.text$x:00000CF6                 xor     ecx, eax
.text$x:00000CF8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000CFD                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00000D02                 jmp     ___CxxFrameHandler3
.text$x:00000D02 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00000D02
.text$x:00000D02 ; ---------------------------------------------------------------------------
.text$x:00000D07                 align 4
.text$x:00000D07 _text$x         ends
.text$x:00000D07
.text$mn:00000D08 ; ===========================================================================
.text$mn:00000D08
.text$mn:00000D08 ; Segment type: Pure code
.text$mn:00000D08 ; Segment permissions: Read/Execute
.text$mn:00000D08 _text$mn        segment para public 'CODE' use32
.text$mn:00000D08                 assume cs:_text$mn
.text$mn:00000D08                 ;org 0D08h
.text$mn:00000D08 ; COMDAT (pick any)
.text$mn:00000D08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000D08
.text$mn:00000D08 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D08
.text$mn:00000D08 ; Attributes: bp-based frame
.text$mn:00000D08
.text$mn:00000D08 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000D08                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00000D08 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00000D08                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000D08
.text$mn:00000D08 var_10          = dword ptr -10h
.text$mn:00000D08 var_C           = dword ptr -0Ch
.text$mn:00000D08 var_4           = dword ptr -4
.text$mn:00000D08
.text$mn:00000D08                 push    ebp
.text$mn:00000D09                 mov     ebp, esp
.text$mn:00000D0B                 push    0FFFFFFFFh
.text$mn:00000D0D                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00000D12                 mov     eax, large fs:0
.text$mn:00000D18                 push    eax
.text$mn:00000D19                 push    ecx
.text$mn:00000D1A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000D1F                 xor     eax, ebp
.text$mn:00000D21                 push    eax
.text$mn:00000D22                 lea     eax, [ebp+var_C]
.text$mn:00000D25                 mov     large fs:0, eax
.text$mn:00000D2B                 mov     [ebp+var_10], ecx
.text$mn:00000D2E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000D31                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000D36                 mov     [ebp+var_4], 0
.text$mn:00000D3D                 mov     eax, [ebp+var_10]
.text$mn:00000D40                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00000D46                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000D4D                 mov     eax, [ebp+var_10]
.text$mn:00000D50                 mov     ecx, [ebp+var_C]
.text$mn:00000D53                 mov     large fs:0, ecx
.text$mn:00000D5A                 pop     ecx
.text$mn:00000D5B                 mov     esp, ebp
.text$mn:00000D5D                 pop     ebp
.text$mn:00000D5E                 retn
.text$mn:00000D5E ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00000D5E
.text$mn:00000D5E ; ---------------------------------------------------------------------------
.text$mn:00000D5F                 align 10h
.text$mn:00000D5F _text$mn        ends
.text$mn:00000D5F
.text$x:00000D60 ; ===========================================================================
.text$x:00000D60
.text$x:00000D60 ; Segment type: Pure code
.text$x:00000D60 ; Segment permissions: Read/Execute
.text$x:00000D60 _text$x         segment para public 'CODE' use32
.text$x:00000D60                 assume cs:_text$x
.text$x:00000D60                 ;org 0D60h
.text$x:00000D60 ; COMDAT (pick associative to section at D08)
.text$x:00000D60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000D60
.text$x:00000D60 ; =============== S U B R O U T I N E =======================================
.text$x:00000D60
.text$x:00000D60
.text$x:00000D60 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00000D60                                         ; DATA XREF: .xdata$x:00002500o
.text$x:00000D60                 mov     ecx, [ebp-10h]  ; this
.text$x:00000D63                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000D63 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00000D63
.text$x:00000D68
.text$x:00000D68 ; =============== S U B R O U T I N E =======================================
.text$x:00000D68
.text$x:00000D68
.text$x:00000D68 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00000D68                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00000D68
.text$x:00000D68 arg_4           = dword ptr  8
.text$x:00000D68
.text$x:00000D68                 mov     edx, [esp+arg_4]
.text$x:00000D6C                 lea     eax, [edx+0Ch]
.text$x:00000D6F                 mov     ecx, [edx-8]
.text$x:00000D72                 xor     ecx, eax
.text$x:00000D74                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000D79                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00000D7E                 jmp     ___CxxFrameHandler3
.text$x:00000D7E __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00000D7E
.text$x:00000D7E ; ---------------------------------------------------------------------------
.text$x:00000D83                 align 4
.text$x:00000D83 _text$x         ends
.text$x:00000D83
.text$mn:00000D84 ; ===========================================================================
.text$mn:00000D84
.text$mn:00000D84 ; Segment type: Pure code
.text$mn:00000D84 ; Segment permissions: Read/Execute
.text$mn:00000D84 _text$mn        segment para public 'CODE' use32
.text$mn:00000D84                 assume cs:_text$mn
.text$mn:00000D84                 ;org 0D84h
.text$mn:00000D84 ; COMDAT (pick any)
.text$mn:00000D84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000D84
.text$mn:00000D84 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D84
.text$mn:00000D84 ; Attributes: bp-based frame
.text$mn:00000D84
.text$mn:00000D84 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00000D84                 public ??0error_category@std@@QAE@XZ
.text$mn:00000D84 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00000D84
.text$mn:00000D84 var_4           = dword ptr -4
.text$mn:00000D84
.text$mn:00000D84                 push    ebp
.text$mn:00000D85                 mov     ebp, esp
.text$mn:00000D87                 push    ecx
.text$mn:00000D88                 mov     [ebp+var_4], ecx
.text$mn:00000D8B                 mov     eax, [ebp+var_4]
.text$mn:00000D8E                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000D94                 mov     eax, [ebp+var_4]
.text$mn:00000D97                 mov     esp, ebp
.text$mn:00000D99                 pop     ebp
.text$mn:00000D9A                 retn
.text$mn:00000D9A ??0error_category@std@@QAE@XZ endp
.text$mn:00000D9A
.text$mn:00000D9A ; ---------------------------------------------------------------------------
.text$mn:00000D9B                 align 4
.text$mn:00000D9B _text$mn        ends
.text$mn:00000D9B
.text$mn:00000D9C ; ===========================================================================
.text$mn:00000D9C
.text$mn:00000D9C ; Segment type: Pure code
.text$mn:00000D9C ; Segment permissions: Read/Execute
.text$mn:00000D9C _text$mn        segment para public 'CODE' use32
.text$mn:00000D9C                 assume cs:_text$mn
.text$mn:00000D9C                 ;org 0D9Ch
.text$mn:00000D9C ; COMDAT (pick any)
.text$mn:00000D9C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000D9C
.text$mn:00000D9C ; =============== S U B R O U T I N E =======================================
.text$mn:00000D9C
.text$mn:00000D9C ; Attributes: bp-based frame
.text$mn:00000D9C
.text$mn:00000D9C ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00000D9C                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00000D9C ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00000D9C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00000D9C                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00000D9C
.text$mn:00000D9C var_4           = dword ptr -4
.text$mn:00000D9C arg_0           = dword ptr  8
.text$mn:00000D9C arg_4           = dword ptr  0Ch
.text$mn:00000D9C
.text$mn:00000D9C                 push    ebp
.text$mn:00000D9D                 mov     ebp, esp
.text$mn:00000D9F                 push    ecx
.text$mn:00000DA0                 mov     [ebp+var_4], ecx
.text$mn:00000DA3                 mov     eax, [ebp+var_4]
.text$mn:00000DA6                 mov     ecx, [ebp+arg_0]
.text$mn:00000DA9                 mov     [eax], ecx
.text$mn:00000DAB                 mov     edx, [ebp+var_4]
.text$mn:00000DAE                 mov     eax, [ebp+arg_4]
.text$mn:00000DB1                 mov     [edx+4], eax
.text$mn:00000DB4                 mov     eax, [ebp+var_4]
.text$mn:00000DB7                 mov     esp, ebp
.text$mn:00000DB9                 pop     ebp
.text$mn:00000DBA                 retn    8
.text$mn:00000DBA ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00000DBA
.text$mn:00000DBA ; ---------------------------------------------------------------------------
.text$mn:00000DBD                 align 10h
.text$mn:00000DBD _text$mn        ends
.text$mn:00000DBD
.text$mn:00000DC0 ; ===========================================================================
.text$mn:00000DC0
.text$mn:00000DC0 ; Segment type: Pure code
.text$mn:00000DC0 ; Segment permissions: Read/Execute
.text$mn:00000DC0 _text$mn        segment para public 'CODE' use32
.text$mn:00000DC0                 assume cs:_text$mn
.text$mn:00000DC0                 ;org 0DC0h
.text$mn:00000DC0 ; COMDAT (pick any)
.text$mn:00000DC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000DC0
.text$mn:00000DC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DC0
.text$mn:00000DC0 ; Attributes: bp-based frame
.text$mn:00000DC0
.text$mn:00000DC0 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:00000DC0                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00000DC0 ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:00000DC0                                         ; DATA XREF: .xdata$x:0000263Co
.text$mn:00000DC0
.text$mn:00000DC0 var_10          = dword ptr -10h
.text$mn:00000DC0 var_C           = dword ptr -0Ch
.text$mn:00000DC0 var_4           = dword ptr -4
.text$mn:00000DC0 arg_0           = dword ptr  8
.text$mn:00000DC0
.text$mn:00000DC0                 push    ebp
.text$mn:00000DC1                 mov     ebp, esp
.text$mn:00000DC3                 push    0FFFFFFFFh
.text$mn:00000DC5                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00000DCA                 mov     eax, large fs:0
.text$mn:00000DD0                 push    eax
.text$mn:00000DD1                 push    ecx
.text$mn:00000DD2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000DD7                 xor     eax, ebp
.text$mn:00000DD9                 push    eax
.text$mn:00000DDA                 lea     eax, [ebp+var_C]
.text$mn:00000DDD                 mov     large fs:0, eax
.text$mn:00000DE3                 mov     [ebp+var_10], ecx
.text$mn:00000DE6                 mov     eax, [ebp+arg_0]
.text$mn:00000DE9                 push    eax             ; struct std::exception *
.text$mn:00000DEA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000DED                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:00000DF2                 mov     [ebp+var_4], 0
.text$mn:00000DF9                 mov     ecx, [ebp+var_10]
.text$mn:00000DFC                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00000E02                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E09                 mov     eax, [ebp+var_10]
.text$mn:00000E0C                 mov     ecx, [ebp+var_C]
.text$mn:00000E0F                 mov     large fs:0, ecx
.text$mn:00000E16                 pop     ecx
.text$mn:00000E17                 mov     esp, ebp
.text$mn:00000E19                 pop     ebp
.text$mn:00000E1A                 retn    4
.text$mn:00000E1A ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:00000E1A
.text$mn:00000E1A ; ---------------------------------------------------------------------------
.text$mn:00000E1D                 align 10h
.text$mn:00000E1D _text$mn        ends
.text$mn:00000E1D
.text$x:00000E20 ; ===========================================================================
.text$x:00000E20
.text$x:00000E20 ; Segment type: Pure code
.text$x:00000E20 ; Segment permissions: Read/Execute
.text$x:00000E20 _text$x         segment para public 'CODE' use32
.text$x:00000E20                 assume cs:_text$x
.text$x:00000E20                 ;org 0E20h
.text$x:00000E20 ; COMDAT (pick associative to section at DC0)
.text$x:00000E20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000E20
.text$x:00000E20 ; =============== S U B R O U T I N E =======================================
.text$x:00000E20
.text$x:00000E20
.text$x:00000E20 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:00000E20                                         ; DATA XREF: .xdata$x:000023CCo
.text$x:00000E20                 mov     ecx, [ebp-10h]  ; this
.text$x:00000E23                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00000E23 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:00000E23
.text$x:00000E28
.text$x:00000E28 ; =============== S U B R O U T I N E =======================================
.text$x:00000E28
.text$x:00000E28
.text$x:00000E28 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:00000E28                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:00000E28
.text$x:00000E28 arg_4           = dword ptr  8
.text$x:00000E28
.text$x:00000E28                 mov     edx, [esp+arg_4]
.text$x:00000E2C                 lea     eax, [edx+0Ch]
.text$x:00000E2F                 mov     ecx, [edx-8]
.text$x:00000E32                 xor     ecx, eax
.text$x:00000E34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E39                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:00000E3E                 jmp     ___CxxFrameHandler3
.text$x:00000E3E __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:00000E3E
.text$x:00000E3E ; ---------------------------------------------------------------------------
.text$x:00000E43                 align 4
.text$x:00000E43 _text$x         ends
.text$x:00000E43
.text$mn:00000E44 ; ===========================================================================
.text$mn:00000E44
.text$mn:00000E44 ; Segment type: Pure code
.text$mn:00000E44 ; Segment permissions: Read/Execute
.text$mn:00000E44 _text$mn        segment para public 'CODE' use32
.text$mn:00000E44                 assume cs:_text$mn
.text$mn:00000E44                 ;org 0E44h
.text$mn:00000E44 ; COMDAT (pick any)
.text$mn:00000E44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000E44
.text$mn:00000E44 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E44
.text$mn:00000E44 ; Attributes: bp-based frame
.text$mn:00000E44
.text$mn:00000E44 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:00000E44                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:00000E44 ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:00000E44                                         ; CODE XREF: ColourPopup::create(int)+42p
.text$mn:00000E44
.text$mn:00000E44 var_10          = dword ptr -10h
.text$mn:00000E44 var_C           = dword ptr -0Ch
.text$mn:00000E44 var_4           = dword ptr -4
.text$mn:00000E44 arg_0           = dword ptr  8
.text$mn:00000E44
.text$mn:00000E44                 push    ebp
.text$mn:00000E45                 mov     ebp, esp
.text$mn:00000E47                 push    0FFFFFFFFh
.text$mn:00000E49                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:00000E4E                 mov     eax, large fs:0
.text$mn:00000E54                 push    eax
.text$mn:00000E55                 push    ecx
.text$mn:00000E56                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000E5B                 xor     eax, ebp
.text$mn:00000E5D                 push    eax
.text$mn:00000E5E                 lea     eax, [ebp+var_C]
.text$mn:00000E61                 mov     large fs:0, eax
.text$mn:00000E67                 mov     [ebp+var_10], ecx
.text$mn:00000E6A                 lea     eax, [ebp+arg_0]
.text$mn:00000E6D                 push    eax             ; char **
.text$mn:00000E6E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000E71                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:00000E76                 mov     [ebp+var_4], 0
.text$mn:00000E7D                 mov     ecx, [ebp+var_10]
.text$mn:00000E80                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00000E86                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E8D                 mov     eax, [ebp+var_10]
.text$mn:00000E90                 mov     ecx, [ebp+var_C]
.text$mn:00000E93                 mov     large fs:0, ecx
.text$mn:00000E9A                 pop     ecx
.text$mn:00000E9B                 mov     esp, ebp
.text$mn:00000E9D                 pop     ebp
.text$mn:00000E9E                 retn    4
.text$mn:00000E9E ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:00000E9E
.text$mn:00000E9E ; ---------------------------------------------------------------------------
.text$mn:00000EA1                 align 4
.text$mn:00000EA1 _text$mn        ends
.text$mn:00000EA1
.text$x:00000EA4 ; ===========================================================================
.text$x:00000EA4
.text$x:00000EA4 ; Segment type: Pure code
.text$x:00000EA4 ; Segment permissions: Read/Execute
.text$x:00000EA4 _text$x         segment para public 'CODE' use32
.text$x:00000EA4                 assume cs:_text$x
.text$x:00000EA4                 ;org 0EA4h
.text$x:00000EA4 ; COMDAT (pick associative to section at E44)
.text$x:00000EA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000EA4
.text$x:00000EA4 ; =============== S U B R O U T I N E =======================================
.text$x:00000EA4
.text$x:00000EA4
.text$x:00000EA4 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:00000EA4                                         ; DATA XREF: .xdata$x:00002374o
.text$x:00000EA4                 mov     ecx, [ebp-10h]  ; this
.text$x:00000EA7                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00000EA7 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:00000EA7
.text$x:00000EAC
.text$x:00000EAC ; =============== S U B R O U T I N E =======================================
.text$x:00000EAC
.text$x:00000EAC
.text$x:00000EAC __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:00000EAC                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:00000EAC
.text$x:00000EAC arg_4           = dword ptr  8
.text$x:00000EAC
.text$x:00000EAC                 mov     edx, [esp+arg_4]
.text$x:00000EB0                 lea     eax, [edx+0Ch]
.text$x:00000EB3                 mov     ecx, [edx-8]
.text$x:00000EB6                 xor     ecx, eax
.text$x:00000EB8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000EBD                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:00000EC2                 jmp     ___CxxFrameHandler3
.text$x:00000EC2 __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:00000EC2
.text$x:00000EC2 ; ---------------------------------------------------------------------------
.text$x:00000EC7                 align 4
.text$x:00000EC7 _text$x         ends
.text$x:00000EC7
.text$mn:00000EC8 ; ===========================================================================
.text$mn:00000EC8
.text$mn:00000EC8 ; Segment type: Pure code
.text$mn:00000EC8 ; Segment permissions: Read/Execute
.text$mn:00000EC8 _text$mn        segment para public 'CODE' use32
.text$mn:00000EC8                 assume cs:_text$mn
.text$mn:00000EC8                 ;org 0EC8h
.text$mn:00000EC8 ; COMDAT (pick any)
.text$mn:00000EC8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000EC8
.text$mn:00000EC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EC8
.text$mn:00000EC8 ; Attributes: bp-based frame
.text$mn:00000EC8
.text$mn:00000EC8 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00000EC8                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000EC8 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00000EC8                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00000EC8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00000EC8
.text$mn:00000EC8 var_10          = dword ptr -10h
.text$mn:00000EC8 var_C           = dword ptr -0Ch
.text$mn:00000EC8 var_4           = dword ptr -4
.text$mn:00000EC8
.text$mn:00000EC8                 push    ebp
.text$mn:00000EC9                 mov     ebp, esp
.text$mn:00000ECB                 push    0FFFFFFFFh
.text$mn:00000ECD                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000ED2                 mov     eax, large fs:0
.text$mn:00000ED8                 push    eax
.text$mn:00000ED9                 push    ecx
.text$mn:00000EDA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000EDF                 xor     eax, ebp
.text$mn:00000EE1                 push    eax
.text$mn:00000EE2                 lea     eax, [ebp+var_C]
.text$mn:00000EE5                 mov     large fs:0, eax
.text$mn:00000EEB                 mov     [ebp+var_10], ecx
.text$mn:00000EEE                 mov     [ebp+var_4], 0
.text$mn:00000EF5                 mov     ecx, [ebp+var_10]
.text$mn:00000EF8                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00000EFD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F04                 mov     ecx, [ebp+var_10]
.text$mn:00000F07                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00000F0C                 mov     ecx, [ebp+var_C]
.text$mn:00000F0F                 mov     large fs:0, ecx
.text$mn:00000F16                 pop     ecx
.text$mn:00000F17                 mov     esp, ebp
.text$mn:00000F19                 pop     ebp
.text$mn:00000F1A                 retn
.text$mn:00000F1A ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00000F1A
.text$mn:00000F1A ; ---------------------------------------------------------------------------
.text$mn:00000F1B                 align 4
.text$mn:00000F1B _text$mn        ends
.text$mn:00000F1B
.text$x:00000F1C ; ===========================================================================
.text$x:00000F1C
.text$x:00000F1C ; Segment type: Pure code
.text$x:00000F1C ; Segment permissions: Read/Execute
.text$x:00000F1C _text$x         segment para public 'CODE' use32
.text$x:00000F1C                 assume cs:_text$x
.text$x:00000F1C                 ;org 0F1Ch
.text$x:00000F1C ; COMDAT (pick associative to section at EC8)
.text$x:00000F1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000F1C
.text$x:00000F1C ; =============== S U B R O U T I N E =======================================
.text$x:00000F1C
.text$x:00000F1C
.text$x:00000F1C __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00000F1C                                         ; DATA XREF: .xdata$x:00002264o
.text$x:00000F1C                 mov     ecx, [ebp-10h]
.text$x:00000F1F                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000F1F __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00000F1F
.text$x:00000F24
.text$x:00000F24 ; =============== S U B R O U T I N E =======================================
.text$x:00000F24
.text$x:00000F24
.text$x:00000F24 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00000F24                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00000F24
.text$x:00000F24 arg_4           = dword ptr  8
.text$x:00000F24
.text$x:00000F24                 mov     edx, [esp+arg_4]
.text$x:00000F28                 lea     eax, [edx+0Ch]
.text$x:00000F2B                 mov     ecx, [edx-8]
.text$x:00000F2E                 xor     ecx, eax
.text$x:00000F30                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F35                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00000F3A                 jmp     ___CxxFrameHandler3
.text$x:00000F3A __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00000F3A
.text$x:00000F3A ; ---------------------------------------------------------------------------
.text$x:00000F3F                 align 10h
.text$x:00000F3F _text$x         ends
.text$x:00000F3F
.text$mn:00000F40 ; ===========================================================================
.text$mn:00000F40
.text$mn:00000F40 ; Segment type: Pure code
.text$mn:00000F40 ; Segment permissions: Read/Execute
.text$mn:00000F40 _text$mn        segment para public 'CODE' use32
.text$mn:00000F40                 assume cs:_text$mn
.text$mn:00000F40                 ;org 0F40h
.text$mn:00000F40 ; COMDAT (pick any)
.text$mn:00000F40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000F40
.text$mn:00000F40 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F40
.text$mn:00000F40 ; Attributes: bp-based frame
.text$mn:00000F40
.text$mn:00000F40 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000F40                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000F40 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000F40                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00000F40                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00000F40
.text$mn:00000F40 var_10          = dword ptr -10h
.text$mn:00000F40 var_C           = dword ptr -0Ch
.text$mn:00000F40 var_4           = dword ptr -4
.text$mn:00000F40
.text$mn:00000F40                 push    ebp
.text$mn:00000F41                 mov     ebp, esp
.text$mn:00000F43                 push    0FFFFFFFFh
.text$mn:00000F45                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000F4A                 mov     eax, large fs:0
.text$mn:00000F50                 push    eax
.text$mn:00000F51                 push    ecx
.text$mn:00000F52                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F57                 xor     eax, ebp
.text$mn:00000F59                 push    eax
.text$mn:00000F5A                 lea     eax, [ebp+var_C]
.text$mn:00000F5D                 mov     large fs:0, eax
.text$mn:00000F63                 mov     [ebp+var_10], ecx
.text$mn:00000F66                 mov     [ebp+var_4], 0
.text$mn:00000F6D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F74                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000F77                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00000F7C                 mov     ecx, [ebp+var_C]
.text$mn:00000F7F                 mov     large fs:0, ecx
.text$mn:00000F86                 pop     ecx
.text$mn:00000F87                 mov     esp, ebp
.text$mn:00000F89                 pop     ebp
.text$mn:00000F8A                 retn
.text$mn:00000F8A ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000F8A
.text$mn:00000F8A ; ---------------------------------------------------------------------------
.text$mn:00000F8B                 align 4
.text$mn:00000F8B _text$mn        ends
.text$mn:00000F8B
.text$x:00000F8C ; ===========================================================================
.text$x:00000F8C
.text$x:00000F8C ; Segment type: Pure code
.text$x:00000F8C ; Segment permissions: Read/Execute
.text$x:00000F8C _text$x         segment para public 'CODE' use32
.text$x:00000F8C                 assume cs:_text$x
.text$x:00000F8C                 ;org 0F8Ch
.text$x:00000F8C ; COMDAT (pick associative to section at F40)
.text$x:00000F8C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00000F8C
.text$x:00000F8C ; =============== S U B R O U T I N E =======================================
.text$x:00000F8C
.text$x:00000F8C
.text$x:00000F8C __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000F8C                                         ; DATA XREF: .xdata$x:0000220Co
.text$x:00000F8C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000F8F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000F8F __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000F8F
.text$x:00000F94
.text$x:00000F94 ; =============== S U B R O U T I N E =======================================
.text$x:00000F94
.text$x:00000F94
.text$x:00000F94 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000F94                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000F94
.text$x:00000F94 arg_4           = dword ptr  8
.text$x:00000F94
.text$x:00000F94                 mov     edx, [esp+arg_4]
.text$x:00000F98                 lea     eax, [edx+0Ch]
.text$x:00000F9B                 mov     ecx, [edx-8]
.text$x:00000F9E                 xor     ecx, eax
.text$x:00000FA0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000FA5                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000FAA                 jmp     ___CxxFrameHandler3
.text$x:00000FAA __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000FAA
.text$x:00000FAA ; ---------------------------------------------------------------------------
.text$x:00000FAF                 align 10h
.text$x:00000FAF _text$x         ends
.text$x:00000FAF
.text$mn:00000FB0 ; ===========================================================================
.text$mn:00000FB0
.text$mn:00000FB0 ; Segment type: Pure code
.text$mn:00000FB0 ; Segment permissions: Read/Execute
.text$mn:00000FB0 _text$mn        segment para public 'CODE' use32
.text$mn:00000FB0                 assume cs:_text$mn
.text$mn:00000FB0                 ;org 0FB0h
.text$mn:00000FB0 ; COMDAT (pick any)
.text$mn:00000FB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000FB0
.text$mn:00000FB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FB0
.text$mn:00000FB0 ; Attributes: bp-based frame
.text$mn:00000FB0
.text$mn:00000FB0 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00000FB0                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000FB0 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00000FB0                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00000FB0                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00000FB0
.text$mn:00000FB0 var_10          = dword ptr -10h
.text$mn:00000FB0 var_C           = dword ptr -0Ch
.text$mn:00000FB0 var_4           = dword ptr -4
.text$mn:00000FB0
.text$mn:00000FB0                 push    ebp
.text$mn:00000FB1                 mov     ebp, esp
.text$mn:00000FB3                 push    0FFFFFFFFh
.text$mn:00000FB5                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000FBA                 mov     eax, large fs:0
.text$mn:00000FC0                 push    eax
.text$mn:00000FC1                 push    ecx
.text$mn:00000FC2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000FC7                 xor     eax, ebp
.text$mn:00000FC9                 push    eax
.text$mn:00000FCA                 lea     eax, [ebp+var_C]
.text$mn:00000FCD                 mov     large fs:0, eax
.text$mn:00000FD3                 mov     [ebp+var_10], ecx
.text$mn:00000FD6                 mov     [ebp+var_4], 0
.text$mn:00000FDD                 push    0               ; Size
.text$mn:00000FDF                 push    1               ; char
.text$mn:00000FE1                 mov     ecx, [ebp+var_10]
.text$mn:00000FE4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000FE9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000FF0                 mov     ecx, [ebp+var_10]
.text$mn:00000FF3                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00000FF8                 mov     ecx, [ebp+var_C]
.text$mn:00000FFB                 mov     large fs:0, ecx
.text$mn:00001002                 pop     ecx
.text$mn:00001003                 mov     esp, ebp
.text$mn:00001005                 pop     ebp
.text$mn:00001006                 retn
.text$mn:00001006 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00001006
.text$mn:00001006 ; ---------------------------------------------------------------------------
.text$mn:00001007                 align 4
.text$mn:00001007 _text$mn        ends
.text$mn:00001007
.text$x:00001008 ; ===========================================================================
.text$x:00001008
.text$x:00001008 ; Segment type: Pure code
.text$x:00001008 ; Segment permissions: Read/Execute
.text$x:00001008 _text$x         segment para public 'CODE' use32
.text$x:00001008                 assume cs:_text$x
.text$x:00001008                 ;org 1008h
.text$x:00001008 ; COMDAT (pick associative to section at FB0)
.text$x:00001008                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001008
.text$x:00001008 ; =============== S U B R O U T I N E =======================================
.text$x:00001008
.text$x:00001008
.text$x:00001008 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00001008                                         ; DATA XREF: .xdata$x:000022BCo
.text$x:00001008                 mov     ecx, [ebp-10h]
.text$x:0000100B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000100B __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000100B
.text$x:00001010
.text$x:00001010 ; =============== S U B R O U T I N E =======================================
.text$x:00001010
.text$x:00001010
.text$x:00001010 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00001010                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00001010
.text$x:00001010 arg_4           = dword ptr  8
.text$x:00001010
.text$x:00001010                 mov     edx, [esp+arg_4]
.text$x:00001014                 lea     eax, [edx+0Ch]
.text$x:00001017                 mov     ecx, [edx-8]
.text$x:0000101A                 xor     ecx, eax
.text$x:0000101C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001021                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00001026                 jmp     ___CxxFrameHandler3
.text$x:00001026 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00001026
.text$x:00001026 ; ---------------------------------------------------------------------------
.text$x:0000102B                 align 4
.text$x:0000102B _text$x         ends
.text$x:0000102B
.text$mn:0000102C ; ===========================================================================
.text$mn:0000102C
.text$mn:0000102C ; Segment type: Pure code
.text$mn:0000102C ; Segment permissions: Read/Execute
.text$mn:0000102C _text$mn        segment para public 'CODE' use32
.text$mn:0000102C                 assume cs:_text$mn
.text$mn:0000102C                 ;org 102Ch
.text$mn:0000102C ; COMDAT (pick any)
.text$mn:0000102C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000102C
.text$mn:0000102C ; =============== S U B R O U T I N E =======================================
.text$mn:0000102C
.text$mn:0000102C ; Attributes: bp-based frame
.text$mn:0000102C
.text$mn:0000102C ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:0000102C                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:0000102C ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:0000102C                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:0000102C                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:0000102C
.text$mn:0000102C var_4           = dword ptr -4
.text$mn:0000102C
.text$mn:0000102C                 push    ebp
.text$mn:0000102D                 mov     ebp, esp
.text$mn:0000102F                 push    ecx
.text$mn:00001030                 mov     [ebp+var_4], ecx
.text$mn:00001033                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001036                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000103B                 mov     esp, ebp
.text$mn:0000103D                 pop     ebp
.text$mn:0000103E                 retn
.text$mn:0000103E ??1_Container_base12@std@@QAE@XZ endp
.text$mn:0000103E
.text$mn:0000103E ; ---------------------------------------------------------------------------
.text$mn:0000103F                 align 10h
.text$mn:0000103F _text$mn        ends
.text$mn:0000103F
.text$mn:00001040 ; ===========================================================================
.text$mn:00001040
.text$mn:00001040 ; Segment type: Pure code
.text$mn:00001040 ; Segment permissions: Read/Execute
.text$mn:00001040 _text$mn        segment para public 'CODE' use32
.text$mn:00001040                 assume cs:_text$mn
.text$mn:00001040                 ;org 1040h
.text$mn:00001040 ; COMDAT (pick any)
.text$mn:00001040                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001040
.text$mn:00001040 ; =============== S U B R O U T I N E =======================================
.text$mn:00001040
.text$mn:00001040 ; Attributes: bp-based frame
.text$mn:00001040
.text$mn:00001040 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001040                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001040 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00001040                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00001040                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00001040
.text$mn:00001040 var_10          = dword ptr -10h
.text$mn:00001040 var_C           = dword ptr -0Ch
.text$mn:00001040 var_4           = dword ptr -4
.text$mn:00001040
.text$mn:00001040                 push    ebp
.text$mn:00001041                 mov     ebp, esp
.text$mn:00001043                 push    0FFFFFFFFh
.text$mn:00001045                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000104A                 mov     eax, large fs:0
.text$mn:00001050                 push    eax
.text$mn:00001051                 push    ecx
.text$mn:00001052                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001057                 xor     eax, ebp
.text$mn:00001059                 push    eax
.text$mn:0000105A                 lea     eax, [ebp+var_C]
.text$mn:0000105D                 mov     large fs:0, eax
.text$mn:00001063                 mov     [ebp+var_10], ecx
.text$mn:00001066                 mov     [ebp+var_4], 0
.text$mn:0000106D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001074                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001077                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000107C                 mov     ecx, [ebp+var_C]
.text$mn:0000107F                 mov     large fs:0, ecx
.text$mn:00001086                 pop     ecx
.text$mn:00001087                 mov     esp, ebp
.text$mn:00001089                 pop     ebp
.text$mn:0000108A                 retn
.text$mn:0000108A ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:0000108A
.text$mn:0000108A ; ---------------------------------------------------------------------------
.text$mn:0000108B                 align 4
.text$mn:0000108B _text$mn        ends
.text$mn:0000108B
.text$x:0000108C ; ===========================================================================
.text$x:0000108C
.text$x:0000108C ; Segment type: Pure code
.text$x:0000108C ; Segment permissions: Read/Execute
.text$x:0000108C _text$x         segment para public 'CODE' use32
.text$x:0000108C                 assume cs:_text$x
.text$x:0000108C                 ;org 108Ch
.text$x:0000108C ; COMDAT (pick associative to section at 1040)
.text$x:0000108C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000108C
.text$x:0000108C ; =============== S U B R O U T I N E =======================================
.text$x:0000108C
.text$x:0000108C
.text$x:0000108C __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:0000108C                                         ; DATA XREF: .xdata$x:00002450o
.text$x:0000108C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000108F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:0000108F __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:0000108F
.text$x:00001094
.text$x:00001094 ; =============== S U B R O U T I N E =======================================
.text$x:00001094
.text$x:00001094
.text$x:00001094 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00001094                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00001094
.text$x:00001094 arg_4           = dword ptr  8
.text$x:00001094
.text$x:00001094                 mov     edx, [esp+arg_4]
.text$x:00001098                 lea     eax, [edx+0Ch]
.text$x:0000109B                 mov     ecx, [edx-8]
.text$x:0000109E                 xor     ecx, eax
.text$x:000010A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000010A5                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:000010AA                 jmp     ___CxxFrameHandler3
.text$x:000010AA __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:000010AA
.text$x:000010AA ; ---------------------------------------------------------------------------
.text$x:000010AF                 align 10h
.text$x:000010AF _text$x         ends
.text$x:000010AF
.text$mn:000010B0 ; ===========================================================================
.text$mn:000010B0
.text$mn:000010B0 ; Segment type: Pure code
.text$mn:000010B0 ; Segment permissions: Read/Execute
.text$mn:000010B0 _text$mn        segment para public 'CODE' use32
.text$mn:000010B0                 assume cs:_text$mn
.text$mn:000010B0                 ;org 10B0h
.text$mn:000010B0 ; COMDAT (pick any)
.text$mn:000010B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000010B0
.text$mn:000010B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000010B0
.text$mn:000010B0 ; Attributes: bp-based frame
.text$mn:000010B0
.text$mn:000010B0 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000010B0                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000010B0 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:000010B0                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:000010B0                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000010B0
.text$mn:000010B0 var_10          = dword ptr -10h
.text$mn:000010B0 var_C           = dword ptr -0Ch
.text$mn:000010B0 var_4           = dword ptr -4
.text$mn:000010B0
.text$mn:000010B0                 push    ebp
.text$mn:000010B1                 mov     ebp, esp
.text$mn:000010B3                 push    0FFFFFFFFh
.text$mn:000010B5                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:000010BA                 mov     eax, large fs:0
.text$mn:000010C0                 push    eax
.text$mn:000010C1                 push    ecx
.text$mn:000010C2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000010C7                 xor     eax, ebp
.text$mn:000010C9                 push    eax
.text$mn:000010CA                 lea     eax, [ebp+var_C]
.text$mn:000010CD                 mov     large fs:0, eax
.text$mn:000010D3                 mov     [ebp+var_10], ecx
.text$mn:000010D6                 mov     [ebp+var_4], 0
.text$mn:000010DD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000010E4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000010E7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000010EC                 mov     ecx, [ebp+var_C]
.text$mn:000010EF                 mov     large fs:0, ecx
.text$mn:000010F6                 pop     ecx
.text$mn:000010F7                 mov     esp, ebp
.text$mn:000010F9                 pop     ebp
.text$mn:000010FA                 retn
.text$mn:000010FA ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:000010FA
.text$mn:000010FA ; ---------------------------------------------------------------------------
.text$mn:000010FB                 align 4
.text$mn:000010FB _text$mn        ends
.text$mn:000010FB
.text$x:000010FC ; ===========================================================================
.text$x:000010FC
.text$x:000010FC ; Segment type: Pure code
.text$x:000010FC ; Segment permissions: Read/Execute
.text$x:000010FC _text$x         segment para public 'CODE' use32
.text$x:000010FC                 assume cs:_text$x
.text$x:000010FC                 ;org 10FCh
.text$x:000010FC ; COMDAT (pick associative to section at 10B0)
.text$x:000010FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000010FC
.text$x:000010FC ; =============== S U B R O U T I N E =======================================
.text$x:000010FC
.text$x:000010FC
.text$x:000010FC __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:000010FC                                         ; DATA XREF: .xdata$x:000024D4o
.text$x:000010FC                 mov     ecx, [ebp-10h]  ; this
.text$x:000010FF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000010FF __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:000010FF
.text$x:00001104
.text$x:00001104 ; =============== S U B R O U T I N E =======================================
.text$x:00001104
.text$x:00001104
.text$x:00001104 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00001104                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00001104
.text$x:00001104 arg_4           = dword ptr  8
.text$x:00001104
.text$x:00001104                 mov     edx, [esp+arg_4]
.text$x:00001108                 lea     eax, [edx+0Ch]
.text$x:0000110B                 mov     ecx, [edx-8]
.text$x:0000110E                 xor     ecx, eax
.text$x:00001110                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001115                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:0000111A                 jmp     ___CxxFrameHandler3
.text$x:0000111A __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:0000111A
.text$x:0000111A ; ---------------------------------------------------------------------------
.text$x:0000111F                 align 10h
.text$x:0000111F _text$x         ends
.text$x:0000111F
.text$mn:00001120 ; ===========================================================================
.text$mn:00001120
.text$mn:00001120 ; Segment type: Pure code
.text$mn:00001120 ; Segment permissions: Read/Execute
.text$mn:00001120 _text$mn        segment para public 'CODE' use32
.text$mn:00001120                 assume cs:_text$mn
.text$mn:00001120                 ;org 1120h
.text$mn:00001120 ; COMDAT (pick any)
.text$mn:00001120                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001120
.text$mn:00001120 ; =============== S U B R O U T I N E =======================================
.text$mn:00001120
.text$mn:00001120 ; Attributes: bp-based frame
.text$mn:00001120
.text$mn:00001120 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001120                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00001120 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00001120                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001120                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001120
.text$mn:00001120 var_10          = dword ptr -10h
.text$mn:00001120 var_C           = dword ptr -0Ch
.text$mn:00001120 var_4           = dword ptr -4
.text$mn:00001120
.text$mn:00001120                 push    ebp
.text$mn:00001121                 mov     ebp, esp
.text$mn:00001123                 push    0FFFFFFFFh
.text$mn:00001125                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:0000112A                 mov     eax, large fs:0
.text$mn:00001130                 push    eax
.text$mn:00001131                 push    ecx
.text$mn:00001132                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001137                 xor     eax, ebp
.text$mn:00001139                 push    eax
.text$mn:0000113A                 lea     eax, [ebp+var_C]
.text$mn:0000113D                 mov     large fs:0, eax
.text$mn:00001143                 mov     [ebp+var_10], ecx
.text$mn:00001146                 mov     [ebp+var_4], 0
.text$mn:0000114D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001154                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001157                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000115C                 mov     ecx, [ebp+var_C]
.text$mn:0000115F                 mov     large fs:0, ecx
.text$mn:00001166                 pop     ecx
.text$mn:00001167                 mov     esp, ebp
.text$mn:00001169                 pop     ebp
.text$mn:0000116A                 retn
.text$mn:0000116A ??1_System_error_category@std@@UAE@XZ endp
.text$mn:0000116A
.text$mn:0000116A ; ---------------------------------------------------------------------------
.text$mn:0000116B                 align 4
.text$mn:0000116B _text$mn        ends
.text$mn:0000116B
.text$x:0000116C ; ===========================================================================
.text$x:0000116C
.text$x:0000116C ; Segment type: Pure code
.text$x:0000116C ; Segment permissions: Read/Execute
.text$x:0000116C _text$x         segment para public 'CODE' use32
.text$x:0000116C                 assume cs:_text$x
.text$x:0000116C                 ;org 116Ch
.text$x:0000116C ; COMDAT (pick associative to section at 1120)
.text$x:0000116C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000116C
.text$x:0000116C ; =============== S U B R O U T I N E =======================================
.text$x:0000116C
.text$x:0000116C
.text$x:0000116C __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:0000116C                                         ; DATA XREF: .xdata$x:00002558o
.text$x:0000116C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000116F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000116F __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000116F
.text$x:00001174
.text$x:00001174 ; =============== S U B R O U T I N E =======================================
.text$x:00001174
.text$x:00001174
.text$x:00001174 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00001174                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00001174
.text$x:00001174 arg_4           = dword ptr  8
.text$x:00001174
.text$x:00001174                 mov     edx, [esp+arg_4]
.text$x:00001178                 lea     eax, [edx+0Ch]
.text$x:0000117B                 mov     ecx, [edx-8]
.text$x:0000117E                 xor     ecx, eax
.text$x:00001180                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001185                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:0000118A                 jmp     ___CxxFrameHandler3
.text$x:0000118A __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:0000118A
.text$x:0000118A ; ---------------------------------------------------------------------------
.text$x:0000118F                 align 10h
.text$x:0000118F _text$x         ends
.text$x:0000118F
.text$mn:00001190 ; ===========================================================================
.text$mn:00001190
.text$mn:00001190 ; Segment type: Pure code
.text$mn:00001190 ; Segment permissions: Read/Execute
.text$mn:00001190 _text$mn        segment para public 'CODE' use32
.text$mn:00001190                 assume cs:_text$mn
.text$mn:00001190                 ;org 1190h
.text$mn:00001190 ; COMDAT (pick any)
.text$mn:00001190                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001190
.text$mn:00001190 ; =============== S U B R O U T I N E =======================================
.text$mn:00001190
.text$mn:00001190 ; Attributes: bp-based frame
.text$mn:00001190
.text$mn:00001190 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00001190                 public ??1error_category@std@@UAE@XZ
.text$mn:00001190 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00001190                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00001190
.text$mn:00001190 var_4           = dword ptr -4
.text$mn:00001190
.text$mn:00001190                 push    ebp
.text$mn:00001191                 mov     ebp, esp
.text$mn:00001193                 push    ecx
.text$mn:00001194                 mov     [ebp+var_4], ecx
.text$mn:00001197                 mov     eax, [ebp+var_4]
.text$mn:0000119A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000011A0                 mov     esp, ebp
.text$mn:000011A2                 pop     ebp
.text$mn:000011A3                 retn
.text$mn:000011A3 ??1error_category@std@@UAE@XZ endp
.text$mn:000011A3
.text$mn:000011A3 _text$mn        ends
.text$mn:000011A3
.text$mn:000011A4 ; ===========================================================================
.text$mn:000011A4
.text$mn:000011A4 ; Segment type: Pure code
.text$mn:000011A4 ; Segment permissions: Read/Execute
.text$mn:000011A4 _text$mn        segment para public 'CODE' use32
.text$mn:000011A4                 assume cs:_text$mn
.text$mn:000011A4                 ;org 11A4h
.text$mn:000011A4 ; COMDAT (pick any)
.text$mn:000011A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000011A4
.text$mn:000011A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000011A4
.text$mn:000011A4 ; Attributes: bp-based frame
.text$mn:000011A4
.text$mn:000011A4 ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:000011A4                 public ??1runtime_error@std@@UAE@XZ
.text$mn:000011A4 ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+Ap
.text$mn:000011A4                                         ; DATA XREF: .xdata$x:000025ECo
.text$mn:000011A4
.text$mn:000011A4 var_10          = dword ptr -10h
.text$mn:000011A4 var_C           = dword ptr -0Ch
.text$mn:000011A4 var_4           = dword ptr -4
.text$mn:000011A4
.text$mn:000011A4                 push    ebp
.text$mn:000011A5                 mov     ebp, esp
.text$mn:000011A7                 push    0FFFFFFFFh
.text$mn:000011A9                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:000011AE                 mov     eax, large fs:0
.text$mn:000011B4                 push    eax
.text$mn:000011B5                 push    ecx
.text$mn:000011B6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000011BB                 xor     eax, ebp
.text$mn:000011BD                 push    eax
.text$mn:000011BE                 lea     eax, [ebp+var_C]
.text$mn:000011C1                 mov     large fs:0, eax
.text$mn:000011C7                 mov     [ebp+var_10], ecx
.text$mn:000011CA                 mov     [ebp+var_4], 0
.text$mn:000011D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000011D8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000011DB                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:000011E0                 mov     ecx, [ebp+var_C]
.text$mn:000011E3                 mov     large fs:0, ecx
.text$mn:000011EA                 pop     ecx
.text$mn:000011EB                 mov     esp, ebp
.text$mn:000011ED                 pop     ebp
.text$mn:000011EE                 retn
.text$mn:000011EE ??1runtime_error@std@@UAE@XZ endp
.text$mn:000011EE
.text$mn:000011EE ; ---------------------------------------------------------------------------
.text$mn:000011EF                 align 10h
.text$mn:000011EF _text$mn        ends
.text$mn:000011EF
.text$x:000011F0 ; ===========================================================================
.text$x:000011F0
.text$x:000011F0 ; Segment type: Pure code
.text$x:000011F0 ; Segment permissions: Read/Execute
.text$x:000011F0 _text$x         segment para public 'CODE' use32
.text$x:000011F0                 assume cs:_text$x
.text$x:000011F0                 ;org 11F0h
.text$x:000011F0 ; COMDAT (pick associative to section at 11A4)
.text$x:000011F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000011F0
.text$x:000011F0 ; =============== S U B R O U T I N E =======================================
.text$x:000011F0
.text$x:000011F0
.text$x:000011F0 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:000011F0                                         ; DATA XREF: .xdata$x:000023A0o
.text$x:000011F0                 mov     ecx, [ebp-10h]  ; this
.text$x:000011F3                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:000011F3 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:000011F3
.text$x:000011F8
.text$x:000011F8 ; =============== S U B R O U T I N E =======================================
.text$x:000011F8
.text$x:000011F8
.text$x:000011F8 __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:000011F8                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:000011F8
.text$x:000011F8 arg_4           = dword ptr  8
.text$x:000011F8
.text$x:000011F8                 mov     edx, [esp+arg_4]
.text$x:000011FC                 lea     eax, [edx+0Ch]
.text$x:000011FF                 mov     ecx, [edx-8]
.text$x:00001202                 xor     ecx, eax
.text$x:00001204                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001209                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:0000120E                 jmp     ___CxxFrameHandler3
.text$x:0000120E __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:0000120E
.text$x:0000120E ; ---------------------------------------------------------------------------
.text$x:00001213                 align 4
.text$x:00001213 _text$x         ends
.text$x:00001213
.text$mn:00001214 ; ===========================================================================
.text$mn:00001214
.text$mn:00001214 ; Segment type: Pure code
.text$mn:00001214 ; Segment permissions: Read/Execute
.text$mn:00001214 _text$mn        segment para public 'CODE' use32
.text$mn:00001214                 assume cs:_text$mn
.text$mn:00001214                 ;org 1214h
.text$mn:00001214 ; COMDAT (pick any)
.text$mn:00001214                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001214
.text$mn:00001214 ; =============== S U B R O U T I N E =======================================
.text$mn:00001214
.text$mn:00001214 ; Attributes: bp-based frame
.text$mn:00001214
.text$mn:00001214 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00001214                 public ??2@YAPAXIPAX@Z
.text$mn:00001214 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00001214                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00001214
.text$mn:00001214 arg_4           = dword ptr  0Ch
.text$mn:00001214
.text$mn:00001214                 push    ebp
.text$mn:00001215                 mov     ebp, esp
.text$mn:00001217                 mov     eax, [ebp+arg_4]
.text$mn:0000121A                 pop     ebp
.text$mn:0000121B                 retn
.text$mn:0000121B ??2@YAPAXIPAX@Z endp
.text$mn:0000121B
.text$mn:0000121B _text$mn        ends
.text$mn:0000121B
.text$mn:0000121C ; ===========================================================================
.text$mn:0000121C
.text$mn:0000121C ; Segment type: Pure code
.text$mn:0000121C ; Segment permissions: Read/Execute
.text$mn:0000121C _text$mn        segment para public 'CODE' use32
.text$mn:0000121C                 assume cs:_text$mn
.text$mn:0000121C                 ;org 121Ch
.text$mn:0000121C ; COMDAT (pick any)
.text$mn:0000121C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000121C
.text$mn:0000121C ; =============== S U B R O U T I N E =======================================
.text$mn:0000121C
.text$mn:0000121C ; Attributes: bp-based frame
.text$mn:0000121C
.text$mn:0000121C ; void __cdecl operator delete(void *)
.text$mn:0000121C                 public ??3@YAXPAX0@Z
.text$mn:0000121C ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:0000121C                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:0000121C                 push    ebp
.text$mn:0000121D                 mov     ebp, esp
.text$mn:0000121F                 pop     ebp
.text$mn:00001220                 retn
.text$mn:00001220 ??3@YAXPAX0@Z   endp
.text$mn:00001220
.text$mn:00001220 ; ---------------------------------------------------------------------------
.text$mn:00001221                 align 4
.text$mn:00001221 _text$mn        ends
.text$mn:00001221
.text$mn:00001224 ; ===========================================================================
.text$mn:00001224
.text$mn:00001224 ; Segment type: Pure code
.text$mn:00001224 ; Segment permissions: Read/Execute
.text$mn:00001224 _text$mn        segment para public 'CODE' use32
.text$mn:00001224                 assume cs:_text$mn
.text$mn:00001224                 ;org 1224h
.text$mn:00001224 ; COMDAT (pick any)
.text$mn:00001224                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001224
.text$mn:00001224 ; =============== S U B R O U T I N E =======================================
.text$mn:00001224
.text$mn:00001224 ; Attributes: bp-based frame
.text$mn:00001224
.text$mn:00001224 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00001224                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00001224 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00001224                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00001224                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00001224
.text$mn:00001224 var_8           = dword ptr -8
.text$mn:00001224 var_4           = dword ptr -4
.text$mn:00001224 arg_0           = dword ptr  8
.text$mn:00001224
.text$mn:00001224                 push    ebp
.text$mn:00001225                 mov     ebp, esp
.text$mn:00001227                 sub     esp, 8
.text$mn:0000122A                 mov     [ebp+var_8], ecx
.text$mn:0000122D                 mov     eax, [ebp+var_8]
.text$mn:00001230                 cmp     eax, [ebp+arg_0]
.text$mn:00001233                 jnz     short loc_123E
.text$mn:00001235                 mov     [ebp+var_4], 1
.text$mn:0000123C                 jmp     short loc_1245
.text$mn:0000123E ; ---------------------------------------------------------------------------
.text$mn:0000123E
.text$mn:0000123E loc_123E:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:0000123E                 mov     [ebp+var_4], 0
.text$mn:00001245
.text$mn:00001245 loc_1245:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00001245                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001248                 mov     esp, ebp
.text$mn:0000124A                 pop     ebp
.text$mn:0000124B                 retn    4
.text$mn:0000124B ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:0000124B
.text$mn:0000124B ; ---------------------------------------------------------------------------
.text$mn:0000124E                 align 10h
.text$mn:0000124E _text$mn        ends
.text$mn:0000124E
.text$mn:00001250 ; ===========================================================================
.text$mn:00001250
.text$mn:00001250 ; Segment type: Pure code
.text$mn:00001250 ; Segment permissions: Read/Execute
.text$mn:00001250 _text$mn        segment para public 'CODE' use32
.text$mn:00001250                 assume cs:_text$mn
.text$mn:00001250                 ;org 1250h
.text$mn:00001250 ; COMDAT (pick any)
.text$mn:00001250                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001250
.text$mn:00001250 ; =============== S U B R O U T I N E =======================================
.text$mn:00001250
.text$mn:00001250 ; Attributes: bp-based frame
.text$mn:00001250
.text$mn:00001250 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00001250                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00001250 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00001250                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00001250
.text$mn:00001250 var_8           = dword ptr -8
.text$mn:00001250 var_4           = dword ptr -4
.text$mn:00001250 arg_0           = dword ptr  8
.text$mn:00001250
.text$mn:00001250                 push    ebp
.text$mn:00001251                 mov     ebp, esp
.text$mn:00001253                 sub     esp, 8
.text$mn:00001256                 push    esi
.text$mn:00001257                 mov     [ebp+var_4], ecx
.text$mn:0000125A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000125D                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001262                 push    eax
.text$mn:00001263                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001266                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000126B                 mov     ecx, eax
.text$mn:0000126D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001272                 movzx   eax, al
.text$mn:00001275                 test    eax, eax
.text$mn:00001277                 jz      short loc_1298
.text$mn:00001279                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000127C                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001281                 mov     esi, eax
.text$mn:00001283                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001286                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:0000128B                 cmp     esi, eax
.text$mn:0000128D                 jnz     short loc_1298
.text$mn:0000128F                 mov     [ebp+var_8], 1
.text$mn:00001296                 jmp     short loc_129F
.text$mn:00001298 ; ---------------------------------------------------------------------------
.text$mn:00001298
.text$mn:00001298 loc_1298:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00001298                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00001298                 mov     [ebp+var_8], 0
.text$mn:0000129F
.text$mn:0000129F loc_129F:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:0000129F                 mov     al, byte ptr [ebp+var_8]
.text$mn:000012A2                 pop     esi
.text$mn:000012A3                 mov     esp, ebp
.text$mn:000012A5                 pop     ebp
.text$mn:000012A6                 retn    4
.text$mn:000012A6 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:000012A6
.text$mn:000012A6 ; ---------------------------------------------------------------------------
.text$mn:000012A9                 align 4
.text$mn:000012A9 _text$mn        ends
.text$mn:000012A9
.text$mn:000012AC ; ===========================================================================
.text$mn:000012AC
.text$mn:000012AC ; Segment type: Pure code
.text$mn:000012AC ; Segment permissions: Read/Execute
.text$mn:000012AC _text$mn        segment para public 'CODE' use32
.text$mn:000012AC                 assume cs:_text$mn
.text$mn:000012AC                 ;org 12ACh
.text$mn:000012AC ; COMDAT (pick any)
.text$mn:000012AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000012AC
.text$mn:000012AC ; =============== S U B R O U T I N E =======================================
.text$mn:000012AC
.text$mn:000012AC ; Attributes: bp-based frame
.text$mn:000012AC
.text$mn:000012AC ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000012AC                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:000012AC ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:000012AC
.text$mn:000012AC var_4           = dword ptr -4
.text$mn:000012AC arg_0           = dword ptr  8
.text$mn:000012AC
.text$mn:000012AC                 push    ebp
.text$mn:000012AD                 mov     ebp, esp
.text$mn:000012AF                 push    ecx
.text$mn:000012B0                 mov     [ebp+var_4], ecx
.text$mn:000012B3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000012B6                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000012BB                 mov     eax, [ebp+arg_0]
.text$mn:000012BE                 and     eax, 1
.text$mn:000012C1                 jz      short loc_12CF
.text$mn:000012C3                 mov     ecx, [ebp+var_4]
.text$mn:000012C6                 push    ecx             ; void *
.text$mn:000012C7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000012CC                 add     esp, 4
.text$mn:000012CF
.text$mn:000012CF loc_12CF:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000012CF                 mov     eax, [ebp+var_4]
.text$mn:000012D2                 mov     esp, ebp
.text$mn:000012D4                 pop     ebp
.text$mn:000012D5                 retn    4
.text$mn:000012D5 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:000012D5
.text$mn:000012D5 _text$mn        ends
.text$mn:000012D5
.text$mn:000012D8 ; ===========================================================================
.text$mn:000012D8
.text$mn:000012D8 ; Segment type: Pure code
.text$mn:000012D8 ; Segment permissions: Read/Execute
.text$mn:000012D8 _text$mn        segment para public 'CODE' use32
.text$mn:000012D8                 assume cs:_text$mn
.text$mn:000012D8                 ;org 12D8h
.text$mn:000012D8 ; COMDAT (pick any)
.text$mn:000012D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000012D8
.text$mn:000012D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000012D8
.text$mn:000012D8 ; Attributes: bp-based frame
.text$mn:000012D8
.text$mn:000012D8 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000012D8                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:000012D8 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:000012D8
.text$mn:000012D8 var_4           = dword ptr -4
.text$mn:000012D8 arg_0           = dword ptr  8
.text$mn:000012D8
.text$mn:000012D8                 push    ebp
.text$mn:000012D9                 mov     ebp, esp
.text$mn:000012DB                 push    ecx
.text$mn:000012DC                 mov     [ebp+var_4], ecx
.text$mn:000012DF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000012E2                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:000012E7                 mov     eax, [ebp+arg_0]
.text$mn:000012EA                 and     eax, 1
.text$mn:000012ED                 jz      short loc_12FB
.text$mn:000012EF                 mov     ecx, [ebp+var_4]
.text$mn:000012F2                 push    ecx             ; void *
.text$mn:000012F3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000012F8                 add     esp, 4
.text$mn:000012FB
.text$mn:000012FB loc_12FB:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000012FB                 mov     eax, [ebp+var_4]
.text$mn:000012FE                 mov     esp, ebp
.text$mn:00001300                 pop     ebp
.text$mn:00001301                 retn    4
.text$mn:00001301 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00001301
.text$mn:00001301 _text$mn        ends
.text$mn:00001301
.text$mn:00001304 ; ===========================================================================
.text$mn:00001304
.text$mn:00001304 ; Segment type: Pure code
.text$mn:00001304 ; Segment permissions: Read/Execute
.text$mn:00001304 _text$mn        segment para public 'CODE' use32
.text$mn:00001304                 assume cs:_text$mn
.text$mn:00001304                 ;org 1304h
.text$mn:00001304 ; COMDAT (pick any)
.text$mn:00001304                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001304
.text$mn:00001304 ; =============== S U B R O U T I N E =======================================
.text$mn:00001304
.text$mn:00001304 ; Attributes: bp-based frame
.text$mn:00001304
.text$mn:00001304 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001304                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00001304 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001304
.text$mn:00001304 var_4           = dword ptr -4
.text$mn:00001304 arg_0           = dword ptr  8
.text$mn:00001304
.text$mn:00001304                 push    ebp
.text$mn:00001305                 mov     ebp, esp
.text$mn:00001307                 push    ecx
.text$mn:00001308                 mov     [ebp+var_4], ecx
.text$mn:0000130B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000130E                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00001313                 mov     eax, [ebp+arg_0]
.text$mn:00001316                 and     eax, 1
.text$mn:00001319                 jz      short loc_1327
.text$mn:0000131B                 mov     ecx, [ebp+var_4]
.text$mn:0000131E                 push    ecx             ; void *
.text$mn:0000131F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001324                 add     esp, 4
.text$mn:00001327
.text$mn:00001327 loc_1327:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001327                 mov     eax, [ebp+var_4]
.text$mn:0000132A                 mov     esp, ebp
.text$mn:0000132C                 pop     ebp
.text$mn:0000132D                 retn    4
.text$mn:0000132D ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:0000132D
.text$mn:0000132D _text$mn        ends
.text$mn:0000132D
.text$mn:00001330 ; ===========================================================================
.text$mn:00001330
.text$mn:00001330 ; Segment type: Pure code
.text$mn:00001330 ; Segment permissions: Read/Execute
.text$mn:00001330 _text$mn        segment para public 'CODE' use32
.text$mn:00001330                 assume cs:_text$mn
.text$mn:00001330                 ;org 1330h
.text$mn:00001330 ; COMDAT (pick any)
.text$mn:00001330                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001330
.text$mn:00001330 ; =============== S U B R O U T I N E =======================================
.text$mn:00001330
.text$mn:00001330 ; Attributes: bp-based frame
.text$mn:00001330
.text$mn:00001330 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001330                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00001330 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00001330
.text$mn:00001330 var_4           = dword ptr -4
.text$mn:00001330 arg_0           = dword ptr  8
.text$mn:00001330
.text$mn:00001330                 push    ebp
.text$mn:00001331                 mov     ebp, esp
.text$mn:00001333                 push    ecx
.text$mn:00001334                 mov     [ebp+var_4], ecx
.text$mn:00001337                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000133A                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:0000133F                 mov     eax, [ebp+arg_0]
.text$mn:00001342                 and     eax, 1
.text$mn:00001345                 jz      short loc_1353
.text$mn:00001347                 mov     ecx, [ebp+var_4]
.text$mn:0000134A                 push    ecx             ; void *
.text$mn:0000134B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001350                 add     esp, 4
.text$mn:00001353
.text$mn:00001353 loc_1353:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001353                 mov     eax, [ebp+var_4]
.text$mn:00001356                 mov     esp, ebp
.text$mn:00001358                 pop     ebp
.text$mn:00001359                 retn    4
.text$mn:00001359 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00001359
.text$mn:00001359 _text$mn        ends
.text$mn:00001359
.text$mn:0000135C ; ===========================================================================
.text$mn:0000135C
.text$mn:0000135C ; Segment type: Pure code
.text$mn:0000135C ; Segment permissions: Read/Execute
.text$mn:0000135C _text$mn        segment para public 'CODE' use32
.text$mn:0000135C                 assume cs:_text$mn
.text$mn:0000135C                 ;org 135Ch
.text$mn:0000135C ; COMDAT (pick any)
.text$mn:0000135C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000135C
.text$mn:0000135C ; =============== S U B R O U T I N E =======================================
.text$mn:0000135C
.text$mn:0000135C ; Attributes: bp-based frame
.text$mn:0000135C
.text$mn:0000135C ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:0000135C                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:0000135C ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:0000135C
.text$mn:0000135C var_4           = dword ptr -4
.text$mn:0000135C arg_0           = dword ptr  8
.text$mn:0000135C
.text$mn:0000135C                 push    ebp
.text$mn:0000135D                 mov     ebp, esp
.text$mn:0000135F                 push    ecx
.text$mn:00001360                 mov     [ebp+var_4], ecx
.text$mn:00001363                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001366                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:0000136B                 mov     eax, [ebp+arg_0]
.text$mn:0000136E                 and     eax, 1
.text$mn:00001371                 jz      short loc_137F
.text$mn:00001373                 mov     ecx, [ebp+var_4]
.text$mn:00001376                 push    ecx             ; void *
.text$mn:00001377                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000137C                 add     esp, 4
.text$mn:0000137F
.text$mn:0000137F loc_137F:                               ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:0000137F                 mov     eax, [ebp+var_4]
.text$mn:00001382                 mov     esp, ebp
.text$mn:00001384                 pop     ebp
.text$mn:00001385                 retn    4
.text$mn:00001385 ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:00001385
.text$mn:00001385 _text$mn        ends
.text$mn:00001385
.text$di:00001388 ; ===========================================================================
.text$di:00001388
.text$di:00001388 ; Segment type: Pure code
.text$di:00001388 ; Segment permissions: Read/Execute
.text$di:00001388 _text$di        segment para public 'CODE' use32
.text$di:00001388                 assume cs:_text$di
.text$di:00001388                 ;org 1388h
.text$di:00001388 ; COMDAT (pick any)
.text$di:00001388                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001388
.text$di:00001388 ; =============== S U B R O U T I N E =======================================
.text$di:00001388
.text$di:00001388 ; Attributes: bp-based frame
.text$di:00001388
.text$di:00001388 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00001388 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00001388                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00001388                 push    ebp
.text$di:00001389                 mov     ebp, esp
.text$di:0000138B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00001390                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00001395                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000139A                 call    _atexit
.text$di:0000139F                 add     esp, 4
.text$di:000013A2                 pop     ebp
.text$di:000013A3                 retn
.text$di:000013A3 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:000013A3
.text$di:000013A3 _text$di        ends
.text$di:000013A3
.text$di:000013A4 ; ===========================================================================
.text$di:000013A4
.text$di:000013A4 ; Segment type: Pure code
.text$di:000013A4 ; Segment permissions: Read/Execute
.text$di:000013A4 _text$di        segment para public 'CODE' use32
.text$di:000013A4                 assume cs:_text$di
.text$di:000013A4                 ;org 13A4h
.text$di:000013A4 ; COMDAT (pick any)
.text$di:000013A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000013A4
.text$di:000013A4 ; =============== S U B R O U T I N E =======================================
.text$di:000013A4
.text$di:000013A4 ; Attributes: bp-based frame
.text$di:000013A4
.text$di:000013A4 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:000013A4 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:000013A4                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:000013A4                 push    ebp
.text$di:000013A5                 mov     ebp, esp
.text$di:000013A7                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:000013AC                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:000013B1                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000013B6                 call    _atexit
.text$di:000013BB                 add     esp, 4
.text$di:000013BE                 pop     ebp
.text$di:000013BF                 retn
.text$di:000013BF ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:000013BF
.text$di:000013BF _text$di        ends
.text$di:000013BF
.text$di:000013C0 ; ===========================================================================
.text$di:000013C0
.text$di:000013C0 ; Segment type: Pure code
.text$di:000013C0 ; Segment permissions: Read/Execute
.text$di:000013C0 _text$di        segment para public 'CODE' use32
.text$di:000013C0                 assume cs:_text$di
.text$di:000013C0                 ;org 13C0h
.text$di:000013C0 ; COMDAT (pick any)
.text$di:000013C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000013C0
.text$di:000013C0 ; =============== S U B R O U T I N E =======================================
.text$di:000013C0
.text$di:000013C0 ; Attributes: bp-based frame
.text$di:000013C0
.text$di:000013C0 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:000013C0 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:000013C0                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:000013C0                 push    ebp
.text$di:000013C1                 mov     ebp, esp
.text$di:000013C3                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:000013C8                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:000013CD                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000013D2                 call    _atexit
.text$di:000013D7                 add     esp, 4
.text$di:000013DA                 pop     ebp
.text$di:000013DB                 retn
.text$di:000013DB ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:000013DB
.text$di:000013DB _text$di        ends
.text$di:000013DB
.text$di:000013DC ; ===========================================================================
.text$di:000013DC
.text$di:000013DC ; Segment type: Pure code
.text$di:000013DC ; Segment permissions: Read/Execute
.text$di:000013DC _text$di        segment para public 'CODE' use32
.text$di:000013DC                 assume cs:_text$di
.text$di:000013DC                 ;org 13DCh
.text$di:000013DC ; COMDAT (pick any)
.text$di:000013DC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000013DC
.text$di:000013DC ; =============== S U B R O U T I N E =======================================
.text$di:000013DC
.text$di:000013DC ; Attributes: bp-based frame
.text$di:000013DC
.text$di:000013DC ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:000013DC ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:000013DC
.text$di:000013DC var_1           = byte ptr -1
.text$di:000013DC
.text$di:000013DC                 push    ebp
.text$di:000013DD                 mov     ebp, esp
.text$di:000013DF                 push    ecx
.text$di:000013E0                 xor     eax, eax
.text$di:000013E2                 mov     [ebp+var_1], al
.text$di:000013E5                 mov     esp, ebp
.text$di:000013E7                 pop     ebp
.text$di:000013E8                 retn
.text$di:000013E8 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:000013E8
.text$di:000013E8 ; ---------------------------------------------------------------------------
.text$di:000013E9                 align 4
.text$di:000013E9 _text$di        ends
.text$di:000013E9
.text$di:000013EC ; ===========================================================================
.text$di:000013EC
.text$di:000013EC ; Segment type: Pure code
.text$di:000013EC ; Segment permissions: Read/Execute
.text$di:000013EC _text$di        segment para public 'CODE' use32
.text$di:000013EC                 assume cs:_text$di
.text$di:000013EC                 ;org 13ECh
.text$di:000013EC ; COMDAT (pick any)
.text$di:000013EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:000013EC
.text$di:000013EC ; =============== S U B R O U T I N E =======================================
.text$di:000013EC
.text$di:000013EC ; Attributes: bp-based frame
.text$di:000013EC
.text$di:000013EC ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:000013EC ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:000013EC                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:000013EC
.text$di:000013EC var_1           = byte ptr -1
.text$di:000013EC
.text$di:000013EC                 push    ebp
.text$di:000013ED                 mov     ebp, esp
.text$di:000013EF                 push    ecx
.text$di:000013F0                 xor     eax, eax
.text$di:000013F2                 mov     [ebp+var_1], al
.text$di:000013F5                 mov     esp, ebp
.text$di:000013F7                 pop     ebp
.text$di:000013F8                 retn
.text$di:000013F8 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:000013F8
.text$di:000013F8 ; ---------------------------------------------------------------------------
.text$di:000013F9                 align 4
.text$di:000013F9 _text$di        ends
.text$di:000013F9
.text$yd:000013FC ; ===========================================================================
.text$yd:000013FC
.text$yd:000013FC ; Segment type: Pure code
.text$yd:000013FC ; Segment permissions: Read/Execute
.text$yd:000013FC _text$yd        segment para public 'CODE' use32
.text$yd:000013FC                 assume cs:_text$yd
.text$yd:000013FC                 ;org 13FCh
.text$yd:000013FC ; COMDAT (pick any)
.text$yd:000013FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:000013FC
.text$yd:000013FC ; =============== S U B R O U T I N E =======================================
.text$yd:000013FC
.text$yd:000013FC ; Attributes: bp-based frame
.text$yd:000013FC
.text$yd:000013FC ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:000013FC ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:000013FC                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:000013FC                 push    ebp
.text$yd:000013FD                 mov     ebp, esp
.text$yd:000013FF                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00001404                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00001409                 pop     ebp
.text$yd:0000140A                 retn
.text$yd:0000140A ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:0000140A
.text$yd:0000140A ; ---------------------------------------------------------------------------
.text$yd:0000140B                 align 4
.text$yd:0000140B _text$yd        ends
.text$yd:0000140B
.text$yd:0000140C ; ===========================================================================
.text$yd:0000140C
.text$yd:0000140C ; Segment type: Pure code
.text$yd:0000140C ; Segment permissions: Read/Execute
.text$yd:0000140C _text$yd        segment para public 'CODE' use32
.text$yd:0000140C                 assume cs:_text$yd
.text$yd:0000140C                 ;org 140Ch
.text$yd:0000140C ; COMDAT (pick any)
.text$yd:0000140C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:0000140C
.text$yd:0000140C ; =============== S U B R O U T I N E =======================================
.text$yd:0000140C
.text$yd:0000140C ; Attributes: bp-based frame
.text$yd:0000140C
.text$yd:0000140C ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:0000140C ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:0000140C                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:0000140C                 push    ebp
.text$yd:0000140D                 mov     ebp, esp
.text$yd:0000140F                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00001414                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00001419                 pop     ebp
.text$yd:0000141A                 retn
.text$yd:0000141A ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:0000141A
.text$yd:0000141A ; ---------------------------------------------------------------------------
.text$yd:0000141B                 align 4
.text$yd:0000141B _text$yd        ends
.text$yd:0000141B
.text$yd:0000141C ; ===========================================================================
.text$yd:0000141C
.text$yd:0000141C ; Segment type: Pure code
.text$yd:0000141C ; Segment permissions: Read/Execute
.text$yd:0000141C _text$yd        segment para public 'CODE' use32
.text$yd:0000141C                 assume cs:_text$yd
.text$yd:0000141C                 ;org 141Ch
.text$yd:0000141C ; COMDAT (pick any)
.text$yd:0000141C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:0000141C
.text$yd:0000141C ; =============== S U B R O U T I N E =======================================
.text$yd:0000141C
.text$yd:0000141C ; Attributes: bp-based frame
.text$yd:0000141C
.text$yd:0000141C ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:0000141C ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:0000141C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:0000141C                 push    ebp
.text$yd:0000141D                 mov     ebp, esp
.text$yd:0000141F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00001424                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00001429                 pop     ebp
.text$yd:0000142A                 retn
.text$yd:0000142A ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:0000142A
.text$yd:0000142A ; ---------------------------------------------------------------------------
.text$yd:0000142B                 align 4
.text$yd:0000142B _text$yd        ends
.text$yd:0000142B
.text$mn:0000142C ; ===========================================================================
.text$mn:0000142C
.text$mn:0000142C ; Segment type: Pure code
.text$mn:0000142C ; Segment permissions: Read/Execute
.text$mn:0000142C _text$mn        segment para public 'CODE' use32
.text$mn:0000142C                 assume cs:_text$mn
.text$mn:0000142C                 ;org 142Ch
.text$mn:0000142C ; COMDAT (pick any)
.text$mn:0000142C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000142C
.text$mn:0000142C ; =============== S U B R O U T I N E =======================================
.text$mn:0000142C
.text$mn:0000142C ; Attributes: bp-based frame
.text$mn:0000142C
.text$mn:0000142C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:0000142C                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:0000142C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000142C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:0000142C
.text$mn:0000142C var_10          = byte ptr -10h
.text$mn:0000142C var_8           = dword ptr -8
.text$mn:0000142C var_1           = byte ptr -1
.text$mn:0000142C
.text$mn:0000142C                 push    ebp
.text$mn:0000142D                 mov     ebp, esp
.text$mn:0000142F                 sub     esp, 10h
.text$mn:00001432                 mov     [ebp+var_8], ecx
.text$mn:00001435                 lea     ecx, [ebp+var_1]
.text$mn:00001438                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000143D                 push    1
.text$mn:0000143F                 lea     ecx, [ebp+var_1]
.text$mn:00001442                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00001447                 mov     ecx, [ebp+var_8]
.text$mn:0000144A                 mov     [ecx], eax
.text$mn:0000144C                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000144F                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001454                 push    eax             ; int
.text$mn:00001455                 mov     edx, [ebp+var_8]
.text$mn:00001458                 mov     eax, [edx]
.text$mn:0000145A                 push    eax             ; void *
.text$mn:0000145B                 lea     ecx, [ebp+var_1]
.text$mn:0000145E                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001463                 mov     ecx, [ebp+var_8]
.text$mn:00001466                 mov     edx, [ecx]
.text$mn:00001468                 mov     eax, [ebp+var_8]
.text$mn:0000146B                 mov     [edx], eax
.text$mn:0000146D                 mov     esp, ebp
.text$mn:0000146F                 pop     ebp
.text$mn:00001470                 retn
.text$mn:00001470 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001470
.text$mn:00001470 ; ---------------------------------------------------------------------------
.text$mn:00001471                 align 4
.text$mn:00001471 _text$mn        ends
.text$mn:00001471
.text$mn:00001474 ; ===========================================================================
.text$mn:00001474
.text$mn:00001474 ; Segment type: Pure code
.text$mn:00001474 ; Segment permissions: Read/Execute
.text$mn:00001474 _text$mn        segment para public 'CODE' use32
.text$mn:00001474                 assume cs:_text$mn
.text$mn:00001474                 ;org 1474h
.text$mn:00001474 ; COMDAT (pick any)
.text$mn:00001474                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001474
.text$mn:00001474 ; =============== S U B R O U T I N E =======================================
.text$mn:00001474
.text$mn:00001474 ; Attributes: bp-based frame
.text$mn:00001474
.text$mn:00001474 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00001474                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001474 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00001474                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00001474
.text$mn:00001474 var_20          = dword ptr -20h
.text$mn:00001474 var_1C          = dword ptr -1Ch
.text$mn:00001474 var_18          = dword ptr -18h
.text$mn:00001474 var_11          = byte ptr -11h
.text$mn:00001474 var_10          = dword ptr -10h
.text$mn:00001474 var_C           = byte ptr -0Ch
.text$mn:00001474 var_4           = dword ptr -4
.text$mn:00001474 arg_0           = dword ptr  8
.text$mn:00001474
.text$mn:00001474 ; FUNCTION CHUNK AT .text$mn:00001596 SIZE 00000009 BYTES
.text$mn:00001474
.text$mn:00001474                 push    ebp
.text$mn:00001475                 mov     ebp, esp
.text$mn:00001477                 push    0FFFFFFFFh
.text$mn:00001479                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000147E                 mov     eax, large fs:0
.text$mn:00001484                 push    eax
.text$mn:00001485                 push    ecx
.text$mn:00001486                 sub     esp, 10h
.text$mn:00001489                 push    ebx
.text$mn:0000148A                 push    esi
.text$mn:0000148B                 push    edi
.text$mn:0000148C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001491                 xor     eax, ebp
.text$mn:00001493                 push    eax
.text$mn:00001494                 lea     eax, [ebp+var_C]
.text$mn:00001497                 mov     large fs:0, eax
.text$mn:0000149D                 mov     [ebp+var_10], esp
.text$mn:000014A0                 mov     [ebp+var_18], ecx
.text$mn:000014A3                 mov     eax, [ebp+arg_0]
.text$mn:000014A6                 or      eax, 0Fh
.text$mn:000014A9                 mov     [ebp+var_1C], eax
.text$mn:000014AC                 mov     ecx, [ebp+var_18]
.text$mn:000014AF                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000014B4                 cmp     eax, [ebp+var_1C]
.text$mn:000014B7                 jnb     short loc_14C1
.text$mn:000014B9                 mov     ecx, [ebp+arg_0]
.text$mn:000014BC                 mov     [ebp+var_1C], ecx
.text$mn:000014BF                 jmp     short loc_1513
.text$mn:000014C1 ; ---------------------------------------------------------------------------
.text$mn:000014C1
.text$mn:000014C1 loc_14C1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:000014C1                 mov     edx, [ebp+var_18]
.text$mn:000014C4                 mov     ecx, [edx+18h]
.text$mn:000014C7                 shr     ecx, 1
.text$mn:000014C9                 mov     eax, [ebp+var_1C]
.text$mn:000014CC                 xor     edx, edx
.text$mn:000014CE                 mov     esi, 3
.text$mn:000014D3                 div     esi
.text$mn:000014D5                 cmp     ecx, eax
.text$mn:000014D7                 ja      short loc_14DB
.text$mn:000014D9                 jmp     short loc_1513
.text$mn:000014DB ; ---------------------------------------------------------------------------
.text$mn:000014DB
.text$mn:000014DB loc_14DB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:000014DB                 mov     ecx, [ebp+var_18]
.text$mn:000014DE                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000014E3                 mov     edx, [ebp+var_18]
.text$mn:000014E6                 mov     ecx, [edx+18h]
.text$mn:000014E9                 shr     ecx, 1
.text$mn:000014EB                 sub     eax, ecx
.text$mn:000014ED                 mov     edx, [ebp+var_18]
.text$mn:000014F0                 cmp     [edx+18h], eax
.text$mn:000014F3                 ja      short loc_1508
.text$mn:000014F5                 mov     eax, [ebp+var_18]
.text$mn:000014F8                 mov     ecx, [eax+18h]
.text$mn:000014FB                 shr     ecx, 1
.text$mn:000014FD                 mov     edx, [ebp+var_18]
.text$mn:00001500                 add     ecx, [edx+18h]
.text$mn:00001503                 mov     [ebp+var_1C], ecx
.text$mn:00001506                 jmp     short loc_1513
.text$mn:00001508 ; ---------------------------------------------------------------------------
.text$mn:00001508
.text$mn:00001508 loc_1508:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00001508                 mov     ecx, [ebp+var_18]
.text$mn:0000150B                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001510                 mov     [ebp+var_1C], eax
.text$mn:00001513
.text$mn:00001513 loc_1513:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00001513                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00001513                 mov     [ebp+var_4], 0
.text$mn:0000151A                 mov     eax, [ebp+var_1C]
.text$mn:0000151D                 add     eax, 1
.text$mn:00001520                 push    eax
.text$mn:00001521                 lea     ecx, [ebp+var_11]
.text$mn:00001524                 push    ecx
.text$mn:00001525                 mov     ecx, [ebp+var_18]
.text$mn:00001528                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000152D                 mov     ecx, eax
.text$mn:0000152F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001534                 mov     [ebp+var_20], eax
.text$mn:00001537                 jmp     short loc_1596
.text$mn:00001537 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00001537
.text$mn:00001539
.text$mn:00001539 ; =============== S U B R O U T I N E =======================================
.text$mn:00001539
.text$mn:00001539
.text$mn:00001539 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001539                                         ; DATA XREF: .xdata$x:000022F0o
.text$mn:00001539
.text$mn:00001539 ; FUNCTION CHUNK AT .text$mn:00001580 SIZE 00000009 BYTES
.text$mn:00001539 ; FUNCTION CHUNK AT .text$mn:00001590 SIZE 00000006 BYTES
.text$mn:00001539
.text$mn:00001539                 mov     [ebp-10h], esp
.text$mn:0000153C                 mov     edx, [ebp+8]
.text$mn:0000153F                 mov     [ebp-1Ch], edx
.text$mn:00001542                 mov     byte ptr [ebp-4], 2
.text$mn:00001546                 mov     eax, [ebp-1Ch]
.text$mn:00001549                 add     eax, 1
.text$mn:0000154C                 push    eax
.text$mn:0000154D                 lea     ecx, [ebp-12h]
.text$mn:00001550                 push    ecx
.text$mn:00001551                 mov     ecx, [ebp-18h]
.text$mn:00001554                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001559                 mov     ecx, eax
.text$mn:0000155B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001560                 mov     [ebp-20h], eax
.text$mn:00001563                 jmp     short loc_1580
.text$mn:00001563 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00001563
.text$mn:00001565
.text$mn:00001565 ; =============== S U B R O U T I N E =======================================
.text$mn:00001565
.text$mn:00001565 ; Attributes: noreturn
.text$mn:00001565
.text$mn:00001565 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001565                                         ; DATA XREF: .xdata$x:00002300o
.text$mn:00001565                 push    0               ; Size
.text$mn:00001567                 push    1               ; char
.text$mn:00001569                 mov     ecx, [ebp-18h]
.text$mn:0000156C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001571                 push    0
.text$mn:00001573                 push    0
.text$mn:00001575                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001575 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00001575
.text$mn:0000157A ; ---------------------------------------------------------------------------
.text$mn:0000157A                 mov     eax, offset $LN17
.text$mn:0000157F                 retn
.text$mn:00001580 ; ---------------------------------------------------------------------------
.text$mn:00001580 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001580
.text$mn:00001580 loc_1580:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00001580                 mov     dword ptr [ebp-4], 1
.text$mn:00001587                 jmp     short loc_1590
.text$mn:00001587 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001589
.text$mn:00001589 ; =============== S U B R O U T I N E =======================================
.text$mn:00001589
.text$mn:00001589
.text$mn:00001589 $LN17           proc near               ; DATA XREF: .text$mn:0000157Ao
.text$mn:00001589                 mov     dword ptr [ebp-4], 1
.text$mn:00001589 $LN17           endp ; sp-analysis failed
.text$mn:00001589
.text$mn:00001590 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001590
.text$mn:00001590 loc_1590:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00001590                 mov     eax, offset $LN19
.text$mn:00001595                 retn
.text$mn:00001595 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001596 ; ---------------------------------------------------------------------------
.text$mn:00001596 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001596
.text$mn:00001596 loc_1596:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00001596                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000159D                 jmp     short loc_15A6
.text$mn:0000159D ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000159F
.text$mn:0000159F ; =============== S U B R O U T I N E =======================================
.text$mn:0000159F
.text$mn:0000159F
.text$mn:0000159F $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_1590o
.text$mn:0000159F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000015A6
.text$mn:000015A6 loc_15A6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:000015A6                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:000015AA                 jbe     short loc_15C5
.text$mn:000015AC                 mov     edx, [ebp+0Ch]
.text$mn:000015AF                 push    edx             ; Size
.text$mn:000015B0                 mov     ecx, [ebp-18h]
.text$mn:000015B3                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000015B8                 push    eax             ; Src
.text$mn:000015B9                 mov     eax, [ebp-20h]
.text$mn:000015BC                 push    eax             ; Dst
.text$mn:000015BD                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000015C2                 add     esp, 0Ch
.text$mn:000015C5
.text$mn:000015C5 loc_15C5:                               ; CODE XREF: $LN19+Bj
.text$mn:000015C5                 push    0               ; Size
.text$mn:000015C7                 push    1               ; char
.text$mn:000015C9                 mov     ecx, [ebp-18h]
.text$mn:000015CC                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000015D1                 lea     ecx, [ebp-20h]
.text$mn:000015D4                 push    ecx             ; int
.text$mn:000015D5                 mov     edx, [ebp-18h]
.text$mn:000015D8                 add     edx, 4
.text$mn:000015DB                 push    edx             ; void *
.text$mn:000015DC                 lea     eax, [ebp-13h]
.text$mn:000015DF                 push    eax
.text$mn:000015E0                 mov     ecx, [ebp-18h]
.text$mn:000015E3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000015E8                 mov     ecx, eax
.text$mn:000015EA                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000015EF                 mov     ecx, [ebp-18h]
.text$mn:000015F2                 mov     edx, [ebp-1Ch]
.text$mn:000015F5                 mov     [ecx+18h], edx
.text$mn:000015F8                 mov     eax, [ebp+0Ch]
.text$mn:000015FB                 push    eax
.text$mn:000015FC                 mov     ecx, [ebp-18h]
.text$mn:000015FF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001604                 mov     ecx, [ebp-0Ch]
.text$mn:00001607                 mov     large fs:0, ecx
.text$mn:0000160E                 pop     ecx
.text$mn:0000160F                 pop     edi
.text$mn:00001610                 pop     esi
.text$mn:00001611                 pop     ebx
.text$mn:00001612                 mov     esp, ebp
.text$mn:00001614                 pop     ebp
.text$mn:00001615                 retn    8
.text$mn:00001615 $LN19           endp ; sp-analysis failed
.text$mn:00001615
.text$mn:00001615 _text$mn        ends
.text$mn:00001615
.text$x:00001618 ; ===========================================================================
.text$x:00001618
.text$x:00001618 ; Segment type: Pure code
.text$x:00001618 ; Segment permissions: Read/Execute
.text$x:00001618 _text$x         segment para public 'CODE' use32
.text$x:00001618                 assume cs:_text$x
.text$x:00001618                 ;org 1618h
.text$x:00001618 ; COMDAT (pick associative to section at 1474)
.text$x:00001618                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001618
.text$x:00001618 ; =============== S U B R O U T I N E =======================================
.text$x:00001618
.text$x:00001618
.text$x:00001618 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00001618                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00001618
.text$x:00001618 arg_4           = dword ptr  8
.text$x:00001618
.text$x:00001618                 mov     edx, [esp+arg_4]
.text$x:0000161C                 lea     eax, [edx+0Ch]
.text$x:0000161F                 mov     ecx, [edx-24h]
.text$x:00001622                 xor     ecx, eax
.text$x:00001624                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001629                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:0000162E                 jmp     ___CxxFrameHandler3
.text$x:0000162E __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:0000162E
.text$x:0000162E ; ---------------------------------------------------------------------------
.text$x:00001633                 align 4
.text$x:00001633 _text$x         ends
.text$x:00001633
.text$mn:00001634 ; ===========================================================================
.text$mn:00001634
.text$mn:00001634 ; Segment type: Pure code
.text$mn:00001634 ; Segment permissions: Read/Execute
.text$mn:00001634 _text$mn        segment para public 'CODE' use32
.text$mn:00001634                 assume cs:_text$mn
.text$mn:00001634                 ;org 1634h
.text$mn:00001634 ; COMDAT (pick any)
.text$mn:00001634                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001634
.text$mn:00001634 ; =============== S U B R O U T I N E =======================================
.text$mn:00001634
.text$mn:00001634 ; Attributes: bp-based frame
.text$mn:00001634
.text$mn:00001634 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00001634                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00001634 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00001634                                         ; CODE XREF: $LN19+60p
.text$mn:00001634                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00001634
.text$mn:00001634 var_8           = dword ptr -8
.text$mn:00001634 var_1           = byte ptr -1
.text$mn:00001634 arg_0           = dword ptr  8
.text$mn:00001634
.text$mn:00001634                 push    ebp
.text$mn:00001635                 mov     ebp, esp
.text$mn:00001637                 sub     esp, 8
.text$mn:0000163A                 mov     [ebp+var_8], ecx
.text$mn:0000163D                 mov     [ebp+var_1], 0
.text$mn:00001641                 mov     eax, [ebp+var_8]
.text$mn:00001644                 mov     ecx, [ebp+arg_0]
.text$mn:00001647                 mov     [eax+14h], ecx
.text$mn:0000164A                 lea     edx, [ebp+var_1]
.text$mn:0000164D                 push    edx
.text$mn:0000164E                 mov     ecx, [ebp+var_8]
.text$mn:00001651                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001656                 add     eax, [ebp+arg_0]
.text$mn:00001659                 push    eax
.text$mn:0000165A                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:0000165F                 add     esp, 8
.text$mn:00001662                 mov     esp, ebp
.text$mn:00001664                 pop     ebp
.text$mn:00001665                 retn    4
.text$mn:00001665 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00001665
.text$mn:00001665 _text$mn        ends
.text$mn:00001665
.text$mn:00001668 ; ===========================================================================
.text$mn:00001668
.text$mn:00001668 ; Segment type: Pure code
.text$mn:00001668 ; Segment permissions: Read/Execute
.text$mn:00001668 _text$mn        segment para public 'CODE' use32
.text$mn:00001668                 assume cs:_text$mn
.text$mn:00001668                 ;org 1668h
.text$mn:00001668 ; COMDAT (pick any)
.text$mn:00001668                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001668
.text$mn:00001668 ; =============== S U B R O U T I N E =======================================
.text$mn:00001668
.text$mn:00001668 ; Attributes: bp-based frame
.text$mn:00001668
.text$mn:00001668 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001668                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001668 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001668                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00001668
.text$mn:00001668 var_8           = dword ptr -8
.text$mn:00001668 var_1           = byte ptr -1
.text$mn:00001668
.text$mn:00001668                 push    ebp
.text$mn:00001669                 mov     ebp, esp
.text$mn:0000166B                 sub     esp, 8
.text$mn:0000166E                 mov     [ebp+var_8], ecx
.text$mn:00001671                 lea     ecx, [ebp+var_1]
.text$mn:00001674                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001679                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000167C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001681                 mov     eax, [ebp+var_8]
.text$mn:00001684                 mov     ecx, [eax]
.text$mn:00001686                 push    ecx
.text$mn:00001687                 lea     ecx, [ebp+var_1]
.text$mn:0000168A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000168F                 push    1               ; int
.text$mn:00001691                 mov     edx, [ebp+var_8]
.text$mn:00001694                 mov     eax, [edx]
.text$mn:00001696                 push    eax             ; void *
.text$mn:00001697                 lea     ecx, [ebp+var_1]
.text$mn:0000169A                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000169F                 mov     ecx, [ebp+var_8]
.text$mn:000016A2                 mov     dword ptr [ecx], 0
.text$mn:000016A8                 mov     esp, ebp
.text$mn:000016AA                 pop     ebp
.text$mn:000016AB                 retn
.text$mn:000016AB ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000016AB
.text$mn:000016AB _text$mn        ends
.text$mn:000016AB
.text$mn:000016AC ; ===========================================================================
.text$mn:000016AC
.text$mn:000016AC ; Segment type: Pure code
.text$mn:000016AC ; Segment permissions: Read/Execute
.text$mn:000016AC _text$mn        segment para public 'CODE' use32
.text$mn:000016AC                 assume cs:_text$mn
.text$mn:000016AC                 ;org 16ACh
.text$mn:000016AC ; COMDAT (pick any)
.text$mn:000016AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000016AC
.text$mn:000016AC ; =============== S U B R O U T I N E =======================================
.text$mn:000016AC
.text$mn:000016AC ; Attributes: bp-based frame
.text$mn:000016AC
.text$mn:000016AC ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:000016AC                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:000016AC ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:000016AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:000016AC                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:000016AC
.text$mn:000016AC var_4           = dword ptr -4
.text$mn:000016AC arg_0           = dword ptr  8
.text$mn:000016AC
.text$mn:000016AC                 push    ebp
.text$mn:000016AD                 mov     ebp, esp
.text$mn:000016AF                 push    ecx
.text$mn:000016B0                 mov     [ebp+var_4], ecx
.text$mn:000016B3                 mov     ecx, [ebp+arg_0]
.text$mn:000016B6                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:000016BB                 mov     eax, [ebp+arg_0]
.text$mn:000016BE                 mov     esp, ebp
.text$mn:000016C0                 pop     ebp
.text$mn:000016C1                 retn    4
.text$mn:000016C1 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:000016C1
.text$mn:000016C1 _text$mn        ends
.text$mn:000016C1
.text$mn:000016C4 ; ===========================================================================
.text$mn:000016C4
.text$mn:000016C4 ; Segment type: Pure code
.text$mn:000016C4 ; Segment permissions: Read/Execute
.text$mn:000016C4 _text$mn        segment para public 'CODE' use32
.text$mn:000016C4                 assume cs:_text$mn
.text$mn:000016C4                 ;org 16C4h
.text$mn:000016C4 ; COMDAT (pick any)
.text$mn:000016C4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000016C4
.text$mn:000016C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000016C4
.text$mn:000016C4 ; Attributes: bp-based frame
.text$mn:000016C4
.text$mn:000016C4 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:000016C4                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:000016C4 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:000016C4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:000016C4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:000016C4
.text$mn:000016C4 var_C           = dword ptr -0Ch
.text$mn:000016C4 Size            = dword ptr -8
.text$mn:000016C4 var_4           = dword ptr -4
.text$mn:000016C4 arg_0           = dword ptr  8
.text$mn:000016C4 arg_4           = byte ptr  0Ch
.text$mn:000016C4
.text$mn:000016C4                 push    ebp
.text$mn:000016C5                 mov     ebp, esp
.text$mn:000016C7                 sub     esp, 0Ch
.text$mn:000016CA                 mov     [ebp+var_4], ecx
.text$mn:000016CD                 mov     ecx, [ebp+var_4]
.text$mn:000016D0                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000016D5                 cmp     eax, [ebp+arg_0]
.text$mn:000016D8                 jnb     short loc_16E2
.text$mn:000016DA                 mov     ecx, [ebp+var_4]
.text$mn:000016DD                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:000016E2
.text$mn:000016E2 loc_16E2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:000016E2                 mov     eax, [ebp+var_4]
.text$mn:000016E5                 mov     ecx, [eax+18h]
.text$mn:000016E8                 cmp     ecx, [ebp+arg_0]
.text$mn:000016EB                 jnb     short loc_1702
.text$mn:000016ED                 mov     edx, [ebp+var_4]
.text$mn:000016F0                 mov     eax, [edx+14h]
.text$mn:000016F3                 push    eax
.text$mn:000016F4                 mov     ecx, [ebp+arg_0]
.text$mn:000016F7                 push    ecx
.text$mn:000016F8                 mov     ecx, [ebp+var_4]
.text$mn:000016FB                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00001700                 jmp     short loc_174C
.text$mn:00001702 ; ---------------------------------------------------------------------------
.text$mn:00001702
.text$mn:00001702 loc_1702:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00001702                 movzx   edx, [ebp+arg_4]
.text$mn:00001706                 test    edx, edx
.text$mn:00001708                 jz      short loc_173C
.text$mn:0000170A                 cmp     [ebp+arg_0], 10h
.text$mn:0000170E                 jnb     short loc_173C
.text$mn:00001710                 mov     eax, [ebp+var_4]
.text$mn:00001713                 mov     ecx, [ebp+arg_0]
.text$mn:00001716                 cmp     ecx, [eax+14h]
.text$mn:00001719                 jnb     short loc_1723
.text$mn:0000171B                 mov     edx, [ebp+arg_0]
.text$mn:0000171E                 mov     [ebp+Size], edx
.text$mn:00001721                 jmp     short loc_172C
.text$mn:00001723 ; ---------------------------------------------------------------------------
.text$mn:00001723
.text$mn:00001723 loc_1723:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00001723                 mov     eax, [ebp+var_4]
.text$mn:00001726                 mov     ecx, [eax+14h]
.text$mn:00001729                 mov     [ebp+Size], ecx
.text$mn:0000172C
.text$mn:0000172C loc_172C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:0000172C                 mov     edx, [ebp+Size]
.text$mn:0000172F                 push    edx             ; Size
.text$mn:00001730                 push    1               ; char
.text$mn:00001732                 mov     ecx, [ebp+var_4]
.text$mn:00001735                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000173A                 jmp     short loc_174C
.text$mn:0000173C ; ---------------------------------------------------------------------------
.text$mn:0000173C
.text$mn:0000173C loc_173C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:0000173C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:0000173C                 cmp     [ebp+arg_0], 0
.text$mn:00001740                 jnz     short loc_174C
.text$mn:00001742                 push    0
.text$mn:00001744                 mov     ecx, [ebp+var_4]
.text$mn:00001747                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000174C
.text$mn:0000174C loc_174C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:0000174C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:0000174C                 cmp     [ebp+arg_0], 0
.text$mn:00001750                 jbe     short loc_175B
.text$mn:00001752                 mov     [ebp+var_C], 1
.text$mn:00001759                 jmp     short loc_1762
.text$mn:0000175B ; ---------------------------------------------------------------------------
.text$mn:0000175B
.text$mn:0000175B loc_175B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000175B                 mov     [ebp+var_C], 0
.text$mn:00001762
.text$mn:00001762 loc_1762:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00001762                 mov     al, byte ptr [ebp+var_C]
.text$mn:00001765                 mov     esp, ebp
.text$mn:00001767                 pop     ebp
.text$mn:00001768                 retn    8
.text$mn:00001768 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00001768
.text$mn:00001768 ; ---------------------------------------------------------------------------
.text$mn:0000176B                 align 4
.text$mn:0000176B _text$mn        ends
.text$mn:0000176B
.text$mn:0000176C ; ===========================================================================
.text$mn:0000176C
.text$mn:0000176C ; Segment type: Pure code
.text$mn:0000176C ; Segment permissions: Read/Execute
.text$mn:0000176C _text$mn        segment para public 'CODE' use32
.text$mn:0000176C                 assume cs:_text$mn
.text$mn:0000176C                 ;org 176Ch
.text$mn:0000176C ; COMDAT (pick any)
.text$mn:0000176C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000176C
.text$mn:0000176C ; =============== S U B R O U T I N E =======================================
.text$mn:0000176C
.text$mn:0000176C ; Attributes: bp-based frame
.text$mn:0000176C
.text$mn:0000176C ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:0000176C                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:0000176C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:0000176C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:0000176C
.text$mn:0000176C var_4           = dword ptr -4
.text$mn:0000176C arg_0           = dword ptr  8
.text$mn:0000176C
.text$mn:0000176C                 push    ebp
.text$mn:0000176D                 mov     ebp, esp
.text$mn:0000176F                 push    ecx
.text$mn:00001770                 mov     [ebp+var_4], ecx
.text$mn:00001773                 cmp     [ebp+arg_0], 0
.text$mn:00001777                 jz      short loc_1799
.text$mn:00001779                 mov     ecx, [ebp+var_4]
.text$mn:0000177C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001781                 cmp     [ebp+arg_0], eax
.text$mn:00001784                 jb      short loc_1799
.text$mn:00001786                 mov     ecx, [ebp+var_4]
.text$mn:00001789                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000178E                 mov     ecx, [ebp+var_4]
.text$mn:00001791                 add     eax, [ecx+14h]
.text$mn:00001794                 cmp     eax, [ebp+arg_0]
.text$mn:00001797                 ja      short loc_179F
.text$mn:00001799
.text$mn:00001799 loc_1799:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00001799                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00001799                 xor     al, al
.text$mn:0000179B                 jmp     short loc_17A1
.text$mn:0000179D ; ---------------------------------------------------------------------------
.text$mn:0000179D                 jmp     short loc_17A1
.text$mn:0000179F ; ---------------------------------------------------------------------------
.text$mn:0000179F
.text$mn:0000179F loc_179F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000179F                 mov     al, 1
.text$mn:000017A1
.text$mn:000017A1 loc_17A1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000017A1                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000017A1                 mov     esp, ebp
.text$mn:000017A3                 pop     ebp
.text$mn:000017A4                 retn    4
.text$mn:000017A4 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000017A4
.text$mn:000017A4 ; ---------------------------------------------------------------------------
.text$mn:000017A7                 align 4
.text$mn:000017A7 _text$mn        ends
.text$mn:000017A7
.text$mn:000017A8 ; ===========================================================================
.text$mn:000017A8
.text$mn:000017A8 ; Segment type: Pure code
.text$mn:000017A8 ; Segment permissions: Read/Execute
.text$mn:000017A8 _text$mn        segment para public 'CODE' use32
.text$mn:000017A8                 assume cs:_text$mn
.text$mn:000017A8                 ;org 17A8h
.text$mn:000017A8 ; COMDAT (pick any)
.text$mn:000017A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000017A8
.text$mn:000017A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000017A8
.text$mn:000017A8 ; Attributes: bp-based frame
.text$mn:000017A8
.text$mn:000017A8 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:000017A8                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:000017A8 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:000017A8                                         ; CODE XREF: $LN19+14p
.text$mn:000017A8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:000017A8
.text$mn:000017A8 var_8           = dword ptr -8
.text$mn:000017A8 var_4           = dword ptr -4
.text$mn:000017A8
.text$mn:000017A8                 push    ebp
.text$mn:000017A9                 mov     ebp, esp
.text$mn:000017AB                 sub     esp, 8
.text$mn:000017AE                 mov     [ebp+var_4], ecx
.text$mn:000017B1                 mov     eax, [ebp+var_4]
.text$mn:000017B4                 cmp     dword ptr [eax+18h], 10h
.text$mn:000017B8                 jb      short loc_17CE
.text$mn:000017BA                 mov     ecx, [ebp+var_4]
.text$mn:000017BD                 mov     edx, [ecx+4]
.text$mn:000017C0                 push    edx
.text$mn:000017C1                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000017C6                 add     esp, 4
.text$mn:000017C9                 mov     [ebp+var_8], eax
.text$mn:000017CC                 jmp     short loc_17D7
.text$mn:000017CE ; ---------------------------------------------------------------------------
.text$mn:000017CE
.text$mn:000017CE loc_17CE:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000017CE                 mov     eax, [ebp+var_4]
.text$mn:000017D1                 add     eax, 4
.text$mn:000017D4                 mov     [ebp+var_8], eax
.text$mn:000017D7
.text$mn:000017D7 loc_17D7:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000017D7                 mov     eax, [ebp+var_8]
.text$mn:000017DA                 mov     esp, ebp
.text$mn:000017DC                 pop     ebp
.text$mn:000017DD                 retn
.text$mn:000017DD ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:000017DD
.text$mn:000017DD ; ---------------------------------------------------------------------------
.text$mn:000017DE                 align 10h
.text$mn:000017DE _text$mn        ends
.text$mn:000017DE
.text$mn:000017E0 ; ===========================================================================
.text$mn:000017E0
.text$mn:000017E0 ; Segment type: Pure code
.text$mn:000017E0 ; Segment permissions: Read/Execute
.text$mn:000017E0 _text$mn        segment para public 'CODE' use32
.text$mn:000017E0                 assume cs:_text$mn
.text$mn:000017E0                 ;org 17E0h
.text$mn:000017E0 ; COMDAT (pick any)
.text$mn:000017E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000017E0
.text$mn:000017E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000017E0
.text$mn:000017E0 ; Attributes: bp-based frame
.text$mn:000017E0
.text$mn:000017E0 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:000017E0                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:000017E0 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:000017E0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:000017E0
.text$mn:000017E0 var_8           = dword ptr -8
.text$mn:000017E0 var_4           = dword ptr -4
.text$mn:000017E0
.text$mn:000017E0                 push    ebp
.text$mn:000017E1                 mov     ebp, esp
.text$mn:000017E3                 sub     esp, 8
.text$mn:000017E6                 mov     [ebp+var_4], ecx
.text$mn:000017E9                 mov     eax, [ebp+var_4]
.text$mn:000017EC                 cmp     dword ptr [eax+18h], 10h
.text$mn:000017F0                 jb      short loc_1806
.text$mn:000017F2                 mov     ecx, [ebp+var_4]
.text$mn:000017F5                 mov     edx, [ecx+4]
.text$mn:000017F8                 push    edx
.text$mn:000017F9                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000017FE                 add     esp, 4
.text$mn:00001801                 mov     [ebp+var_8], eax
.text$mn:00001804                 jmp     short loc_180F
.text$mn:00001806 ; ---------------------------------------------------------------------------
.text$mn:00001806
.text$mn:00001806 loc_1806:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00001806                 mov     eax, [ebp+var_4]
.text$mn:00001809                 add     eax, 4
.text$mn:0000180C                 mov     [ebp+var_8], eax
.text$mn:0000180F
.text$mn:0000180F loc_180F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000180F                 mov     eax, [ebp+var_8]
.text$mn:00001812                 mov     esp, ebp
.text$mn:00001814                 pop     ebp
.text$mn:00001815                 retn
.text$mn:00001815 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00001815
.text$mn:00001815 ; ---------------------------------------------------------------------------
.text$mn:00001816                 align 4
.text$mn:00001816 _text$mn        ends
.text$mn:00001816
.text$mn:00001818 ; ===========================================================================
.text$mn:00001818
.text$mn:00001818 ; Segment type: Pure code
.text$mn:00001818 ; Segment permissions: Read/Execute
.text$mn:00001818 _text$mn        segment para public 'CODE' use32
.text$mn:00001818                 assume cs:_text$mn
.text$mn:00001818                 ;org 1818h
.text$mn:00001818 ; COMDAT (pick any)
.text$mn:00001818                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001818
.text$mn:00001818 ; =============== S U B R O U T I N E =======================================
.text$mn:00001818
.text$mn:00001818 ; Attributes: bp-based frame
.text$mn:00001818
.text$mn:00001818 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00001818                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001818 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00001818                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00001818                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:00001818
.text$mn:00001818 var_18          = byte ptr -18h
.text$mn:00001818 var_14          = dword ptr -14h
.text$mn:00001818 var_10          = dword ptr -10h
.text$mn:00001818 var_C           = dword ptr -0Ch
.text$mn:00001818 var_4           = dword ptr -4
.text$mn:00001818
.text$mn:00001818                 push    ebp
.text$mn:00001819                 mov     ebp, esp
.text$mn:0000181B                 push    0FFFFFFFFh
.text$mn:0000181D                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001822                 mov     eax, large fs:0
.text$mn:00001828                 push    eax
.text$mn:00001829                 sub     esp, 0Ch
.text$mn:0000182C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001831                 xor     eax, ebp
.text$mn:00001833                 push    eax
.text$mn:00001834                 lea     eax, [ebp+var_C]
.text$mn:00001837                 mov     large fs:0, eax
.text$mn:0000183D                 mov     [ebp+var_14], ecx
.text$mn:00001840                 mov     eax, [ebp+var_14]
.text$mn:00001843                 cmp     dword ptr [eax], 0
.text$mn:00001846                 jz      short loc_18A3
.text$mn:00001848                 push    3               ; int
.text$mn:0000184A                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000184D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00001852                 mov     [ebp+var_4], 0
.text$mn:00001859                 mov     ecx, [ebp+var_14]
.text$mn:0000185C                 mov     edx, [ecx]
.text$mn:0000185E                 add     edx, 4
.text$mn:00001861                 mov     [ebp+var_10], edx
.text$mn:00001864                 jmp     short loc_1873
.text$mn:00001866 ; ---------------------------------------------------------------------------
.text$mn:00001866
.text$mn:00001866 loc_1866:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00001866                 mov     eax, [ebp+var_10]
.text$mn:00001869                 mov     ecx, [eax]
.text$mn:0000186B                 mov     edx, [ebp+var_10]
.text$mn:0000186E                 mov     eax, [ecx+4]
.text$mn:00001871                 mov     [edx], eax
.text$mn:00001873
.text$mn:00001873 loc_1873:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00001873                 mov     ecx, [ebp+var_10]
.text$mn:00001876                 cmp     dword ptr [ecx], 0
.text$mn:00001879                 jz      short loc_1888
.text$mn:0000187B                 mov     edx, [ebp+var_10]
.text$mn:0000187E                 mov     eax, [edx]
.text$mn:00001880                 mov     dword ptr [eax], 0
.text$mn:00001886                 jmp     short loc_1866
.text$mn:00001888 ; ---------------------------------------------------------------------------
.text$mn:00001888
.text$mn:00001888 loc_1888:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00001888                 mov     ecx, [ebp+var_14]
.text$mn:0000188B                 mov     edx, [ecx]
.text$mn:0000188D                 mov     dword ptr [edx+4], 0
.text$mn:00001894                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000189B                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000189E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000018A3
.text$mn:000018A3 loc_18A3:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000018A3                 mov     ecx, [ebp+var_C]
.text$mn:000018A6                 mov     large fs:0, ecx
.text$mn:000018AD                 pop     ecx
.text$mn:000018AE                 mov     esp, ebp
.text$mn:000018B0                 pop     ebp
.text$mn:000018B1                 retn
.text$mn:000018B1 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000018B1
.text$mn:000018B1 ; ---------------------------------------------------------------------------
.text$mn:000018B2                 align 4
.text$mn:000018B2 _text$mn        ends
.text$mn:000018B2
.text$x:000018B4 ; ===========================================================================
.text$x:000018B4
.text$x:000018B4 ; Segment type: Pure code
.text$x:000018B4 ; Segment permissions: Read/Execute
.text$x:000018B4 _text$x         segment para public 'CODE' use32
.text$x:000018B4                 assume cs:_text$x
.text$x:000018B4                 ;org 18B4h
.text$x:000018B4 ; COMDAT (pick associative to section at 1818)
.text$x:000018B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000018B4
.text$x:000018B4 ; =============== S U B R O U T I N E =======================================
.text$x:000018B4
.text$x:000018B4
.text$x:000018B4 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000018B4                                         ; DATA XREF: .xdata$x:000021B4o
.text$x:000018B4                 lea     ecx, [ebp-18h]  ; this
.text$x:000018B7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000018B7 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000018B7
.text$x:000018BC
.text$x:000018BC ; =============== S U B R O U T I N E =======================================
.text$x:000018BC
.text$x:000018BC
.text$x:000018BC __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:000018BC                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:000018BC
.text$x:000018BC arg_4           = dword ptr  8
.text$x:000018BC
.text$x:000018BC                 mov     edx, [esp+arg_4]
.text$x:000018C0                 lea     eax, [edx+0Ch]
.text$x:000018C3                 mov     ecx, [edx-10h]
.text$x:000018C6                 xor     ecx, eax
.text$x:000018C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000018CD                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:000018D2                 jmp     ___CxxFrameHandler3
.text$x:000018D2 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:000018D2
.text$x:000018D2 ; ---------------------------------------------------------------------------
.text$x:000018D7                 align 4
.text$x:000018D7 _text$x         ends
.text$x:000018D7
.text$mn:000018D8 ; ===========================================================================
.text$mn:000018D8
.text$mn:000018D8 ; Segment type: Pure code
.text$mn:000018D8 ; Segment permissions: Read/Execute
.text$mn:000018D8 _text$mn        segment para public 'CODE' use32
.text$mn:000018D8                 assume cs:_text$mn
.text$mn:000018D8                 ;org 18D8h
.text$mn:000018D8 ; COMDAT (pick any)
.text$mn:000018D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000018D8
.text$mn:000018D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000018D8
.text$mn:000018D8 ; Attributes: bp-based frame
.text$mn:000018D8
.text$mn:000018D8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:000018D8                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:000018D8 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:000018D8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:000018D8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:000018D8
.text$mn:000018D8 var_C           = dword ptr -0Ch
.text$mn:000018D8 var_8           = dword ptr -8
.text$mn:000018D8 var_2           = byte ptr -2
.text$mn:000018D8 var_1           = byte ptr -1
.text$mn:000018D8 arg_0           = byte ptr  8
.text$mn:000018D8 Size            = dword ptr  0Ch
.text$mn:000018D8
.text$mn:000018D8                 push    ebp
.text$mn:000018D9                 mov     ebp, esp
.text$mn:000018DB                 sub     esp, 0Ch
.text$mn:000018DE                 mov     [ebp+var_8], ecx
.text$mn:000018E1                 movzx   eax, [ebp+arg_0]
.text$mn:000018E5                 test    eax, eax
.text$mn:000018E7                 jnz     short loc_18EB
.text$mn:000018E9                 jmp     short loc_195E
.text$mn:000018EB ; ---------------------------------------------------------------------------
.text$mn:000018EB
.text$mn:000018EB loc_18EB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:000018EB                 mov     ecx, [ebp+var_8]
.text$mn:000018EE                 cmp     dword ptr [ecx+18h], 10h
.text$mn:000018F2                 jb      short loc_195E
.text$mn:000018F4                 mov     edx, [ebp+var_8]
.text$mn:000018F7                 mov     eax, [edx+4]
.text$mn:000018FA                 mov     [ebp+var_C], eax
.text$mn:000018FD                 mov     ecx, [ebp+var_8]
.text$mn:00001900                 add     ecx, 4
.text$mn:00001903                 push    ecx
.text$mn:00001904                 lea     edx, [ebp+var_1]
.text$mn:00001907                 push    edx
.text$mn:00001908                 mov     ecx, [ebp+var_8]
.text$mn:0000190B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001910                 mov     ecx, eax
.text$mn:00001912                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001917                 cmp     [ebp+Size], 0
.text$mn:0000191B                 jbe     short loc_193D
.text$mn:0000191D                 mov     eax, [ebp+Size]
.text$mn:00001920                 push    eax             ; Size
.text$mn:00001921                 mov     ecx, [ebp+var_C]
.text$mn:00001924                 push    ecx
.text$mn:00001925                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000192A                 add     esp, 4
.text$mn:0000192D                 push    eax             ; Src
.text$mn:0000192E                 mov     edx, [ebp+var_8]
.text$mn:00001931                 add     edx, 4
.text$mn:00001934                 push    edx             ; Dst
.text$mn:00001935                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000193A                 add     esp, 0Ch
.text$mn:0000193D
.text$mn:0000193D loc_193D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:0000193D                 mov     eax, [ebp+var_8]
.text$mn:00001940                 mov     ecx, [eax+18h]
.text$mn:00001943                 add     ecx, 1
.text$mn:00001946                 push    ecx             ; int
.text$mn:00001947                 mov     edx, [ebp+var_C]
.text$mn:0000194A                 push    edx             ; void *
.text$mn:0000194B                 lea     eax, [ebp+var_2]
.text$mn:0000194E                 push    eax
.text$mn:0000194F                 mov     ecx, [ebp+var_8]
.text$mn:00001952                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001957                 mov     ecx, eax
.text$mn:00001959                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:0000195E
.text$mn:0000195E loc_195E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:0000195E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:0000195E                 mov     ecx, [ebp+var_8]
.text$mn:00001961                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00001968                 mov     edx, [ebp+Size]
.text$mn:0000196B                 push    edx
.text$mn:0000196C                 mov     ecx, [ebp+var_8]
.text$mn:0000196F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001974                 mov     esp, ebp
.text$mn:00001976                 pop     ebp
.text$mn:00001977                 retn    8
.text$mn:00001977 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00001977
.text$mn:00001977 ; ---------------------------------------------------------------------------
.text$mn:0000197A                 align 4
.text$mn:0000197A _text$mn        ends
.text$mn:0000197A
.text$mn:0000197C ; ===========================================================================
.text$mn:0000197C
.text$mn:0000197C ; Segment type: Pure code
.text$mn:0000197C ; Segment permissions: Read/Execute
.text$mn:0000197C _text$mn        segment para public 'CODE' use32
.text$mn:0000197C                 assume cs:_text$mn
.text$mn:0000197C                 ;org 197Ch
.text$mn:0000197C ; COMDAT (pick any)
.text$mn:0000197C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000197C
.text$mn:0000197C ; =============== S U B R O U T I N E =======================================
.text$mn:0000197C
.text$mn:0000197C ; Attributes: bp-based frame
.text$mn:0000197C
.text$mn:0000197C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:0000197C                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:0000197C ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:0000197C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:0000197C
.text$mn:0000197C var_4           = dword ptr -4
.text$mn:0000197C
.text$mn:0000197C                 push    ebp
.text$mn:0000197D                 mov     ebp, esp
.text$mn:0000197F                 push    ecx
.text$mn:00001980                 mov     [ebp+var_4], ecx
.text$mn:00001983                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00001988                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000198D                 mov     esp, ebp
.text$mn:0000198F                 pop     ebp
.text$mn:00001990                 retn
.text$mn:00001990 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00001990
.text$mn:00001990 ; ---------------------------------------------------------------------------
.text$mn:00001991                 align 4
.text$mn:00001991 _text$mn        ends
.text$mn:00001991
.text$mn:00001994 ; ===========================================================================
.text$mn:00001994
.text$mn:00001994 ; Segment type: Pure code
.text$mn:00001994 ; Segment permissions: Read/Execute
.text$mn:00001994 _text$mn        segment para public 'CODE' use32
.text$mn:00001994                 assume cs:_text$mn
.text$mn:00001994                 ;org 1994h
.text$mn:00001994 ; COMDAT (pick any)
.text$mn:00001994                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001994
.text$mn:00001994 ; =============== S U B R O U T I N E =======================================
.text$mn:00001994
.text$mn:00001994 ; Attributes: bp-based frame
.text$mn:00001994
.text$mn:00001994 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00001994                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00001994 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00001994                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00001994                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00001994
.text$mn:00001994 var_4           = dword ptr -4
.text$mn:00001994
.text$mn:00001994                 push    ebp
.text$mn:00001995                 mov     ebp, esp
.text$mn:00001997                 push    ecx
.text$mn:00001998                 mov     [ebp+var_4], ecx
.text$mn:0000199B                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:000019A0                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:000019A5                 mov     esp, ebp
.text$mn:000019A7                 pop     ebp
.text$mn:000019A8                 retn
.text$mn:000019A8 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000019A8
.text$mn:000019A8 ; ---------------------------------------------------------------------------
.text$mn:000019A9                 align 4
.text$mn:000019A9 _text$mn        ends
.text$mn:000019A9
.text$mn:000019AC ; ===========================================================================
.text$mn:000019AC
.text$mn:000019AC ; Segment type: Pure code
.text$mn:000019AC ; Segment permissions: Read/Execute
.text$mn:000019AC _text$mn        segment para public 'CODE' use32
.text$mn:000019AC                 assume cs:_text$mn
.text$mn:000019AC                 ;org 19ACh
.text$mn:000019AC ; COMDAT (pick any)
.text$mn:000019AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000019AC
.text$mn:000019AC ; =============== S U B R O U T I N E =======================================
.text$mn:000019AC
.text$mn:000019AC ; Attributes: bp-based frame
.text$mn:000019AC
.text$mn:000019AC ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:000019AC                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:000019AC ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:000019AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:000019AC                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:000019AC
.text$mn:000019AC var_4           = dword ptr -4
.text$mn:000019AC arg_0           = dword ptr  8
.text$mn:000019AC
.text$mn:000019AC                 push    ebp
.text$mn:000019AD                 mov     ebp, esp
.text$mn:000019AF                 push    ecx
.text$mn:000019B0                 mov     [ebp+var_4], ecx
.text$mn:000019B3                 mov     eax, [ebp+arg_0]
.text$mn:000019B6                 push    eax
.text$mn:000019B7                 mov     ecx, [ebp+var_4]
.text$mn:000019BA                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:000019BF                 mov     esp, ebp
.text$mn:000019C1                 pop     ebp
.text$mn:000019C2                 retn    4
.text$mn:000019C2 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:000019C2
.text$mn:000019C2 ; ---------------------------------------------------------------------------
.text$mn:000019C5                 align 4
.text$mn:000019C5 _text$mn        ends
.text$mn:000019C5
.text$mn:000019C8 ; ===========================================================================
.text$mn:000019C8
.text$mn:000019C8 ; Segment type: Pure code
.text$mn:000019C8 ; Segment permissions: Read/Execute
.text$mn:000019C8 _text$mn        segment para public 'CODE' use32
.text$mn:000019C8                 assume cs:_text$mn
.text$mn:000019C8                 ;org 19C8h
.text$mn:000019C8 ; COMDAT (pick any)
.text$mn:000019C8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000019C8
.text$mn:000019C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000019C8
.text$mn:000019C8 ; Attributes: bp-based frame
.text$mn:000019C8
.text$mn:000019C8 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:000019C8                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:000019C8 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:000019C8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:000019C8
.text$mn:000019C8 var_4           = dword ptr -4
.text$mn:000019C8 arg_0           = dword ptr  8
.text$mn:000019C8
.text$mn:000019C8                 push    ebp
.text$mn:000019C9                 mov     ebp, esp
.text$mn:000019CB                 push    ecx
.text$mn:000019CC                 mov     [ebp+var_4], ecx
.text$mn:000019CF                 push    0
.text$mn:000019D1                 mov     eax, [ebp+arg_0]
.text$mn:000019D4                 push    eax
.text$mn:000019D5                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:000019DA                 add     esp, 8
.text$mn:000019DD                 mov     esp, ebp
.text$mn:000019DF                 pop     ebp
.text$mn:000019E0                 retn    4
.text$mn:000019E0 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:000019E0
.text$mn:000019E0 ; ---------------------------------------------------------------------------
.text$mn:000019E3                 align 4
.text$mn:000019E3 _text$mn        ends
.text$mn:000019E3
.text$mn:000019E4 ; ===========================================================================
.text$mn:000019E4
.text$mn:000019E4 ; Segment type: Pure code
.text$mn:000019E4 ; Segment permissions: Read/Execute
.text$mn:000019E4 _text$mn        segment para public 'CODE' use32
.text$mn:000019E4                 assume cs:_text$mn
.text$mn:000019E4                 ;org 19E4h
.text$mn:000019E4 ; COMDAT (pick any)
.text$mn:000019E4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000019E4
.text$mn:000019E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000019E4
.text$mn:000019E4 ; Attributes: bp-based frame
.text$mn:000019E4
.text$mn:000019E4 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:000019E4                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000019E4 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000019E4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:000019E4
.text$mn:000019E4 var_4           = dword ptr -4
.text$mn:000019E4 arg_0           = dword ptr  8
.text$mn:000019E4
.text$mn:000019E4                 push    ebp
.text$mn:000019E5                 mov     ebp, esp
.text$mn:000019E7                 push    ecx
.text$mn:000019E8                 mov     [ebp+var_4], ecx
.text$mn:000019EB                 push    0
.text$mn:000019ED                 mov     eax, [ebp+arg_0]
.text$mn:000019F0                 push    eax
.text$mn:000019F1                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:000019F6                 add     esp, 8
.text$mn:000019F9                 mov     esp, ebp
.text$mn:000019FB                 pop     ebp
.text$mn:000019FC                 retn    4
.text$mn:000019FC ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:000019FC
.text$mn:000019FC ; ---------------------------------------------------------------------------
.text$mn:000019FF                 align 10h
.text$mn:000019FF _text$mn        ends
.text$mn:000019FF
.text$mn:00001A00 ; ===========================================================================
.text$mn:00001A00
.text$mn:00001A00 ; Segment type: Pure code
.text$mn:00001A00 ; Segment permissions: Read/Execute
.text$mn:00001A00 _text$mn        segment para public 'CODE' use32
.text$mn:00001A00                 assume cs:_text$mn
.text$mn:00001A00                 ;org 1A00h
.text$mn:00001A00 ; COMDAT (pick any)
.text$mn:00001A00                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A00
.text$mn:00001A00 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A00
.text$mn:00001A00 ; Attributes: bp-based frame
.text$mn:00001A00
.text$mn:00001A00 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00001A00                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001A00 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001A00                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00001A00
.text$mn:00001A00 Size            = dword ptr -8
.text$mn:00001A00 var_4           = dword ptr -4
.text$mn:00001A00 arg_0           = dword ptr  8
.text$mn:00001A00 arg_4           = dword ptr  0Ch
.text$mn:00001A00 arg_8           = dword ptr  10h
.text$mn:00001A00
.text$mn:00001A00                 push    ebp
.text$mn:00001A01                 mov     ebp, esp
.text$mn:00001A03                 sub     esp, 8
.text$mn:00001A06                 mov     [ebp+var_4], ecx
.text$mn:00001A09                 mov     ecx, [ebp+arg_0]
.text$mn:00001A0C                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001A11                 cmp     eax, [ebp+arg_4]
.text$mn:00001A14                 jnb     short loc_1A1E
.text$mn:00001A16                 mov     ecx, [ebp+var_4]
.text$mn:00001A19                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001A1E
.text$mn:00001A1E loc_1A1E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00001A1E                 mov     ecx, [ebp+arg_0]
.text$mn:00001A21                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001A26                 sub     eax, [ebp+arg_4]
.text$mn:00001A29                 mov     [ebp+Size], eax
.text$mn:00001A2C                 mov     eax, [ebp+arg_8]
.text$mn:00001A2F                 cmp     eax, [ebp+Size]
.text$mn:00001A32                 jnb     short loc_1A3A
.text$mn:00001A34                 mov     ecx, [ebp+arg_8]
.text$mn:00001A37                 mov     [ebp+Size], ecx
.text$mn:00001A3A
.text$mn:00001A3A loc_1A3A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00001A3A                 mov     edx, [ebp+var_4]
.text$mn:00001A3D                 cmp     edx, [ebp+arg_0]
.text$mn:00001A40                 jnz     short loc_1A61
.text$mn:00001A42                 mov     eax, [ebp+arg_4]
.text$mn:00001A45                 add     eax, [ebp+Size]
.text$mn:00001A48                 push    eax
.text$mn:00001A49                 mov     ecx, [ebp+var_4]
.text$mn:00001A4C                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00001A51                 mov     ecx, [ebp+arg_4]
.text$mn:00001A54                 push    ecx
.text$mn:00001A55                 push    0
.text$mn:00001A57                 mov     ecx, [ebp+var_4]
.text$mn:00001A5A                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00001A5F                 jmp     short loc_1AA3
.text$mn:00001A61 ; ---------------------------------------------------------------------------
.text$mn:00001A61
.text$mn:00001A61 loc_1A61:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00001A61                 push    0
.text$mn:00001A63                 mov     edx, [ebp+Size]
.text$mn:00001A66                 push    edx
.text$mn:00001A67                 mov     ecx, [ebp+var_4]
.text$mn:00001A6A                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001A6F                 movzx   eax, al
.text$mn:00001A72                 test    eax, eax
.text$mn:00001A74                 jz      short loc_1AA3
.text$mn:00001A76                 mov     ecx, [ebp+Size]
.text$mn:00001A79                 push    ecx             ; Size
.text$mn:00001A7A                 mov     ecx, [ebp+arg_0]
.text$mn:00001A7D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001A82                 add     eax, [ebp+arg_4]
.text$mn:00001A85                 push    eax             ; Src
.text$mn:00001A86                 mov     ecx, [ebp+var_4]
.text$mn:00001A89                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001A8E                 push    eax             ; Dst
.text$mn:00001A8F                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001A94                 add     esp, 0Ch
.text$mn:00001A97                 mov     edx, [ebp+Size]
.text$mn:00001A9A                 push    edx
.text$mn:00001A9B                 mov     ecx, [ebp+var_4]
.text$mn:00001A9E                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001AA3
.text$mn:00001AA3 loc_1AA3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00001AA3                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00001AA3                 mov     eax, [ebp+var_4]
.text$mn:00001AA6                 mov     esp, ebp
.text$mn:00001AA8                 pop     ebp
.text$mn:00001AA9                 retn    0Ch
.text$mn:00001AA9 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00001AA9
.text$mn:00001AA9 _text$mn        ends
.text$mn:00001AA9
.text$mn:00001AAC ; ===========================================================================
.text$mn:00001AAC
.text$mn:00001AAC ; Segment type: Pure code
.text$mn:00001AAC ; Segment permissions: Read/Execute
.text$mn:00001AAC _text$mn        segment para public 'CODE' use32
.text$mn:00001AAC                 assume cs:_text$mn
.text$mn:00001AAC                 ;org 1AACh
.text$mn:00001AAC ; COMDAT (pick any)
.text$mn:00001AAC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001AAC
.text$mn:00001AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00001AAC
.text$mn:00001AAC ; Attributes: bp-based frame
.text$mn:00001AAC
.text$mn:00001AAC ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00001AAC                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00001AAC ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00001AAC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00001AAC
.text$mn:00001AAC var_4           = dword ptr -4
.text$mn:00001AAC Str             = dword ptr  8
.text$mn:00001AAC
.text$mn:00001AAC                 push    ebp
.text$mn:00001AAD                 mov     ebp, esp
.text$mn:00001AAF                 push    ecx
.text$mn:00001AB0                 mov     [ebp+var_4], ecx
.text$mn:00001AB3                 push    490h            ; unsigned int
.text$mn:00001AB8                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001ABD                 mov     eax, [ebp+Str]
.text$mn:00001AC0                 push    eax             ; int
.text$mn:00001AC1                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001AC6                 add     esp, 0Ch
.text$mn:00001AC9                 mov     ecx, [ebp+Str]
.text$mn:00001ACC                 push    ecx             ; Str
.text$mn:00001ACD                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00001AD2                 add     esp, 4
.text$mn:00001AD5                 push    eax             ; Size
.text$mn:00001AD6                 mov     edx, [ebp+Str]
.text$mn:00001AD9                 push    edx             ; Src
.text$mn:00001ADA                 mov     ecx, [ebp+var_4]
.text$mn:00001ADD                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00001AE2                 mov     esp, ebp
.text$mn:00001AE4                 pop     ebp
.text$mn:00001AE5                 retn    4
.text$mn:00001AE5 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00001AE5
.text$mn:00001AE5 _text$mn        ends
.text$mn:00001AE5
.text$mn:00001AE8 ; ===========================================================================
.text$mn:00001AE8
.text$mn:00001AE8 ; Segment type: Pure code
.text$mn:00001AE8 ; Segment permissions: Read/Execute
.text$mn:00001AE8 _text$mn        segment para public 'CODE' use32
.text$mn:00001AE8                 assume cs:_text$mn
.text$mn:00001AE8                 ;org 1AE8h
.text$mn:00001AE8 ; COMDAT (pick any)
.text$mn:00001AE8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001AE8
.text$mn:00001AE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AE8
.text$mn:00001AE8 ; Attributes: bp-based frame
.text$mn:00001AE8
.text$mn:00001AE8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00001AE8                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00001AE8 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00001AE8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00001AE8
.text$mn:00001AE8 var_4           = dword ptr -4
.text$mn:00001AE8 Src             = dword ptr  8
.text$mn:00001AE8 Size            = dword ptr  0Ch
.text$mn:00001AE8
.text$mn:00001AE8                 push    ebp
.text$mn:00001AE9                 mov     ebp, esp
.text$mn:00001AEB                 push    ecx
.text$mn:00001AEC                 mov     [ebp+var_4], ecx
.text$mn:00001AEF                 cmp     [ebp+Size], 0
.text$mn:00001AF3                 jz      short loc_1B0B
.text$mn:00001AF5                 push    47Fh            ; unsigned int
.text$mn:00001AFA                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001AFF                 mov     eax, [ebp+Src]
.text$mn:00001B02                 push    eax             ; int
.text$mn:00001B03                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00001B08                 add     esp, 0Ch
.text$mn:00001B0B
.text$mn:00001B0B loc_1B0B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00001B0B                 mov     ecx, [ebp+Src]
.text$mn:00001B0E                 push    ecx
.text$mn:00001B0F                 mov     ecx, [ebp+var_4]
.text$mn:00001B12                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00001B17                 movzx   edx, al
.text$mn:00001B1A                 test    edx, edx
.text$mn:00001B1C                 jz      short loc_1B3E
.text$mn:00001B1E                 mov     eax, [ebp+Size]
.text$mn:00001B21                 push    eax
.text$mn:00001B22                 mov     ecx, [ebp+var_4]
.text$mn:00001B25                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001B2A                 mov     ecx, [ebp+Src]
.text$mn:00001B2D                 sub     ecx, eax
.text$mn:00001B2F                 push    ecx
.text$mn:00001B30                 mov     edx, [ebp+var_4]
.text$mn:00001B33                 push    edx
.text$mn:00001B34                 mov     ecx, [ebp+var_4]
.text$mn:00001B37                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00001B3C                 jmp     short loc_1B7B
.text$mn:00001B3E ; ---------------------------------------------------------------------------
.text$mn:00001B3E
.text$mn:00001B3E loc_1B3E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00001B3E                 push    0
.text$mn:00001B40                 mov     eax, [ebp+Size]
.text$mn:00001B43                 push    eax
.text$mn:00001B44                 mov     ecx, [ebp+var_4]
.text$mn:00001B47                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00001B4C                 movzx   ecx, al
.text$mn:00001B4F                 test    ecx, ecx
.text$mn:00001B51                 jz      short loc_1B78
.text$mn:00001B53                 mov     edx, [ebp+Size]
.text$mn:00001B56                 push    edx             ; Size
.text$mn:00001B57                 mov     eax, [ebp+Src]
.text$mn:00001B5A                 push    eax             ; Src
.text$mn:00001B5B                 mov     ecx, [ebp+var_4]
.text$mn:00001B5E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001B63                 push    eax             ; Dst
.text$mn:00001B64                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001B69                 add     esp, 0Ch
.text$mn:00001B6C                 mov     ecx, [ebp+Size]
.text$mn:00001B6F                 push    ecx
.text$mn:00001B70                 mov     ecx, [ebp+var_4]
.text$mn:00001B73                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001B78
.text$mn:00001B78 loc_1B78:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00001B78                 mov     eax, [ebp+var_4]
.text$mn:00001B7B
.text$mn:00001B7B loc_1B7B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00001B7B                 mov     esp, ebp
.text$mn:00001B7D                 pop     ebp
.text$mn:00001B7E                 retn    8
.text$mn:00001B7E ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00001B7E
.text$mn:00001B7E ; ---------------------------------------------------------------------------
.text$mn:00001B81                 align 4
.text$mn:00001B81 _text$mn        ends
.text$mn:00001B81
.text$mn:00001B84 ; ===========================================================================
.text$mn:00001B84
.text$mn:00001B84 ; Segment type: Pure code
.text$mn:00001B84 ; Segment permissions: Read/Execute
.text$mn:00001B84 _text$mn        segment para public 'CODE' use32
.text$mn:00001B84                 assume cs:_text$mn
.text$mn:00001B84                 ;org 1B84h
.text$mn:00001B84 ; COMDAT (pick any)
.text$mn:00001B84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B84
.text$mn:00001B84 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B84
.text$mn:00001B84 ; Attributes: bp-based frame
.text$mn:00001B84
.text$mn:00001B84 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00001B84                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00001B84 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00001B84                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00001B84
.text$mn:00001B84 arg_0           = dword ptr  8
.text$mn:00001B84 arg_4           = dword ptr  0Ch
.text$mn:00001B84
.text$mn:00001B84                 push    ebp
.text$mn:00001B85                 mov     ebp, esp
.text$mn:00001B87                 mov     eax, [ebp+arg_0]
.text$mn:00001B8A                 mov     ecx, [ebp+arg_4]
.text$mn:00001B8D                 mov     dl, [ecx]
.text$mn:00001B8F                 mov     [eax], dl
.text$mn:00001B91                 pop     ebp
.text$mn:00001B92                 retn
.text$mn:00001B92 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00001B92
.text$mn:00001B92 ; ---------------------------------------------------------------------------
.text$mn:00001B93                 align 4
.text$mn:00001B93 _text$mn        ends
.text$mn:00001B93
.text$mn:00001B94 ; ===========================================================================
.text$mn:00001B94
.text$mn:00001B94 ; Segment type: Pure code
.text$mn:00001B94 ; Segment permissions: Read/Execute
.text$mn:00001B94 _text$mn        segment para public 'CODE' use32
.text$mn:00001B94                 assume cs:_text$mn
.text$mn:00001B94                 ;org 1B94h
.text$mn:00001B94 ; COMDAT (pick any)
.text$mn:00001B94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B94
.text$mn:00001B94 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B94
.text$mn:00001B94 ; Attributes: bp-based frame
.text$mn:00001B94
.text$mn:00001B94 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00001B94                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00001B94 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001B94                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00001B94
.text$mn:00001B94 var_4           = dword ptr -4
.text$mn:00001B94
.text$mn:00001B94                 push    ebp
.text$mn:00001B95                 mov     ebp, esp
.text$mn:00001B97                 push    ecx
.text$mn:00001B98                 mov     [ebp+var_4], ecx
.text$mn:00001B9B                 mov     eax, [ebp+var_4]
.text$mn:00001B9E                 mov     eax, [eax+4]
.text$mn:00001BA1                 mov     esp, ebp
.text$mn:00001BA3                 pop     ebp
.text$mn:00001BA4                 retn
.text$mn:00001BA4 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001BA4
.text$mn:00001BA4 ; ---------------------------------------------------------------------------
.text$mn:00001BA5                 align 4
.text$mn:00001BA5 _text$mn        ends
.text$mn:00001BA5
.text$mn:00001BA8 ; ===========================================================================
.text$mn:00001BA8
.text$mn:00001BA8 ; Segment type: Pure code
.text$mn:00001BA8 ; Segment permissions: Read/Execute
.text$mn:00001BA8 _text$mn        segment para public 'CODE' use32
.text$mn:00001BA8                 assume cs:_text$mn
.text$mn:00001BA8                 ;org 1BA8h
.text$mn:00001BA8 ; COMDAT (pick any)
.text$mn:00001BA8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001BA8
.text$mn:00001BA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BA8
.text$mn:00001BA8 ; Attributes: bp-based frame
.text$mn:00001BA8
.text$mn:00001BA8 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00001BA8                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00001BA8 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001BA8                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00001BA8                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00001BA8
.text$mn:00001BA8 var_4           = dword ptr -4
.text$mn:00001BA8
.text$mn:00001BA8                 push    ebp
.text$mn:00001BA9                 mov     ebp, esp
.text$mn:00001BAB                 push    ecx
.text$mn:00001BAC                 mov     [ebp+var_4], ecx
.text$mn:00001BAF                 mov     eax, [ebp+var_4]
.text$mn:00001BB2                 mov     eax, [eax+4]
.text$mn:00001BB5                 mov     esp, ebp
.text$mn:00001BB7                 pop     ebp
.text$mn:00001BB8                 retn
.text$mn:00001BB8 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001BB8
.text$mn:00001BB8 ; ---------------------------------------------------------------------------
.text$mn:00001BB9                 align 4
.text$mn:00001BB9 _text$mn        ends
.text$mn:00001BB9
.text$mn:00001BBC ; ===========================================================================
.text$mn:00001BBC
.text$mn:00001BBC ; Segment type: Pure code
.text$mn:00001BBC ; Segment permissions: Read/Execute
.text$mn:00001BBC _text$mn        segment para public 'CODE' use32
.text$mn:00001BBC                 assume cs:_text$mn
.text$mn:00001BBC                 ;org 1BBCh
.text$mn:00001BBC ; COMDAT (pick any)
.text$mn:00001BBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001BBC
.text$mn:00001BBC ; =============== S U B R O U T I N E =======================================
.text$mn:00001BBC
.text$mn:00001BBC ; Attributes: bp-based frame
.text$mn:00001BBC
.text$mn:00001BBC ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00001BBC                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001BBC ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00001BBC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00001BBC
.text$mn:00001BBC var_4           = dword ptr -4
.text$mn:00001BBC Dst             = dword ptr  8
.text$mn:00001BBC Src             = dword ptr  0Ch
.text$mn:00001BBC Size            = dword ptr  10h
.text$mn:00001BBC
.text$mn:00001BBC                 push    ebp
.text$mn:00001BBD                 mov     ebp, esp
.text$mn:00001BBF                 push    ecx
.text$mn:00001BC0                 cmp     [ebp+Size], 0
.text$mn:00001BC4                 jnz     short loc_1BCE
.text$mn:00001BC6                 mov     eax, [ebp+Dst]
.text$mn:00001BC9                 mov     [ebp+var_4], eax
.text$mn:00001BCC                 jmp     short loc_1BE5
.text$mn:00001BCE ; ---------------------------------------------------------------------------
.text$mn:00001BCE
.text$mn:00001BCE loc_1BCE:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00001BCE                 mov     ecx, [ebp+Size]
.text$mn:00001BD1                 push    ecx             ; Size
.text$mn:00001BD2                 mov     edx, [ebp+Src]
.text$mn:00001BD5                 push    edx             ; Src
.text$mn:00001BD6                 mov     eax, [ebp+Dst]
.text$mn:00001BD9                 push    eax             ; Dst
.text$mn:00001BDA                 call    _memcpy
.text$mn:00001BDF                 add     esp, 0Ch
.text$mn:00001BE2                 mov     [ebp+var_4], eax
.text$mn:00001BE5
.text$mn:00001BE5 loc_1BE5:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00001BE5                 mov     eax, [ebp+var_4]
.text$mn:00001BE8                 mov     esp, ebp
.text$mn:00001BEA                 pop     ebp
.text$mn:00001BEB                 retn
.text$mn:00001BEB ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001BEB
.text$mn:00001BEB _text$mn        ends
.text$mn:00001BEB
.text$mn:00001BEC ; ===========================================================================
.text$mn:00001BEC
.text$mn:00001BEC ; Segment type: Pure code
.text$mn:00001BEC ; Segment permissions: Read/Execute
.text$mn:00001BEC _text$mn        segment para public 'CODE' use32
.text$mn:00001BEC                 assume cs:_text$mn
.text$mn:00001BEC                 ;org 1BECh
.text$mn:00001BEC ; COMDAT (pick any)
.text$mn:00001BEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001BEC
.text$mn:00001BEC ; =============== S U B R O U T I N E =======================================
.text$mn:00001BEC
.text$mn:00001BEC ; Attributes: bp-based frame
.text$mn:00001BEC
.text$mn:00001BEC ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00001BEC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00001BEC ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00001BEC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00001BEC
.text$mn:00001BEC var_4           = dword ptr -4
.text$mn:00001BEC arg_0           = dword ptr  8
.text$mn:00001BEC arg_4           = dword ptr  0Ch
.text$mn:00001BEC
.text$mn:00001BEC                 push    ebp
.text$mn:00001BED                 mov     ebp, esp
.text$mn:00001BEF                 push    ecx
.text$mn:00001BF0                 mov     [ebp+var_4], ecx
.text$mn:00001BF3                 mov     eax, [ebp+arg_4]
.text$mn:00001BF6                 push    eax             ; int
.text$mn:00001BF7                 mov     ecx, [ebp+arg_0]
.text$mn:00001BFA                 push    ecx             ; void *
.text$mn:00001BFB                 mov     ecx, [ebp+var_4]
.text$mn:00001BFE                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00001C03                 mov     esp, ebp
.text$mn:00001C05                 pop     ebp
.text$mn:00001C06                 retn    8
.text$mn:00001C06 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00001C06
.text$mn:00001C06 ; ---------------------------------------------------------------------------
.text$mn:00001C09                 align 4
.text$mn:00001C09 _text$mn        ends
.text$mn:00001C09
.text$mn:00001C0C ; ===========================================================================
.text$mn:00001C0C
.text$mn:00001C0C ; Segment type: Pure code
.text$mn:00001C0C ; Segment permissions: Read/Execute
.text$mn:00001C0C _text$mn        segment para public 'CODE' use32
.text$mn:00001C0C                 assume cs:_text$mn
.text$mn:00001C0C                 ;org 1C0Ch
.text$mn:00001C0C ; COMDAT (pick any)
.text$mn:00001C0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C0C
.text$mn:00001C0C ; =============== S U B R O U T I N E =======================================
.text$mn:00001C0C
.text$mn:00001C0C ; Attributes: bp-based frame
.text$mn:00001C0C
.text$mn:00001C0C ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00001C0C                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00001C0C ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00001C0C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00001C0C
.text$mn:00001C0C var_4           = dword ptr -4
.text$mn:00001C0C arg_0           = dword ptr  8
.text$mn:00001C0C
.text$mn:00001C0C                 push    ebp
.text$mn:00001C0D                 mov     ebp, esp
.text$mn:00001C0F                 push    ecx
.text$mn:00001C10                 mov     [ebp+var_4], ecx
.text$mn:00001C13                 mov     eax, [ebp+arg_0]
.text$mn:00001C16                 push    eax             ; void *
.text$mn:00001C17                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001C1C                 add     esp, 4
.text$mn:00001C1F                 mov     esp, ebp
.text$mn:00001C21                 pop     ebp
.text$mn:00001C22                 retn    8
.text$mn:00001C22 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00001C22
.text$mn:00001C22 ; ---------------------------------------------------------------------------
.text$mn:00001C25                 align 4
.text$mn:00001C25 _text$mn        ends
.text$mn:00001C25
.text$mn:00001C28 ; ===========================================================================
.text$mn:00001C28
.text$mn:00001C28 ; Segment type: Pure code
.text$mn:00001C28 ; Segment permissions: Read/Execute
.text$mn:00001C28 _text$mn        segment para public 'CODE' use32
.text$mn:00001C28                 assume cs:_text$mn
.text$mn:00001C28                 ;org 1C28h
.text$mn:00001C28 ; COMDAT (pick any)
.text$mn:00001C28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C28
.text$mn:00001C28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C28
.text$mn:00001C28 ; Attributes: bp-based frame
.text$mn:00001C28
.text$mn:00001C28 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00001C28                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00001C28 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00001C28                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00001C28
.text$mn:00001C28 var_4           = dword ptr -4
.text$mn:00001C28 arg_0           = dword ptr  8
.text$mn:00001C28
.text$mn:00001C28                 push    ebp
.text$mn:00001C29                 mov     ebp, esp
.text$mn:00001C2B                 push    ecx
.text$mn:00001C2C                 mov     [ebp+var_4], ecx
.text$mn:00001C2F                 mov     eax, [ebp+arg_0]
.text$mn:00001C32                 push    eax             ; void *
.text$mn:00001C33                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001C38                 add     esp, 4
.text$mn:00001C3B                 mov     esp, ebp
.text$mn:00001C3D                 pop     ebp
.text$mn:00001C3E                 retn    8
.text$mn:00001C3E ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00001C3E
.text$mn:00001C3E ; ---------------------------------------------------------------------------
.text$mn:00001C41                 align 4
.text$mn:00001C41 _text$mn        ends
.text$mn:00001C41
.text$mn:00001C44 ; ===========================================================================
.text$mn:00001C44
.text$mn:00001C44 ; Segment type: Pure code
.text$mn:00001C44 ; Segment permissions: Read/Execute
.text$mn:00001C44 _text$mn        segment para public 'CODE' use32
.text$mn:00001C44                 assume cs:_text$mn
.text$mn:00001C44                 ;org 1C44h
.text$mn:00001C44 ; COMDAT (pick any)
.text$mn:00001C44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C44
.text$mn:00001C44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C44
.text$mn:00001C44 ; Attributes: bp-based frame
.text$mn:00001C44
.text$mn:00001C44 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00001C44                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001C44 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001C44                                         ; DATA XREF: .rdata:00002718o
.text$mn:00001C44
.text$mn:00001C44 var_4           = dword ptr -4
.text$mn:00001C44 arg_0           = dword ptr  8
.text$mn:00001C44 arg_4           = dword ptr  0Ch
.text$mn:00001C44
.text$mn:00001C44                 push    ebp
.text$mn:00001C45                 mov     ebp, esp
.text$mn:00001C47                 push    ecx
.text$mn:00001C48                 mov     [ebp+var_4], ecx
.text$mn:00001C4B                 mov     eax, [ebp+arg_4]
.text$mn:00001C4E                 push    eax             ; int
.text$mn:00001C4F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00001C54                 add     esp, 4
.text$mn:00001C57                 test    eax, eax
.text$mn:00001C59                 jz      short loc_1C74
.text$mn:00001C5B                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00001C60                 push    eax             ; struct std::error_category *
.text$mn:00001C61                 mov     ecx, [ebp+arg_4]
.text$mn:00001C64                 push    ecx             ; int
.text$mn:00001C65                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001C68                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001C6D                 mov     eax, [ebp+arg_0]
.text$mn:00001C70                 jmp     short loc_1C89
.text$mn:00001C72 ; ---------------------------------------------------------------------------
.text$mn:00001C72                 jmp     short loc_1C89
.text$mn:00001C74 ; ---------------------------------------------------------------------------
.text$mn:00001C74
.text$mn:00001C74 loc_1C74:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00001C74                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00001C79                 push    eax             ; struct std::error_category *
.text$mn:00001C7A                 mov     edx, [ebp+arg_4]
.text$mn:00001C7D                 push    edx             ; int
.text$mn:00001C7E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001C81                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001C86                 mov     eax, [ebp+arg_0]
.text$mn:00001C89
.text$mn:00001C89 loc_1C89:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00001C89                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00001C89                 mov     esp, ebp
.text$mn:00001C8B                 pop     ebp
.text$mn:00001C8C                 retn    8
.text$mn:00001C8C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001C8C
.text$mn:00001C8C ; ---------------------------------------------------------------------------
.text$mn:00001C8F                 align 10h
.text$mn:00001C8F _text$mn        ends
.text$mn:00001C8F
.text$mn:00001C90 ; ===========================================================================
.text$mn:00001C90
.text$mn:00001C90 ; Segment type: Pure code
.text$mn:00001C90 ; Segment permissions: Read/Execute
.text$mn:00001C90 _text$mn        segment para public 'CODE' use32
.text$mn:00001C90                 assume cs:_text$mn
.text$mn:00001C90                 ;org 1C90h
.text$mn:00001C90 ; COMDAT (pick any)
.text$mn:00001C90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C90
.text$mn:00001C90 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C90
.text$mn:00001C90 ; Attributes: bp-based frame
.text$mn:00001C90
.text$mn:00001C90 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00001C90                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001C90 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001C90                                         ; DATA XREF: .rdata:00002688o
.text$mn:00001C90                                         ; .rdata:000026A4o ...
.text$mn:00001C90
.text$mn:00001C90 var_4           = dword ptr -4
.text$mn:00001C90 arg_0           = dword ptr  8
.text$mn:00001C90 arg_4           = dword ptr  0Ch
.text$mn:00001C90
.text$mn:00001C90                 push    ebp
.text$mn:00001C91                 mov     ebp, esp
.text$mn:00001C93                 push    ecx
.text$mn:00001C94                 mov     [ebp+var_4], ecx
.text$mn:00001C97                 mov     eax, [ebp+var_4]
.text$mn:00001C9A                 push    eax             ; struct std::error_category *
.text$mn:00001C9B                 mov     ecx, [ebp+arg_4]
.text$mn:00001C9E                 push    ecx             ; int
.text$mn:00001C9F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001CA2                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00001CA7                 mov     eax, [ebp+arg_0]
.text$mn:00001CAA                 mov     esp, ebp
.text$mn:00001CAC                 pop     ebp
.text$mn:00001CAD                 retn    8
.text$mn:00001CAD ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001CAD
.text$mn:00001CAD _text$mn        ends
.text$mn:00001CAD
.text$mn:00001CB0 ; ===========================================================================
.text$mn:00001CB0
.text$mn:00001CB0 ; Segment type: Pure code
.text$mn:00001CB0 ; Segment permissions: Read/Execute
.text$mn:00001CB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001CB0                 assume cs:_text$mn
.text$mn:00001CB0                 ;org 1CB0h
.text$mn:00001CB0 ; COMDAT (pick any)
.text$mn:00001CB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001CB0
.text$mn:00001CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CB0
.text$mn:00001CB0 ; Attributes: bp-based frame
.text$mn:00001CB0
.text$mn:00001CB0 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00001CB0                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00001CB0 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00001CB0                                         ; DATA XREF: .rdata:0000268Co
.text$mn:00001CB0                                         ; .rdata:000026A8o ...
.text$mn:00001CB0
.text$mn:00001CB0 var_8           = dword ptr -8
.text$mn:00001CB0 var_4           = dword ptr -4
.text$mn:00001CB0 arg_0           = dword ptr  8
.text$mn:00001CB0 arg_4           = dword ptr  0Ch
.text$mn:00001CB0
.text$mn:00001CB0                 push    ebp
.text$mn:00001CB1                 mov     ebp, esp
.text$mn:00001CB3                 sub     esp, 8
.text$mn:00001CB6                 mov     [ebp+var_8], ecx
.text$mn:00001CB9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001CBC                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00001CC1                 push    eax
.text$mn:00001CC2                 mov     ecx, [ebp+var_8]
.text$mn:00001CC5                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001CCA                 movzx   eax, al
.text$mn:00001CCD                 test    eax, eax
.text$mn:00001CCF                 jz      short loc_1CE7
.text$mn:00001CD1                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001CD4                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00001CD9                 cmp     eax, [ebp+arg_4]
.text$mn:00001CDC                 jnz     short loc_1CE7
.text$mn:00001CDE                 mov     [ebp+var_4], 1
.text$mn:00001CE5                 jmp     short loc_1CEE
.text$mn:00001CE7 ; ---------------------------------------------------------------------------
.text$mn:00001CE7
.text$mn:00001CE7 loc_1CE7:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00001CE7                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00001CE7                 mov     [ebp+var_4], 0
.text$mn:00001CEE
.text$mn:00001CEE loc_1CEE:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00001CEE                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001CF1                 mov     esp, ebp
.text$mn:00001CF3                 pop     ebp
.text$mn:00001CF4                 retn    8
.text$mn:00001CF4 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00001CF4
.text$mn:00001CF4 ; ---------------------------------------------------------------------------
.text$mn:00001CF7                 align 4
.text$mn:00001CF7 _text$mn        ends
.text$mn:00001CF7
.text$mn:00001CF8 ; ===========================================================================
.text$mn:00001CF8
.text$mn:00001CF8 ; Segment type: Pure code
.text$mn:00001CF8 ; Segment permissions: Read/Execute
.text$mn:00001CF8 _text$mn        segment para public 'CODE' use32
.text$mn:00001CF8                 assume cs:_text$mn
.text$mn:00001CF8                 ;org 1CF8h
.text$mn:00001CF8 ; COMDAT (pick any)
.text$mn:00001CF8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001CF8
.text$mn:00001CF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CF8
.text$mn:00001CF8 ; Attributes: bp-based frame
.text$mn:00001CF8
.text$mn:00001CF8 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00001CF8                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00001CF8 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00001CF8                                         ; DATA XREF: .rdata:00002690o
.text$mn:00001CF8                                         ; .rdata:000026ACo ...
.text$mn:00001CF8
.text$mn:00001CF8 var_C           = byte ptr -0Ch
.text$mn:00001CF8 var_4           = dword ptr -4
.text$mn:00001CF8 arg_0           = dword ptr  8
.text$mn:00001CF8 arg_4           = dword ptr  0Ch
.text$mn:00001CF8
.text$mn:00001CF8                 push    ebp
.text$mn:00001CF9                 mov     ebp, esp
.text$mn:00001CFB                 sub     esp, 0Ch
.text$mn:00001CFE                 mov     [ebp+var_4], ecx
.text$mn:00001D01                 mov     eax, [ebp+arg_4]
.text$mn:00001D04                 push    eax             ; std::error_condition *
.text$mn:00001D05                 mov     ecx, [ebp+arg_0]
.text$mn:00001D08                 push    ecx
.text$mn:00001D09                 lea     edx, [ebp+var_C]
.text$mn:00001D0C                 push    edx
.text$mn:00001D0D                 mov     eax, [ebp+var_4]
.text$mn:00001D10                 mov     edx, [eax]
.text$mn:00001D12                 mov     ecx, [ebp+var_4]
.text$mn:00001D15                 mov     eax, [edx+0Ch]
.text$mn:00001D18                 call    eax
.text$mn:00001D1A                 mov     ecx, eax
.text$mn:00001D1C                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00001D21                 mov     esp, ebp
.text$mn:00001D23                 pop     ebp
.text$mn:00001D24                 retn    8
.text$mn:00001D24 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00001D24
.text$mn:00001D24 ; ---------------------------------------------------------------------------
.text$mn:00001D27                 align 4
.text$mn:00001D27 _text$mn        ends
.text$mn:00001D27
.text$mn:00001D28 ; ===========================================================================
.text$mn:00001D28
.text$mn:00001D28 ; Segment type: Pure code
.text$mn:00001D28 ; Segment permissions: Read/Execute
.text$mn:00001D28 _text$mn        segment para public 'CODE' use32
.text$mn:00001D28                 assume cs:_text$mn
.text$mn:00001D28                 ;org 1D28h
.text$mn:00001D28 ; COMDAT (pick any)
.text$mn:00001D28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D28
.text$mn:00001D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D28
.text$mn:00001D28 ; Attributes: bp-based frame
.text$mn:00001D28
.text$mn:00001D28 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00001D28                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00001D28 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00001D28                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00001D28
.text$mn:00001D28 var_4           = dword ptr -4
.text$mn:00001D28 arg_0           = dword ptr  8
.text$mn:00001D28
.text$mn:00001D28                 push    ebp
.text$mn:00001D29                 mov     ebp, esp
.text$mn:00001D2B                 push    ecx
.text$mn:00001D2C                 mov     [ebp+var_4], ecx
.text$mn:00001D2F                 mov     eax, [ebp+var_4]
.text$mn:00001D32                 mov     ecx, [eax+14h]
.text$mn:00001D35                 cmp     ecx, [ebp+arg_0]
.text$mn:00001D38                 jnb     short loc_1D42
.text$mn:00001D3A                 mov     ecx, [ebp+var_4]
.text$mn:00001D3D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001D42
.text$mn:00001D42 loc_1D42:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00001D42                 mov     edx, [ebp+arg_0]
.text$mn:00001D45                 push    edx
.text$mn:00001D46                 mov     ecx, [ebp+var_4]
.text$mn:00001D49                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001D4E                 mov     eax, [ebp+var_4]
.text$mn:00001D51                 mov     esp, ebp
.text$mn:00001D53                 pop     ebp
.text$mn:00001D54                 retn    4
.text$mn:00001D54 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00001D54
.text$mn:00001D54 ; ---------------------------------------------------------------------------
.text$mn:00001D57                 align 4
.text$mn:00001D57 _text$mn        ends
.text$mn:00001D57
.text$mn:00001D58 ; ===========================================================================
.text$mn:00001D58
.text$mn:00001D58 ; Segment type: Pure code
.text$mn:00001D58 ; Segment permissions: Read/Execute
.text$mn:00001D58 _text$mn        segment para public 'CODE' use32
.text$mn:00001D58                 assume cs:_text$mn
.text$mn:00001D58                 ;org 1D58h
.text$mn:00001D58 ; COMDAT (pick any)
.text$mn:00001D58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D58
.text$mn:00001D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D58
.text$mn:00001D58 ; Attributes: bp-based frame
.text$mn:00001D58
.text$mn:00001D58 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00001D58                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00001D58 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00001D58                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00001D58
.text$mn:00001D58 var_C           = dword ptr -0Ch
.text$mn:00001D58 Dst             = dword ptr -8
.text$mn:00001D58 var_4           = dword ptr -4
.text$mn:00001D58 arg_0           = dword ptr  8
.text$mn:00001D58 arg_4           = dword ptr  0Ch
.text$mn:00001D58
.text$mn:00001D58                 push    ebp
.text$mn:00001D59                 mov     ebp, esp
.text$mn:00001D5B                 sub     esp, 0Ch
.text$mn:00001D5E                 mov     [ebp+var_4], ecx
.text$mn:00001D61                 mov     eax, [ebp+var_4]
.text$mn:00001D64                 mov     ecx, [eax+14h]
.text$mn:00001D67                 cmp     ecx, [ebp+arg_0]
.text$mn:00001D6A                 jnb     short loc_1D74
.text$mn:00001D6C                 mov     ecx, [ebp+var_4]
.text$mn:00001D6F                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001D74
.text$mn:00001D74 loc_1D74:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00001D74                 mov     edx, [ebp+var_4]
.text$mn:00001D77                 mov     eax, [edx+14h]
.text$mn:00001D7A                 sub     eax, [ebp+arg_0]
.text$mn:00001D7D                 cmp     eax, [ebp+arg_4]
.text$mn:00001D80                 ja      short loc_1D90
.text$mn:00001D82                 mov     ecx, [ebp+arg_0]
.text$mn:00001D85                 push    ecx
.text$mn:00001D86                 mov     ecx, [ebp+var_4]
.text$mn:00001D89                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001D8E                 jmp     short loc_1DD6
.text$mn:00001D90 ; ---------------------------------------------------------------------------
.text$mn:00001D90
.text$mn:00001D90 loc_1D90:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00001D90                 cmp     [ebp+arg_4], 0
.text$mn:00001D94                 jbe     short loc_1DD6
.text$mn:00001D96                 mov     ecx, [ebp+var_4]
.text$mn:00001D99                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001D9E                 add     eax, [ebp+arg_0]
.text$mn:00001DA1                 mov     [ebp+Dst], eax
.text$mn:00001DA4                 mov     edx, [ebp+var_4]
.text$mn:00001DA7                 mov     eax, [edx+14h]
.text$mn:00001DAA                 sub     eax, [ebp+arg_4]
.text$mn:00001DAD                 mov     [ebp+var_C], eax
.text$mn:00001DB0                 mov     ecx, [ebp+var_C]
.text$mn:00001DB3                 sub     ecx, [ebp+arg_0]
.text$mn:00001DB6                 push    ecx             ; Size
.text$mn:00001DB7                 mov     edx, [ebp+Dst]
.text$mn:00001DBA                 add     edx, [ebp+arg_4]
.text$mn:00001DBD                 push    edx             ; Src
.text$mn:00001DBE                 mov     eax, [ebp+Dst]
.text$mn:00001DC1                 push    eax             ; Dst
.text$mn:00001DC2                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00001DC7                 add     esp, 0Ch
.text$mn:00001DCA                 mov     ecx, [ebp+var_C]
.text$mn:00001DCD                 push    ecx
.text$mn:00001DCE                 mov     ecx, [ebp+var_4]
.text$mn:00001DD1                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001DD6
.text$mn:00001DD6 loc_1DD6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00001DD6                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00001DD6                 mov     eax, [ebp+var_4]
.text$mn:00001DD9                 mov     esp, ebp
.text$mn:00001DDB                 pop     ebp
.text$mn:00001DDC                 retn    8
.text$mn:00001DDC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00001DDC
.text$mn:00001DDC ; ---------------------------------------------------------------------------
.text$mn:00001DDF                 align 10h
.text$mn:00001DDF _text$mn        ends
.text$mn:00001DDF
.text$mn:00001DE0 ; ===========================================================================
.text$mn:00001DE0
.text$mn:00001DE0 ; Segment type: Pure code
.text$mn:00001DE0 ; Segment permissions: Read/Execute
.text$mn:00001DE0 _text$mn        segment para public 'CODE' use32
.text$mn:00001DE0                 assume cs:_text$mn
.text$mn:00001DE0                 ;org 1DE0h
.text$mn:00001DE0 ; COMDAT (pick any)
.text$mn:00001DE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001DE0
.text$mn:00001DE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DE0
.text$mn:00001DE0 ; Attributes: bp-based frame
.text$mn:00001DE0
.text$mn:00001DE0 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00001DE0                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00001DE0 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001DE0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00001DE0                 push    ebp
.text$mn:00001DE1                 mov     ebp, esp
.text$mn:00001DE3                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00001DE8                 pop     ebp
.text$mn:00001DE9                 retn
.text$mn:00001DE9 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001DE9
.text$mn:00001DE9 ; ---------------------------------------------------------------------------
.text$mn:00001DEA                 align 4
.text$mn:00001DEA _text$mn        ends
.text$mn:00001DEA
.text$mn:00001DEC ; ===========================================================================
.text$mn:00001DEC
.text$mn:00001DEC ; Segment type: Pure code
.text$mn:00001DEC ; Segment permissions: Read/Execute
.text$mn:00001DEC _text$mn        segment para public 'CODE' use32
.text$mn:00001DEC                 assume cs:_text$mn
.text$mn:00001DEC                 ;org 1DECh
.text$mn:00001DEC ; COMDAT (pick any)
.text$mn:00001DEC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001DEC
.text$mn:00001DEC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DEC
.text$mn:00001DEC ; Attributes: bp-based frame
.text$mn:00001DEC
.text$mn:00001DEC ; void __thiscall Window::getClientRect(Window *this, struct tagRECT *)
.text$mn:00001DEC                 public ?getClientRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:00001DEC ?getClientRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:00001DEC                                         ; CODE XREF: ColourPopup::create(int)+5Fp
.text$mn:00001DEC
.text$mn:00001DEC var_4           = dword ptr -4
.text$mn:00001DEC lpRect          = dword ptr  8
.text$mn:00001DEC
.text$mn:00001DEC                 push    ebp
.text$mn:00001DED                 mov     ebp, esp
.text$mn:00001DEF                 push    ecx
.text$mn:00001DF0                 mov     [ebp+var_4], ecx
.text$mn:00001DF3                 mov     eax, [ebp+lpRect]
.text$mn:00001DF6                 push    eax             ; lpRect
.text$mn:00001DF7                 mov     ecx, [ebp+var_4]
.text$mn:00001DFA                 mov     edx, [ecx+0Ch]
.text$mn:00001DFD                 push    edx             ; hWnd
.text$mn:00001DFE                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00001E04                 mov     esp, ebp
.text$mn:00001E06                 pop     ebp
.text$mn:00001E07                 retn    4
.text$mn:00001E07 ?getClientRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:00001E07
.text$mn:00001E07 ; ---------------------------------------------------------------------------
.text$mn:00001E0A                 align 4
.text$mn:00001E0A _text$mn        ends
.text$mn:00001E0A
.text$mn:00001E0C ; ===========================================================================
.text$mn:00001E0C
.text$mn:00001E0C ; Segment type: Pure code
.text$mn:00001E0C ; Segment permissions: Read/Execute
.text$mn:00001E0C _text$mn        segment para public 'CODE' use32
.text$mn:00001E0C                 assume cs:_text$mn
.text$mn:00001E0C                 ;org 1E0Ch
.text$mn:00001E0C ; COMDAT (pick any)
.text$mn:00001E0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E0C
.text$mn:00001E0C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E0C
.text$mn:00001E0C ; Attributes: bp-based frame
.text$mn:00001E0C
.text$mn:00001E0C ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00001E0C                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00001E0C ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00001E0C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00001E0C
.text$mn:00001E0C var_4           = dword ptr -4
.text$mn:00001E0C Str             = dword ptr  8
.text$mn:00001E0C
.text$mn:00001E0C                 push    ebp
.text$mn:00001E0D                 mov     ebp, esp
.text$mn:00001E0F                 push    ecx
.text$mn:00001E10                 mov     eax, [ebp+Str]
.text$mn:00001E13                 movsx   ecx, byte ptr [eax]
.text$mn:00001E16                 test    ecx, ecx
.text$mn:00001E18                 jnz     short loc_1E23
.text$mn:00001E1A                 mov     [ebp+var_4], 0
.text$mn:00001E21                 jmp     short loc_1E32
.text$mn:00001E23 ; ---------------------------------------------------------------------------
.text$mn:00001E23
.text$mn:00001E23 loc_1E23:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00001E23                 mov     edx, [ebp+Str]
.text$mn:00001E26                 push    edx             ; Str
.text$mn:00001E27                 call    _strlen
.text$mn:00001E2C                 add     esp, 4
.text$mn:00001E2F                 mov     [ebp+var_4], eax
.text$mn:00001E32
.text$mn:00001E32 loc_1E32:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00001E32                 mov     eax, [ebp+var_4]
.text$mn:00001E35                 mov     esp, ebp
.text$mn:00001E37                 pop     ebp
.text$mn:00001E38                 retn
.text$mn:00001E38 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00001E38
.text$mn:00001E38 ; ---------------------------------------------------------------------------
.text$mn:00001E39                 align 4
.text$mn:00001E39 _text$mn        ends
.text$mn:00001E39
.text$mn:00001E3C ; ===========================================================================
.text$mn:00001E3C
.text$mn:00001E3C ; Segment type: Pure code
.text$mn:00001E3C ; Segment permissions: Read/Execute
.text$mn:00001E3C _text$mn        segment para public 'CODE' use32
.text$mn:00001E3C                 assume cs:_text$mn
.text$mn:00001E3C                 ;org 1E3Ch
.text$mn:00001E3C ; COMDAT (pick any)
.text$mn:00001E3C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E3C
.text$mn:00001E3C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E3C
.text$mn:00001E3C ; Attributes: bp-based frame
.text$mn:00001E3C
.text$mn:00001E3C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00001E3C                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00001E3C ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00001E3C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00001E3C
.text$mn:00001E3C var_4           = dword ptr -4
.text$mn:00001E3C
.text$mn:00001E3C                 push    ebp
.text$mn:00001E3D                 mov     ebp, esp
.text$mn:00001E3F                 push    ecx
.text$mn:00001E40                 mov     [ebp+var_4], ecx
.text$mn:00001E43                 mov     eax, [ebp+var_4]
.text$mn:00001E46                 push    eax
.text$mn:00001E47                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00001E4C                 add     esp, 4
.text$mn:00001E4F                 mov     esp, ebp
.text$mn:00001E51                 pop     ebp
.text$mn:00001E52                 retn
.text$mn:00001E52 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00001E52
.text$mn:00001E52 ; ---------------------------------------------------------------------------
.text$mn:00001E53                 align 4
.text$mn:00001E53 _text$mn        ends
.text$mn:00001E53
.text$mn:00001E54 ; ===========================================================================
.text$mn:00001E54
.text$mn:00001E54 ; Segment type: Pure code
.text$mn:00001E54 ; Segment permissions: Read/Execute
.text$mn:00001E54 _text$mn        segment para public 'CODE' use32
.text$mn:00001E54                 assume cs:_text$mn
.text$mn:00001E54                 ;org 1E54h
.text$mn:00001E54 ; COMDAT (pick any)
.text$mn:00001E54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E54
.text$mn:00001E54 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E54
.text$mn:00001E54 ; Attributes: bp-based frame
.text$mn:00001E54
.text$mn:00001E54 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00001E54                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00001E54 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00001E54                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00001E54
.text$mn:00001E54 var_4           = dword ptr -4
.text$mn:00001E54
.text$mn:00001E54                 push    ebp
.text$mn:00001E55                 mov     ebp, esp
.text$mn:00001E57                 push    ecx
.text$mn:00001E58                 mov     [ebp+var_4], ecx
.text$mn:00001E5B                 or      eax, 0FFFFFFFFh
.text$mn:00001E5E                 mov     esp, ebp
.text$mn:00001E60                 pop     ebp
.text$mn:00001E61                 retn
.text$mn:00001E61 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00001E61
.text$mn:00001E61 ; ---------------------------------------------------------------------------
.text$mn:00001E62                 align 4
.text$mn:00001E62 _text$mn        ends
.text$mn:00001E62
.text$mn:00001E64 ; ===========================================================================
.text$mn:00001E64
.text$mn:00001E64 ; Segment type: Pure code
.text$mn:00001E64 ; Segment permissions: Read/Execute
.text$mn:00001E64 _text$mn        segment para public 'CODE' use32
.text$mn:00001E64                 assume cs:_text$mn
.text$mn:00001E64                 ;org 1E64h
.text$mn:00001E64 ; COMDAT (pick any)
.text$mn:00001E64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E64
.text$mn:00001E64 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E64
.text$mn:00001E64 ; Attributes: bp-based frame
.text$mn:00001E64
.text$mn:00001E64 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00001E64                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00001E64 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00001E64                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00001E64
.text$mn:00001E64 arg_0           = dword ptr  8
.text$mn:00001E64
.text$mn:00001E64                 push    ebp
.text$mn:00001E65                 mov     ebp, esp
.text$mn:00001E67                 mov     ecx, [ebp+arg_0]
.text$mn:00001E6A                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00001E6F                 pop     ebp
.text$mn:00001E70                 retn
.text$mn:00001E70 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00001E70
.text$mn:00001E70 ; ---------------------------------------------------------------------------
.text$mn:00001E71                 align 4
.text$mn:00001E71 _text$mn        ends
.text$mn:00001E71
.text$mn:00001E74 ; ===========================================================================
.text$mn:00001E74
.text$mn:00001E74 ; Segment type: Pure code
.text$mn:00001E74 ; Segment permissions: Read/Execute
.text$mn:00001E74 _text$mn        segment para public 'CODE' use32
.text$mn:00001E74                 assume cs:_text$mn
.text$mn:00001E74                 ;org 1E74h
.text$mn:00001E74 ; COMDAT (pick any)
.text$mn:00001E74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E74
.text$mn:00001E74 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E74
.text$mn:00001E74 ; Attributes: bp-based frame
.text$mn:00001E74
.text$mn:00001E74 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00001E74                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00001E74 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00001E74                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00001E74                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00001E74
.text$mn:00001E74 var_10          = dword ptr -10h
.text$mn:00001E74 var_C           = dword ptr -0Ch
.text$mn:00001E74 var_8           = dword ptr -8
.text$mn:00001E74 var_1           = byte ptr -1
.text$mn:00001E74
.text$mn:00001E74                 push    ebp
.text$mn:00001E75                 mov     ebp, esp
.text$mn:00001E77                 sub     esp, 10h
.text$mn:00001E7A                 mov     [ebp+var_10], ecx
.text$mn:00001E7D                 lea     eax, [ebp+var_1]
.text$mn:00001E80                 push    eax
.text$mn:00001E81                 mov     ecx, [ebp+var_10]
.text$mn:00001E84                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001E89                 mov     ecx, eax
.text$mn:00001E8B                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00001E90                 mov     [ebp+var_8], eax
.text$mn:00001E93                 cmp     [ebp+var_8], 1
.text$mn:00001E97                 ja      short loc_1EA2
.text$mn:00001E99                 mov     [ebp+var_C], 1
.text$mn:00001EA0                 jmp     short loc_1EAB
.text$mn:00001EA2 ; ---------------------------------------------------------------------------
.text$mn:00001EA2
.text$mn:00001EA2 loc_1EA2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00001EA2                 mov     ecx, [ebp+var_8]
.text$mn:00001EA5                 sub     ecx, 1
.text$mn:00001EA8                 mov     [ebp+var_C], ecx
.text$mn:00001EAB
.text$mn:00001EAB loc_1EAB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00001EAB                 mov     eax, [ebp+var_C]
.text$mn:00001EAE                 mov     esp, ebp
.text$mn:00001EB0                 pop     ebp
.text$mn:00001EB1                 retn
.text$mn:00001EB1 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001EB1
.text$mn:00001EB1 ; ---------------------------------------------------------------------------
.text$mn:00001EB2                 align 4
.text$mn:00001EB2 _text$mn        ends
.text$mn:00001EB2
.text$mn:00001EB4 ; ===========================================================================
.text$mn:00001EB4
.text$mn:00001EB4 ; Segment type: Pure code
.text$mn:00001EB4 ; Segment permissions: Read/Execute
.text$mn:00001EB4 _text$mn        segment para public 'CODE' use32
.text$mn:00001EB4                 assume cs:_text$mn
.text$mn:00001EB4                 ;org 1EB4h
.text$mn:00001EB4 ; COMDAT (pick any)
.text$mn:00001EB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001EB4
.text$mn:00001EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EB4
.text$mn:00001EB4 ; Attributes: bp-based frame
.text$mn:00001EB4
.text$mn:00001EB4 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00001EB4                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001EB4 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001EB4                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00001EB4                                         ; DATA XREF: .rdata:000026A0o
.text$mn:00001EB4
.text$mn:00001EB4 var_1C          = dword ptr -1Ch
.text$mn:00001EB4 var_18          = dword ptr -18h
.text$mn:00001EB4 Str             = dword ptr -14h
.text$mn:00001EB4 var_10          = dword ptr -10h
.text$mn:00001EB4 var_C           = dword ptr -0Ch
.text$mn:00001EB4 var_4           = dword ptr -4
.text$mn:00001EB4 arg_0           = dword ptr  8
.text$mn:00001EB4 arg_4           = dword ptr  0Ch
.text$mn:00001EB4
.text$mn:00001EB4                 push    ebp
.text$mn:00001EB5                 mov     ebp, esp
.text$mn:00001EB7                 push    0FFFFFFFFh
.text$mn:00001EB9                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001EBE                 mov     eax, large fs:0
.text$mn:00001EC4                 push    eax
.text$mn:00001EC5                 sub     esp, 10h
.text$mn:00001EC8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001ECD                 xor     eax, ebp
.text$mn:00001ECF                 push    eax
.text$mn:00001ED0                 lea     eax, [ebp+var_C]
.text$mn:00001ED3                 mov     large fs:0, eax
.text$mn:00001ED9                 mov     [ebp+var_1C], ecx
.text$mn:00001EDC                 mov     [ebp+var_18], 0
.text$mn:00001EE3                 mov     eax, [ebp+arg_4]
.text$mn:00001EE6                 push    eax             ; int
.text$mn:00001EE7                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00001EEC                 add     esp, 4
.text$mn:00001EEF                 mov     [ebp+var_10], eax
.text$mn:00001EF2                 cmp     [ebp+var_10], 0
.text$mn:00001EF6                 jz      short loc_1F00
.text$mn:00001EF8                 mov     ecx, [ebp+var_10]
.text$mn:00001EFB                 mov     [ebp+Str], ecx
.text$mn:00001EFE                 jmp     short loc_1F07
.text$mn:00001F00 ; ---------------------------------------------------------------------------
.text$mn:00001F00
.text$mn:00001F00 loc_1F00:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00001F00                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00001F07
.text$mn:00001F07 loc_1F07:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00001F07                 mov     edx, [ebp+Str]
.text$mn:00001F0A                 push    edx             ; Str
.text$mn:00001F0B                 mov     ecx, [ebp+arg_0]
.text$mn:00001F0E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001F13                 mov     [ebp+var_4], 0
.text$mn:00001F1A                 mov     eax, [ebp+var_18]
.text$mn:00001F1D                 or      eax, 1
.text$mn:00001F20                 mov     [ebp+var_18], eax
.text$mn:00001F23                 mov     eax, [ebp+arg_0]
.text$mn:00001F26                 mov     ecx, [ebp+var_C]
.text$mn:00001F29                 mov     large fs:0, ecx
.text$mn:00001F30                 pop     ecx
.text$mn:00001F31                 mov     esp, ebp
.text$mn:00001F33                 pop     ebp
.text$mn:00001F34                 retn    8
.text$mn:00001F34 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001F34
.text$mn:00001F34 ; ---------------------------------------------------------------------------
.text$mn:00001F37                 align 4
.text$mn:00001F37 _text$mn        ends
.text$mn:00001F37
.text$x:00001F38 ; ===========================================================================
.text$x:00001F38
.text$x:00001F38 ; Segment type: Pure code
.text$x:00001F38 ; Segment permissions: Read/Execute
.text$x:00001F38 _text$x         segment para public 'CODE' use32
.text$x:00001F38                 assume cs:_text$x
.text$x:00001F38                 ;org 1F38h
.text$x:00001F38 ; COMDAT (pick associative to section at 1EB4)
.text$x:00001F38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001F38
.text$x:00001F38 ; =============== S U B R O U T I N E =======================================
.text$x:00001F38
.text$x:00001F38
.text$x:00001F38 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001F38                                         ; DATA XREF: .xdata$x:00002424o
.text$x:00001F38                 mov     eax, [ebp-18h]
.text$x:00001F3B                 and     eax, 1
.text$x:00001F3E                 jz      $LN6
.text$x:00001F44                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001F48                 mov     ecx, [ebp+8]
.text$x:00001F4B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001F50 ; ---------------------------------------------------------------------------
.text$x:00001F50
.text$x:00001F50 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001F50                 retn
.text$x:00001F50 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001F50
.text$x:00001F51
.text$x:00001F51 ; =============== S U B R O U T I N E =======================================
.text$x:00001F51
.text$x:00001F51
.text$x:00001F51 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001F51                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00001F51
.text$x:00001F51 arg_4           = dword ptr  8
.text$x:00001F51
.text$x:00001F51                 mov     edx, [esp+arg_4]
.text$x:00001F55                 lea     eax, [edx+0Ch]
.text$x:00001F58                 mov     ecx, [edx-14h]
.text$x:00001F5B                 xor     ecx, eax
.text$x:00001F5D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001F62                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001F67                 jmp     ___CxxFrameHandler3
.text$x:00001F67 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001F67
.text$x:00001F67 _text$x         ends
.text$x:00001F67
.text$mn:00001F6C ; ===========================================================================
.text$mn:00001F6C
.text$mn:00001F6C ; Segment type: Pure code
.text$mn:00001F6C ; Segment permissions: Read/Execute
.text$mn:00001F6C _text$mn        segment para public 'CODE' use32
.text$mn:00001F6C                 assume cs:_text$mn
.text$mn:00001F6C                 ;org 1F6Ch
.text$mn:00001F6C ; COMDAT (pick any)
.text$mn:00001F6C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001F6C
.text$mn:00001F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F6C
.text$mn:00001F6C ; Attributes: bp-based frame
.text$mn:00001F6C
.text$mn:00001F6C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00001F6C                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001F6C ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001F6C                                         ; DATA XREF: .rdata:000026D4o
.text$mn:00001F6C
.text$mn:00001F6C var_14          = dword ptr -14h
.text$mn:00001F6C var_10          = dword ptr -10h
.text$mn:00001F6C var_C           = dword ptr -0Ch
.text$mn:00001F6C var_4           = dword ptr -4
.text$mn:00001F6C arg_0           = dword ptr  8
.text$mn:00001F6C arg_4           = dword ptr  0Ch
.text$mn:00001F6C
.text$mn:00001F6C                 push    ebp
.text$mn:00001F6D                 mov     ebp, esp
.text$mn:00001F6F                 push    0FFFFFFFFh
.text$mn:00001F71                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001F76                 mov     eax, large fs:0
.text$mn:00001F7C                 push    eax
.text$mn:00001F7D                 sub     esp, 8
.text$mn:00001F80                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001F85                 xor     eax, ebp
.text$mn:00001F87                 push    eax
.text$mn:00001F88                 lea     eax, [ebp+var_C]
.text$mn:00001F8B                 mov     large fs:0, eax
.text$mn:00001F91                 mov     [ebp+var_14], ecx
.text$mn:00001F94                 mov     [ebp+var_10], 0
.text$mn:00001F9B                 cmp     [ebp+arg_4], 1
.text$mn:00001F9F                 jnz     short loc_1FC5
.text$mn:00001FA1                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00001FA6                 mov     ecx, [ebp+arg_0]
.text$mn:00001FA9                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001FAE                 mov     [ebp+var_4], 0
.text$mn:00001FB5                 mov     eax, [ebp+var_10]
.text$mn:00001FB8                 or      eax, 1
.text$mn:00001FBB                 mov     [ebp+var_10], eax
.text$mn:00001FBE                 mov     eax, [ebp+arg_0]
.text$mn:00001FC1                 jmp     short loc_1FE8
.text$mn:00001FC3 ; ---------------------------------------------------------------------------
.text$mn:00001FC3                 jmp     short loc_1FE8
.text$mn:00001FC5 ; ---------------------------------------------------------------------------
.text$mn:00001FC5
.text$mn:00001FC5 loc_1FC5:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00001FC5                 mov     ecx, [ebp+arg_4]
.text$mn:00001FC8                 push    ecx
.text$mn:00001FC9                 mov     edx, [ebp+arg_0]
.text$mn:00001FCC                 push    edx
.text$mn:00001FCD                 mov     ecx, [ebp+var_14]
.text$mn:00001FD0                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00001FD5                 mov     [ebp+var_4], 0
.text$mn:00001FDC                 mov     eax, [ebp+var_10]
.text$mn:00001FDF                 or      eax, 1
.text$mn:00001FE2                 mov     [ebp+var_10], eax
.text$mn:00001FE5                 mov     eax, [ebp+arg_0]
.text$mn:00001FE8
.text$mn:00001FE8 loc_1FE8:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00001FE8                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00001FE8                 mov     ecx, [ebp+var_C]
.text$mn:00001FEB                 mov     large fs:0, ecx
.text$mn:00001FF2                 pop     ecx
.text$mn:00001FF3                 mov     esp, ebp
.text$mn:00001FF5                 pop     ebp
.text$mn:00001FF6                 retn    8
.text$mn:00001FF6 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001FF6
.text$mn:00001FF6 ; ---------------------------------------------------------------------------
.text$mn:00001FF9                 align 4
.text$mn:00001FF9 _text$mn        ends
.text$mn:00001FF9
.text$x:00001FFC ; ===========================================================================
.text$x:00001FFC
.text$x:00001FFC ; Segment type: Pure code
.text$x:00001FFC ; Segment permissions: Read/Execute
.text$x:00001FFC _text$x         segment para public 'CODE' use32
.text$x:00001FFC                 assume cs:_text$x
.text$x:00001FFC                 ;org 1FFCh
.text$x:00001FFC ; COMDAT (pick associative to section at 1F6C)
.text$x:00001FFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001FFC
.text$x:00001FFC ; =============== S U B R O U T I N E =======================================
.text$x:00001FFC
.text$x:00001FFC
.text$x:00001FFC __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001FFC                                         ; DATA XREF: .xdata$x:000024A8o
.text$x:00001FFC                 mov     eax, [ebp-10h]
.text$x:00001FFF                 and     eax, 1
.text$x:00002002                 jz      $LN6_0
.text$x:00002008                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000200C                 mov     ecx, [ebp+8]
.text$x:0000200F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002014 ; ---------------------------------------------------------------------------
.text$x:00002014
.text$x:00002014 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002014                 retn
.text$x:00002014 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002014
.text$x:00002015
.text$x:00002015 ; =============== S U B R O U T I N E =======================================
.text$x:00002015
.text$x:00002015
.text$x:00002015 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002015                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00002015
.text$x:00002015 arg_4           = dword ptr  8
.text$x:00002015
.text$x:00002015                 mov     edx, [esp+arg_4]
.text$x:00002019                 lea     eax, [edx+0Ch]
.text$x:0000201C                 mov     ecx, [edx-0Ch]
.text$x:0000201F                 xor     ecx, eax
.text$x:00002021                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002026                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000202B                 jmp     ___CxxFrameHandler3
.text$x:0000202B __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000202B
.text$x:0000202B _text$x         ends
.text$x:0000202B
.text$mn:00002030 ; ===========================================================================
.text$mn:00002030
.text$mn:00002030 ; Segment type: Pure code
.text$mn:00002030 ; Segment permissions: Read/Execute
.text$mn:00002030 _text$mn        segment para public 'CODE' use32
.text$mn:00002030                 assume cs:_text$mn
.text$mn:00002030                 ;org 2030h
.text$mn:00002030 ; COMDAT (pick any)
.text$mn:00002030                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002030
.text$mn:00002030 ; =============== S U B R O U T I N E =======================================
.text$mn:00002030
.text$mn:00002030 ; Attributes: bp-based frame
.text$mn:00002030
.text$mn:00002030 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00002030                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002030 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002030                                         ; DATA XREF: .rdata:00002714o
.text$mn:00002030
.text$mn:00002030 var_1C          = dword ptr -1Ch
.text$mn:00002030 var_18          = dword ptr -18h
.text$mn:00002030 Str             = dword ptr -14h
.text$mn:00002030 var_10          = dword ptr -10h
.text$mn:00002030 var_C           = dword ptr -0Ch
.text$mn:00002030 var_4           = dword ptr -4
.text$mn:00002030 arg_0           = dword ptr  8
.text$mn:00002030 arg_4           = dword ptr  0Ch
.text$mn:00002030
.text$mn:00002030                 push    ebp
.text$mn:00002031                 mov     ebp, esp
.text$mn:00002033                 push    0FFFFFFFFh
.text$mn:00002035                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000203A                 mov     eax, large fs:0
.text$mn:00002040                 push    eax
.text$mn:00002041                 sub     esp, 10h
.text$mn:00002044                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002049                 xor     eax, ebp
.text$mn:0000204B                 push    eax
.text$mn:0000204C                 lea     eax, [ebp+var_C]
.text$mn:0000204F                 mov     large fs:0, eax
.text$mn:00002055                 mov     [ebp+var_1C], ecx
.text$mn:00002058                 mov     [ebp+var_18], 0
.text$mn:0000205F                 mov     eax, [ebp+arg_4]
.text$mn:00002062                 push    eax             ; int
.text$mn:00002063                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00002068                 add     esp, 4
.text$mn:0000206B                 mov     [ebp+var_10], eax
.text$mn:0000206E                 cmp     [ebp+var_10], 0
.text$mn:00002072                 jz      short loc_207C
.text$mn:00002074                 mov     ecx, [ebp+var_10]
.text$mn:00002077                 mov     [ebp+Str], ecx
.text$mn:0000207A                 jmp     short loc_2083
.text$mn:0000207C ; ---------------------------------------------------------------------------
.text$mn:0000207C
.text$mn:0000207C loc_207C:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:0000207C                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002083
.text$mn:00002083 loc_2083:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00002083                 mov     edx, [ebp+Str]
.text$mn:00002086                 push    edx             ; Str
.text$mn:00002087                 mov     ecx, [ebp+arg_0]
.text$mn:0000208A                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000208F                 mov     [ebp+var_4], 0
.text$mn:00002096                 mov     eax, [ebp+var_18]
.text$mn:00002099                 or      eax, 1
.text$mn:0000209C                 mov     [ebp+var_18], eax
.text$mn:0000209F                 mov     eax, [ebp+arg_0]
.text$mn:000020A2                 mov     ecx, [ebp+var_C]
.text$mn:000020A5                 mov     large fs:0, ecx
.text$mn:000020AC                 pop     ecx
.text$mn:000020AD                 mov     esp, ebp
.text$mn:000020AF                 pop     ebp
.text$mn:000020B0                 retn    8
.text$mn:000020B0 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000020B0
.text$mn:000020B0 ; ---------------------------------------------------------------------------
.text$mn:000020B3                 align 4
.text$mn:000020B3 _text$mn        ends
.text$mn:000020B3
.text$x:000020B4 ; ===========================================================================
.text$x:000020B4
.text$x:000020B4 ; Segment type: Pure code
.text$x:000020B4 ; Segment permissions: Read/Execute
.text$x:000020B4 _text$x         segment para public 'CODE' use32
.text$x:000020B4                 assume cs:_text$x
.text$x:000020B4                 ;org 20B4h
.text$x:000020B4 ; COMDAT (pick associative to section at 2030)
.text$x:000020B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000020B4
.text$x:000020B4 ; =============== S U B R O U T I N E =======================================
.text$x:000020B4
.text$x:000020B4
.text$x:000020B4 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000020B4                                         ; DATA XREF: .xdata$x:0000252Co
.text$x:000020B4                 mov     eax, [ebp-18h]
.text$x:000020B7                 and     eax, 1
.text$x:000020BA                 jz      $LN6_1
.text$x:000020C0                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000020C4                 mov     ecx, [ebp+8]
.text$x:000020C7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000020CC ; ---------------------------------------------------------------------------
.text$x:000020CC
.text$x:000020CC $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000020CC                 retn
.text$x:000020CC __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000020CC
.text$x:000020CD
.text$x:000020CD ; =============== S U B R O U T I N E =======================================
.text$x:000020CD
.text$x:000020CD
.text$x:000020CD __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000020CD                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:000020CD
.text$x:000020CD arg_4           = dword ptr  8
.text$x:000020CD
.text$x:000020CD                 mov     edx, [esp+arg_4]
.text$x:000020D1                 lea     eax, [edx+0Ch]
.text$x:000020D4                 mov     ecx, [edx-14h]
.text$x:000020D7                 xor     ecx, eax
.text$x:000020D9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000020DE                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000020E3                 jmp     ___CxxFrameHandler3
.text$x:000020E3 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000020E3
.text$x:000020E3 _text$x         ends
.text$x:000020E3
.text$mn:000020E8 ; ===========================================================================
.text$mn:000020E8
.text$mn:000020E8 ; Segment type: Pure code
.text$mn:000020E8 ; Segment permissions: Read/Execute
.text$mn:000020E8 _text$mn        segment para public 'CODE' use32
.text$mn:000020E8                 assume cs:_text$mn
.text$mn:000020E8                 ;org 20E8h
.text$mn:000020E8 ; COMDAT (pick any)
.text$mn:000020E8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000020E8
.text$mn:000020E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000020E8
.text$mn:000020E8 ; Attributes: bp-based frame
.text$mn:000020E8
.text$mn:000020E8 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000020E8                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000020E8 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000020E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000020E8
.text$mn:000020E8 var_4           = dword ptr -4
.text$mn:000020E8 Dst             = dword ptr  8
.text$mn:000020E8 Src             = dword ptr  0Ch
.text$mn:000020E8 Size            = dword ptr  10h
.text$mn:000020E8
.text$mn:000020E8                 push    ebp
.text$mn:000020E9                 mov     ebp, esp
.text$mn:000020EB                 push    ecx
.text$mn:000020EC                 cmp     [ebp+Size], 0
.text$mn:000020F0                 jnz     short loc_20FA
.text$mn:000020F2                 mov     eax, [ebp+Dst]
.text$mn:000020F5                 mov     [ebp+var_4], eax
.text$mn:000020F8                 jmp     short loc_2111
.text$mn:000020FA ; ---------------------------------------------------------------------------
.text$mn:000020FA
.text$mn:000020FA loc_20FA:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:000020FA                 mov     ecx, [ebp+Size]
.text$mn:000020FD                 push    ecx             ; Size
.text$mn:000020FE                 mov     edx, [ebp+Src]
.text$mn:00002101                 push    edx             ; Src
.text$mn:00002102                 mov     eax, [ebp+Dst]
.text$mn:00002105                 push    eax             ; Dst
.text$mn:00002106                 call    _memmove
.text$mn:0000210B                 add     esp, 0Ch
.text$mn:0000210E                 mov     [ebp+var_4], eax
.text$mn:00002111
.text$mn:00002111 loc_2111:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00002111                 mov     eax, [ebp+var_4]
.text$mn:00002114                 mov     esp, ebp
.text$mn:00002116                 pop     ebp
.text$mn:00002117                 retn
.text$mn:00002117 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002117
.text$mn:00002117 _text$mn        ends
.text$mn:00002117
.text$mn:00002118 ; ===========================================================================
.text$mn:00002118
.text$mn:00002118 ; Segment type: Pure code
.text$mn:00002118 ; Segment permissions: Read/Execute
.text$mn:00002118 _text$mn        segment para public 'CODE' use32
.text$mn:00002118                 assume cs:_text$mn
.text$mn:00002118                 ;org 2118h
.text$mn:00002118 ; COMDAT (pick any)
.text$mn:00002118                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002118
.text$mn:00002118 ; =============== S U B R O U T I N E =======================================
.text$mn:00002118
.text$mn:00002118 ; Attributes: bp-based frame
.text$mn:00002118
.text$mn:00002118 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00002118                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00002118 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00002118                                         ; DATA XREF: .rdata:0000269Co
.text$mn:00002118
.text$mn:00002118 var_4           = dword ptr -4
.text$mn:00002118
.text$mn:00002118                 push    ebp
.text$mn:00002119                 mov     ebp, esp
.text$mn:0000211B                 push    ecx
.text$mn:0000211C                 mov     [ebp+var_4], ecx
.text$mn:0000211F                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00002124                 mov     esp, ebp
.text$mn:00002126                 pop     ebp
.text$mn:00002127                 retn
.text$mn:00002127 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00002127
.text$mn:00002127 _text$mn        ends
.text$mn:00002127
.text$mn:00002128 ; ===========================================================================
.text$mn:00002128
.text$mn:00002128 ; Segment type: Pure code
.text$mn:00002128 ; Segment permissions: Read/Execute
.text$mn:00002128 _text$mn        segment para public 'CODE' use32
.text$mn:00002128                 assume cs:_text$mn
.text$mn:00002128                 ;org 2128h
.text$mn:00002128 ; COMDAT (pick any)
.text$mn:00002128                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002128
.text$mn:00002128 ; =============== S U B R O U T I N E =======================================
.text$mn:00002128
.text$mn:00002128 ; Attributes: bp-based frame
.text$mn:00002128
.text$mn:00002128 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00002128                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00002128 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00002128                                         ; DATA XREF: .rdata:000026D0o
.text$mn:00002128
.text$mn:00002128 var_4           = dword ptr -4
.text$mn:00002128
.text$mn:00002128                 push    ebp
.text$mn:00002129                 mov     ebp, esp
.text$mn:0000212B                 push    ecx
.text$mn:0000212C                 mov     [ebp+var_4], ecx
.text$mn:0000212F                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00002134                 mov     esp, ebp
.text$mn:00002136                 pop     ebp
.text$mn:00002137                 retn
.text$mn:00002137 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00002137
.text$mn:00002137 _text$mn        ends
.text$mn:00002137
.text$mn:00002138 ; ===========================================================================
.text$mn:00002138
.text$mn:00002138 ; Segment type: Pure code
.text$mn:00002138 ; Segment permissions: Read/Execute
.text$mn:00002138 _text$mn        segment para public 'CODE' use32
.text$mn:00002138                 assume cs:_text$mn
.text$mn:00002138                 ;org 2138h
.text$mn:00002138 ; COMDAT (pick any)
.text$mn:00002138                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002138
.text$mn:00002138 ; =============== S U B R O U T I N E =======================================
.text$mn:00002138
.text$mn:00002138 ; Attributes: bp-based frame
.text$mn:00002138
.text$mn:00002138 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00002138                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00002138 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00002138                                         ; DATA XREF: .rdata:00002710o
.text$mn:00002138
.text$mn:00002138 var_4           = dword ptr -4
.text$mn:00002138
.text$mn:00002138                 push    ebp
.text$mn:00002139                 mov     ebp, esp
.text$mn:0000213B                 push    ecx
.text$mn:0000213C                 mov     [ebp+var_4], ecx
.text$mn:0000213F                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00002144                 mov     esp, ebp
.text$mn:00002146                 pop     ebp
.text$mn:00002147                 retn
.text$mn:00002147 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00002147
.text$mn:00002147 _text$mn        ends
.text$mn:00002147
.text$mn:00002148 ; ===========================================================================
.text$mn:00002148
.text$mn:00002148 ; Segment type: Pure code
.text$mn:00002148 ; Segment permissions: Read/Execute
.text$mn:00002148 _text$mn        segment para public 'CODE' use32
.text$mn:00002148                 assume cs:_text$mn
.text$mn:00002148                 ;org 2148h
.text$mn:00002148 ; COMDAT (pick any)
.text$mn:00002148                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002148
.text$mn:00002148 ; =============== S U B R O U T I N E =======================================
.text$mn:00002148
.text$mn:00002148 ; Attributes: bp-based frame
.text$mn:00002148
.text$mn:00002148 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00002148                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002148 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002148                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00002148                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00002148
.text$mn:00002148 var_4           = dword ptr -4
.text$mn:00002148
.text$mn:00002148                 push    ebp
.text$mn:00002149                 mov     ebp, esp
.text$mn:0000214B                 push    ecx
.text$mn:0000214C                 mov     [ebp+var_4], ecx
.text$mn:0000214F                 mov     eax, [ebp+var_4]
.text$mn:00002152                 mov     eax, [eax+14h]
.text$mn:00002155                 mov     esp, ebp
.text$mn:00002157                 pop     ebp
.text$mn:00002158                 retn
.text$mn:00002158 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002158
.text$mn:00002158 ; ---------------------------------------------------------------------------
.text$mn:00002159                 align 4
.text$mn:00002159 _text$mn        ends
.text$mn:00002159
.text$mn:0000215C ; ===========================================================================
.text$mn:0000215C
.text$mn:0000215C ; Segment type: Pure code
.text$mn:0000215C ; Segment permissions: Read/Execute
.text$mn:0000215C _text$mn        segment para public 'CODE' use32
.text$mn:0000215C                 assume cs:_text$mn
.text$mn:0000215C                 ;org 215Ch
.text$mn:0000215C ; COMDAT (pick any)
.text$mn:0000215C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000215C
.text$mn:0000215C ; =============== S U B R O U T I N E =======================================
.text$mn:0000215C
.text$mn:0000215C ; Attributes: bp-based frame
.text$mn:0000215C
.text$mn:0000215C ; const struct std::error_category *__cdecl std::system_category()
.text$mn:0000215C                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:0000215C ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:0000215C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_1C74p
.text$mn:0000215C                 push    ebp
.text$mn:0000215D                 mov     ebp, esp
.text$mn:0000215F                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00002164                 pop     ebp
.text$mn:00002165                 retn
.text$mn:00002165 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002165
.text$mn:00002165 ; ---------------------------------------------------------------------------
.text$mn:00002166                 align 4
.text$mn:00002166 _text$mn        ends
.text$mn:00002166
.text$mn:00002168 ; ===========================================================================
.text$mn:00002168
.text$mn:00002168 ; Segment type: Pure code
.text$mn:00002168 ; Segment permissions: Read/Execute
.text$mn:00002168 _text$mn        segment para public 'CODE' use32
.text$mn:00002168                 assume cs:_text$mn
.text$mn:00002168                 ;org 2168h
.text$mn:00002168 ; COMDAT (pick any)
.text$mn:00002168                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002168
.text$mn:00002168 ; =============== S U B R O U T I N E =======================================
.text$mn:00002168
.text$mn:00002168 ; Attributes: bp-based frame
.text$mn:00002168
.text$mn:00002168 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00002168                 public ?value@error_code@std@@QBEHXZ
.text$mn:00002168 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00002168
.text$mn:00002168 var_4           = dword ptr -4
.text$mn:00002168
.text$mn:00002168                 push    ebp
.text$mn:00002169                 mov     ebp, esp
.text$mn:0000216B                 push    ecx
.text$mn:0000216C                 mov     [ebp+var_4], ecx
.text$mn:0000216F                 mov     eax, [ebp+var_4]
.text$mn:00002172                 mov     eax, [eax]
.text$mn:00002174                 mov     esp, ebp
.text$mn:00002176                 pop     ebp
.text$mn:00002177                 retn
.text$mn:00002177 ?value@error_code@std@@QBEHXZ endp
.text$mn:00002177
.text$mn:00002177 _text$mn        ends
.text$mn:00002177
.text$mn:00002178 ; ===========================================================================
.text$mn:00002178
.text$mn:00002178 ; Segment type: Pure code
.text$mn:00002178 ; Segment permissions: Read/Execute
.text$mn:00002178 _text$mn        segment para public 'CODE' use32
.text$mn:00002178                 assume cs:_text$mn
.text$mn:00002178                 ;org 2178h
.text$mn:00002178 ; COMDAT (pick any)
.text$mn:00002178                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002178
.text$mn:00002178 ; =============== S U B R O U T I N E =======================================
.text$mn:00002178
.text$mn:00002178 ; Attributes: bp-based frame
.text$mn:00002178
.text$mn:00002178 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00002178                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00002178 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00002178                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00002178                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00002178
.text$mn:00002178 var_4           = dword ptr -4
.text$mn:00002178
.text$mn:00002178                 push    ebp
.text$mn:00002179                 mov     ebp, esp
.text$mn:0000217B                 push    ecx
.text$mn:0000217C                 mov     [ebp+var_4], ecx
.text$mn:0000217F                 mov     eax, [ebp+var_4]
.text$mn:00002182                 mov     eax, [eax]
.text$mn:00002184                 mov     esp, ebp
.text$mn:00002186                 pop     ebp
.text$mn:00002187                 retn
.text$mn:00002187 ?value@error_condition@std@@QBEHXZ endp
.text$mn:00002187
.text$mn:00002187 _text$mn        ends
.text$mn:00002187
.text$mn:00002188 ; ===========================================================================
.text$mn:00002188
.text$mn:00002188 ; Segment type: Pure code
.text$mn:00002188 ; Segment permissions: Read/Execute
.text$mn:00002188 _text$mn        segment para public 'CODE' use32
.text$mn:00002188                 assume cs:_text$mn
.text$mn:00002188                 ;org 2188h
.text$mn:00002188 ; COMDAT (pick any)
.text$mn:00002188                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002188
.text$mn:00002188 ; =============== S U B R O U T I N E =======================================
.text$mn:00002188
.text$mn:00002188 ; Attributes: bp-based frame
.text$mn:00002188
.text$mn:00002188                 public _hypot
.text$mn:00002188 _hypot          proc near
.text$mn:00002188
.text$mn:00002188 var_10          = qword ptr -10h
.text$mn:00002188 var_8           = qword ptr -8
.text$mn:00002188 arg_0           = qword ptr  8
.text$mn:00002188 arg_8           = qword ptr  10h
.text$mn:00002188
.text$mn:00002188                 push    ebp
.text$mn:00002189                 mov     ebp, esp
.text$mn:0000218B                 sub     esp, 8
.text$mn:0000218E                 movsd   xmm0, [ebp+arg_8]
.text$mn:00002193                 movsd   [esp+8+var_8], xmm0
.text$mn:00002198                 sub     esp, 8
.text$mn:0000219B                 movsd   xmm0, [ebp+arg_0]
.text$mn:000021A0                 movsd   [esp+10h+var_10], xmm0
.text$mn:000021A5                 call    __hypot
.text$mn:000021AA                 add     esp, 10h
.text$mn:000021AD                 pop     ebp
.text$mn:000021AE                 retn
.text$mn:000021AE _hypot          endp
.text$mn:000021AE
.text$mn:000021AE ; ---------------------------------------------------------------------------
.text$mn:000021AF                 align 10h
.text$mn:000021AF _text$mn        ends
.text$mn:000021AF
.xdata$x:000021B0 ; ===========================================================================
.xdata$x:000021B0
.xdata$x:000021B0 ; Segment type: Pure data
.xdata$x:000021B0 ; Segment permissions: Read
.xdata$x:000021B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000021B0                 assume cs:_xdata$x
.xdata$x:000021B0                 ;org 21B0h
.xdata$x:000021B0 ; COMDAT (pick associative to section at 1818)
.xdata$x:000021B0 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:000021B0                                         ; DATA XREF: .xdata$x:000021C0o
.xdata$x:000021B1                 db 0FFh
.xdata$x:000021B2                 db 0FFh
.xdata$x:000021B3                 db 0FFh
.xdata$x:000021B4                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:000021B8 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:000021B8                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:000021B9                 db    5
.xdata$x:000021BA                 db  93h ; ô
.xdata$x:000021BB                 db  19h
.xdata$x:000021BC                 db    1
.xdata$x:000021BD                 db    0
.xdata$x:000021BE                 db    0
.xdata$x:000021BF                 db    0
.xdata$x:000021C0                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:000021C4                 db    0
.xdata$x:000021C5                 db    0
.xdata$x:000021C6                 db    0
.xdata$x:000021C7                 db    0
.xdata$x:000021C8                 db    0
.xdata$x:000021C9                 db    0
.xdata$x:000021CA                 db    0
.xdata$x:000021CB                 db    0
.xdata$x:000021CC                 db    0
.xdata$x:000021CD                 db    0
.xdata$x:000021CE                 db    0
.xdata$x:000021CF                 db    0
.xdata$x:000021D0                 db    0
.xdata$x:000021D1                 db    0
.xdata$x:000021D2                 db    0
.xdata$x:000021D3                 db    0
.xdata$x:000021D4                 db    0
.xdata$x:000021D5                 db    0
.xdata$x:000021D6                 db    0
.xdata$x:000021D7                 db    0
.xdata$x:000021D8                 db    0
.xdata$x:000021D9                 db    0
.xdata$x:000021DA                 db    0
.xdata$x:000021DB                 db    0
.xdata$x:000021DB _xdata$x        ends
.xdata$x:000021DB
.xdata$x:000021DC ; ===========================================================================
.xdata$x:000021DC
.xdata$x:000021DC ; Segment type: Pure data
.xdata$x:000021DC ; Segment permissions: Read
.xdata$x:000021DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000021DC                 assume cs:_xdata$x
.xdata$x:000021DC                 ;org 21DCh
.xdata$x:000021DC ; COMDAT (pick associative to section at A7C)
.xdata$x:000021DC __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000021DC                                         ; DATA XREF: .xdata$x:000021ECo
.xdata$x:000021DD                 db 0FFh
.xdata$x:000021DE                 db 0FFh
.xdata$x:000021DF                 db 0FFh
.xdata$x:000021E0                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000021E4 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000021E4                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000021E5                 db    5
.xdata$x:000021E6                 db  93h ; ô
.xdata$x:000021E7                 db  19h
.xdata$x:000021E8                 db    1
.xdata$x:000021E9                 db    0
.xdata$x:000021EA                 db    0
.xdata$x:000021EB                 db    0
.xdata$x:000021EC                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000021F0                 db    0
.xdata$x:000021F1                 db    0
.xdata$x:000021F2                 db    0
.xdata$x:000021F3                 db    0
.xdata$x:000021F4                 db    0
.xdata$x:000021F5                 db    0
.xdata$x:000021F6                 db    0
.xdata$x:000021F7                 db    0
.xdata$x:000021F8                 db    0
.xdata$x:000021F9                 db    0
.xdata$x:000021FA                 db    0
.xdata$x:000021FB                 db    0
.xdata$x:000021FC                 db    0
.xdata$x:000021FD                 db    0
.xdata$x:000021FE                 db    0
.xdata$x:000021FF                 db    0
.xdata$x:00002200                 db    0
.xdata$x:00002201                 db    0
.xdata$x:00002202                 db    0
.xdata$x:00002203                 db    0
.xdata$x:00002204                 db    0
.xdata$x:00002205                 db    0
.xdata$x:00002206                 db    0
.xdata$x:00002207                 db    0
.xdata$x:00002207 _xdata$x        ends
.xdata$x:00002207
.xdata$x:00002208 ; ===========================================================================
.xdata$x:00002208
.xdata$x:00002208 ; Segment type: Pure data
.xdata$x:00002208 ; Segment permissions: Read
.xdata$x:00002208 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002208                 assume cs:_xdata$x
.xdata$x:00002208                 ;org 2208h
.xdata$x:00002208 ; COMDAT (pick associative to section at F40)
.xdata$x:00002208 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002208                                         ; DATA XREF: .xdata$x:00002218o
.xdata$x:00002209                 db 0FFh
.xdata$x:0000220A                 db 0FFh
.xdata$x:0000220B                 db 0FFh
.xdata$x:0000220C                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002210 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002210                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002211                 db    5
.xdata$x:00002212                 db  93h ; ô
.xdata$x:00002213                 db  19h
.xdata$x:00002214                 db    1
.xdata$x:00002215                 db    0
.xdata$x:00002216                 db    0
.xdata$x:00002217                 db    0
.xdata$x:00002218                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000221C                 db    0
.xdata$x:0000221D                 db    0
.xdata$x:0000221E                 db    0
.xdata$x:0000221F                 db    0
.xdata$x:00002220                 db    0
.xdata$x:00002221                 db    0
.xdata$x:00002222                 db    0
.xdata$x:00002223                 db    0
.xdata$x:00002224                 db    0
.xdata$x:00002225                 db    0
.xdata$x:00002226                 db    0
.xdata$x:00002227                 db    0
.xdata$x:00002228                 db    0
.xdata$x:00002229                 db    0
.xdata$x:0000222A                 db    0
.xdata$x:0000222B                 db    0
.xdata$x:0000222C                 db    0
.xdata$x:0000222D                 db    0
.xdata$x:0000222E                 db    0
.xdata$x:0000222F                 db    0
.xdata$x:00002230                 db    0
.xdata$x:00002231                 db    0
.xdata$x:00002232                 db    0
.xdata$x:00002233                 db    0
.xdata$x:00002233 _xdata$x        ends
.xdata$x:00002233
.xdata$x:00002234 ; ===========================================================================
.xdata$x:00002234
.xdata$x:00002234 ; Segment type: Pure data
.xdata$x:00002234 ; Segment permissions: Read
.xdata$x:00002234 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002234                 assume cs:_xdata$x
.xdata$x:00002234                 ;org 2234h
.xdata$x:00002234 ; COMDAT (pick associative to section at A00)
.xdata$x:00002234 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00002234                                         ; DATA XREF: .xdata$x:00002244o
.xdata$x:00002235                 db 0FFh
.xdata$x:00002236                 db 0FFh
.xdata$x:00002237                 db 0FFh
.xdata$x:00002238                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:0000223C __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:0000223C                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:0000223D                 db    5
.xdata$x:0000223E                 db  93h ; ô
.xdata$x:0000223F                 db  19h
.xdata$x:00002240                 db    1
.xdata$x:00002241                 db    0
.xdata$x:00002242                 db    0
.xdata$x:00002243                 db    0
.xdata$x:00002244                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00002248                 align 20h
.xdata$x:00002248 _xdata$x        ends
.xdata$x:00002248
.xdata$x:00002260 ; ===========================================================================
.xdata$x:00002260
.xdata$x:00002260 ; Segment type: Pure data
.xdata$x:00002260 ; Segment permissions: Read
.xdata$x:00002260 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002260                 assume cs:_xdata$x
.xdata$x:00002260                 ;org 2260h
.xdata$x:00002260 ; COMDAT (pick associative to section at EC8)
.xdata$x:00002260 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002260                                         ; DATA XREF: .xdata$x:00002270o
.xdata$x:00002261                 db 0FFh
.xdata$x:00002262                 db 0FFh
.xdata$x:00002263                 db 0FFh
.xdata$x:00002264                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00002268 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002268                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00002269                 db    5
.xdata$x:0000226A                 db  93h ; ô
.xdata$x:0000226B                 db  19h
.xdata$x:0000226C                 db    1
.xdata$x:0000226D                 db    0
.xdata$x:0000226E                 db    0
.xdata$x:0000226F                 db    0
.xdata$x:00002270                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00002274                 db    0
.xdata$x:00002275                 db    0
.xdata$x:00002276                 db    0
.xdata$x:00002277                 db    0
.xdata$x:00002278                 db    0
.xdata$x:00002279                 db    0
.xdata$x:0000227A                 db    0
.xdata$x:0000227B                 db    0
.xdata$x:0000227C                 db    0
.xdata$x:0000227D                 db    0
.xdata$x:0000227E                 db    0
.xdata$x:0000227F                 db    0
.xdata$x:00002280                 db    0
.xdata$x:00002281                 db    0
.xdata$x:00002282                 db    0
.xdata$x:00002283                 db    0
.xdata$x:00002284                 db    0
.xdata$x:00002285                 db    0
.xdata$x:00002286                 db    0
.xdata$x:00002287                 db    0
.xdata$x:00002288                 db    0
.xdata$x:00002289                 db    0
.xdata$x:0000228A                 db    0
.xdata$x:0000228B                 db    0
.xdata$x:0000228B _xdata$x        ends
.xdata$x:0000228B
.xdata$x:0000228C ; ===========================================================================
.xdata$x:0000228C
.xdata$x:0000228C ; Segment type: Pure data
.xdata$x:0000228C ; Segment permissions: Read
.xdata$x:0000228C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000228C                 assume cs:_xdata$x
.xdata$x:0000228C                 ;org 228Ch
.xdata$x:0000228C ; COMDAT (pick associative to section at B3C)
.xdata$x:0000228C __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:0000228C                                         ; DATA XREF: .xdata$x:0000229Co
.xdata$x:0000228D                 db 0FFh
.xdata$x:0000228E                 db 0FFh
.xdata$x:0000228F                 db 0FFh
.xdata$x:00002290                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00002294 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00002294                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00002295                 db    5
.xdata$x:00002296                 db  93h ; ô
.xdata$x:00002297                 db  19h
.xdata$x:00002298                 db    1
.xdata$x:00002299                 db    0
.xdata$x:0000229A                 db    0
.xdata$x:0000229B                 db    0
.xdata$x:0000229C                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:000022A0                 db    0
.xdata$x:000022A1                 db    0
.xdata$x:000022A2                 db    0
.xdata$x:000022A3                 db    0
.xdata$x:000022A4                 db    0
.xdata$x:000022A5                 db    0
.xdata$x:000022A6                 db    0
.xdata$x:000022A7                 db    0
.xdata$x:000022A8                 db    0
.xdata$x:000022A9                 db    0
.xdata$x:000022AA                 db    0
.xdata$x:000022AB                 db    0
.xdata$x:000022AC                 db    0
.xdata$x:000022AD                 db    0
.xdata$x:000022AE                 db    0
.xdata$x:000022AF                 db    0
.xdata$x:000022B0                 db    0
.xdata$x:000022B1                 db    0
.xdata$x:000022B2                 db    0
.xdata$x:000022B3                 db    0
.xdata$x:000022B4                 db    0
.xdata$x:000022B5                 db    0
.xdata$x:000022B6                 db    0
.xdata$x:000022B7                 db    0
.xdata$x:000022B7 _xdata$x        ends
.xdata$x:000022B7
.xdata$x:000022B8 ; ===========================================================================
.xdata$x:000022B8
.xdata$x:000022B8 ; Segment type: Pure data
.xdata$x:000022B8 ; Segment permissions: Read
.xdata$x:000022B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000022B8                 assume cs:_xdata$x
.xdata$x:000022B8                 ;org 22B8h
.xdata$x:000022B8 ; COMDAT (pick associative to section at FB0)
.xdata$x:000022B8 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:000022B8                                         ; DATA XREF: .xdata$x:000022C8o
.xdata$x:000022B9                 db 0FFh
.xdata$x:000022BA                 db 0FFh
.xdata$x:000022BB                 db 0FFh
.xdata$x:000022BC                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:000022C0 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000022C0                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:000022C1                 db    5
.xdata$x:000022C2                 db  93h ; ô
.xdata$x:000022C3                 db  19h
.xdata$x:000022C4                 db    1
.xdata$x:000022C5                 db    0
.xdata$x:000022C6                 db    0
.xdata$x:000022C7                 db    0
.xdata$x:000022C8                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:000022CC                 db    0
.xdata$x:000022CD                 db    0
.xdata$x:000022CE                 db    0
.xdata$x:000022CF                 db    0
.xdata$x:000022D0                 db    0
.xdata$x:000022D1                 db    0
.xdata$x:000022D2                 db    0
.xdata$x:000022D3                 db    0
.xdata$x:000022D4                 db    0
.xdata$x:000022D5                 db    0
.xdata$x:000022D6                 db    0
.xdata$x:000022D7                 db    0
.xdata$x:000022D8                 db    0
.xdata$x:000022D9                 db    0
.xdata$x:000022DA                 db    0
.xdata$x:000022DB                 db    0
.xdata$x:000022DC                 db    0
.xdata$x:000022DD                 db    0
.xdata$x:000022DE                 db    0
.xdata$x:000022DF                 db    0
.xdata$x:000022E0                 db    0
.xdata$x:000022E1                 db    0
.xdata$x:000022E2                 db    0
.xdata$x:000022E3                 db    0
.xdata$x:000022E3 _xdata$x        ends
.xdata$x:000022E3
.xdata$x:000022E4 ; ===========================================================================
.xdata$x:000022E4
.xdata$x:000022E4 ; Segment type: Pure data
.xdata$x:000022E4 ; Segment permissions: Read
.xdata$x:000022E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000022E4                 assume cs:_xdata$x
.xdata$x:000022E4                 ;org 22E4h
.xdata$x:000022E4 ; COMDAT (pick associative to section at 1474)
.xdata$x:000022E4 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:000022E4                                         ; DATA XREF: .xdata$x:0000236Co
.xdata$x:000022E5                 db    0
.xdata$x:000022E6                 db    0
.xdata$x:000022E7                 db    0
.xdata$x:000022E8                 db    0
.xdata$x:000022E9                 db    0
.xdata$x:000022EA                 db    0
.xdata$x:000022EB                 db    0
.xdata$x:000022EC                 db    0
.xdata$x:000022ED                 db    0
.xdata$x:000022EE                 db    0
.xdata$x:000022EF                 db    0
.xdata$x:000022F0                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:000022F4 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:000022F4                                         ; DATA XREF: .xdata$x:00002358o
.xdata$x:000022F5                 db    0
.xdata$x:000022F6                 db    0
.xdata$x:000022F7                 db    0
.xdata$x:000022F8                 db    0
.xdata$x:000022F9                 db    0
.xdata$x:000022FA                 db    0
.xdata$x:000022FB                 db    0
.xdata$x:000022FC                 db    0
.xdata$x:000022FD                 db    0
.xdata$x:000022FE                 db    0
.xdata$x:000022FF                 db    0
.xdata$x:00002300                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00002304 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002304                                         ; DATA XREF: .xdata$x:0000232Co
.xdata$x:00002305                 db 0FFh
.xdata$x:00002306                 db 0FFh
.xdata$x:00002307                 db 0FFh
.xdata$x:00002308                 db    0
.xdata$x:00002309                 db    0
.xdata$x:0000230A                 db    0
.xdata$x:0000230B                 db    0
.xdata$x:0000230C                 db 0FFh
.xdata$x:0000230D                 db 0FFh
.xdata$x:0000230E                 db 0FFh
.xdata$x:0000230F                 db 0FFh
.xdata$x:00002310                 db    0
.xdata$x:00002311                 db    0
.xdata$x:00002312                 db    0
.xdata$x:00002313                 db    0
.xdata$x:00002314                 db    1
.xdata$x:00002315                 db    0
.xdata$x:00002316                 db    0
.xdata$x:00002317                 db    0
.xdata$x:00002318                 db    0
.xdata$x:00002319                 db    0
.xdata$x:0000231A                 db    0
.xdata$x:0000231B                 db    0
.xdata$x:0000231C                 db    1
.xdata$x:0000231D                 db    0
.xdata$x:0000231E                 db    0
.xdata$x:0000231F                 db    0
.xdata$x:00002320                 db    0
.xdata$x:00002321                 db    0
.xdata$x:00002322                 db    0
.xdata$x:00002323                 db    0
.xdata$x:00002324 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00002324                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00002325                 db    5
.xdata$x:00002326                 db  93h ; ô
.xdata$x:00002327                 db  19h
.xdata$x:00002328                 db    4
.xdata$x:00002329                 db    0
.xdata$x:0000232A                 db    0
.xdata$x:0000232B                 db    0
.xdata$x:0000232C                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002330                 db    2
.xdata$x:00002331                 db    0
.xdata$x:00002332                 db    0
.xdata$x:00002333                 db    0
.xdata$x:00002334                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002338                 db    0
.xdata$x:00002339                 db    0
.xdata$x:0000233A                 db    0
.xdata$x:0000233B                 db    0
.xdata$x:0000233C                 db    0
.xdata$x:0000233D                 db    0
.xdata$x:0000233E                 db    0
.xdata$x:0000233F                 db    0
.xdata$x:00002340                 db    0
.xdata$x:00002341                 db    0
.xdata$x:00002342                 db    0
.xdata$x:00002343                 db    0
.xdata$x:00002344                 db    0
.xdata$x:00002345                 db    0
.xdata$x:00002346                 db    0
.xdata$x:00002347                 db    0
.xdata$x:00002348 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00002348                                         ; DATA XREF: .xdata$x:00002334o
.xdata$x:00002349                 db    0
.xdata$x:0000234A                 db    0
.xdata$x:0000234B                 db    0
.xdata$x:0000234C                 db    2
.xdata$x:0000234D                 db    0
.xdata$x:0000234E                 db    0
.xdata$x:0000234F                 db    0
.xdata$x:00002350                 db    3
.xdata$x:00002351                 db    0
.xdata$x:00002352                 db    0
.xdata$x:00002353                 db    0
.xdata$x:00002354                 db    1
.xdata$x:00002355                 db    0
.xdata$x:00002356                 db    0
.xdata$x:00002357                 db    0
.xdata$x:00002358                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:0000235C                 db    0
.xdata$x:0000235D                 db    0
.xdata$x:0000235E                 db    0
.xdata$x:0000235F                 db    0
.xdata$x:00002360                 db    0
.xdata$x:00002361                 db    0
.xdata$x:00002362                 db    0
.xdata$x:00002363                 db    0
.xdata$x:00002364                 db    3
.xdata$x:00002365                 db    0
.xdata$x:00002366                 db    0
.xdata$x:00002367                 db    0
.xdata$x:00002368                 db    1
.xdata$x:00002369                 db    0
.xdata$x:0000236A                 db    0
.xdata$x:0000236B                 db    0
.xdata$x:0000236C                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:0000236C _xdata$x        ends
.xdata$x:0000236C
.xdata$x:00002370 ; ===========================================================================
.xdata$x:00002370
.xdata$x:00002370 ; Segment type: Pure data
.xdata$x:00002370 ; Segment permissions: Read
.xdata$x:00002370 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002370                 assume cs:_xdata$x
.xdata$x:00002370                 ;org 2370h
.xdata$x:00002370 ; COMDAT (pick associative to section at E44)
.xdata$x:00002370 __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002370                                         ; DATA XREF: .xdata$x:00002380o
.xdata$x:00002371                 db 0FFh
.xdata$x:00002372                 db 0FFh
.xdata$x:00002373                 db 0FFh
.xdata$x:00002374                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:00002378 __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00002378                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:00002379                 db    5
.xdata$x:0000237A                 db  93h ; ô
.xdata$x:0000237B                 db  19h
.xdata$x:0000237C                 db    1
.xdata$x:0000237D                 db    0
.xdata$x:0000237E                 db    0
.xdata$x:0000237F                 db    0
.xdata$x:00002380                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:00002384                 db    0
.xdata$x:00002385                 db    0
.xdata$x:00002386                 db    0
.xdata$x:00002387                 db    0
.xdata$x:00002388                 db    0
.xdata$x:00002389                 db    0
.xdata$x:0000238A                 db    0
.xdata$x:0000238B                 db    0
.xdata$x:0000238C                 db    0
.xdata$x:0000238D                 db    0
.xdata$x:0000238E                 db    0
.xdata$x:0000238F                 db    0
.xdata$x:00002390                 db    0
.xdata$x:00002391                 db    0
.xdata$x:00002392                 db    0
.xdata$x:00002393                 db    0
.xdata$x:00002394                 db    0
.xdata$x:00002395                 db    0
.xdata$x:00002396                 db    0
.xdata$x:00002397                 db    0
.xdata$x:00002398                 db    0
.xdata$x:00002399                 db    0
.xdata$x:0000239A                 db    0
.xdata$x:0000239B                 db    0
.xdata$x:0000239B _xdata$x        ends
.xdata$x:0000239B
.xdata$x:0000239C ; ===========================================================================
.xdata$x:0000239C
.xdata$x:0000239C ; Segment type: Pure data
.xdata$x:0000239C ; Segment permissions: Read
.xdata$x:0000239C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000239C                 assume cs:_xdata$x
.xdata$x:0000239C                 ;org 239Ch
.xdata$x:0000239C ; COMDAT (pick associative to section at 11A4)
.xdata$x:0000239C __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:0000239C                                         ; DATA XREF: .xdata$x:000023ACo
.xdata$x:0000239D                 db 0FFh
.xdata$x:0000239E                 db 0FFh
.xdata$x:0000239F                 db 0FFh
.xdata$x:000023A0                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:000023A4 __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:000023A4                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:000023A5                 db    5
.xdata$x:000023A6                 db  93h ; ô
.xdata$x:000023A7                 db  19h
.xdata$x:000023A8                 db    1
.xdata$x:000023A9                 db    0
.xdata$x:000023AA                 db    0
.xdata$x:000023AB                 db    0
.xdata$x:000023AC                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:000023B0                 db    0
.xdata$x:000023B1                 db    0
.xdata$x:000023B2                 db    0
.xdata$x:000023B3                 db    0
.xdata$x:000023B4                 db    0
.xdata$x:000023B5                 db    0
.xdata$x:000023B6                 db    0
.xdata$x:000023B7                 db    0
.xdata$x:000023B8                 db    0
.xdata$x:000023B9                 db    0
.xdata$x:000023BA                 db    0
.xdata$x:000023BB                 db    0
.xdata$x:000023BC                 db    0
.xdata$x:000023BD                 db    0
.xdata$x:000023BE                 db    0
.xdata$x:000023BF                 db    0
.xdata$x:000023C0                 db    0
.xdata$x:000023C1                 db    0
.xdata$x:000023C2                 db    0
.xdata$x:000023C3                 db    0
.xdata$x:000023C4                 db    0
.xdata$x:000023C5                 db    0
.xdata$x:000023C6                 db    0
.xdata$x:000023C7                 db    0
.xdata$x:000023C7 _xdata$x        ends
.xdata$x:000023C7
.xdata$x:000023C8 ; ===========================================================================
.xdata$x:000023C8
.xdata$x:000023C8 ; Segment type: Pure data
.xdata$x:000023C8 ; Segment permissions: Read
.xdata$x:000023C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000023C8                 assume cs:_xdata$x
.xdata$x:000023C8                 ;org 23C8h
.xdata$x:000023C8 ; COMDAT (pick associative to section at DC0)
.xdata$x:000023C8 __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:000023C8                                         ; DATA XREF: .xdata$x:000023D8o
.xdata$x:000023C9                 db 0FFh
.xdata$x:000023CA                 db 0FFh
.xdata$x:000023CB                 db 0FFh
.xdata$x:000023CC                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:000023D0 __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:000023D0                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:000023D1                 db    5
.xdata$x:000023D2                 db  93h ; ô
.xdata$x:000023D3                 db  19h
.xdata$x:000023D4                 db    1
.xdata$x:000023D5                 db    0
.xdata$x:000023D6                 db    0
.xdata$x:000023D7                 db    0
.xdata$x:000023D8                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:000023DC                 db    0
.xdata$x:000023DD                 db    0
.xdata$x:000023DE                 db    0
.xdata$x:000023DF                 db    0
.xdata$x:000023E0                 db    0
.xdata$x:000023E1                 db    0
.xdata$x:000023E2                 db    0
.xdata$x:000023E3                 db    0
.xdata$x:000023E4                 db    0
.xdata$x:000023E5                 db    0
.xdata$x:000023E6                 db    0
.xdata$x:000023E7                 db    0
.xdata$x:000023E8                 db    0
.xdata$x:000023E9                 db    0
.xdata$x:000023EA                 db    0
.xdata$x:000023EB                 db    0
.xdata$x:000023EC                 db    0
.xdata$x:000023ED                 db    0
.xdata$x:000023EE                 db    0
.xdata$x:000023EF                 db    0
.xdata$x:000023F0                 db    0
.xdata$x:000023F1                 db    0
.xdata$x:000023F2                 db    0
.xdata$x:000023F3                 db    0
.xdata$x:000023F3 _xdata$x        ends
.xdata$x:000023F3
.xdata$x:000023F4 ; ===========================================================================
.xdata$x:000023F4
.xdata$x:000023F4 ; Segment type: Pure data
.xdata$x:000023F4 ; Segment permissions: Read
.xdata$x:000023F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000023F4                 assume cs:_xdata$x
.xdata$x:000023F4                 ;org 23F4h
.xdata$x:000023F4 ; COMDAT (pick associative to section at C10)
.xdata$x:000023F4 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000023F4                                         ; DATA XREF: .xdata$x:00002404o
.xdata$x:000023F5                 db 0FFh
.xdata$x:000023F6                 db 0FFh
.xdata$x:000023F7                 db 0FFh
.xdata$x:000023F8                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:000023FC __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000023FC                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:000023FD                 db    5
.xdata$x:000023FE                 db  93h ; ô
.xdata$x:000023FF                 db  19h
.xdata$x:00002400                 db    1
.xdata$x:00002401                 db    0
.xdata$x:00002402                 db    0
.xdata$x:00002403                 db    0
.xdata$x:00002404                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00002408                 align 20h
.xdata$x:00002408 _xdata$x        ends
.xdata$x:00002408
.xdata$x:00002420 ; ===========================================================================
.xdata$x:00002420
.xdata$x:00002420 ; Segment type: Pure data
.xdata$x:00002420 ; Segment permissions: Read
.xdata$x:00002420 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002420                 assume cs:_xdata$x
.xdata$x:00002420                 ;org 2420h
.xdata$x:00002420 ; COMDAT (pick associative to section at 1EB4)
.xdata$x:00002420 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002420                                         ; DATA XREF: .xdata$x:00002430o
.xdata$x:00002421                 db 0FFh
.xdata$x:00002422                 db 0FFh
.xdata$x:00002423                 db 0FFh
.xdata$x:00002424                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002428 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002428                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002429                 db    5
.xdata$x:0000242A                 db  93h ; ô
.xdata$x:0000242B                 db  19h
.xdata$x:0000242C                 db    1
.xdata$x:0000242D                 db    0
.xdata$x:0000242E                 db    0
.xdata$x:0000242F                 db    0
.xdata$x:00002430                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002434                 db    0
.xdata$x:00002435                 db    0
.xdata$x:00002436                 db    0
.xdata$x:00002437                 db    0
.xdata$x:00002438                 db    0
.xdata$x:00002439                 db    0
.xdata$x:0000243A                 db    0
.xdata$x:0000243B                 db    0
.xdata$x:0000243C                 db    0
.xdata$x:0000243D                 db    0
.xdata$x:0000243E                 db    0
.xdata$x:0000243F                 db    0
.xdata$x:00002440                 db    0
.xdata$x:00002441                 db    0
.xdata$x:00002442                 db    0
.xdata$x:00002443                 db    0
.xdata$x:00002444                 db    0
.xdata$x:00002445                 db    0
.xdata$x:00002446                 db    0
.xdata$x:00002447                 db    0
.xdata$x:00002448                 db    0
.xdata$x:00002449                 db    0
.xdata$x:0000244A                 db    0
.xdata$x:0000244B                 db    0
.xdata$x:0000244B _xdata$x        ends
.xdata$x:0000244B
.xdata$x:0000244C ; ===========================================================================
.xdata$x:0000244C
.xdata$x:0000244C ; Segment type: Pure data
.xdata$x:0000244C ; Segment permissions: Read
.xdata$x:0000244C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000244C                 assume cs:_xdata$x
.xdata$x:0000244C                 ;org 244Ch
.xdata$x:0000244C ; COMDAT (pick associative to section at 1040)
.xdata$x:0000244C __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:0000244C                                         ; DATA XREF: .xdata$x:0000245Co
.xdata$x:0000244D                 db 0FFh
.xdata$x:0000244E                 db 0FFh
.xdata$x:0000244F                 db 0FFh
.xdata$x:00002450                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00002454 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002454                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00002455                 db    5
.xdata$x:00002456                 db  93h ; ô
.xdata$x:00002457                 db  19h
.xdata$x:00002458                 db    1
.xdata$x:00002459                 db    0
.xdata$x:0000245A                 db    0
.xdata$x:0000245B                 db    0
.xdata$x:0000245C                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00002460                 db    0
.xdata$x:00002461                 db    0
.xdata$x:00002462                 db    0
.xdata$x:00002463                 db    0
.xdata$x:00002464                 db    0
.xdata$x:00002465                 db    0
.xdata$x:00002466                 db    0
.xdata$x:00002467                 db    0
.xdata$x:00002468                 db    0
.xdata$x:00002469                 db    0
.xdata$x:0000246A                 db    0
.xdata$x:0000246B                 db    0
.xdata$x:0000246C                 db    0
.xdata$x:0000246D                 db    0
.xdata$x:0000246E                 db    0
.xdata$x:0000246F                 db    0
.xdata$x:00002470                 db    0
.xdata$x:00002471                 db    0
.xdata$x:00002472                 db    0
.xdata$x:00002473                 db    0
.xdata$x:00002474                 db    0
.xdata$x:00002475                 db    0
.xdata$x:00002476                 db    0
.xdata$x:00002477                 db    0
.xdata$x:00002477 _xdata$x        ends
.xdata$x:00002477
.xdata$x:00002478 ; ===========================================================================
.xdata$x:00002478
.xdata$x:00002478 ; Segment type: Pure data
.xdata$x:00002478 ; Segment permissions: Read
.xdata$x:00002478 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002478                 assume cs:_xdata$x
.xdata$x:00002478                 ;org 2478h
.xdata$x:00002478 ; COMDAT (pick associative to section at C8C)
.xdata$x:00002478 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002478                                         ; DATA XREF: .xdata$x:00002488o
.xdata$x:00002479                 db 0FFh
.xdata$x:0000247A                 db 0FFh
.xdata$x:0000247B                 db 0FFh
.xdata$x:0000247C                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00002480 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002480                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00002481                 db    5
.xdata$x:00002482                 db  93h ; ô
.xdata$x:00002483                 db  19h
.xdata$x:00002484                 db    1
.xdata$x:00002485                 db    0
.xdata$x:00002486                 db    0
.xdata$x:00002487                 db    0
.xdata$x:00002488                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:0000248C                 db    0
.xdata$x:0000248D                 db    0
.xdata$x:0000248E                 db    0
.xdata$x:0000248F                 db    0
.xdata$x:00002490                 db    0
.xdata$x:00002491                 db    0
.xdata$x:00002492                 db    0
.xdata$x:00002493                 db    0
.xdata$x:00002494                 db    0
.xdata$x:00002495                 db    0
.xdata$x:00002496                 db    0
.xdata$x:00002497                 db    0
.xdata$x:00002498                 db    0
.xdata$x:00002499                 db    0
.xdata$x:0000249A                 db    0
.xdata$x:0000249B                 db    0
.xdata$x:0000249C                 db    0
.xdata$x:0000249D                 db    0
.xdata$x:0000249E                 db    0
.xdata$x:0000249F                 db    0
.xdata$x:000024A0                 db    0
.xdata$x:000024A1                 db    0
.xdata$x:000024A2                 db    0
.xdata$x:000024A3                 db    0
.xdata$x:000024A3 _xdata$x        ends
.xdata$x:000024A3
.xdata$x:000024A4 ; ===========================================================================
.xdata$x:000024A4
.xdata$x:000024A4 ; Segment type: Pure data
.xdata$x:000024A4 ; Segment permissions: Read
.xdata$x:000024A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000024A4                 assume cs:_xdata$x
.xdata$x:000024A4                 ;org 24A4h
.xdata$x:000024A4 ; COMDAT (pick associative to section at 1F6C)
.xdata$x:000024A4 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000024A4                                         ; DATA XREF: .xdata$x:000024B4o
.xdata$x:000024A5                 db 0FFh
.xdata$x:000024A6                 db 0FFh
.xdata$x:000024A7                 db 0FFh
.xdata$x:000024A8                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000024AC __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000024AC                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000024AD                 db    5
.xdata$x:000024AE                 db  93h ; ô
.xdata$x:000024AF                 db  19h
.xdata$x:000024B0                 db    1
.xdata$x:000024B1                 db    0
.xdata$x:000024B2                 db    0
.xdata$x:000024B3                 db    0
.xdata$x:000024B4                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000024B8                 db    0
.xdata$x:000024B9                 db    0
.xdata$x:000024BA                 db    0
.xdata$x:000024BB                 db    0
.xdata$x:000024BC                 db    0
.xdata$x:000024BD                 db    0
.xdata$x:000024BE                 db    0
.xdata$x:000024BF                 db    0
.xdata$x:000024C0                 db    0
.xdata$x:000024C1                 db    0
.xdata$x:000024C2                 db    0
.xdata$x:000024C3                 db    0
.xdata$x:000024C4                 db    0
.xdata$x:000024C5                 db    0
.xdata$x:000024C6                 db    0
.xdata$x:000024C7                 db    0
.xdata$x:000024C8                 db    0
.xdata$x:000024C9                 db    0
.xdata$x:000024CA                 db    0
.xdata$x:000024CB                 db    0
.xdata$x:000024CC                 db    0
.xdata$x:000024CD                 db    0
.xdata$x:000024CE                 db    0
.xdata$x:000024CF                 db    0
.xdata$x:000024CF _xdata$x        ends
.xdata$x:000024CF
.xdata$x:000024D0 ; ===========================================================================
.xdata$x:000024D0
.xdata$x:000024D0 ; Segment type: Pure data
.xdata$x:000024D0 ; Segment permissions: Read
.xdata$x:000024D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000024D0                 assume cs:_xdata$x
.xdata$x:000024D0                 ;org 24D0h
.xdata$x:000024D0 ; COMDAT (pick associative to section at 10B0)
.xdata$x:000024D0 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000024D0                                         ; DATA XREF: .xdata$x:000024E0o
.xdata$x:000024D1                 db 0FFh
.xdata$x:000024D2                 db 0FFh
.xdata$x:000024D3                 db 0FFh
.xdata$x:000024D4                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:000024D8 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000024D8                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:000024D9                 db    5
.xdata$x:000024DA                 db  93h ; ô
.xdata$x:000024DB                 db  19h
.xdata$x:000024DC                 db    1
.xdata$x:000024DD                 db    0
.xdata$x:000024DE                 db    0
.xdata$x:000024DF                 db    0
.xdata$x:000024E0                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000024E4                 db    0
.xdata$x:000024E5                 db    0
.xdata$x:000024E6                 db    0
.xdata$x:000024E7                 db    0
.xdata$x:000024E8                 db    0
.xdata$x:000024E9                 db    0
.xdata$x:000024EA                 db    0
.xdata$x:000024EB                 db    0
.xdata$x:000024EC                 db    0
.xdata$x:000024ED                 db    0
.xdata$x:000024EE                 db    0
.xdata$x:000024EF                 db    0
.xdata$x:000024F0                 db    0
.xdata$x:000024F1                 db    0
.xdata$x:000024F2                 db    0
.xdata$x:000024F3                 db    0
.xdata$x:000024F4                 db    0
.xdata$x:000024F5                 db    0
.xdata$x:000024F6                 db    0
.xdata$x:000024F7                 db    0
.xdata$x:000024F8                 db    0
.xdata$x:000024F9                 db    0
.xdata$x:000024FA                 db    0
.xdata$x:000024FB                 db    0
.xdata$x:000024FB _xdata$x        ends
.xdata$x:000024FB
.xdata$x:000024FC ; ===========================================================================
.xdata$x:000024FC
.xdata$x:000024FC ; Segment type: Pure data
.xdata$x:000024FC ; Segment permissions: Read
.xdata$x:000024FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000024FC                 assume cs:_xdata$x
.xdata$x:000024FC                 ;org 24FCh
.xdata$x:000024FC ; COMDAT (pick associative to section at D08)
.xdata$x:000024FC __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000024FC                                         ; DATA XREF: .xdata$x:0000250Co
.xdata$x:000024FD                 db 0FFh
.xdata$x:000024FE                 db 0FFh
.xdata$x:000024FF                 db 0FFh
.xdata$x:00002500                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00002504 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002504                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00002505                 db    5
.xdata$x:00002506                 db  93h ; ô
.xdata$x:00002507                 db  19h
.xdata$x:00002508                 db    1
.xdata$x:00002509                 db    0
.xdata$x:0000250A                 db    0
.xdata$x:0000250B                 db    0
.xdata$x:0000250C                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00002510                 db    0
.xdata$x:00002511                 db    0
.xdata$x:00002512                 db    0
.xdata$x:00002513                 db    0
.xdata$x:00002514                 db    0
.xdata$x:00002515                 db    0
.xdata$x:00002516                 db    0
.xdata$x:00002517                 db    0
.xdata$x:00002518                 db    0
.xdata$x:00002519                 db    0
.xdata$x:0000251A                 db    0
.xdata$x:0000251B                 db    0
.xdata$x:0000251C                 db    0
.xdata$x:0000251D                 db    0
.xdata$x:0000251E                 db    0
.xdata$x:0000251F                 db    0
.xdata$x:00002520                 db    0
.xdata$x:00002521                 db    0
.xdata$x:00002522                 db    0
.xdata$x:00002523                 db    0
.xdata$x:00002524                 db    0
.xdata$x:00002525                 db    0
.xdata$x:00002526                 db    0
.xdata$x:00002527                 db    0
.xdata$x:00002527 _xdata$x        ends
.xdata$x:00002527
.xdata$x:00002528 ; ===========================================================================
.xdata$x:00002528
.xdata$x:00002528 ; Segment type: Pure data
.xdata$x:00002528 ; Segment permissions: Read
.xdata$x:00002528 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002528                 assume cs:_xdata$x
.xdata$x:00002528                 ;org 2528h
.xdata$x:00002528 ; COMDAT (pick associative to section at 2030)
.xdata$x:00002528 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002528                                         ; DATA XREF: .xdata$x:00002538o
.xdata$x:00002529                 db 0FFh
.xdata$x:0000252A                 db 0FFh
.xdata$x:0000252B                 db 0FFh
.xdata$x:0000252C                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00002530 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00002530                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00002531                 db    5
.xdata$x:00002532                 db  93h ; ô
.xdata$x:00002533                 db  19h
.xdata$x:00002534                 db    1
.xdata$x:00002535                 db    0
.xdata$x:00002536                 db    0
.xdata$x:00002537                 db    0
.xdata$x:00002538                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000253C                 db    0
.xdata$x:0000253D                 db    0
.xdata$x:0000253E                 db    0
.xdata$x:0000253F                 db    0
.xdata$x:00002540                 db    0
.xdata$x:00002541                 db    0
.xdata$x:00002542                 db    0
.xdata$x:00002543                 db    0
.xdata$x:00002544                 db    0
.xdata$x:00002545                 db    0
.xdata$x:00002546                 db    0
.xdata$x:00002547                 db    0
.xdata$x:00002548                 db    0
.xdata$x:00002549                 db    0
.xdata$x:0000254A                 db    0
.xdata$x:0000254B                 db    0
.xdata$x:0000254C                 db    0
.xdata$x:0000254D                 db    0
.xdata$x:0000254E                 db    0
.xdata$x:0000254F                 db    0
.xdata$x:00002550                 db    0
.xdata$x:00002551                 db    0
.xdata$x:00002552                 db    0
.xdata$x:00002553                 db    0
.xdata$x:00002553 _xdata$x        ends
.xdata$x:00002553
.xdata$x:00002554 ; ===========================================================================
.xdata$x:00002554
.xdata$x:00002554 ; Segment type: Pure data
.xdata$x:00002554 ; Segment permissions: Read
.xdata$x:00002554 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002554                 assume cs:_xdata$x
.xdata$x:00002554                 ;org 2554h
.xdata$x:00002554 ; COMDAT (pick associative to section at 1120)
.xdata$x:00002554 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002554                                         ; DATA XREF: .xdata$x:00002564o
.xdata$x:00002555                 db 0FFh
.xdata$x:00002556                 db 0FFh
.xdata$x:00002557                 db 0FFh
.xdata$x:00002558                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:0000255C __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000255C                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:0000255D                 db    5
.xdata$x:0000255E                 db  93h ; ô
.xdata$x:0000255F                 db  19h
.xdata$x:00002560                 db    1
.xdata$x:00002561                 db    0
.xdata$x:00002562                 db    0
.xdata$x:00002563                 db    0
.xdata$x:00002564                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00002568                 align 20h
.xdata$x:00002568 _xdata$x        ends
.xdata$x:00002568
.xdata$x:00002580 ; ===========================================================================
.xdata$x:00002580
.xdata$x:00002580 ; Segment type: Pure data
.xdata$x:00002580 ; Segment permissions: Read
.xdata$x:00002580 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002580                 assume cs:_xdata$x
.xdata$x:00002580                 ;org 2580h
.xdata$x:00002580 ; COMDAT (pick associative to section at 8E4)
.xdata$x:00002580 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002580                                         ; DATA XREF: .xdata$x:00002590o
.xdata$x:00002581                 db 0FFh
.xdata$x:00002582                 db 0FFh
.xdata$x:00002583                 db 0FFh
.xdata$x:00002584                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00002588 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00002588                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00002589                 db    5
.xdata$x:0000258A                 db  93h ; ô
.xdata$x:0000258B                 db  19h
.xdata$x:0000258C                 db    1
.xdata$x:0000258D                 db    0
.xdata$x:0000258E                 db    0
.xdata$x:0000258F                 db    0
.xdata$x:00002590                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00002594                 db    0
.xdata$x:00002595                 db    0
.xdata$x:00002596                 db    0
.xdata$x:00002597                 db    0
.xdata$x:00002598                 db    0
.xdata$x:00002599                 db    0
.xdata$x:0000259A                 db    0
.xdata$x:0000259B                 db    0
.xdata$x:0000259C                 db    0
.xdata$x:0000259D                 db    0
.xdata$x:0000259E                 db    0
.xdata$x:0000259F                 db    0
.xdata$x:000025A0                 db    0
.xdata$x:000025A1                 db    0
.xdata$x:000025A2                 db    0
.xdata$x:000025A3                 db    0
.xdata$x:000025A4                 db    0
.xdata$x:000025A5                 db    0
.xdata$x:000025A6                 db    0
.xdata$x:000025A7                 db    0
.xdata$x:000025A8                 db    0
.xdata$x:000025A9                 db    0
.xdata$x:000025AA                 db    0
.xdata$x:000025AB                 db    0
.xdata$x:000025AB _xdata$x        ends
.xdata$x:000025AB
.xdata$x:000025AC ; ===========================================================================
.xdata$x:000025AC
.xdata$x:000025AC ; Segment type: Pure data
.xdata$x:000025AC ; Segment permissions: Read
.xdata$x:000025AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000025AC                 assume cs:_xdata$x
.xdata$x:000025AC                 ;org 25ACh
.xdata$x:000025AC ; COMDAT (pick associative to section at 810)
.xdata$x:000025AC __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:000025AC                                         ; DATA XREF: .xdata$x:000025BCo
.xdata$x:000025AD                 db 0FFh
.xdata$x:000025AE                 db 0FFh
.xdata$x:000025AF                 db 0FFh
.xdata$x:000025B0                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:000025B4 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:000025B4                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:000025B5                 db    5
.xdata$x:000025B6                 db  93h ; ô
.xdata$x:000025B7                 db  19h
.xdata$x:000025B8                 db    1
.xdata$x:000025B9                 db    0
.xdata$x:000025BA                 db    0
.xdata$x:000025BB                 db    0
.xdata$x:000025BC                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:000025C0                 db    0
.xdata$x:000025C1                 db    0
.xdata$x:000025C2                 db    0
.xdata$x:000025C3                 db    0
.xdata$x:000025C4                 db    0
.xdata$x:000025C5                 db    0
.xdata$x:000025C6                 db    0
.xdata$x:000025C7                 db    0
.xdata$x:000025C8                 db    0
.xdata$x:000025C9                 db    0
.xdata$x:000025CA                 db    0
.xdata$x:000025CB                 db    0
.xdata$x:000025CC                 db    0
.xdata$x:000025CD                 db    0
.xdata$x:000025CE                 db    0
.xdata$x:000025CF                 db    0
.xdata$x:000025D0                 db    0
.xdata$x:000025D1                 db    0
.xdata$x:000025D2                 db    0
.xdata$x:000025D3                 db    0
.xdata$x:000025D4                 db    0
.xdata$x:000025D5                 db    0
.xdata$x:000025D6                 db    0
.xdata$x:000025D7                 db    0
.xdata$x:000025D7 _xdata$x        ends
.xdata$x:000025D7
.bss:000025D8 ; ===========================================================================
.bss:000025D8
.bss:000025D8 ; Segment type: Uninitialized
.bss:000025D8 ; Segment permissions: Read/Write
.bss:000025D8 _bss            segment byte public 'BSS' use32
.bss:000025D8                 assume cs:_bss
.bss:000025D8                 ;org 25D8h
.bss:000025D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000025D8 _allocator_arg  db    ? ;
.bss:000025D9 _piecewise_construct db    ? ;
.bss:000025DA                 align 4
.bss:000025DA _bss            ends
.bss:000025DA
.rdata:000025DC ; ===========================================================================
.rdata:000025DC
.rdata:000025DC ; Segment type: Pure data
.rdata:000025DC ; Segment permissions: Read
.rdata:000025DC _rdata          segment dword public 'DATA' use32
.rdata:000025DC                 assume cs:_rdata
.rdata:000025DC                 ;org 25DCh
.rdata:000025DC ; COMDAT (pick largest)
.rdata:000025DC                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:000025E0                 public ??_7runtime_error@std@@6B@
.rdata:000025E0 ; const std::runtime_error::`vftable'
.rdata:000025E0 ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:000025E0                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:000025E0                                         ; std::runtime_error::runtime_error(char const *)+3Co
.rdata:000025E0                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:000025E4                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:000025E4 _rdata          ends
.rdata:000025E4
.xdata$x:000025E8 ; ===========================================================================
.xdata$x:000025E8
.xdata$x:000025E8 ; Segment type: Pure data
.xdata$x:000025E8 ; Segment permissions: Read
.xdata$x:000025E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000025E8                 assume cs:_xdata$x
.xdata$x:000025E8                 ;org 25E8h
.xdata$x:000025E8 ; COMDAT (pick any)
.xdata$x:000025E8                 public __TI2?AVruntime_error@std@@
.xdata$x:000025E8 __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: ColourPopup::create(int)+47o
.xdata$x:000025E9                 db    0
.xdata$x:000025EA                 db    0
.xdata$x:000025EB                 db    0
.xdata$x:000025EC                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:000025F0                 db    0
.xdata$x:000025F1                 db    0
.xdata$x:000025F2                 db    0
.xdata$x:000025F3                 db    0
.xdata$x:000025F4                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:000025F4 _xdata$x        ends
.xdata$x:000025F4
.xdata$x:000025F8 ; ===========================================================================
.xdata$x:000025F8
.xdata$x:000025F8 ; Segment type: Pure data
.xdata$x:000025F8 ; Segment permissions: Read
.xdata$x:000025F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000025F8                 assume cs:_xdata$x
.xdata$x:000025F8                 ;org 25F8h
.xdata$x:000025F8 ; COMDAT (pick any)
.xdata$x:000025F8                 public __CTA2?AVruntime_error@std@@
.xdata$x:000025F8 __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:000025F4o
.xdata$x:000025F9                 db    0
.xdata$x:000025FA                 db    0
.xdata$x:000025FB                 db    0
.xdata$x:000025FC                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00002600                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00002600 _xdata$x        ends
.xdata$x:00002600
.data$r:00002604 ; ===========================================================================
.data$r:00002604
.data$r:00002604 ; Segment type: Pure data
.data$r:00002604 ; Segment permissions: Read/Write
.data$r:00002604 _data$r         segment dword public 'DATA' use32
.data$r:00002604                 assume cs:_data$r
.data$r:00002604                 ;org 2604h
.data$r:00002604 ; COMDAT (pick any)
.data$r:00002604                 public ??_R0?AVruntime_error@std@@@8
.data$r:00002604 ; class std::runtime_error `RTTI Type Descriptor'
.data$r:00002604 ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002604                                         ; DATA XREF: .xdata$x:00002628o
.data$r:00002604                                         ; .rdata$r:0000289Co ...
.data$r:00002604                                         ; const type_info::`vftable'
.data$r:00002608                 db    0
.data$r:00002609                 db    0
.data$r:0000260A                 db    0
.data$r:0000260B                 db    0
.data$r:0000260C                 db  2Eh ; .
.data$r:0000260D                 db  3Fh ; ?
.data$r:0000260E                 db  41h ; A
.data$r:0000260F                 db  56h ; V
.data$r:00002610                 db  72h ; r
.data$r:00002611                 db  75h ; u
.data$r:00002612                 db  6Eh ; n
.data$r:00002613                 db  74h ; t
.data$r:00002614                 db  69h ; i
.data$r:00002615                 db  6Dh ; m
.data$r:00002616                 db  65h ; e
.data$r:00002617                 db  5Fh ; _
.data$r:00002618                 db  65h ; e
.data$r:00002619                 db  72h ; r
.data$r:0000261A                 db  72h ; r
.data$r:0000261B                 db  6Fh ; o
.data$r:0000261C                 db  72h ; r
.data$r:0000261D                 db  40h ; @
.data$r:0000261E                 db  73h ; s
.data$r:0000261F                 db  74h ; t
.data$r:00002620                 db  64h ; d
.data$r:00002621                 db  40h ; @
.data$r:00002622                 db  40h ; @
.data$r:00002623                 db    0
.data$r:00002623 _data$r         ends
.data$r:00002623
.xdata$x:00002624 ; ===========================================================================
.xdata$x:00002624
.xdata$x:00002624 ; Segment type: Pure data
.xdata$x:00002624 ; Segment permissions: Read
.xdata$x:00002624 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002624                 assume cs:_xdata$x
.xdata$x:00002624                 ;org 2624h
.xdata$x:00002624 ; COMDAT (pick any)
.xdata$x:00002624                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00002624 __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00002624                                         ; DATA XREF: .xdata$x:000025FCo
.xdata$x:00002625                 db    0
.xdata$x:00002626                 db    0
.xdata$x:00002627                 db    0
.xdata$x:00002628                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:0000262C                 align 10h
.xdata$x:00002630                 db 0FFh
.xdata$x:00002631                 db 0FFh
.xdata$x:00002632                 db 0FFh
.xdata$x:00002633                 db 0FFh
.xdata$x:00002634                 db    0
.xdata$x:00002635                 db    0
.xdata$x:00002636                 db    0
.xdata$x:00002637                 db    0
.xdata$x:00002638                 db  0Ch
.xdata$x:00002639                 db    0
.xdata$x:0000263A                 db    0
.xdata$x:0000263B                 db    0
.xdata$x:0000263C                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:0000263C _xdata$x        ends
.xdata$x:0000263C
.data$r:00002640 ; ===========================================================================
.data$r:00002640
.data$r:00002640 ; Segment type: Pure data
.data$r:00002640 ; Segment permissions: Read/Write
.data$r:00002640 _data$r         segment dword public 'DATA' use32
.data$r:00002640                 assume cs:_data$r
.data$r:00002640                 ;org 2640h
.data$r:00002640 ; COMDAT (pick any)
.data$r:00002640                 public ??_R0?AVexception@std@@@8
.data$r:00002640 ; class std::exception `RTTI Type Descriptor'
.data$r:00002640 ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002640                                         ; DATA XREF: .xdata$x:00002660o
.data$r:00002640                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002640                                         ; const type_info::`vftable'
.data$r:00002644                 align 8
.data$r:00002648 a_?avexception@ db '.?AVexception@std@@',0
.data$r:00002648 _data$r         ends
.data$r:00002648
.xdata$x:0000265C ; ===========================================================================
.xdata$x:0000265C
.xdata$x:0000265C ; Segment type: Pure data
.xdata$x:0000265C ; Segment permissions: Read
.xdata$x:0000265C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000265C                 assume cs:_xdata$x
.xdata$x:0000265C                 ;org 265Ch
.xdata$x:0000265C ; COMDAT (pick any)
.xdata$x:0000265C                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:0000265C __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:0000265C                                         ; DATA XREF: .xdata$x:00002600o
.xdata$x:0000265D                 db    0
.xdata$x:0000265E                 db    0
.xdata$x:0000265F                 db    0
.xdata$x:00002660                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:00002664                 align 8
.xdata$x:00002668                 db 0FFh
.xdata$x:00002669                 db 0FFh
.xdata$x:0000266A                 db 0FFh
.xdata$x:0000266B                 db 0FFh
.xdata$x:0000266C                 db    0
.xdata$x:0000266D                 db    0
.xdata$x:0000266E                 db    0
.xdata$x:0000266F                 db    0
.xdata$x:00002670                 db  0Ch
.xdata$x:00002671                 db    0
.xdata$x:00002672                 db    0
.xdata$x:00002673                 db    0
.xdata$x:00002674                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:00002674 _xdata$x        ends
.xdata$x:00002674
.rdata:00002678 ; ===========================================================================
.rdata:00002678
.rdata:00002678 ; Segment type: Pure data
.rdata:00002678 ; Segment permissions: Read
.rdata:00002678 _rdata          segment dword public 'DATA' use32
.rdata:00002678                 assume cs:_rdata
.rdata:00002678                 ;org 2678h
.rdata:00002678 ; COMDAT (pick largest)
.rdata:00002678                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:0000267C                 public ??_7error_category@std@@6B@
.rdata:0000267C ; const std::error_category::`vftable'
.rdata:0000267C ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:0000267C                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:0000267C                                         ; std::error_category::~error_category(void)+Ao
.rdata:0000267C                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00002680                 dd offset __purecall
.rdata:00002684                 dd offset __purecall
.rdata:00002688                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000268C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002690                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002690 _rdata          ends
.rdata:00002690
.rdata:00002694 ; ===========================================================================
.rdata:00002694
.rdata:00002694 ; Segment type: Pure data
.rdata:00002694 ; Segment permissions: Read
.rdata:00002694 _rdata          segment dword public 'DATA' use32
.rdata:00002694                 assume cs:_rdata
.rdata:00002694                 ;org 2694h
.rdata:00002694 ; COMDAT (pick largest)
.rdata:00002694                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00002698                 public ??_7_Generic_error_category@std@@6B@
.rdata:00002698 ; const std::_Generic_error_category::`vftable'
.rdata:00002698 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00002698                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00002698                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:0000269C                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:000026A0                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:000026A4                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000026A8                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000026AC                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000026AC _rdata          ends
.rdata:000026AC
.rdata:000026B0 ; ===========================================================================
.rdata:000026B0
.rdata:000026B0 ; Segment type: Pure data
.rdata:000026B0 ; Segment permissions: Read
.rdata:000026B0 _rdata          segment dword public 'DATA' use32
.rdata:000026B0                 assume cs:_rdata
.rdata:000026B0                 ;org 26B0h
.rdata:000026B0 ; COMDAT (pick any)
.rdata:000026B0                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:000026B0 ; `string'
.rdata:000026B0 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:000026B0                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:000026B0 _rdata          ends
.rdata:000026B0
.rdata:000026B8 ; ===========================================================================
.rdata:000026B8
.rdata:000026B8 ; Segment type: Pure data
.rdata:000026B8 ; Segment permissions: Read
.rdata:000026B8 _rdata          segment dword public 'DATA' use32
.rdata:000026B8                 assume cs:_rdata
.rdata:000026B8                 ;org 26B8h
.rdata:000026B8 ; COMDAT (pick any)
.rdata:000026B8                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:000026B8 ; `string'
.rdata:000026B8 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:000026B8                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_1F00o
.rdata:000026B8                                         ; std::_System_error_category::message(int):loc_207Co
.rdata:000026C6                 align 4
.rdata:000026C6 _rdata          ends
.rdata:000026C6
.rdata:000026C8 ; ===========================================================================
.rdata:000026C8
.rdata:000026C8 ; Segment type: Pure data
.rdata:000026C8 ; Segment permissions: Read
.rdata:000026C8 _rdata          segment dword public 'DATA' use32
.rdata:000026C8                 assume cs:_rdata
.rdata:000026C8                 ;org 26C8h
.rdata:000026C8 ; COMDAT (pick largest)
.rdata:000026C8                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:000026CC                 public ??_7_Iostream_error_category@std@@6B@
.rdata:000026CC ; const std::_Iostream_error_category::`vftable'
.rdata:000026CC ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:000026CC                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:000026CC                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:000026D0                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:000026D4                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:000026D8                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000026DC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000026E0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000026E0 _rdata          ends
.rdata:000026E0
.rdata:000026E4 ; ===========================================================================
.rdata:000026E4
.rdata:000026E4 ; Segment type: Pure data
.rdata:000026E4 ; Segment permissions: Read
.rdata:000026E4 _rdata          segment dword public 'DATA' use32
.rdata:000026E4                 assume cs:_rdata
.rdata:000026E4                 ;org 26E4h
.rdata:000026E4 ; COMDAT (pick any)
.rdata:000026E4                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:000026E4 ; `string'
.rdata:000026E4 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:000026E4                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:000026ED                 align 10h
.rdata:000026ED _rdata          ends
.rdata:000026ED
.rdata:000026F0 ; ===========================================================================
.rdata:000026F0
.rdata:000026F0 ; Segment type: Pure data
.rdata:000026F0 ; Segment permissions: Read
.rdata:000026F0 _rdata          segment dword public 'DATA' use32
.rdata:000026F0                 assume cs:_rdata
.rdata:000026F0                 ;org 26F0h
.rdata:000026F0 ; COMDAT (pick any)
.rdata:000026F0                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:000026F0 ; char `string'[]
.rdata:000026F0 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:000026F0                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00002706                 align 4
.rdata:00002706 _rdata          ends
.rdata:00002706
.rdata:00002708 ; ===========================================================================
.rdata:00002708
.rdata:00002708 ; Segment type: Pure data
.rdata:00002708 ; Segment permissions: Read
.rdata:00002708 _rdata          segment dword public 'DATA' use32
.rdata:00002708                 assume cs:_rdata
.rdata:00002708                 ;org 2708h
.rdata:00002708 ; COMDAT (pick largest)
.rdata:00002708                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:0000270C                 public ??_7_System_error_category@std@@6B@
.rdata:0000270C ; const std::_System_error_category::`vftable'
.rdata:0000270C ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:0000270C                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:0000270C                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00002710                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00002714                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00002718                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:0000271C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00002720                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00002720 _rdata          ends
.rdata:00002720
.rdata:00002724 ; ===========================================================================
.rdata:00002724
.rdata:00002724 ; Segment type: Pure data
.rdata:00002724 ; Segment permissions: Read
.rdata:00002724 _rdata          segment dword public 'DATA' use32
.rdata:00002724                 assume cs:_rdata
.rdata:00002724                 ;org 2724h
.rdata:00002724 ; COMDAT (pick any)
.rdata:00002724                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00002724 ; `string'
.rdata:00002724 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00002724                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000272B                 align 4
.rdata:0000272B _rdata          ends
.rdata:0000272B
.bss:0000272C ; ===========================================================================
.bss:0000272C
.bss:0000272C ; Segment type: Uninitialized
.bss:0000272C ; Segment permissions: Read/Write
.bss:0000272C _bss            segment dword public 'BSS' use32
.bss:0000272C                 assume cs:_bss
.bss:0000272C                 ;org 272Ch
.bss:0000272C ; COMDAT (pick any)
.bss:0000272C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:0000272C                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:0000272C ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:0000272C ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:0000272C                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:0000272C                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:0000272D                 db    ? ;
.bss:0000272E                 db    ? ;
.bss:0000272F                 db    ? ;
.bss:0000272F _bss            ends
.bss:0000272F
.bss:00002730 ; ===========================================================================
.bss:00002730
.bss:00002730 ; Segment type: Uninitialized
.bss:00002730 ; Segment permissions: Read/Write
.bss:00002730 _bss            segment dword public 'BSS' use32
.bss:00002730                 assume cs:_bss
.bss:00002730                 ;org 2730h
.bss:00002730 ; COMDAT (pick any)
.bss:00002730                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002730                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00002730 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00002730 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00002730                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002730                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00002731                 db    ? ;
.bss:00002732                 db    ? ;
.bss:00002733                 db    ? ;
.bss:00002733 _bss            ends
.bss:00002733
.bss:00002734 ; ===========================================================================
.bss:00002734
.bss:00002734 ; Segment type: Uninitialized
.bss:00002734 ; Segment permissions: Read/Write
.bss:00002734 _bss            segment dword public 'BSS' use32
.bss:00002734                 assume cs:_bss
.bss:00002734                 ;org 2734h
.bss:00002734 ; COMDAT (pick any)
.bss:00002734                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00002734                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00002734 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00002734 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00002734                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00002734                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00002735                 db    ? ;
.bss:00002736                 db    ? ;
.bss:00002737                 db    ? ;
.bss:00002737 _bss            ends
.bss:00002737
.data:00002738 ; ===========================================================================
.data:00002738
.data:00002738 ; Segment type: Pure data
.data:00002738 ; Segment permissions: Read/Write
.data:00002738 ; Segment alignment 'qword' can not be represented in assembly
.data:00002738 _data           segment para public 'DATA' use32
.data:00002738                 assume cs:_data
.data:00002738                 ;org 2738h
.data:00002738 ; COMDAT (pick any)
.data:00002738 ; unsigned long * `private: int __stdcall ColourPopup::run_dlgProc(unsigned int, unsigned int, long)'::`22'::acrCustClr
.data:00002738 ?acrCustClr@?BG@??run_dlgProc@ColourPopup@@AAGHIIJ@Z@4PAKA db 0FFh
.data:00002738                                         ; DATA XREF: ColourPopup::run_dlgProc(uint,uint,long)+3A6o
.data:00002739                 db 0FFh
.data:0000273A                 db 0FFh
.data:0000273B                 db    0
.data:0000273C                 db 0FFh
.data:0000273D                 db 0FFh
.data:0000273E                 db 0FFh
.data:0000273F                 db    0
.data:00002740                 db 0FFh
.data:00002741                 db 0FFh
.data:00002742                 db 0FFh
.data:00002743                 db    0
.data:00002744                 db 0FFh
.data:00002745                 db 0FFh
.data:00002746                 db 0FFh
.data:00002747                 db    0
.data:00002748                 db 0FFh
.data:00002749                 db 0FFh
.data:0000274A                 db 0FFh
.data:0000274B                 db    0
.data:0000274C                 db 0FFh
.data:0000274D                 db 0FFh
.data:0000274E                 db 0FFh
.data:0000274F                 db    0
.data:00002750                 db 0FFh
.data:00002751                 db 0FFh
.data:00002752                 db 0FFh
.data:00002753                 db    0
.data:00002754                 db 0FFh
.data:00002755                 db 0FFh
.data:00002756                 db 0FFh
.data:00002757                 db    0
.data:00002758                 db 0FFh
.data:00002759                 db 0FFh
.data:0000275A                 db 0FFh
.data:0000275B                 db    0
.data:0000275C                 db 0FFh
.data:0000275D                 db 0FFh
.data:0000275E                 db 0FFh
.data:0000275F                 db    0
.data:00002760                 db 0FFh
.data:00002761                 db 0FFh
.data:00002762                 db 0FFh
.data:00002763                 db    0
.data:00002764                 db 0FFh
.data:00002765                 db 0FFh
.data:00002766                 db 0FFh
.data:00002767                 db    0
.data:00002768                 db 0FFh
.data:00002769                 db 0FFh
.data:0000276A                 db 0FFh
.data:0000276B                 db    0
.data:0000276C                 db 0FFh
.data:0000276D                 db 0FFh
.data:0000276E                 db 0FFh
.data:0000276F                 db    0
.data:00002770                 db 0FFh
.data:00002771                 db 0FFh
.data:00002772                 db 0FFh
.data:00002773                 db    0
.data:00002774                 db 0FFh
.data:00002775                 db 0FFh
.data:00002776                 db 0FFh
.data:00002777                 db    0
.data:00002777 _data           ends
.data:00002777
.rdata:00002778 ; ===========================================================================
.rdata:00002778
.rdata:00002778 ; Segment type: Pure data
.rdata:00002778 ; Segment permissions: Read
.rdata:00002778 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002778 _rdata          segment para public 'DATA' use32
.rdata:00002778                 assume cs:_rdata
.rdata:00002778                 ;org 2778h
.rdata:00002778 ; COMDAT (pick any)
.rdata:00002778                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00002778 ; wchar_t `string'
.rdata:00002778 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00002778                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00002778                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00002778                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00002778                 unicode 0, <clude\xstring>,0
.rdata:00002806                 align 4
.rdata:00002806 _rdata          ends
.rdata:00002806
.rdata:00002808 ; ===========================================================================
.rdata:00002808
.rdata:00002808 ; Segment type: Pure data
.rdata:00002808 ; Segment permissions: Read
.rdata:00002808 _rdata          segment dword public 'DATA' use32
.rdata:00002808                 assume cs:_rdata
.rdata:00002808                 ;org 2808h
.rdata:00002808 ; COMDAT (pick any)
.rdata:00002808                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00002808 ; char `string'[]
.rdata:00002808 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00002808                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00002808 _rdata          ends
.rdata:00002808
.rdata:00002818 ; ===========================================================================
.rdata:00002818
.rdata:00002818 ; Segment type: Pure data
.rdata:00002818 ; Segment permissions: Read
.rdata:00002818 _rdata          segment dword public 'DATA' use32
.rdata:00002818                 assume cs:_rdata
.rdata:00002818                 ;org 2818h
.rdata:00002818 ; COMDAT (pick any)
.rdata:00002818                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00002818 ; char `string'[]
.rdata:00002818 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00002818                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00002818 _rdata          ends
.rdata:00002818
.rdata:00002830 ; ===========================================================================
.rdata:00002830
.rdata:00002830 ; Segment type: Pure data
.rdata:00002830 ; Segment permissions: Read
.rdata:00002830 _rdata          segment dword public 'DATA' use32
.rdata:00002830                 assume cs:_rdata
.rdata:00002830                 ;org 2830h
.rdata:00002830 ; COMDAT (pick any)
.rdata:00002830                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00002830 ; wchar_t `string'
.rdata:00002830 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00002830                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00002830                 unicode 0, <invalid null pointer>,0
.rdata:0000285A                 align 4
.rdata:0000285A _rdata          ends
.rdata:0000285A
.rdata$r:0000285C ; ===========================================================================
.rdata$r:0000285C
.rdata$r:0000285C ; Segment type: Pure data
.rdata$r:0000285C ; Segment permissions: Read
.rdata$r:0000285C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000285C                 assume cs:_rdata$r
.rdata$r:0000285C                 ;org 285Ch
.rdata$r:0000285C ; COMDAT (pick any)
.rdata$r:0000285C                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:0000285C ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000285C ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:0000285C                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:0000285C                                         ; .rdata$r:000028B8o
.rdata$r:0000285C                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:00002860                 db    0
.rdata$r:00002861                 db    0
.rdata$r:00002862                 db    0
.rdata$r:00002863                 db    0
.rdata$r:00002864                 db    0
.rdata$r:00002865                 db    0
.rdata$r:00002866                 db    0
.rdata$r:00002867                 db    0
.rdata$r:00002868                 db 0FFh
.rdata$r:00002869                 db 0FFh
.rdata$r:0000286A                 db 0FFh
.rdata$r:0000286B                 db 0FFh
.rdata$r:0000286C                 db    0
.rdata$r:0000286D                 db    0
.rdata$r:0000286E                 db    0
.rdata$r:0000286F                 db    0
.rdata$r:00002870                 db  40h ; @
.rdata$r:00002871                 db    0
.rdata$r:00002872                 db    0
.rdata$r:00002873                 db    0
.rdata$r:00002874                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002874 _rdata$r        ends
.rdata$r:00002874
.rdata$r:00002878 ; ===========================================================================
.rdata$r:00002878
.rdata$r:00002878 ; Segment type: Pure data
.rdata$r:00002878 ; Segment permissions: Read
.rdata$r:00002878 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002878                 assume cs:_rdata$r
.rdata$r:00002878                 ;org 2878h
.rdata$r:00002878 ; COMDAT (pick any)
.rdata$r:00002878                 public ??_R3exception@std@@8
.rdata$r:00002878 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002878 ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:00002874o
.rdata$r:00002879                 db    0
.rdata$r:0000287A                 db    0
.rdata$r:0000287B                 db    0
.rdata$r:0000287C                 db    0
.rdata$r:0000287D                 db    0
.rdata$r:0000287E                 db    0
.rdata$r:0000287F                 db    0
.rdata$r:00002880                 db    1
.rdata$r:00002881                 db    0
.rdata$r:00002882                 db    0
.rdata$r:00002883                 db    0
.rdata$r:00002884                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:00002884 _rdata$r        ends
.rdata$r:00002884
.rdata$r:00002888 ; ===========================================================================
.rdata$r:00002888
.rdata$r:00002888 ; Segment type: Pure data
.rdata$r:00002888 ; Segment permissions: Read
.rdata$r:00002888 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002888                 assume cs:_rdata$r
.rdata$r:00002888                 ;org 2888h
.rdata$r:00002888 ; COMDAT (pick any)
.rdata$r:00002888                 public ??_R2exception@std@@8
.rdata$r:00002888 ; std::exception::`RTTI Base Class Array'
.rdata$r:00002888 ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00002888                                         ; DATA XREF: .rdata$r:00002884o
.rdata$r:00002888                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000288C                 db    0
.rdata$r:0000288D                 align 10h
.rdata$r:0000288D _rdata$r        ends
.rdata$r:0000288D
.rdata$r:00002890 ; ===========================================================================
.rdata$r:00002890
.rdata$r:00002890 ; Segment type: Pure data
.rdata$r:00002890 ; Segment permissions: Read
.rdata$r:00002890 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002890                 assume cs:_rdata$r
.rdata$r:00002890                 ;org 2890h
.rdata$r:00002890 ; COMDAT (pick any)
.rdata$r:00002890                 public ??_R4runtime_error@std@@6B@
.rdata$r:00002890 ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:00002890 ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:000025DCo
.rdata$r:00002891                 db    0
.rdata$r:00002892                 db    0
.rdata$r:00002893                 db    0
.rdata$r:00002894                 db    0
.rdata$r:00002895                 db    0
.rdata$r:00002896                 db    0
.rdata$r:00002897                 db    0
.rdata$r:00002898                 db    0
.rdata$r:00002899                 db    0
.rdata$r:0000289A                 db    0
.rdata$r:0000289B                 db    0
.rdata$r:0000289C                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:000028A0                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028A0 _rdata$r        ends
.rdata$r:000028A0
.rdata$r:000028A4 ; ===========================================================================
.rdata$r:000028A4
.rdata$r:000028A4 ; Segment type: Pure data
.rdata$r:000028A4 ; Segment permissions: Read
.rdata$r:000028A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028A4                 assume cs:_rdata$r
.rdata$r:000028A4                 ;org 28A4h
.rdata$r:000028A4 ; COMDAT (pick any)
.rdata$r:000028A4                 public ??_R3runtime_error@std@@8
.rdata$r:000028A4 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028A4 ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:000028A0o
.rdata$r:000028A4                                         ; .rdata$r:000028D8o
.rdata$r:000028A5                 db    0
.rdata$r:000028A6                 db    0
.rdata$r:000028A7                 db    0
.rdata$r:000028A8                 db    0
.rdata$r:000028A9                 db    0
.rdata$r:000028AA                 db    0
.rdata$r:000028AB                 db    0
.rdata$r:000028AC                 db    2
.rdata$r:000028AD                 db    0
.rdata$r:000028AE                 db    0
.rdata$r:000028AF                 db    0
.rdata$r:000028B0                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:000028B0 _rdata$r        ends
.rdata$r:000028B0
.rdata$r:000028B4 ; ===========================================================================
.rdata$r:000028B4
.rdata$r:000028B4 ; Segment type: Pure data
.rdata$r:000028B4 ; Segment permissions: Read
.rdata$r:000028B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028B4                 assume cs:_rdata$r
.rdata$r:000028B4                 ;org 28B4h
.rdata$r:000028B4 ; COMDAT (pick any)
.rdata$r:000028B4                 public ??_R2runtime_error@std@@8
.rdata$r:000028B4 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:000028B4 ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:000028B4                                         ; DATA XREF: .rdata$r:000028B0o
.rdata$r:000028B4                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000028B8                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000028BC                 db    0
.rdata$r:000028BD                 align 10h
.rdata$r:000028BD _rdata$r        ends
.rdata$r:000028BD
.rdata$r:000028C0 ; ===========================================================================
.rdata$r:000028C0
.rdata$r:000028C0 ; Segment type: Pure data
.rdata$r:000028C0 ; Segment permissions: Read
.rdata$r:000028C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028C0                 assume cs:_rdata$r
.rdata$r:000028C0                 ;org 28C0h
.rdata$r:000028C0 ; COMDAT (pick any)
.rdata$r:000028C0                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:000028C0 ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000028C0 ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:000028C0                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:000028C0                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:000028C4                 db    1
.rdata$r:000028C5                 db    0
.rdata$r:000028C6                 db    0
.rdata$r:000028C7                 db    0
.rdata$r:000028C8                 db    0
.rdata$r:000028C9                 db    0
.rdata$r:000028CA                 db    0
.rdata$r:000028CB                 db    0
.rdata$r:000028CC                 db 0FFh
.rdata$r:000028CD                 db 0FFh
.rdata$r:000028CE                 db 0FFh
.rdata$r:000028CF                 db 0FFh
.rdata$r:000028D0                 db    0
.rdata$r:000028D1                 db    0
.rdata$r:000028D2                 db    0
.rdata$r:000028D3                 db    0
.rdata$r:000028D4                 db  40h ; @
.rdata$r:000028D5                 db    0
.rdata$r:000028D6                 db    0
.rdata$r:000028D7                 db    0
.rdata$r:000028D8                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028D8 _rdata$r        ends
.rdata$r:000028D8
.rdata$r:000028DC ; ===========================================================================
.rdata$r:000028DC
.rdata$r:000028DC ; Segment type: Pure data
.rdata$r:000028DC ; Segment permissions: Read
.rdata$r:000028DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000028DC                 assume cs:_rdata$r
.rdata$r:000028DC                 ;org 28DCh
.rdata$r:000028DC ; COMDAT (pick any)
.rdata$r:000028DC                 public ??_R4error_category@std@@6B@
.rdata$r:000028DC ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:000028DC ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00002678o
.rdata$r:000028DD                 db    0
.rdata$r:000028DE                 db    0
.rdata$r:000028DF                 db    0
.rdata$r:000028E0                 db    0
.rdata$r:000028E1                 db    0
.rdata$r:000028E2                 db    0
.rdata$r:000028E3                 db    0
.rdata$r:000028E4                 db    0
.rdata$r:000028E5                 db    0
.rdata$r:000028E6                 db    0
.rdata$r:000028E7                 db    0
.rdata$r:000028E8                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:000028EC                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000028EC _rdata$r        ends
.rdata$r:000028EC
.data$r:000028F0 ; ===========================================================================
.data$r:000028F0
.data$r:000028F0 ; Segment type: Pure data
.data$r:000028F0 ; Segment permissions: Read/Write
.data$r:000028F0 _data$r         segment dword public 'DATA' use32
.data$r:000028F0                 assume cs:_data$r
.data$r:000028F0                 ;org 28F0h
.data$r:000028F0 ; COMDAT (pick any)
.data$r:000028F0                 public ??_R0?AVerror_category@std@@@8
.data$r:000028F0 ; class std::error_category `RTTI Type Descriptor'
.data$r:000028F0 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000028F0                                         ; DATA XREF: .rdata$r:000028E8o
.data$r:000028F0                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000028F0                                         ; const type_info::`vftable'
.data$r:000028F4                 align 8
.data$r:000028F8 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:00002911                 align 4
.data$r:00002911 _data$r         ends
.data$r:00002911
.rdata$r:00002914 ; ===========================================================================
.rdata$r:00002914
.rdata$r:00002914 ; Segment type: Pure data
.rdata$r:00002914 ; Segment permissions: Read
.rdata$r:00002914 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002914                 assume cs:_rdata$r
.rdata$r:00002914                 ;org 2914h
.rdata$r:00002914 ; COMDAT (pick any)
.rdata$r:00002914                 public ??_R3error_category@std@@8
.rdata$r:00002914 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002914 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:000028ECo
.rdata$r:00002914                                         ; .rdata$r:00002944o
.rdata$r:00002915                 db    0
.rdata$r:00002916                 db    0
.rdata$r:00002917                 db    0
.rdata$r:00002918                 db    0
.rdata$r:00002919                 db    0
.rdata$r:0000291A                 db    0
.rdata$r:0000291B                 db    0
.rdata$r:0000291C                 db    1
.rdata$r:0000291D                 db    0
.rdata$r:0000291E                 db    0
.rdata$r:0000291F                 db    0
.rdata$r:00002920                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002920 _rdata$r        ends
.rdata$r:00002920
.rdata$r:00002924 ; ===========================================================================
.rdata$r:00002924
.rdata$r:00002924 ; Segment type: Pure data
.rdata$r:00002924 ; Segment permissions: Read
.rdata$r:00002924 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002924                 assume cs:_rdata$r
.rdata$r:00002924                 ;org 2924h
.rdata$r:00002924 ; COMDAT (pick any)
.rdata$r:00002924                 public ??_R2error_category@std@@8
.rdata$r:00002924 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002924 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002924                                         ; DATA XREF: .rdata$r:00002920o
.rdata$r:00002924                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002928                 db    0
.rdata$r:00002929                 align 4
.rdata$r:00002929 _rdata$r        ends
.rdata$r:00002929
.rdata$r:0000292C ; ===========================================================================
.rdata$r:0000292C
.rdata$r:0000292C ; Segment type: Pure data
.rdata$r:0000292C ; Segment permissions: Read
.rdata$r:0000292C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000292C                 assume cs:_rdata$r
.rdata$r:0000292C                 ;org 292Ch
.rdata$r:0000292C ; COMDAT (pick any)
.rdata$r:0000292C                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000292C ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000292C ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:0000292C                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:0000292C                                         ; .rdata$r:0000299Co ...
.rdata$r:0000292C                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002930                 db    0
.rdata$r:00002931                 db    0
.rdata$r:00002932                 db    0
.rdata$r:00002933                 db    0
.rdata$r:00002934                 db    0
.rdata$r:00002935                 db    0
.rdata$r:00002936                 db    0
.rdata$r:00002937                 db    0
.rdata$r:00002938                 db 0FFh
.rdata$r:00002939                 db 0FFh
.rdata$r:0000293A                 db 0FFh
.rdata$r:0000293B                 db 0FFh
.rdata$r:0000293C                 db    0
.rdata$r:0000293D                 db    0
.rdata$r:0000293E                 db    0
.rdata$r:0000293F                 db    0
.rdata$r:00002940                 db  40h ; @
.rdata$r:00002941                 db    0
.rdata$r:00002942                 db    0
.rdata$r:00002943                 db    0
.rdata$r:00002944                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002944 _rdata$r        ends
.rdata$r:00002944
.rdata$r:00002948 ; ===========================================================================
.rdata$r:00002948
.rdata$r:00002948 ; Segment type: Pure data
.rdata$r:00002948 ; Segment permissions: Read
.rdata$r:00002948 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002948                 assume cs:_rdata$r
.rdata$r:00002948                 ;org 2948h
.rdata$r:00002948 ; COMDAT (pick any)
.rdata$r:00002948                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00002948 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00002948 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00002948                                         ; DATA XREF: .rdata:00002694o
.rdata$r:00002949                 db    0
.rdata$r:0000294A                 db    0
.rdata$r:0000294B                 db    0
.rdata$r:0000294C                 db    0
.rdata$r:0000294D                 db    0
.rdata$r:0000294E                 db    0
.rdata$r:0000294F                 db    0
.rdata$r:00002950                 db    0
.rdata$r:00002951                 db    0
.rdata$r:00002952                 db    0
.rdata$r:00002953                 db    0
.rdata$r:00002954                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00002958                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002958 _rdata$r        ends
.rdata$r:00002958
.data$r:0000295C ; ===========================================================================
.data$r:0000295C
.data$r:0000295C ; Segment type: Pure data
.data$r:0000295C ; Segment permissions: Read/Write
.data$r:0000295C _data$r         segment dword public 'DATA' use32
.data$r:0000295C                 assume cs:_data$r
.data$r:0000295C                 ;org 295Ch
.data$r:0000295C ; COMDAT (pick any)
.data$r:0000295C                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:0000295C ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:0000295C ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000295C                                         ; DATA XREF: .rdata$r:00002954o
.data$r:0000295C                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000295C                                         ; const type_info::`vftable'
.data$r:00002960                 db    0
.data$r:00002961                 db    0
.data$r:00002962                 db    0
.data$r:00002963                 db    0
.data$r:00002964                 db  2Eh ; .
.data$r:00002965                 db  3Fh ; ?
.data$r:00002966                 db  41h ; A
.data$r:00002967                 db  56h ; V
.data$r:00002968                 db  5Fh ; _
.data$r:00002969                 db  47h ; G
.data$r:0000296A                 db  65h ; e
.data$r:0000296B                 db  6Eh ; n
.data$r:0000296C                 db  65h ; e
.data$r:0000296D                 db  72h ; r
.data$r:0000296E                 db  69h ; i
.data$r:0000296F                 db  63h ; c
.data$r:00002970                 db  5Fh ; _
.data$r:00002971                 db  65h ; e
.data$r:00002972                 db  72h ; r
.data$r:00002973                 db  72h ; r
.data$r:00002974                 db  6Fh ; o
.data$r:00002975                 db  72h ; r
.data$r:00002976                 db  5Fh ; _
.data$r:00002977                 db  63h ; c
.data$r:00002978                 db  61h ; a
.data$r:00002979                 db  74h ; t
.data$r:0000297A                 db  65h ; e
.data$r:0000297B                 db  67h ; g
.data$r:0000297C                 db  6Fh ; o
.data$r:0000297D                 db  72h ; r
.data$r:0000297E                 db  79h ; y
.data$r:0000297F                 db  40h ; @
.data$r:00002980                 db  73h ; s
.data$r:00002981                 db  74h ; t
.data$r:00002982                 db  64h ; d
.data$r:00002983                 db  40h ; @
.data$r:00002984                 db  40h ; @
.data$r:00002985                 db    0
.data$r:00002986                 align 4
.data$r:00002986 _data$r         ends
.data$r:00002986
.rdata$r:00002988 ; ===========================================================================
.rdata$r:00002988
.rdata$r:00002988 ; Segment type: Pure data
.rdata$r:00002988 ; Segment permissions: Read
.rdata$r:00002988 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002988                 assume cs:_rdata$r
.rdata$r:00002988                 ;org 2988h
.rdata$r:00002988 ; COMDAT (pick any)
.rdata$r:00002988                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00002988 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002988 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00002988                                         ; DATA XREF: .rdata$r:00002958o
.rdata$r:00002988                                         ; .rdata$r:000029BCo
.rdata$r:00002989                 db    0
.rdata$r:0000298A                 db    0
.rdata$r:0000298B                 db    0
.rdata$r:0000298C                 db    0
.rdata$r:0000298D                 db    0
.rdata$r:0000298E                 db    0
.rdata$r:0000298F                 db    0
.rdata$r:00002990                 db    2
.rdata$r:00002991                 db    0
.rdata$r:00002992                 db    0
.rdata$r:00002993                 db    0
.rdata$r:00002994                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002994 _rdata$r        ends
.rdata$r:00002994
.rdata$r:00002998 ; ===========================================================================
.rdata$r:00002998
.rdata$r:00002998 ; Segment type: Pure data
.rdata$r:00002998 ; Segment permissions: Read
.rdata$r:00002998 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002998                 assume cs:_rdata$r
.rdata$r:00002998                 ;org 2998h
.rdata$r:00002998 ; COMDAT (pick any)
.rdata$r:00002998                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00002998 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00002998 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002998                                         ; DATA XREF: .rdata$r:00002994o
.rdata$r:00002998                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000299C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000029A0                 db    0
.rdata$r:000029A1                 align 4
.rdata$r:000029A1 _rdata$r        ends
.rdata$r:000029A1
.rdata$r:000029A4 ; ===========================================================================
.rdata$r:000029A4
.rdata$r:000029A4 ; Segment type: Pure data
.rdata$r:000029A4 ; Segment permissions: Read
.rdata$r:000029A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000029A4                 assume cs:_rdata$r
.rdata$r:000029A4                 ;org 29A4h
.rdata$r:000029A4 ; COMDAT (pick any)
.rdata$r:000029A4                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000029A4 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000029A4 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:000029A4                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:000029A4                                         ; .rdata$r:00002A14o ...
.rdata$r:000029A4                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000029A8                 db    1
.rdata$r:000029A9                 db    0
.rdata$r:000029AA                 db    0
.rdata$r:000029AB                 db    0
.rdata$r:000029AC                 db    0
.rdata$r:000029AD                 db    0
.rdata$r:000029AE                 db    0
.rdata$r:000029AF                 db    0
.rdata$r:000029B0                 db 0FFh
.rdata$r:000029B1                 db 0FFh
.rdata$r:000029B2                 db 0FFh
.rdata$r:000029B3                 db 0FFh
.rdata$r:000029B4                 db    0
.rdata$r:000029B5                 db    0
.rdata$r:000029B6                 db    0
.rdata$r:000029B7                 db    0
.rdata$r:000029B8                 db  40h ; @
.rdata$r:000029B9                 db    0
.rdata$r:000029BA                 db    0
.rdata$r:000029BB                 db    0
.rdata$r:000029BC                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000029BC _rdata$r        ends
.rdata$r:000029BC
.rdata$r:000029C0 ; ===========================================================================
.rdata$r:000029C0
.rdata$r:000029C0 ; Segment type: Pure data
.rdata$r:000029C0 ; Segment permissions: Read
.rdata$r:000029C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000029C0                 assume cs:_rdata$r
.rdata$r:000029C0                 ;org 29C0h
.rdata$r:000029C0 ; COMDAT (pick any)
.rdata$r:000029C0                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:000029C0 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:000029C0 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:000029C0                                         ; DATA XREF: .rdata:000026C8o
.rdata$r:000029C1                 db    0
.rdata$r:000029C2                 db    0
.rdata$r:000029C3                 db    0
.rdata$r:000029C4                 db    0
.rdata$r:000029C5                 db    0
.rdata$r:000029C6                 db    0
.rdata$r:000029C7                 db    0
.rdata$r:000029C8                 db    0
.rdata$r:000029C9                 db    0
.rdata$r:000029CA                 db    0
.rdata$r:000029CB                 db    0
.rdata$r:000029CC                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000029D0                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000029D0 _rdata$r        ends
.rdata$r:000029D0
.data$r:000029D4 ; ===========================================================================
.data$r:000029D4
.data$r:000029D4 ; Segment type: Pure data
.data$r:000029D4 ; Segment permissions: Read/Write
.data$r:000029D4 _data$r         segment dword public 'DATA' use32
.data$r:000029D4                 assume cs:_data$r
.data$r:000029D4                 ;org 29D4h
.data$r:000029D4 ; COMDAT (pick any)
.data$r:000029D4                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:000029D4 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:000029D4 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000029D4                                         ; DATA XREF: .rdata$r:000029CCo
.data$r:000029D4                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000029D4                                         ; const type_info::`vftable'
.data$r:000029D8                 db    0
.data$r:000029D9                 db    0
.data$r:000029DA                 db    0
.data$r:000029DB                 db    0
.data$r:000029DC                 db  2Eh ; .
.data$r:000029DD                 db  3Fh ; ?
.data$r:000029DE                 db  41h ; A
.data$r:000029DF                 db  56h ; V
.data$r:000029E0                 db  5Fh ; _
.data$r:000029E1                 db  49h ; I
.data$r:000029E2                 db  6Fh ; o
.data$r:000029E3                 db  73h ; s
.data$r:000029E4                 db  74h ; t
.data$r:000029E5                 db  72h ; r
.data$r:000029E6                 db  65h ; e
.data$r:000029E7                 db  61h ; a
.data$r:000029E8                 db  6Dh ; m
.data$r:000029E9                 db  5Fh ; _
.data$r:000029EA                 db  65h ; e
.data$r:000029EB                 db  72h ; r
.data$r:000029EC                 db  72h ; r
.data$r:000029ED                 db  6Fh ; o
.data$r:000029EE                 db  72h ; r
.data$r:000029EF                 db  5Fh ; _
.data$r:000029F0                 db  63h ; c
.data$r:000029F1                 db  61h ; a
.data$r:000029F2                 db  74h ; t
.data$r:000029F3                 db  65h ; e
.data$r:000029F4                 db  67h ; g
.data$r:000029F5                 db  6Fh ; o
.data$r:000029F6                 db  72h ; r
.data$r:000029F7                 db  79h ; y
.data$r:000029F8                 db  40h ; @
.data$r:000029F9                 db  73h ; s
.data$r:000029FA                 db  74h ; t
.data$r:000029FB                 db  64h ; d
.data$r:000029FC                 db  40h ; @
.data$r:000029FD                 db  40h ; @
.data$r:000029FE                 db    0
.data$r:000029FF                 align 10h
.data$r:000029FF _data$r         ends
.data$r:000029FF
.rdata$r:00002A00 ; ===========================================================================
.rdata$r:00002A00
.rdata$r:00002A00 ; Segment type: Pure data
.rdata$r:00002A00 ; Segment permissions: Read
.rdata$r:00002A00 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A00                 assume cs:_rdata$r
.rdata$r:00002A00                 ;org 2A00h
.rdata$r:00002A00 ; COMDAT (pick any)
.rdata$r:00002A00                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00002A00 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A00 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00002A00                                         ; DATA XREF: .rdata$r:000029D0o
.rdata$r:00002A00                                         ; .rdata$r:00002A38o
.rdata$r:00002A01                 db    0
.rdata$r:00002A02                 db    0
.rdata$r:00002A03                 db    0
.rdata$r:00002A04                 db    0
.rdata$r:00002A05                 db    0
.rdata$r:00002A06                 db    0
.rdata$r:00002A07                 db    0
.rdata$r:00002A08                 db    3
.rdata$r:00002A09                 db    0
.rdata$r:00002A0A                 db    0
.rdata$r:00002A0B                 db    0
.rdata$r:00002A0C                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002A0C _rdata$r        ends
.rdata$r:00002A0C
.rdata$r:00002A10 ; ===========================================================================
.rdata$r:00002A10
.rdata$r:00002A10 ; Segment type: Pure data
.rdata$r:00002A10 ; Segment permissions: Read
.rdata$r:00002A10 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A10                 assume cs:_rdata$r
.rdata$r:00002A10                 ;org 2A10h
.rdata$r:00002A10 ; COMDAT (pick any)
.rdata$r:00002A10                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00002A10 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002A10 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002A10                                         ; DATA XREF: .rdata$r:00002A0Co
.rdata$r:00002A10                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002A14                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002A18                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002A1C                 db    0
.rdata$r:00002A1D                 align 10h
.rdata$r:00002A1D _rdata$r        ends
.rdata$r:00002A1D
.rdata$r:00002A20 ; ===========================================================================
.rdata$r:00002A20
.rdata$r:00002A20 ; Segment type: Pure data
.rdata$r:00002A20 ; Segment permissions: Read
.rdata$r:00002A20 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A20                 assume cs:_rdata$r
.rdata$r:00002A20                 ;org 2A20h
.rdata$r:00002A20 ; COMDAT (pick any)
.rdata$r:00002A20                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002A20 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002A20 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00002A20                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00002A20                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002A24                 db    2
.rdata$r:00002A25                 db    0
.rdata$r:00002A26                 db    0
.rdata$r:00002A27                 db    0
.rdata$r:00002A28                 db    0
.rdata$r:00002A29                 db    0
.rdata$r:00002A2A                 db    0
.rdata$r:00002A2B                 db    0
.rdata$r:00002A2C                 db 0FFh
.rdata$r:00002A2D                 db 0FFh
.rdata$r:00002A2E                 db 0FFh
.rdata$r:00002A2F                 db 0FFh
.rdata$r:00002A30                 db    0
.rdata$r:00002A31                 db    0
.rdata$r:00002A32                 db    0
.rdata$r:00002A33                 db    0
.rdata$r:00002A34                 db  40h ; @
.rdata$r:00002A35                 db    0
.rdata$r:00002A36                 db    0
.rdata$r:00002A37                 db    0
.rdata$r:00002A38                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A38 _rdata$r        ends
.rdata$r:00002A38
.rdata$r:00002A3C ; ===========================================================================
.rdata$r:00002A3C
.rdata$r:00002A3C ; Segment type: Pure data
.rdata$r:00002A3C ; Segment permissions: Read
.rdata$r:00002A3C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A3C                 assume cs:_rdata$r
.rdata$r:00002A3C                 ;org 2A3Ch
.rdata$r:00002A3C ; COMDAT (pick any)
.rdata$r:00002A3C                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00002A3C ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00002A3C ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00002708o
.rdata$r:00002A3D                 db    0
.rdata$r:00002A3E                 db    0
.rdata$r:00002A3F                 db    0
.rdata$r:00002A40                 db    0
.rdata$r:00002A41                 db    0
.rdata$r:00002A42                 db    0
.rdata$r:00002A43                 db    0
.rdata$r:00002A44                 db    0
.rdata$r:00002A45                 db    0
.rdata$r:00002A46                 db    0
.rdata$r:00002A47                 db    0
.rdata$r:00002A48                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002A4C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A4C _rdata$r        ends
.rdata$r:00002A4C
.data$r:00002A50 ; ===========================================================================
.data$r:00002A50
.data$r:00002A50 ; Segment type: Pure data
.data$r:00002A50 ; Segment permissions: Read/Write
.data$r:00002A50 _data$r         segment dword public 'DATA' use32
.data$r:00002A50                 assume cs:_data$r
.data$r:00002A50                 ;org 2A50h
.data$r:00002A50 ; COMDAT (pick any)
.data$r:00002A50                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00002A50 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00002A50 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002A50                                         ; DATA XREF: .rdata$r:00002A48o
.data$r:00002A50                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002A50                                         ; const type_info::`vftable'
.data$r:00002A54                 align 8
.data$r:00002A58 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:00002A79                 align 4
.data$r:00002A79 _data$r         ends
.data$r:00002A79
.rdata$r:00002A7C ; ===========================================================================
.rdata$r:00002A7C
.rdata$r:00002A7C ; Segment type: Pure data
.rdata$r:00002A7C ; Segment permissions: Read
.rdata$r:00002A7C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A7C                 assume cs:_rdata$r
.rdata$r:00002A7C                 ;org 2A7Ch
.rdata$r:00002A7C ; COMDAT (pick any)
.rdata$r:00002A7C                 public ??_R3_System_error_category@std@@8
.rdata$r:00002A7C ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002A7C ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00002A4Co
.rdata$r:00002A7C                                         ; .rdata$r:00002AB4o
.rdata$r:00002A7D                 db    0
.rdata$r:00002A7E                 db    0
.rdata$r:00002A7F                 db    0
.rdata$r:00002A80                 db    0
.rdata$r:00002A81                 db    0
.rdata$r:00002A82                 db    0
.rdata$r:00002A83                 db    0
.rdata$r:00002A84                 db    3
.rdata$r:00002A85                 db    0
.rdata$r:00002A86                 db    0
.rdata$r:00002A87                 db    0
.rdata$r:00002A88                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002A88 _rdata$r        ends
.rdata$r:00002A88
.rdata$r:00002A8C ; ===========================================================================
.rdata$r:00002A8C
.rdata$r:00002A8C ; Segment type: Pure data
.rdata$r:00002A8C ; Segment permissions: Read
.rdata$r:00002A8C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A8C                 assume cs:_rdata$r
.rdata$r:00002A8C                 ;org 2A8Ch
.rdata$r:00002A8C ; COMDAT (pick any)
.rdata$r:00002A8C                 public ??_R2_System_error_category@std@@8
.rdata$r:00002A8C ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00002A8C ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002A8C                                         ; DATA XREF: .rdata$r:00002A88o
.rdata$r:00002A8C                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002A90                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002A94                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002A98                 db    0
.rdata$r:00002A99                 align 4
.rdata$r:00002A99 _rdata$r        ends
.rdata$r:00002A99
.rdata$r:00002A9C ; ===========================================================================
.rdata$r:00002A9C
.rdata$r:00002A9C ; Segment type: Pure data
.rdata$r:00002A9C ; Segment permissions: Read
.rdata$r:00002A9C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002A9C                 assume cs:_rdata$r
.rdata$r:00002A9C                 ;org 2A9Ch
.rdata$r:00002A9C ; COMDAT (pick any)
.rdata$r:00002A9C                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002A9C ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002A9C ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00002A9C                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00002A9C                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002AA0                 db    2
.rdata$r:00002AA1                 db    0
.rdata$r:00002AA2                 db    0
.rdata$r:00002AA3                 db    0
.rdata$r:00002AA4                 db    0
.rdata$r:00002AA5                 db    0
.rdata$r:00002AA6                 db    0
.rdata$r:00002AA7                 db    0
.rdata$r:00002AA8                 db 0FFh
.rdata$r:00002AA9                 db 0FFh
.rdata$r:00002AAA                 db 0FFh
.rdata$r:00002AAB                 db 0FFh
.rdata$r:00002AAC                 db    0
.rdata$r:00002AAD                 db    0
.rdata$r:00002AAE                 db    0
.rdata$r:00002AAF                 db    0
.rdata$r:00002AB0                 db  40h ; @
.rdata$r:00002AB1                 db    0
.rdata$r:00002AB2                 db    0
.rdata$r:00002AB3                 db    0
.rdata$r:00002AB4                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002AB4 _rdata$r        ends
.rdata$r:00002AB4
.CRT$XCU:00002AB8 ; ===========================================================================
.CRT$XCU:00002AB8
.CRT$XCU:00002AB8 ; Segment type: Pure data
.CRT$XCU:00002AB8 ; Segment permissions: Read
.CRT$XCU:00002AB8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002AB8                 assume cs:_CRT$XCU
.CRT$XCU:00002AB8                 ;org 2AB8h
.CRT$XCU:00002AB8 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00002ABC _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00002ABC _CRT$XCU        ends
.CRT$XCU:00002ABC
.CRT$XCU:00002AC0 ; ===========================================================================
.CRT$XCU:00002AC0
.CRT$XCU:00002AC0 ; Segment type: Pure data
.CRT$XCU:00002AC0 ; Segment permissions: Read
.CRT$XCU:00002AC0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002AC0                 assume cs:_CRT$XCU
.CRT$XCU:00002AC0                 ;org 2AC0h
.CRT$XCU:00002AC0 ; COMDAT (pick associative to section at 272C)
.CRT$XCU:00002AC0 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00002AC0 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00002AC0 _CRT$XCU        ends
.CRT$XCU:00002AC0
.CRT$XCU:00002AC4 ; ===========================================================================
.CRT$XCU:00002AC4
.CRT$XCU:00002AC4 ; Segment type: Pure data
.CRT$XCU:00002AC4 ; Segment permissions: Read
.CRT$XCU:00002AC4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002AC4                 assume cs:_CRT$XCU
.CRT$XCU:00002AC4                 ;org 2AC4h
.CRT$XCU:00002AC4 ; COMDAT (pick associative to section at 2730)
.CRT$XCU:00002AC4 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00002AC4 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00002AC4 _CRT$XCU        ends
.CRT$XCU:00002AC4
.CRT$XCU:00002AC8 ; ===========================================================================
.CRT$XCU:00002AC8
.CRT$XCU:00002AC8 ; Segment type: Pure data
.CRT$XCU:00002AC8 ; Segment permissions: Read
.CRT$XCU:00002AC8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002AC8                 assume cs:_CRT$XCU
.CRT$XCU:00002AC8                 ;org 2AC8h
.CRT$XCU:00002AC8 ; COMDAT (pick associative to section at 2734)
.CRT$XCU:00002AC8 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00002AC8 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00002AC8 _CRT$XCU        ends
.CRT$XCU:00002AC8
UNDEF:00002AD0 ; ===========================================================================
UNDEF:00002AD0
UNDEF:00002AD0 ; Segment type: Externs
UNDEF:00002AD0 ; UNDEF
UNDEF:00002AD0                 extrn __purecall:near   ; DATA XREF: .rdata:00002680o
UNDEF:00002AD0                                         ; .rdata:00002684o
UNDEF:00002AD4 ; void *__cdecl operator new(unsigned int)
UNDEF:00002AD4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00002AD4                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:00002AD8 ; void __cdecl operator delete(void *)
UNDEF:00002AD8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00002AD8                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:00002ADC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:00002ADC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:00002ADC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00002AE0 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00002AE0                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00002AE0                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00002AE4 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00002AE4                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00002AE4                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00002AE4                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00002AE8                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00002AEC ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00002AEC                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00002AF0 ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:00002AF0                 extrn _memset:near      ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+38Ep
UNDEF:00002AF4 ; size_t __cdecl strlen(const char *Str)
UNDEF:00002AF4                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00002AF8 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00002AF8                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00002AFC ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:00002AFC                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:00002AFC                                         ; CODE XREF: std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:00002B00 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:00002B00                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:00002B00                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:00002B00                                         ; DATA XREF: .xdata$x:00002674o
UNDEF:00002B04 ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:00002B04                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:00002B04                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:00002B04                                         ; __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0+3j ...
UNDEF:00002B08 ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:00002B08                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:00002B08                                         ; DATA XREF: .rdata:000025E4o
UNDEF:00002B0C ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00002B0C                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00002B0C                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00002B10 ; void __cdecl std::_Xbad_alloc()
UNDEF:00002B10                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00002B10                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_76Ep
UNDEF:00002B10                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_7B0p
UNDEF:00002B14 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00002B14                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00002B14                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00002B18 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00002B18                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00002B18                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00002B1C ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:00002B1C                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:00002B1C                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:00002B20 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002B20                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002B20                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00002B24 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00002B24                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00002B24                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00002B24                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00002B28 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00002B28                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00002B28                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00002B2C ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002B2C                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002B2C                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00002B30 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002B30                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002B30                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00002B34 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002B34                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002B34                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00002B38 ; HPEN __stdcall CreatePen(int iStyle, int cWidth, COLORREF color)
UNDEF:00002B38                 extrn __imp__CreatePen@12:near
UNDEF:00002B38                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+21Dp
UNDEF:00002B38                                         ; ColourPopup::run_dlgProc(uint,uint,long)+294p
UNDEF:00002B38                                         ; DATA XREF: ...
UNDEF:00002B3C ; HBRUSH __stdcall CreateSolidBrush(COLORREF color)
UNDEF:00002B3C                 extrn __imp__CreateSolidBrush@4:near
UNDEF:00002B3C                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+CFp
UNDEF:00002B3C                                         ; ColourPopup::run_dlgProc(uint,uint,long)+196p ...
UNDEF:00002B40 ; BOOL __stdcall DeleteObject(HGDIOBJ ho)
UNDEF:00002B40                 extrn __imp__DeleteObject@4:near
UNDEF:00002B40                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+1B5p
UNDEF:00002B40                                         ; ColourPopup::run_dlgProc(uint,uint,long)+281p ...
UNDEF:00002B44 ; HGDIOBJ __stdcall GetStockObject(int i)
UNDEF:00002B44                 extrn __imp__GetStockObject@4:near
UNDEF:00002B44                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+1BDp
UNDEF:00002B44                                         ; DATA XREF: ColourPopup::run_dlgProc(uint,uint,long)+1BDr
UNDEF:00002B48 ; BOOL __stdcall LineTo(HDC hdc, int x, int y)
UNDEF:00002B48                 extrn __imp__LineTo@12:near
UNDEF:00002B48                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+257p
UNDEF:00002B48                                         ; ColourPopup::run_dlgProc(uint,uint,long)+269p ...
UNDEF:00002B4C ; HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h)
UNDEF:00002B4C                 extrn __imp__SelectObject@8:near
UNDEF:00002B4C                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+22Ep
UNDEF:00002B4C                                         ; ColourPopup::run_dlgProc(uint,uint,long)+277p ...
UNDEF:00002B50 ; int __stdcall SetBkMode(HDC hdc, int mode)
UNDEF:00002B50                 extrn __imp__SetBkMode@8:near
UNDEF:00002B50                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+10Cp
UNDEF:00002B50                                         ; DATA XREF: ColourPopup::run_dlgProc(uint,uint,long)+10Cr
UNDEF:00002B54 ; BOOL __stdcall MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
UNDEF:00002B54                 extrn __imp__MoveToEx@16:near
UNDEF:00002B54                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+245p
UNDEF:00002B54                                         ; DATA XREF: ColourPopup::run_dlgProc(uint,uint,long)+245r
UNDEF:00002B58 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00002B58                 extrn __imp__SendMessageW@16:near
UNDEF:00002B58                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+3EDp
UNDEF:00002B58                                         ; ColourPopup::run_dlgProc(uint,uint,long)+405p ...
UNDEF:00002B5C ; HWND __stdcall CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
UNDEF:00002B5C                 extrn __imp__CreateDialogParamW@20:near
UNDEF:00002B5C                                         ; CODE XREF: ColourPopup::create(int)+25p
UNDEF:00002B5C                                         ; DATA XREF: ColourPopup::create(int)+25r
UNDEF:00002B60 ; HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem)
UNDEF:00002B60                 extrn __imp__GetDlgItem@8:near
UNDEF:00002B60                                         ; CODE XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+3Fp
UNDEF:00002B60                                         ; DATA XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+3Fr
UNDEF:00002B64 ; LRESULT __stdcall SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00002B64                 extrn __imp__SendDlgItemMessageW@20:near
UNDEF:00002B64                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+8Ep
UNDEF:00002B64                                         ; ColourPopup::run_dlgProc(uint,uint,long)+B4p
UNDEF:00002B64                                         ; DATA XREF: ...
UNDEF:00002B68 ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:00002B68                 extrn __imp__GetClientRect@8:near
UNDEF:00002B68                                         ; CODE XREF: Window::getClientRect(tagRECT &)+12p
UNDEF:00002B68                                         ; DATA XREF: Window::getClientRect(tagRECT &)+12r
UNDEF:00002B6C ; BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect)
UNDEF:00002B6C                 extrn __imp__GetWindowRect@8:near
UNDEF:00002B6C                                         ; CODE XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+46p
UNDEF:00002B6C                                         ; DATA XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+46r
UNDEF:00002B70 ; DWORD __stdcall GetSysColor(int nIndex)
UNDEF:00002B70                 extrn __imp__GetSysColor@4:near
UNDEF:00002B70                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+C8p
UNDEF:00002B70                                         ; ColourPopup::run_dlgProc(uint,uint,long)+212p ...
UNDEF:00002B74 ; BOOL __stdcall DrawFocusRect(HDC hDC, const RECT *lprc)
UNDEF:00002B74                 extrn __imp__DrawFocusRect@8:near
UNDEF:00002B74                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+34Fp
UNDEF:00002B74                                         ; DATA XREF: ColourPopup::run_dlgProc(uint,uint,long)+34Fr
UNDEF:00002B78 ; int __stdcall FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
UNDEF:00002B78                 extrn __imp__FillRect@12:near
UNDEF:00002B78                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+1ABp
UNDEF:00002B78                                         ; DATA XREF: ColourPopup::run_dlgProc(uint,uint,long)+1ABr
UNDEF:00002B7C ; int __stdcall FrameRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
UNDEF:00002B7C                 extrn __imp__FrameRect@12:near
UNDEF:00002B7C                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+1CCp
UNDEF:00002B7C                                         ; ColourPopup::run_dlgProc(uint,uint,long)+30Ap
UNDEF:00002B7C                                         ; DATA XREF: ...
UNDEF:00002B80 ; BOOL __stdcall InflateRect(LPRECT lprc, int dx, int dy)
UNDEF:00002B80                 extrn __imp__InflateRect@12:near
UNDEF:00002B80                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+18Cp
UNDEF:00002B80                                         ; ColourPopup::run_dlgProc(uint,uint,long)+341p
UNDEF:00002B80                                         ; DATA XREF: ...
UNDEF:00002B84 ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:00002B84                 extrn __imp__GetWindowLongW@8:near
UNDEF:00002B84                                         ; CODE XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+BDp
UNDEF:00002B84                                         ; DATA XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+BDr
UNDEF:00002B88 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:00002B88                 extrn __imp__SetWindowLongW@12:near
UNDEF:00002B88                                         ; CODE XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+95p
UNDEF:00002B88                                         ; DATA XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+95r
UNDEF:00002B8C ; BOOL __stdcall ChooseColorW(LPCHOOSECOLORW)
UNDEF:00002B8C                 extrn __imp__ChooseColorW@4:near
UNDEF:00002B8C                                         ; CODE XREF: ColourPopup::run_dlgProc(uint,uint,long)+3D0p
UNDEF:00002B8C                                         ; DATA XREF: ColourPopup::run_dlgProc(uint,uint,long)+3D0r
UNDEF:00002B90 ; __fastcall __security_check_cookie(x)
UNDEF:00002B90                 extrn @__security_check_cookie@4:near
UNDEF:00002B90                                         ; CODE XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+EAp
UNDEF:00002B90                                         ; ColourPopup::run_dlgProc(uint,uint,long)+4B3p ...
UNDEF:00002B94 ; __stdcall _CxxThrowException(x, x)
UNDEF:00002B94                 extrn __CxxThrowException@8:near
UNDEF:00002B94                                         ; CODE XREF: ColourPopup::create(int)+50p
UNDEF:00002B94                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:00002B98                 extrn ___CxxFrameHandler3:near
UNDEF:00002B98                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:00002B98                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:00002B9C ; const type_info::`vftable'
UNDEF:00002B9C                 extrn ??_7type_info@@6B@:near
UNDEF:00002B9C                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:00002B9C                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:00002BA0                 extrn ___security_cookie:near
UNDEF:00002BA0                                         ; DATA XREF: ColourPopup::dlgProc(HWND__ *,uint,uint,long)+6r
UNDEF:00002BA0                                         ; ColourPopup::run_dlgProc(uint,uint,long)+6r ...
UNDEF:00002BA4                 extrn __fltused:near
UNDEF:00002BA4
UNDEF:00002BA4
UNDEF:00002BA4                 end