.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 48C082385AB3AFE70D7842E9C21344E7
.rdata:00000000 ; Input CRC32 : B391B08F
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\ToolBar.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; wchar_t _SG123040
.rdata:00000000 $SG123040:                              ; DATA XREF: ToolBar::initTheme(TiXmlDocument *)+31o
.rdata:00000000                 unicode 0, <NotepadPlus>,0
.rdata:00000018 ; wchar_t _SG123042
.rdata:00000018 $SG123042:                              ; DATA XREF: ToolBar::initTheme(TiXmlDocument *)+5Do
.rdata:00000018                 unicode 0, <ToolBarIcons>,0
.rdata:00000032                 align 4
.rdata:00000034 ; wchar_t _SG123044
.rdata:00000034 $SG123044:                              ; DATA XREF: ToolBar::initTheme(TiXmlDocument *)+92o
.rdata:00000034                 unicode 0, <Theme>,0
.rdata:00000040 ; wchar_t _SG123047
.rdata:00000040 $SG123047:                              ; DATA XREF: ToolBar::initTheme(TiXmlDocument *)+C7o
.rdata:00000040                 unicode 0, <pathPrefix>,0
.rdata:00000056                 align 4
.rdata:00000058 ; wchar_t _SG123049
.rdata:00000058 $SG123049:                              ; DATA XREF: ToolBar::initTheme(TiXmlDocument *)+EAo
.rdata:00000058                 unicode 0, <Icon>,0
.rdata:00000062                 align 4
.rdata:00000064 ; wchar_t _SG123053
.rdata:00000064 $SG123053:                              ; DATA XREF: ToolBar::initTheme(TiXmlDocument *):loc_238o
.rdata:00000064                 unicode 0, <Icon>,0
.rdata:0000006E                 align 10h
.rdata:00000070 ; wchar_t _SG123056
.rdata:00000070 $SG123056:                              ; DATA XREF: ToolBar::initTheme(TiXmlDocument *)+132o
.rdata:00000070                 unicode 0, <id>,0
.rdata:00000076                 align 4
.rdata:00000078 ; wchar_t _SG123059
.rdata:00000078 $SG123059:                              ; DATA XREF: ToolBar::initTheme(TiXmlDocument *)+15Co
.rdata:00000078                 unicode 0, <normal>,0
.rdata:00000086                 align 4
.rdata:00000088 $SG123064       db    0                 ; DATA XREF: ToolBar::initTheme(TiXmlDocument *):loc_2E4o
.rdata:00000089                 db    0
.rdata:0000008A                 db    0
.rdata:0000008B                 db    0
.rdata:0000008C ; wchar_t _SG123067
.rdata:0000008C $SG123067:                              ; DATA XREF: ToolBar::initTheme(TiXmlDocument *):loc_3A6o
.rdata:0000008C                 unicode 0, <hover>,0
.rdata:00000098 $SG123072       db    0                 ; DATA XREF: ToolBar::initTheme(TiXmlDocument *):loc_3FEo
.rdata:00000099                 db    0
.rdata:0000009A                 db    0
.rdata:0000009B                 db    0
.rdata:0000009C ; wchar_t _SG123075
.rdata:0000009C $SG123075:                              ; DATA XREF: ToolBar::initTheme(TiXmlDocument *):loc_4C0o
.rdata:0000009C                 unicode 0, <disabled>,0
.rdata:000000AE                 align 10h
.rdata:000000B0 $SG123080       db    0                 ; DATA XREF: ToolBar::initTheme(TiXmlDocument *):loc_518o
.rdata:000000B1                 db    0
.rdata:000000B2                 db    0
.rdata:000000B3                 db    0
.rdata:000000B4 ; const WCHAR _SG123170
.rdata:000000B4 $SG123170       dw 0                    ; DATA XREF: ToolBar::reset(bool)+B0o
.rdata:000000B6                 align 4
.rdata:000000B8 ; const WCHAR _SG123171
.rdata:000000B8 $SG123171:                              ; DATA XREF: ToolBar::reset(bool)+B5o
.rdata:000000B8                 unicode 0, <ToolbarWindow32>,0
.rdata:000000D8 ; char _SG123178[]
.rdata:000000D8 $SG123178       db 'ToolBar::reset : CreateWindowEx() function return null',0
.rdata:000000D8                                         ; DATA XREF: ToolBar::reset(bool)+100o
.rdata:0000010F                 align 10h
.rdata:00000110 ; const WCHAR _SG123254
.rdata:00000110 $SG123254       dw 0                    ; DATA XREF: ToolBar::doPopop(tagPOINT):loc_DC6o
.rdata:00000112                 align 4
.rdata:00000114 ; const WCHAR _SG123277
.rdata:00000114 $SG123277:                              ; DATA XREF: ReBar::init(HINSTANCE__ *,HWND__ *)+3Ao
.rdata:00000114                 unicode 0, <ReBarWindow32>,0
.rdata:00000114 _rdata          ends
.rdata:00000114
.text$mn:00000130 ; ===========================================================================
.text$mn:00000130
.text$mn:00000130 ; Segment type: Pure code
.text$mn:00000130 ; Segment permissions: Read/Execute
.text$mn:00000130 _text$mn        segment para public 'CODE' use32
.text$mn:00000130                 assume cs:_text$mn
.text$mn:00000130                 ;org 130h
.text$mn:00000130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000130
.text$mn:00000130 ; =============== S U B R O U T I N E =======================================
.text$mn:00000130
.text$mn:00000130 ; Attributes: bp-based frame
.text$mn:00000130
.text$mn:00000130 ; void __thiscall ToolBar::initTheme(ToolBar *this, struct TiXmlDocument *)
.text$mn:00000130                 public ?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z
.text$mn:00000130 ?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z proc near
.text$mn:00000130
.text$mn:00000130 var_13C         = dword ptr -13Ch
.text$mn:00000130 var_138         = dword ptr -138h
.text$mn:00000130 var_134         = dword ptr -134h
.text$mn:00000130 var_130         = dword ptr -130h
.text$mn:00000130 var_12C         = dword ptr -12Ch
.text$mn:00000130 var_128         = dword ptr -128h
.text$mn:00000130 var_124         = dword ptr -124h
.text$mn:00000130 var_120         = dword ptr -120h
.text$mn:00000130 var_11C         = dword ptr -11Ch
.text$mn:00000130 var_118         = dword ptr -118h
.text$mn:00000130 var_114         = dword ptr -114h
.text$mn:00000130 var_110         = dword ptr -110h
.text$mn:00000130 var_10C         = dword ptr -10Ch
.text$mn:00000130 var_108         = dword ptr -108h
.text$mn:00000130 var_104         = dword ptr -104h
.text$mn:00000130 var_100         = dword ptr -100h
.text$mn:00000130 var_FC          = dword ptr -0FCh
.text$mn:00000130 Str             = dword ptr -0F8h
.text$mn:00000130 var_F4          = dword ptr -0F4h
.text$mn:00000130 var_F0          = dword ptr -0F0h
.text$mn:00000130 var_EC          = dword ptr -0ECh
.text$mn:00000130 var_E8          = dword ptr -0E8h
.text$mn:00000130 var_E4          = dword ptr -0E4h
.text$mn:00000130 var_E0          = dword ptr -0E0h
.text$mn:00000130 var_DC          = dword ptr -0DCh
.text$mn:00000130 var_D8          = dword ptr -0D8h
.text$mn:00000130 var_D4          = dword ptr -0D4h
.text$mn:00000130 var_D0          = byte ptr -0D0h
.text$mn:00000130 var_AC          = byte ptr -0ACh
.text$mn:00000130 var_88          = byte ptr -88h
.text$mn:00000130 var_64          = byte ptr -64h
.text$mn:00000130 var_48          = byte ptr -48h
.text$mn:00000130 var_2C          = byte ptr -2Ch
.text$mn:00000130 var_10          = dword ptr -10h
.text$mn:00000130 var_C           = dword ptr -0Ch
.text$mn:00000130 var_4           = dword ptr -4
.text$mn:00000130 arg_0           = dword ptr  8
.text$mn:00000130
.text$mn:00000130                 push    ebp
.text$mn:00000131                 mov     ebp, esp
.text$mn:00000133                 push    0FFFFFFFFh
.text$mn:00000135                 push    offset __ehhandler$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z
.text$mn:0000013A                 mov     eax, large fs:0
.text$mn:00000140                 push    eax
.text$mn:00000141                 sub     esp, 130h
.text$mn:00000147                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000014C                 xor     eax, ebp
.text$mn:0000014E                 mov     [ebp+var_10], eax
.text$mn:00000151                 push    eax
.text$mn:00000152                 lea     eax, [ebp+var_C]
.text$mn:00000155                 mov     large fs:0, eax
.text$mn:0000015B                 mov     [ebp+var_D4], ecx
.text$mn:00000161                 push    offset $SG123040 ; "NotepadPlus"
.text$mn:00000166                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000169                 call    ?FirstChild@TiXmlNode@@QBEPAV1@PB_W@Z ; TiXmlNode::FirstChild(wchar_t const *)
.text$mn:0000016E                 mov     ecx, [ebp+var_D4]
.text$mn:00000174                 mov     [ecx+174h], eax
.text$mn:0000017A                 mov     edx, [ebp+var_D4]
.text$mn:00000180                 cmp     dword ptr [edx+174h], 0
.text$mn:00000187                 jz      loc_5DF
.text$mn:0000018D                 push    offset $SG123042 ; "ToolBarIcons"
.text$mn:00000192                 mov     eax, [ebp+var_D4]
.text$mn:00000198                 mov     ecx, [eax+174h] ; this
.text$mn:0000019E                 call    ?FirstChild@TiXmlNode@@QBEPAV1@PB_W@Z ; TiXmlNode::FirstChild(wchar_t const *)
.text$mn:000001A3                 mov     ecx, [ebp+var_D4]
.text$mn:000001A9                 mov     [ecx+174h], eax
.text$mn:000001AF                 mov     edx, [ebp+var_D4]
.text$mn:000001B5                 cmp     dword ptr [edx+174h], 0
.text$mn:000001BC                 jz      loc_5DF
.text$mn:000001C2                 push    offset $SG123044 ; "Theme"
.text$mn:000001C7                 mov     eax, [ebp+var_D4]
.text$mn:000001CD                 mov     ecx, [eax+174h] ; this
.text$mn:000001D3                 call    ?FirstChild@TiXmlNode@@QBEPAV1@PB_W@Z ; TiXmlNode::FirstChild(wchar_t const *)
.text$mn:000001D8                 mov     ecx, [ebp+var_D4]
.text$mn:000001DE                 mov     [ecx+174h], eax
.text$mn:000001E4                 mov     edx, [ebp+var_D4]
.text$mn:000001EA                 cmp     dword ptr [edx+174h], 0
.text$mn:000001F1                 jz      loc_5DF
.text$mn:000001F7                 push    offset $SG123047 ; "pathPrefix"
.text$mn:000001FC                 mov     eax, [ebp+var_D4]
.text$mn:00000202                 mov     ecx, [eax+174h] ; this
.text$mn:00000208                 call    ?ToElement@TiXmlNode@@QBEPAVTiXmlElement@@XZ ; TiXmlNode::ToElement(void)
.text$mn:0000020D                 mov     ecx, eax        ; this
.text$mn:0000020F                 call    ?Attribute@TiXmlElement@@QBEPB_WPB_W@Z ; TiXmlElement::Attribute(wchar_t const *)
.text$mn:00000214                 mov     [ebp+var_E0], eax
.text$mn:0000021A                 push    offset $SG123049 ; "Icon"
.text$mn:0000021F                 mov     ecx, [ebp+var_D4]
.text$mn:00000225                 mov     ecx, [ecx+174h] ; this
.text$mn:0000022B                 call    ?FirstChildElement@TiXmlNode@@QBEPAVTiXmlElement@@PB_W@Z ; TiXmlNode::FirstChildElement(wchar_t const *)
.text$mn:00000230                 mov     [ebp+var_DC], eax
.text$mn:00000236                 jmp     short loc_24E
.text$mn:00000238 ; ---------------------------------------------------------------------------
.text$mn:00000238
.text$mn:00000238 loc_238:                                ; CODE XREF: ToolBar::initTheme(TiXmlDocument *):loc_5DAj
.text$mn:00000238                 push    offset $SG123053 ; "Icon"
.text$mn:0000023D                 mov     ecx, [ebp+var_DC] ; this
.text$mn:00000243                 call    ?NextSibling@TiXmlNode@@QBEPAV1@PB_W@Z ; TiXmlNode::NextSibling(wchar_t const *)
.text$mn:00000248                 mov     [ebp+var_DC], eax
.text$mn:0000024E
.text$mn:0000024E loc_24E:                                ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+106j
.text$mn:0000024E                 cmp     [ebp+var_DC], 0
.text$mn:00000255                 jz      loc_5DF
.text$mn:0000025B                 lea     edx, [ebp+var_E4]
.text$mn:00000261                 push    edx             ; int *
.text$mn:00000262                 push    offset $SG123056 ; "id"
.text$mn:00000267                 mov     ecx, [ebp+var_DC] ; this
.text$mn:0000026D                 call    ?ToElement@TiXmlNode@@QBEPAVTiXmlElement@@XZ ; TiXmlNode::ToElement(void)
.text$mn:00000272                 mov     ecx, eax        ; this
.text$mn:00000274                 call    ?Attribute@TiXmlElement@@QBEPB_WPB_WPAH@Z ; TiXmlElement::Attribute(wchar_t const *,int *)
.text$mn:00000279                 mov     [ebp+var_124], eax
.text$mn:0000027F                 cmp     [ebp+var_124], 0
.text$mn:00000286                 jz      loc_5DA
.text$mn:0000028C                 push    offset $SG123059 ; "normal"
.text$mn:00000291                 mov     ecx, [ebp+var_DC] ; this
.text$mn:00000297                 call    ?FirstChildElement@TiXmlNode@@QBEPAVTiXmlElement@@PB_W@Z ; TiXmlNode::FirstChildElement(wchar_t const *)
.text$mn:0000029C                 mov     [ebp+var_D8], eax
.text$mn:000002A2                 cmp     [ebp+var_D8], 0
.text$mn:000002A9                 jz      loc_3A6
.text$mn:000002AF                 mov     ecx, [ebp+var_D8] ; this
.text$mn:000002B5                 call    ?FirstChild@TiXmlNode@@QBEPAV1@XZ ; TiXmlNode::FirstChild(void)
.text$mn:000002BA                 mov     [ebp+var_FC], eax
.text$mn:000002C0                 cmp     [ebp+var_FC], 0
.text$mn:000002C7                 jz      loc_3A6
.text$mn:000002CD                 cmp     [ebp+var_E0], 0
.text$mn:000002D4                 jz      short loc_2E4
.text$mn:000002D6                 mov     eax, [ebp+var_E0]
.text$mn:000002DC                 mov     [ebp+Str], eax
.text$mn:000002E2                 jmp     short loc_2EE
.text$mn:000002E4 ; ---------------------------------------------------------------------------
.text$mn:000002E4
.text$mn:000002E4 loc_2E4:                                ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+1A4j
.text$mn:000002E4                 mov     [ebp+Str], offset $SG123064
.text$mn:000002EE
.text$mn:000002EE loc_2EE:                                ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+1B2j
.text$mn:000002EE                 mov     ecx, [ebp+Str]
.text$mn:000002F4                 push    ecx             ; Str
.text$mn:000002F5                 lea     ecx, [ebp+var_2C]
.text$mn:000002F8                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000002FD                 mov     [ebp+var_4], 0
.text$mn:00000304                 mov     ecx, [ebp+var_FC] ; this
.text$mn:0000030A                 call    ?Value@TiXmlNode@@QBEPB_WXZ ; TiXmlNode::Value(void)
.text$mn:0000030F                 push    eax             ; Str
.text$mn:00000310                 lea     ecx, [ebp+var_2C]
.text$mn:00000313                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00000318                 sub     esp, 1Ch
.text$mn:0000031B                 mov     ecx, esp
.text$mn:0000031D                 mov     [ebp+var_12C], esp
.text$mn:00000323                 lea     edx, [ebp+var_2C]
.text$mn:00000326                 push    edx
.text$mn:00000327                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000032C                 mov     [ebp+var_104], eax
.text$mn:00000332                 mov     eax, [ebp+var_104]
.text$mn:00000338                 mov     [ebp+var_13C], eax
.text$mn:0000033E                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000342                 mov     ecx, [ebp+var_E4]
.text$mn:00000348                 push    ecx
.text$mn:00000349                 push    0
.text$mn:0000034B                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000034F                 lea     ecx, [ebp+var_D0]
.text$mn:00000355                 call    ??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; iconLocator::iconLocator(int,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)
.text$mn:0000035A                 mov     [ebp+var_10C], eax
.text$mn:00000360                 mov     edx, [ebp+var_10C]
.text$mn:00000366                 mov     [ebp+var_114], edx
.text$mn:0000036C                 mov     byte ptr [ebp+var_4], 2
.text$mn:00000370                 mov     eax, [ebp+var_114]
.text$mn:00000376                 push    eax
.text$mn:00000377                 mov     ecx, [ebp+var_D4]
.text$mn:0000037D                 add     ecx, 164h
.text$mn:00000383                 call    ?push_back@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QAEX$$QAUiconLocator@@@Z ; std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)
.text$mn:00000388                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000038C                 lea     ecx, [ebp+var_D0] ; this
.text$mn:00000392                 call    ??1iconLocator@@QAE@XZ ; iconLocator::~iconLocator(void)
.text$mn:00000397                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000039E                 lea     ecx, [ebp+var_2C]
.text$mn:000003A1                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000003A6
.text$mn:000003A6 loc_3A6:                                ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+179j
.text$mn:000003A6                                         ; ToolBar::initTheme(TiXmlDocument *)+197j
.text$mn:000003A6                 push    offset $SG123067 ; "hover"
.text$mn:000003AB                 mov     ecx, [ebp+var_DC] ; this
.text$mn:000003B1                 call    ?FirstChildElement@TiXmlNode@@QBEPAVTiXmlElement@@PB_W@Z ; TiXmlNode::FirstChildElement(wchar_t const *)
.text$mn:000003B6                 mov     [ebp+var_D8], eax
.text$mn:000003BC                 cmp     [ebp+var_D8], 0
.text$mn:000003C3                 jz      loc_4C0
.text$mn:000003C9                 mov     ecx, [ebp+var_D8] ; this
.text$mn:000003CF                 call    ?FirstChild@TiXmlNode@@QBEPAV1@XZ ; TiXmlNode::FirstChild(void)
.text$mn:000003D4                 mov     [ebp+var_E8], eax
.text$mn:000003DA                 cmp     [ebp+var_E8], 0
.text$mn:000003E1                 jz      loc_4C0
.text$mn:000003E7                 cmp     [ebp+var_E0], 0
.text$mn:000003EE                 jz      short loc_3FE
.text$mn:000003F0                 mov     ecx, [ebp+var_E0]
.text$mn:000003F6                 mov     [ebp+var_F0], ecx
.text$mn:000003FC                 jmp     short loc_408
.text$mn:000003FE ; ---------------------------------------------------------------------------
.text$mn:000003FE
.text$mn:000003FE loc_3FE:                                ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+2BEj
.text$mn:000003FE                 mov     [ebp+var_F0], offset $SG123072
.text$mn:00000408
.text$mn:00000408 loc_408:                                ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+2CCj
.text$mn:00000408                 mov     edx, [ebp+var_F0]
.text$mn:0000040E                 push    edx             ; Str
.text$mn:0000040F                 lea     ecx, [ebp+var_64]
.text$mn:00000412                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000417                 mov     [ebp+var_4], 3
.text$mn:0000041E                 mov     ecx, [ebp+var_E8] ; this
.text$mn:00000424                 call    ?Value@TiXmlNode@@QBEPB_WXZ ; TiXmlNode::Value(void)
.text$mn:00000429                 push    eax             ; Str
.text$mn:0000042A                 lea     ecx, [ebp+var_64]
.text$mn:0000042D                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00000432                 sub     esp, 1Ch
.text$mn:00000435                 mov     ecx, esp
.text$mn:00000437                 mov     [ebp+var_130], esp
.text$mn:0000043D                 lea     eax, [ebp+var_64]
.text$mn:00000440                 push    eax
.text$mn:00000441                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00000446                 mov     [ebp+var_11C], eax
.text$mn:0000044C                 mov     ecx, [ebp+var_11C]
.text$mn:00000452                 mov     [ebp+var_138], ecx
.text$mn:00000458                 mov     byte ptr [ebp+var_4], 4
.text$mn:0000045C                 mov     edx, [ebp+var_E4]
.text$mn:00000462                 push    edx
.text$mn:00000463                 push    1
.text$mn:00000465                 mov     byte ptr [ebp+var_4], 3
.text$mn:00000469                 lea     ecx, [ebp+var_AC]
.text$mn:0000046F                 call    ??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; iconLocator::iconLocator(int,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)
.text$mn:00000474                 mov     [ebp+var_100], eax
.text$mn:0000047A                 mov     eax, [ebp+var_100]
.text$mn:00000480                 mov     [ebp+var_108], eax
.text$mn:00000486                 mov     byte ptr [ebp+var_4], 5
.text$mn:0000048A                 mov     ecx, [ebp+var_108]
.text$mn:00000490                 push    ecx
.text$mn:00000491                 mov     ecx, [ebp+var_D4]
.text$mn:00000497                 add     ecx, 164h
.text$mn:0000049D                 call    ?push_back@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QAEX$$QAUiconLocator@@@Z ; std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)
.text$mn:000004A2                 mov     byte ptr [ebp+var_4], 3
.text$mn:000004A6                 lea     ecx, [ebp+var_AC] ; this
.text$mn:000004AC                 call    ??1iconLocator@@QAE@XZ ; iconLocator::~iconLocator(void)
.text$mn:000004B1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000004B8                 lea     ecx, [ebp+var_64]
.text$mn:000004BB                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000004C0
.text$mn:000004C0 loc_4C0:                                ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+293j
.text$mn:000004C0                                         ; ToolBar::initTheme(TiXmlDocument *)+2B1j
.text$mn:000004C0                 push    offset $SG123075 ; "disabled"
.text$mn:000004C5                 mov     ecx, [ebp+var_DC] ; this
.text$mn:000004CB                 call    ?FirstChildElement@TiXmlNode@@QBEPAVTiXmlElement@@PB_W@Z ; TiXmlNode::FirstChildElement(wchar_t const *)
.text$mn:000004D0                 mov     [ebp+var_D8], eax
.text$mn:000004D6                 cmp     [ebp+var_D8], 0
.text$mn:000004DD                 jz      loc_5DA
.text$mn:000004E3                 mov     ecx, [ebp+var_D8] ; this
.text$mn:000004E9                 call    ?FirstChild@TiXmlNode@@QBEPAV1@XZ ; TiXmlNode::FirstChild(void)
.text$mn:000004EE                 mov     [ebp+var_F4], eax
.text$mn:000004F4                 cmp     [ebp+var_F4], 0
.text$mn:000004FB                 jz      loc_5DA
.text$mn:00000501                 cmp     [ebp+var_E0], 0
.text$mn:00000508                 jz      short loc_518
.text$mn:0000050A                 mov     edx, [ebp+var_E0]
.text$mn:00000510                 mov     [ebp+var_EC], edx
.text$mn:00000516                 jmp     short loc_522
.text$mn:00000518 ; ---------------------------------------------------------------------------
.text$mn:00000518
.text$mn:00000518 loc_518:                                ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+3D8j
.text$mn:00000518                 mov     [ebp+var_EC], offset $SG123080
.text$mn:00000522
.text$mn:00000522 loc_522:                                ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+3E6j
.text$mn:00000522                 mov     eax, [ebp+var_EC]
.text$mn:00000528                 push    eax             ; Str
.text$mn:00000529                 lea     ecx, [ebp+var_48]
.text$mn:0000052C                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000531                 mov     [ebp+var_4], 6
.text$mn:00000538                 mov     ecx, [ebp+var_F4] ; this
.text$mn:0000053E                 call    ?Value@TiXmlNode@@QBEPB_WXZ ; TiXmlNode::Value(void)
.text$mn:00000543                 push    eax             ; Str
.text$mn:00000544                 lea     ecx, [ebp+var_48]
.text$mn:00000547                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:0000054C                 sub     esp, 1Ch
.text$mn:0000054F                 mov     ecx, esp
.text$mn:00000551                 mov     [ebp+var_128], esp
.text$mn:00000557                 lea     edx, [ebp+var_48]
.text$mn:0000055A                 push    edx
.text$mn:0000055B                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00000560                 mov     [ebp+var_120], eax
.text$mn:00000566                 mov     eax, [ebp+var_120]
.text$mn:0000056C                 mov     [ebp+var_134], eax
.text$mn:00000572                 mov     byte ptr [ebp+var_4], 7
.text$mn:00000576                 mov     ecx, [ebp+var_E4]
.text$mn:0000057C                 push    ecx
.text$mn:0000057D                 push    2
.text$mn:0000057F                 mov     byte ptr [ebp+var_4], 6
.text$mn:00000583                 lea     ecx, [ebp+var_88]
.text$mn:00000589                 call    ??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; iconLocator::iconLocator(int,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)
.text$mn:0000058E                 mov     [ebp+var_118], eax
.text$mn:00000594                 mov     edx, [ebp+var_118]
.text$mn:0000059A                 mov     [ebp+var_110], edx
.text$mn:000005A0                 mov     byte ptr [ebp+var_4], 8
.text$mn:000005A4                 mov     eax, [ebp+var_110]
.text$mn:000005AA                 push    eax
.text$mn:000005AB                 mov     ecx, [ebp+var_D4]
.text$mn:000005B1                 add     ecx, 164h
.text$mn:000005B7                 call    ?push_back@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QAEX$$QAUiconLocator@@@Z ; std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)
.text$mn:000005BC                 mov     byte ptr [ebp+var_4], 6
.text$mn:000005C0                 lea     ecx, [ebp+var_88] ; this
.text$mn:000005C6                 call    ??1iconLocator@@QAE@XZ ; iconLocator::~iconLocator(void)
.text$mn:000005CB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000005D2                 lea     ecx, [ebp+var_48]
.text$mn:000005D5                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000005DA
.text$mn:000005DA loc_5DA:                                ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+156j
.text$mn:000005DA                                         ; ToolBar::initTheme(TiXmlDocument *)+3ADj ...
.text$mn:000005DA                 jmp     loc_238
.text$mn:000005DF ; ---------------------------------------------------------------------------
.text$mn:000005DF
.text$mn:000005DF loc_5DF:                                ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+57j
.text$mn:000005DF                                         ; ToolBar::initTheme(TiXmlDocument *)+8Cj ...
.text$mn:000005DF                 mov     ecx, [ebp+var_C]
.text$mn:000005E2                 mov     large fs:0, ecx
.text$mn:000005E9                 pop     ecx
.text$mn:000005EA                 mov     ecx, [ebp+var_10]
.text$mn:000005ED                 xor     ecx, ebp
.text$mn:000005EF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000005F4                 mov     esp, ebp
.text$mn:000005F6                 pop     ebp
.text$mn:000005F7                 retn    4
.text$mn:000005F7 ?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z endp
.text$mn:000005F7
.text$mn:000005F7 ; ---------------------------------------------------------------------------
.text$mn:000005FA                 align 10h
.text$mn:00000600
.text$mn:00000600 ; =============== S U B R O U T I N E =======================================
.text$mn:00000600
.text$mn:00000600 ; Attributes: bp-based frame
.text$mn:00000600
.text$mn:00000600 ; public: virtual bool __thiscall ToolBar::init(struct HINSTANCE__ *, struct HWND__ *, enum  toolBarStatusType, struct ToolBarButtonUnit *, int)
.text$mn:00000600                 public ?init@ToolBar@@UAE_NPAUHINSTANCE__@@PAUHWND__@@W4toolBarStatusType@@PAUToolBarButtonUnit@@H@Z
.text$mn:00000600 ?init@ToolBar@@UAE_NPAUHINSTANCE__@@PAUHWND__@@W4toolBarStatusType@@PAUToolBarButtonUnit@@H@Z proc near
.text$mn:00000600
.text$mn:00000600 picce           = INITCOMMONCONTROLSEX ptr -34h
.text$mn:00000600 var_2C          = dword ptr -2Ch
.text$mn:00000600 var_28          = dword ptr -28h
.text$mn:00000600 var_24          = dword ptr -24h
.text$mn:00000600 var_20          = dword ptr -20h
.text$mn:00000600 var_1C          = dword ptr -1Ch
.text$mn:00000600 var_18          = dword ptr -18h
.text$mn:00000600 var_14          = dword ptr -14h
.text$mn:00000600 var_10          = dword ptr -10h
.text$mn:00000600 var_C           = dword ptr -0Ch
.text$mn:00000600 var_8           = dword ptr -8
.text$mn:00000600 var_4           = dword ptr -4
.text$mn:00000600 arg_0           = dword ptr  8
.text$mn:00000600 arg_4           = dword ptr  0Ch
.text$mn:00000600 arg_8           = dword ptr  10h
.text$mn:00000600 arg_C           = dword ptr  14h
.text$mn:00000600 arg_10          = dword ptr  18h
.text$mn:00000600
.text$mn:00000600                 push    ebp
.text$mn:00000601                 mov     ebp, esp
.text$mn:00000603                 sub     esp, 34h
.text$mn:00000606                 mov     [ebp+var_4], ecx
.text$mn:00000609                 mov     eax, [ebp+arg_4]
.text$mn:0000060C                 push    eax             ; HWND
.text$mn:0000060D                 mov     ecx, [ebp+arg_0]
.text$mn:00000610                 push    ecx             ; HINSTANCE
.text$mn:00000611                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000614                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:00000619                 mov     edx, [ebp+var_4]
.text$mn:0000061C                 mov     eax, [ebp+arg_8]
.text$mn:0000061F                 mov     [edx+0ECh], eax
.text$mn:00000625                 mov     ecx, [ebp+var_4]
.text$mn:00000628                 cmp     dword ptr [ecx+0ECh], 1
.text$mn:0000062F                 jnz     short loc_63A
.text$mn:00000631                 mov     [ebp+var_18], 20h ; ' '
.text$mn:00000638                 jmp     short loc_641
.text$mn:0000063A ; ---------------------------------------------------------------------------
.text$mn:0000063A
.text$mn:0000063A loc_63A:                                ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+2Fj
.text$mn:0000063A                 mov     [ebp+var_18], 10h
.text$mn:00000641
.text$mn:00000641 loc_641:                                ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+38j
.text$mn:00000641                 mov     edx, [ebp+var_18]
.text$mn:00000644                 push    edx             ; int
.text$mn:00000645                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:0000064A                 add     eax, 0Ch
.text$mn:0000064D                 mov     ecx, eax        ; this
.text$mn:0000064F                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:00000654                 mov     [ebp+var_28], eax
.text$mn:00000657                 mov     eax, [ebp+arg_10]
.text$mn:0000065A                 push    eax             ; int
.text$mn:0000065B                 mov     ecx, [ebp+arg_C]
.text$mn:0000065E                 push    ecx             ; struct ToolBarButtonUnit *
.text$mn:0000065F                 mov     ecx, [ebp+var_4]
.text$mn:00000662                 add     ecx, 14h        ; this
.text$mn:00000665                 call    ?init@ToolBarIcons@@QAEXPAUToolBarButtonUnit@@H@Z ; ToolBarIcons::init(ToolBarButtonUnit *,int)
.text$mn:0000066A                 mov     edx, [ebp+var_28]
.text$mn:0000066D                 push    edx             ; int
.text$mn:0000066E                 mov     eax, [ebp+var_4]
.text$mn:00000671                 mov     ecx, [eax+4]
.text$mn:00000674                 push    ecx             ; HINSTANCE
.text$mn:00000675                 mov     ecx, [ebp+var_4]
.text$mn:00000678                 add     ecx, 14h        ; this
.text$mn:0000067B                 call    ?create@ToolBarIcons@@QAEXPAUHINSTANCE__@@H@Z ; ToolBarIcons::create(HINSTANCE__ *,int)
.text$mn:00000680                 mov     [ebp+picce.dwSize], 8
.text$mn:00000687                 mov     [ebp+picce.dwICC], 6FFh
.text$mn:0000068E                 lea     edx, [ebp+picce]
.text$mn:00000691                 push    edx             ; picce
.text$mn:00000692                 call    dword ptr ds:__imp__InitCommonControlsEx@4 ; InitCommonControlsEx(x)
.text$mn:00000698                 mov     eax, [ebp+var_4]
.text$mn:0000069B
.text$mn:0000069B ; const WCHAR BitmapName
.text$mn:0000069B BitmapName:                             ; DATA XREF: ReBar::setGrayBackground(int)+4Ao
.text$mn:0000069B                 mov     ecx, [ebp+arg_10]
.text$mn:0000069E                 mov     [eax+100h], ecx
.text$mn:000006A4                 mov     ecx, [ebp+var_4]
.text$mn:000006A7                 add     ecx, 0F0h ; '='
.text$mn:000006AD                 call    ?size@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ ; std::vector<tDynamicList,std::allocator<tDynamicList>>::size(void)
.text$mn:000006B2                 mov     edx, [ebp+var_4]
.text$mn:000006B5                 mov     [edx+104h], eax
.text$mn:000006BB                 mov     eax, [ebp+var_4]
.text$mn:000006BE                 cmp     dword ptr [eax+104h], 0
.text$mn:000006C5                 jz      short loc_6D8
.text$mn:000006C7                 mov     ecx, [ebp+var_4]
.text$mn:000006CA                 mov     edx, [ecx+104h]
.text$mn:000006D0                 add     edx, 1
.text$mn:000006D3                 mov     [ebp+var_1C], edx
.text$mn:000006D6                 jmp     short loc_6DF
.text$mn:000006D8 ; ---------------------------------------------------------------------------
.text$mn:000006D8
.text$mn:000006D8 loc_6D8:                                ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+C5j
.text$mn:000006D8                 mov     [ebp+var_1C], 0
.text$mn:000006DF
.text$mn:000006DF loc_6DF:                                ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+D6j
.text$mn:000006DF                 mov     eax, [ebp+var_4]
.text$mn:000006E2                 mov     ecx, [eax+100h]
.text$mn:000006E8                 add     ecx, [ebp+var_1C]
.text$mn:000006EB                 mov     edx, [ebp+var_4]
.text$mn:000006EE                 mov     [edx+108h], ecx
.text$mn:000006F4                 xor     ecx, ecx
.text$mn:000006F6                 mov     edx, [ebp+var_4]
.text$mn:000006F9                 mov     eax, [edx+108h]
.text$mn:000006FF                 mov     edx, 14h
.text$mn:00000704                 mul     edx
.text$mn:00000706                 seto    cl
.text$mn:00000709                 neg     ecx
.text$mn:0000070B                 or      ecx, eax
.text$mn:0000070D                 push    ecx             ; unsigned int
.text$mn:0000070E                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00000713                 add     esp, 4
.text$mn:00000716                 mov     [ebp+var_2C], eax
.text$mn:00000719                 mov     eax, [ebp+var_4]
.text$mn:0000071C                 mov     ecx, [ebp+var_2C]
.text$mn:0000071F                 mov     [eax+10h], ecx
.text$mn:00000722                 mov     [ebp+var_10], 0
.text$mn:00000729                 mov     [ebp+var_C], 0FFFFFFFFh
.text$mn:00000730                 mov     [ebp+var_8], 0
.text$mn:00000737                 jmp     short loc_742
.text$mn:00000739 ; ---------------------------------------------------------------------------
.text$mn:00000739
.text$mn:00000739 loc_739:                                ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+1FAj
.text$mn:00000739                 mov     edx, [ebp+var_8]
.text$mn:0000073C                 add     edx, 1
.text$mn:0000073F                 mov     [ebp+var_8], edx
.text$mn:00000742
.text$mn:00000742 loc_742:                                ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+137j
.text$mn:00000742                 mov     eax, [ebp+var_4]
.text$mn:00000745                 mov     ecx, [ebp+var_8]
.text$mn:00000748                 cmp     ecx, [eax+100h]
.text$mn:0000074E                 jnb     loc_7FF
.text$mn:00000754                 imul    edx, [ebp+var_8], 14h
.text$mn:00000758                 mov     eax, [ebp+arg_C]
.text$mn:0000075B                 mov     ecx, [eax+edx]
.text$mn:0000075E                 mov     [ebp+var_10], ecx
.text$mn:00000761                 cmp     [ebp+var_10], 0
.text$mn:00000765                 jz      short loc_779
.text$mn:00000767                 mov     edx, [ebp+var_C]
.text$mn:0000076A                 add     edx, 1
.text$mn:0000076D                 mov     [ebp+var_C], edx
.text$mn:00000770                 mov     [ebp+var_24], 0
.text$mn:00000777                 jmp     short loc_780
.text$mn:00000779 ; ---------------------------------------------------------------------------
.text$mn:00000779
.text$mn:00000779 loc_779:                                ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+165j
.text$mn:00000779                 mov     [ebp+var_24], 1
.text$mn:00000780
.text$mn:00000780 loc_780:                                ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+177j
.text$mn:00000780                 cmp     [ebp+var_10], 0
.text$mn:00000784                 jz      short loc_78E
.text$mn:00000786                 mov     eax, [ebp+var_C]
.text$mn:00000789                 mov     [ebp+var_20], eax
.text$mn:0000078C                 jmp     short loc_795
.text$mn:0000078E ; ---------------------------------------------------------------------------
.text$mn:0000078E
.text$mn:0000078E loc_78E:                                ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+184j
.text$mn:0000078E                 mov     [ebp+var_20], 0
.text$mn:00000795
.text$mn:00000795 loc_795:                                ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+18Cj
.text$mn:00000795                 imul    ecx, [ebp+var_8], 14h
.text$mn:00000799                 mov     edx, [ebp+var_4]
.text$mn:0000079C                 mov     eax, [edx+10h]
.text$mn:0000079F                 mov     edx, [ebp+var_20]
.text$mn:000007A2                 mov     [eax+ecx], edx
.text$mn:000007A5                 imul    eax, [ebp+var_8], 14h
.text$mn:000007A9                 mov     ecx, [ebp+var_4]
.text$mn:000007AC                 mov     edx, [ecx+10h]
.text$mn:000007AF                 mov     ecx, [ebp+var_10]
.text$mn:000007B2                 mov     [edx+eax+4], ecx
.text$mn:000007B6                 imul    edx, [ebp+var_8], 14h
.text$mn:000007BA                 mov     eax, [ebp+var_4]
.text$mn:000007BD                 mov     ecx, [eax+10h]
.text$mn:000007C0                 mov     byte ptr [ecx+edx+8], 4
.text$mn:000007C5                 imul    edx, [ebp+var_8], 14h
.text$mn:000007C9                 mov     eax, [ebp+var_4]
.text$mn:000007CC                 mov     ecx, [eax+10h]
.text$mn:000007CF                 mov     al, byte ptr [ebp+var_24]
.text$mn:000007D2                 mov     [ecx+edx+9], al
.text$mn:000007D6                 imul    ecx, [ebp+var_8], 14h
.text$mn:000007DA                 mov     edx, [ebp+var_4]
.text$mn:000007DD                 mov     eax, [edx+10h]
.text$mn:000007E0                 mov     dword ptr [eax+ecx+0Ch], 0
.text$mn:000007E8                 imul    ecx, [ebp+var_8], 14h
.text$mn:000007EC                 mov     edx, [ebp+var_4]
.text$mn:000007EF                 mov     eax, [edx+10h]
.text$mn:000007F2                 mov     dword ptr [eax+ecx+10h], 0
.text$mn:000007FA                 jmp     loc_739
.text$mn:000007FF ; ---------------------------------------------------------------------------
.text$mn:000007FF
.text$mn:000007FF loc_7FF:                                ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+14Ej
.text$mn:000007FF                 mov     ecx, [ebp+var_4]
.text$mn:00000802                 cmp     dword ptr [ecx+104h], 0
.text$mn:00000809                 jbe     loc_932
.text$mn:0000080F                 imul    edx, [ebp+var_8], 14h
.text$mn:00000813                 mov     eax, [ebp+var_4]
.text$mn:00000816                 mov     ecx, [eax+10h]
.text$mn:00000819                 mov     dword ptr [ecx+edx], 0
.text$mn:00000820                 imul    edx, [ebp+var_8], 14h
.text$mn:00000824                 mov     eax, [ebp+var_4]
.text$mn:00000827                 mov     ecx, [eax+10h]
.text$mn:0000082A                 mov     dword ptr [ecx+edx+4], 0
.text$mn:00000832                 imul    edx, [ebp+var_8], 14h
.text$mn:00000836                 mov     eax, [ebp+var_4]
.text$mn:00000839                 mov     ecx, [eax+10h]
.text$mn:0000083C                 mov     byte ptr [ecx+edx+8], 4
.text$mn:00000841                 imul    edx, [ebp+var_8], 14h
.text$mn:00000845                 mov     eax, [ebp+var_4]
.text$mn:00000848                 mov     ecx, [eax+10h]
.text$mn:0000084B                 mov     byte ptr [ecx+edx+9], 1
.text$mn:00000850                 imul    edx, [ebp+var_8], 14h
.text$mn:00000854                 mov     eax, [ebp+var_4]
.text$mn:00000857                 mov     ecx, [eax+10h]
.text$mn:0000085A                 mov     dword ptr [ecx+edx+0Ch], 0
.text$mn:00000862                 imul    edx, [ebp+var_8], 14h
.text$mn:00000866                 mov     eax, [ebp+var_4]
.text$mn:00000869                 mov     ecx, [eax+10h]
.text$mn:0000086C                 mov     dword ptr [ecx+edx+10h], 0
.text$mn:00000874                 mov     edx, [ebp+var_8]
.text$mn:00000877                 add     edx, 1
.text$mn:0000087A                 mov     [ebp+var_8], edx
.text$mn:0000087D                 mov     [ebp+var_14], 0
.text$mn:00000884                 jmp     short loc_898
.text$mn:00000886 ; ---------------------------------------------------------------------------
.text$mn:00000886
.text$mn:00000886 loc_886:                                ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+32Dj
.text$mn:00000886                 mov     eax, [ebp+var_14]
.text$mn:00000889                 add     eax, 1
.text$mn:0000088C                 mov     [ebp+var_14], eax
.text$mn:0000088F                 mov     ecx, [ebp+var_8]
.text$mn:00000892                 add     ecx, 1
.text$mn:00000895                 mov     [ebp+var_8], ecx
.text$mn:00000898
.text$mn:00000898 loc_898:                                ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+284j
.text$mn:00000898                 mov     edx, [ebp+var_4]
.text$mn:0000089B                 mov     eax, [ebp+var_14]
.text$mn:0000089E                 cmp     eax, [edx+104h]
.text$mn:000008A4                 jnb     loc_932
.text$mn:000008AA                 mov     ecx, [ebp+var_14]
.text$mn:000008AD                 push    ecx
.text$mn:000008AE                 mov     ecx, [ebp+var_4]
.text$mn:000008B1                 add     ecx, 0F0h ; '='
.text$mn:000008B7                 call    ??A?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QAEAAUtDynamicList@@I@Z ; std::vector<tDynamicList,std::allocator<tDynamicList>>::operator[](uint)
.text$mn:000008BC                 mov     edx, [eax]
.text$mn:000008BE                 mov     [ebp+var_10], edx
.text$mn:000008C1                 mov     eax, [ebp+var_C]
.text$mn:000008C4                 add     eax, 1
.text$mn:000008C7                 mov     [ebp+var_C], eax
.text$mn:000008CA                 imul    ecx, [ebp+var_8], 14h
.text$mn:000008CE                 mov     edx, [ebp+var_4]
.text$mn:000008D1                 mov     eax, [edx+10h]
.text$mn:000008D4                 mov     edx, [ebp+var_C]
.text$mn:000008D7                 mov     [eax+ecx], edx
.text$mn:000008DA                 imul    eax, [ebp+var_8], 14h
.text$mn:000008DE                 mov     ecx, [ebp+var_4]
.text$mn:000008E1                 mov     edx, [ecx+10h]
.text$mn:000008E4                 mov     ecx, [ebp+var_10]
.text$mn:000008E7                 mov     [edx+eax+4], ecx
.text$mn:000008EB                 imul    edx, [ebp+var_8], 14h
.text$mn:000008EF                 mov     eax, [ebp+var_4]
.text$mn:000008F2                 mov     ecx, [eax+10h]
.text$mn:000008F5                 mov     byte ptr [ecx+edx+8], 4
.text$mn:000008FA                 imul    edx, [ebp+var_8], 14h
.text$mn:000008FE                 mov     eax, [ebp+var_4]
.text$mn:00000901                 mov     ecx, [eax+10h]
.text$mn:00000904                 mov     byte ptr [ecx+edx+9], 0
.text$mn:00000909                 imul    edx, [ebp+var_8], 14h
.text$mn:0000090D                 mov     eax, [ebp+var_4]
.text$mn:00000910                 mov     ecx, [eax+10h]
.text$mn:00000913                 mov     dword ptr [ecx+edx+0Ch], 0
.text$mn:0000091B                 imul    edx, [ebp+var_8], 14h
.text$mn:0000091F                 mov     eax, [ebp+var_4]
.text$mn:00000922                 mov     ecx, [eax+10h]
.text$mn:00000925                 mov     dword ptr [ecx+edx+10h], 0
.text$mn:0000092D                 jmp     loc_886
.text$mn:00000932 ; ---------------------------------------------------------------------------
.text$mn:00000932
.text$mn:00000932 loc_932:                                ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+209j
.text$mn:00000932                                         ; ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+2A4j
.text$mn:00000932                 push    1               ; bool
.text$mn:00000934                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000937                 call    ?reset@ToolBar@@AAEX_N@Z ; ToolBar::reset(bool)
.text$mn:0000093C                 mov     al, 1
.text$mn:0000093E                 mov     esp, ebp
.text$mn:00000940                 pop     ebp
.text$mn:00000941                 retn    14h
.text$mn:00000941 ?init@ToolBar@@UAE_NPAUHINSTANCE__@@PAUHWND__@@W4toolBarStatusType@@PAUToolBarButtonUnit@@H@Z endp
.text$mn:00000941
.text$mn:00000941 ; ---------------------------------------------------------------------------
.text$mn:00000944                 align 10h
.text$mn:00000950
.text$mn:00000950 ; =============== S U B R O U T I N E =======================================
.text$mn:00000950
.text$mn:00000950 ; Attributes: bp-based frame
.text$mn:00000950
.text$mn:00000950 ; void __thiscall ToolBar::destroy(ToolBar *__hidden this)
.text$mn:00000950                 public ?destroy@ToolBar@@UAEXXZ
.text$mn:00000950 ?destroy@ToolBar@@UAEXXZ proc near
.text$mn:00000950
.text$mn:00000950 var_8           = dword ptr -8
.text$mn:00000950 var_4           = dword ptr -4
.text$mn:00000950
.text$mn:00000950                 push    ebp
.text$mn:00000951                 mov     ebp, esp
.text$mn:00000953                 sub     esp, 8
.text$mn:00000956                 mov     [ebp+var_4], ecx
.text$mn:00000959                 mov     eax, [ebp+var_4]
.text$mn:0000095C                 cmp     dword ptr [eax+110h], 0
.text$mn:00000963                 jz      short loc_98A
.text$mn:00000965                 mov     ecx, [ebp+var_4]
.text$mn:00000968                 mov     edx, [ecx+148h]
.text$mn:0000096E                 push    edx             ; int
.text$mn:0000096F                 mov     eax, [ebp+var_4]
.text$mn:00000972                 mov     ecx, [eax+110h] ; this
.text$mn:00000978                 call    ?removeBand@ReBar@@QAEXH@Z ; ReBar::removeBand(int)
.text$mn:0000097D                 mov     ecx, [ebp+var_4]
.text$mn:00000980                 mov     dword ptr [ecx+110h], 0
.text$mn:0000098A
.text$mn:0000098A loc_98A:                                ; CODE XREF: ToolBar::destroy(void)+13j
.text$mn:0000098A                 mov     edx, [ebp+var_4]
.text$mn:0000098D                 mov     eax, [edx+10h]
.text$mn:00000990                 mov     [ebp+var_8], eax
.text$mn:00000993                 mov     ecx, [ebp+var_8]
.text$mn:00000996                 push    ecx             ; void *
.text$mn:00000997                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:0000099C                 add     esp, 4
.text$mn:0000099F                 mov     edx, [ebp+var_4]
.text$mn:000009A2                 mov     eax, [edx+0Ch]
.text$mn:000009A5                 push    eax             ; hWnd
.text$mn:000009A6                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:000009AC                 mov     ecx, [ebp+var_4]
.text$mn:000009AF                 mov     dword ptr [ecx+0Ch], 0
.text$mn:000009B6                 mov     ecx, [ebp+var_4]
.text$mn:000009B9                 add     ecx, 14h        ; this
.text$mn:000009BC                 call    ?destroy@ToolBarIcons@@QAEXXZ ; ToolBarIcons::destroy(void)
.text$mn:000009C1                 mov     esp, ebp
.text$mn:000009C3                 pop     ebp
.text$mn:000009C4                 retn
.text$mn:000009C4 ?destroy@ToolBar@@UAEXXZ endp
.text$mn:000009C4
.text$mn:000009C4 ; ---------------------------------------------------------------------------
.text$mn:000009C5                 align 10h
.text$mn:000009D0
.text$mn:000009D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000009D0
.text$mn:000009D0 ; Attributes: bp-based frame
.text$mn:000009D0
.text$mn:000009D0 ; int __thiscall ToolBar::getWidth(ToolBar *__hidden this)
.text$mn:000009D0                 public ?getWidth@ToolBar@@UBEHXZ
.text$mn:000009D0 ?getWidth@ToolBar@@UBEHXZ proc near
.text$mn:000009D0
.text$mn:000009D0 var_20          = dword ptr -20h
.text$mn:000009D0 var_1C          = dword ptr -1Ch
.text$mn:000009D0 wParam          = dword ptr -18h
.text$mn:000009D0 lParam          = dword ptr -14h
.text$mn:000009D0 var_C           = dword ptr -0Ch
.text$mn:000009D0 var_4           = dword ptr -4
.text$mn:000009D0
.text$mn:000009D0                 push    ebp
.text$mn:000009D1                 mov     ebp, esp
.text$mn:000009D3                 sub     esp, 20h
.text$mn:000009D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000009DB                 xor     eax, ebp
.text$mn:000009DD                 mov     [ebp+var_4], eax
.text$mn:000009E0                 mov     [ebp+var_20], ecx
.text$mn:000009E3                 mov     [ebp+var_1C], 0
.text$mn:000009EA                 mov     [ebp+wParam], 0
.text$mn:000009F1                 jmp     short loc_9FC
.text$mn:000009F3 ; ---------------------------------------------------------------------------
.text$mn:000009F3
.text$mn:000009F3 loc_9F3:                                ; CODE XREF: ToolBar::getWidth(void)+60j
.text$mn:000009F3                 mov     eax, [ebp+wParam]
.text$mn:000009F6                 add     eax, 1
.text$mn:000009F9                 mov     [ebp+wParam], eax
.text$mn:000009FC
.text$mn:000009FC loc_9FC:                                ; CODE XREF: ToolBar::getWidth(void)+21j
.text$mn:000009FC                 mov     ecx, [ebp+var_20]
.text$mn:000009FF                 mov     edx, [ebp+wParam]
.text$mn:00000A02                 cmp     edx, [ecx+10Ch]
.text$mn:00000A08                 jnb     short loc_A32
.text$mn:00000A0A                 lea     eax, [ebp+lParam]
.text$mn:00000A0D                 push    eax             ; lParam
.text$mn:00000A0E                 mov     ecx, [ebp+wParam]
.text$mn:00000A11                 push    ecx             ; wParam
.text$mn:00000A12                 push    41Dh            ; Msg
.text$mn:00000A17                 mov     edx, [ebp+var_20]
.text$mn:00000A1A                 mov     eax, [edx+0Ch]
.text$mn:00000A1D                 push    eax             ; hWnd
.text$mn:00000A1E                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000A24                 mov     ecx, [ebp+var_C]
.text$mn:00000A27                 sub     ecx, [ebp+lParam]
.text$mn:00000A2A                 add     ecx, [ebp+var_1C]
.text$mn:00000A2D                 mov     [ebp+var_1C], ecx
.text$mn:00000A30                 jmp     short loc_9F3
.text$mn:00000A32 ; ---------------------------------------------------------------------------
.text$mn:00000A32
.text$mn:00000A32 loc_A32:                                ; CODE XREF: ToolBar::getWidth(void)+38j
.text$mn:00000A32                 mov     eax, [ebp+var_1C]
.text$mn:00000A35                 mov     ecx, [ebp+var_4]
.text$mn:00000A38                 xor     ecx, ebp
.text$mn:00000A3A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000A3F                 mov     esp, ebp
.text$mn:00000A41                 pop     ebp
.text$mn:00000A42                 retn
.text$mn:00000A42 ?getWidth@ToolBar@@UBEHXZ endp
.text$mn:00000A42
.text$mn:00000A42 ; ---------------------------------------------------------------------------
.text$mn:00000A43                 align 10h
.text$mn:00000A50
.text$mn:00000A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A50
.text$mn:00000A50 ; Attributes: bp-based frame
.text$mn:00000A50
.text$mn:00000A50 ; int __thiscall ToolBar::getHeight(ToolBar *__hidden this)
.text$mn:00000A50                 public ?getHeight@ToolBar@@UBEHXZ
.text$mn:00000A50 ?getHeight@ToolBar@@UBEHXZ proc near
.text$mn:00000A50
.text$mn:00000A50 var_10          = dword ptr -10h
.text$mn:00000A50 var_C           = dword ptr -0Ch
.text$mn:00000A50 var_8           = dword ptr -8
.text$mn:00000A50 var_4           = dword ptr -4
.text$mn:00000A50
.text$mn:00000A50                 push    ebp
.text$mn:00000A51                 mov     ebp, esp
.text$mn:00000A53                 sub     esp, 10h
.text$mn:00000A56                 mov     [ebp+var_4], ecx
.text$mn:00000A59                 push    0               ; lParam
.text$mn:00000A5B                 push    0               ; wParam
.text$mn:00000A5D                 push    43Ah            ; Msg
.text$mn:00000A62                 mov     eax, [ebp+var_4]
.text$mn:00000A65                 mov     ecx, [eax+0Ch]
.text$mn:00000A68                 push    ecx             ; hWnd
.text$mn:00000A69                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000A6F                 mov     [ebp+var_8], eax
.text$mn:00000A72                 push    0               ; lParam
.text$mn:00000A74                 push    0               ; wParam
.text$mn:00000A76                 push    456h            ; Msg
.text$mn:00000A7B                 mov     edx, [ebp+var_4]
.text$mn:00000A7E                 mov     eax, [edx+0Ch]
.text$mn:00000A81                 push    eax             ; hWnd
.text$mn:00000A82                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000A88                 mov     [ebp+var_C], eax
.text$mn:00000A8B                 mov     ecx, [ebp+var_8]
.text$mn:00000A8E                 shr     ecx, 10h
.text$mn:00000A91                 and     ecx, 0FFFFh
.text$mn:00000A97                 movzx   edx, cx
.text$mn:00000A9A                 mov     eax, [ebp+var_C]
.text$mn:00000A9D                 shr     eax, 10h
.text$mn:00000AA0                 and     eax, 0FFFFh
.text$mn:00000AA5                 movzx   ecx, ax
.text$mn:00000AA8                 add     edx, ecx
.text$mn:00000AAA                 mov     [ebp+var_10], edx
.text$mn:00000AAD                 mov     eax, [ebp+var_10]
.text$mn:00000AB0                 mov     esp, ebp
.text$mn:00000AB2                 pop     ebp
.text$mn:00000AB3                 retn
.text$mn:00000AB3 ?getHeight@ToolBar@@UBEHXZ endp
.text$mn:00000AB3
.text$mn:00000AB3 ; ---------------------------------------------------------------------------
.text$mn:00000AB4                 align 10h
.text$mn:00000AC0
.text$mn:00000AC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AC0
.text$mn:00000AC0 ; Attributes: bp-based frame
.text$mn:00000AC0
.text$mn:00000AC0 ; void __thiscall ToolBar::reduce(ToolBar *__hidden this)
.text$mn:00000AC0                 public ?reduce@ToolBar@@QAEXXZ
.text$mn:00000AC0 ?reduce@ToolBar@@QAEXXZ proc near
.text$mn:00000AC0
.text$mn:00000AC0 var_10          = dword ptr -10h
.text$mn:00000AC0 var_C           = dword ptr -0Ch
.text$mn:00000AC0 var_8           = dword ptr -8
.text$mn:00000AC0 var_1           = byte ptr -1
.text$mn:00000AC0
.text$mn:00000AC0                 push    ebp
.text$mn:00000AC1                 mov     ebp, esp
.text$mn:00000AC3                 sub     esp, 10h
.text$mn:00000AC6                 mov     [ebp+var_8], ecx
.text$mn:00000AC9                 mov     eax, [ebp+var_8]
.text$mn:00000ACC                 cmp     dword ptr [eax+0ECh], 0
.text$mn:00000AD3                 jnz     short loc_AD7
.text$mn:00000AD5                 jmp     short loc_B3D
.text$mn:00000AD7 ; ---------------------------------------------------------------------------
.text$mn:00000AD7
.text$mn:00000AD7 loc_AD7:                                ; CODE XREF: ToolBar::reduce(void)+13j
.text$mn:00000AD7                 push    10h             ; int
.text$mn:00000AD9                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000ADE                 add     eax, 0Ch
.text$mn:00000AE1                 mov     ecx, eax        ; this
.text$mn:00000AE3                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:00000AE8                 mov     [ebp+var_10], eax
.text$mn:00000AEB                 mov     ecx, [ebp+var_10]
.text$mn:00000AEE                 push    ecx             ; int
.text$mn:00000AEF                 mov     ecx, [ebp+var_8]
.text$mn:00000AF2                 add     ecx, 14h        ; this
.text$mn:00000AF5                 call    ?resizeIcon@ToolBarIcons@@QAEXH@Z ; ToolBarIcons::resizeIcon(int)
.text$mn:00000AFA                 mov     edx, [ebp+var_8]
.text$mn:00000AFD                 cmp     dword ptr [edx+0ECh], 2
.text$mn:00000B04                 jnz     short loc_B0F
.text$mn:00000B06                 mov     [ebp+var_C], 1
.text$mn:00000B0D                 jmp     short loc_B16
.text$mn:00000B0F ; ---------------------------------------------------------------------------
.text$mn:00000B0F
.text$mn:00000B0F loc_B0F:                                ; CODE XREF: ToolBar::reduce(void)+44j
.text$mn:00000B0F                 mov     [ebp+var_C], 0
.text$mn:00000B16
.text$mn:00000B16 loc_B16:                                ; CODE XREF: ToolBar::reduce(void)+4Dj
.text$mn:00000B16                 mov     al, byte ptr [ebp+var_C]
.text$mn:00000B19                 mov     [ebp+var_1], al
.text$mn:00000B1C                 push    0
.text$mn:00000B1E                 mov     ecx, [ebp+var_8]
.text$mn:00000B21                 call    ?setState@ToolBar@@AAEXW4toolBarStatusType@@@Z ; ToolBar::setState(toolBarStatusType)
.text$mn:00000B26                 movzx   ecx, [ebp+var_1]
.text$mn:00000B2A                 push    ecx             ; bool
.text$mn:00000B2B                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000B2E                 call    ?reset@ToolBar@@AAEX_N@Z ; ToolBar::reset(bool)
.text$mn:00000B33                 push    0               ; bool
.text$mn:00000B35                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000B38                 call    ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.text$mn:00000B3D
.text$mn:00000B3D loc_B3D:                                ; CODE XREF: ToolBar::reduce(void)+15j
.text$mn:00000B3D                 mov     esp, ebp
.text$mn:00000B3F                 pop     ebp
.text$mn:00000B40                 retn
.text$mn:00000B40 ?reduce@ToolBar@@QAEXXZ endp
.text$mn:00000B40
.text$mn:00000B40 ; ---------------------------------------------------------------------------
.text$mn:00000B41                 align 10h
.text$mn:00000B50
.text$mn:00000B50 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B50
.text$mn:00000B50 ; Attributes: bp-based frame
.text$mn:00000B50
.text$mn:00000B50 ; void __thiscall ToolBar::enlarge(ToolBar *__hidden this)
.text$mn:00000B50                 public ?enlarge@ToolBar@@QAEXXZ
.text$mn:00000B50 ?enlarge@ToolBar@@QAEXXZ proc near
.text$mn:00000B50
.text$mn:00000B50 var_10          = dword ptr -10h
.text$mn:00000B50 var_C           = dword ptr -0Ch
.text$mn:00000B50 var_8           = dword ptr -8
.text$mn:00000B50 var_1           = byte ptr -1
.text$mn:00000B50
.text$mn:00000B50                 push    ebp
.text$mn:00000B51                 mov     ebp, esp
.text$mn:00000B53                 sub     esp, 10h
.text$mn:00000B56                 mov     [ebp+var_8], ecx
.text$mn:00000B59                 mov     eax, [ebp+var_8]
.text$mn:00000B5C                 cmp     dword ptr [eax+0ECh], 1
.text$mn:00000B63                 jnz     short loc_B67
.text$mn:00000B65                 jmp     short loc_BCD
.text$mn:00000B67 ; ---------------------------------------------------------------------------
.text$mn:00000B67
.text$mn:00000B67 loc_B67:                                ; CODE XREF: ToolBar::enlarge(void)+13j
.text$mn:00000B67                 push    20h ; ' '       ; int
.text$mn:00000B69                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000B6E                 add     eax, 0Ch
.text$mn:00000B71                 mov     ecx, eax        ; this
.text$mn:00000B73                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:00000B78                 mov     [ebp+var_10], eax
.text$mn:00000B7B                 mov     ecx, [ebp+var_10]
.text$mn:00000B7E                 push    ecx             ; int
.text$mn:00000B7F                 mov     ecx, [ebp+var_8]
.text$mn:00000B82                 add     ecx, 14h        ; this
.text$mn:00000B85                 call    ?resizeIcon@ToolBarIcons@@QAEXH@Z ; ToolBarIcons::resizeIcon(int)
.text$mn:00000B8A                 mov     edx, [ebp+var_8]
.text$mn:00000B8D                 cmp     dword ptr [edx+0ECh], 2
.text$mn:00000B94                 jnz     short loc_B9F
.text$mn:00000B96                 mov     [ebp+var_C], 1
.text$mn:00000B9D                 jmp     short loc_BA6
.text$mn:00000B9F ; ---------------------------------------------------------------------------
.text$mn:00000B9F
.text$mn:00000B9F loc_B9F:                                ; CODE XREF: ToolBar::enlarge(void)+44j
.text$mn:00000B9F                 mov     [ebp+var_C], 0
.text$mn:00000BA6
.text$mn:00000BA6 loc_BA6:                                ; CODE XREF: ToolBar::enlarge(void)+4Dj
.text$mn:00000BA6                 mov     al, byte ptr [ebp+var_C]
.text$mn:00000BA9                 mov     [ebp+var_1], al
.text$mn:00000BAC                 push    1
.text$mn:00000BAE                 mov     ecx, [ebp+var_8]
.text$mn:00000BB1                 call    ?setState@ToolBar@@AAEXW4toolBarStatusType@@@Z ; ToolBar::setState(toolBarStatusType)
.text$mn:00000BB6                 movzx   ecx, [ebp+var_1]
.text$mn:00000BBA                 push    ecx             ; bool
.text$mn:00000BBB                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000BBE                 call    ?reset@ToolBar@@AAEX_N@Z ; ToolBar::reset(bool)
.text$mn:00000BC3                 push    0               ; bool
.text$mn:00000BC5                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000BC8                 call    ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.text$mn:00000BCD
.text$mn:00000BCD loc_BCD:                                ; CODE XREF: ToolBar::enlarge(void)+15j
.text$mn:00000BCD                 mov     esp, ebp
.text$mn:00000BCF                 pop     ebp
.text$mn:00000BD0                 retn
.text$mn:00000BD0 ?enlarge@ToolBar@@QAEXXZ endp
.text$mn:00000BD0
.text$mn:00000BD0 ; ---------------------------------------------------------------------------
.text$mn:00000BD1                 align 10h
.text$mn:00000BE0
.text$mn:00000BE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BE0
.text$mn:00000BE0 ; Attributes: bp-based frame
.text$mn:00000BE0
.text$mn:00000BE0 ; void __thiscall ToolBar::setToUglyIcons(ToolBar *__hidden this)
.text$mn:00000BE0                 public ?setToUglyIcons@ToolBar@@QAEXXZ
.text$mn:00000BE0 ?setToUglyIcons@ToolBar@@QAEXXZ proc near
.text$mn:00000BE0
.text$mn:00000BE0 var_8           = dword ptr -8
.text$mn:00000BE0 var_1           = byte ptr -1
.text$mn:00000BE0
.text$mn:00000BE0                 push    ebp
.text$mn:00000BE1                 mov     ebp, esp
.text$mn:00000BE3                 sub     esp, 8
.text$mn:00000BE6                 mov     [ebp+var_8], ecx
.text$mn:00000BE9                 mov     eax, [ebp+var_8]
.text$mn:00000BEC                 cmp     dword ptr [eax+0ECh], 2
.text$mn:00000BF3                 jnz     short loc_BF7
.text$mn:00000BF5                 jmp     short loc_C1C
.text$mn:00000BF7 ; ---------------------------------------------------------------------------
.text$mn:00000BF7
.text$mn:00000BF7 loc_BF7:                                ; CODE XREF: ToolBar::setToUglyIcons(void)+13j
.text$mn:00000BF7                 mov     [ebp+var_1], 1
.text$mn:00000BFB                 push    2
.text$mn:00000BFD                 mov     ecx, [ebp+var_8]
.text$mn:00000C00                 call    ?setState@ToolBar@@AAEXW4toolBarStatusType@@@Z ; ToolBar::setState(toolBarStatusType)
.text$mn:00000C05                 movzx   ecx, [ebp+var_1]
.text$mn:00000C09                 push    ecx             ; bool
.text$mn:00000C0A                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000C0D                 call    ?reset@ToolBar@@AAEX_N@Z ; ToolBar::reset(bool)
.text$mn:00000C12                 push    0               ; bool
.text$mn:00000C14                 mov     ecx, [ebp+var_8] ; this
.text$mn:00000C17                 call    ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.text$mn:00000C1C
.text$mn:00000C1C loc_C1C:                                ; CODE XREF: ToolBar::setToUglyIcons(void)+15j
.text$mn:00000C1C                 mov     esp, ebp
.text$mn:00000C1E                 pop     ebp
.text$mn:00000C1F                 retn
.text$mn:00000C1F ?setToUglyIcons@ToolBar@@QAEXXZ endp
.text$mn:00000C1F
.text$mn:00000C20
.text$mn:00000C20 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C20
.text$mn:00000C20 ; Attributes: bp-based frame
.text$mn:00000C20
.text$mn:00000C20 ; void __thiscall ToolBar::registerDynBtn(ToolBar *this, unsigned int, struct toolbarIcons *)
.text$mn:00000C20                 public ?registerDynBtn@ToolBar@@QAEXIPAUtoolbarIcons@@@Z
.text$mn:00000C20 ?registerDynBtn@ToolBar@@QAEXIPAUtoolbarIcons@@@Z proc near
.text$mn:00000C20
.text$mn:00000C20 var_10          = dword ptr -10h
.text$mn:00000C20 var_C           = dword ptr -0Ch
.text$mn:00000C20 var_8           = dword ptr -8
.text$mn:00000C20 var_4           = dword ptr -4
.text$mn:00000C20 arg_0           = dword ptr  8
.text$mn:00000C20 arg_4           = dword ptr  0Ch
.text$mn:00000C20
.text$mn:00000C20                 push    ebp
.text$mn:00000C21                 mov     ebp, esp
.text$mn:00000C23                 sub     esp, 10h
.text$mn:00000C26                 mov     [ebp+var_4], ecx
.text$mn:00000C29                 mov     eax, [ebp+var_4]
.text$mn:00000C2C                 cmp     dword ptr [eax+0Ch], 0
.text$mn:00000C30                 jnz     short loc_C69
.text$mn:00000C32                 cmp     [ebp+arg_0], 0
.text$mn:00000C36                 jz      short loc_C69
.text$mn:00000C38                 mov     ecx, [ebp+arg_4]
.text$mn:00000C3B                 cmp     dword ptr [ecx], 0
.text$mn:00000C3E                 jz      short loc_C69
.text$mn:00000C40                 mov     edx, [ebp+arg_0]
.text$mn:00000C43                 mov     [ebp+var_10], edx
.text$mn:00000C46                 mov     eax, [ebp+arg_4]
.text$mn:00000C49                 mov     ecx, [eax]
.text$mn:00000C4B                 mov     [ebp+var_C], ecx
.text$mn:00000C4E                 mov     edx, [ebp+arg_4]
.text$mn:00000C51                 mov     eax, [edx+4]
.text$mn:00000C54                 mov     [ebp+var_8], eax
.text$mn:00000C57                 lea     ecx, [ebp+var_10]
.text$mn:00000C5A                 push    ecx
.text$mn:00000C5B                 mov     ecx, [ebp+var_4]
.text$mn:00000C5E                 add     ecx, 0F0h ; '='
.text$mn:00000C64                 call    ?push_back@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QAEXABUtDynamicList@@@Z ; std::vector<tDynamicList,std::allocator<tDynamicList>>::push_back(tDynamicList const &)
.text$mn:00000C69
.text$mn:00000C69 loc_C69:                                ; CODE XREF: ToolBar::registerDynBtn(uint,toolbarIcons *)+10j
.text$mn:00000C69                                         ; ToolBar::registerDynBtn(uint,toolbarIcons *)+16j ...
.text$mn:00000C69                 mov     esp, ebp
.text$mn:00000C6B                 pop     ebp
.text$mn:00000C6C                 retn    8
.text$mn:00000C6C ?registerDynBtn@ToolBar@@QAEXIPAUtoolbarIcons@@@Z endp
.text$mn:00000C6C
.text$mn:00000C6C ; ---------------------------------------------------------------------------
.text$mn:00000C6F                 align 10h
.text$mn:00000C70
.text$mn:00000C70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C70
.text$mn:00000C70 ; Attributes: bp-based frame
.text$mn:00000C70
.text$mn:00000C70 ; void __thiscall ToolBar::doPopop(ToolBar *this, struct tagPOINT x)
.text$mn:00000C70                 public ?doPopop@ToolBar@@QAEXUtagPOINT@@@Z
.text$mn:00000C70 ?doPopop@ToolBar@@QAEXUtagPOINT@@@Z proc near
.text$mn:00000C70
.text$mn:00000C70 var_50          = dword ptr -50h
.text$mn:00000C70 uIDNewItem      = dword ptr -4Ch
.text$mn:00000C70 hMenu           = dword ptr -48h
.text$mn:00000C70 var_44          = dword ptr -44h
.text$mn:00000C70 wParam          = dword ptr -40h
.text$mn:00000C70 var_3C          = byte ptr -3Ch
.text$mn:00000C70 lParam          = dword ptr -20h
.text$mn:00000C70 var_1C          = dword ptr -1Ch
.text$mn:00000C70 var_18          = dword ptr -18h
.text$mn:00000C70 var_14          = dword ptr -14h
.text$mn:00000C70 var_10          = dword ptr -10h
.text$mn:00000C70 var_C           = dword ptr -0Ch
.text$mn:00000C70 var_4           = dword ptr -4
.text$mn:00000C70 x               = tagPOINT ptr  8
.text$mn:00000C70
.text$mn:00000C70                 push    ebp
.text$mn:00000C71                 mov     ebp, esp
.text$mn:00000C73                 push    0FFFFFFFFh
.text$mn:00000C75                 push    offset __ehhandler$?doPopop@ToolBar@@QAEXUtagPOINT@@@Z
.text$mn:00000C7A                 mov     eax, large fs:0
.text$mn:00000C80                 push    eax
.text$mn:00000C81                 sub     esp, 44h
.text$mn:00000C84                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C89                 xor     eax, ebp
.text$mn:00000C8B                 mov     [ebp+var_10], eax
.text$mn:00000C8E                 push    eax
.text$mn:00000C8F                 lea     eax, [ebp+var_C]
.text$mn:00000C92                 mov     large fs:0, eax
.text$mn:00000C98                 mov     [ebp+var_44], ecx
.text$mn:00000C9B                 mov     ecx, [ebp+var_44] ; this
.text$mn:00000C9E                 call    ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.text$mn:00000CA3                 mov     [ebp+var_50], eax
.text$mn:00000CA6                 mov     [ebp+wParam], 0
.text$mn:00000CAD                 mov     [ebp+lParam], 0
.text$mn:00000CB4                 mov     [ebp+var_1C], 0
.text$mn:00000CBB                 mov     [ebp+var_18], 0
.text$mn:00000CC2                 mov     [ebp+var_14], 0
.text$mn:00000CC9
.text$mn:00000CC9 loc_CC9:                                ; CODE XREF: ToolBar::doPopop(tagPOINT)+94j
.text$mn:00000CC9                 mov     eax, [ebp+var_44]
.text$mn:00000CCC                 mov     ecx, [ebp+wParam]
.text$mn:00000CCF                 cmp     ecx, [eax+10Ch]
.text$mn:00000CD5                 jnb     short loc_D06
.text$mn:00000CD7                 lea     edx, [ebp+lParam]
.text$mn:00000CDA                 push    edx             ; lParam
.text$mn:00000CDB                 mov     eax, [ebp+wParam]
.text$mn:00000CDE                 push    eax             ; wParam
.text$mn:00000CDF                 push    41Dh            ; Msg
.text$mn:00000CE4                 mov     ecx, [ebp+var_44]
.text$mn:00000CE7                 mov     edx, [ecx+0Ch]
.text$mn:00000CEA                 push    edx             ; hWnd
.text$mn:00000CEB                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000CF1                 mov     eax, [ebp+var_18]
.text$mn:00000CF4                 cmp     eax, [ebp+var_50]
.text$mn:00000CF7                 jle     short loc_CFB
.text$mn:00000CF9                 jmp     short loc_D06
.text$mn:00000CFB ; ---------------------------------------------------------------------------
.text$mn:00000CFB
.text$mn:00000CFB loc_CFB:                                ; CODE XREF: ToolBar::doPopop(tagPOINT)+87j
.text$mn:00000CFB                 mov     ecx, [ebp+wParam]
.text$mn:00000CFE                 add     ecx, 1
.text$mn:00000D01                 mov     [ebp+wParam], ecx
.text$mn:00000D04                 jmp     short loc_CC9
.text$mn:00000D06 ; ---------------------------------------------------------------------------
.text$mn:00000D06
.text$mn:00000D06 loc_D06:                                ; CODE XREF: ToolBar::doPopop(tagPOINT)+65j
.text$mn:00000D06                                         ; ToolBar::doPopop(tagPOINT)+89j
.text$mn:00000D06                 mov     edx, [ebp+var_44]
.text$mn:00000D09                 mov     eax, [ebp+wParam]
.text$mn:00000D0C                 cmp     eax, [edx+10Ch]
.text$mn:00000D12                 jnb     loc_E18
.text$mn:00000D18                 call    dword ptr ds:__imp__CreatePopupMenu@0 ; CreatePopupMenu()
.text$mn:00000D1E                 mov     [ebp+hMenu], eax
.text$mn:00000D21                 lea     ecx, [ebp+var_3C]
.text$mn:00000D24                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00000D29                 mov     [ebp+var_4], 0
.text$mn:00000D30
.text$mn:00000D30 loc_D30:                                ; CODE XREF: ToolBar::doPopop(tagPOINT)+175j
.text$mn:00000D30                 mov     ecx, [ebp+var_44]
.text$mn:00000D33                 mov     edx, [ebp+wParam]
.text$mn:00000D36                 cmp     edx, [ecx+10Ch]
.text$mn:00000D3C                 jnb     loc_DEA
.text$mn:00000D42                 imul    eax, [ebp+wParam], 14h
.text$mn:00000D46                 mov     ecx, [ebp+var_44]
.text$mn:00000D49                 mov     edx, [ecx+10h]
.text$mn:00000D4C                 mov     eax, [edx+eax+4]
.text$mn:00000D50                 mov     [ebp+uIDNewItem], eax
.text$mn:00000D53                 lea     ecx, [ebp+var_3C]
.text$mn:00000D56                 push    ecx
.text$mn:00000D57                 mov     edx, [ebp+uIDNewItem]
.text$mn:00000D5A                 push    edx
.text$mn:00000D5B                 call    ?getNameStrFromCmd@@YAXKAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; getNameStrFromCmd(ulong,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00000D60                 add     esp, 8
.text$mn:00000D63                 imul    eax, [ebp+wParam], 14h
.text$mn:00000D67                 mov     ecx, [ebp+var_44]
.text$mn:00000D6A                 mov     edx, [ecx+10h]
.text$mn:00000D6D                 cmp     dword ptr [edx+eax+4], 0
.text$mn:00000D72                 jz      short loc_DC6
.text$mn:00000D74                 push    0               ; lParam
.text$mn:00000D76                 mov     eax, [ebp+uIDNewItem]
.text$mn:00000D79                 push    eax             ; wParam
.text$mn:00000D7A                 push    409h            ; Msg
.text$mn:00000D7F                 mov     ecx, [ebp+var_44]
.text$mn:00000D82                 mov     edx, [ecx+0Ch]
.text$mn:00000D85                 push    edx             ; hWnd
.text$mn:00000D86                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000D8C                 test    eax, eax
.text$mn:00000D8E                 jz      short loc_DAB
.text$mn:00000D90                 lea     ecx, [ebp+var_3C]
.text$mn:00000D93                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000D98                 push    eax             ; lpNewItem
.text$mn:00000D99                 mov     eax, [ebp+uIDNewItem]
.text$mn:00000D9C                 push    eax             ; uIDNewItem
.text$mn:00000D9D                 push    0               ; uFlags
.text$mn:00000D9F                 mov     ecx, [ebp+hMenu]
.text$mn:00000DA2                 push    ecx             ; hMenu
.text$mn:00000DA3                 call    dword ptr ds:__imp__AppendMenuW@16 ; AppendMenuW(x,x,x,x)
.text$mn:00000DA9                 jmp     short loc_DC4
.text$mn:00000DAB ; ---------------------------------------------------------------------------
.text$mn:00000DAB
.text$mn:00000DAB loc_DAB:                                ; CODE XREF: ToolBar::doPopop(tagPOINT)+11Ej
.text$mn:00000DAB                 lea     ecx, [ebp+var_3C]
.text$mn:00000DAE                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00000DB3                 push    eax             ; lpNewItem
.text$mn:00000DB4                 mov     edx, [ebp+uIDNewItem]
.text$mn:00000DB7                 push    edx             ; uIDNewItem
.text$mn:00000DB8                 push    3               ; uFlags
.text$mn:00000DBA                 mov     eax, [ebp+hMenu]
.text$mn:00000DBD                 push    eax             ; hMenu
.text$mn:00000DBE                 call    dword ptr ds:__imp__AppendMenuW@16 ; AppendMenuW(x,x,x,x)
.text$mn:00000DC4
.text$mn:00000DC4 loc_DC4:                                ; CODE XREF: ToolBar::doPopop(tagPOINT)+139j
.text$mn:00000DC4                 jmp     short loc_DDC
.text$mn:00000DC6 ; ---------------------------------------------------------------------------
.text$mn:00000DC6
.text$mn:00000DC6 loc_DC6:                                ; CODE XREF: ToolBar::doPopop(tagPOINT)+102j
.text$mn:00000DC6                 push    offset $SG123254 ; lpNewItem
.text$mn:00000DCB                 push    0               ; uIDNewItem
.text$mn:00000DCD                 push    800h            ; uFlags
.text$mn:00000DD2                 mov     ecx, [ebp+hMenu]
.text$mn:00000DD5                 push    ecx             ; hMenu
.text$mn:00000DD6                 call    dword ptr ds:__imp__AppendMenuW@16 ; AppendMenuW(x,x,x,x)
.text$mn:00000DDC
.text$mn:00000DDC loc_DDC:                                ; CODE XREF: ToolBar::doPopop(tagPOINT):loc_DC4j
.text$mn:00000DDC                 mov     edx, [ebp+wParam]
.text$mn:00000DDF                 add     edx, 1
.text$mn:00000DE2                 mov     [ebp+wParam], edx
.text$mn:00000DE5                 jmp     loc_D30
.text$mn:00000DEA ; ---------------------------------------------------------------------------
.text$mn:00000DEA
.text$mn:00000DEA loc_DEA:                                ; CODE XREF: ToolBar::doPopop(tagPOINT)+CCj
.text$mn:00000DEA                 push    0               ; prcRect
.text$mn:00000DEC                 mov     eax, [ebp+var_44]
.text$mn:00000DEF                 mov     ecx, [eax+0Ch]
.text$mn:00000DF2                 push    ecx             ; hWnd
.text$mn:00000DF3                 push    0               ; nReserved
.text$mn:00000DF5                 mov     edx, [ebp+x.y]
.text$mn:00000DF8                 push    edx             ; y
.text$mn:00000DF9                 mov     eax, [ebp+x.x]
.text$mn:00000DFC                 push    eax             ; x
.text$mn:00000DFD                 push    0               ; uFlags
.text$mn:00000DFF                 mov     ecx, [ebp+hMenu]
.text$mn:00000E02                 push    ecx             ; hMenu
.text$mn:00000E03                 call    dword ptr ds:__imp__TrackPopupMenu@28 ; TrackPopupMenu(x,x,x,x,x,x,x)
.text$mn:00000E09                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E10                 lea     ecx, [ebp+var_3C]
.text$mn:00000E13                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00000E18
.text$mn:00000E18 loc_E18:                                ; CODE XREF: ToolBar::doPopop(tagPOINT)+A2j
.text$mn:00000E18                 mov     ecx, [ebp+var_C]
.text$mn:00000E1B                 mov     large fs:0, ecx
.text$mn:00000E22                 pop     ecx
.text$mn:00000E23                 mov     ecx, [ebp+var_10]
.text$mn:00000E26                 xor     ecx, ebp
.text$mn:00000E28                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000E2D                 mov     esp, ebp
.text$mn:00000E2F                 pop     ebp
.text$mn:00000E30                 retn    8
.text$mn:00000E30 ?doPopop@ToolBar@@QAEXUtagPOINT@@@Z endp
.text$mn:00000E30
.text$mn:00000E30 ; ---------------------------------------------------------------------------
.text$mn:00000E33                 align 10h
.text$mn:00000E40
.text$mn:00000E40 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E40
.text$mn:00000E40 ; Attributes: bp-based frame
.text$mn:00000E40
.text$mn:00000E40 ; void __thiscall ToolBar::addToRebar(ToolBar *this, struct ReBar *)
.text$mn:00000E40                 public ?addToRebar@ToolBar@@QAEXPAVReBar@@@Z
.text$mn:00000E40 ?addToRebar@ToolBar@@QAEXPAVReBar@@@Z proc near
.text$mn:00000E40
.text$mn:00000E40 var_C           = dword ptr -0Ch
.text$mn:00000E40 var_8           = dword ptr -8
.text$mn:00000E40 var_4           = dword ptr -4
.text$mn:00000E40 arg_0           = dword ptr  8
.text$mn:00000E40
.text$mn:00000E40                 push    ebp
.text$mn:00000E41                 mov     ebp, esp
.text$mn:00000E43                 sub     esp, 0Ch
.text$mn:00000E46                 mov     [ebp+var_4], ecx
.text$mn:00000E49                 mov     eax, [ebp+var_4]
.text$mn:00000E4C                 cmp     dword ptr [eax+110h], 0
.text$mn:00000E53                 jz      short loc_E5A
.text$mn:00000E55                 jmp     loc_F51
.text$mn:00000E5A ; ---------------------------------------------------------------------------
.text$mn:00000E5A
.text$mn:00000E5A loc_E5A:                                ; CODE XREF: ToolBar::addToRebar(ReBar *)+13j
.text$mn:00000E5A                 mov     ecx, [ebp+var_4]
.text$mn:00000E5D                 mov     edx, [ebp+arg_0]
.text$mn:00000E60                 mov     [ecx+110h], edx
.text$mn:00000E66                 push    38h ; '8'       ; Size
.text$mn:00000E68                 push    0               ; Val
.text$mn:00000E6A                 mov     eax, [ebp+var_4]
.text$mn:00000E6D                 add     eax, 114h
.text$mn:00000E72                 push    eax             ; Dst
.text$mn:00000E73                 call    _memset
.text$mn:00000E78                 add     esp, 0Ch
.text$mn:00000E7B                 mov     ecx, [ebp+var_4]
.text$mn:00000E7E                 mov     dword ptr [ecx+114h], 38h ; '8'
.text$mn:00000E88                 mov     edx, [ebp+var_4]
.text$mn:00000E8B                 mov     dword ptr [edx+118h], 371h
.text$mn:00000E95                 mov     eax, [ebp+var_4]
.text$mn:00000E98                 mov     dword ptr [eax+11Ch], 240h
.text$mn:00000EA2                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000EA5                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00000EAA                 mov     ecx, [ebp+var_4]
.text$mn:00000EAD                 mov     [ecx+134h], eax
.text$mn:00000EB3                 mov     edx, [ebp+var_4]
.text$mn:00000EB6                 mov     dword ptr [edx+148h], 0
.text$mn:00000EC0                 mov     eax, [ebp+var_4]
.text$mn:00000EC3                 mov     dword ptr [eax+138h], 0
.text$mn:00000ECD                 mov     ecx, [ebp+var_4]
.text$mn:00000ED0                 mov     dword ptr [ecx+154h], 1
.text$mn:00000EDA                 mov     edx, [ebp+var_4]
.text$mn:00000EDD                 mov     eax, [edx]
.text$mn:00000EDF                 mov     ecx, [ebp+var_4]
.text$mn:00000EE2                 mov     edx, [eax+28h]
.text$mn:00000EE5                 call    edx
.text$mn:00000EE7                 mov     [ebp+var_8], eax
.text$mn:00000EEA                 mov     eax, [ebp+var_4]
.text$mn:00000EED                 mov     ecx, [ebp+var_8]
.text$mn:00000EF0                 mov     [eax+150h], ecx
.text$mn:00000EF6                 mov     edx, [ebp+var_4]
.text$mn:00000EF9                 mov     eax, [ebp+var_8]
.text$mn:00000EFC                 mov     [edx+13Ch], eax
.text$mn:00000F02                 mov     ecx, [ebp+var_4]
.text$mn:00000F05                 mov     edx, [ecx]
.text$mn:00000F07                 mov     ecx, [ebp+var_4]
.text$mn:00000F0A                 mov     eax, [edx+24h]
.text$mn:00000F0D                 call    eax
.text$mn:00000F0F                 mov     [ebp+var_C], eax
.text$mn:00000F12                 mov     ecx, [ebp+var_4]
.text$mn:00000F15                 mov     edx, [ebp+var_C]
.text$mn:00000F18                 mov     [ecx+140h], edx
.text$mn:00000F1E                 mov     eax, [ebp+var_4]
.text$mn:00000F21                 mov     ecx, [ebp+var_C]
.text$mn:00000F24                 mov     [eax+158h], ecx
.text$mn:00000F2A                 push    1               ; bool
.text$mn:00000F2C                 mov     edx, [ebp+var_4]
.text$mn:00000F2F                 add     edx, 114h
.text$mn:00000F35                 push    edx             ; lParam
.text$mn:00000F36                 mov     eax, [ebp+var_4]
.text$mn:00000F39                 mov     ecx, [eax+110h] ; this
.text$mn:00000F3F                 call    ?addBand@ReBar@@QAE_NPAUtagREBARBANDINFOW@@_N@Z ; ReBar::addBand(tagREBARBANDINFOW *,bool)
.text$mn:00000F44                 mov     ecx, [ebp+var_4]
.text$mn:00000F47                 mov     dword ptr [ecx+118h], 270h
.text$mn:00000F51
.text$mn:00000F51 loc_F51:                                ; CODE XREF: ToolBar::addToRebar(ReBar *)+15j
.text$mn:00000F51                 mov     esp, ebp
.text$mn:00000F53                 pop     ebp
.text$mn:00000F54                 retn    4
.text$mn:00000F54 ?addToRebar@ToolBar@@QAEXPAVReBar@@@Z endp
.text$mn:00000F54
.text$mn:00000F54 ; ---------------------------------------------------------------------------
.text$mn:00000F57                 align 10h
.text$mn:00000F60
.text$mn:00000F60 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F60
.text$mn:00000F60 ; Attributes: bp-based frame
.text$mn:00000F60
.text$mn:00000F60 ; void __thiscall ToolBar::reset(ToolBar *this, bool)
.text$mn:00000F60                 public ?reset@ToolBar@@AAEX_N@Z
.text$mn:00000F60 ?reset@ToolBar@@AAEX_N@Z proc near      ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+337p
.text$mn:00000F60                                         ; ToolBar::reduce(void)+6Ep ...
.text$mn:00000F60
.text$mn:00000F60 var_60          = byte ptr -60h
.text$mn:00000F60 var_54          = dword ptr -54h
.text$mn:00000F60 var_50          = dword ptr -50h
.text$mn:00000F60 var_4C          = dword ptr -4Ch
.text$mn:00000F60 var_48          = dword ptr -48h
.text$mn:00000F60 var_44          = dword ptr -44h
.text$mn:00000F60 var_40          = dword ptr -40h
.text$mn:00000F60 var_3C          = dword ptr -3Ch
.text$mn:00000F60 var_38          = dword ptr -38h
.text$mn:00000F60 var_34          = dword ptr -34h
.text$mn:00000F60 var_30          = dword ptr -30h
.text$mn:00000F60 var_2C          = dword ptr -2Ch
.text$mn:00000F60 cy              = dword ptr -28h
.text$mn:00000F60 var_24          = word ptr -24h
.text$mn:00000F60 wParam          = dword ptr -20h
.text$mn:00000F60 var_1C          = dword ptr -1Ch
.text$mn:00000F60 lParam          = dword ptr -18h
.text$mn:00000F60 var_10          = byte ptr -10h
.text$mn:00000F60 var_4           = dword ptr -4
.text$mn:00000F60 arg_0           = byte ptr  8
.text$mn:00000F60
.text$mn:00000F60                 push    ebp
.text$mn:00000F61                 mov     ebp, esp
.text$mn:00000F63                 sub     esp, 60h
.text$mn:00000F66                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F6B                 xor     eax, ebp
.text$mn:00000F6D                 mov     [ebp+var_4], eax
.text$mn:00000F70                 mov     [ebp+var_1C], ecx
.text$mn:00000F73                 movzx   eax, [ebp+arg_0]
.text$mn:00000F77                 test    eax, eax
.text$mn:00000F79                 jz      short loc_FE8
.text$mn:00000F7B                 mov     ecx, [ebp+var_1C]
.text$mn:00000F7E                 cmp     dword ptr [ecx+0Ch], 0
.text$mn:00000F82                 jz      short loc_FE8
.text$mn:00000F84                 mov     [ebp+wParam], 0
.text$mn:00000F8B                 jmp     short loc_F96
.text$mn:00000F8D ; ---------------------------------------------------------------------------
.text$mn:00000F8D
.text$mn:00000F8D loc_F8D:                                ; CODE XREF: ToolBar::reset(bool)+6Fj
.text$mn:00000F8D                 mov     edx, [ebp+wParam]
.text$mn:00000F90                 add     edx, 1
.text$mn:00000F93                 mov     [ebp+wParam], edx
.text$mn:00000F96
.text$mn:00000F96 loc_F96:                                ; CODE XREF: ToolBar::reset(bool)+2Bj
.text$mn:00000F96                 mov     eax, [ebp+var_1C]
.text$mn:00000F99                 mov     ecx, [ebp+wParam]
.text$mn:00000F9C                 cmp     ecx, [eax+10Ch]
.text$mn:00000FA2                 jnb     short loc_FD1
.text$mn:00000FA4                 lea     edx, [ebp+lParam]
.text$mn:00000FA7                 push    edx             ; lParam
.text$mn:00000FA8                 mov     eax, [ebp+wParam]
.text$mn:00000FAB                 push    eax             ; wParam
.text$mn:00000FAC                 push    417h            ; Msg
.text$mn:00000FB1                 mov     ecx, [ebp+var_1C]
.text$mn:00000FB4                 mov     edx, [ecx+0Ch]
.text$mn:00000FB7                 push    edx             ; hWnd
.text$mn:00000FB8                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000FBE                 imul    eax, [ebp+wParam], 14h
.text$mn:00000FC2                 mov     ecx, [ebp+var_1C]
.text$mn:00000FC5                 mov     edx, [ecx+10h]
.text$mn:00000FC8                 mov     cl, [ebp+var_10]
.text$mn:00000FCB                 mov     [edx+eax+8], cl
.text$mn:00000FCF                 jmp     short loc_F8D
.text$mn:00000FD1 ; ---------------------------------------------------------------------------
.text$mn:00000FD1
.text$mn:00000FD1 loc_FD1:                                ; CODE XREF: ToolBar::reset(bool)+42j
.text$mn:00000FD1                 mov     edx, [ebp+var_1C]
.text$mn:00000FD4                 mov     eax, [edx+0Ch]
.text$mn:00000FD7                 push    eax             ; hWnd
.text$mn:00000FD8                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:00000FDE                 mov     ecx, [ebp+var_1C]
.text$mn:00000FE1                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00000FE8
.text$mn:00000FE8 loc_FE8:                                ; CODE XREF: ToolBar::reset(bool)+19j
.text$mn:00000FE8                                         ; ToolBar::reset(bool)+22j
.text$mn:00000FE8                 mov     edx, [ebp+var_1C]
.text$mn:00000FEB                 cmp     dword ptr [edx+0Ch], 0
.text$mn:00000FEF                 jnz     short loc_1057
.text$mn:00000FF1                 push    0               ; lpParam
.text$mn:00000FF3                 mov     eax, [ebp+var_1C]
.text$mn:00000FF6                 mov     ecx, [eax+4]
.text$mn:00000FF9                 push    ecx             ; hInstance
.text$mn:00000FFA                 push    0               ; hMenu
.text$mn:00000FFC                 mov     edx, [ebp+var_1C]
.text$mn:00000FFF                 mov     eax, [edx+8]
.text$mn:00001002                 push    eax             ; hWndParent
.text$mn:00001003                 push    0               ; nHeight
.text$mn:00001005                 push    0               ; nWidth
.text$mn:00001007                 push    0               ; Y
.text$mn:00001009                 push    0               ; X
.text$mn:0000100B                 push    5600095Dh       ; dwStyle
.text$mn:00001010                 push    offset $SG123170 ; lpWindowName
.text$mn:00001015                 push    offset $SG123171 ; "ToolbarWindow32"
.text$mn:0000101A                 push    188h            ; dwExStyle
.text$mn:0000101F                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:00001025                 mov     ecx, [ebp+var_1C]
.text$mn:00001028                 mov     [ecx+0Ch], eax
.text$mn:0000102B                 push    0               ; lParam
.text$mn:0000102D                 push    14h             ; wParam
.text$mn:0000102F                 push    41Eh            ; Msg
.text$mn:00001034                 mov     edx, [ebp+var_1C]
.text$mn:00001037                 mov     eax, [edx+0Ch]
.text$mn:0000103A                 push    eax             ; hWnd
.text$mn:0000103B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001041                 push    10h             ; lParam
.text$mn:00001043                 push    0               ; wParam
.text$mn:00001045                 push    454h            ; Msg
.text$mn:0000104A                 mov     ecx, [ebp+var_1C]
.text$mn:0000104D                 mov     edx, [ecx+0Ch]
.text$mn:00001050                 push    edx             ; hWnd
.text$mn:00001051                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001057
.text$mn:00001057 loc_1057:                               ; CODE XREF: ToolBar::reset(bool)+8Fj
.text$mn:00001057                 mov     eax, [ebp+var_1C]
.text$mn:0000105A                 cmp     dword ptr [eax+0Ch], 0
.text$mn:0000105E                 jnz     short loc_107B
.text$mn:00001060                 push    offset $SG123178 ; "ToolBar::reset : CreateWindowEx() funct"...
.text$mn:00001065                 lea     ecx, [ebp+var_60] ; this
.text$mn:00001068                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:0000106D                 push    offset __TI2?AVruntime_error@std@@
.text$mn:00001072                 lea     ecx, [ebp+var_60]
.text$mn:00001075                 push    ecx
.text$mn:00001076                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000107B ; ---------------------------------------------------------------------------
.text$mn:0000107B
.text$mn:0000107B loc_107B:                               ; CODE XREF: ToolBar::reset(bool)+FEj
.text$mn:0000107B                 mov     edx, [ebp+var_1C]
.text$mn:0000107E                 cmp     dword ptr [edx+0ECh], 2
.text$mn:00001085                 jz      short loc_10A4
.text$mn:00001087                 mov     ecx, [ebp+var_1C] ; this
.text$mn:0000108A                 call    ?setDefaultImageList@ToolBar@@AAEXXZ ; ToolBar::setDefaultImageList(void)
.text$mn:0000108F                 mov     ecx, [ebp+var_1C] ; this
.text$mn:00001092                 call    ?setHotImageList@ToolBar@@AAEXXZ ; ToolBar::setHotImageList(void)
.text$mn:00001097                 mov     ecx, [ebp+var_1C] ; this
.text$mn:0000109A                 call    ?setDisableImageList@ToolBar@@AAEXXZ ; ToolBar::setDisableImageList(void)
.text$mn:0000109F                 jmp     loc_11D5
.text$mn:000010A4 ; ---------------------------------------------------------------------------
.text$mn:000010A4
.text$mn:000010A4 loc_10A4:                               ; CODE XREF: ToolBar::reset(bool)+125j
.text$mn:000010A4                 push    10h             ; int
.text$mn:000010A6                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000010AB                 add     eax, 0Ch
.text$mn:000010AE                 mov     ecx, eax        ; this
.text$mn:000010B0                 call    ?scaleX@DPIManager@@QAEHH@Z ; DPIManager::scaleX(int)
.text$mn:000010B5                 mov     [ebp+cy], eax
.text$mn:000010B8                 mov     eax, [ebp+cy]
.text$mn:000010BB                 and     eax, 0FFFFh
.text$mn:000010C0                 movzx   ecx, ax
.text$mn:000010C3                 mov     edx, [ebp+cy]
.text$mn:000010C6                 and     edx, 0FFFFh
.text$mn:000010CC                 movzx   eax, dx
.text$mn:000010CF                 shl     eax, 10h
.text$mn:000010D2                 or      ecx, eax
.text$mn:000010D4                 push    ecx             ; lParam
.text$mn:000010D5                 push    0               ; wParam
.text$mn:000010D7                 push    420h            ; Msg
.text$mn:000010DC                 mov     ecx, [ebp+var_1C]
.text$mn:000010DF                 mov     edx, [ecx+0Ch]
.text$mn:000010E2                 push    edx             ; hWnd
.text$mn:000010E3                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000010E9                 mov     [ebp+var_48], 0
.text$mn:000010F0                 mov     [ebp+var_44], 0
.text$mn:000010F7                 mov     [ebp+var_54], 0
.text$mn:000010FE                 mov     [ebp+var_50], 0
.text$mn:00001105                 mov     [ebp+var_30], 0
.text$mn:0000110C                 jmp     short loc_1117
.text$mn:0000110E ; ---------------------------------------------------------------------------
.text$mn:0000110E
.text$mn:0000110E loc_110E:                               ; CODE XREF: ToolBar::reset(bool)+215j
.text$mn:0000110E                 mov     eax, [ebp+var_30]
.text$mn:00001111                 add     eax, 1
.text$mn:00001114                 mov     [ebp+var_30], eax
.text$mn:00001117
.text$mn:00001117 loc_1117:                               ; CODE XREF: ToolBar::reset(bool)+1ACj
.text$mn:00001117                 mov     ecx, [ebp+var_1C]
.text$mn:0000111A                 mov     edx, [ebp+var_30]
.text$mn:0000111D                 cmp     edx, [ecx+100h]
.text$mn:00001123                 jnb     short loc_1177
.text$mn:00001125                 push    1020h           ; fuLoad
.text$mn:0000112A                 mov     eax, [ebp+cy]
.text$mn:0000112D                 push    eax             ; cy
.text$mn:0000112E                 mov     ecx, [ebp+cy]
.text$mn:00001131                 push    ecx             ; cx
.text$mn:00001132                 push    0               ; type
.text$mn:00001134                 mov     edx, [ebp+var_30]
.text$mn:00001137                 push    edx             ; int
.text$mn:00001138                 mov     ecx, [ebp+var_1C]
.text$mn:0000113B                 add     ecx, 14h        ; this
.text$mn:0000113E                 call    ?getStdIconAt@ToolBarIcons@@QBEHH@Z ; ToolBarIcons::getStdIconAt(int)
.text$mn:00001143                 movzx   eax, ax
.text$mn:00001146                 push    eax             ; name
.text$mn:00001147                 mov     ecx, [ebp+var_1C]
.text$mn:0000114A                 mov     edx, [ecx+4]
.text$mn:0000114D                 push    edx             ; hInst
.text$mn:0000114E                 call    dword ptr ds:__imp__LoadImageW@24 ; LoadImageW(x,x,x,x,x,x)
.text$mn:00001154                 mov     [ebp+var_4C], eax
.text$mn:00001157                 mov     eax, [ebp+var_4C]
.text$mn:0000115A                 mov     [ebp+var_44], eax
.text$mn:0000115D                 lea     ecx, [ebp+var_48]
.text$mn:00001160                 push    ecx             ; lParam
.text$mn:00001161                 push    1               ; wParam
.text$mn:00001163                 push    413h            ; Msg
.text$mn:00001168                 mov     edx, [ebp+var_1C]
.text$mn:0000116B                 mov     eax, [edx+0Ch]
.text$mn:0000116E                 push    eax             ; hWnd
.text$mn:0000116F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001175                 jmp     short loc_110E
.text$mn:00001177 ; ---------------------------------------------------------------------------
.text$mn:00001177
.text$mn:00001177 loc_1177:                               ; CODE XREF: ToolBar::reset(bool)+1C3j
.text$mn:00001177                 mov     ecx, [ebp+var_1C]
.text$mn:0000117A                 cmp     dword ptr [ecx+104h], 0
.text$mn:00001181                 jbe     short loc_11D5
.text$mn:00001183                 mov     [ebp+var_2C], 0
.text$mn:0000118A                 jmp     short loc_1195
.text$mn:0000118C ; ---------------------------------------------------------------------------
.text$mn:0000118C
.text$mn:0000118C loc_118C:                               ; CODE XREF: ToolBar::reset(bool)+273j
.text$mn:0000118C                 mov     edx, [ebp+var_2C]
.text$mn:0000118F                 add     edx, 1
.text$mn:00001192                 mov     [ebp+var_2C], edx
.text$mn:00001195
.text$mn:00001195 loc_1195:                               ; CODE XREF: ToolBar::reset(bool)+22Aj
.text$mn:00001195                 mov     eax, [ebp+var_1C]
.text$mn:00001198                 mov     ecx, [ebp+var_2C]
.text$mn:0000119B                 cmp     ecx, [eax+104h]
.text$mn:000011A1                 jnb     short loc_11D5
.text$mn:000011A3                 mov     edx, [ebp+var_2C]
.text$mn:000011A6                 push    edx
.text$mn:000011A7                 mov     ecx, [ebp+var_1C]
.text$mn:000011AA                 add     ecx, 0F0h ; '='
.text$mn:000011B0                 call    ?at@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QAEAAUtDynamicList@@I@Z ; std::vector<tDynamicList,std::allocator<tDynamicList>>::at(uint)
.text$mn:000011B5                 mov     eax, [eax+4]
.text$mn:000011B8                 mov     [ebp+var_50], eax
.text$mn:000011BB                 lea     ecx, [ebp+var_54]
.text$mn:000011BE                 push    ecx             ; lParam
.text$mn:000011BF                 push    1               ; wParam
.text$mn:000011C1                 push    413h            ; Msg
.text$mn:000011C6                 mov     edx, [ebp+var_1C]
.text$mn:000011C9                 mov     eax, [edx+0Ch]
.text$mn:000011CC                 push    eax             ; hWnd
.text$mn:000011CD                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000011D3                 jmp     short loc_118C
.text$mn:000011D5 ; ---------------------------------------------------------------------------
.text$mn:000011D5
.text$mn:000011D5 loc_11D5:                               ; CODE XREF: ToolBar::reset(bool)+13Fj
.text$mn:000011D5                                         ; ToolBar::reset(bool)+221j ...
.text$mn:000011D5                 movzx   ecx, [ebp+arg_0]
.text$mn:000011D9                 test    ecx, ecx
.text$mn:000011DB                 jz      loc_128D
.text$mn:000011E1                 mov     edx, [ebp+var_1C]
.text$mn:000011E4                 cmp     dword ptr [edx+0ECh], 2
.text$mn:000011EB                 jnz     short loc_11FB
.text$mn:000011ED                 mov     eax, [ebp+var_1C]
.text$mn:000011F0                 mov     ecx, [eax+108h]
.text$mn:000011F6                 mov     [ebp+var_3C], ecx
.text$mn:000011F9                 jmp     short loc_1207
.text$mn:000011FB ; ---------------------------------------------------------------------------
.text$mn:000011FB
.text$mn:000011FB loc_11FB:                               ; CODE XREF: ToolBar::reset(bool)+28Bj
.text$mn:000011FB                 mov     edx, [ebp+var_1C]
.text$mn:000011FE                 mov     eax, [edx+100h]
.text$mn:00001204                 mov     [ebp+var_3C], eax
.text$mn:00001207
.text$mn:00001207 loc_1207:                               ; CODE XREF: ToolBar::reset(bool)+299j
.text$mn:00001207                 mov     ecx, [ebp+var_3C]
.text$mn:0000120A                 mov     [ebp+var_40], ecx
.text$mn:0000120D                 mov     edx, [ebp+var_1C]
.text$mn:00001210                 mov     eax, [ebp+var_40]
.text$mn:00001213                 mov     [edx+10Ch], eax
.text$mn:00001219                 mov     ecx, [ebp+var_1C]
.text$mn:0000121C                 cmp     dword ptr [ecx+0ECh], 1
.text$mn:00001223                 jnz     short loc_122E
.text$mn:00001225                 mov     [ebp+var_34], 20h ; ' '
.text$mn:0000122C                 jmp     short loc_1235
.text$mn:0000122E ; ---------------------------------------------------------------------------
.text$mn:0000122E
.text$mn:0000122E loc_122E:                               ; CODE XREF: ToolBar::reset(bool)+2C3j
.text$mn:0000122E                 mov     [ebp+var_34], 10h
.text$mn:00001235
.text$mn:00001235 loc_1235:                               ; CODE XREF: ToolBar::reset(bool)+2CCj
.text$mn:00001235                 mov     dx, word ptr [ebp+var_34]
.text$mn:00001239                 mov     [ebp+var_24], dx
.text$mn:0000123D                 movzx   eax, [ebp+var_24]
.text$mn:00001241                 and     eax, 0FFFFh
.text$mn:00001246                 movzx   ecx, ax
.text$mn:00001249                 movzx   edx, [ebp+var_24]
.text$mn:0000124D                 and     edx, 0FFFFh
.text$mn:00001253                 movzx   eax, dx
.text$mn:00001256                 shl     eax, 10h
.text$mn:00001259                 or      ecx, eax
.text$mn:0000125B                 push    ecx             ; lParam
.text$mn:0000125C                 push    0               ; wParam
.text$mn:0000125E                 push    41Fh            ; Msg
.text$mn:00001263                 mov     ecx, [ebp+var_1C]
.text$mn:00001266                 mov     edx, [ecx+0Ch]
.text$mn:00001269                 push    edx             ; hWnd
.text$mn:0000126A                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001270                 mov     eax, [ebp+var_1C]
.text$mn:00001273                 mov     ecx, [eax+10h]
.text$mn:00001276                 push    ecx             ; lParam
.text$mn:00001277                 mov     edx, [ebp+var_40]
.text$mn:0000127A                 push    edx             ; wParam
.text$mn:0000127B                 push    444h            ; Msg
.text$mn:00001280                 mov     eax, [ebp+var_1C]
.text$mn:00001283                 mov     ecx, [eax+0Ch]
.text$mn:00001286                 push    ecx             ; hWnd
.text$mn:00001287                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000128D
.text$mn:0000128D loc_128D:                               ; CODE XREF: ToolBar::reset(bool)+27Bj
.text$mn:0000128D                 push    0               ; lParam
.text$mn:0000128F                 push    0               ; wParam
.text$mn:00001291                 push    421h            ; Msg
.text$mn:00001296                 mov     edx, [ebp+var_1C]
.text$mn:00001299                 mov     eax, [edx+0Ch]
.text$mn:0000129C                 push    eax             ; hWnd
.text$mn:0000129D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000012A3                 mov     ecx, [ebp+var_1C]
.text$mn:000012A6                 cmp     dword ptr [ecx+110h], 0
.text$mn:000012AD                 jz      loc_1336
.text$mn:000012B3                 mov     ecx, [ebp+var_1C] ; this
.text$mn:000012B6                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000012BB                 mov     edx, [ebp+var_1C]
.text$mn:000012BE                 mov     [edx+134h], eax
.text$mn:000012C4                 mov     eax, [ebp+var_1C]
.text$mn:000012C7                 mov     dword ptr [eax+138h], 0
.text$mn:000012D1                 mov     ecx, [ebp+var_1C]
.text$mn:000012D4                 mov     dword ptr [ecx+154h], 1
.text$mn:000012DE                 mov     edx, [ebp+var_1C]
.text$mn:000012E1                 mov     eax, [edx]
.text$mn:000012E3                 mov     ecx, [ebp+var_1C]
.text$mn:000012E6                 mov     edx, [eax+28h]
.text$mn:000012E9                 call    edx
.text$mn:000012EB                 mov     [ebp+var_38], eax
.text$mn:000012EE                 mov     eax, [ebp+var_1C]
.text$mn:000012F1                 mov     ecx, [ebp+var_38]
.text$mn:000012F4                 mov     [eax+150h], ecx
.text$mn:000012FA                 mov     edx, [ebp+var_1C]
.text$mn:000012FD                 mov     eax, [ebp+var_38]
.text$mn:00001300                 mov     [edx+13Ch], eax
.text$mn:00001306                 mov     ecx, [ebp+var_1C]
.text$mn:00001309                 mov     edx, [ecx]
.text$mn:0000130B                 mov     ecx, [ebp+var_1C]
.text$mn:0000130E                 mov     eax, [edx+24h]
.text$mn:00001311                 call    eax
.text$mn:00001313                 mov     ecx, [ebp+var_1C]
.text$mn:00001316                 mov     [ecx+158h], eax
.text$mn:0000131C                 mov     edx, [ebp+var_1C]
.text$mn:0000131F                 add     edx, 114h
.text$mn:00001325                 push    edx             ; struct tagREBARBANDINFOW *
.text$mn:00001326                 push    0               ; wParam
.text$mn:00001328                 mov     eax, [ebp+var_1C]
.text$mn:0000132B                 mov     ecx, [eax+110h] ; this
.text$mn:00001331                 call    ?reNew@ReBar@@QAEXHPAUtagREBARBANDINFOW@@@Z ; ReBar::reNew(int,tagREBARBANDINFOW *)
.text$mn:00001336
.text$mn:00001336 loc_1336:                               ; CODE XREF: ToolBar::reset(bool)+34Dj
.text$mn:00001336                 mov     ecx, [ebp+var_4]
.text$mn:00001339                 xor     ecx, ebp
.text$mn:0000133B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001340                 mov     esp, ebp
.text$mn:00001342                 pop     ebp
.text$mn:00001343                 retn    4
.text$mn:00001343 ?reset@ToolBar@@AAEX_N@Z endp
.text$mn:00001343
.text$mn:00001343 ; ---------------------------------------------------------------------------
.text$mn:00001346                 align 10h
.text$mn:00001350
.text$mn:00001350 ; =============== S U B R O U T I N E =======================================
.text$mn:00001350
.text$mn:00001350 ; Attributes: bp-based frame
.text$mn:00001350
.text$mn:00001350 ; void __thiscall ReBar::init(ReBar *this, HINSTANCE, HWND)
.text$mn:00001350                 public ?init@ReBar@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00001350 ?init@ReBar@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00001350
.text$mn:00001350 Dst             = dword ptr -10h
.text$mn:00001350 var_C           = dword ptr -0Ch
.text$mn:00001350 var_8           = dword ptr -8
.text$mn:00001350 var_4           = dword ptr -4
.text$mn:00001350 arg_0           = dword ptr  8
.text$mn:00001350 arg_4           = dword ptr  0Ch
.text$mn:00001350
.text$mn:00001350                 push    ebp
.text$mn:00001351                 mov     ebp, esp
.text$mn:00001353                 sub     esp, 10h
.text$mn:00001356                 mov     [ebp+var_4], ecx
.text$mn:00001359                 mov     eax, [ebp+arg_4]
.text$mn:0000135C                 push    eax             ; HWND
.text$mn:0000135D                 mov     ecx, [ebp+arg_0]
.text$mn:00001360                 push    ecx             ; HINSTANCE
.text$mn:00001361                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001364                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:00001369                 push    0               ; lpParam
.text$mn:0000136B                 mov     edx, [ebp+var_4]
.text$mn:0000136E                 mov     eax, [edx+4]
.text$mn:00001371                 push    eax             ; hInstance
.text$mn:00001372                 push    0               ; hMenu
.text$mn:00001374                 mov     ecx, [ebp+var_4]
.text$mn:00001377                 mov     edx, [ecx+8]
.text$mn:0000137A                 push    edx             ; hWndParent
.text$mn:0000137B                 push    0               ; nHeight
.text$mn:0000137D                 push    0               ; nWidth
.text$mn:0000137F                 push    0               ; Y
.text$mn:00001381                 push    0               ; X
.text$mn:00001383                 push    56000648h       ; dwStyle
.text$mn:00001388                 push    0               ; lpWindowName
.text$mn:0000138A                 push    offset $SG123277 ; "ReBarWindow32"
.text$mn:0000138F                 push    80h ; 'Ç'       ; dwExStyle
.text$mn:00001394                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:0000139A                 mov     ecx, [ebp+var_4]
.text$mn:0000139D                 mov     [ecx+0Ch], eax
.text$mn:000013A0                 push    0Ch             ; Size
.text$mn:000013A2                 push    0               ; Val
.text$mn:000013A4                 lea     edx, [ebp+Dst]
.text$mn:000013A7                 push    edx             ; Dst
.text$mn:000013A8                 call    _memset
.text$mn:000013AD                 add     esp, 0Ch
.text$mn:000013B0                 mov     [ebp+Dst], 0Ch
.text$mn:000013B7                 mov     [ebp+var_C], 0
.text$mn:000013BE                 mov     [ebp+var_8], 0
.text$mn:000013C5                 lea     eax, [ebp+Dst]
.text$mn:000013C8                 push    eax             ; lParam
.text$mn:000013C9                 push    0               ; wParam
.text$mn:000013CB                 push    404h            ; Msg
.text$mn:000013D0                 mov     ecx, [ebp+var_4]
.text$mn:000013D3                 mov     edx, [ecx+0Ch]
.text$mn:000013D6                 push    edx             ; hWnd
.text$mn:000013D7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000013DD                 mov     esp, ebp
.text$mn:000013DF                 pop     ebp
.text$mn:000013E0                 retn    8
.text$mn:000013E0 ?init@ReBar@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:000013E0
.text$mn:000013E0 ; ---------------------------------------------------------------------------
.text$mn:000013E3                 align 10h
.text$mn:000013F0
.text$mn:000013F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000013F0
.text$mn:000013F0 ; Attributes: bp-based frame
.text$mn:000013F0
.text$mn:000013F0 ; bool __thiscall ReBar::addBand(ReBar *this, LPARAM lParam, bool)
.text$mn:000013F0                 public ?addBand@ReBar@@QAE_NPAUtagREBARBANDINFOW@@_N@Z
.text$mn:000013F0 ?addBand@ReBar@@QAE_NPAUtagREBARBANDINFOW@@_N@Z proc near
.text$mn:000013F0                                         ; CODE XREF: ToolBar::addToRebar(ReBar *)+FFp
.text$mn:000013F0
.text$mn:000013F0 var_4           = dword ptr -4
.text$mn:000013F0 lParam          = dword ptr  8
.text$mn:000013F0 arg_4           = byte ptr  0Ch
.text$mn:000013F0
.text$mn:000013F0                 push    ebp
.text$mn:000013F1                 mov     ebp, esp
.text$mn:000013F3                 push    ecx
.text$mn:000013F4                 mov     [ebp+var_4], ecx
.text$mn:000013F7                 mov     eax, [ebp+lParam]
.text$mn:000013FA                 mov     ecx, [eax+4]
.text$mn:000013FD                 and     ecx, 1
.text$mn:00001400                 jz      short loc_1423
.text$mn:00001402                 mov     edx, [ebp+lParam]
.text$mn:00001405                 mov     eax, [edx+8]
.text$mn:00001408                 and     eax, 100h
.text$mn:0000140D                 jnz     short loc_1421
.text$mn:0000140F                 mov     ecx, [ebp+lParam]
.text$mn:00001412                 mov     edx, [ecx+8]
.text$mn:00001415                 or      edx, 80h
.text$mn:0000141B                 mov     eax, [ebp+lParam]
.text$mn:0000141E                 mov     [eax+8], edx
.text$mn:00001421
.text$mn:00001421 loc_1421:                               ; CODE XREF: ReBar::addBand(tagREBARBANDINFOW *,bool)+1Dj
.text$mn:00001421                 jmp     short loc_142D
.text$mn:00001423 ; ---------------------------------------------------------------------------
.text$mn:00001423
.text$mn:00001423 loc_1423:                               ; CODE XREF: ReBar::addBand(tagREBARBANDINFOW *,bool)+10j
.text$mn:00001423                 mov     ecx, [ebp+lParam]
.text$mn:00001426                 mov     dword ptr [ecx+8], 80h ; 'Ç'
.text$mn:0000142D
.text$mn:0000142D loc_142D:                               ; CODE XREF: ReBar::addBand(tagREBARBANDINFOW *,bool):loc_1421j
.text$mn:0000142D                 mov     edx, [ebp+lParam]
.text$mn:00001430                 mov     eax, [edx+4]
.text$mn:00001433                 or      eax, 101h
.text$mn:00001438                 mov     ecx, [ebp+lParam]
.text$mn:0000143B                 mov     [ecx+4], eax
.text$mn:0000143E                 movzx   edx, [ebp+arg_4]
.text$mn:00001442                 test    edx, edx
.text$mn:00001444                 jz      short loc_1462
.text$mn:00001446                 mov     eax, [ebp+lParam]
.text$mn:00001449                 mov     ecx, [eax+34h]
.text$mn:0000144C                 push    ecx             ; int
.text$mn:0000144D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001450                 call    ?isIDTaken@ReBar@@AAE_NH@Z ; ReBar::isIDTaken(int)
.text$mn:00001455                 movzx   edx, al
.text$mn:00001458                 test    edx, edx
.text$mn:0000145A                 jz      short loc_1460
.text$mn:0000145C                 xor     al, al
.text$mn:0000145E                 jmp     short loc_148A
.text$mn:00001460 ; ---------------------------------------------------------------------------
.text$mn:00001460
.text$mn:00001460 loc_1460:                               ; CODE XREF: ReBar::addBand(tagREBARBANDINFOW *,bool)+6Aj
.text$mn:00001460                 jmp     short loc_1470
.text$mn:00001462 ; ---------------------------------------------------------------------------
.text$mn:00001462
.text$mn:00001462 loc_1462:                               ; CODE XREF: ReBar::addBand(tagREBARBANDINFOW *,bool)+54j
.text$mn:00001462                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001465                 call    ?getNewID@ReBar@@AAEHXZ ; ReBar::getNewID(void)
.text$mn:0000146A                 mov     ecx, [ebp+lParam]
.text$mn:0000146D                 mov     [ecx+34h], eax
.text$mn:00001470
.text$mn:00001470 loc_1470:                               ; CODE XREF: ReBar::addBand(tagREBARBANDINFOW *,bool):loc_1460j
.text$mn:00001470                 mov     edx, [ebp+lParam]
.text$mn:00001473                 push    edx             ; lParam
.text$mn:00001474                 push    0FFFFFFFFh      ; wParam
.text$mn:00001476                 push    40Ah            ; Msg
.text$mn:0000147B                 mov     eax, [ebp+var_4]
.text$mn:0000147E                 mov     ecx, [eax+0Ch]
.text$mn:00001481                 push    ecx             ; hWnd
.text$mn:00001482                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001488                 mov     al, 1
.text$mn:0000148A
.text$mn:0000148A loc_148A:                               ; CODE XREF: ReBar::addBand(tagREBARBANDINFOW *,bool)+6Ej
.text$mn:0000148A                 mov     esp, ebp
.text$mn:0000148C                 pop     ebp
.text$mn:0000148D                 retn    8
.text$mn:0000148D ?addBand@ReBar@@QAE_NPAUtagREBARBANDINFOW@@_N@Z endp
.text$mn:0000148D
.text$mn:00001490
.text$mn:00001490 ; =============== S U B R O U T I N E =======================================
.text$mn:00001490
.text$mn:00001490 ; Attributes: bp-based frame
.text$mn:00001490
.text$mn:00001490 ; void __thiscall ReBar::reNew(ReBar *this, WPARAM wParam, struct tagREBARBANDINFOW *)
.text$mn:00001490                 public ?reNew@ReBar@@QAEXHPAUtagREBARBANDINFOW@@@Z
.text$mn:00001490 ?reNew@ReBar@@QAEXHPAUtagREBARBANDINFOW@@@Z proc near
.text$mn:00001490                                         ; CODE XREF: ToolBar::reset(bool)+3D1p
.text$mn:00001490
.text$mn:00001490 var_8           = dword ptr -8
.text$mn:00001490 var_4           = dword ptr -4
.text$mn:00001490 wParam          = dword ptr  8
.text$mn:00001490 lParam          = dword ptr  0Ch
.text$mn:00001490
.text$mn:00001490                 push    ebp
.text$mn:00001491                 mov     ebp, esp
.text$mn:00001493                 sub     esp, 8
.text$mn:00001496                 mov     [ebp+var_4], ecx
.text$mn:00001499                 push    0               ; lParam
.text$mn:0000149B                 mov     eax, [ebp+wParam]
.text$mn:0000149E                 push    eax             ; wParam
.text$mn:0000149F                 push    410h            ; Msg
.text$mn:000014A4                 mov     ecx, [ebp+var_4]
.text$mn:000014A7                 mov     edx, [ecx+0Ch]
.text$mn:000014AA                 push    edx             ; hWnd
.text$mn:000014AB                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000014B1                 mov     [ebp+var_8], eax
.text$mn:000014B4                 mov     eax, [ebp+lParam]
.text$mn:000014B7                 push    eax             ; lParam
.text$mn:000014B8                 mov     ecx, [ebp+var_8]
.text$mn:000014BB                 push    ecx             ; wParam
.text$mn:000014BC                 push    40Bh            ; Msg
.text$mn:000014C1                 mov     edx, [ebp+var_4]
.text$mn:000014C4                 mov     eax, [edx+0Ch]
.text$mn:000014C7                 push    eax             ; hWnd
.text$mn:000014C8                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000014CE                 mov     esp, ebp
.text$mn:000014D0                 pop     ebp
.text$mn:000014D1                 retn    8
.text$mn:000014D1 ?reNew@ReBar@@QAEXHPAUtagREBARBANDINFOW@@@Z endp
.text$mn:000014D1
.text$mn:000014D1 ; ---------------------------------------------------------------------------
.text$mn:000014D4                 align 10h
.text$mn:000014E0
.text$mn:000014E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000014E0
.text$mn:000014E0 ; Attributes: bp-based frame
.text$mn:000014E0
.text$mn:000014E0 ; void __thiscall ReBar::removeBand(ReBar *this, int)
.text$mn:000014E0                 public ?removeBand@ReBar@@QAEXH@Z
.text$mn:000014E0 ?removeBand@ReBar@@QAEXH@Z proc near    ; CODE XREF: ToolBar::destroy(void)+28p
.text$mn:000014E0
.text$mn:000014E0 var_8           = dword ptr -8
.text$mn:000014E0 var_4           = dword ptr -4
.text$mn:000014E0 wParam          = dword ptr  8
.text$mn:000014E0
.text$mn:000014E0                 push    ebp
.text$mn:000014E1                 mov     ebp, esp
.text$mn:000014E3                 sub     esp, 8
.text$mn:000014E6                 mov     [ebp+var_4], ecx
.text$mn:000014E9                 push    0               ; lParam
.text$mn:000014EB                 mov     eax, [ebp+wParam]
.text$mn:000014EE                 push    eax             ; wParam
.text$mn:000014EF                 push    410h            ; Msg
.text$mn:000014F4                 mov     ecx, [ebp+var_4]
.text$mn:000014F7                 mov     edx, [ecx+0Ch]
.text$mn:000014FA                 push    edx             ; hWnd
.text$mn:000014FB                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001501                 mov     [ebp+var_8], eax
.text$mn:00001504                 cmp     [ebp+wParam], 0Ah
.text$mn:00001508                 jl      short loc_1516
.text$mn:0000150A                 mov     eax, [ebp+wParam]
.text$mn:0000150D                 push    eax             ; int
.text$mn:0000150E                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001511                 call    ?releaseID@ReBar@@AAEXH@Z ; ReBar::releaseID(int)
.text$mn:00001516
.text$mn:00001516 loc_1516:                               ; CODE XREF: ReBar::removeBand(int)+28j
.text$mn:00001516                 push    0               ; lParam
.text$mn:00001518                 mov     ecx, [ebp+var_8]
.text$mn:0000151B                 push    ecx             ; wParam
.text$mn:0000151C                 push    402h            ; Msg
.text$mn:00001521                 mov     edx, [ebp+var_4]
.text$mn:00001524                 mov     eax, [edx+0Ch]
.text$mn:00001527                 push    eax             ; hWnd
.text$mn:00001528                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000152E                 mov     esp, ebp
.text$mn:00001530                 pop     ebp
.text$mn:00001531                 retn    4
.text$mn:00001531 ?removeBand@ReBar@@QAEXH@Z endp
.text$mn:00001531
.text$mn:00001531 ; ---------------------------------------------------------------------------
.text$mn:00001534                 align 10h
.text$mn:00001540
.text$mn:00001540 ; =============== S U B R O U T I N E =======================================
.text$mn:00001540
.text$mn:00001540 ; Attributes: bp-based frame
.text$mn:00001540
.text$mn:00001540 ; void __thiscall ReBar::setIDVisible(ReBar *this, WPARAM wParam, bool)
.text$mn:00001540                 public ?setIDVisible@ReBar@@QAEXH_N@Z
.text$mn:00001540 ?setIDVisible@ReBar@@QAEXH_N@Z proc near
.text$mn:00001540
.text$mn:00001540 Dst             = dword ptr -58h
.text$mn:00001540 var_54          = dword ptr -54h
.text$mn:00001540 var_50          = dword ptr -50h
.text$mn:00001540 var_8           = dword ptr -8
.text$mn:00001540 var_4           = dword ptr -4
.text$mn:00001540 wParam          = dword ptr  8
.text$mn:00001540 arg_4           = byte ptr  0Ch
.text$mn:00001540
.text$mn:00001540                 push    ebp
.text$mn:00001541                 mov     ebp, esp
.text$mn:00001543                 sub     esp, 58h
.text$mn:00001546                 mov     [ebp+var_8], ecx
.text$mn:00001549                 push    0               ; lParam
.text$mn:0000154B                 mov     eax, [ebp+wParam]
.text$mn:0000154E                 push    eax             ; wParam
.text$mn:0000154F                 push    410h            ; Msg
.text$mn:00001554                 mov     ecx, [ebp+var_8]
.text$mn:00001557                 mov     edx, [ecx+0Ch]
.text$mn:0000155A                 push    edx             ; hWnd
.text$mn:0000155B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001561                 mov     [ebp+var_4], eax
.text$mn:00001564                 cmp     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001568                 jnz     short loc_156C
.text$mn:0000156A                 jmp     short loc_15DA
.text$mn:0000156C ; ---------------------------------------------------------------------------
.text$mn:0000156C
.text$mn:0000156C loc_156C:                               ; CODE XREF: ReBar::setIDVisible(int,bool)+28j
.text$mn:0000156C                 push    38h ; '8'       ; Size
.text$mn:0000156E                 push    0               ; Val
.text$mn:00001570                 lea     eax, [ebp+Dst]
.text$mn:00001573                 push    eax             ; Dst
.text$mn:00001574                 call    _memset
.text$mn:00001579                 add     esp, 0Ch
.text$mn:0000157C                 mov     [ebp+Dst], 38h ; '8'
.text$mn:00001583                 mov     [ebp+var_54], 1
.text$mn:0000158A                 lea     ecx, [ebp+Dst]
.text$mn:0000158D                 push    ecx             ; lParam
.text$mn:0000158E                 mov     edx, [ebp+var_4]
.text$mn:00001591                 push    edx             ; wParam
.text$mn:00001592                 push    41Ch            ; Msg
.text$mn:00001597                 mov     eax, [ebp+var_8]
.text$mn:0000159A                 mov     ecx, [eax+0Ch]
.text$mn:0000159D                 push    ecx             ; hWnd
.text$mn:0000159E                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000015A4                 movzx   edx, [ebp+arg_4]
.text$mn:000015A8                 test    edx, edx
.text$mn:000015AA                 jz      short loc_15B7
.text$mn:000015AC                 mov     eax, [ebp+var_50]
.text$mn:000015AF                 and     eax, 0FFFFFFF7h
.text$mn:000015B2                 mov     [ebp+var_50], eax
.text$mn:000015B5                 jmp     short loc_15C0
.text$mn:000015B7 ; ---------------------------------------------------------------------------
.text$mn:000015B7
.text$mn:000015B7 loc_15B7:                               ; CODE XREF: ReBar::setIDVisible(int,bool)+6Aj
.text$mn:000015B7                 mov     ecx, [ebp+var_50]
.text$mn:000015BA                 or      ecx, 8
.text$mn:000015BD                 mov     [ebp+var_50], ecx
.text$mn:000015C0
.text$mn:000015C0 loc_15C0:                               ; CODE XREF: ReBar::setIDVisible(int,bool)+75j
.text$mn:000015C0                 lea     edx, [ebp+Dst]
.text$mn:000015C3                 push    edx             ; lParam
.text$mn:000015C4                 mov     eax, [ebp+var_4]
.text$mn:000015C7                 push    eax             ; wParam
.text$mn:000015C8                 push    40Bh            ; Msg
.text$mn:000015CD                 mov     ecx, [ebp+var_8]
.text$mn:000015D0                 mov     edx, [ecx+0Ch]
.text$mn:000015D3                 push    edx             ; hWnd
.text$mn:000015D4                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000015DA
.text$mn:000015DA loc_15DA:                               ; CODE XREF: ReBar::setIDVisible(int,bool)+2Aj
.text$mn:000015DA                 mov     esp, ebp
.text$mn:000015DC                 pop     ebp
.text$mn:000015DD                 retn    8
.text$mn:000015DD ?setIDVisible@ReBar@@QAEXH_N@Z endp
.text$mn:000015DD
.text$mn:000015E0
.text$mn:000015E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000015E0
.text$mn:000015E0 ; Attributes: bp-based frame
.text$mn:000015E0
.text$mn:000015E0 ; bool __thiscall ReBar::getIDVisible(ReBar *this, int)
.text$mn:000015E0                 public ?getIDVisible@ReBar@@QAE_NH@Z
.text$mn:000015E0 ?getIDVisible@ReBar@@QAE_NH@Z proc near
.text$mn:000015E0
.text$mn:000015E0 Dst             = dword ptr -5Ch
.text$mn:000015E0 var_58          = dword ptr -58h
.text$mn:000015E0 var_54          = dword ptr -54h
.text$mn:000015E0 var_C           = dword ptr -0Ch
.text$mn:000015E0 var_8           = dword ptr -8
.text$mn:000015E0 var_4           = dword ptr -4
.text$mn:000015E0 wParam          = dword ptr  8
.text$mn:000015E0
.text$mn:000015E0                 push    ebp
.text$mn:000015E1                 mov     ebp, esp
.text$mn:000015E3                 sub     esp, 5Ch
.text$mn:000015E6                 mov     [ebp+var_8], ecx
.text$mn:000015E9                 push    0               ; lParam
.text$mn:000015EB                 mov     eax, [ebp+wParam]
.text$mn:000015EE                 push    eax             ; wParam
.text$mn:000015EF                 push    410h            ; Msg
.text$mn:000015F4                 mov     ecx, [ebp+var_8]
.text$mn:000015F7                 mov     edx, [ecx+0Ch]
.text$mn:000015FA                 push    edx             ; hWnd
.text$mn:000015FB                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001601                 mov     [ebp+var_4], eax
.text$mn:00001604                 cmp     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001608                 jnz     short loc_160E
.text$mn:0000160A                 xor     al, al
.text$mn:0000160C                 jmp     short loc_1661
.text$mn:0000160E ; ---------------------------------------------------------------------------
.text$mn:0000160E
.text$mn:0000160E loc_160E:                               ; CODE XREF: ReBar::getIDVisible(int)+28j
.text$mn:0000160E                 push    38h ; '8'       ; Size
.text$mn:00001610                 push    0               ; Val
.text$mn:00001612                 lea     eax, [ebp+Dst]
.text$mn:00001615                 push    eax             ; Dst
.text$mn:00001616                 call    _memset
.text$mn:0000161B                 add     esp, 0Ch
.text$mn:0000161E                 mov     [ebp+Dst], 38h ; '8'
.text$mn:00001625                 mov     [ebp+var_58], 1
.text$mn:0000162C                 lea     ecx, [ebp+Dst]
.text$mn:0000162F                 push    ecx             ; lParam
.text$mn:00001630                 mov     edx, [ebp+var_4]
.text$mn:00001633                 push    edx             ; wParam
.text$mn:00001634                 push    41Ch            ; Msg
.text$mn:00001639                 mov     eax, [ebp+var_8]
.text$mn:0000163C                 mov     ecx, [eax+0Ch]
.text$mn:0000163F                 push    ecx             ; hWnd
.text$mn:00001640                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001646                 mov     edx, [ebp+var_54]
.text$mn:00001649                 and     edx, 8
.text$mn:0000164C                 jnz     short loc_1657
.text$mn:0000164E                 mov     [ebp+var_C], 1
.text$mn:00001655                 jmp     short loc_165E
.text$mn:00001657 ; ---------------------------------------------------------------------------
.text$mn:00001657
.text$mn:00001657 loc_1657:                               ; CODE XREF: ReBar::getIDVisible(int)+6Cj
.text$mn:00001657                 mov     [ebp+var_C], 0
.text$mn:0000165E
.text$mn:0000165E loc_165E:                               ; CODE XREF: ReBar::getIDVisible(int)+75j
.text$mn:0000165E                 mov     al, byte ptr [ebp+var_C]
.text$mn:00001661
.text$mn:00001661 loc_1661:                               ; CODE XREF: ReBar::getIDVisible(int)+2Cj
.text$mn:00001661                 mov     esp, ebp
.text$mn:00001663                 pop     ebp
.text$mn:00001664                 retn    4
.text$mn:00001664 ?getIDVisible@ReBar@@QAE_NH@Z endp
.text$mn:00001664
.text$mn:00001664 ; ---------------------------------------------------------------------------
.text$mn:00001667                 align 10h
.text$mn:00001670
.text$mn:00001670 ; =============== S U B R O U T I N E =======================================
.text$mn:00001670
.text$mn:00001670 ; Attributes: bp-based frame
.text$mn:00001670
.text$mn:00001670 ; void __thiscall ReBar::setGrayBackground(ReBar *this, int)
.text$mn:00001670                 public ?setGrayBackground@ReBar@@QAEXH@Z
.text$mn:00001670 ?setGrayBackground@ReBar@@QAEXH@Z proc near
.text$mn:00001670
.text$mn:00001670 Dst             = dword ptr -58h
.text$mn:00001670 var_54          = dword ptr -54h
.text$mn:00001670 var_28          = dword ptr -28h
.text$mn:00001670 var_8           = dword ptr -8
.text$mn:00001670 var_4           = dword ptr -4
.text$mn:00001670 wParam          = dword ptr  8
.text$mn:00001670
.text$mn:00001670                 push    ebp
.text$mn:00001671                 mov     ebp, esp
.text$mn:00001673                 sub     esp, 58h
.text$mn:00001676                 mov     [ebp+var_8], ecx
.text$mn:00001679                 push    0               ; lParam
.text$mn:0000167B                 mov     eax, [ebp+wParam]
.text$mn:0000167E                 push    eax             ; wParam
.text$mn:0000167F                 push    410h            ; Msg
.text$mn:00001684                 mov     ecx, [ebp+var_8]
.text$mn:00001687                 mov     edx, [ecx+0Ch]
.text$mn:0000168A                 push    edx             ; hWnd
.text$mn:0000168B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001691                 mov     [ebp+var_4], eax
.text$mn:00001694                 cmp     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001698                 jnz     short loc_169C
.text$mn:0000169A                 jmp     short loc_16EB
.text$mn:0000169C ; ---------------------------------------------------------------------------
.text$mn:0000169C
.text$mn:0000169C loc_169C:                               ; CODE XREF: ReBar::setGrayBackground(int)+28j
.text$mn:0000169C                 push    38h ; '8'       ; Size
.text$mn:0000169E                 push    0               ; Val
.text$mn:000016A0                 lea     eax, [ebp+Dst]
.text$mn:000016A3                 push    eax             ; Dst
.text$mn:000016A4                 call    _memset
.text$mn:000016A9                 add     esp, 0Ch
.text$mn:000016AC                 mov     [ebp+Dst], 38h ; '8'
.text$mn:000016B3                 mov     [ebp+var_54], 80h ; 'Ç'
.text$mn:000016BA                 push    offset BitmapName ; lpBitmapName
.text$mn:000016BF                 push    0               ; lpModuleName
.text$mn:000016C1                 call    dword ptr ds:__imp__GetModuleHandleW@4 ; GetModuleHandleW(x)
.text$mn:000016C7                 push    eax             ; hInstance
.text$mn:000016C8                 call    dword ptr ds:__imp__LoadBitmapW@8 ; LoadBitmapW(x,x)
.text$mn:000016CE                 mov     [ebp+var_28], eax
.text$mn:000016D1                 lea     ecx, [ebp+Dst]
.text$mn:000016D4                 push    ecx             ; lParam
.text$mn:000016D5                 mov     edx, [ebp+var_4]
.text$mn:000016D8                 push    edx             ; wParam
.text$mn:000016D9                 push    40Bh            ; Msg
.text$mn:000016DE                 mov     eax, [ebp+var_8]
.text$mn:000016E1                 mov     ecx, [eax+0Ch]
.text$mn:000016E4                 push    ecx             ; hWnd
.text$mn:000016E5                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000016EB
.text$mn:000016EB loc_16EB:                               ; CODE XREF: ReBar::setGrayBackground(int)+2Aj
.text$mn:000016EB                 mov     esp, ebp
.text$mn:000016ED                 pop     ebp
.text$mn:000016EE                 retn    4
.text$mn:000016EE ?setGrayBackground@ReBar@@QAEXH@Z endp
.text$mn:000016EE
.text$mn:000016EE ; ---------------------------------------------------------------------------
.text$mn:000016F1                 align 10h
.text$mn:00001700
.text$mn:00001700 ; =============== S U B R O U T I N E =======================================
.text$mn:00001700
.text$mn:00001700 ; Attributes: bp-based frame
.text$mn:00001700
.text$mn:00001700 ; int __thiscall ReBar::getNewID(ReBar *__hidden this)
.text$mn:00001700                 public ?getNewID@ReBar@@AAEHXZ
.text$mn:00001700 ?getNewID@ReBar@@AAEHXZ proc near       ; CODE XREF: ReBar::addBand(tagREBARBANDINFOW *,bool)+75p
.text$mn:00001700
.text$mn:00001700 var_14          = dword ptr -14h
.text$mn:00001700 var_10          = dword ptr -10h
.text$mn:00001700 var_C           = dword ptr -0Ch
.text$mn:00001700 var_8           = dword ptr -8
.text$mn:00001700 var_4           = dword ptr -4
.text$mn:00001700
.text$mn:00001700                 push    ebp
.text$mn:00001701                 mov     ebp, esp
.text$mn:00001703                 sub     esp, 14h
.text$mn:00001706                 mov     [ebp+var_10], ecx
.text$mn:00001709                 mov     [ebp+var_4], 0Ah
.text$mn:00001710                 mov     [ebp+var_C], 0
.text$mn:00001717                 mov     ecx, [ebp+var_10]
.text$mn:0000171A                 add     ecx, 10h
.text$mn:0000171D                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00001722                 mov     [ebp+var_14], eax
.text$mn:00001725                 mov     [ebp+var_8], 0
.text$mn:0000172C                 jmp     short loc_1737
.text$mn:0000172E ; ---------------------------------------------------------------------------
.text$mn:0000172E
.text$mn:0000172E loc_172E:                               ; CODE XREF: ReBar::getNewID(void)+5Bj
.text$mn:0000172E                                         ; ReBar::getNewID(void):loc_1774j
.text$mn:0000172E                 mov     eax, [ebp+var_8]
.text$mn:00001731                 add     eax, 1
.text$mn:00001734                 mov     [ebp+var_8], eax
.text$mn:00001737
.text$mn:00001737 loc_1737:                               ; CODE XREF: ReBar::getNewID(void)+2Cj
.text$mn:00001737                 mov     ecx, [ebp+var_8]
.text$mn:0000173A                 cmp     ecx, [ebp+var_14]
.text$mn:0000173D                 jnb     short loc_1776
.text$mn:0000173F                 mov     edx, [ebp+var_8]
.text$mn:00001742                 push    edx
.text$mn:00001743                 mov     ecx, [ebp+var_10]
.text$mn:00001746                 add     ecx, 10h
.text$mn:00001749                 call    ?at@?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::at(uint)
.text$mn:0000174E                 mov     eax, [eax]
.text$mn:00001750                 mov     [ebp+var_C], eax
.text$mn:00001753                 mov     ecx, [ebp+var_C]
.text$mn:00001756                 cmp     ecx, [ebp+var_4]
.text$mn:00001759                 jge     short loc_175F
.text$mn:0000175B                 jmp     short loc_172E
.text$mn:0000175D ; ---------------------------------------------------------------------------
.text$mn:0000175D                 jmp     short loc_1774
.text$mn:0000175F ; ---------------------------------------------------------------------------
.text$mn:0000175F
.text$mn:0000175F loc_175F:                               ; CODE XREF: ReBar::getNewID(void)+59j
.text$mn:0000175F                 mov     edx, [ebp+var_C]
.text$mn:00001762                 cmp     edx, [ebp+var_4]
.text$mn:00001765                 jnz     short loc_1772
.text$mn:00001767                 mov     eax, [ebp+var_4]
.text$mn:0000176A                 add     eax, 1
.text$mn:0000176D                 mov     [ebp+var_4], eax
.text$mn:00001770                 jmp     short loc_1774
.text$mn:00001772 ; ---------------------------------------------------------------------------
.text$mn:00001772
.text$mn:00001772 loc_1772:                               ; CODE XREF: ReBar::getNewID(void)+65j
.text$mn:00001772                 jmp     short loc_1776
.text$mn:00001774 ; ---------------------------------------------------------------------------
.text$mn:00001774
.text$mn:00001774 loc_1774:                               ; CODE XREF: ReBar::getNewID(void)+5Dj
.text$mn:00001774                                         ; ReBar::getNewID(void)+70j
.text$mn:00001774                 jmp     short loc_172E
.text$mn:00001776 ; ---------------------------------------------------------------------------
.text$mn:00001776
.text$mn:00001776 loc_1776:                               ; CODE XREF: ReBar::getNewID(void)+3Dj
.text$mn:00001776                                         ; ReBar::getNewID(void):loc_1772j
.text$mn:00001776                 lea     ecx, [ebp+var_4]
.text$mn:00001779                 push    ecx
.text$mn:0000177A                 mov     ecx, [ebp+var_10]
.text$mn:0000177D                 add     ecx, 10h
.text$mn:00001780                 call    ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int>>::push_back(int const &)
.text$mn:00001785                 mov     eax, [ebp+var_4]
.text$mn:00001788                 mov     esp, ebp
.text$mn:0000178A                 pop     ebp
.text$mn:0000178B                 retn
.text$mn:0000178B ?getNewID@ReBar@@AAEHXZ endp
.text$mn:0000178B
.text$mn:0000178B ; ---------------------------------------------------------------------------
.text$mn:0000178C                 align 10h
.text$mn:00001790
.text$mn:00001790 ; =============== S U B R O U T I N E =======================================
.text$mn:00001790
.text$mn:00001790 ; Attributes: bp-based frame
.text$mn:00001790
.text$mn:00001790 ; void __thiscall ReBar::releaseID(ReBar *this, int)
.text$mn:00001790                 public ?releaseID@ReBar@@AAEXH@Z
.text$mn:00001790 ?releaseID@ReBar@@AAEXH@Z proc near     ; CODE XREF: ReBar::removeBand(int)+31p
.text$mn:00001790
.text$mn:00001790 var_5C          = byte ptr -5Ch
.text$mn:00001790 var_50          = dword ptr -50h
.text$mn:00001790 var_44          = dword ptr -44h
.text$mn:00001790 var_38          = dword ptr -38h
.text$mn:00001790 var_34          = dword ptr -34h
.text$mn:00001790 var_30          = dword ptr -30h
.text$mn:00001790 var_2C          = dword ptr -2Ch
.text$mn:00001790 var_28          = dword ptr -28h
.text$mn:00001790 var_24          = dword ptr -24h
.text$mn:00001790 var_20          = dword ptr -20h
.text$mn:00001790 var_1C          = dword ptr -1Ch
.text$mn:00001790 var_18          = dword ptr -18h
.text$mn:00001790 var_14          = dword ptr -14h
.text$mn:00001790 Dst             = dword ptr -10h
.text$mn:00001790 var_C           = dword ptr -0Ch
.text$mn:00001790 var_4           = dword ptr -4
.text$mn:00001790 arg_0           = dword ptr  8
.text$mn:00001790
.text$mn:00001790                 push    ebp
.text$mn:00001791                 mov     ebp, esp
.text$mn:00001793                 push    0FFFFFFFFh
.text$mn:00001795                 push    offset __ehhandler$?releaseID@ReBar@@AAEXH@Z
.text$mn:0000179A                 mov     eax, large fs:0
.text$mn:000017A0                 push    eax
.text$mn:000017A1                 sub     esp, 50h
.text$mn:000017A4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000017A9                 xor     eax, ebp
.text$mn:000017AB                 push    eax
.text$mn:000017AC                 lea     eax, [ebp+var_C]
.text$mn:000017AF                 mov     large fs:0, eax
.text$mn:000017B5                 mov     [ebp+var_14], ecx
.text$mn:000017B8                 mov     ecx, [ebp+var_14]
.text$mn:000017BB                 add     ecx, 10h
.text$mn:000017BE                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:000017C3                 mov     [ebp+var_18], eax
.text$mn:000017C6                 mov     [ebp+Dst], 0
.text$mn:000017CD                 jmp     short loc_17D8
.text$mn:000017CF ; ---------------------------------------------------------------------------
.text$mn:000017CF
.text$mn:000017CF loc_17CF:                               ; CODE XREF: ReBar::releaseID(int):loc_1893j
.text$mn:000017CF                 mov     eax, [ebp+Dst]
.text$mn:000017D2                 add     eax, 1
.text$mn:000017D5                 mov     [ebp+Dst], eax
.text$mn:000017D8
.text$mn:000017D8 loc_17D8:                               ; CODE XREF: ReBar::releaseID(int)+3Dj
.text$mn:000017D8                 mov     ecx, [ebp+Dst]
.text$mn:000017DB                 cmp     ecx, [ebp+var_18]
.text$mn:000017DE                 jnb     loc_1898
.text$mn:000017E4                 mov     edx, [ebp+Dst]
.text$mn:000017E7                 push    edx
.text$mn:000017E8                 mov     ecx, [ebp+var_14]
.text$mn:000017EB                 add     ecx, 10h
.text$mn:000017EE                 call    ?at@?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::at(uint)
.text$mn:000017F3                 mov     eax, [eax]
.text$mn:000017F5                 cmp     eax, [ebp+arg_0]
.text$mn:000017F8                 jnz     loc_1893
.text$mn:000017FE                 mov     ecx, [ebp+Dst]
.text$mn:00001801                 push    ecx             ; Dst
.text$mn:00001802                 lea     edx, [ebp+var_50]
.text$mn:00001805                 push    edx             ; int
.text$mn:00001806                 lea     eax, [ebp+var_5C]
.text$mn:00001809                 push    eax             ; char
.text$mn:0000180A                 mov     ecx, [ebp+var_14]
.text$mn:0000180D                 add     ecx, 10h
.text$mn:00001810                 call    ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int>>::begin(void)
.text$mn:00001815                 mov     [ebp+var_1C], eax
.text$mn:00001818                 mov     ecx, [ebp+var_1C]
.text$mn:0000181B                 mov     [ebp+var_20], ecx
.text$mn:0000181E                 mov     [ebp+var_4], 0
.text$mn:00001825                 mov     ecx, [ebp+var_20]
.text$mn:00001828                 call    ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+(int)
.text$mn:0000182D                 mov     [ebp+var_24], eax
.text$mn:00001830                 mov     edx, [ebp+var_24]
.text$mn:00001833                 mov     [ebp+var_28], edx
.text$mn:00001836                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000183A                 sub     esp, 0Ch
.text$mn:0000183D                 mov     ecx, esp
.text$mn:0000183F                 mov     [ebp+var_30], esp
.text$mn:00001842                 mov     eax, [ebp+var_28]
.text$mn:00001845                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00001846                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:0000184B                 mov     [ebp+var_2C], eax
.text$mn:0000184E                 mov     ecx, [ebp+var_2C]
.text$mn:00001851                 mov     [ebp+var_34], ecx
.text$mn:00001854                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001858                 lea     edx, [ebp+var_44]
.text$mn:0000185B                 push    edx             ; int
.text$mn:0000185C                 mov     ecx, [ebp+var_14]
.text$mn:0000185F                 add     ecx, 10h
.text$mn:00001862                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001866                 call    ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z ; std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:0000186B                 mov     [ebp+var_38], eax
.text$mn:0000186E                 lea     ecx, [ebp+var_44]
.text$mn:00001871                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00001876                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000187A                 lea     ecx, [ebp+var_50]
.text$mn:0000187D                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00001882                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001889                 lea     ecx, [ebp+var_5C]
.text$mn:0000188C                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00001891                 jmp     short loc_1898
.text$mn:00001893 ; ---------------------------------------------------------------------------
.text$mn:00001893
.text$mn:00001893 loc_1893:                               ; CODE XREF: ReBar::releaseID(int)+68j
.text$mn:00001893                 jmp     loc_17CF
.text$mn:00001898 ; ---------------------------------------------------------------------------
.text$mn:00001898
.text$mn:00001898 loc_1898:                               ; CODE XREF: ReBar::releaseID(int)+4Ej
.text$mn:00001898                                         ; ReBar::releaseID(int)+101j
.text$mn:00001898                 mov     ecx, [ebp+var_C]
.text$mn:0000189B                 mov     large fs:0, ecx
.text$mn:000018A2                 pop     ecx
.text$mn:000018A3                 mov     esp, ebp
.text$mn:000018A5                 pop     ebp
.text$mn:000018A6                 retn    4
.text$mn:000018A6 ?releaseID@ReBar@@AAEXH@Z endp
.text$mn:000018A6
.text$mn:000018A6 ; ---------------------------------------------------------------------------
.text$mn:000018A9                 align 10h
.text$mn:000018B0
.text$mn:000018B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018B0
.text$mn:000018B0 ; Attributes: bp-based frame
.text$mn:000018B0
.text$mn:000018B0 ; bool __thiscall ReBar::isIDTaken(ReBar *this, int)
.text$mn:000018B0                 public ?isIDTaken@ReBar@@AAE_NH@Z
.text$mn:000018B0 ?isIDTaken@ReBar@@AAE_NH@Z proc near    ; CODE XREF: ReBar::addBand(tagREBARBANDINFOW *,bool)+60p
.text$mn:000018B0
.text$mn:000018B0 var_C           = dword ptr -0Ch
.text$mn:000018B0 var_8           = dword ptr -8
.text$mn:000018B0 var_4           = dword ptr -4
.text$mn:000018B0 arg_0           = dword ptr  8
.text$mn:000018B0
.text$mn:000018B0                 push    ebp
.text$mn:000018B1                 mov     ebp, esp
.text$mn:000018B3                 sub     esp, 0Ch
.text$mn:000018B6                 mov     [ebp+var_8], ecx
.text$mn:000018B9                 mov     ecx, [ebp+var_8]
.text$mn:000018BC                 add     ecx, 10h
.text$mn:000018BF                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:000018C4                 mov     [ebp+var_C], eax
.text$mn:000018C7                 mov     [ebp+var_4], 0
.text$mn:000018CE                 jmp     short loc_18D9
.text$mn:000018D0 ; ---------------------------------------------------------------------------
.text$mn:000018D0
.text$mn:000018D0 loc_18D0:                               ; CODE XREF: ReBar::isIDTaken(int):loc_18FBj
.text$mn:000018D0                 mov     eax, [ebp+var_4]
.text$mn:000018D3                 add     eax, 1
.text$mn:000018D6                 mov     [ebp+var_4], eax
.text$mn:000018D9
.text$mn:000018D9 loc_18D9:                               ; CODE XREF: ReBar::isIDTaken(int)+1Ej
.text$mn:000018D9                 mov     ecx, [ebp+var_4]
.text$mn:000018DC                 cmp     ecx, [ebp+var_C]
.text$mn:000018DF                 jnb     short loc_18FD
.text$mn:000018E1                 mov     edx, [ebp+var_4]
.text$mn:000018E4                 push    edx
.text$mn:000018E5                 mov     ecx, [ebp+var_8]
.text$mn:000018E8                 add     ecx, 10h
.text$mn:000018EB                 call    ?at@?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int>>::at(uint)
.text$mn:000018F0                 mov     eax, [eax]
.text$mn:000018F2                 cmp     eax, [ebp+arg_0]
.text$mn:000018F5                 jnz     short loc_18FB
.text$mn:000018F7                 mov     al, 1
.text$mn:000018F9                 jmp     short loc_18FF
.text$mn:000018FB ; ---------------------------------------------------------------------------
.text$mn:000018FB
.text$mn:000018FB loc_18FB:                               ; CODE XREF: ReBar::isIDTaken(int)+45j
.text$mn:000018FB                 jmp     short loc_18D0
.text$mn:000018FD ; ---------------------------------------------------------------------------
.text$mn:000018FD
.text$mn:000018FD loc_18FD:                               ; CODE XREF: ReBar::isIDTaken(int)+2Fj
.text$mn:000018FD                 xor     al, al
.text$mn:000018FF
.text$mn:000018FF loc_18FF:                               ; CODE XREF: ReBar::isIDTaken(int)+49j
.text$mn:000018FF                 mov     esp, ebp
.text$mn:00001901                 pop     ebp
.text$mn:00001902                 retn    4
.text$mn:00001902 ?isIDTaken@ReBar@@AAE_NH@Z endp
.text$mn:00001902
.text$mn:00001902 ; ---------------------------------------------------------------------------
.text$mn:00001905                 align 4
.text$mn:00001905 _text$mn        ends
.text$mn:00001905
.text$x:00001908 ; ===========================================================================
.text$x:00001908
.text$x:00001908 ; Segment type: Pure code
.text$x:00001908 ; Segment permissions: Read/Execute
.text$x:00001908 _text$x         segment para public 'CODE' use32
.text$x:00001908                 assume cs:_text$x
.text$x:00001908                 ;org 1908h
.text$x:00001908                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001908
.text$x:00001908 ; =============== S U B R O U T I N E =======================================
.text$x:00001908
.text$x:00001908
.text$x:00001908 __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$0 proc near
.text$x:00001908                                         ; DATA XREF: .xdata$x:000081C4o
.text$x:00001908                 lea     ecx, [ebp-2Ch]
.text$x:0000190B                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000190B __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$0 endp
.text$x:0000190B
.text$x:00001910
.text$x:00001910 ; =============== S U B R O U T I N E =======================================
.text$x:00001910
.text$x:00001910
.text$x:00001910 __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$1 proc near
.text$x:00001910                                         ; DATA XREF: .xdata$x:000081CCo
.text$x:00001910                 mov     ecx, [ebp-12Ch]
.text$x:00001916                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001916 __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$1 endp
.text$x:00001916
.text$x:0000191B
.text$x:0000191B ; =============== S U B R O U T I N E =======================================
.text$x:0000191B
.text$x:0000191B
.text$x:0000191B __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$2 proc near
.text$x:0000191B                                         ; DATA XREF: .xdata$x:000081D4o
.text$x:0000191B                 lea     ecx, [ebp-0D0h] ; this
.text$x:00001921                 jmp     ??1iconLocator@@QAE@XZ ; iconLocator::~iconLocator(void)
.text$x:00001921 __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$2 endp
.text$x:00001921
.text$x:00001926
.text$x:00001926 ; =============== S U B R O U T I N E =======================================
.text$x:00001926
.text$x:00001926
.text$x:00001926 __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$3 proc near
.text$x:00001926                                         ; DATA XREF: .xdata$x:000081DCo
.text$x:00001926                 lea     ecx, [ebp-64h]
.text$x:00001929                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001929 __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$3 endp
.text$x:00001929
.text$x:0000192E
.text$x:0000192E ; =============== S U B R O U T I N E =======================================
.text$x:0000192E
.text$x:0000192E
.text$x:0000192E __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$4 proc near
.text$x:0000192E                                         ; DATA XREF: .xdata$x:000081E4o
.text$x:0000192E                 mov     ecx, [ebp-130h]
.text$x:00001934                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001934 __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$4 endp
.text$x:00001934
.text$x:00001939
.text$x:00001939 ; =============== S U B R O U T I N E =======================================
.text$x:00001939
.text$x:00001939
.text$x:00001939 __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$5 proc near
.text$x:00001939                                         ; DATA XREF: .xdata$x:000081ECo
.text$x:00001939                 lea     ecx, [ebp-0ACh] ; this
.text$x:0000193F                 jmp     ??1iconLocator@@QAE@XZ ; iconLocator::~iconLocator(void)
.text$x:0000193F __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$5 endp
.text$x:0000193F
.text$x:00001944
.text$x:00001944 ; =============== S U B R O U T I N E =======================================
.text$x:00001944
.text$x:00001944
.text$x:00001944 __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$6 proc near
.text$x:00001944                                         ; DATA XREF: .xdata$x:000081F4o
.text$x:00001944                 lea     ecx, [ebp-48h]
.text$x:00001947                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001947 __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$6 endp
.text$x:00001947
.text$x:0000194C
.text$x:0000194C ; =============== S U B R O U T I N E =======================================
.text$x:0000194C
.text$x:0000194C
.text$x:0000194C __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$7 proc near
.text$x:0000194C                                         ; DATA XREF: .xdata$x:000081FCo
.text$x:0000194C                 mov     ecx, [ebp-128h]
.text$x:00001952                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001952 __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$7 endp
.text$x:00001952
.text$x:00001957
.text$x:00001957 ; =============== S U B R O U T I N E =======================================
.text$x:00001957
.text$x:00001957
.text$x:00001957 __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$8 proc near
.text$x:00001957                                         ; DATA XREF: .xdata$x:00008204o
.text$x:00001957                 lea     ecx, [ebp-88h]  ; this
.text$x:0000195D                 jmp     ??1iconLocator@@QAE@XZ ; iconLocator::~iconLocator(void)
.text$x:0000195D __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$8 endp
.text$x:0000195D
.text$x:00001962
.text$x:00001962 ; =============== S U B R O U T I N E =======================================
.text$x:00001962
.text$x:00001962
.text$x:00001962 __ehhandler$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z proc near
.text$x:00001962                                         ; DATA XREF: ToolBar::initTheme(TiXmlDocument *)+5o
.text$x:00001962
.text$x:00001962 arg_4           = dword ptr  8
.text$x:00001962
.text$x:00001962                 mov     edx, [esp+arg_4]
.text$x:00001966                 lea     eax, [edx+0Ch]
.text$x:00001969                 mov     ecx, [edx-134h]
.text$x:0000196F                 xor     ecx, eax
.text$x:00001971                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001976                 mov     ecx, [edx-4]
.text$x:00001979                 xor     ecx, eax
.text$x:0000197B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001980                 mov     eax, offset __ehfuncinfo$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z
.text$x:00001985                 jmp     ___CxxFrameHandler3
.text$x:00001985 __ehhandler$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z endp
.text$x:00001985
.text$x:0000198A
.text$x:0000198A ; =============== S U B R O U T I N E =======================================
.text$x:0000198A
.text$x:0000198A
.text$x:0000198A __unwindfunclet$?doPopop@ToolBar@@QAEXUtagPOINT@@@Z$0 proc near
.text$x:0000198A                                         ; DATA XREF: .xdata$x:00008138o
.text$x:0000198A                 lea     ecx, [ebp-3Ch]
.text$x:0000198D                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000198D __unwindfunclet$?doPopop@ToolBar@@QAEXUtagPOINT@@@Z$0 endp
.text$x:0000198D
.text$x:00001992
.text$x:00001992 ; =============== S U B R O U T I N E =======================================
.text$x:00001992
.text$x:00001992
.text$x:00001992 __ehhandler$?doPopop@ToolBar@@QAEXUtagPOINT@@@Z proc near
.text$x:00001992                                         ; DATA XREF: ToolBar::doPopop(tagPOINT)+5o
.text$x:00001992
.text$x:00001992 arg_4           = dword ptr  8
.text$x:00001992
.text$x:00001992                 mov     edx, [esp+arg_4]
.text$x:00001996                 lea     eax, [edx+0Ch]
.text$x:00001999                 mov     ecx, [edx-48h]
.text$x:0000199C                 xor     ecx, eax
.text$x:0000199E                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019A3                 mov     ecx, [edx-4]
.text$x:000019A6                 xor     ecx, eax
.text$x:000019A8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019AD                 mov     eax, offset __ehfuncinfo$?doPopop@ToolBar@@QAEXUtagPOINT@@@Z
.text$x:000019B2                 jmp     ___CxxFrameHandler3
.text$x:000019B2 __ehhandler$?doPopop@ToolBar@@QAEXUtagPOINT@@@Z endp
.text$x:000019B2
.text$x:000019B7
.text$x:000019B7 ; =============== S U B R O U T I N E =======================================
.text$x:000019B7
.text$x:000019B7
.text$x:000019B7 __unwindfunclet$?releaseID@ReBar@@AAEXH@Z$0 proc near
.text$x:000019B7                                         ; DATA XREF: .xdata$x:00008140o
.text$x:000019B7                 lea     ecx, [ebp-5Ch]
.text$x:000019BA                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000019BA __unwindfunclet$?releaseID@ReBar@@AAEXH@Z$0 endp
.text$x:000019BA
.text$x:000019BF
.text$x:000019BF ; =============== S U B R O U T I N E =======================================
.text$x:000019BF
.text$x:000019BF
.text$x:000019BF __unwindfunclet$?releaseID@ReBar@@AAEXH@Z$1 proc near
.text$x:000019BF                                         ; DATA XREF: .xdata$x:00008148o
.text$x:000019BF                 lea     ecx, [ebp-50h]
.text$x:000019C2                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000019C2 __unwindfunclet$?releaseID@ReBar@@AAEXH@Z$1 endp
.text$x:000019C2
.text$x:000019C7
.text$x:000019C7 ; =============== S U B R O U T I N E =======================================
.text$x:000019C7
.text$x:000019C7
.text$x:000019C7 __unwindfunclet$?releaseID@ReBar@@AAEXH@Z$2 proc near
.text$x:000019C7                                         ; DATA XREF: .xdata$x:00008150o
.text$x:000019C7                 mov     ecx, [ebp-30h]
.text$x:000019CA                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000019CA __unwindfunclet$?releaseID@ReBar@@AAEXH@Z$2 endp
.text$x:000019CA
.text$x:000019CF
.text$x:000019CF ; =============== S U B R O U T I N E =======================================
.text$x:000019CF
.text$x:000019CF
.text$x:000019CF __ehhandler$?releaseID@ReBar@@AAEXH@Z proc near
.text$x:000019CF                                         ; DATA XREF: ReBar::releaseID(int)+5o
.text$x:000019CF
.text$x:000019CF arg_4           = dword ptr  8
.text$x:000019CF
.text$x:000019CF                 mov     edx, [esp+arg_4]
.text$x:000019D3                 lea     eax, [edx+0Ch]
.text$x:000019D6                 mov     ecx, [edx-54h]
.text$x:000019D9                 xor     ecx, eax
.text$x:000019DB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019E0                 mov     eax, offset __ehfuncinfo$?releaseID@ReBar@@AAEXH@Z
.text$x:000019E5                 jmp     ___CxxFrameHandler3
.text$x:000019E5 __ehhandler$?releaseID@ReBar@@AAEXH@Z endp
.text$x:000019E5
.text$x:000019E5 ; ---------------------------------------------------------------------------
.text$x:000019EA                 align 4
.text$x:000019EA _text$x         ends
.text$x:000019EA
.text$mn:000019EC ; ===========================================================================
.text$mn:000019EC
.text$mn:000019EC ; Segment type: Pure code
.text$mn:000019EC ; Segment permissions: Read/Execute
.text$mn:000019EC _text$mn        segment para public 'CODE' use32
.text$mn:000019EC                 assume cs:_text$mn
.text$mn:000019EC                 ;org 19ECh
.text$mn:000019EC ; COMDAT (pick any)
.text$mn:000019EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019EC
.text$mn:000019EC ; =============== S U B R O U T I N E =======================================
.text$mn:000019EC
.text$mn:000019EC ; Attributes: bp-based frame
.text$mn:000019EC
.text$mn:000019EC ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:000019EC                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:000019EC ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:000019EC                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:000019EC
.text$mn:000019EC var_4           = dword ptr -4
.text$mn:000019EC arg_0           = dword ptr  8
.text$mn:000019EC
.text$mn:000019EC                 push    ebp
.text$mn:000019ED                 mov     ebp, esp
.text$mn:000019EF                 push    ecx
.text$mn:000019F0                 mov     [ebp+var_4], 0
.text$mn:000019F7                 cmp     [ebp+arg_0], 0
.text$mn:000019FB                 jnz     short loc_19FF
.text$mn:000019FD                 jmp     short loc_1A1F
.text$mn:000019FF ; ---------------------------------------------------------------------------
.text$mn:000019FF
.text$mn:000019FF loc_19FF:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000019FF                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00001A03                 ja      short loc_1A1A
.text$mn:00001A05                 mov     eax, [ebp+arg_0]
.text$mn:00001A08                 push    eax             ; unsigned int
.text$mn:00001A09                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001A0E                 add     esp, 4
.text$mn:00001A11                 mov     [ebp+var_4], eax
.text$mn:00001A14                 cmp     [ebp+var_4], 0
.text$mn:00001A18                 jnz     short loc_1A1F
.text$mn:00001A1A
.text$mn:00001A1A loc_1A1A:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00001A1A                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001A1F
.text$mn:00001A1F loc_1A1F:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00001A1F                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00001A1F                 mov     eax, [ebp+var_4]
.text$mn:00001A22                 mov     esp, ebp
.text$mn:00001A24                 pop     ebp
.text$mn:00001A25                 retn
.text$mn:00001A25 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00001A25
.text$mn:00001A25 ; ---------------------------------------------------------------------------
.text$mn:00001A26                 align 4
.text$mn:00001A26 _text$mn        ends
.text$mn:00001A26
.text$mn:00001A28 ; ===========================================================================
.text$mn:00001A28
.text$mn:00001A28 ; Segment type: Pure code
.text$mn:00001A28 ; Segment permissions: Read/Execute
.text$mn:00001A28 _text$mn        segment para public 'CODE' use32
.text$mn:00001A28                 assume cs:_text$mn
.text$mn:00001A28                 ;org 1A28h
.text$mn:00001A28 ; COMDAT (pick any)
.text$mn:00001A28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A28
.text$mn:00001A28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A28
.text$mn:00001A28 ; Attributes: bp-based frame
.text$mn:00001A28
.text$mn:00001A28 ; int * __cdecl std::_Allocate<int>(unsigned int, int *)
.text$mn:00001A28                 public ??$_Allocate@H@std@@YAPAHIPAH@Z
.text$mn:00001A28 ??$_Allocate@H@std@@YAPAHIPAH@Z proc near
.text$mn:00001A28                                         ; CODE XREF: std::allocator<int>::allocate(uint)+Dp
.text$mn:00001A28
.text$mn:00001A28 var_4           = dword ptr -4
.text$mn:00001A28 arg_0           = dword ptr  8
.text$mn:00001A28
.text$mn:00001A28                 push    ebp
.text$mn:00001A29                 mov     ebp, esp
.text$mn:00001A2B                 push    ecx
.text$mn:00001A2C                 mov     [ebp+var_4], 0
.text$mn:00001A33                 cmp     [ebp+arg_0], 0
.text$mn:00001A37                 jnz     short loc_1A3B
.text$mn:00001A39                 jmp     short loc_1A61
.text$mn:00001A3B ; ---------------------------------------------------------------------------
.text$mn:00001A3B
.text$mn:00001A3B loc_1A3B:                               ; CODE XREF: std::_Allocate<int>(uint,int *)+Fj
.text$mn:00001A3B                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:00001A42                 ja      short loc_1A5C
.text$mn:00001A44                 mov     eax, [ebp+arg_0]
.text$mn:00001A47                 shl     eax, 2
.text$mn:00001A4A                 push    eax             ; unsigned int
.text$mn:00001A4B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001A50                 add     esp, 4
.text$mn:00001A53                 mov     [ebp+var_4], eax
.text$mn:00001A56                 cmp     [ebp+var_4], 0
.text$mn:00001A5A                 jnz     short loc_1A61
.text$mn:00001A5C
.text$mn:00001A5C loc_1A5C:                               ; CODE XREF: std::_Allocate<int>(uint,int *)+1Aj
.text$mn:00001A5C                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001A61
.text$mn:00001A61 loc_1A61:                               ; CODE XREF: std::_Allocate<int>(uint,int *)+11j
.text$mn:00001A61                                         ; std::_Allocate<int>(uint,int *)+32j
.text$mn:00001A61                 mov     eax, [ebp+var_4]
.text$mn:00001A64                 mov     esp, ebp
.text$mn:00001A66                 pop     ebp
.text$mn:00001A67                 retn
.text$mn:00001A67 ??$_Allocate@H@std@@YAPAHIPAH@Z endp
.text$mn:00001A67
.text$mn:00001A67 _text$mn        ends
.text$mn:00001A67
.text$mn:00001A68 ; ===========================================================================
.text$mn:00001A68
.text$mn:00001A68 ; Segment type: Pure code
.text$mn:00001A68 ; Segment permissions: Read/Execute
.text$mn:00001A68 _text$mn        segment para public 'CODE' use32
.text$mn:00001A68                 assume cs:_text$mn
.text$mn:00001A68                 ;org 1A68h
.text$mn:00001A68 ; COMDAT (pick any)
.text$mn:00001A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A68
.text$mn:00001A68 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A68
.text$mn:00001A68 ; Attributes: bp-based frame
.text$mn:00001A68
.text$mn:00001A68 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00001A68                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00001A68 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00001A68                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00001A68
.text$mn:00001A68 var_4           = dword ptr -4
.text$mn:00001A68 arg_0           = dword ptr  8
.text$mn:00001A68
.text$mn:00001A68                 push    ebp
.text$mn:00001A69                 mov     ebp, esp
.text$mn:00001A6B                 push    ecx
.text$mn:00001A6C                 mov     [ebp+var_4], 0
.text$mn:00001A73                 cmp     [ebp+arg_0], 0
.text$mn:00001A77                 jnz     short loc_1A7B
.text$mn:00001A79                 jmp     short loc_1AA1
.text$mn:00001A7B ; ---------------------------------------------------------------------------
.text$mn:00001A7B
.text$mn:00001A7B loc_1A7B:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00001A7B                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00001A82                 ja      short loc_1A9C
.text$mn:00001A84                 mov     eax, [ebp+arg_0]
.text$mn:00001A87                 shl     eax, 3
.text$mn:00001A8A                 push    eax             ; unsigned int
.text$mn:00001A8B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001A90                 add     esp, 4
.text$mn:00001A93                 mov     [ebp+var_4], eax
.text$mn:00001A96                 cmp     [ebp+var_4], 0
.text$mn:00001A9A                 jnz     short loc_1AA1
.text$mn:00001A9C
.text$mn:00001A9C loc_1A9C:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00001A9C                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001AA1
.text$mn:00001AA1 loc_1AA1:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00001AA1                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00001AA1                 mov     eax, [ebp+var_4]
.text$mn:00001AA4                 mov     esp, ebp
.text$mn:00001AA6                 pop     ebp
.text$mn:00001AA7                 retn
.text$mn:00001AA7 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00001AA7
.text$mn:00001AA7 _text$mn        ends
.text$mn:00001AA7
.text$mn:00001AA8 ; ===========================================================================
.text$mn:00001AA8
.text$mn:00001AA8 ; Segment type: Pure code
.text$mn:00001AA8 ; Segment permissions: Read/Execute
.text$mn:00001AA8 _text$mn        segment para public 'CODE' use32
.text$mn:00001AA8                 assume cs:_text$mn
.text$mn:00001AA8                 ;org 1AA8h
.text$mn:00001AA8 ; COMDAT (pick any)
.text$mn:00001AA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AA8
.text$mn:00001AA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AA8
.text$mn:00001AA8 ; Attributes: bp-based frame
.text$mn:00001AA8
.text$mn:00001AA8 ; struct iconLocator * __cdecl std::_Allocate<struct iconLocator>(unsigned int, struct iconLocator *)
.text$mn:00001AA8                 public ??$_Allocate@UiconLocator@@@std@@YAPAUiconLocator@@IPAU1@@Z
.text$mn:00001AA8 ??$_Allocate@UiconLocator@@@std@@YAPAUiconLocator@@IPAU1@@Z proc near
.text$mn:00001AA8                                         ; CODE XREF: std::allocator<iconLocator>::allocate(uint)+Dp
.text$mn:00001AA8
.text$mn:00001AA8 var_4           = dword ptr -4
.text$mn:00001AA8 arg_0           = dword ptr  8
.text$mn:00001AA8
.text$mn:00001AA8                 push    ebp
.text$mn:00001AA9                 mov     ebp, esp
.text$mn:00001AAB                 push    ecx
.text$mn:00001AAC                 mov     [ebp+var_4], 0
.text$mn:00001AB3                 cmp     [ebp+arg_0], 0
.text$mn:00001AB7                 jnz     short loc_1ABB
.text$mn:00001AB9                 jmp     short loc_1ADF
.text$mn:00001ABB ; ---------------------------------------------------------------------------
.text$mn:00001ABB
.text$mn:00001ABB loc_1ABB:                               ; CODE XREF: std::_Allocate<iconLocator>(uint,iconLocator *)+Fj
.text$mn:00001ABB                 cmp     [ebp+arg_0], 71C71C7h
.text$mn:00001AC2                 ja      short loc_1ADA
.text$mn:00001AC4                 imul    eax, [ebp+arg_0], 24h
.text$mn:00001AC8                 push    eax             ; unsigned int
.text$mn:00001AC9                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001ACE                 add     esp, 4
.text$mn:00001AD1                 mov     [ebp+var_4], eax
.text$mn:00001AD4                 cmp     [ebp+var_4], 0
.text$mn:00001AD8                 jnz     short loc_1ADF
.text$mn:00001ADA
.text$mn:00001ADA loc_1ADA:                               ; CODE XREF: std::_Allocate<iconLocator>(uint,iconLocator *)+1Aj
.text$mn:00001ADA                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001ADF
.text$mn:00001ADF loc_1ADF:                               ; CODE XREF: std::_Allocate<iconLocator>(uint,iconLocator *)+11j
.text$mn:00001ADF                                         ; std::_Allocate<iconLocator>(uint,iconLocator *)+30j
.text$mn:00001ADF                 mov     eax, [ebp+var_4]
.text$mn:00001AE2                 mov     esp, ebp
.text$mn:00001AE4                 pop     ebp
.text$mn:00001AE5                 retn
.text$mn:00001AE5 ??$_Allocate@UiconLocator@@@std@@YAPAUiconLocator@@IPAU1@@Z endp
.text$mn:00001AE5
.text$mn:00001AE5 ; ---------------------------------------------------------------------------
.text$mn:00001AE6                 align 4
.text$mn:00001AE6 _text$mn        ends
.text$mn:00001AE6
.text$mn:00001AE8 ; ===========================================================================
.text$mn:00001AE8
.text$mn:00001AE8 ; Segment type: Pure code
.text$mn:00001AE8 ; Segment permissions: Read/Execute
.text$mn:00001AE8 _text$mn        segment para public 'CODE' use32
.text$mn:00001AE8                 assume cs:_text$mn
.text$mn:00001AE8                 ;org 1AE8h
.text$mn:00001AE8 ; COMDAT (pick any)
.text$mn:00001AE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001AE8
.text$mn:00001AE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AE8
.text$mn:00001AE8 ; Attributes: bp-based frame
.text$mn:00001AE8
.text$mn:00001AE8 ; struct tDynamicList * __cdecl std::_Allocate<struct tDynamicList>(unsigned int, struct tDynamicList *)
.text$mn:00001AE8                 public ??$_Allocate@UtDynamicList@@@std@@YAPAUtDynamicList@@IPAU1@@Z
.text$mn:00001AE8 ??$_Allocate@UtDynamicList@@@std@@YAPAUtDynamicList@@IPAU1@@Z proc near
.text$mn:00001AE8                                         ; CODE XREF: std::allocator<tDynamicList>::allocate(uint)+Dp
.text$mn:00001AE8
.text$mn:00001AE8 var_4           = dword ptr -4
.text$mn:00001AE8 arg_0           = dword ptr  8
.text$mn:00001AE8
.text$mn:00001AE8                 push    ebp
.text$mn:00001AE9                 mov     ebp, esp
.text$mn:00001AEB                 push    ecx
.text$mn:00001AEC                 mov     [ebp+var_4], 0
.text$mn:00001AF3                 cmp     [ebp+arg_0], 0
.text$mn:00001AF7                 jnz     short loc_1AFB
.text$mn:00001AF9                 jmp     short loc_1B1F
.text$mn:00001AFB ; ---------------------------------------------------------------------------
.text$mn:00001AFB
.text$mn:00001AFB loc_1AFB:                               ; CODE XREF: std::_Allocate<tDynamicList>(uint,tDynamicList *)+Fj
.text$mn:00001AFB                 cmp     [ebp+arg_0], 15555555h
.text$mn:00001B02                 ja      short loc_1B1A
.text$mn:00001B04                 imul    eax, [ebp+arg_0], 0Ch
.text$mn:00001B08                 push    eax             ; unsigned int
.text$mn:00001B09                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001B0E                 add     esp, 4
.text$mn:00001B11                 mov     [ebp+var_4], eax
.text$mn:00001B14                 cmp     [ebp+var_4], 0
.text$mn:00001B18                 jnz     short loc_1B1F
.text$mn:00001B1A
.text$mn:00001B1A loc_1B1A:                               ; CODE XREF: std::_Allocate<tDynamicList>(uint,tDynamicList *)+1Aj
.text$mn:00001B1A                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001B1F
.text$mn:00001B1F loc_1B1F:                               ; CODE XREF: std::_Allocate<tDynamicList>(uint,tDynamicList *)+11j
.text$mn:00001B1F                                         ; std::_Allocate<tDynamicList>(uint,tDynamicList *)+30j
.text$mn:00001B1F                 mov     eax, [ebp+var_4]
.text$mn:00001B22                 mov     esp, ebp
.text$mn:00001B24                 pop     ebp
.text$mn:00001B25                 retn
.text$mn:00001B25 ??$_Allocate@UtDynamicList@@@std@@YAPAUtDynamicList@@IPAU1@@Z endp
.text$mn:00001B25
.text$mn:00001B25 ; ---------------------------------------------------------------------------
.text$mn:00001B26                 align 4
.text$mn:00001B26 _text$mn        ends
.text$mn:00001B26
.text$mn:00001B28 ; ===========================================================================
.text$mn:00001B28
.text$mn:00001B28 ; Segment type: Pure code
.text$mn:00001B28 ; Segment permissions: Read/Execute
.text$mn:00001B28 _text$mn        segment para public 'CODE' use32
.text$mn:00001B28                 assume cs:_text$mn
.text$mn:00001B28                 ;org 1B28h
.text$mn:00001B28 ; COMDAT (pick any)
.text$mn:00001B28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B28
.text$mn:00001B28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B28
.text$mn:00001B28 ; Attributes: bp-based frame
.text$mn:00001B28
.text$mn:00001B28 ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:00001B28                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:00001B28 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:00001B28                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:00001B28
.text$mn:00001B28 var_4           = dword ptr -4
.text$mn:00001B28 arg_0           = dword ptr  8
.text$mn:00001B28
.text$mn:00001B28                 push    ebp
.text$mn:00001B29                 mov     ebp, esp
.text$mn:00001B2B                 push    ecx
.text$mn:00001B2C                 mov     [ebp+var_4], 0
.text$mn:00001B33                 cmp     [ebp+arg_0], 0
.text$mn:00001B37                 jnz     short loc_1B3B
.text$mn:00001B39                 jmp     short loc_1B60
.text$mn:00001B3B ; ---------------------------------------------------------------------------
.text$mn:00001B3B
.text$mn:00001B3B loc_1B3B:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:00001B3B                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:00001B42                 ja      short loc_1B5B
.text$mn:00001B44                 mov     eax, [ebp+arg_0]
.text$mn:00001B47                 shl     eax, 1
.text$mn:00001B49                 push    eax             ; unsigned int
.text$mn:00001B4A                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001B4F                 add     esp, 4
.text$mn:00001B52                 mov     [ebp+var_4], eax
.text$mn:00001B55                 cmp     [ebp+var_4], 0
.text$mn:00001B59                 jnz     short loc_1B60
.text$mn:00001B5B
.text$mn:00001B5B loc_1B5B:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:00001B5B                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001B60
.text$mn:00001B60 loc_1B60:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:00001B60                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:00001B60                 mov     eax, [ebp+var_4]
.text$mn:00001B63                 mov     esp, ebp
.text$mn:00001B65                 pop     ebp
.text$mn:00001B66                 retn
.text$mn:00001B66 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:00001B66
.text$mn:00001B66 ; ---------------------------------------------------------------------------
.text$mn:00001B67                 align 4
.text$mn:00001B67 _text$mn        ends
.text$mn:00001B67
.text$mn:00001B68 ; ===========================================================================
.text$mn:00001B68
.text$mn:00001B68 ; Segment type: Pure code
.text$mn:00001B68 ; Segment permissions: Read/Execute
.text$mn:00001B68 _text$mn        segment para public 'CODE' use32
.text$mn:00001B68                 assume cs:_text$mn
.text$mn:00001B68                 ;org 1B68h
.text$mn:00001B68 ; COMDAT (pick any)
.text$mn:00001B68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B68
.text$mn:00001B68 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B68
.text$mn:00001B68 ; Attributes: bp-based frame
.text$mn:00001B68
.text$mn:00001B68 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00001B68                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00001B68 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00001B68                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00001B68                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00001B68
.text$mn:00001B68 arg_0           = dword ptr  8
.text$mn:00001B68 arg_4           = dword ptr  0Ch
.text$mn:00001B68 arg_8           = dword ptr  10h
.text$mn:00001B68
.text$mn:00001B68                 push    ebp
.text$mn:00001B69                 mov     ebp, esp
.text$mn:00001B6B                 cmp     [ebp+arg_0], 0
.text$mn:00001B6F                 jnz     short loc_1B86
.text$mn:00001B71                 mov     eax, [ebp+arg_8]
.text$mn:00001B74                 push    eax             ; unsigned int
.text$mn:00001B75                 mov     ecx, [ebp+arg_4]
.text$mn:00001B78                 push    ecx             ; wchar_t *
.text$mn:00001B79                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001B7E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001B83                 add     esp, 0Ch
.text$mn:00001B86
.text$mn:00001B86 loc_1B86:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00001B86                 pop     ebp
.text$mn:00001B87                 retn
.text$mn:00001B87 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00001B87
.text$mn:00001B87 _text$mn        ends
.text$mn:00001B87
.text$mn:00001B88 ; ===========================================================================
.text$mn:00001B88
.text$mn:00001B88 ; Segment type: Pure code
.text$mn:00001B88 ; Segment permissions: Read/Execute
.text$mn:00001B88 _text$mn        segment para public 'CODE' use32
.text$mn:00001B88                 assume cs:_text$mn
.text$mn:00001B88                 ;org 1B88h
.text$mn:00001B88 ; COMDAT (pick any)
.text$mn:00001B88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B88
.text$mn:00001B88 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B88
.text$mn:00001B88 ; Attributes: bp-based frame
.text$mn:00001B88
.text$mn:00001B88 ; int __cdecl std::_Debug_pointer<int>(int, wchar_t *, unsigned int)
.text$mn:00001B88                 public ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z
.text$mn:00001B88 ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z proc near
.text$mn:00001B88                                         ; CODE XREF: std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00001B88                                         ; std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00001B88
.text$mn:00001B88 arg_0           = dword ptr  8
.text$mn:00001B88 arg_4           = dword ptr  0Ch
.text$mn:00001B88 arg_8           = dword ptr  10h
.text$mn:00001B88
.text$mn:00001B88                 push    ebp
.text$mn:00001B89                 mov     ebp, esp
.text$mn:00001B8B                 cmp     [ebp+arg_0], 0
.text$mn:00001B8F                 jnz     short loc_1BA6
.text$mn:00001B91                 mov     eax, [ebp+arg_8]
.text$mn:00001B94                 push    eax             ; unsigned int
.text$mn:00001B95                 mov     ecx, [ebp+arg_4]
.text$mn:00001B98                 push    ecx             ; wchar_t *
.text$mn:00001B99                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001B9E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001BA3                 add     esp, 0Ch
.text$mn:00001BA6
.text$mn:00001BA6 loc_1BA6:                               ; CODE XREF: std::_Debug_pointer<int>(int *,wchar_t const *,uint)+7j
.text$mn:00001BA6                 pop     ebp
.text$mn:00001BA7                 retn
.text$mn:00001BA7 ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z endp
.text$mn:00001BA7
.text$mn:00001BA7 _text$mn        ends
.text$mn:00001BA7
.text$mn:00001BA8 ; ===========================================================================
.text$mn:00001BA8
.text$mn:00001BA8 ; Segment type: Pure code
.text$mn:00001BA8 ; Segment permissions: Read/Execute
.text$mn:00001BA8 _text$mn        segment para public 'CODE' use32
.text$mn:00001BA8                 assume cs:_text$mn
.text$mn:00001BA8                 ;org 1BA8h
.text$mn:00001BA8 ; COMDAT (pick any)
.text$mn:00001BA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BA8
.text$mn:00001BA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BA8
.text$mn:00001BA8 ; Attributes: bp-based frame
.text$mn:00001BA8
.text$mn:00001BA8 ; int __cdecl std::_Debug_pointer<iconLocator>(int, wchar_t *, unsigned int)
.text$mn:00001BA8                 public ??$_Debug_pointer@UiconLocator@@@std@@YAXPAUiconLocator@@PB_WI@Z
.text$mn:00001BA8 ??$_Debug_pointer@UiconLocator@@@std@@YAXPAUiconLocator@@PB_WI@Z proc near
.text$mn:00001BA8                                         ; CODE XREF: std::_Debug_range2<iconLocator *>(iconLocator *,iconLocator *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00001BA8                                         ; std::_Debug_range2<iconLocator *>(iconLocator *,iconLocator *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00001BA8
.text$mn:00001BA8 arg_0           = dword ptr  8
.text$mn:00001BA8 arg_4           = dword ptr  0Ch
.text$mn:00001BA8 arg_8           = dword ptr  10h
.text$mn:00001BA8
.text$mn:00001BA8                 push    ebp
.text$mn:00001BA9                 mov     ebp, esp
.text$mn:00001BAB                 cmp     [ebp+arg_0], 0
.text$mn:00001BAF                 jnz     short loc_1BC6
.text$mn:00001BB1                 mov     eax, [ebp+arg_8]
.text$mn:00001BB4                 push    eax             ; unsigned int
.text$mn:00001BB5                 mov     ecx, [ebp+arg_4]
.text$mn:00001BB8                 push    ecx             ; wchar_t *
.text$mn:00001BB9                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001BBE                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001BC3                 add     esp, 0Ch
.text$mn:00001BC6
.text$mn:00001BC6 loc_1BC6:                               ; CODE XREF: std::_Debug_pointer<iconLocator>(iconLocator *,wchar_t const *,uint)+7j
.text$mn:00001BC6                 pop     ebp
.text$mn:00001BC7                 retn
.text$mn:00001BC7 ??$_Debug_pointer@UiconLocator@@@std@@YAXPAUiconLocator@@PB_WI@Z endp
.text$mn:00001BC7
.text$mn:00001BC7 _text$mn        ends
.text$mn:00001BC7
.text$mn:00001BC8 ; ===========================================================================
.text$mn:00001BC8
.text$mn:00001BC8 ; Segment type: Pure code
.text$mn:00001BC8 ; Segment permissions: Read/Execute
.text$mn:00001BC8 _text$mn        segment para public 'CODE' use32
.text$mn:00001BC8                 assume cs:_text$mn
.text$mn:00001BC8                 ;org 1BC8h
.text$mn:00001BC8 ; COMDAT (pick any)
.text$mn:00001BC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BC8
.text$mn:00001BC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BC8
.text$mn:00001BC8 ; Attributes: bp-based frame
.text$mn:00001BC8
.text$mn:00001BC8 ; int __cdecl std::_Debug_pointer<tDynamicList>(int, wchar_t *, unsigned int)
.text$mn:00001BC8                 public ??$_Debug_pointer@UtDynamicList@@@std@@YAXPAUtDynamicList@@PB_WI@Z
.text$mn:00001BC8 ??$_Debug_pointer@UtDynamicList@@@std@@YAXPAUtDynamicList@@PB_WI@Z proc near
.text$mn:00001BC8                                         ; CODE XREF: std::_Debug_range2<tDynamicList *>(tDynamicList *,tDynamicList *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00001BC8                                         ; std::_Debug_range2<tDynamicList *>(tDynamicList *,tDynamicList *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00001BC8
.text$mn:00001BC8 arg_0           = dword ptr  8
.text$mn:00001BC8 arg_4           = dword ptr  0Ch
.text$mn:00001BC8 arg_8           = dword ptr  10h
.text$mn:00001BC8
.text$mn:00001BC8                 push    ebp
.text$mn:00001BC9                 mov     ebp, esp
.text$mn:00001BCB                 cmp     [ebp+arg_0], 0
.text$mn:00001BCF                 jnz     short loc_1BE6
.text$mn:00001BD1                 mov     eax, [ebp+arg_8]
.text$mn:00001BD4                 push    eax             ; unsigned int
.text$mn:00001BD5                 mov     ecx, [ebp+arg_4]
.text$mn:00001BD8                 push    ecx             ; wchar_t *
.text$mn:00001BD9                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001BDE                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001BE3                 add     esp, 0Ch
.text$mn:00001BE6
.text$mn:00001BE6 loc_1BE6:                               ; CODE XREF: std::_Debug_pointer<tDynamicList>(tDynamicList *,wchar_t const *,uint)+7j
.text$mn:00001BE6                 pop     ebp
.text$mn:00001BE7                 retn
.text$mn:00001BE7 ??$_Debug_pointer@UtDynamicList@@@std@@YAXPAUtDynamicList@@PB_WI@Z endp
.text$mn:00001BE7
.text$mn:00001BE7 _text$mn        ends
.text$mn:00001BE7
.text$mn:00001BE8 ; ===========================================================================
.text$mn:00001BE8
.text$mn:00001BE8 ; Segment type: Pure code
.text$mn:00001BE8 ; Segment permissions: Read/Execute
.text$mn:00001BE8 _text$mn        segment para public 'CODE' use32
.text$mn:00001BE8                 assume cs:_text$mn
.text$mn:00001BE8                 ;org 1BE8h
.text$mn:00001BE8 ; COMDAT (pick any)
.text$mn:00001BE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BE8
.text$mn:00001BE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BE8
.text$mn:00001BE8 ; Attributes: bp-based frame
.text$mn:00001BE8
.text$mn:00001BE8 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:00001BE8                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:00001BE8 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:00001BE8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+15p
.text$mn:00001BE8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+1Dp ...
.text$mn:00001BE8
.text$mn:00001BE8 arg_0           = dword ptr  8
.text$mn:00001BE8 arg_4           = dword ptr  0Ch
.text$mn:00001BE8 arg_8           = dword ptr  10h
.text$mn:00001BE8
.text$mn:00001BE8                 push    ebp
.text$mn:00001BE9                 mov     ebp, esp
.text$mn:00001BEB                 cmp     [ebp+arg_0], 0
.text$mn:00001BEF                 jnz     short loc_1C06
.text$mn:00001BF1                 mov     eax, [ebp+arg_8]
.text$mn:00001BF4                 push    eax             ; unsigned int
.text$mn:00001BF5                 mov     ecx, [ebp+arg_4]
.text$mn:00001BF8                 push    ecx             ; wchar_t *
.text$mn:00001BF9                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001BFE                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001C03                 add     esp, 0Ch
.text$mn:00001C06
.text$mn:00001C06 loc_1C06:                               ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:00001C06                 pop     ebp
.text$mn:00001C07                 retn
.text$mn:00001C07 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:00001C07
.text$mn:00001C07 _text$mn        ends
.text$mn:00001C07
.text$mn:00001C08 ; ===========================================================================
.text$mn:00001C08
.text$mn:00001C08 ; Segment type: Pure code
.text$mn:00001C08 ; Segment permissions: Read/Execute
.text$mn:00001C08 _text$mn        segment para public 'CODE' use32
.text$mn:00001C08                 assume cs:_text$mn
.text$mn:00001C08                 ;org 1C08h
.text$mn:00001C08 ; COMDAT (pick any)
.text$mn:00001C08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C08
.text$mn:00001C08 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C08
.text$mn:00001C08 ; Attributes: bp-based frame
.text$mn:00001C08
.text$mn:00001C08 ; int __cdecl std::_Debug_range2<int *>(int, int, wchar_t *, unsigned int)
.text$mn:00001C08                 public ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00001C08 ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00001C08                                         ; CODE XREF: std::_Debug_range<int *>(int *,int *,wchar_t const *,uint)+2Ap
.text$mn:00001C08
.text$mn:00001C08 arg_0           = dword ptr  8
.text$mn:00001C08 arg_4           = dword ptr  0Ch
.text$mn:00001C08 arg_8           = dword ptr  10h
.text$mn:00001C08 arg_C           = dword ptr  14h
.text$mn:00001C08
.text$mn:00001C08                 push    ebp
.text$mn:00001C09                 mov     ebp, esp
.text$mn:00001C0B                 mov     eax, [ebp+arg_0]
.text$mn:00001C0E                 cmp     eax, [ebp+arg_4]
.text$mn:00001C11                 jz      short loc_1C58
.text$mn:00001C13                 mov     ecx, [ebp+arg_C]
.text$mn:00001C16                 push    ecx             ; unsigned int
.text$mn:00001C17                 mov     edx, [ebp+arg_8]
.text$mn:00001C1A                 push    edx             ; wchar_t *
.text$mn:00001C1B                 mov     eax, [ebp+arg_0]
.text$mn:00001C1E                 push    eax             ; int
.text$mn:00001C1F                 call    ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)
.text$mn:00001C24                 add     esp, 0Ch
.text$mn:00001C27                 mov     ecx, [ebp+arg_C]
.text$mn:00001C2A                 push    ecx             ; unsigned int
.text$mn:00001C2B                 mov     edx, [ebp+arg_8]
.text$mn:00001C2E                 push    edx             ; wchar_t *
.text$mn:00001C2F                 mov     eax, [ebp+arg_4]
.text$mn:00001C32                 push    eax             ; int
.text$mn:00001C33                 call    ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)
.text$mn:00001C38                 add     esp, 0Ch
.text$mn:00001C3B                 mov     ecx, [ebp+arg_4]
.text$mn:00001C3E                 cmp     ecx, [ebp+arg_0]
.text$mn:00001C41                 jnb     short loc_1C58
.text$mn:00001C43                 mov     edx, [ebp+arg_C]
.text$mn:00001C46                 push    edx             ; unsigned int
.text$mn:00001C47                 mov     eax, [ebp+arg_8]
.text$mn:00001C4A                 push    eax             ; wchar_t *
.text$mn:00001C4B                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00001C50                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001C55                 add     esp, 0Ch
.text$mn:00001C58
.text$mn:00001C58 loc_1C58:                               ; CODE XREF: std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00001C58                                         ; std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00001C58                 pop     ebp
.text$mn:00001C59                 retn
.text$mn:00001C59 ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00001C59
.text$mn:00001C59 ; ---------------------------------------------------------------------------
.text$mn:00001C5A                 align 4
.text$mn:00001C5A _text$mn        ends
.text$mn:00001C5A
.text$mn:00001C5C ; ===========================================================================
.text$mn:00001C5C
.text$mn:00001C5C ; Segment type: Pure code
.text$mn:00001C5C ; Segment permissions: Read/Execute
.text$mn:00001C5C _text$mn        segment para public 'CODE' use32
.text$mn:00001C5C                 assume cs:_text$mn
.text$mn:00001C5C                 ;org 1C5Ch
.text$mn:00001C5C ; COMDAT (pick any)
.text$mn:00001C5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C5C
.text$mn:00001C5C ; =============== S U B R O U T I N E =======================================
.text$mn:00001C5C
.text$mn:00001C5C ; Attributes: bp-based frame
.text$mn:00001C5C
.text$mn:00001C5C ; int __cdecl std::_Debug_range2<iconLocator *>(int, int, wchar_t *, unsigned int)
.text$mn:00001C5C                 public ??$_Debug_range2@PAUiconLocator@@@std@@YAXPAUiconLocator@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00001C5C ??$_Debug_range2@PAUiconLocator@@@std@@YAXPAUiconLocator@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00001C5C                                         ; CODE XREF: std::_Debug_range<iconLocator *>(iconLocator *,iconLocator *,wchar_t const *,uint)+2Ap
.text$mn:00001C5C
.text$mn:00001C5C arg_0           = dword ptr  8
.text$mn:00001C5C arg_4           = dword ptr  0Ch
.text$mn:00001C5C arg_8           = dword ptr  10h
.text$mn:00001C5C arg_C           = dword ptr  14h
.text$mn:00001C5C
.text$mn:00001C5C                 push    ebp
.text$mn:00001C5D                 mov     ebp, esp
.text$mn:00001C5F                 mov     eax, [ebp+arg_0]
.text$mn:00001C62                 cmp     eax, [ebp+arg_4]
.text$mn:00001C65                 jz      short loc_1CAC
.text$mn:00001C67                 mov     ecx, [ebp+arg_C]
.text$mn:00001C6A                 push    ecx             ; unsigned int
.text$mn:00001C6B                 mov     edx, [ebp+arg_8]
.text$mn:00001C6E                 push    edx             ; wchar_t *
.text$mn:00001C6F                 mov     eax, [ebp+arg_0]
.text$mn:00001C72                 push    eax             ; int
.text$mn:00001C73                 call    ??$_Debug_pointer@UiconLocator@@@std@@YAXPAUiconLocator@@PB_WI@Z ; std::_Debug_pointer<iconLocator>(iconLocator *,wchar_t const *,uint)
.text$mn:00001C78                 add     esp, 0Ch
.text$mn:00001C7B                 mov     ecx, [ebp+arg_C]
.text$mn:00001C7E                 push    ecx             ; unsigned int
.text$mn:00001C7F                 mov     edx, [ebp+arg_8]
.text$mn:00001C82                 push    edx             ; wchar_t *
.text$mn:00001C83                 mov     eax, [ebp+arg_4]
.text$mn:00001C86                 push    eax             ; int
.text$mn:00001C87                 call    ??$_Debug_pointer@UiconLocator@@@std@@YAXPAUiconLocator@@PB_WI@Z ; std::_Debug_pointer<iconLocator>(iconLocator *,wchar_t const *,uint)
.text$mn:00001C8C                 add     esp, 0Ch
.text$mn:00001C8F                 mov     ecx, [ebp+arg_4]
.text$mn:00001C92                 cmp     ecx, [ebp+arg_0]
.text$mn:00001C95                 jnb     short loc_1CAC
.text$mn:00001C97                 mov     edx, [ebp+arg_C]
.text$mn:00001C9A                 push    edx             ; unsigned int
.text$mn:00001C9B                 mov     eax, [ebp+arg_8]
.text$mn:00001C9E                 push    eax             ; wchar_t *
.text$mn:00001C9F                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00001CA4                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001CA9                 add     esp, 0Ch
.text$mn:00001CAC
.text$mn:00001CAC loc_1CAC:                               ; CODE XREF: std::_Debug_range2<iconLocator *>(iconLocator *,iconLocator *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00001CAC                                         ; std::_Debug_range2<iconLocator *>(iconLocator *,iconLocator *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00001CAC                 pop     ebp
.text$mn:00001CAD                 retn
.text$mn:00001CAD ??$_Debug_range2@PAUiconLocator@@@std@@YAXPAUiconLocator@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00001CAD
.text$mn:00001CAD ; ---------------------------------------------------------------------------
.text$mn:00001CAE                 align 10h
.text$mn:00001CAE _text$mn        ends
.text$mn:00001CAE
.text$mn:00001CB0 ; ===========================================================================
.text$mn:00001CB0
.text$mn:00001CB0 ; Segment type: Pure code
.text$mn:00001CB0 ; Segment permissions: Read/Execute
.text$mn:00001CB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001CB0                 assume cs:_text$mn
.text$mn:00001CB0                 ;org 1CB0h
.text$mn:00001CB0 ; COMDAT (pick any)
.text$mn:00001CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CB0
.text$mn:00001CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CB0
.text$mn:00001CB0 ; Attributes: bp-based frame
.text$mn:00001CB0
.text$mn:00001CB0 ; int __cdecl std::_Debug_range2<tDynamicList *>(int, int, wchar_t *, unsigned int)
.text$mn:00001CB0                 public ??$_Debug_range2@PAUtDynamicList@@@std@@YAXPAUtDynamicList@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00001CB0 ??$_Debug_range2@PAUtDynamicList@@@std@@YAXPAUtDynamicList@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00001CB0                                         ; CODE XREF: std::_Debug_range<tDynamicList *>(tDynamicList *,tDynamicList *,wchar_t const *,uint)+2Ap
.text$mn:00001CB0
.text$mn:00001CB0 arg_0           = dword ptr  8
.text$mn:00001CB0 arg_4           = dword ptr  0Ch
.text$mn:00001CB0 arg_8           = dword ptr  10h
.text$mn:00001CB0 arg_C           = dword ptr  14h
.text$mn:00001CB0
.text$mn:00001CB0                 push    ebp
.text$mn:00001CB1                 mov     ebp, esp
.text$mn:00001CB3                 mov     eax, [ebp+arg_0]
.text$mn:00001CB6                 cmp     eax, [ebp+arg_4]
.text$mn:00001CB9                 jz      short loc_1D00
.text$mn:00001CBB                 mov     ecx, [ebp+arg_C]
.text$mn:00001CBE                 push    ecx             ; unsigned int
.text$mn:00001CBF                 mov     edx, [ebp+arg_8]
.text$mn:00001CC2                 push    edx             ; wchar_t *
.text$mn:00001CC3                 mov     eax, [ebp+arg_0]
.text$mn:00001CC6                 push    eax             ; int
.text$mn:00001CC7                 call    ??$_Debug_pointer@UtDynamicList@@@std@@YAXPAUtDynamicList@@PB_WI@Z ; std::_Debug_pointer<tDynamicList>(tDynamicList *,wchar_t const *,uint)
.text$mn:00001CCC                 add     esp, 0Ch
.text$mn:00001CCF                 mov     ecx, [ebp+arg_C]
.text$mn:00001CD2                 push    ecx             ; unsigned int
.text$mn:00001CD3                 mov     edx, [ebp+arg_8]
.text$mn:00001CD6                 push    edx             ; wchar_t *
.text$mn:00001CD7                 mov     eax, [ebp+arg_4]
.text$mn:00001CDA                 push    eax             ; int
.text$mn:00001CDB                 call    ??$_Debug_pointer@UtDynamicList@@@std@@YAXPAUtDynamicList@@PB_WI@Z ; std::_Debug_pointer<tDynamicList>(tDynamicList *,wchar_t const *,uint)
.text$mn:00001CE0                 add     esp, 0Ch
.text$mn:00001CE3                 mov     ecx, [ebp+arg_4]
.text$mn:00001CE6                 cmp     ecx, [ebp+arg_0]
.text$mn:00001CE9                 jnb     short loc_1D00
.text$mn:00001CEB                 mov     edx, [ebp+arg_C]
.text$mn:00001CEE                 push    edx             ; unsigned int
.text$mn:00001CEF                 mov     eax, [ebp+arg_8]
.text$mn:00001CF2                 push    eax             ; wchar_t *
.text$mn:00001CF3                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00001CF8                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001CFD                 add     esp, 0Ch
.text$mn:00001D00
.text$mn:00001D00 loc_1D00:                               ; CODE XREF: std::_Debug_range2<tDynamicList *>(tDynamicList *,tDynamicList *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00001D00                                         ; std::_Debug_range2<tDynamicList *>(tDynamicList *,tDynamicList *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00001D00                 pop     ebp
.text$mn:00001D01                 retn
.text$mn:00001D01 ??$_Debug_range2@PAUtDynamicList@@@std@@YAXPAUtDynamicList@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00001D01
.text$mn:00001D01 ; ---------------------------------------------------------------------------
.text$mn:00001D02                 align 4
.text$mn:00001D02 _text$mn        ends
.text$mn:00001D02
.text$mn:00001D04 ; ===========================================================================
.text$mn:00001D04
.text$mn:00001D04 ; Segment type: Pure code
.text$mn:00001D04 ; Segment permissions: Read/Execute
.text$mn:00001D04 _text$mn        segment para public 'CODE' use32
.text$mn:00001D04                 assume cs:_text$mn
.text$mn:00001D04                 ;org 1D04h
.text$mn:00001D04 ; COMDAT (pick any)
.text$mn:00001D04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D04
.text$mn:00001D04 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D04
.text$mn:00001D04 ; Attributes: bp-based frame
.text$mn:00001D04
.text$mn:00001D04 ; int __cdecl std::_Debug_range<int *>(int, int, wchar_t *, unsigned int)
.text$mn:00001D04                 public ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z
.text$mn:00001D04 ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z proc near
.text$mn:00001D04                                         ; CODE XREF: std::_Uninit_move<int,int,int>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:00001D04
.text$mn:00001D04 var_1           = byte ptr -1
.text$mn:00001D04 arg_0           = dword ptr  8
.text$mn:00001D04 arg_4           = dword ptr  0Ch
.text$mn:00001D04 arg_8           = dword ptr  10h
.text$mn:00001D04 arg_C           = dword ptr  14h
.text$mn:00001D04
.text$mn:00001D04                 push    ebp
.text$mn:00001D05                 mov     ebp, esp
.text$mn:00001D07                 push    ecx
.text$mn:00001D08                 lea     eax, [ebp+arg_0]
.text$mn:00001D0B                 push    eax
.text$mn:00001D0C                 lea     ecx, [ebp+var_1]
.text$mn:00001D0F                 push    ecx
.text$mn:00001D10                 call    ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>(int * const &)
.text$mn:00001D15                 add     esp, 8
.text$mn:00001D18                 mov     dl, [eax]
.text$mn:00001D1A                 movzx   eax, dl
.text$mn:00001D1D                 push    eax
.text$mn:00001D1E                 mov     ecx, [ebp+arg_C]
.text$mn:00001D21                 push    ecx             ; unsigned int
.text$mn:00001D22                 mov     edx, [ebp+arg_8]
.text$mn:00001D25                 push    edx             ; wchar_t *
.text$mn:00001D26                 mov     eax, [ebp+arg_4]
.text$mn:00001D29                 push    eax             ; int
.text$mn:00001D2A                 mov     ecx, [ebp+arg_0]
.text$mn:00001D2D                 push    ecx             ; int
.text$mn:00001D2E                 call    ??$_Debug_range2@PAH@std@@YAXPAH0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00001D33                 add     esp, 14h
.text$mn:00001D36                 mov     esp, ebp
.text$mn:00001D38                 pop     ebp
.text$mn:00001D39                 retn
.text$mn:00001D39 ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z endp
.text$mn:00001D39
.text$mn:00001D39 ; ---------------------------------------------------------------------------
.text$mn:00001D3A                 align 4
.text$mn:00001D3A _text$mn        ends
.text$mn:00001D3A
.text$mn:00001D3C ; ===========================================================================
.text$mn:00001D3C
.text$mn:00001D3C ; Segment type: Pure code
.text$mn:00001D3C ; Segment permissions: Read/Execute
.text$mn:00001D3C _text$mn        segment para public 'CODE' use32
.text$mn:00001D3C                 assume cs:_text$mn
.text$mn:00001D3C                 ;org 1D3Ch
.text$mn:00001D3C ; COMDAT (pick any)
.text$mn:00001D3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D3C
.text$mn:00001D3C ; =============== S U B R O U T I N E =======================================
.text$mn:00001D3C
.text$mn:00001D3C ; Attributes: bp-based frame
.text$mn:00001D3C
.text$mn:00001D3C ; int __cdecl std::_Debug_range<iconLocator *>(int, int, wchar_t *, unsigned int)
.text$mn:00001D3C                 public ??$_Debug_range@PAUiconLocator@@@std@@YAXPAUiconLocator@@0PB_WI@Z
.text$mn:00001D3C ??$_Debug_range@PAUiconLocator@@@std@@YAXPAUiconLocator@@0PB_WI@Z proc near
.text$mn:00001D3C                                         ; CODE XREF: std::_Uninit_move<iconLocator *,iconLocator *,std::allocator<iconLocator>,iconLocator>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &,iconLocator *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00001D3C
.text$mn:00001D3C var_1           = byte ptr -1
.text$mn:00001D3C arg_0           = dword ptr  8
.text$mn:00001D3C arg_4           = dword ptr  0Ch
.text$mn:00001D3C arg_8           = dword ptr  10h
.text$mn:00001D3C arg_C           = dword ptr  14h
.text$mn:00001D3C
.text$mn:00001D3C                 push    ebp
.text$mn:00001D3D                 mov     ebp, esp
.text$mn:00001D3F                 push    ecx
.text$mn:00001D40                 lea     eax, [ebp+arg_0]
.text$mn:00001D43                 push    eax
.text$mn:00001D44                 lea     ecx, [ebp+var_1]
.text$mn:00001D47                 push    ecx
.text$mn:00001D48                 call    ??$_Iter_cat@PAUiconLocator@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUiconLocator@@@Z ; std::_Iter_cat<iconLocator *>(iconLocator * const &)
.text$mn:00001D4D                 add     esp, 8
.text$mn:00001D50                 mov     dl, [eax]
.text$mn:00001D52                 movzx   eax, dl
.text$mn:00001D55                 push    eax
.text$mn:00001D56                 mov     ecx, [ebp+arg_C]
.text$mn:00001D59                 push    ecx             ; unsigned int
.text$mn:00001D5A                 mov     edx, [ebp+arg_8]
.text$mn:00001D5D                 push    edx             ; wchar_t *
.text$mn:00001D5E                 mov     eax, [ebp+arg_4]
.text$mn:00001D61                 push    eax             ; int
.text$mn:00001D62                 mov     ecx, [ebp+arg_0]
.text$mn:00001D65                 push    ecx             ; int
.text$mn:00001D66                 call    ??$_Debug_range2@PAUiconLocator@@@std@@YAXPAUiconLocator@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<iconLocator *>(iconLocator *,iconLocator *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00001D6B                 add     esp, 14h
.text$mn:00001D6E                 mov     esp, ebp
.text$mn:00001D70                 pop     ebp
.text$mn:00001D71                 retn
.text$mn:00001D71 ??$_Debug_range@PAUiconLocator@@@std@@YAXPAUiconLocator@@0PB_WI@Z endp
.text$mn:00001D71
.text$mn:00001D71 ; ---------------------------------------------------------------------------
.text$mn:00001D72                 align 4
.text$mn:00001D72 _text$mn        ends
.text$mn:00001D72
.text$mn:00001D74 ; ===========================================================================
.text$mn:00001D74
.text$mn:00001D74 ; Segment type: Pure code
.text$mn:00001D74 ; Segment permissions: Read/Execute
.text$mn:00001D74 _text$mn        segment para public 'CODE' use32
.text$mn:00001D74                 assume cs:_text$mn
.text$mn:00001D74                 ;org 1D74h
.text$mn:00001D74 ; COMDAT (pick any)
.text$mn:00001D74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D74
.text$mn:00001D74 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D74
.text$mn:00001D74 ; Attributes: bp-based frame
.text$mn:00001D74
.text$mn:00001D74 ; int __cdecl std::_Debug_range<tDynamicList *>(int, int, wchar_t *, unsigned int)
.text$mn:00001D74                 public ??$_Debug_range@PAUtDynamicList@@@std@@YAXPAUtDynamicList@@0PB_WI@Z
.text$mn:00001D74 ??$_Debug_range@PAUtDynamicList@@@std@@YAXPAUtDynamicList@@0PB_WI@Z proc near
.text$mn:00001D74                                         ; CODE XREF: std::_Uninit_move<tDynamicList *,tDynamicList *,std::allocator<tDynamicList>,tDynamicList>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &,tDynamicList *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00001D74
.text$mn:00001D74 var_1           = byte ptr -1
.text$mn:00001D74 arg_0           = dword ptr  8
.text$mn:00001D74 arg_4           = dword ptr  0Ch
.text$mn:00001D74 arg_8           = dword ptr  10h
.text$mn:00001D74 arg_C           = dword ptr  14h
.text$mn:00001D74
.text$mn:00001D74                 push    ebp
.text$mn:00001D75                 mov     ebp, esp
.text$mn:00001D77                 push    ecx
.text$mn:00001D78                 lea     eax, [ebp+arg_0]
.text$mn:00001D7B                 push    eax
.text$mn:00001D7C                 lea     ecx, [ebp+var_1]
.text$mn:00001D7F                 push    ecx
.text$mn:00001D80                 call    ??$_Iter_cat@PAUtDynamicList@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUtDynamicList@@@Z ; std::_Iter_cat<tDynamicList *>(tDynamicList * const &)
.text$mn:00001D85                 add     esp, 8
.text$mn:00001D88                 mov     dl, [eax]
.text$mn:00001D8A                 movzx   eax, dl
.text$mn:00001D8D                 push    eax
.text$mn:00001D8E                 mov     ecx, [ebp+arg_C]
.text$mn:00001D91                 push    ecx             ; unsigned int
.text$mn:00001D92                 mov     edx, [ebp+arg_8]
.text$mn:00001D95                 push    edx             ; wchar_t *
.text$mn:00001D96                 mov     eax, [ebp+arg_4]
.text$mn:00001D99                 push    eax             ; int
.text$mn:00001D9A                 mov     ecx, [ebp+arg_0]
.text$mn:00001D9D                 push    ecx             ; int
.text$mn:00001D9E                 call    ??$_Debug_range2@PAUtDynamicList@@@std@@YAXPAUtDynamicList@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<tDynamicList *>(tDynamicList *,tDynamicList *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00001DA3                 add     esp, 14h
.text$mn:00001DA6                 mov     esp, ebp
.text$mn:00001DA8                 pop     ebp
.text$mn:00001DA9                 retn
.text$mn:00001DA9 ??$_Debug_range@PAUtDynamicList@@@std@@YAXPAUtDynamicList@@0PB_WI@Z endp
.text$mn:00001DA9
.text$mn:00001DA9 ; ---------------------------------------------------------------------------
.text$mn:00001DAA                 align 4
.text$mn:00001DAA _text$mn        ends
.text$mn:00001DAA
.text$mn:00001DAC ; ===========================================================================
.text$mn:00001DAC
.text$mn:00001DAC ; Segment type: Pure code
.text$mn:00001DAC ; Segment permissions: Read/Execute
.text$mn:00001DAC _text$mn        segment para public 'CODE' use32
.text$mn:00001DAC                 assume cs:_text$mn
.text$mn:00001DAC                 ;org 1DACh
.text$mn:00001DAC ; COMDAT (pick any)
.text$mn:00001DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DAC
.text$mn:00001DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DAC
.text$mn:00001DAC ; Attributes: bp-based frame
.text$mn:00001DAC
.text$mn:00001DAC ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<int>>>(int *, int *, struct std::_Wrap_alloc<class std::allocator<int>> &)
.text$mn:00001DAC                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
.text$mn:00001DAC ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z proc near
.text$mn:00001DAC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Destroy(int *,int *)+21p
.text$mn:00001DAC
.text$mn:00001DAC var_1           = byte ptr -1
.text$mn:00001DAC arg_0           = dword ptr  8
.text$mn:00001DAC arg_4           = dword ptr  0Ch
.text$mn:00001DAC arg_8           = dword ptr  10h
.text$mn:00001DAC
.text$mn:00001DAC                 push    ebp
.text$mn:00001DAD                 mov     ebp, esp
.text$mn:00001DAF                 push    ecx
.text$mn:00001DB0                 mov     eax, [ebp+arg_4]
.text$mn:00001DB3                 push    eax
.text$mn:00001DB4                 mov     ecx, [ebp+arg_0]
.text$mn:00001DB7                 push    ecx
.text$mn:00001DB8                 call    ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>(int *,int *)
.text$mn:00001DBD                 add     esp, 8
.text$mn:00001DC0                 mov     [ebp+var_1], al
.text$mn:00001DC3                 movzx   edx, [ebp+var_1]
.text$mn:00001DC7                 push    edx
.text$mn:00001DC8                 mov     eax, [ebp+arg_8]
.text$mn:00001DCB                 push    eax
.text$mn:00001DCC                 mov     ecx, [ebp+arg_4]
.text$mn:00001DCF                 push    ecx
.text$mn:00001DD0                 mov     edx, [ebp+arg_0]
.text$mn:00001DD3                 push    edx
.text$mn:00001DD4                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00001DD9                 add     esp, 10h
.text$mn:00001DDC                 mov     esp, ebp
.text$mn:00001DDE                 pop     ebp
.text$mn:00001DDF                 retn
.text$mn:00001DDF ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z endp
.text$mn:00001DDF
.text$mn:00001DDF _text$mn        ends
.text$mn:00001DDF
.text$mn:00001DE0 ; ===========================================================================
.text$mn:00001DE0
.text$mn:00001DE0 ; Segment type: Pure code
.text$mn:00001DE0 ; Segment permissions: Read/Execute
.text$mn:00001DE0 _text$mn        segment para public 'CODE' use32
.text$mn:00001DE0                 assume cs:_text$mn
.text$mn:00001DE0                 ;org 1DE0h
.text$mn:00001DE0 ; COMDAT (pick any)
.text$mn:00001DE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DE0
.text$mn:00001DE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DE0
.text$mn:00001DE0 ; Attributes: bp-based frame
.text$mn:00001DE0
.text$mn:00001DE0 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<int>>>(int *, int *, struct std::_Wrap_alloc<class std::allocator<int>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00001DE0                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00001DE0 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00001DE0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+28p
.text$mn:00001DE0                 push    ebp
.text$mn:00001DE1                 mov     ebp, esp
.text$mn:00001DE3                 pop     ebp
.text$mn:00001DE4                 retn
.text$mn:00001DE4 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00001DE4
.text$mn:00001DE4 ; ---------------------------------------------------------------------------
.text$mn:00001DE5                 align 4
.text$mn:00001DE5 _text$mn        ends
.text$mn:00001DE5
.text$mn:00001DE8 ; ===========================================================================
.text$mn:00001DE8
.text$mn:00001DE8 ; Segment type: Pure code
.text$mn:00001DE8 ; Segment permissions: Read/Execute
.text$mn:00001DE8 _text$mn        segment para public 'CODE' use32
.text$mn:00001DE8                 assume cs:_text$mn
.text$mn:00001DE8                 ;org 1DE8h
.text$mn:00001DE8 ; COMDAT (pick any)
.text$mn:00001DE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DE8
.text$mn:00001DE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DE8
.text$mn:00001DE8 ; Attributes: bp-based frame
.text$mn:00001DE8
.text$mn:00001DE8 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct iconLocator>>>(struct iconLocator *, struct iconLocator *, struct std::_Wrap_alloc<class std::allocator<struct iconLocator>> &)
.text$mn:00001DE8                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAXPAUiconLocator@@0AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@@Z
.text$mn:00001DE8 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAXPAUiconLocator@@0AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@@Z proc near
.text$mn:00001DE8                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Destroy(iconLocator *,iconLocator *)+21p
.text$mn:00001DE8
.text$mn:00001DE8 var_1           = byte ptr -1
.text$mn:00001DE8 arg_0           = dword ptr  8
.text$mn:00001DE8 arg_4           = dword ptr  0Ch
.text$mn:00001DE8 arg_8           = dword ptr  10h
.text$mn:00001DE8
.text$mn:00001DE8                 push    ebp
.text$mn:00001DE9                 mov     ebp, esp
.text$mn:00001DEB                 push    ecx
.text$mn:00001DEC                 mov     eax, [ebp+arg_4]
.text$mn:00001DEF                 push    eax
.text$mn:00001DF0                 mov     ecx, [ebp+arg_0]
.text$mn:00001DF3                 push    ecx
.text$mn:00001DF4                 call    ??$_Ptr_cat@UiconLocator@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUiconLocator@@0@Z ; std::_Ptr_cat<iconLocator,iconLocator>(iconLocator *,iconLocator *)
.text$mn:00001DF9                 add     esp, 8
.text$mn:00001DFC                 mov     [ebp+var_1], al
.text$mn:00001DFF                 movzx   edx, [ebp+var_1]
.text$mn:00001E03                 push    edx
.text$mn:00001E04                 mov     eax, [ebp+arg_8]
.text$mn:00001E07                 push    eax
.text$mn:00001E08                 mov     ecx, [ebp+arg_4]
.text$mn:00001E0B                 push    ecx
.text$mn:00001E0C                 mov     edx, [ebp+arg_0]
.text$mn:00001E0F                 push    edx
.text$mn:00001E10                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAXPAUiconLocator@@0AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00001E15                 add     esp, 10h
.text$mn:00001E18                 mov     esp, ebp
.text$mn:00001E1A                 pop     ebp
.text$mn:00001E1B                 retn
.text$mn:00001E1B ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAXPAUiconLocator@@0AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@@Z endp
.text$mn:00001E1B
.text$mn:00001E1B _text$mn        ends
.text$mn:00001E1B
.text$mn:00001E1C ; ===========================================================================
.text$mn:00001E1C
.text$mn:00001E1C ; Segment type: Pure code
.text$mn:00001E1C ; Segment permissions: Read/Execute
.text$mn:00001E1C _text$mn        segment para public 'CODE' use32
.text$mn:00001E1C                 assume cs:_text$mn
.text$mn:00001E1C                 ;org 1E1Ch
.text$mn:00001E1C ; COMDAT (pick any)
.text$mn:00001E1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E1C
.text$mn:00001E1C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E1C
.text$mn:00001E1C ; Attributes: bp-based frame
.text$mn:00001E1C
.text$mn:00001E1C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct iconLocator>>>(struct iconLocator *, struct iconLocator *, struct std::_Wrap_alloc<class std::allocator<struct iconLocator>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00001E1C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAXPAUiconLocator@@0AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00001E1C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAXPAUiconLocator@@0AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00001E1C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &)+28p
.text$mn:00001E1C
.text$mn:00001E1C arg_0           = dword ptr  8
.text$mn:00001E1C arg_4           = dword ptr  0Ch
.text$mn:00001E1C arg_8           = dword ptr  10h
.text$mn:00001E1C
.text$mn:00001E1C                 push    ebp
.text$mn:00001E1D                 mov     ebp, esp
.text$mn:00001E1F                 jmp     short loc_1E2A
.text$mn:00001E21 ; ---------------------------------------------------------------------------
.text$mn:00001E21
.text$mn:00001E21 loc_1E21:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00001E21                 mov     eax, [ebp+arg_0]
.text$mn:00001E24                 add     eax, 24h ; '$'
.text$mn:00001E27                 mov     [ebp+arg_0], eax
.text$mn:00001E2A
.text$mn:00001E2A loc_1E2A:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00001E2A                 mov     ecx, [ebp+arg_0]
.text$mn:00001E2D                 cmp     ecx, [ebp+arg_4]
.text$mn:00001E30                 jz      short loc_1E40
.text$mn:00001E32                 mov     edx, [ebp+arg_0]
.text$mn:00001E35                 push    edx
.text$mn:00001E36                 mov     ecx, [ebp+arg_8]
.text$mn:00001E39                 call    ??$destroy@UiconLocator@@@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@@Z ; std::_Wrap_alloc<std::allocator<iconLocator>>::destroy<iconLocator>(iconLocator *)
.text$mn:00001E3E                 jmp     short loc_1E21
.text$mn:00001E40 ; ---------------------------------------------------------------------------
.text$mn:00001E40
.text$mn:00001E40 loc_1E40:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00001E40                 pop     ebp
.text$mn:00001E41                 retn
.text$mn:00001E41 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAXPAUiconLocator@@0AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00001E41
.text$mn:00001E41 ; ---------------------------------------------------------------------------
.text$mn:00001E42                 align 4
.text$mn:00001E42 _text$mn        ends
.text$mn:00001E42
.text$mn:00001E44 ; ===========================================================================
.text$mn:00001E44
.text$mn:00001E44 ; Segment type: Pure code
.text$mn:00001E44 ; Segment permissions: Read/Execute
.text$mn:00001E44 _text$mn        segment para public 'CODE' use32
.text$mn:00001E44                 assume cs:_text$mn
.text$mn:00001E44                 ;org 1E44h
.text$mn:00001E44 ; COMDAT (pick any)
.text$mn:00001E44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E44
.text$mn:00001E44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E44
.text$mn:00001E44 ; Attributes: bp-based frame
.text$mn:00001E44
.text$mn:00001E44 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct tDynamicList>>>(struct tDynamicList *, struct tDynamicList *, struct std::_Wrap_alloc<class std::allocator<struct tDynamicList>> &)
.text$mn:00001E44                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAXPAUtDynamicList@@0AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@@Z
.text$mn:00001E44 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAXPAUtDynamicList@@0AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@@Z proc near
.text$mn:00001E44                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Destroy(tDynamicList *,tDynamicList *)+21p
.text$mn:00001E44
.text$mn:00001E44 var_1           = byte ptr -1
.text$mn:00001E44 arg_0           = dword ptr  8
.text$mn:00001E44 arg_4           = dword ptr  0Ch
.text$mn:00001E44 arg_8           = dword ptr  10h
.text$mn:00001E44
.text$mn:00001E44                 push    ebp
.text$mn:00001E45                 mov     ebp, esp
.text$mn:00001E47                 push    ecx
.text$mn:00001E48                 mov     eax, [ebp+arg_4]
.text$mn:00001E4B                 push    eax
.text$mn:00001E4C                 mov     ecx, [ebp+arg_0]
.text$mn:00001E4F                 push    ecx
.text$mn:00001E50                 call    ??$_Ptr_cat@UtDynamicList@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtDynamicList@@0@Z ; std::_Ptr_cat<tDynamicList,tDynamicList>(tDynamicList *,tDynamicList *)
.text$mn:00001E55                 add     esp, 8
.text$mn:00001E58                 mov     [ebp+var_1], al
.text$mn:00001E5B                 movzx   edx, [ebp+var_1]
.text$mn:00001E5F                 push    edx
.text$mn:00001E60                 mov     eax, [ebp+arg_8]
.text$mn:00001E63                 push    eax
.text$mn:00001E64                 mov     ecx, [ebp+arg_4]
.text$mn:00001E67                 push    ecx
.text$mn:00001E68                 mov     edx, [ebp+arg_0]
.text$mn:00001E6B                 push    edx
.text$mn:00001E6C                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAXPAUtDynamicList@@0AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00001E71                 add     esp, 10h
.text$mn:00001E74                 mov     esp, ebp
.text$mn:00001E76                 pop     ebp
.text$mn:00001E77                 retn
.text$mn:00001E77 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAXPAUtDynamicList@@0AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@@Z endp
.text$mn:00001E77
.text$mn:00001E77 _text$mn        ends
.text$mn:00001E77
.text$mn:00001E78 ; ===========================================================================
.text$mn:00001E78
.text$mn:00001E78 ; Segment type: Pure code
.text$mn:00001E78 ; Segment permissions: Read/Execute
.text$mn:00001E78 _text$mn        segment para public 'CODE' use32
.text$mn:00001E78                 assume cs:_text$mn
.text$mn:00001E78                 ;org 1E78h
.text$mn:00001E78 ; COMDAT (pick any)
.text$mn:00001E78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E78
.text$mn:00001E78 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E78
.text$mn:00001E78 ; Attributes: bp-based frame
.text$mn:00001E78
.text$mn:00001E78 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<struct tDynamicList>>>(struct tDynamicList *, struct tDynamicList *, struct std::_Wrap_alloc<class std::allocator<struct tDynamicList>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00001E78                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAXPAUtDynamicList@@0AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00001E78 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAXPAUtDynamicList@@0AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00001E78                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &)+28p
.text$mn:00001E78
.text$mn:00001E78 arg_0           = dword ptr  8
.text$mn:00001E78 arg_4           = dword ptr  0Ch
.text$mn:00001E78 arg_8           = dword ptr  10h
.text$mn:00001E78
.text$mn:00001E78                 push    ebp
.text$mn:00001E79                 mov     ebp, esp
.text$mn:00001E7B                 jmp     short loc_1E86
.text$mn:00001E7D ; ---------------------------------------------------------------------------
.text$mn:00001E7D
.text$mn:00001E7D loc_1E7D:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00001E7D                 mov     eax, [ebp+arg_0]
.text$mn:00001E80                 add     eax, 0Ch
.text$mn:00001E83                 mov     [ebp+arg_0], eax
.text$mn:00001E86
.text$mn:00001E86 loc_1E86:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00001E86                 mov     ecx, [ebp+arg_0]
.text$mn:00001E89                 cmp     ecx, [ebp+arg_4]
.text$mn:00001E8C                 jz      short loc_1E9C
.text$mn:00001E8E                 mov     edx, [ebp+arg_0]
.text$mn:00001E91                 push    edx
.text$mn:00001E92                 mov     ecx, [ebp+arg_8]
.text$mn:00001E95                 call    ??$destroy@UtDynamicList@@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@@Z ; std::_Wrap_alloc<std::allocator<tDynamicList>>::destroy<tDynamicList>(tDynamicList *)
.text$mn:00001E9A                 jmp     short loc_1E7D
.text$mn:00001E9C ; ---------------------------------------------------------------------------
.text$mn:00001E9C
.text$mn:00001E9C loc_1E9C:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00001E9C                 pop     ebp
.text$mn:00001E9D                 retn
.text$mn:00001E9D ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAXPAUtDynamicList@@0AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00001E9D
.text$mn:00001E9D ; ---------------------------------------------------------------------------
.text$mn:00001E9E                 align 10h
.text$mn:00001E9E _text$mn        ends
.text$mn:00001E9E
.text$mn:00001EA0 ; ===========================================================================
.text$mn:00001EA0
.text$mn:00001EA0 ; Segment type: Pure code
.text$mn:00001EA0 ; Segment permissions: Read/Execute
.text$mn:00001EA0 _text$mn        segment para public 'CODE' use32
.text$mn:00001EA0                 assume cs:_text$mn
.text$mn:00001EA0                 ;org 1EA0h
.text$mn:00001EA0 ; COMDAT (pick any)
.text$mn:00001EA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EA0
.text$mn:00001EA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EA0
.text$mn:00001EA0 ; Attributes: bp-based frame
.text$mn:00001EA0
.text$mn:00001EA0 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<int *>(int * const &)
.text$mn:00001EA0                 public ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
.text$mn:00001EA0 ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z proc near
.text$mn:00001EA0                                         ; CODE XREF: std::_Debug_range<int *>(int *,int *,wchar_t const *,uint)+Cp
.text$mn:00001EA0
.text$mn:00001EA0 var_1           = byte ptr -1
.text$mn:00001EA0 arg_0           = dword ptr  8
.text$mn:00001EA0
.text$mn:00001EA0                 push    ebp
.text$mn:00001EA1                 mov     ebp, esp
.text$mn:00001EA3                 push    ecx
.text$mn:00001EA4                 mov     eax, [ebp+arg_0]
.text$mn:00001EA7                 mov     cl, [ebp+var_1]
.text$mn:00001EAA                 mov     [eax], cl
.text$mn:00001EAC                 mov     eax, [ebp+arg_0]
.text$mn:00001EAF                 mov     esp, ebp
.text$mn:00001EB1                 pop     ebp
.text$mn:00001EB2                 retn
.text$mn:00001EB2 ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z endp
.text$mn:00001EB2
.text$mn:00001EB2 ; ---------------------------------------------------------------------------
.text$mn:00001EB3                 align 4
.text$mn:00001EB3 _text$mn        ends
.text$mn:00001EB3
.text$mn:00001EB4 ; ===========================================================================
.text$mn:00001EB4
.text$mn:00001EB4 ; Segment type: Pure code
.text$mn:00001EB4 ; Segment permissions: Read/Execute
.text$mn:00001EB4 _text$mn        segment para public 'CODE' use32
.text$mn:00001EB4                 assume cs:_text$mn
.text$mn:00001EB4                 ;org 1EB4h
.text$mn:00001EB4 ; COMDAT (pick any)
.text$mn:00001EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EB4
.text$mn:00001EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EB4
.text$mn:00001EB4 ; Attributes: bp-based frame
.text$mn:00001EB4
.text$mn:00001EB4 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct iconLocator *>(struct iconLocator * const &)
.text$mn:00001EB4                 public ??$_Iter_cat@PAUiconLocator@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUiconLocator@@@Z
.text$mn:00001EB4 ??$_Iter_cat@PAUiconLocator@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUiconLocator@@@Z proc near
.text$mn:00001EB4                                         ; CODE XREF: std::_Debug_range<iconLocator *>(iconLocator *,iconLocator *,wchar_t const *,uint)+Cp
.text$mn:00001EB4
.text$mn:00001EB4 var_1           = byte ptr -1
.text$mn:00001EB4 arg_0           = dword ptr  8
.text$mn:00001EB4
.text$mn:00001EB4                 push    ebp
.text$mn:00001EB5                 mov     ebp, esp
.text$mn:00001EB7                 push    ecx
.text$mn:00001EB8                 mov     eax, [ebp+arg_0]
.text$mn:00001EBB                 mov     cl, [ebp+var_1]
.text$mn:00001EBE                 mov     [eax], cl
.text$mn:00001EC0                 mov     eax, [ebp+arg_0]
.text$mn:00001EC3                 mov     esp, ebp
.text$mn:00001EC5                 pop     ebp
.text$mn:00001EC6                 retn
.text$mn:00001EC6 ??$_Iter_cat@PAUiconLocator@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUiconLocator@@@Z endp
.text$mn:00001EC6
.text$mn:00001EC6 ; ---------------------------------------------------------------------------
.text$mn:00001EC7                 align 4
.text$mn:00001EC7 _text$mn        ends
.text$mn:00001EC7
.text$mn:00001EC8 ; ===========================================================================
.text$mn:00001EC8
.text$mn:00001EC8 ; Segment type: Pure code
.text$mn:00001EC8 ; Segment permissions: Read/Execute
.text$mn:00001EC8 _text$mn        segment para public 'CODE' use32
.text$mn:00001EC8                 assume cs:_text$mn
.text$mn:00001EC8                 ;org 1EC8h
.text$mn:00001EC8 ; COMDAT (pick any)
.text$mn:00001EC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EC8
.text$mn:00001EC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EC8
.text$mn:00001EC8 ; Attributes: bp-based frame
.text$mn:00001EC8
.text$mn:00001EC8 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<struct tDynamicList *>(struct tDynamicList * const &)
.text$mn:00001EC8                 public ??$_Iter_cat@PAUtDynamicList@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUtDynamicList@@@Z
.text$mn:00001EC8 ??$_Iter_cat@PAUtDynamicList@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUtDynamicList@@@Z proc near
.text$mn:00001EC8                                         ; CODE XREF: std::_Debug_range<tDynamicList *>(tDynamicList *,tDynamicList *,wchar_t const *,uint)+Cp
.text$mn:00001EC8
.text$mn:00001EC8 var_1           = byte ptr -1
.text$mn:00001EC8 arg_0           = dword ptr  8
.text$mn:00001EC8
.text$mn:00001EC8                 push    ebp
.text$mn:00001EC9                 mov     ebp, esp
.text$mn:00001ECB                 push    ecx
.text$mn:00001ECC                 mov     eax, [ebp+arg_0]
.text$mn:00001ECF                 mov     cl, [ebp+var_1]
.text$mn:00001ED2                 mov     [eax], cl
.text$mn:00001ED4                 mov     eax, [ebp+arg_0]
.text$mn:00001ED7                 mov     esp, ebp
.text$mn:00001ED9                 pop     ebp
.text$mn:00001EDA                 retn
.text$mn:00001EDA ??$_Iter_cat@PAUtDynamicList@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUtDynamicList@@@Z endp
.text$mn:00001EDA
.text$mn:00001EDA ; ---------------------------------------------------------------------------
.text$mn:00001EDB                 align 4
.text$mn:00001EDB _text$mn        ends
.text$mn:00001EDB
.text$mn:00001EDC ; ===========================================================================
.text$mn:00001EDC
.text$mn:00001EDC ; Segment type: Pure code
.text$mn:00001EDC ; Segment permissions: Read/Execute
.text$mn:00001EDC _text$mn        segment para public 'CODE' use32
.text$mn:00001EDC                 assume cs:_text$mn
.text$mn:00001EDC                 ;org 1EDCh
.text$mn:00001EDC ; COMDAT (pick any)
.text$mn:00001EDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EDC
.text$mn:00001EDC ; =============== S U B R O U T I N E =======================================
.text$mn:00001EDC
.text$mn:00001EDC ; Attributes: bp-based frame
.text$mn:00001EDC
.text$mn:00001EDC ; int __cdecl std::_Move<int *,int *>(void *Src, int, void *Dst)
.text$mn:00001EDC                 public ??$_Move@PAHPAH@std@@YAPAHPAH00@Z
.text$mn:00001EDC ??$_Move@PAHPAH@std@@YAPAHPAH00@Z proc near
.text$mn:00001EDC                                         ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+82p
.text$mn:00001EDC
.text$mn:00001EDC var_1           = byte ptr -1
.text$mn:00001EDC Src             = dword ptr  8
.text$mn:00001EDC arg_4           = dword ptr  0Ch
.text$mn:00001EDC Dst             = dword ptr  10h
.text$mn:00001EDC
.text$mn:00001EDC                 push    ebp
.text$mn:00001EDD                 mov     ebp, esp
.text$mn:00001EDF                 push    ecx
.text$mn:00001EE0                 mov     eax, [ebp+Dst]
.text$mn:00001EE3                 push    eax
.text$mn:00001EE4                 mov     ecx, [ebp+Src]
.text$mn:00001EE7                 push    ecx
.text$mn:00001EE8                 call    ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>(int *,int *)
.text$mn:00001EED                 add     esp, 8
.text$mn:00001EF0                 mov     [ebp+var_1], al
.text$mn:00001EF3                 movzx   edx, [ebp+var_1]
.text$mn:00001EF7                 push    edx
.text$mn:00001EF8                 mov     eax, [ebp+Dst]
.text$mn:00001EFB                 push    eax             ; Dst
.text$mn:00001EFC                 mov     ecx, [ebp+arg_4]
.text$mn:00001EFF                 push    ecx             ; int
.text$mn:00001F00                 mov     edx, [ebp+Src]
.text$mn:00001F03                 push    edx             ; Src
.text$mn:00001F04                 call    ??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<int *,int *>(int *,int *,int *,std::_Scalar_ptr_iterator_tag)
.text$mn:00001F09                 add     esp, 10h
.text$mn:00001F0C                 mov     esp, ebp
.text$mn:00001F0E                 pop     ebp
.text$mn:00001F0F                 retn
.text$mn:00001F0F ??$_Move@PAHPAH@std@@YAPAHPAH00@Z endp
.text$mn:00001F0F
.text$mn:00001F0F _text$mn        ends
.text$mn:00001F0F
.text$mn:00001F10 ; ===========================================================================
.text$mn:00001F10
.text$mn:00001F10 ; Segment type: Pure code
.text$mn:00001F10 ; Segment permissions: Read/Execute
.text$mn:00001F10 _text$mn        segment para public 'CODE' use32
.text$mn:00001F10                 assume cs:_text$mn
.text$mn:00001F10                 ;org 1F10h
.text$mn:00001F10 ; COMDAT (pick any)
.text$mn:00001F10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F10
.text$mn:00001F10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F10
.text$mn:00001F10 ; Attributes: bp-based frame
.text$mn:00001F10
.text$mn:00001F10 ; int __cdecl std::_Move<int *,int *>(void *Src, int, void *Dst)
.text$mn:00001F10                 public ??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00001F10 ??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00001F10                                         ; CODE XREF: std::_Move<int *,int *>(int *,int *,int *)+28p
.text$mn:00001F10
.text$mn:00001F10 var_4           = dword ptr -4
.text$mn:00001F10 Src             = dword ptr  8
.text$mn:00001F10 arg_4           = dword ptr  0Ch
.text$mn:00001F10 Dst             = dword ptr  10h
.text$mn:00001F10
.text$mn:00001F10                 push    ebp
.text$mn:00001F11                 mov     ebp, esp
.text$mn:00001F13                 push    ecx
.text$mn:00001F14                 mov     eax, [ebp+arg_4]
.text$mn:00001F17                 sub     eax, [ebp+Src]
.text$mn:00001F1A                 sar     eax, 2
.text$mn:00001F1D                 mov     [ebp+var_4], eax
.text$mn:00001F20                 mov     ecx, [ebp+var_4]
.text$mn:00001F23                 shl     ecx, 2
.text$mn:00001F26                 push    ecx             ; Size
.text$mn:00001F27                 mov     edx, [ebp+Src]
.text$mn:00001F2A                 push    edx             ; Src
.text$mn:00001F2B                 mov     eax, [ebp+Dst]
.text$mn:00001F2E                 push    eax             ; Dst
.text$mn:00001F2F                 call    _memmove
.text$mn:00001F34                 add     esp, 0Ch
.text$mn:00001F37                 mov     ecx, [ebp+var_4]
.text$mn:00001F3A                 mov     edx, [ebp+Dst]
.text$mn:00001F3D                 lea     eax, [edx+ecx*4]
.text$mn:00001F40                 mov     esp, ebp
.text$mn:00001F42                 pop     ebp
.text$mn:00001F43                 retn
.text$mn:00001F43 ??$_Move@PAHPAH@std@@YAPAHPAH00U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00001F43
.text$mn:00001F43 _text$mn        ends
.text$mn:00001F43
.text$mn:00001F44 ; ===========================================================================
.text$mn:00001F44
.text$mn:00001F44 ; Segment type: Pure code
.text$mn:00001F44 ; Segment permissions: Read/Execute
.text$mn:00001F44 _text$mn        segment para public 'CODE' use32
.text$mn:00001F44                 assume cs:_text$mn
.text$mn:00001F44                 ;org 1F44h
.text$mn:00001F44 ; COMDAT (pick any)
.text$mn:00001F44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F44
.text$mn:00001F44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F44
.text$mn:00001F44 ; Attributes: bp-based frame
.text$mn:00001F44
.text$mn:00001F44 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<int, int>(int *, int *)
.text$mn:00001F44                 public ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z
.text$mn:00001F44 ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z proc near
.text$mn:00001F44                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+Cp
.text$mn:00001F44                                         ; std::_Move<int *,int *>(int *,int *,int *)+Cp ...
.text$mn:00001F44
.text$mn:00001F44 var_1           = byte ptr -1
.text$mn:00001F44
.text$mn:00001F44                 push    ebp
.text$mn:00001F45                 mov     ebp, esp
.text$mn:00001F47                 push    ecx
.text$mn:00001F48                 mov     al, [ebp+var_1]
.text$mn:00001F4B                 mov     esp, ebp
.text$mn:00001F4D                 pop     ebp
.text$mn:00001F4E                 retn
.text$mn:00001F4E ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z endp
.text$mn:00001F4E
.text$mn:00001F4E ; ---------------------------------------------------------------------------
.text$mn:00001F4F                 align 10h
.text$mn:00001F4F _text$mn        ends
.text$mn:00001F4F
.text$mn:00001F50 ; ===========================================================================
.text$mn:00001F50
.text$mn:00001F50 ; Segment type: Pure code
.text$mn:00001F50 ; Segment permissions: Read/Execute
.text$mn:00001F50 _text$mn        segment para public 'CODE' use32
.text$mn:00001F50                 assume cs:_text$mn
.text$mn:00001F50                 ;org 1F50h
.text$mn:00001F50 ; COMDAT (pick any)
.text$mn:00001F50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F50
.text$mn:00001F50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F50
.text$mn:00001F50 ; Attributes: bp-based frame
.text$mn:00001F50
.text$mn:00001F50 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct iconLocator, struct iconLocator>(struct iconLocator *, struct iconLocator *)
.text$mn:00001F50                 public ??$_Ptr_cat@UiconLocator@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUiconLocator@@0@Z
.text$mn:00001F50 ??$_Ptr_cat@UiconLocator@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUiconLocator@@0@Z proc near
.text$mn:00001F50                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &)+Cp
.text$mn:00001F50                                         ; std::_Uninit_move<iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &)+Cp
.text$mn:00001F50
.text$mn:00001F50 var_1           = byte ptr -1
.text$mn:00001F50
.text$mn:00001F50                 push    ebp
.text$mn:00001F51                 mov     ebp, esp
.text$mn:00001F53                 push    ecx
.text$mn:00001F54                 mov     al, [ebp+var_1]
.text$mn:00001F57                 mov     esp, ebp
.text$mn:00001F59                 pop     ebp
.text$mn:00001F5A                 retn
.text$mn:00001F5A ??$_Ptr_cat@UiconLocator@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUiconLocator@@0@Z endp
.text$mn:00001F5A
.text$mn:00001F5A ; ---------------------------------------------------------------------------
.text$mn:00001F5B                 align 4
.text$mn:00001F5B _text$mn        ends
.text$mn:00001F5B
.text$mn:00001F5C ; ===========================================================================
.text$mn:00001F5C
.text$mn:00001F5C ; Segment type: Pure code
.text$mn:00001F5C ; Segment permissions: Read/Execute
.text$mn:00001F5C _text$mn        segment para public 'CODE' use32
.text$mn:00001F5C                 assume cs:_text$mn
.text$mn:00001F5C                 ;org 1F5Ch
.text$mn:00001F5C ; COMDAT (pick any)
.text$mn:00001F5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F5C
.text$mn:00001F5C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F5C
.text$mn:00001F5C ; Attributes: bp-based frame
.text$mn:00001F5C
.text$mn:00001F5C ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<struct tDynamicList, struct tDynamicList>(struct tDynamicList *, struct tDynamicList *)
.text$mn:00001F5C                 public ??$_Ptr_cat@UtDynamicList@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtDynamicList@@0@Z
.text$mn:00001F5C ??$_Ptr_cat@UtDynamicList@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtDynamicList@@0@Z proc near
.text$mn:00001F5C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &)+Cp
.text$mn:00001F5C                                         ; std::_Uninit_move<tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &)+Cp
.text$mn:00001F5C
.text$mn:00001F5C var_1           = byte ptr -1
.text$mn:00001F5C
.text$mn:00001F5C                 push    ebp
.text$mn:00001F5D                 mov     ebp, esp
.text$mn:00001F5F                 push    ecx
.text$mn:00001F60                 mov     al, [ebp+var_1]
.text$mn:00001F63                 mov     esp, ebp
.text$mn:00001F65                 pop     ebp
.text$mn:00001F66                 retn
.text$mn:00001F66 ??$_Ptr_cat@UtDynamicList@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtDynamicList@@0@Z endp
.text$mn:00001F66
.text$mn:00001F66 ; ---------------------------------------------------------------------------
.text$mn:00001F67                 align 4
.text$mn:00001F67 _text$mn        ends
.text$mn:00001F67
.text$mn:00001F68 ; ===========================================================================
.text$mn:00001F68
.text$mn:00001F68 ; Segment type: Pure code
.text$mn:00001F68 ; Segment permissions: Read/Execute
.text$mn:00001F68 _text$mn        segment para public 'CODE' use32
.text$mn:00001F68                 assume cs:_text$mn
.text$mn:00001F68                 ;org 1F68h
.text$mn:00001F68 ; COMDAT (pick any)
.text$mn:00001F68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F68
.text$mn:00001F68 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F68
.text$mn:00001F68 ; Attributes: bp-based frame
.text$mn:00001F68
.text$mn:00001F68 ; int * & __cdecl std::_Rechecked<int *, int *>(int * &, int *)
.text$mn:00001F68                 public ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z
.text$mn:00001F68 ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z proc near
.text$mn:00001F68                                         ; CODE XREF: std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+3Bp
.text$mn:00001F68
.text$mn:00001F68 arg_0           = dword ptr  8
.text$mn:00001F68 arg_4           = dword ptr  0Ch
.text$mn:00001F68
.text$mn:00001F68                 push    ebp
.text$mn:00001F69                 mov     ebp, esp
.text$mn:00001F6B                 mov     eax, [ebp+arg_0]
.text$mn:00001F6E                 mov     ecx, [ebp+arg_4]
.text$mn:00001F71                 mov     [eax], ecx
.text$mn:00001F73                 mov     eax, [ebp+arg_0]
.text$mn:00001F76                 pop     ebp
.text$mn:00001F77                 retn
.text$mn:00001F77 ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z endp
.text$mn:00001F77
.text$mn:00001F77 _text$mn        ends
.text$mn:00001F77
.text$mn:00001F78 ; ===========================================================================
.text$mn:00001F78
.text$mn:00001F78 ; Segment type: Pure code
.text$mn:00001F78 ; Segment permissions: Read/Execute
.text$mn:00001F78 _text$mn        segment para public 'CODE' use32
.text$mn:00001F78                 assume cs:_text$mn
.text$mn:00001F78                 ;org 1F78h
.text$mn:00001F78 ; COMDAT (pick any)
.text$mn:00001F78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F78
.text$mn:00001F78 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F78
.text$mn:00001F78 ; Attributes: bp-based frame
.text$mn:00001F78
.text$mn:00001F78 ; struct iconLocator * & __cdecl std::_Rechecked<struct iconLocator *, struct iconLocator *>(struct iconLocator * &, struct iconLocator *)
.text$mn:00001F78                 public ??$_Rechecked@PAUiconLocator@@PAU1@@std@@YAAAPAUiconLocator@@AAPAU1@PAU1@@Z
.text$mn:00001F78 ??$_Rechecked@PAUiconLocator@@PAU1@@std@@YAAAPAUiconLocator@@AAPAU1@PAU1@@Z proc near
.text$mn:00001F78                                         ; CODE XREF: std::_Uninitialized_move<iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &)+3Bp
.text$mn:00001F78
.text$mn:00001F78 arg_0           = dword ptr  8
.text$mn:00001F78 arg_4           = dword ptr  0Ch
.text$mn:00001F78
.text$mn:00001F78                 push    ebp
.text$mn:00001F79                 mov     ebp, esp
.text$mn:00001F7B                 mov     eax, [ebp+arg_0]
.text$mn:00001F7E                 mov     ecx, [ebp+arg_4]
.text$mn:00001F81                 mov     [eax], ecx
.text$mn:00001F83                 mov     eax, [ebp+arg_0]
.text$mn:00001F86                 pop     ebp
.text$mn:00001F87                 retn
.text$mn:00001F87 ??$_Rechecked@PAUiconLocator@@PAU1@@std@@YAAAPAUiconLocator@@AAPAU1@PAU1@@Z endp
.text$mn:00001F87
.text$mn:00001F87 _text$mn        ends
.text$mn:00001F87
.text$mn:00001F88 ; ===========================================================================
.text$mn:00001F88
.text$mn:00001F88 ; Segment type: Pure code
.text$mn:00001F88 ; Segment permissions: Read/Execute
.text$mn:00001F88 _text$mn        segment para public 'CODE' use32
.text$mn:00001F88                 assume cs:_text$mn
.text$mn:00001F88                 ;org 1F88h
.text$mn:00001F88 ; COMDAT (pick any)
.text$mn:00001F88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F88
.text$mn:00001F88 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F88
.text$mn:00001F88 ; Attributes: bp-based frame
.text$mn:00001F88
.text$mn:00001F88 ; struct tDynamicList * & __cdecl std::_Rechecked<struct tDynamicList *, struct tDynamicList *>(struct tDynamicList * &, struct tDynamicList *)
.text$mn:00001F88                 public ??$_Rechecked@PAUtDynamicList@@PAU1@@std@@YAAAPAUtDynamicList@@AAPAU1@PAU1@@Z
.text$mn:00001F88 ??$_Rechecked@PAUtDynamicList@@PAU1@@std@@YAAAPAUtDynamicList@@AAPAU1@PAU1@@Z proc near
.text$mn:00001F88                                         ; CODE XREF: std::_Uninitialized_move<tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &)+3Bp
.text$mn:00001F88
.text$mn:00001F88 arg_0           = dword ptr  8
.text$mn:00001F88 arg_4           = dword ptr  0Ch
.text$mn:00001F88
.text$mn:00001F88                 push    ebp
.text$mn:00001F89                 mov     ebp, esp
.text$mn:00001F8B                 mov     eax, [ebp+arg_0]
.text$mn:00001F8E                 mov     ecx, [ebp+arg_4]
.text$mn:00001F91                 mov     [eax], ecx
.text$mn:00001F93                 mov     eax, [ebp+arg_0]
.text$mn:00001F96                 pop     ebp
.text$mn:00001F97                 retn
.text$mn:00001F97 ??$_Rechecked@PAUtDynamicList@@PAU1@@std@@YAAAPAUtDynamicList@@AAPAU1@PAU1@@Z endp
.text$mn:00001F97
.text$mn:00001F97 _text$mn        ends
.text$mn:00001F97
.text$mn:00001F98 ; ===========================================================================
.text$mn:00001F98
.text$mn:00001F98 ; Segment type: Pure code
.text$mn:00001F98 ; Segment permissions: Read/Execute
.text$mn:00001F98 _text$mn        segment para public 'CODE' use32
.text$mn:00001F98                 assume cs:_text$mn
.text$mn:00001F98                 ;org 1F98h
.text$mn:00001F98 ; COMDAT (pick any)
.text$mn:00001F98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F98
.text$mn:00001F98 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F98
.text$mn:00001F98 ; Attributes: bp-based frame
.text$mn:00001F98
.text$mn:00001F98 ; protected: int * __thiscall std::vector<int, class std::allocator<int>>::_Umove<int *>(int *, int *, int *)
.text$mn:00001F98                 public ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
.text$mn:00001F98 ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z proc near
.text$mn:00001F98                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+65p
.text$mn:00001F98
.text$mn:00001F98 var_8           = dword ptr -8
.text$mn:00001F98 var_1           = byte ptr -1
.text$mn:00001F98 arg_0           = dword ptr  8
.text$mn:00001F98 arg_4           = dword ptr  0Ch
.text$mn:00001F98 arg_8           = dword ptr  10h
.text$mn:00001F98
.text$mn:00001F98                 push    ebp
.text$mn:00001F99                 mov     ebp, esp
.text$mn:00001F9B                 sub     esp, 8
.text$mn:00001F9E                 mov     [ebp+var_8], ecx
.text$mn:00001FA1                 lea     eax, [ebp+var_1]
.text$mn:00001FA4                 push    eax
.text$mn:00001FA5                 mov     ecx, [ebp+var_8]
.text$mn:00001FA8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00001FAD                 lea     ecx, [ebp+var_1]
.text$mn:00001FB0                 push    ecx
.text$mn:00001FB1                 mov     edx, [ebp+arg_8]
.text$mn:00001FB4                 push    edx
.text$mn:00001FB5                 mov     eax, [ebp+arg_4]
.text$mn:00001FB8                 push    eax
.text$mn:00001FB9                 mov     ecx, [ebp+arg_0]
.text$mn:00001FBC                 push    ecx
.text$mn:00001FBD                 call    ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)
.text$mn:00001FC2                 add     esp, 10h
.text$mn:00001FC5                 mov     esp, ebp
.text$mn:00001FC7                 pop     ebp
.text$mn:00001FC8                 retn    0Ch
.text$mn:00001FC8 ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z endp
.text$mn:00001FC8
.text$mn:00001FC8 ; ---------------------------------------------------------------------------
.text$mn:00001FCB                 align 4
.text$mn:00001FCB _text$mn        ends
.text$mn:00001FCB
.text$mn:00001FCC ; ===========================================================================
.text$mn:00001FCC
.text$mn:00001FCC ; Segment type: Pure code
.text$mn:00001FCC ; Segment permissions: Read/Execute
.text$mn:00001FCC _text$mn        segment para public 'CODE' use32
.text$mn:00001FCC                 assume cs:_text$mn
.text$mn:00001FCC                 ;org 1FCCh
.text$mn:00001FCC ; COMDAT (pick any)
.text$mn:00001FCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FCC
.text$mn:00001FCC ; =============== S U B R O U T I N E =======================================
.text$mn:00001FCC
.text$mn:00001FCC ; Attributes: bp-based frame
.text$mn:00001FCC
.text$mn:00001FCC ; protected: struct iconLocator * __thiscall std::vector<struct iconLocator, class std::allocator<struct iconLocator>>::_Umove<struct iconLocator *>(struct iconLocator *, struct iconLocator *, struct iconLocator *)
.text$mn:00001FCC                 public ??$_Umove@PAUiconLocator@@@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEPAUiconLocator@@PAU2@00@Z
.text$mn:00001FCC ??$_Umove@PAUiconLocator@@@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEPAUiconLocator@@PAU2@00@Z proc near
.text$mn:00001FCC                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Reallocate(uint)+65p
.text$mn:00001FCC
.text$mn:00001FCC var_8           = dword ptr -8
.text$mn:00001FCC var_1           = byte ptr -1
.text$mn:00001FCC arg_0           = dword ptr  8
.text$mn:00001FCC arg_4           = dword ptr  0Ch
.text$mn:00001FCC arg_8           = dword ptr  10h
.text$mn:00001FCC
.text$mn:00001FCC                 push    ebp
.text$mn:00001FCD                 mov     ebp, esp
.text$mn:00001FCF                 sub     esp, 8
.text$mn:00001FD2                 mov     [ebp+var_8], ecx
.text$mn:00001FD5                 lea     eax, [ebp+var_1]
.text$mn:00001FD8                 push    eax
.text$mn:00001FD9                 mov     ecx, [ebp+var_8]
.text$mn:00001FDC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<iconLocator,std::allocator<iconLocator>>>::_Getal(void)
.text$mn:00001FE1                 lea     ecx, [ebp+var_1]
.text$mn:00001FE4                 push    ecx
.text$mn:00001FE5                 mov     edx, [ebp+arg_8]
.text$mn:00001FE8                 push    edx
.text$mn:00001FE9                 mov     eax, [ebp+arg_4]
.text$mn:00001FEC                 push    eax
.text$mn:00001FED                 mov     ecx, [ebp+arg_0]
.text$mn:00001FF0                 push    ecx
.text$mn:00001FF1                 call    ??$_Uninitialized_move@PAUiconLocator@@PAU1@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@@Z ; std::_Uninitialized_move<iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &)
.text$mn:00001FF6                 add     esp, 10h
.text$mn:00001FF9                 mov     esp, ebp
.text$mn:00001FFB                 pop     ebp
.text$mn:00001FFC                 retn    0Ch
.text$mn:00001FFC ??$_Umove@PAUiconLocator@@@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEPAUiconLocator@@PAU2@00@Z endp
.text$mn:00001FFC
.text$mn:00001FFC ; ---------------------------------------------------------------------------
.text$mn:00001FFF                 align 10h
.text$mn:00001FFF _text$mn        ends
.text$mn:00001FFF
.text$mn:00002000 ; ===========================================================================
.text$mn:00002000
.text$mn:00002000 ; Segment type: Pure code
.text$mn:00002000 ; Segment permissions: Read/Execute
.text$mn:00002000 _text$mn        segment para public 'CODE' use32
.text$mn:00002000                 assume cs:_text$mn
.text$mn:00002000                 ;org 2000h
.text$mn:00002000 ; COMDAT (pick any)
.text$mn:00002000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002000
.text$mn:00002000 ; =============== S U B R O U T I N E =======================================
.text$mn:00002000
.text$mn:00002000 ; Attributes: bp-based frame
.text$mn:00002000
.text$mn:00002000 ; protected: struct tDynamicList * __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::_Umove<struct tDynamicList *>(struct tDynamicList *, struct tDynamicList *, struct tDynamicList *)
.text$mn:00002000                 public ??$_Umove@PAUtDynamicList@@@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEPAUtDynamicList@@PAU2@00@Z
.text$mn:00002000 ??$_Umove@PAUtDynamicList@@@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEPAUtDynamicList@@PAU2@00@Z proc near
.text$mn:00002000                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reallocate(uint)+65p
.text$mn:00002000
.text$mn:00002000 var_8           = dword ptr -8
.text$mn:00002000 var_1           = byte ptr -1
.text$mn:00002000 arg_0           = dword ptr  8
.text$mn:00002000 arg_4           = dword ptr  0Ch
.text$mn:00002000 arg_8           = dword ptr  10h
.text$mn:00002000
.text$mn:00002000                 push    ebp
.text$mn:00002001                 mov     ebp, esp
.text$mn:00002003                 sub     esp, 8
.text$mn:00002006                 mov     [ebp+var_8], ecx
.text$mn:00002009                 lea     eax, [ebp+var_1]
.text$mn:0000200C                 push    eax
.text$mn:0000200D                 mov     ecx, [ebp+var_8]
.text$mn:00002010                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tDynamicList,std::allocator<tDynamicList>>>::_Getal(void)
.text$mn:00002015                 lea     ecx, [ebp+var_1]
.text$mn:00002018                 push    ecx
.text$mn:00002019                 mov     edx, [ebp+arg_8]
.text$mn:0000201C                 push    edx
.text$mn:0000201D                 mov     eax, [ebp+arg_4]
.text$mn:00002020                 push    eax
.text$mn:00002021                 mov     ecx, [ebp+arg_0]
.text$mn:00002024                 push    ecx
.text$mn:00002025                 call    ??$_Uninitialized_move@PAUtDynamicList@@PAU1@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@@Z ; std::_Uninitialized_move<tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &)
.text$mn:0000202A                 add     esp, 10h
.text$mn:0000202D                 mov     esp, ebp
.text$mn:0000202F                 pop     ebp
.text$mn:00002030                 retn    0Ch
.text$mn:00002030 ??$_Umove@PAUtDynamicList@@@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEPAUtDynamicList@@PAU2@00@Z endp
.text$mn:00002030
.text$mn:00002030 ; ---------------------------------------------------------------------------
.text$mn:00002033                 align 4
.text$mn:00002033 _text$mn        ends
.text$mn:00002033
.text$mn:00002034 ; ===========================================================================
.text$mn:00002034
.text$mn:00002034 ; Segment type: Pure code
.text$mn:00002034 ; Segment permissions: Read/Execute
.text$mn:00002034 _text$mn        segment para public 'CODE' use32
.text$mn:00002034                 assume cs:_text$mn
.text$mn:00002034                 ;org 2034h
.text$mn:00002034 ; COMDAT (pick any)
.text$mn:00002034                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002034
.text$mn:00002034 ; =============== S U B R O U T I N E =======================================
.text$mn:00002034
.text$mn:00002034 ; Attributes: bp-based frame
.text$mn:00002034
.text$mn:00002034 ; int * __cdecl std::_Unchecked<int *>(int *)
.text$mn:00002034                 public ??$_Unchecked@PAH@std@@YAPAHPAH@Z
.text$mn:00002034 ??$_Unchecked@PAH@std@@YAPAHPAH@Z proc near
.text$mn:00002034                                         ; CODE XREF: std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+Bp
.text$mn:00002034                                         ; std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+18p ...
.text$mn:00002034
.text$mn:00002034 arg_0           = dword ptr  8
.text$mn:00002034
.text$mn:00002034                 push    ebp
.text$mn:00002035                 mov     ebp, esp
.text$mn:00002037                 mov     eax, [ebp+arg_0]
.text$mn:0000203A                 pop     ebp
.text$mn:0000203B                 retn
.text$mn:0000203B ??$_Unchecked@PAH@std@@YAPAHPAH@Z endp
.text$mn:0000203B
.text$mn:0000203B _text$mn        ends
.text$mn:0000203B
.text$mn:0000203C ; ===========================================================================
.text$mn:0000203C
.text$mn:0000203C ; Segment type: Pure code
.text$mn:0000203C ; Segment permissions: Read/Execute
.text$mn:0000203C _text$mn        segment para public 'CODE' use32
.text$mn:0000203C                 assume cs:_text$mn
.text$mn:0000203C                 ;org 203Ch
.text$mn:0000203C ; COMDAT (pick any)
.text$mn:0000203C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000203C
.text$mn:0000203C ; =============== S U B R O U T I N E =======================================
.text$mn:0000203C
.text$mn:0000203C ; Attributes: bp-based frame
.text$mn:0000203C
.text$mn:0000203C ; struct iconLocator * __cdecl std::_Unchecked<struct iconLocator *>(struct iconLocator *)
.text$mn:0000203C                 public ??$_Unchecked@PAUiconLocator@@@std@@YAPAUiconLocator@@PAU1@@Z
.text$mn:0000203C ??$_Unchecked@PAUiconLocator@@@std@@YAPAUiconLocator@@PAU1@@Z proc near
.text$mn:0000203C                                         ; CODE XREF: std::_Uninitialized_move<iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &)+Bp
.text$mn:0000203C                                         ; std::_Uninitialized_move<iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &)+18p ...
.text$mn:0000203C
.text$mn:0000203C arg_0           = dword ptr  8
.text$mn:0000203C
.text$mn:0000203C                 push    ebp
.text$mn:0000203D                 mov     ebp, esp
.text$mn:0000203F                 mov     eax, [ebp+arg_0]
.text$mn:00002042                 pop     ebp
.text$mn:00002043                 retn
.text$mn:00002043 ??$_Unchecked@PAUiconLocator@@@std@@YAPAUiconLocator@@PAU1@@Z endp
.text$mn:00002043
.text$mn:00002043 _text$mn        ends
.text$mn:00002043
.text$mn:00002044 ; ===========================================================================
.text$mn:00002044
.text$mn:00002044 ; Segment type: Pure code
.text$mn:00002044 ; Segment permissions: Read/Execute
.text$mn:00002044 _text$mn        segment para public 'CODE' use32
.text$mn:00002044                 assume cs:_text$mn
.text$mn:00002044                 ;org 2044h
.text$mn:00002044 ; COMDAT (pick any)
.text$mn:00002044                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002044
.text$mn:00002044 ; =============== S U B R O U T I N E =======================================
.text$mn:00002044
.text$mn:00002044 ; Attributes: bp-based frame
.text$mn:00002044
.text$mn:00002044 ; struct tDynamicList * __cdecl std::_Unchecked<struct tDynamicList *>(struct tDynamicList *)
.text$mn:00002044                 public ??$_Unchecked@PAUtDynamicList@@@std@@YAPAUtDynamicList@@PAU1@@Z
.text$mn:00002044 ??$_Unchecked@PAUtDynamicList@@@std@@YAPAUtDynamicList@@PAU1@@Z proc near
.text$mn:00002044                                         ; CODE XREF: std::_Uninitialized_move<tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &)+Bp
.text$mn:00002044                                         ; std::_Uninitialized_move<tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &)+18p ...
.text$mn:00002044
.text$mn:00002044 arg_0           = dword ptr  8
.text$mn:00002044
.text$mn:00002044                 push    ebp
.text$mn:00002045                 mov     ebp, esp
.text$mn:00002047                 mov     eax, [ebp+arg_0]
.text$mn:0000204A                 pop     ebp
.text$mn:0000204B                 retn
.text$mn:0000204B ??$_Unchecked@PAUtDynamicList@@@std@@YAPAUtDynamicList@@PAU1@@Z endp
.text$mn:0000204B
.text$mn:0000204B _text$mn        ends
.text$mn:0000204B
.text$mn:0000204C ; ===========================================================================
.text$mn:0000204C
.text$mn:0000204C ; Segment type: Pure code
.text$mn:0000204C ; Segment permissions: Read/Execute
.text$mn:0000204C _text$mn        segment para public 'CODE' use32
.text$mn:0000204C                 assume cs:_text$mn
.text$mn:0000204C                 ;org 204Ch
.text$mn:0000204C ; COMDAT (pick any)
.text$mn:0000204C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000204C
.text$mn:0000204C ; =============== S U B R O U T I N E =======================================
.text$mn:0000204C
.text$mn:0000204C ; Attributes: bp-based frame
.text$mn:0000204C
.text$mn:0000204C ; int __cdecl std::_Uninit_move<int,int,int>(void *Src, int, void *Dst)
.text$mn:0000204C                 public ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:0000204C ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:0000204C                                         ; CODE XREF: std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+39p
.text$mn:0000204C
.text$mn:0000204C var_4           = dword ptr -4
.text$mn:0000204C Src             = dword ptr  8
.text$mn:0000204C arg_4           = dword ptr  0Ch
.text$mn:0000204C Dst             = dword ptr  10h
.text$mn:0000204C
.text$mn:0000204C                 push    ebp
.text$mn:0000204D                 mov     ebp, esp
.text$mn:0000204F                 push    ecx
.text$mn:00002050                 push    1D6h            ; unsigned int
.text$mn:00002055                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000205A                 mov     eax, [ebp+arg_4]
.text$mn:0000205D                 push    eax             ; int
.text$mn:0000205E                 mov     ecx, [ebp+Src]
.text$mn:00002061                 push    ecx             ; int
.text$mn:00002062                 call    ??$_Debug_range@PAH@std@@YAXPAH0PB_WI@Z ; std::_Debug_range<int *>(int *,int *,wchar_t const *,uint)
.text$mn:00002067                 add     esp, 10h
.text$mn:0000206A                 push    1D7h            ; unsigned int
.text$mn:0000206F                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002074                 mov     edx, [ebp+Dst]
.text$mn:00002077                 push    edx             ; int
.text$mn:00002078                 call    ??$_Debug_pointer@H@std@@YAXPAHPB_WI@Z ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)
.text$mn:0000207D                 add     esp, 0Ch
.text$mn:00002080                 mov     eax, [ebp+arg_4]
.text$mn:00002083                 sub     eax, [ebp+Src]
.text$mn:00002086                 sar     eax, 2
.text$mn:00002089                 mov     [ebp+var_4], eax
.text$mn:0000208C                 mov     ecx, [ebp+var_4]
.text$mn:0000208F                 shl     ecx, 2
.text$mn:00002092                 push    ecx             ; Size
.text$mn:00002093                 mov     edx, [ebp+Src]
.text$mn:00002096                 push    edx             ; Src
.text$mn:00002097                 mov     eax, [ebp+Dst]
.text$mn:0000209A                 push    eax             ; Dst
.text$mn:0000209B                 call    _memmove
.text$mn:000020A0                 add     esp, 0Ch
.text$mn:000020A3                 mov     ecx, [ebp+var_4]
.text$mn:000020A6                 lea     eax, [eax+ecx*4]
.text$mn:000020A9                 mov     esp, ebp
.text$mn:000020AB                 pop     ebp
.text$mn:000020AC                 retn
.text$mn:000020AC ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:000020AC
.text$mn:000020AC ; ---------------------------------------------------------------------------
.text$mn:000020AD                 align 10h
.text$mn:000020AD _text$mn        ends
.text$mn:000020AD
.text$mn:000020B0 ; ===========================================================================
.text$mn:000020B0
.text$mn:000020B0 ; Segment type: Pure code
.text$mn:000020B0 ; Segment permissions: Read/Execute
.text$mn:000020B0 _text$mn        segment para public 'CODE' use32
.text$mn:000020B0                 assume cs:_text$mn
.text$mn:000020B0                 ;org 20B0h
.text$mn:000020B0 ; COMDAT (pick any)
.text$mn:000020B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020B0
.text$mn:000020B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000020B0
.text$mn:000020B0 ; Attributes: bp-based frame
.text$mn:000020B0
.text$mn:000020B0 ; int __cdecl std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(void *Src, int, void *Dst, int)
.text$mn:000020B0                 public ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
.text$mn:000020B0 ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z proc near
.text$mn:000020B0                                         ; CODE XREF: std::_Uninitialized_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+2Ep
.text$mn:000020B0
.text$mn:000020B0 var_1           = byte ptr -1
.text$mn:000020B0 Src             = dword ptr  8
.text$mn:000020B0 arg_4           = dword ptr  0Ch
.text$mn:000020B0 Dst             = dword ptr  10h
.text$mn:000020B0 arg_C           = dword ptr  14h
.text$mn:000020B0
.text$mn:000020B0                 push    ebp
.text$mn:000020B1                 mov     ebp, esp
.text$mn:000020B3                 push    ecx
.text$mn:000020B4                 mov     eax, [ebp+Dst]
.text$mn:000020B7                 push    eax
.text$mn:000020B8                 mov     ecx, [ebp+Src]
.text$mn:000020BB                 push    ecx
.text$mn:000020BC                 call    ??$_Ptr_cat@HH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAH0@Z ; std::_Ptr_cat<int,int>(int *,int *)
.text$mn:000020C1                 add     esp, 8
.text$mn:000020C4                 mov     [ebp+var_1], al
.text$mn:000020C7                 movzx   edx, [ebp+var_1]
.text$mn:000020CB                 push    edx
.text$mn:000020CC                 mov     eax, [ebp+Src]
.text$mn:000020CF                 push    eax
.text$mn:000020D0                 call    ??$_Val_type@PAH@std@@YAPAHPAH@Z ; std::_Val_type<int *>(int *)
.text$mn:000020D5                 add     esp, 4
.text$mn:000020D8                 push    eax
.text$mn:000020D9                 mov     ecx, [ebp+arg_C]
.text$mn:000020DC                 push    ecx
.text$mn:000020DD                 mov     edx, [ebp+Dst]
.text$mn:000020E0                 push    edx             ; Dst
.text$mn:000020E1                 mov     eax, [ebp+arg_4]
.text$mn:000020E4                 push    eax             ; int
.text$mn:000020E5                 mov     ecx, [ebp+Src]
.text$mn:000020E8                 push    ecx             ; Src
.text$mn:000020E9                 call    ??$_Uninit_move@HHH@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<int,int,int>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)
.text$mn:000020EE                 add     esp, 18h
.text$mn:000020F1                 mov     esp, ebp
.text$mn:000020F3                 pop     ebp
.text$mn:000020F4                 retn
.text$mn:000020F4 ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z endp
.text$mn:000020F4
.text$mn:000020F4 ; ---------------------------------------------------------------------------
.text$mn:000020F5                 align 4
.text$mn:000020F5 _text$mn        ends
.text$mn:000020F5
.text$mn:000020F8 ; ===========================================================================
.text$mn:000020F8
.text$mn:000020F8 ; Segment type: Pure code
.text$mn:000020F8 ; Segment permissions: Read/Execute
.text$mn:000020F8 _text$mn        segment para public 'CODE' use32
.text$mn:000020F8                 assume cs:_text$mn
.text$mn:000020F8                 ;org 20F8h
.text$mn:000020F8 ; COMDAT (pick any)
.text$mn:000020F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020F8
.text$mn:000020F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000020F8
.text$mn:000020F8 ; Attributes: bp-based frame
.text$mn:000020F8
.text$mn:000020F8 ; int __cdecl std::_Uninit_move<iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>>>(int, int, void *, int)
.text$mn:000020F8                 public ??$_Uninit_move@PAUiconLocator@@PAU1@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@@Z
.text$mn:000020F8 ??$_Uninit_move@PAUiconLocator@@PAU1@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@@Z proc near
.text$mn:000020F8                                         ; CODE XREF: std::_Uninitialized_move<iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &)+2Ep
.text$mn:000020F8
.text$mn:000020F8 var_1           = byte ptr -1
.text$mn:000020F8 arg_0           = dword ptr  8
.text$mn:000020F8 arg_4           = dword ptr  0Ch
.text$mn:000020F8 arg_8           = dword ptr  10h
.text$mn:000020F8 arg_C           = dword ptr  14h
.text$mn:000020F8
.text$mn:000020F8                 push    ebp
.text$mn:000020F9                 mov     ebp, esp
.text$mn:000020FB                 push    ecx
.text$mn:000020FC                 mov     eax, [ebp+arg_8]
.text$mn:000020FF                 push    eax
.text$mn:00002100                 mov     ecx, [ebp+arg_0]
.text$mn:00002103                 push    ecx
.text$mn:00002104                 call    ??$_Ptr_cat@UiconLocator@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUiconLocator@@0@Z ; std::_Ptr_cat<iconLocator,iconLocator>(iconLocator *,iconLocator *)
.text$mn:00002109                 add     esp, 8
.text$mn:0000210C                 mov     [ebp+var_1], al
.text$mn:0000210F                 movzx   edx, [ebp+var_1]
.text$mn:00002113                 push    edx
.text$mn:00002114                 mov     eax, [ebp+arg_0]
.text$mn:00002117                 push    eax
.text$mn:00002118                 call    ??$_Val_type@PAUiconLocator@@@std@@YAPAUiconLocator@@PAU1@@Z ; std::_Val_type<iconLocator *>(iconLocator *)
.text$mn:0000211D                 add     esp, 4
.text$mn:00002120                 push    eax
.text$mn:00002121                 mov     ecx, [ebp+arg_C]
.text$mn:00002124                 push    ecx             ; int
.text$mn:00002125                 mov     edx, [ebp+arg_8]
.text$mn:00002128                 push    edx             ; void *
.text$mn:00002129                 mov     eax, [ebp+arg_4]
.text$mn:0000212C                 push    eax             ; int
.text$mn:0000212D                 mov     ecx, [ebp+arg_0]
.text$mn:00002130                 push    ecx             ; int
.text$mn:00002131                 call    ??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<iconLocator *,iconLocator *,std::allocator<iconLocator>,iconLocator>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &,iconLocator *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002136                 add     esp, 18h
.text$mn:00002139                 mov     esp, ebp
.text$mn:0000213B                 pop     ebp
.text$mn:0000213C                 retn
.text$mn:0000213C ??$_Uninit_move@PAUiconLocator@@PAU1@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@@Z endp
.text$mn:0000213C
.text$mn:0000213C ; ---------------------------------------------------------------------------
.text$mn:0000213D                 align 10h
.text$mn:0000213D _text$mn        ends
.text$mn:0000213D
.text$mn:00002140 ; ===========================================================================
.text$mn:00002140
.text$mn:00002140 ; Segment type: Pure code
.text$mn:00002140 ; Segment permissions: Read/Execute
.text$mn:00002140 _text$mn        segment para public 'CODE' use32
.text$mn:00002140                 assume cs:_text$mn
.text$mn:00002140                 ;org 2140h
.text$mn:00002140 ; COMDAT (pick any)
.text$mn:00002140                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002140
.text$mn:00002140 ; =============== S U B R O U T I N E =======================================
.text$mn:00002140
.text$mn:00002140 ; Attributes: bp-based frame
.text$mn:00002140
.text$mn:00002140 ; int __cdecl std::_Uninit_move<iconLocator *,iconLocator *,std::allocator<iconLocator>,iconLocator>(int, int, void *, int)
.text$mn:00002140                 public ??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002140 ??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002140                                         ; CODE XREF: std::_Uninit_move<iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &)+39p
.text$mn:00002140
.text$mn:00002140 var_14          = dword ptr -14h
.text$mn:00002140 var_10          = dword ptr -10h
.text$mn:00002140 var_C           = dword ptr -0Ch
.text$mn:00002140 var_4           = dword ptr -4
.text$mn:00002140 arg_0           = dword ptr  8
.text$mn:00002140 arg_4           = dword ptr  0Ch
.text$mn:00002140 arg_8           = dword ptr  10h
.text$mn:00002140 arg_C           = dword ptr  14h
.text$mn:00002140
.text$mn:00002140 ; FUNCTION CHUNK AT .text$mn:00002207 SIZE 00000009 BYTES
.text$mn:00002140 ; FUNCTION CHUNK AT .text$mn:00002217 SIZE 00000015 BYTES
.text$mn:00002140
.text$mn:00002140                 push    ebp
.text$mn:00002141                 mov     ebp, esp
.text$mn:00002143                 push    0FFFFFFFFh
.text$mn:00002145                 push    offset __ehhandler$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000214A                 mov     eax, large fs:0
.text$mn:00002150                 push    eax
.text$mn:00002151                 push    ecx
.text$mn:00002152                 push    ecx
.text$mn:00002153                 push    ebx
.text$mn:00002154                 push    esi
.text$mn:00002155                 push    edi
.text$mn:00002156                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000215B                 xor     eax, ebp
.text$mn:0000215D                 push    eax
.text$mn:0000215E                 lea     eax, [ebp+var_C]
.text$mn:00002161                 mov     large fs:0, eax
.text$mn:00002167                 mov     [ebp+var_10], esp
.text$mn:0000216A                 push    1B6h            ; unsigned int
.text$mn:0000216F                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002174                 mov     eax, [ebp+arg_4]
.text$mn:00002177                 push    eax             ; int
.text$mn:00002178                 mov     ecx, [ebp+arg_0]
.text$mn:0000217B                 push    ecx             ; int
.text$mn:0000217C                 call    ??$_Debug_range@PAUiconLocator@@@std@@YAXPAUiconLocator@@0PB_WI@Z ; std::_Debug_range<iconLocator *>(iconLocator *,iconLocator *,wchar_t const *,uint)
.text$mn:00002181                 add     esp, 10h
.text$mn:00002184                 push    1B7h            ; unsigned int
.text$mn:00002189                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000218E                 mov     edx, [ebp+arg_8]
.text$mn:00002191                 push    edx             ; int
.text$mn:00002192                 call    ??$_Debug_pointer@UiconLocator@@@std@@YAXPAUiconLocator@@PB_WI@Z ; std::_Debug_pointer<iconLocator>(iconLocator *,wchar_t const *,uint)
.text$mn:00002197                 add     esp, 0Ch
.text$mn:0000219A                 mov     eax, [ebp+arg_8]
.text$mn:0000219D                 mov     [ebp+var_14], eax
.text$mn:000021A0                 mov     [ebp+var_4], 0
.text$mn:000021A7                 jmp     short loc_21BB
.text$mn:000021A9 ; ---------------------------------------------------------------------------
.text$mn:000021A9
.text$mn:000021A9 loc_21A9:                               ; CODE XREF: std::_Uninit_move<iconLocator *,iconLocator *,std::allocator<iconLocator>,iconLocator>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &,iconLocator *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:000021A9                 mov     ecx, [ebp+arg_8]
.text$mn:000021AC                 add     ecx, 24h ; '$'
.text$mn:000021AF                 mov     [ebp+arg_8], ecx
.text$mn:000021B2                 mov     edx, [ebp+arg_0]
.text$mn:000021B5                 add     edx, 24h ; '$'
.text$mn:000021B8                 mov     [ebp+arg_0], edx
.text$mn:000021BB
.text$mn:000021BB loc_21BB:                               ; CODE XREF: std::_Uninit_move<iconLocator *,iconLocator *,std::allocator<iconLocator>,iconLocator>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &,iconLocator *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:000021BB                 mov     eax, [ebp+arg_0]
.text$mn:000021BE                 cmp     eax, [ebp+arg_4]
.text$mn:000021C1                 jz      short loc_21D5
.text$mn:000021C3                 mov     ecx, [ebp+arg_0]
.text$mn:000021C6                 push    ecx             ; int
.text$mn:000021C7                 mov     edx, [ebp+arg_8]
.text$mn:000021CA                 push    edx             ; void *
.text$mn:000021CB                 mov     ecx, [ebp+arg_C]
.text$mn:000021CE                 call    ??$construct@UiconLocator@@U1@@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<iconLocator>>::construct<iconLocator,iconLocator>(iconLocator *,iconLocator &&)
.text$mn:000021D3                 jmp     short loc_21A9
.text$mn:000021D5 ; ---------------------------------------------------------------------------
.text$mn:000021D5
.text$mn:000021D5 loc_21D5:                               ; CODE XREF: std::_Uninit_move<iconLocator *,iconLocator *,std::allocator<iconLocator>,iconLocator>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &,iconLocator *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:000021D5                 jmp     short loc_2207
.text$mn:000021D5 ??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000021D5
.text$mn:000021D7
.text$mn:000021D7 ; =============== S U B R O U T I N E =======================================
.text$mn:000021D7
.text$mn:000021D7 ; Attributes: noreturn
.text$mn:000021D7
.text$mn:000021D7 __catch$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:000021D7                                         ; DATA XREF: .xdata$x:0000875Co
.text$mn:000021D7                 jmp     short loc_21E2
.text$mn:000021D9 ; ---------------------------------------------------------------------------
.text$mn:000021D9
.text$mn:000021D9 loc_21D9:                               ; CODE XREF: __catch$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:000021D9                 mov     eax, [ebp-14h]
.text$mn:000021DC                 add     eax, 24h ; '$'
.text$mn:000021DF                 mov     [ebp-14h], eax
.text$mn:000021E2
.text$mn:000021E2 loc_21E2:                               ; CODE XREF: __catch$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:000021E2                 mov     ecx, [ebp-14h]
.text$mn:000021E5                 cmp     ecx, [ebp+10h]
.text$mn:000021E8                 jz      short loc_21F8
.text$mn:000021EA                 mov     edx, [ebp-14h]
.text$mn:000021ED                 push    edx
.text$mn:000021EE                 mov     ecx, [ebp+14h]
.text$mn:000021F1                 call    ??$destroy@UiconLocator@@@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@@Z ; std::_Wrap_alloc<std::allocator<iconLocator>>::destroy<iconLocator>(iconLocator *)
.text$mn:000021F6                 jmp     short loc_21D9
.text$mn:000021F8 ; ---------------------------------------------------------------------------
.text$mn:000021F8
.text$mn:000021F8 loc_21F8:                               ; CODE XREF: __catch$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:000021F8                 push    0
.text$mn:000021FA                 push    0
.text$mn:000021FC                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000021FC __catch$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:000021FC
.text$mn:00002201 ; ---------------------------------------------------------------------------
.text$mn:00002201                 mov     eax, offset $LN13_0
.text$mn:00002206                 retn
.text$mn:00002207 ; ---------------------------------------------------------------------------
.text$mn:00002207 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002207
.text$mn:00002207 loc_2207:                               ; CODE XREF: std::_Uninit_move<iconLocator *,iconLocator *,std::allocator<iconLocator>,iconLocator>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &,iconLocator *,std::_Nonscalar_ptr_iterator_tag):loc_21D5j
.text$mn:00002207                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000220E                 jmp     short loc_2217
.text$mn:0000220E ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002210
.text$mn:00002210 ; =============== S U B R O U T I N E =======================================
.text$mn:00002210
.text$mn:00002210
.text$mn:00002210 $LN13_0         proc near               ; DATA XREF: .text$mn:00002201o
.text$mn:00002210                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002210 $LN13_0         endp ; sp-analysis failed
.text$mn:00002210
.text$mn:00002217 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002217
.text$mn:00002217 loc_2217:                               ; CODE XREF: std::_Uninit_move<iconLocator *,iconLocator *,std::allocator<iconLocator>,iconLocator>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &,iconLocator *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:00002217                 mov     eax, [ebp+arg_8]
.text$mn:0000221A                 mov     ecx, [ebp+var_C]
.text$mn:0000221D                 mov     large fs:0, ecx
.text$mn:00002224                 pop     ecx
.text$mn:00002225                 pop     edi
.text$mn:00002226                 pop     esi
.text$mn:00002227                 pop     ebx
.text$mn:00002228                 mov     esp, ebp
.text$mn:0000222A                 pop     ebp
.text$mn:0000222B                 retn
.text$mn:0000222B ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000222B _text$mn        ends
.text$mn:0000222B
.text$x:0000222C ; ===========================================================================
.text$x:0000222C
.text$x:0000222C ; Segment type: Pure code
.text$x:0000222C ; Segment permissions: Read/Execute
.text$x:0000222C _text$x         segment para public 'CODE' use32
.text$x:0000222C                 assume cs:_text$x
.text$x:0000222C                 ;org 222Ch
.text$x:0000222C ; COMDAT (pick associative to section at 2140)
.text$x:0000222C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000222C
.text$x:0000222C ; =============== S U B R O U T I N E =======================================
.text$x:0000222C
.text$x:0000222C
.text$x:0000222C __ehhandler$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:0000222C                                         ; DATA XREF: std::_Uninit_move<iconLocator *,iconLocator *,std::allocator<iconLocator>,iconLocator>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &,iconLocator *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:0000222C
.text$x:0000222C arg_4           = dword ptr  8
.text$x:0000222C
.text$x:0000222C                 mov     edx, [esp+arg_4]
.text$x:00002230                 lea     eax, [edx+0Ch]
.text$x:00002233                 mov     ecx, [edx-18h]
.text$x:00002236                 xor     ecx, eax
.text$x:00002238                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000223D                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00002242                 jmp     ___CxxFrameHandler3
.text$x:00002242 __ehhandler$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00002242
.text$x:00002242 ; ---------------------------------------------------------------------------
.text$x:00002247                 align 4
.text$x:00002247 _text$x         ends
.text$x:00002247
.text$mn:00002248 ; ===========================================================================
.text$mn:00002248
.text$mn:00002248 ; Segment type: Pure code
.text$mn:00002248 ; Segment permissions: Read/Execute
.text$mn:00002248 _text$mn        segment para public 'CODE' use32
.text$mn:00002248                 assume cs:_text$mn
.text$mn:00002248                 ;org 2248h
.text$mn:00002248 ; COMDAT (pick any)
.text$mn:00002248                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002248
.text$mn:00002248 ; =============== S U B R O U T I N E =======================================
.text$mn:00002248
.text$mn:00002248 ; Attributes: bp-based frame
.text$mn:00002248
.text$mn:00002248 ; int __cdecl std::_Uninit_move<tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>>>(int, int, void *, int)
.text$mn:00002248                 public ??$_Uninit_move@PAUtDynamicList@@PAU1@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@@Z
.text$mn:00002248 ??$_Uninit_move@PAUtDynamicList@@PAU1@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@@Z proc near
.text$mn:00002248                                         ; CODE XREF: std::_Uninitialized_move<tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &)+2Ep
.text$mn:00002248
.text$mn:00002248 var_1           = byte ptr -1
.text$mn:00002248 arg_0           = dword ptr  8
.text$mn:00002248 arg_4           = dword ptr  0Ch
.text$mn:00002248 arg_8           = dword ptr  10h
.text$mn:00002248 arg_C           = dword ptr  14h
.text$mn:00002248
.text$mn:00002248                 push    ebp
.text$mn:00002249                 mov     ebp, esp
.text$mn:0000224B                 push    ecx
.text$mn:0000224C                 mov     eax, [ebp+arg_8]
.text$mn:0000224F                 push    eax
.text$mn:00002250                 mov     ecx, [ebp+arg_0]
.text$mn:00002253                 push    ecx
.text$mn:00002254                 call    ??$_Ptr_cat@UtDynamicList@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUtDynamicList@@0@Z ; std::_Ptr_cat<tDynamicList,tDynamicList>(tDynamicList *,tDynamicList *)
.text$mn:00002259                 add     esp, 8
.text$mn:0000225C                 mov     [ebp+var_1], al
.text$mn:0000225F                 movzx   edx, [ebp+var_1]
.text$mn:00002263                 push    edx
.text$mn:00002264                 mov     eax, [ebp+arg_0]
.text$mn:00002267                 push    eax
.text$mn:00002268                 call    ??$_Val_type@PAUtDynamicList@@@std@@YAPAUtDynamicList@@PAU1@@Z ; std::_Val_type<tDynamicList *>(tDynamicList *)
.text$mn:0000226D                 add     esp, 4
.text$mn:00002270                 push    eax
.text$mn:00002271                 mov     ecx, [ebp+arg_C]
.text$mn:00002274                 push    ecx             ; int
.text$mn:00002275                 mov     edx, [ebp+arg_8]
.text$mn:00002278                 push    edx             ; void *
.text$mn:00002279                 mov     eax, [ebp+arg_4]
.text$mn:0000227C                 push    eax             ; int
.text$mn:0000227D                 mov     ecx, [ebp+arg_0]
.text$mn:00002280                 push    ecx             ; int
.text$mn:00002281                 call    ??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<tDynamicList *,tDynamicList *,std::allocator<tDynamicList>,tDynamicList>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &,tDynamicList *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002286                 add     esp, 18h
.text$mn:00002289                 mov     esp, ebp
.text$mn:0000228B                 pop     ebp
.text$mn:0000228C                 retn
.text$mn:0000228C ??$_Uninit_move@PAUtDynamicList@@PAU1@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@@Z endp
.text$mn:0000228C
.text$mn:0000228C ; ---------------------------------------------------------------------------
.text$mn:0000228D                 align 10h
.text$mn:0000228D _text$mn        ends
.text$mn:0000228D
.text$mn:00002290 ; ===========================================================================
.text$mn:00002290
.text$mn:00002290 ; Segment type: Pure code
.text$mn:00002290 ; Segment permissions: Read/Execute
.text$mn:00002290 _text$mn        segment para public 'CODE' use32
.text$mn:00002290                 assume cs:_text$mn
.text$mn:00002290                 ;org 2290h
.text$mn:00002290 ; COMDAT (pick any)
.text$mn:00002290                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002290
.text$mn:00002290 ; =============== S U B R O U T I N E =======================================
.text$mn:00002290
.text$mn:00002290 ; Attributes: bp-based frame
.text$mn:00002290
.text$mn:00002290 ; int __cdecl std::_Uninit_move<tDynamicList *,tDynamicList *,std::allocator<tDynamicList>,tDynamicList>(int, int, void *, int)
.text$mn:00002290                 public ??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002290 ??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002290                                         ; CODE XREF: std::_Uninit_move<tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &)+39p
.text$mn:00002290
.text$mn:00002290 var_14          = dword ptr -14h
.text$mn:00002290 var_10          = dword ptr -10h
.text$mn:00002290 var_C           = dword ptr -0Ch
.text$mn:00002290 var_4           = dword ptr -4
.text$mn:00002290 arg_0           = dword ptr  8
.text$mn:00002290 arg_4           = dword ptr  0Ch
.text$mn:00002290 arg_8           = dword ptr  10h
.text$mn:00002290 arg_C           = dword ptr  14h
.text$mn:00002290
.text$mn:00002290 ; FUNCTION CHUNK AT .text$mn:00002357 SIZE 00000009 BYTES
.text$mn:00002290 ; FUNCTION CHUNK AT .text$mn:00002367 SIZE 00000015 BYTES
.text$mn:00002290
.text$mn:00002290                 push    ebp
.text$mn:00002291                 mov     ebp, esp
.text$mn:00002293                 push    0FFFFFFFFh
.text$mn:00002295                 push    offset __ehhandler$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000229A                 mov     eax, large fs:0
.text$mn:000022A0                 push    eax
.text$mn:000022A1                 push    ecx
.text$mn:000022A2                 push    ecx
.text$mn:000022A3                 push    ebx
.text$mn:000022A4                 push    esi
.text$mn:000022A5                 push    edi
.text$mn:000022A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000022AB                 xor     eax, ebp
.text$mn:000022AD                 push    eax
.text$mn:000022AE                 lea     eax, [ebp+var_C]
.text$mn:000022B1                 mov     large fs:0, eax
.text$mn:000022B7                 mov     [ebp+var_10], esp
.text$mn:000022BA                 push    1B6h            ; unsigned int
.text$mn:000022BF                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000022C4                 mov     eax, [ebp+arg_4]
.text$mn:000022C7                 push    eax             ; int
.text$mn:000022C8                 mov     ecx, [ebp+arg_0]
.text$mn:000022CB                 push    ecx             ; int
.text$mn:000022CC                 call    ??$_Debug_range@PAUtDynamicList@@@std@@YAXPAUtDynamicList@@0PB_WI@Z ; std::_Debug_range<tDynamicList *>(tDynamicList *,tDynamicList *,wchar_t const *,uint)
.text$mn:000022D1                 add     esp, 10h
.text$mn:000022D4                 push    1B7h            ; unsigned int
.text$mn:000022D9                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000022DE                 mov     edx, [ebp+arg_8]
.text$mn:000022E1                 push    edx             ; int
.text$mn:000022E2                 call    ??$_Debug_pointer@UtDynamicList@@@std@@YAXPAUtDynamicList@@PB_WI@Z ; std::_Debug_pointer<tDynamicList>(tDynamicList *,wchar_t const *,uint)
.text$mn:000022E7                 add     esp, 0Ch
.text$mn:000022EA                 mov     eax, [ebp+arg_8]
.text$mn:000022ED                 mov     [ebp+var_14], eax
.text$mn:000022F0                 mov     [ebp+var_4], 0
.text$mn:000022F7                 jmp     short loc_230B
.text$mn:000022F9 ; ---------------------------------------------------------------------------
.text$mn:000022F9
.text$mn:000022F9 loc_22F9:                               ; CODE XREF: std::_Uninit_move<tDynamicList *,tDynamicList *,std::allocator<tDynamicList>,tDynamicList>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &,tDynamicList *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:000022F9                 mov     ecx, [ebp+arg_8]
.text$mn:000022FC                 add     ecx, 0Ch
.text$mn:000022FF                 mov     [ebp+arg_8], ecx
.text$mn:00002302                 mov     edx, [ebp+arg_0]
.text$mn:00002305                 add     edx, 0Ch
.text$mn:00002308                 mov     [ebp+arg_0], edx
.text$mn:0000230B
.text$mn:0000230B loc_230B:                               ; CODE XREF: std::_Uninit_move<tDynamicList *,tDynamicList *,std::allocator<tDynamicList>,tDynamicList>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &,tDynamicList *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:0000230B                 mov     eax, [ebp+arg_0]
.text$mn:0000230E                 cmp     eax, [ebp+arg_4]
.text$mn:00002311                 jz      short loc_2325
.text$mn:00002313                 mov     ecx, [ebp+arg_0]
.text$mn:00002316                 push    ecx             ; int
.text$mn:00002317                 mov     edx, [ebp+arg_8]
.text$mn:0000231A                 push    edx             ; void *
.text$mn:0000231B                 mov     ecx, [ebp+arg_C]
.text$mn:0000231E                 call    ??$construct@UtDynamicList@@U1@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList>(tDynamicList *,tDynamicList &&)
.text$mn:00002323                 jmp     short loc_22F9
.text$mn:00002325 ; ---------------------------------------------------------------------------
.text$mn:00002325
.text$mn:00002325 loc_2325:                               ; CODE XREF: std::_Uninit_move<tDynamicList *,tDynamicList *,std::allocator<tDynamicList>,tDynamicList>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &,tDynamicList *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00002325                 jmp     short loc_2357
.text$mn:00002325 ??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002325
.text$mn:00002327
.text$mn:00002327 ; =============== S U B R O U T I N E =======================================
.text$mn:00002327
.text$mn:00002327 ; Attributes: noreturn
.text$mn:00002327
.text$mn:00002327 __catch$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00002327                                         ; DATA XREF: .xdata$x:00008704o
.text$mn:00002327                 jmp     short loc_2332
.text$mn:00002329 ; ---------------------------------------------------------------------------
.text$mn:00002329
.text$mn:00002329 loc_2329:                               ; CODE XREF: __catch$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00002329                 mov     eax, [ebp-14h]
.text$mn:0000232C                 add     eax, 0Ch
.text$mn:0000232F                 mov     [ebp-14h], eax
.text$mn:00002332
.text$mn:00002332 loc_2332:                               ; CODE XREF: __catch$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:00002332                 mov     ecx, [ebp-14h]
.text$mn:00002335                 cmp     ecx, [ebp+10h]
.text$mn:00002338                 jz      short loc_2348
.text$mn:0000233A                 mov     edx, [ebp-14h]
.text$mn:0000233D                 push    edx
.text$mn:0000233E                 mov     ecx, [ebp+14h]
.text$mn:00002341                 call    ??$destroy@UtDynamicList@@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@@Z ; std::_Wrap_alloc<std::allocator<tDynamicList>>::destroy<tDynamicList>(tDynamicList *)
.text$mn:00002346                 jmp     short loc_2329
.text$mn:00002348 ; ---------------------------------------------------------------------------
.text$mn:00002348
.text$mn:00002348 loc_2348:                               ; CODE XREF: __catch$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:00002348                 push    0
.text$mn:0000234A                 push    0
.text$mn:0000234C                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000234C __catch$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:0000234C
.text$mn:00002351 ; ---------------------------------------------------------------------------
.text$mn:00002351                 mov     eax, offset $LN13
.text$mn:00002356                 retn
.text$mn:00002357 ; ---------------------------------------------------------------------------
.text$mn:00002357 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002357
.text$mn:00002357 loc_2357:                               ; CODE XREF: std::_Uninit_move<tDynamicList *,tDynamicList *,std::allocator<tDynamicList>,tDynamicList>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &,tDynamicList *,std::_Nonscalar_ptr_iterator_tag):loc_2325j
.text$mn:00002357                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000235E                 jmp     short loc_2367
.text$mn:0000235E ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002360
.text$mn:00002360 ; =============== S U B R O U T I N E =======================================
.text$mn:00002360
.text$mn:00002360
.text$mn:00002360 $LN13           proc near               ; DATA XREF: .text$mn:00002351o
.text$mn:00002360                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002360 $LN13           endp ; sp-analysis failed
.text$mn:00002360
.text$mn:00002367 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002367
.text$mn:00002367 loc_2367:                               ; CODE XREF: std::_Uninit_move<tDynamicList *,tDynamicList *,std::allocator<tDynamicList>,tDynamicList>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &,tDynamicList *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:00002367                 mov     eax, [ebp+arg_8]
.text$mn:0000236A                 mov     ecx, [ebp+var_C]
.text$mn:0000236D                 mov     large fs:0, ecx
.text$mn:00002374                 pop     ecx
.text$mn:00002375                 pop     edi
.text$mn:00002376                 pop     esi
.text$mn:00002377                 pop     ebx
.text$mn:00002378                 mov     esp, ebp
.text$mn:0000237A                 pop     ebp
.text$mn:0000237B                 retn
.text$mn:0000237B ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000237B _text$mn        ends
.text$mn:0000237B
.text$x:0000237C ; ===========================================================================
.text$x:0000237C
.text$x:0000237C ; Segment type: Pure code
.text$x:0000237C ; Segment permissions: Read/Execute
.text$x:0000237C _text$x         segment para public 'CODE' use32
.text$x:0000237C                 assume cs:_text$x
.text$x:0000237C                 ;org 237Ch
.text$x:0000237C ; COMDAT (pick associative to section at 2290)
.text$x:0000237C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000237C
.text$x:0000237C ; =============== S U B R O U T I N E =======================================
.text$x:0000237C
.text$x:0000237C
.text$x:0000237C __ehhandler$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:0000237C                                         ; DATA XREF: std::_Uninit_move<tDynamicList *,tDynamicList *,std::allocator<tDynamicList>,tDynamicList>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &,tDynamicList *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:0000237C
.text$x:0000237C arg_4           = dword ptr  8
.text$x:0000237C
.text$x:0000237C                 mov     edx, [esp+arg_4]
.text$x:00002380                 lea     eax, [edx+0Ch]
.text$x:00002383                 mov     ecx, [edx-18h]
.text$x:00002386                 xor     ecx, eax
.text$x:00002388                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000238D                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00002392                 jmp     ___CxxFrameHandler3
.text$x:00002392 __ehhandler$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00002392
.text$x:00002392 ; ---------------------------------------------------------------------------
.text$x:00002397                 align 4
.text$x:00002397 _text$x         ends
.text$x:00002397
.text$mn:00002398 ; ===========================================================================
.text$mn:00002398
.text$mn:00002398 ; Segment type: Pure code
.text$mn:00002398 ; Segment permissions: Read/Execute
.text$mn:00002398 _text$mn        segment para public 'CODE' use32
.text$mn:00002398                 assume cs:_text$mn
.text$mn:00002398                 ;org 2398h
.text$mn:00002398 ; COMDAT (pick any)
.text$mn:00002398                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002398
.text$mn:00002398 ; =============== S U B R O U T I N E =======================================
.text$mn:00002398
.text$mn:00002398 ; Attributes: bp-based frame
.text$mn:00002398
.text$mn:00002398 ; int * __cdecl std::_Uninitialized_move<int *, int *, struct std::_Wrap_alloc<class std::allocator<int>>>(int *, int *, int *, struct std::_Wrap_alloc<class std::allocator<int>> &)
.text$mn:00002398                 public ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z
.text$mn:00002398 ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z proc near
.text$mn:00002398                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Umove<int *>(int *,int *,int *)+25p
.text$mn:00002398
.text$mn:00002398 arg_0           = dword ptr  8
.text$mn:00002398 arg_4           = dword ptr  0Ch
.text$mn:00002398 arg_8           = dword ptr  10h
.text$mn:00002398 arg_C           = dword ptr  14h
.text$mn:00002398
.text$mn:00002398                 push    ebp
.text$mn:00002399                 mov     ebp, esp
.text$mn:0000239B                 mov     eax, [ebp+arg_C]
.text$mn:0000239E                 push    eax             ; int
.text$mn:0000239F                 mov     ecx, [ebp+arg_8]
.text$mn:000023A2                 push    ecx
.text$mn:000023A3                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:000023A8                 add     esp, 4
.text$mn:000023AB                 push    eax             ; Dst
.text$mn:000023AC                 mov     edx, [ebp+arg_4]
.text$mn:000023AF                 push    edx
.text$mn:000023B0                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:000023B5                 add     esp, 4
.text$mn:000023B8                 push    eax             ; int
.text$mn:000023B9                 mov     eax, [ebp+arg_0]
.text$mn:000023BC                 push    eax
.text$mn:000023BD                 call    ??$_Unchecked@PAH@std@@YAPAHPAH@Z ; std::_Unchecked<int *>(int *)
.text$mn:000023C2                 add     esp, 4
.text$mn:000023C5                 push    eax             ; Src
.text$mn:000023C6                 call    ??$_Uninit_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)
.text$mn:000023CB                 add     esp, 10h
.text$mn:000023CE                 push    eax
.text$mn:000023CF                 lea     ecx, [ebp+arg_8]
.text$mn:000023D2                 push    ecx
.text$mn:000023D3                 call    ??$_Rechecked@PAHPAH@std@@YAAAPAHAAPAHPAH@Z ; std::_Rechecked<int *,int *>(int * &,int *)
.text$mn:000023D8                 add     esp, 8
.text$mn:000023DB                 mov     eax, [eax]
.text$mn:000023DD                 pop     ebp
.text$mn:000023DE                 retn
.text$mn:000023DE ??$_Uninitialized_move@PAHPAHU?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAPAHPAH00AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z endp
.text$mn:000023DE
.text$mn:000023DE ; ---------------------------------------------------------------------------
.text$mn:000023DF                 align 10h
.text$mn:000023DF _text$mn        ends
.text$mn:000023DF
.text$mn:000023E0 ; ===========================================================================
.text$mn:000023E0
.text$mn:000023E0 ; Segment type: Pure code
.text$mn:000023E0 ; Segment permissions: Read/Execute
.text$mn:000023E0 _text$mn        segment para public 'CODE' use32
.text$mn:000023E0                 assume cs:_text$mn
.text$mn:000023E0                 ;org 23E0h
.text$mn:000023E0 ; COMDAT (pick any)
.text$mn:000023E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023E0
.text$mn:000023E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000023E0
.text$mn:000023E0 ; Attributes: bp-based frame
.text$mn:000023E0
.text$mn:000023E0 ; struct iconLocator * __cdecl std::_Uninitialized_move<struct iconLocator *, struct iconLocator *, struct std::_Wrap_alloc<class std::allocator<struct iconLocator>>>(struct iconLocator *, struct iconLocator *, struct iconLocator *, struct std::_Wrap_alloc<class std::allocator<struct iconLocator>> &)
.text$mn:000023E0                 public ??$_Uninitialized_move@PAUiconLocator@@PAU1@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@@Z
.text$mn:000023E0 ??$_Uninitialized_move@PAUiconLocator@@PAU1@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@@Z proc near
.text$mn:000023E0                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Umove<iconLocator *>(iconLocator *,iconLocator *,iconLocator *)+25p
.text$mn:000023E0
.text$mn:000023E0 arg_0           = dword ptr  8
.text$mn:000023E0 arg_4           = dword ptr  0Ch
.text$mn:000023E0 arg_8           = dword ptr  10h
.text$mn:000023E0 arg_C           = dword ptr  14h
.text$mn:000023E0
.text$mn:000023E0                 push    ebp
.text$mn:000023E1                 mov     ebp, esp
.text$mn:000023E3                 mov     eax, [ebp+arg_C]
.text$mn:000023E6                 push    eax             ; int
.text$mn:000023E7                 mov     ecx, [ebp+arg_8]
.text$mn:000023EA                 push    ecx
.text$mn:000023EB                 call    ??$_Unchecked@PAUiconLocator@@@std@@YAPAUiconLocator@@PAU1@@Z ; std::_Unchecked<iconLocator *>(iconLocator *)
.text$mn:000023F0                 add     esp, 4
.text$mn:000023F3                 push    eax             ; void *
.text$mn:000023F4                 mov     edx, [ebp+arg_4]
.text$mn:000023F7                 push    edx
.text$mn:000023F8                 call    ??$_Unchecked@PAUiconLocator@@@std@@YAPAUiconLocator@@PAU1@@Z ; std::_Unchecked<iconLocator *>(iconLocator *)
.text$mn:000023FD                 add     esp, 4
.text$mn:00002400                 push    eax             ; int
.text$mn:00002401                 mov     eax, [ebp+arg_0]
.text$mn:00002404                 push    eax
.text$mn:00002405                 call    ??$_Unchecked@PAUiconLocator@@@std@@YAPAUiconLocator@@PAU1@@Z ; std::_Unchecked<iconLocator *>(iconLocator *)
.text$mn:0000240A                 add     esp, 4
.text$mn:0000240D                 push    eax             ; int
.text$mn:0000240E                 call    ??$_Uninit_move@PAUiconLocator@@PAU1@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@@Z ; std::_Uninit_move<iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &)
.text$mn:00002413                 add     esp, 10h
.text$mn:00002416                 push    eax
.text$mn:00002417                 lea     ecx, [ebp+arg_8]
.text$mn:0000241A                 push    ecx
.text$mn:0000241B                 call    ??$_Rechecked@PAUiconLocator@@PAU1@@std@@YAAAPAUiconLocator@@AAPAU1@PAU1@@Z ; std::_Rechecked<iconLocator *,iconLocator *>(iconLocator * &,iconLocator *)
.text$mn:00002420                 add     esp, 8
.text$mn:00002423                 mov     eax, [eax]
.text$mn:00002425                 pop     ebp
.text$mn:00002426                 retn
.text$mn:00002426 ??$_Uninitialized_move@PAUiconLocator@@PAU1@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@@Z endp
.text$mn:00002426
.text$mn:00002426 ; ---------------------------------------------------------------------------
.text$mn:00002427                 align 4
.text$mn:00002427 _text$mn        ends
.text$mn:00002427
.text$mn:00002428 ; ===========================================================================
.text$mn:00002428
.text$mn:00002428 ; Segment type: Pure code
.text$mn:00002428 ; Segment permissions: Read/Execute
.text$mn:00002428 _text$mn        segment para public 'CODE' use32
.text$mn:00002428                 assume cs:_text$mn
.text$mn:00002428                 ;org 2428h
.text$mn:00002428 ; COMDAT (pick any)
.text$mn:00002428                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002428
.text$mn:00002428 ; =============== S U B R O U T I N E =======================================
.text$mn:00002428
.text$mn:00002428 ; Attributes: bp-based frame
.text$mn:00002428
.text$mn:00002428 ; struct tDynamicList * __cdecl std::_Uninitialized_move<struct tDynamicList *, struct tDynamicList *, struct std::_Wrap_alloc<class std::allocator<struct tDynamicList>>>(struct tDynamicList *, struct tDynamicList *, struct tDynamicList *, struct std::_Wrap_alloc<class std::allocator<struct tDynamicList>> &)
.text$mn:00002428                 public ??$_Uninitialized_move@PAUtDynamicList@@PAU1@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@@Z
.text$mn:00002428 ??$_Uninitialized_move@PAUtDynamicList@@PAU1@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@@Z proc near
.text$mn:00002428                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Umove<tDynamicList *>(tDynamicList *,tDynamicList *,tDynamicList *)+25p
.text$mn:00002428
.text$mn:00002428 arg_0           = dword ptr  8
.text$mn:00002428 arg_4           = dword ptr  0Ch
.text$mn:00002428 arg_8           = dword ptr  10h
.text$mn:00002428 arg_C           = dword ptr  14h
.text$mn:00002428
.text$mn:00002428                 push    ebp
.text$mn:00002429                 mov     ebp, esp
.text$mn:0000242B                 mov     eax, [ebp+arg_C]
.text$mn:0000242E                 push    eax             ; int
.text$mn:0000242F                 mov     ecx, [ebp+arg_8]
.text$mn:00002432                 push    ecx
.text$mn:00002433                 call    ??$_Unchecked@PAUtDynamicList@@@std@@YAPAUtDynamicList@@PAU1@@Z ; std::_Unchecked<tDynamicList *>(tDynamicList *)
.text$mn:00002438                 add     esp, 4
.text$mn:0000243B                 push    eax             ; void *
.text$mn:0000243C                 mov     edx, [ebp+arg_4]
.text$mn:0000243F                 push    edx
.text$mn:00002440                 call    ??$_Unchecked@PAUtDynamicList@@@std@@YAPAUtDynamicList@@PAU1@@Z ; std::_Unchecked<tDynamicList *>(tDynamicList *)
.text$mn:00002445                 add     esp, 4
.text$mn:00002448                 push    eax             ; int
.text$mn:00002449                 mov     eax, [ebp+arg_0]
.text$mn:0000244C                 push    eax
.text$mn:0000244D                 call    ??$_Unchecked@PAUtDynamicList@@@std@@YAPAUtDynamicList@@PAU1@@Z ; std::_Unchecked<tDynamicList *>(tDynamicList *)
.text$mn:00002452                 add     esp, 4
.text$mn:00002455                 push    eax             ; int
.text$mn:00002456                 call    ??$_Uninit_move@PAUtDynamicList@@PAU1@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@@Z ; std::_Uninit_move<tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &)
.text$mn:0000245B                 add     esp, 10h
.text$mn:0000245E                 push    eax
.text$mn:0000245F                 lea     ecx, [ebp+arg_8]
.text$mn:00002462                 push    ecx
.text$mn:00002463                 call    ??$_Rechecked@PAUtDynamicList@@PAU1@@std@@YAAAPAUtDynamicList@@AAPAU1@PAU1@@Z ; std::_Rechecked<tDynamicList *,tDynamicList *>(tDynamicList * &,tDynamicList *)
.text$mn:00002468                 add     esp, 8
.text$mn:0000246B                 mov     eax, [eax]
.text$mn:0000246D                 pop     ebp
.text$mn:0000246E                 retn
.text$mn:0000246E ??$_Uninitialized_move@PAUtDynamicList@@PAU1@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@@Z endp
.text$mn:0000246E
.text$mn:0000246E ; ---------------------------------------------------------------------------
.text$mn:0000246F                 align 10h
.text$mn:0000246F _text$mn        ends
.text$mn:0000246F
.text$mn:00002470 ; ===========================================================================
.text$mn:00002470
.text$mn:00002470 ; Segment type: Pure code
.text$mn:00002470 ; Segment permissions: Read/Execute
.text$mn:00002470 _text$mn        segment para public 'CODE' use32
.text$mn:00002470                 assume cs:_text$mn
.text$mn:00002470                 ;org 2470h
.text$mn:00002470 ; COMDAT (pick any)
.text$mn:00002470                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002470
.text$mn:00002470 ; =============== S U B R O U T I N E =======================================
.text$mn:00002470
.text$mn:00002470 ; Attributes: bp-based frame
.text$mn:00002470
.text$mn:00002470 ; int * __cdecl std::_Val_type<int *>(int *)
.text$mn:00002470                 public ??$_Val_type@PAH@std@@YAPAHPAH@Z
.text$mn:00002470 ??$_Val_type@PAH@std@@YAPAHPAH@Z proc near
.text$mn:00002470                                         ; CODE XREF: std::_Uninit_move<int *,int *,std::_Wrap_alloc<std::allocator<int>>>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &)+20p
.text$mn:00002470                 push    ebp
.text$mn:00002471                 mov     ebp, esp
.text$mn:00002473                 xor     eax, eax
.text$mn:00002475                 pop     ebp
.text$mn:00002476                 retn
.text$mn:00002476 ??$_Val_type@PAH@std@@YAPAHPAH@Z endp
.text$mn:00002476
.text$mn:00002476 ; ---------------------------------------------------------------------------
.text$mn:00002477                 align 4
.text$mn:00002477 _text$mn        ends
.text$mn:00002477
.text$mn:00002478 ; ===========================================================================
.text$mn:00002478
.text$mn:00002478 ; Segment type: Pure code
.text$mn:00002478 ; Segment permissions: Read/Execute
.text$mn:00002478 _text$mn        segment para public 'CODE' use32
.text$mn:00002478                 assume cs:_text$mn
.text$mn:00002478                 ;org 2478h
.text$mn:00002478 ; COMDAT (pick any)
.text$mn:00002478                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002478
.text$mn:00002478 ; =============== S U B R O U T I N E =======================================
.text$mn:00002478
.text$mn:00002478 ; Attributes: bp-based frame
.text$mn:00002478
.text$mn:00002478 ; struct iconLocator * __cdecl std::_Val_type<struct iconLocator *>(struct iconLocator *)
.text$mn:00002478                 public ??$_Val_type@PAUiconLocator@@@std@@YAPAUiconLocator@@PAU1@@Z
.text$mn:00002478 ??$_Val_type@PAUiconLocator@@@std@@YAPAUiconLocator@@PAU1@@Z proc near
.text$mn:00002478                                         ; CODE XREF: std::_Uninit_move<iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &)+20p
.text$mn:00002478                 push    ebp
.text$mn:00002479                 mov     ebp, esp
.text$mn:0000247B                 xor     eax, eax
.text$mn:0000247D                 pop     ebp
.text$mn:0000247E                 retn
.text$mn:0000247E ??$_Val_type@PAUiconLocator@@@std@@YAPAUiconLocator@@PAU1@@Z endp
.text$mn:0000247E
.text$mn:0000247E ; ---------------------------------------------------------------------------
.text$mn:0000247F                 align 10h
.text$mn:0000247F _text$mn        ends
.text$mn:0000247F
.text$mn:00002480 ; ===========================================================================
.text$mn:00002480
.text$mn:00002480 ; Segment type: Pure code
.text$mn:00002480 ; Segment permissions: Read/Execute
.text$mn:00002480 _text$mn        segment para public 'CODE' use32
.text$mn:00002480                 assume cs:_text$mn
.text$mn:00002480                 ;org 2480h
.text$mn:00002480 ; COMDAT (pick any)
.text$mn:00002480                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002480
.text$mn:00002480 ; =============== S U B R O U T I N E =======================================
.text$mn:00002480
.text$mn:00002480 ; Attributes: bp-based frame
.text$mn:00002480
.text$mn:00002480 ; struct tDynamicList * __cdecl std::_Val_type<struct tDynamicList *>(struct tDynamicList *)
.text$mn:00002480                 public ??$_Val_type@PAUtDynamicList@@@std@@YAPAUtDynamicList@@PAU1@@Z
.text$mn:00002480 ??$_Val_type@PAUtDynamicList@@@std@@YAPAUtDynamicList@@PAU1@@Z proc near
.text$mn:00002480                                         ; CODE XREF: std::_Uninit_move<tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &)+20p
.text$mn:00002480                 push    ebp
.text$mn:00002481                 mov     ebp, esp
.text$mn:00002483                 xor     eax, eax
.text$mn:00002485                 pop     ebp
.text$mn:00002486                 retn
.text$mn:00002486 ??$_Val_type@PAUtDynamicList@@@std@@YAPAUtDynamicList@@PAU1@@Z endp
.text$mn:00002486
.text$mn:00002486 ; ---------------------------------------------------------------------------
.text$mn:00002487                 align 4
.text$mn:00002487 _text$mn        ends
.text$mn:00002487
.text$mn:00002488 ; ===========================================================================
.text$mn:00002488
.text$mn:00002488 ; Segment type: Pure code
.text$mn:00002488 ; Segment permissions: Read/Execute
.text$mn:00002488 _text$mn        segment para public 'CODE' use32
.text$mn:00002488                 assume cs:_text$mn
.text$mn:00002488                 ;org 2488h
.text$mn:00002488 ; COMDAT (pick any)
.text$mn:00002488                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002488
.text$mn:00002488 ; =============== S U B R O U T I N E =======================================
.text$mn:00002488
.text$mn:00002488 ; Attributes: bp-based frame
.text$mn:00002488
.text$mn:00002488 ; int const * __cdecl std::addressof<int const>(int const &)
.text$mn:00002488                 public ??$addressof@$$CBH@std@@YAPBHABH@Z
.text$mn:00002488 ??$addressof@$$CBH@std@@YAPBHABH@Z proc near
.text$mn:00002488                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+Dp
.text$mn:00002488                                         ; std::vector<int,std::allocator<int>>::push_back(int const &)+29p
.text$mn:00002488
.text$mn:00002488 arg_0           = dword ptr  8
.text$mn:00002488
.text$mn:00002488                 push    ebp
.text$mn:00002489                 mov     ebp, esp
.text$mn:0000248B                 mov     eax, [ebp+arg_0]
.text$mn:0000248E                 pop     ebp
.text$mn:0000248F                 retn
.text$mn:0000248F ??$addressof@$$CBH@std@@YAPBHABH@Z endp
.text$mn:0000248F
.text$mn:0000248F _text$mn        ends
.text$mn:0000248F
.text$mn:00002490 ; ===========================================================================
.text$mn:00002490
.text$mn:00002490 ; Segment type: Pure code
.text$mn:00002490 ; Segment permissions: Read/Execute
.text$mn:00002490 _text$mn        segment para public 'CODE' use32
.text$mn:00002490                 assume cs:_text$mn
.text$mn:00002490                 ;org 2490h
.text$mn:00002490 ; COMDAT (pick any)
.text$mn:00002490                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002490
.text$mn:00002490 ; =============== S U B R O U T I N E =======================================
.text$mn:00002490
.text$mn:00002490 ; Attributes: bp-based frame
.text$mn:00002490
.text$mn:00002490 ; struct tDynamicList const * __cdecl std::addressof<struct tDynamicList const>(struct tDynamicList const &)
.text$mn:00002490                 public ??$addressof@$$CBUtDynamicList@@@std@@YAPBUtDynamicList@@ABU1@@Z
.text$mn:00002490 ??$addressof@$$CBUtDynamicList@@@std@@YAPBUtDynamicList@@ABU1@@Z proc near
.text$mn:00002490                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::push_back(tDynamicList const &)+Dp
.text$mn:00002490                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::push_back(tDynamicList const &)+2Dp
.text$mn:00002490
.text$mn:00002490 arg_0           = dword ptr  8
.text$mn:00002490
.text$mn:00002490                 push    ebp
.text$mn:00002491                 mov     ebp, esp
.text$mn:00002493                 mov     eax, [ebp+arg_0]
.text$mn:00002496                 pop     ebp
.text$mn:00002497                 retn
.text$mn:00002497 ??$addressof@$$CBUtDynamicList@@@std@@YAPBUtDynamicList@@ABU1@@Z endp
.text$mn:00002497
.text$mn:00002497 _text$mn        ends
.text$mn:00002497
.text$mn:00002498 ; ===========================================================================
.text$mn:00002498
.text$mn:00002498 ; Segment type: Pure code
.text$mn:00002498 ; Segment permissions: Read/Execute
.text$mn:00002498 _text$mn        segment para public 'CODE' use32
.text$mn:00002498                 assume cs:_text$mn
.text$mn:00002498                 ;org 2498h
.text$mn:00002498 ; COMDAT (pick any)
.text$mn:00002498                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002498
.text$mn:00002498 ; =============== S U B R O U T I N E =======================================
.text$mn:00002498
.text$mn:00002498 ; Attributes: bp-based frame
.text$mn:00002498
.text$mn:00002498 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00002498                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00002498 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00002498                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00002498                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00002498
.text$mn:00002498 arg_0           = dword ptr  8
.text$mn:00002498
.text$mn:00002498                 push    ebp
.text$mn:00002499                 mov     ebp, esp
.text$mn:0000249B                 mov     eax, [ebp+arg_0]
.text$mn:0000249E                 pop     ebp
.text$mn:0000249F                 retn
.text$mn:0000249F ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:0000249F
.text$mn:0000249F _text$mn        ends
.text$mn:0000249F
.text$mn:000024A0 ; ===========================================================================
.text$mn:000024A0
.text$mn:000024A0 ; Segment type: Pure code
.text$mn:000024A0 ; Segment permissions: Read/Execute
.text$mn:000024A0 _text$mn        segment para public 'CODE' use32
.text$mn:000024A0                 assume cs:_text$mn
.text$mn:000024A0                 ;org 24A0h
.text$mn:000024A0 ; COMDAT (pick any)
.text$mn:000024A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024A0
.text$mn:000024A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000024A0
.text$mn:000024A0 ; Attributes: bp-based frame
.text$mn:000024A0
.text$mn:000024A0 ; struct iconLocator * __cdecl std::addressof<struct iconLocator>(struct iconLocator &)
.text$mn:000024A0                 public ??$addressof@UiconLocator@@@std@@YAPAUiconLocator@@AAU1@@Z
.text$mn:000024A0 ??$addressof@UiconLocator@@@std@@YAPAUiconLocator@@AAU1@@Z proc near
.text$mn:000024A0                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)+Dp
.text$mn:000024A0                                         ; std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)+2Dp
.text$mn:000024A0
.text$mn:000024A0 arg_0           = dword ptr  8
.text$mn:000024A0
.text$mn:000024A0                 push    ebp
.text$mn:000024A1                 mov     ebp, esp
.text$mn:000024A3                 mov     eax, [ebp+arg_0]
.text$mn:000024A6                 pop     ebp
.text$mn:000024A7                 retn
.text$mn:000024A7 ??$addressof@UiconLocator@@@std@@YAPAUiconLocator@@AAU1@@Z endp
.text$mn:000024A7
.text$mn:000024A7 _text$mn        ends
.text$mn:000024A7
.text$mn:000024A8 ; ===========================================================================
.text$mn:000024A8
.text$mn:000024A8 ; Segment type: Pure code
.text$mn:000024A8 ; Segment permissions: Read/Execute
.text$mn:000024A8 _text$mn        segment para public 'CODE' use32
.text$mn:000024A8                 assume cs:_text$mn
.text$mn:000024A8                 ;org 24A8h
.text$mn:000024A8 ; COMDAT (pick any)
.text$mn:000024A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024A8
.text$mn:000024A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000024A8
.text$mn:000024A8 ; Attributes: bp-based frame
.text$mn:000024A8
.text$mn:000024A8 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:000024A8                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:000024A8 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:000024A8                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:000024A8                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:000024A8
.text$mn:000024A8 arg_0           = dword ptr  8
.text$mn:000024A8
.text$mn:000024A8                 push    ebp
.text$mn:000024A9                 mov     ebp, esp
.text$mn:000024AB                 mov     eax, [ebp+arg_0]
.text$mn:000024AE                 pop     ebp
.text$mn:000024AF                 retn
.text$mn:000024AF ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:000024AF
.text$mn:000024AF _text$mn        ends
.text$mn:000024AF
.text$mn:000024B0 ; ===========================================================================
.text$mn:000024B0
.text$mn:000024B0 ; Segment type: Pure code
.text$mn:000024B0 ; Segment permissions: Read/Execute
.text$mn:000024B0 _text$mn        segment para public 'CODE' use32
.text$mn:000024B0                 assume cs:_text$mn
.text$mn:000024B0                 ;org 24B0h
.text$mn:000024B0 ; COMDAT (pick any)
.text$mn:000024B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024B0
.text$mn:000024B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000024B0
.text$mn:000024B0 ; Attributes: bp-based frame
.text$mn:000024B0
.text$mn:000024B0 ; int __stdcall std::_Wrap_alloc<std::allocator<int>>::construct<int,int &>(void *, int)
.text$mn:000024B0                 public ??$construct@HAAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHAAH@Z
.text$mn:000024B0 ??$construct@HAAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHAAH@Z proc near
.text$mn:000024B0                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+8Dp
.text$mn:000024B0
.text$mn:000024B0 var_4           = dword ptr -4
.text$mn:000024B0 arg_0           = dword ptr  8
.text$mn:000024B0 arg_4           = dword ptr  0Ch
.text$mn:000024B0
.text$mn:000024B0                 push    ebp
.text$mn:000024B1                 mov     ebp, esp
.text$mn:000024B3                 push    ecx
.text$mn:000024B4                 mov     [ebp+var_4], ecx
.text$mn:000024B7                 mov     eax, [ebp+arg_4]
.text$mn:000024BA                 push    eax
.text$mn:000024BB                 call    ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>(int &)
.text$mn:000024C0                 add     esp, 4
.text$mn:000024C3                 push    eax             ; int
.text$mn:000024C4                 mov     ecx, [ebp+arg_0]
.text$mn:000024C7                 push    ecx             ; void *
.text$mn:000024C8                 mov     edx, [ebp+var_4]
.text$mn:000024CB                 push    edx             ; int
.text$mn:000024CC                 call    ??$construct@HAAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHAAH@Z ; std::allocator_traits<std::allocator<int>>::construct<int,int &>(std::allocator<int> &,int *,int &)
.text$mn:000024D1                 add     esp, 0Ch
.text$mn:000024D4                 mov     esp, ebp
.text$mn:000024D6                 pop     ebp
.text$mn:000024D7                 retn    8
.text$mn:000024D7 ??$construct@HAAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHAAH@Z endp
.text$mn:000024D7
.text$mn:000024D7 ; ---------------------------------------------------------------------------
.text$mn:000024DA                 align 4
.text$mn:000024DA _text$mn        ends
.text$mn:000024DA
.text$mn:000024DC ; ===========================================================================
.text$mn:000024DC
.text$mn:000024DC ; Segment type: Pure code
.text$mn:000024DC ; Segment permissions: Read/Execute
.text$mn:000024DC _text$mn        segment para public 'CODE' use32
.text$mn:000024DC                 assume cs:_text$mn
.text$mn:000024DC                 ;org 24DCh
.text$mn:000024DC ; COMDAT (pick any)
.text$mn:000024DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024DC
.text$mn:000024DC ; =============== S U B R O U T I N E =======================================
.text$mn:000024DC
.text$mn:000024DC ; Attributes: bp-based frame
.text$mn:000024DC
.text$mn:000024DC ; int __stdcall std::allocator<int>::construct<int,int &>(void *, int)
.text$mn:000024DC                 public ??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z
.text$mn:000024DC ??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z proc near
.text$mn:000024DC                                         ; CODE XREF: std::allocator_traits<std::allocator<int>>::construct<int,int &>(std::allocator<int> &,int *,int &)+17p
.text$mn:000024DC
.text$mn:000024DC var_1C          = dword ptr -1Ch
.text$mn:000024DC var_18          = dword ptr -18h
.text$mn:000024DC var_14          = dword ptr -14h
.text$mn:000024DC var_10          = dword ptr -10h
.text$mn:000024DC var_C           = dword ptr -0Ch
.text$mn:000024DC var_4           = dword ptr -4
.text$mn:000024DC arg_0           = dword ptr  8
.text$mn:000024DC arg_4           = dword ptr  0Ch
.text$mn:000024DC
.text$mn:000024DC                 push    ebp
.text$mn:000024DD                 mov     ebp, esp
.text$mn:000024DF                 push    0FFFFFFFFh
.text$mn:000024E1                 push    offset __ehhandler$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z
.text$mn:000024E6                 mov     eax, large fs:0
.text$mn:000024EC                 push    eax
.text$mn:000024ED                 sub     esp, 10h
.text$mn:000024F0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000024F5                 xor     eax, ebp
.text$mn:000024F7                 push    eax
.text$mn:000024F8                 lea     eax, [ebp+var_C]
.text$mn:000024FB                 mov     large fs:0, eax
.text$mn:00002501                 mov     [ebp+var_18], ecx
.text$mn:00002504                 mov     eax, [ebp+arg_0]
.text$mn:00002507                 push    eax             ; void *
.text$mn:00002508                 push    4               ; unsigned int
.text$mn:0000250A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000250F                 add     esp, 8
.text$mn:00002512                 mov     [ebp+var_10], eax
.text$mn:00002515                 mov     [ebp+var_4], 0
.text$mn:0000251C                 cmp     [ebp+var_10], 0
.text$mn:00002520                 jz      short loc_253D
.text$mn:00002522                 mov     ecx, [ebp+arg_4]
.text$mn:00002525                 push    ecx
.text$mn:00002526                 call    ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>(int &)
.text$mn:0000252B                 add     esp, 4
.text$mn:0000252E                 mov     edx, [ebp+var_10]
.text$mn:00002531                 mov     eax, [eax]
.text$mn:00002533                 mov     [edx], eax
.text$mn:00002535                 mov     ecx, [ebp+var_10]
.text$mn:00002538                 mov     [ebp+var_14], ecx
.text$mn:0000253B                 jmp     short loc_2544
.text$mn:0000253D ; ---------------------------------------------------------------------------
.text$mn:0000253D
.text$mn:0000253D loc_253D:                               ; CODE XREF: std::allocator<int>::construct<int,int &>(int *,int &)+44j
.text$mn:0000253D                 mov     [ebp+var_14], 0
.text$mn:00002544
.text$mn:00002544 loc_2544:                               ; CODE XREF: std::allocator<int>::construct<int,int &>(int *,int &)+5Fj
.text$mn:00002544                 mov     edx, [ebp+var_14]
.text$mn:00002547                 mov     [ebp+var_1C], edx
.text$mn:0000254A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002551                 mov     ecx, [ebp+var_C]
.text$mn:00002554                 mov     large fs:0, ecx
.text$mn:0000255B                 pop     ecx
.text$mn:0000255C                 mov     esp, ebp
.text$mn:0000255E                 pop     ebp
.text$mn:0000255F                 retn    8
.text$mn:0000255F ??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z endp
.text$mn:0000255F
.text$mn:0000255F ; ---------------------------------------------------------------------------
.text$mn:00002562                 align 4
.text$mn:00002562 _text$mn        ends
.text$mn:00002562
.text$x:00002564 ; ===========================================================================
.text$x:00002564
.text$x:00002564 ; Segment type: Pure code
.text$x:00002564 ; Segment permissions: Read/Execute
.text$x:00002564 _text$x         segment para public 'CODE' use32
.text$x:00002564                 assume cs:_text$x
.text$x:00002564                 ;org 2564h
.text$x:00002564 ; COMDAT (pick associative to section at 24DC)
.text$x:00002564                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002564
.text$x:00002564 ; =============== S U B R O U T I N E =======================================
.text$x:00002564
.text$x:00002564
.text$x:00002564 __unwindfunclet$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z$0 proc near
.text$x:00002564                                         ; DATA XREF: .xdata$x:00008678o
.text$x:00002564                 mov     eax, [ebp+8]
.text$x:00002567                 push    eax
.text$x:00002568                 mov     eax, [ebp-10h]
.text$x:0000256B                 push    eax             ; void *
.text$x:0000256C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002571                 add     esp, 8
.text$x:00002574                 retn
.text$x:00002574 __unwindfunclet$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z$0 endp
.text$x:00002574
.text$x:00002575
.text$x:00002575 ; =============== S U B R O U T I N E =======================================
.text$x:00002575
.text$x:00002575
.text$x:00002575 __ehhandler$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z proc near
.text$x:00002575                                         ; DATA XREF: std::allocator<int>::construct<int,int &>(int *,int &)+5o
.text$x:00002575
.text$x:00002575 arg_4           = dword ptr  8
.text$x:00002575
.text$x:00002575                 mov     edx, [esp+arg_4]
.text$x:00002579                 lea     eax, [edx+0Ch]
.text$x:0000257C                 mov     ecx, [edx-14h]
.text$x:0000257F                 xor     ecx, eax
.text$x:00002581                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002586                 mov     eax, offset __ehfuncinfo$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z
.text$x:0000258B                 jmp     ___CxxFrameHandler3
.text$x:0000258B __ehhandler$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z endp
.text$x:0000258B
.text$x:0000258B _text$x         ends
.text$x:0000258B
.text$mn:00002590 ; ===========================================================================
.text$mn:00002590
.text$mn:00002590 ; Segment type: Pure code
.text$mn:00002590 ; Segment permissions: Read/Execute
.text$mn:00002590 _text$mn        segment para public 'CODE' use32
.text$mn:00002590                 assume cs:_text$mn
.text$mn:00002590                 ;org 2590h
.text$mn:00002590 ; COMDAT (pick any)
.text$mn:00002590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002590
.text$mn:00002590 ; =============== S U B R O U T I N E =======================================
.text$mn:00002590
.text$mn:00002590 ; Attributes: bp-based frame
.text$mn:00002590
.text$mn:00002590 ; int __cdecl std::allocator_traits<std::allocator<int>>::construct<int,int &>(int, void *, int)
.text$mn:00002590                 public ??$construct@HAAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHAAH@Z
.text$mn:00002590 ??$construct@HAAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHAAH@Z proc near
.text$mn:00002590                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::construct<int,int &>(int *,int &)+1Cp
.text$mn:00002590
.text$mn:00002590 arg_0           = dword ptr  8
.text$mn:00002590 arg_4           = dword ptr  0Ch
.text$mn:00002590 arg_8           = dword ptr  10h
.text$mn:00002590
.text$mn:00002590                 push    ebp
.text$mn:00002591                 mov     ebp, esp
.text$mn:00002593                 mov     eax, [ebp+arg_8]
.text$mn:00002596                 push    eax
.text$mn:00002597                 call    ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>(int &)
.text$mn:0000259C                 add     esp, 4
.text$mn:0000259F                 push    eax             ; int
.text$mn:000025A0                 mov     ecx, [ebp+arg_4]
.text$mn:000025A3                 push    ecx             ; void *
.text$mn:000025A4                 mov     ecx, [ebp+arg_0]
.text$mn:000025A7                 call    ??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z ; std::allocator<int>::construct<int,int &>(int *,int &)
.text$mn:000025AC                 pop     ebp
.text$mn:000025AD                 retn
.text$mn:000025AD ??$construct@HAAH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHAAH@Z endp
.text$mn:000025AD
.text$mn:000025AD ; ---------------------------------------------------------------------------
.text$mn:000025AE                 align 10h
.text$mn:000025AE _text$mn        ends
.text$mn:000025AE
.text$mn:000025B0 ; ===========================================================================
.text$mn:000025B0
.text$mn:000025B0 ; Segment type: Pure code
.text$mn:000025B0 ; Segment permissions: Read/Execute
.text$mn:000025B0 _text$mn        segment para public 'CODE' use32
.text$mn:000025B0                 assume cs:_text$mn
.text$mn:000025B0                 ;org 25B0h
.text$mn:000025B0 ; COMDAT (pick any)
.text$mn:000025B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025B0
.text$mn:000025B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025B0
.text$mn:000025B0 ; Attributes: bp-based frame
.text$mn:000025B0
.text$mn:000025B0 ; int __stdcall std::_Wrap_alloc<std::allocator<int>>::construct<int,int const &>(void *, int)
.text$mn:000025B0                 public ??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z
.text$mn:000025B0 ??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z proc near
.text$mn:000025B0                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+EAp
.text$mn:000025B0
.text$mn:000025B0 var_4           = dword ptr -4
.text$mn:000025B0 arg_0           = dword ptr  8
.text$mn:000025B0 arg_4           = dword ptr  0Ch
.text$mn:000025B0
.text$mn:000025B0                 push    ebp
.text$mn:000025B1                 mov     ebp, esp
.text$mn:000025B3                 push    ecx
.text$mn:000025B4                 mov     [ebp+var_4], ecx
.text$mn:000025B7                 mov     eax, [ebp+arg_4]
.text$mn:000025BA                 push    eax
.text$mn:000025BB                 call    ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>(int const &)
.text$mn:000025C0                 add     esp, 4
.text$mn:000025C3                 push    eax             ; int
.text$mn:000025C4                 mov     ecx, [ebp+arg_0]
.text$mn:000025C7                 push    ecx             ; void *
.text$mn:000025C8                 mov     edx, [ebp+var_4]
.text$mn:000025CB                 push    edx             ; int
.text$mn:000025CC                 call    ??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z ; std::allocator_traits<std::allocator<int>>::construct<int,int const &>(std::allocator<int> &,int *,int const &)
.text$mn:000025D1                 add     esp, 0Ch
.text$mn:000025D4                 mov     esp, ebp
.text$mn:000025D6                 pop     ebp
.text$mn:000025D7                 retn    8
.text$mn:000025D7 ??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z endp
.text$mn:000025D7
.text$mn:000025D7 ; ---------------------------------------------------------------------------
.text$mn:000025DA                 align 4
.text$mn:000025DA _text$mn        ends
.text$mn:000025DA
.text$mn:000025DC ; ===========================================================================
.text$mn:000025DC
.text$mn:000025DC ; Segment type: Pure code
.text$mn:000025DC ; Segment permissions: Read/Execute
.text$mn:000025DC _text$mn        segment para public 'CODE' use32
.text$mn:000025DC                 assume cs:_text$mn
.text$mn:000025DC                 ;org 25DCh
.text$mn:000025DC ; COMDAT (pick any)
.text$mn:000025DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025DC
.text$mn:000025DC ; =============== S U B R O U T I N E =======================================
.text$mn:000025DC
.text$mn:000025DC ; Attributes: bp-based frame
.text$mn:000025DC
.text$mn:000025DC ; int __cdecl std::allocator_traits<std::allocator<int>>::construct<int,int const &>(int, void *, int)
.text$mn:000025DC                 public ??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z
.text$mn:000025DC ??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z proc near
.text$mn:000025DC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::construct<int,int const &>(int *,int const &)+1Cp
.text$mn:000025DC
.text$mn:000025DC arg_0           = dword ptr  8
.text$mn:000025DC arg_4           = dword ptr  0Ch
.text$mn:000025DC arg_8           = dword ptr  10h
.text$mn:000025DC
.text$mn:000025DC                 push    ebp
.text$mn:000025DD                 mov     ebp, esp
.text$mn:000025DF                 mov     eax, [ebp+arg_8]
.text$mn:000025E2                 push    eax
.text$mn:000025E3                 call    ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>(int const &)
.text$mn:000025E8                 add     esp, 4
.text$mn:000025EB                 push    eax             ; int
.text$mn:000025EC                 mov     ecx, [ebp+arg_4]
.text$mn:000025EF                 push    ecx             ; void *
.text$mn:000025F0                 mov     ecx, [ebp+arg_0]
.text$mn:000025F3                 call    ?construct@?$allocator@H@std@@QAEXPAHABH@Z ; std::allocator<int>::construct(int *,int const &)
.text$mn:000025F8                 pop     ebp
.text$mn:000025F9                 retn
.text$mn:000025F9 ??$construct@HABH@?$allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@PAHABH@Z endp
.text$mn:000025F9
.text$mn:000025F9 ; ---------------------------------------------------------------------------
.text$mn:000025FA                 align 4
.text$mn:000025FA _text$mn        ends
.text$mn:000025FA
.text$mn:000025FC ; ===========================================================================
.text$mn:000025FC
.text$mn:000025FC ; Segment type: Pure code
.text$mn:000025FC ; Segment permissions: Read/Execute
.text$mn:000025FC _text$mn        segment para public 'CODE' use32
.text$mn:000025FC                 assume cs:_text$mn
.text$mn:000025FC                 ;org 25FCh
.text$mn:000025FC ; COMDAT (pick any)
.text$mn:000025FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025FC
.text$mn:000025FC ; =============== S U B R O U T I N E =======================================
.text$mn:000025FC
.text$mn:000025FC ; Attributes: bp-based frame
.text$mn:000025FC
.text$mn:000025FC ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000025FC                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000025FC ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000025FC                                         ; CODE XREF: $LN19+4Bp
.text$mn:000025FC
.text$mn:000025FC var_4           = dword ptr -4
.text$mn:000025FC arg_0           = dword ptr  8
.text$mn:000025FC arg_4           = dword ptr  0Ch
.text$mn:000025FC
.text$mn:000025FC                 push    ebp
.text$mn:000025FD                 mov     ebp, esp
.text$mn:000025FF                 push    ecx
.text$mn:00002600                 mov     [ebp+var_4], ecx
.text$mn:00002603                 mov     eax, [ebp+arg_4]
.text$mn:00002606                 push    eax
.text$mn:00002607                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000260C                 add     esp, 4
.text$mn:0000260F                 push    eax             ; int
.text$mn:00002610                 mov     ecx, [ebp+arg_0]
.text$mn:00002613                 push    ecx             ; void *
.text$mn:00002614                 mov     edx, [ebp+var_4]
.text$mn:00002617                 push    edx             ; int
.text$mn:00002618                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:0000261D                 add     esp, 0Ch
.text$mn:00002620                 mov     esp, ebp
.text$mn:00002622                 pop     ebp
.text$mn:00002623                 retn    8
.text$mn:00002623 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00002623
.text$mn:00002623 ; ---------------------------------------------------------------------------
.text$mn:00002626                 align 4
.text$mn:00002626 _text$mn        ends
.text$mn:00002626
.text$mn:00002628 ; ===========================================================================
.text$mn:00002628
.text$mn:00002628 ; Segment type: Pure code
.text$mn:00002628 ; Segment permissions: Read/Execute
.text$mn:00002628 _text$mn        segment para public 'CODE' use32
.text$mn:00002628                 assume cs:_text$mn
.text$mn:00002628                 ;org 2628h
.text$mn:00002628 ; COMDAT (pick any)
.text$mn:00002628                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002628
.text$mn:00002628 ; =============== S U B R O U T I N E =======================================
.text$mn:00002628
.text$mn:00002628 ; Attributes: bp-based frame
.text$mn:00002628
.text$mn:00002628 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00002628                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00002628 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00002628                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00002628
.text$mn:00002628 var_1C          = dword ptr -1Ch
.text$mn:00002628 var_18          = dword ptr -18h
.text$mn:00002628 var_14          = dword ptr -14h
.text$mn:00002628 var_10          = dword ptr -10h
.text$mn:00002628 var_C           = dword ptr -0Ch
.text$mn:00002628 var_4           = dword ptr -4
.text$mn:00002628 arg_0           = dword ptr  8
.text$mn:00002628 arg_4           = dword ptr  0Ch
.text$mn:00002628
.text$mn:00002628                 push    ebp
.text$mn:00002629                 mov     ebp, esp
.text$mn:0000262B                 push    0FFFFFFFFh
.text$mn:0000262D                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00002632                 mov     eax, large fs:0
.text$mn:00002638                 push    eax
.text$mn:00002639                 sub     esp, 10h
.text$mn:0000263C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002641                 xor     eax, ebp
.text$mn:00002643                 push    eax
.text$mn:00002644                 lea     eax, [ebp+var_C]
.text$mn:00002647                 mov     large fs:0, eax
.text$mn:0000264D                 mov     [ebp+var_18], ecx
.text$mn:00002650                 mov     eax, [ebp+arg_0]
.text$mn:00002653                 push    eax             ; void *
.text$mn:00002654                 push    4               ; unsigned int
.text$mn:00002656                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000265B                 add     esp, 8
.text$mn:0000265E                 mov     [ebp+var_10], eax
.text$mn:00002661                 mov     [ebp+var_4], 0
.text$mn:00002668                 cmp     [ebp+var_10], 0
.text$mn:0000266C                 jz      short loc_2689
.text$mn:0000266E                 mov     ecx, [ebp+arg_4]
.text$mn:00002671                 push    ecx
.text$mn:00002672                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00002677                 add     esp, 4
.text$mn:0000267A                 mov     edx, [ebp+var_10]
.text$mn:0000267D                 mov     eax, [eax]
.text$mn:0000267F                 mov     [edx], eax
.text$mn:00002681                 mov     ecx, [ebp+var_10]
.text$mn:00002684                 mov     [ebp+var_14], ecx
.text$mn:00002687                 jmp     short loc_2690
.text$mn:00002689 ; ---------------------------------------------------------------------------
.text$mn:00002689
.text$mn:00002689 loc_2689:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00002689                 mov     [ebp+var_14], 0
.text$mn:00002690
.text$mn:00002690 loc_2690:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00002690                 mov     edx, [ebp+var_14]
.text$mn:00002693                 mov     [ebp+var_1C], edx
.text$mn:00002696                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000269D                 mov     ecx, [ebp+var_C]
.text$mn:000026A0                 mov     large fs:0, ecx
.text$mn:000026A7                 pop     ecx
.text$mn:000026A8                 mov     esp, ebp
.text$mn:000026AA                 pop     ebp
.text$mn:000026AB                 retn    8
.text$mn:000026AB ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000026AB
.text$mn:000026AB ; ---------------------------------------------------------------------------
.text$mn:000026AE                 align 10h
.text$mn:000026AE _text$mn        ends
.text$mn:000026AE
.text$x:000026B0 ; ===========================================================================
.text$x:000026B0
.text$x:000026B0 ; Segment type: Pure code
.text$x:000026B0 ; Segment permissions: Read/Execute
.text$x:000026B0 _text$x         segment para public 'CODE' use32
.text$x:000026B0                 assume cs:_text$x
.text$x:000026B0                 ;org 26B0h
.text$x:000026B0 ; COMDAT (pick associative to section at 2628)
.text$x:000026B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000026B0
.text$x:000026B0 ; =============== S U B R O U T I N E =======================================
.text$x:000026B0
.text$x:000026B0
.text$x:000026B0 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000026B0                                         ; DATA XREF: .xdata$x:000086A4o
.text$x:000026B0                 mov     eax, [ebp+8]
.text$x:000026B3                 push    eax
.text$x:000026B4                 mov     eax, [ebp-10h]
.text$x:000026B7                 push    eax             ; void *
.text$x:000026B8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000026BD                 add     esp, 8
.text$x:000026C0                 retn
.text$x:000026C0 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000026C0
.text$x:000026C1
.text$x:000026C1 ; =============== S U B R O U T I N E =======================================
.text$x:000026C1
.text$x:000026C1
.text$x:000026C1 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000026C1                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000026C1
.text$x:000026C1 arg_4           = dword ptr  8
.text$x:000026C1
.text$x:000026C1                 mov     edx, [esp+arg_4]
.text$x:000026C5                 lea     eax, [edx+0Ch]
.text$x:000026C8                 mov     ecx, [edx-14h]
.text$x:000026CB                 xor     ecx, eax
.text$x:000026CD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000026D2                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000026D7                 jmp     ___CxxFrameHandler3
.text$x:000026D7 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000026D7
.text$x:000026D7 _text$x         ends
.text$x:000026D7
.text$mn:000026DC ; ===========================================================================
.text$mn:000026DC
.text$mn:000026DC ; Segment type: Pure code
.text$mn:000026DC ; Segment permissions: Read/Execute
.text$mn:000026DC _text$mn        segment para public 'CODE' use32
.text$mn:000026DC                 assume cs:_text$mn
.text$mn:000026DC                 ;org 26DCh
.text$mn:000026DC ; COMDAT (pick any)
.text$mn:000026DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026DC
.text$mn:000026DC ; =============== S U B R O U T I N E =======================================
.text$mn:000026DC
.text$mn:000026DC ; Attributes: bp-based frame
.text$mn:000026DC
.text$mn:000026DC ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000026DC                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000026DC ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000026DC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000026DC
.text$mn:000026DC arg_0           = dword ptr  8
.text$mn:000026DC arg_4           = dword ptr  0Ch
.text$mn:000026DC arg_8           = dword ptr  10h
.text$mn:000026DC
.text$mn:000026DC                 push    ebp
.text$mn:000026DD                 mov     ebp, esp
.text$mn:000026DF                 mov     eax, [ebp+arg_8]
.text$mn:000026E2                 push    eax
.text$mn:000026E3                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000026E8                 add     esp, 4
.text$mn:000026EB                 push    eax             ; int
.text$mn:000026EC                 mov     ecx, [ebp+arg_4]
.text$mn:000026EF                 push    ecx             ; void *
.text$mn:000026F0                 mov     ecx, [ebp+arg_0]
.text$mn:000026F3                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:000026F8                 pop     ebp
.text$mn:000026F9                 retn
.text$mn:000026F9 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:000026F9
.text$mn:000026F9 ; ---------------------------------------------------------------------------
.text$mn:000026FA                 align 4
.text$mn:000026FA _text$mn        ends
.text$mn:000026FA
.text$mn:000026FC ; ===========================================================================
.text$mn:000026FC
.text$mn:000026FC ; Segment type: Pure code
.text$mn:000026FC ; Segment permissions: Read/Execute
.text$mn:000026FC _text$mn        segment para public 'CODE' use32
.text$mn:000026FC                 assume cs:_text$mn
.text$mn:000026FC                 ;org 26FCh
.text$mn:000026FC ; COMDAT (pick any)
.text$mn:000026FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026FC
.text$mn:000026FC ; =============== S U B R O U T I N E =======================================
.text$mn:000026FC
.text$mn:000026FC ; Attributes: bp-based frame
.text$mn:000026FC
.text$mn:000026FC ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:000026FC                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:000026FC ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:000026FC                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:000026FC
.text$mn:000026FC var_4           = dword ptr -4
.text$mn:000026FC arg_0           = dword ptr  8
.text$mn:000026FC arg_4           = dword ptr  0Ch
.text$mn:000026FC
.text$mn:000026FC                 push    ebp
.text$mn:000026FD                 mov     ebp, esp
.text$mn:000026FF                 push    ecx
.text$mn:00002700                 mov     [ebp+var_4], ecx
.text$mn:00002703                 mov     eax, [ebp+arg_4]
.text$mn:00002706                 push    eax
.text$mn:00002707                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:0000270C                 add     esp, 4
.text$mn:0000270F                 push    eax             ; int
.text$mn:00002710                 mov     ecx, [ebp+arg_0]
.text$mn:00002713                 push    ecx             ; void *
.text$mn:00002714                 mov     edx, [ebp+var_4]
.text$mn:00002717                 push    edx             ; int
.text$mn:00002718                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:0000271D                 add     esp, 0Ch
.text$mn:00002720                 mov     esp, ebp
.text$mn:00002722                 pop     ebp
.text$mn:00002723                 retn    8
.text$mn:00002723 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00002723
.text$mn:00002723 ; ---------------------------------------------------------------------------
.text$mn:00002726                 align 4
.text$mn:00002726 _text$mn        ends
.text$mn:00002726
.text$mn:00002728 ; ===========================================================================
.text$mn:00002728
.text$mn:00002728 ; Segment type: Pure code
.text$mn:00002728 ; Segment permissions: Read/Execute
.text$mn:00002728 _text$mn        segment para public 'CODE' use32
.text$mn:00002728                 assume cs:_text$mn
.text$mn:00002728                 ;org 2728h
.text$mn:00002728 ; COMDAT (pick any)
.text$mn:00002728                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002728
.text$mn:00002728 ; =============== S U B R O U T I N E =======================================
.text$mn:00002728
.text$mn:00002728 ; Attributes: bp-based frame
.text$mn:00002728
.text$mn:00002728 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00002728                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00002728 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00002728                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:00002728
.text$mn:00002728 var_1C          = dword ptr -1Ch
.text$mn:00002728 var_18          = dword ptr -18h
.text$mn:00002728 var_14          = dword ptr -14h
.text$mn:00002728 var_10          = dword ptr -10h
.text$mn:00002728 var_C           = dword ptr -0Ch
.text$mn:00002728 var_4           = dword ptr -4
.text$mn:00002728 arg_0           = dword ptr  8
.text$mn:00002728 arg_4           = dword ptr  0Ch
.text$mn:00002728
.text$mn:00002728                 push    ebp
.text$mn:00002729                 mov     ebp, esp
.text$mn:0000272B                 push    0FFFFFFFFh
.text$mn:0000272D                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00002732                 mov     eax, large fs:0
.text$mn:00002738                 push    eax
.text$mn:00002739                 sub     esp, 10h
.text$mn:0000273C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002741                 xor     eax, ebp
.text$mn:00002743                 push    eax
.text$mn:00002744                 lea     eax, [ebp+var_C]
.text$mn:00002747                 mov     large fs:0, eax
.text$mn:0000274D                 mov     [ebp+var_18], ecx
.text$mn:00002750                 mov     eax, [ebp+arg_0]
.text$mn:00002753                 push    eax             ; void *
.text$mn:00002754                 push    4               ; unsigned int
.text$mn:00002756                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000275B                 add     esp, 8
.text$mn:0000275E                 mov     [ebp+var_10], eax
.text$mn:00002761                 mov     [ebp+var_4], 0
.text$mn:00002768                 cmp     [ebp+var_10], 0
.text$mn:0000276C                 jz      short loc_2789
.text$mn:0000276E                 mov     ecx, [ebp+arg_4]
.text$mn:00002771                 push    ecx
.text$mn:00002772                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00002777                 add     esp, 4
.text$mn:0000277A                 mov     edx, [ebp+var_10]
.text$mn:0000277D                 mov     eax, [eax]
.text$mn:0000277F                 mov     [edx], eax
.text$mn:00002781                 mov     ecx, [ebp+var_10]
.text$mn:00002784                 mov     [ebp+var_14], ecx
.text$mn:00002787                 jmp     short loc_2790
.text$mn:00002789 ; ---------------------------------------------------------------------------
.text$mn:00002789
.text$mn:00002789 loc_2789:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:00002789                 mov     [ebp+var_14], 0
.text$mn:00002790
.text$mn:00002790 loc_2790:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:00002790                 mov     edx, [ebp+var_14]
.text$mn:00002793                 mov     [ebp+var_1C], edx
.text$mn:00002796                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000279D                 mov     ecx, [ebp+var_C]
.text$mn:000027A0                 mov     large fs:0, ecx
.text$mn:000027A7                 pop     ecx
.text$mn:000027A8                 mov     esp, ebp
.text$mn:000027AA                 pop     ebp
.text$mn:000027AB                 retn    8
.text$mn:000027AB ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:000027AB
.text$mn:000027AB ; ---------------------------------------------------------------------------
.text$mn:000027AE                 align 10h
.text$mn:000027AE _text$mn        ends
.text$mn:000027AE
.text$x:000027B0 ; ===========================================================================
.text$x:000027B0
.text$x:000027B0 ; Segment type: Pure code
.text$x:000027B0 ; Segment permissions: Read/Execute
.text$x:000027B0 _text$x         segment para public 'CODE' use32
.text$x:000027B0                 assume cs:_text$x
.text$x:000027B0                 ;org 27B0h
.text$x:000027B0 ; COMDAT (pick associative to section at 2728)
.text$x:000027B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000027B0
.text$x:000027B0 ; =============== S U B R O U T I N E =======================================
.text$x:000027B0
.text$x:000027B0
.text$x:000027B0 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:000027B0                                         ; DATA XREF: .xdata$x:000086D0o
.text$x:000027B0                 mov     eax, [ebp+8]
.text$x:000027B3                 push    eax
.text$x:000027B4                 mov     eax, [ebp-10h]
.text$x:000027B7                 push    eax             ; void *
.text$x:000027B8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000027BD                 add     esp, 8
.text$x:000027C0                 retn
.text$x:000027C0 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:000027C0
.text$x:000027C1
.text$x:000027C1 ; =============== S U B R O U T I N E =======================================
.text$x:000027C1
.text$x:000027C1
.text$x:000027C1 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:000027C1                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:000027C1
.text$x:000027C1 arg_4           = dword ptr  8
.text$x:000027C1
.text$x:000027C1                 mov     edx, [esp+arg_4]
.text$x:000027C5                 lea     eax, [edx+0Ch]
.text$x:000027C8                 mov     ecx, [edx-14h]
.text$x:000027CB                 xor     ecx, eax
.text$x:000027CD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000027D2                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:000027D7                 jmp     ___CxxFrameHandler3
.text$x:000027D7 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:000027D7
.text$x:000027D7 _text$x         ends
.text$x:000027D7
.text$mn:000027DC ; ===========================================================================
.text$mn:000027DC
.text$mn:000027DC ; Segment type: Pure code
.text$mn:000027DC ; Segment permissions: Read/Execute
.text$mn:000027DC _text$mn        segment para public 'CODE' use32
.text$mn:000027DC                 assume cs:_text$mn
.text$mn:000027DC                 ;org 27DCh
.text$mn:000027DC ; COMDAT (pick any)
.text$mn:000027DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027DC
.text$mn:000027DC ; =============== S U B R O U T I N E =======================================
.text$mn:000027DC
.text$mn:000027DC ; Attributes: bp-based frame
.text$mn:000027DC
.text$mn:000027DC ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:000027DC                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:000027DC ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:000027DC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:000027DC
.text$mn:000027DC arg_0           = dword ptr  8
.text$mn:000027DC arg_4           = dword ptr  0Ch
.text$mn:000027DC arg_8           = dword ptr  10h
.text$mn:000027DC
.text$mn:000027DC                 push    ebp
.text$mn:000027DD                 mov     ebp, esp
.text$mn:000027DF                 mov     eax, [ebp+arg_8]
.text$mn:000027E2                 push    eax
.text$mn:000027E3                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000027E8                 add     esp, 4
.text$mn:000027EB                 push    eax             ; int
.text$mn:000027EC                 mov     ecx, [ebp+arg_4]
.text$mn:000027EF                 push    ecx             ; void *
.text$mn:000027F0                 mov     ecx, [ebp+arg_0]
.text$mn:000027F3                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:000027F8                 pop     ebp
.text$mn:000027F9                 retn
.text$mn:000027F9 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:000027F9
.text$mn:000027F9 ; ---------------------------------------------------------------------------
.text$mn:000027FA                 align 4
.text$mn:000027FA _text$mn        ends
.text$mn:000027FA
.text$mn:000027FC ; ===========================================================================
.text$mn:000027FC
.text$mn:000027FC ; Segment type: Pure code
.text$mn:000027FC ; Segment permissions: Read/Execute
.text$mn:000027FC _text$mn        segment para public 'CODE' use32
.text$mn:000027FC                 assume cs:_text$mn
.text$mn:000027FC                 ;org 27FCh
.text$mn:000027FC ; COMDAT (pick any)
.text$mn:000027FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027FC
.text$mn:000027FC ; =============== S U B R O U T I N E =======================================
.text$mn:000027FC
.text$mn:000027FC ; Attributes: bp-based frame
.text$mn:000027FC
.text$mn:000027FC ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:000027FC                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:000027FC ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:000027FC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:000027FC                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+32p
.text$mn:000027FC
.text$mn:000027FC var_1C          = dword ptr -1Ch
.text$mn:000027FC var_18          = dword ptr -18h
.text$mn:000027FC var_14          = dword ptr -14h
.text$mn:000027FC var_10          = dword ptr -10h
.text$mn:000027FC var_C           = dword ptr -0Ch
.text$mn:000027FC var_4           = dword ptr -4
.text$mn:000027FC arg_0           = dword ptr  8
.text$mn:000027FC arg_4           = dword ptr  0Ch
.text$mn:000027FC
.text$mn:000027FC                 push    ebp
.text$mn:000027FD                 mov     ebp, esp
.text$mn:000027FF                 push    0FFFFFFFFh
.text$mn:00002801                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00002806                 mov     eax, large fs:0
.text$mn:0000280C                 push    eax
.text$mn:0000280D                 sub     esp, 10h
.text$mn:00002810                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002815                 xor     eax, ebp
.text$mn:00002817                 push    eax
.text$mn:00002818                 lea     eax, [ebp+var_C]
.text$mn:0000281B                 mov     large fs:0, eax
.text$mn:00002821                 mov     [ebp+var_18], ecx
.text$mn:00002824                 mov     eax, [ebp+arg_0]
.text$mn:00002827                 push    eax             ; void *
.text$mn:00002828                 push    8               ; unsigned int
.text$mn:0000282A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000282F                 add     esp, 8
.text$mn:00002832                 mov     [ebp+var_10], eax
.text$mn:00002835                 mov     [ebp+var_4], 0
.text$mn:0000283C                 cmp     [ebp+var_10], 0
.text$mn:00002840                 jz      short loc_2863
.text$mn:00002842                 mov     ecx, [ebp+arg_4]
.text$mn:00002845                 push    ecx
.text$mn:00002846                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000284B                 add     esp, 4
.text$mn:0000284E                 mov     edx, [eax]
.text$mn:00002850                 mov     eax, [eax+4]
.text$mn:00002853                 mov     ecx, [ebp+var_10]
.text$mn:00002856                 mov     [ecx], edx
.text$mn:00002858                 mov     [ecx+4], eax
.text$mn:0000285B                 mov     edx, [ebp+var_10]
.text$mn:0000285E                 mov     [ebp+var_14], edx
.text$mn:00002861                 jmp     short loc_286A
.text$mn:00002863 ; ---------------------------------------------------------------------------
.text$mn:00002863
.text$mn:00002863 loc_2863:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00002863                 mov     [ebp+var_14], 0
.text$mn:0000286A
.text$mn:0000286A loc_286A:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:0000286A                 mov     eax, [ebp+var_14]
.text$mn:0000286D                 mov     [ebp+var_1C], eax
.text$mn:00002870                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002877                 mov     ecx, [ebp+var_C]
.text$mn:0000287A                 mov     large fs:0, ecx
.text$mn:00002881                 pop     ecx
.text$mn:00002882                 mov     esp, ebp
.text$mn:00002884                 pop     ebp
.text$mn:00002885                 retn    8
.text$mn:00002885 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00002885
.text$mn:00002885 _text$mn        ends
.text$mn:00002885
.text$x:00002888 ; ===========================================================================
.text$x:00002888
.text$x:00002888 ; Segment type: Pure code
.text$x:00002888 ; Segment permissions: Read/Execute
.text$x:00002888 _text$x         segment para public 'CODE' use32
.text$x:00002888                 assume cs:_text$x
.text$x:00002888                 ;org 2888h
.text$x:00002888 ; COMDAT (pick associative to section at 27FC)
.text$x:00002888                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002888
.text$x:00002888 ; =============== S U B R O U T I N E =======================================
.text$x:00002888
.text$x:00002888
.text$x:00002888 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00002888                                         ; DATA XREF: .xdata$x:000085F4o
.text$x:00002888                 mov     eax, [ebp+8]
.text$x:0000288B                 push    eax
.text$x:0000288C                 mov     eax, [ebp-10h]
.text$x:0000288F                 push    eax             ; void *
.text$x:00002890                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002895                 add     esp, 8
.text$x:00002898                 retn
.text$x:00002898 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00002898
.text$x:00002899
.text$x:00002899 ; =============== S U B R O U T I N E =======================================
.text$x:00002899
.text$x:00002899
.text$x:00002899 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00002899                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00002899
.text$x:00002899 arg_4           = dword ptr  8
.text$x:00002899
.text$x:00002899                 mov     edx, [esp+arg_4]
.text$x:0000289D                 lea     eax, [edx+0Ch]
.text$x:000028A0                 mov     ecx, [edx-14h]
.text$x:000028A3                 xor     ecx, eax
.text$x:000028A5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000028AA                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000028AF                 jmp     ___CxxFrameHandler3
.text$x:000028AF __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000028AF
.text$x:000028AF _text$x         ends
.text$x:000028AF
.text$mn:000028B4 ; ===========================================================================
.text$mn:000028B4
.text$mn:000028B4 ; Segment type: Pure code
.text$mn:000028B4 ; Segment permissions: Read/Execute
.text$mn:000028B4 _text$mn        segment para public 'CODE' use32
.text$mn:000028B4                 assume cs:_text$mn
.text$mn:000028B4                 ;org 28B4h
.text$mn:000028B4 ; COMDAT (pick any)
.text$mn:000028B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028B4
.text$mn:000028B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000028B4
.text$mn:000028B4 ; Attributes: bp-based frame
.text$mn:000028B4
.text$mn:000028B4 ; int __stdcall std::_Wrap_alloc<std::allocator<iconLocator>>::construct<iconLocator,iconLocator>(void *, int)
.text$mn:000028B4                 public ??$construct@UiconLocator@@U1@@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z
.text$mn:000028B4 ??$construct@UiconLocator@@U1@@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z proc near
.text$mn:000028B4                                         ; CODE XREF: std::_Uninit_move<iconLocator *,iconLocator *,std::allocator<iconLocator>,iconLocator>(iconLocator *,iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &,iconLocator *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:000028B4                                         ; std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)+9Dp ...
.text$mn:000028B4
.text$mn:000028B4 var_4           = dword ptr -4
.text$mn:000028B4 arg_0           = dword ptr  8
.text$mn:000028B4 arg_4           = dword ptr  0Ch
.text$mn:000028B4
.text$mn:000028B4                 push    ebp
.text$mn:000028B5                 mov     ebp, esp
.text$mn:000028B7                 push    ecx
.text$mn:000028B8                 mov     [ebp+var_4], ecx
.text$mn:000028BB                 mov     eax, [ebp+arg_4]
.text$mn:000028BE                 push    eax
.text$mn:000028BF                 call    ??$forward@UiconLocator@@@std@@YA$$QAUiconLocator@@AAU1@@Z ; std::forward<iconLocator>(iconLocator &)
.text$mn:000028C4                 add     esp, 4
.text$mn:000028C7                 push    eax             ; int
.text$mn:000028C8                 mov     ecx, [ebp+arg_0]
.text$mn:000028CB                 push    ecx             ; void *
.text$mn:000028CC                 mov     edx, [ebp+var_4]
.text$mn:000028CF                 push    edx             ; int
.text$mn:000028D0                 call    ??$construct@UiconLocator@@U1@@?$allocator_traits@V?$allocator@UiconLocator@@@std@@@std@@SAXAAV?$allocator@UiconLocator@@@1@PAUiconLocator@@$$QAU3@@Z ; std::allocator_traits<std::allocator<iconLocator>>::construct<iconLocator,iconLocator>(std::allocator<iconLocator> &,iconLocator *,iconLocator &&)
.text$mn:000028D5                 add     esp, 0Ch
.text$mn:000028D8                 mov     esp, ebp
.text$mn:000028DA                 pop     ebp
.text$mn:000028DB                 retn    8
.text$mn:000028DB ??$construct@UiconLocator@@U1@@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z endp
.text$mn:000028DB
.text$mn:000028DB ; ---------------------------------------------------------------------------
.text$mn:000028DE                 align 10h
.text$mn:000028DE _text$mn        ends
.text$mn:000028DE
.text$mn:000028E0 ; ===========================================================================
.text$mn:000028E0
.text$mn:000028E0 ; Segment type: Pure code
.text$mn:000028E0 ; Segment permissions: Read/Execute
.text$mn:000028E0 _text$mn        segment para public 'CODE' use32
.text$mn:000028E0                 assume cs:_text$mn
.text$mn:000028E0                 ;org 28E0h
.text$mn:000028E0 ; COMDAT (pick any)
.text$mn:000028E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028E0
.text$mn:000028E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000028E0
.text$mn:000028E0 ; Attributes: bp-based frame
.text$mn:000028E0
.text$mn:000028E0 ; int __stdcall std::allocator<iconLocator>::construct<iconLocator,iconLocator>(void *, int)
.text$mn:000028E0                 public ??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z
.text$mn:000028E0 ??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z proc near
.text$mn:000028E0                                         ; CODE XREF: std::allocator_traits<std::allocator<iconLocator>>::construct<iconLocator,iconLocator>(std::allocator<iconLocator> &,iconLocator *,iconLocator &&)+17p
.text$mn:000028E0
.text$mn:000028E0 var_1C          = dword ptr -1Ch
.text$mn:000028E0 var_18          = dword ptr -18h
.text$mn:000028E0 var_14          = dword ptr -14h
.text$mn:000028E0 var_10          = dword ptr -10h
.text$mn:000028E0 var_C           = dword ptr -0Ch
.text$mn:000028E0 var_4           = dword ptr -4
.text$mn:000028E0 arg_0           = dword ptr  8
.text$mn:000028E0 arg_4           = dword ptr  0Ch
.text$mn:000028E0
.text$mn:000028E0                 push    ebp
.text$mn:000028E1                 mov     ebp, esp
.text$mn:000028E3                 push    0FFFFFFFFh
.text$mn:000028E5                 push    offset __ehhandler$??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z
.text$mn:000028EA                 mov     eax, large fs:0
.text$mn:000028F0                 push    eax
.text$mn:000028F1                 sub     esp, 10h
.text$mn:000028F4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000028F9                 xor     eax, ebp
.text$mn:000028FB                 push    eax
.text$mn:000028FC                 lea     eax, [ebp+var_C]
.text$mn:000028FF                 mov     large fs:0, eax
.text$mn:00002905                 mov     [ebp+var_18], ecx
.text$mn:00002908                 mov     eax, [ebp+arg_0]
.text$mn:0000290B                 push    eax             ; void *
.text$mn:0000290C                 push    24h ; '$'       ; unsigned int
.text$mn:0000290E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002913                 add     esp, 8
.text$mn:00002916                 mov     [ebp+var_10], eax
.text$mn:00002919                 mov     [ebp+var_4], 0
.text$mn:00002920                 cmp     [ebp+var_10], 0
.text$mn:00002924                 jz      short loc_2940
.text$mn:00002926                 mov     ecx, [ebp+arg_4]
.text$mn:00002929                 push    ecx
.text$mn:0000292A                 call    ??$forward@UiconLocator@@@std@@YA$$QAUiconLocator@@AAU1@@Z ; std::forward<iconLocator>(iconLocator &)
.text$mn:0000292F                 add     esp, 4
.text$mn:00002932                 push    eax
.text$mn:00002933                 mov     ecx, [ebp+var_10]
.text$mn:00002936                 call    ??0iconLocator@@QAE@ABU0@@Z ; iconLocator::iconLocator(iconLocator const &)
.text$mn:0000293B                 mov     [ebp+var_14], eax
.text$mn:0000293E                 jmp     short loc_2947
.text$mn:00002940 ; ---------------------------------------------------------------------------
.text$mn:00002940
.text$mn:00002940 loc_2940:                               ; CODE XREF: std::allocator<iconLocator>::construct<iconLocator,iconLocator>(iconLocator *,iconLocator &&)+44j
.text$mn:00002940                 mov     [ebp+var_14], 0
.text$mn:00002947
.text$mn:00002947 loc_2947:                               ; CODE XREF: std::allocator<iconLocator>::construct<iconLocator,iconLocator>(iconLocator *,iconLocator &&)+5Ej
.text$mn:00002947                 mov     edx, [ebp+var_14]
.text$mn:0000294A                 mov     [ebp+var_1C], edx
.text$mn:0000294D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002954                 mov     ecx, [ebp+var_C]
.text$mn:00002957                 mov     large fs:0, ecx
.text$mn:0000295E                 pop     ecx
.text$mn:0000295F                 mov     esp, ebp
.text$mn:00002961                 pop     ebp
.text$mn:00002962                 retn    8
.text$mn:00002962 ??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z endp
.text$mn:00002962
.text$mn:00002962 ; ---------------------------------------------------------------------------
.text$mn:00002965                 align 4
.text$mn:00002965 _text$mn        ends
.text$mn:00002965
.text$x:00002968 ; ===========================================================================
.text$x:00002968
.text$x:00002968 ; Segment type: Pure code
.text$x:00002968 ; Segment permissions: Read/Execute
.text$x:00002968 _text$x         segment para public 'CODE' use32
.text$x:00002968                 assume cs:_text$x
.text$x:00002968                 ;org 2968h
.text$x:00002968 ; COMDAT (pick associative to section at 28E0)
.text$x:00002968                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002968
.text$x:00002968 ; =============== S U B R O U T I N E =======================================
.text$x:00002968
.text$x:00002968
.text$x:00002968 __unwindfunclet$??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z$0 proc near
.text$x:00002968                                         ; DATA XREF: .xdata$x:0000864Co
.text$x:00002968                 mov     eax, [ebp+8]
.text$x:0000296B                 push    eax
.text$x:0000296C                 mov     eax, [ebp-10h]
.text$x:0000296F                 push    eax             ; void *
.text$x:00002970                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002975                 add     esp, 8
.text$x:00002978                 retn
.text$x:00002978 __unwindfunclet$??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z$0 endp
.text$x:00002978
.text$x:00002979
.text$x:00002979 ; =============== S U B R O U T I N E =======================================
.text$x:00002979
.text$x:00002979
.text$x:00002979 __ehhandler$??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z proc near
.text$x:00002979                                         ; DATA XREF: std::allocator<iconLocator>::construct<iconLocator,iconLocator>(iconLocator *,iconLocator &&)+5o
.text$x:00002979
.text$x:00002979 arg_4           = dword ptr  8
.text$x:00002979
.text$x:00002979                 mov     edx, [esp+arg_4]
.text$x:0000297D                 lea     eax, [edx+0Ch]
.text$x:00002980                 mov     ecx, [edx-14h]
.text$x:00002983                 xor     ecx, eax
.text$x:00002985                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000298A                 mov     eax, offset __ehfuncinfo$??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z
.text$x:0000298F                 jmp     ___CxxFrameHandler3
.text$x:0000298F __ehhandler$??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z endp
.text$x:0000298F
.text$x:0000298F _text$x         ends
.text$x:0000298F
.text$mn:00002994 ; ===========================================================================
.text$mn:00002994
.text$mn:00002994 ; Segment type: Pure code
.text$mn:00002994 ; Segment permissions: Read/Execute
.text$mn:00002994 _text$mn        segment para public 'CODE' use32
.text$mn:00002994                 assume cs:_text$mn
.text$mn:00002994                 ;org 2994h
.text$mn:00002994 ; COMDAT (pick any)
.text$mn:00002994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002994
.text$mn:00002994 ; =============== S U B R O U T I N E =======================================
.text$mn:00002994
.text$mn:00002994 ; Attributes: bp-based frame
.text$mn:00002994
.text$mn:00002994 ; int __cdecl std::allocator_traits<std::allocator<iconLocator>>::construct<iconLocator,iconLocator>(int, void *, int)
.text$mn:00002994                 public ??$construct@UiconLocator@@U1@@?$allocator_traits@V?$allocator@UiconLocator@@@std@@@std@@SAXAAV?$allocator@UiconLocator@@@1@PAUiconLocator@@$$QAU3@@Z
.text$mn:00002994 ??$construct@UiconLocator@@U1@@?$allocator_traits@V?$allocator@UiconLocator@@@std@@@std@@SAXAAV?$allocator@UiconLocator@@@1@PAUiconLocator@@$$QAU3@@Z proc near
.text$mn:00002994                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<iconLocator>>::construct<iconLocator,iconLocator>(iconLocator *,iconLocator &&)+1Cp
.text$mn:00002994
.text$mn:00002994 arg_0           = dword ptr  8
.text$mn:00002994 arg_4           = dword ptr  0Ch
.text$mn:00002994 arg_8           = dword ptr  10h
.text$mn:00002994
.text$mn:00002994                 push    ebp
.text$mn:00002995                 mov     ebp, esp
.text$mn:00002997                 mov     eax, [ebp+arg_8]
.text$mn:0000299A                 push    eax
.text$mn:0000299B                 call    ??$forward@UiconLocator@@@std@@YA$$QAUiconLocator@@AAU1@@Z ; std::forward<iconLocator>(iconLocator &)
.text$mn:000029A0                 add     esp, 4
.text$mn:000029A3                 push    eax             ; int
.text$mn:000029A4                 mov     ecx, [ebp+arg_4]
.text$mn:000029A7                 push    ecx             ; void *
.text$mn:000029A8                 mov     ecx, [ebp+arg_0]
.text$mn:000029AB                 call    ??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z ; std::allocator<iconLocator>::construct<iconLocator,iconLocator>(iconLocator *,iconLocator &&)
.text$mn:000029B0                 pop     ebp
.text$mn:000029B1                 retn
.text$mn:000029B1 ??$construct@UiconLocator@@U1@@?$allocator_traits@V?$allocator@UiconLocator@@@std@@@std@@SAXAAV?$allocator@UiconLocator@@@1@PAUiconLocator@@$$QAU3@@Z endp
.text$mn:000029B1
.text$mn:000029B1 ; ---------------------------------------------------------------------------
.text$mn:000029B2                 align 4
.text$mn:000029B2 _text$mn        ends
.text$mn:000029B2
.text$mn:000029B4 ; ===========================================================================
.text$mn:000029B4
.text$mn:000029B4 ; Segment type: Pure code
.text$mn:000029B4 ; Segment permissions: Read/Execute
.text$mn:000029B4 _text$mn        segment para public 'CODE' use32
.text$mn:000029B4                 assume cs:_text$mn
.text$mn:000029B4                 ;org 29B4h
.text$mn:000029B4 ; COMDAT (pick any)
.text$mn:000029B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029B4
.text$mn:000029B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029B4
.text$mn:000029B4 ; Attributes: bp-based frame
.text$mn:000029B4
.text$mn:000029B4 ; int __stdcall std::_Wrap_alloc<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList &>(void *, int)
.text$mn:000029B4                 public ??$construct@UtDynamicList@@AAU1@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@AAU2@@Z
.text$mn:000029B4 ??$construct@UtDynamicList@@AAU1@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@AAU2@@Z proc near
.text$mn:000029B4                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::push_back(tDynamicList const &)+94p
.text$mn:000029B4
.text$mn:000029B4 var_4           = dword ptr -4
.text$mn:000029B4 arg_0           = dword ptr  8
.text$mn:000029B4 arg_4           = dword ptr  0Ch
.text$mn:000029B4
.text$mn:000029B4                 push    ebp
.text$mn:000029B5                 mov     ebp, esp
.text$mn:000029B7                 push    ecx
.text$mn:000029B8                 mov     [ebp+var_4], ecx
.text$mn:000029BB                 mov     eax, [ebp+arg_4]
.text$mn:000029BE                 push    eax
.text$mn:000029BF                 call    ??$forward@AAUtDynamicList@@@std@@YAAAUtDynamicList@@AAU1@@Z ; std::forward<tDynamicList &>(tDynamicList &)
.text$mn:000029C4                 add     esp, 4
.text$mn:000029C7                 push    eax             ; int
.text$mn:000029C8                 mov     ecx, [ebp+arg_0]
.text$mn:000029CB                 push    ecx             ; void *
.text$mn:000029CC                 mov     edx, [ebp+var_4]
.text$mn:000029CF                 push    edx             ; int
.text$mn:000029D0                 call    ??$construct@UtDynamicList@@AAU1@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@AAU3@@Z ; std::allocator_traits<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList &>(std::allocator<tDynamicList> &,tDynamicList *,tDynamicList &)
.text$mn:000029D5                 add     esp, 0Ch
.text$mn:000029D8                 mov     esp, ebp
.text$mn:000029DA                 pop     ebp
.text$mn:000029DB                 retn    8
.text$mn:000029DB ??$construct@UtDynamicList@@AAU1@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@AAU2@@Z endp
.text$mn:000029DB
.text$mn:000029DB ; ---------------------------------------------------------------------------
.text$mn:000029DE                 align 10h
.text$mn:000029DE _text$mn        ends
.text$mn:000029DE
.text$mn:000029E0 ; ===========================================================================
.text$mn:000029E0
.text$mn:000029E0 ; Segment type: Pure code
.text$mn:000029E0 ; Segment permissions: Read/Execute
.text$mn:000029E0 _text$mn        segment para public 'CODE' use32
.text$mn:000029E0                 assume cs:_text$mn
.text$mn:000029E0                 ;org 29E0h
.text$mn:000029E0 ; COMDAT (pick any)
.text$mn:000029E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029E0
.text$mn:000029E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000029E0
.text$mn:000029E0 ; Attributes: bp-based frame
.text$mn:000029E0
.text$mn:000029E0 ; int __stdcall std::allocator<tDynamicList>::construct<tDynamicList,tDynamicList &>(void *, int)
.text$mn:000029E0                 public ??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z
.text$mn:000029E0 ??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z proc near
.text$mn:000029E0                                         ; CODE XREF: std::allocator_traits<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList &>(std::allocator<tDynamicList> &,tDynamicList *,tDynamicList &)+17p
.text$mn:000029E0
.text$mn:000029E0 var_1C          = dword ptr -1Ch
.text$mn:000029E0 var_18          = dword ptr -18h
.text$mn:000029E0 var_14          = dword ptr -14h
.text$mn:000029E0 var_10          = dword ptr -10h
.text$mn:000029E0 var_C           = dword ptr -0Ch
.text$mn:000029E0 var_4           = dword ptr -4
.text$mn:000029E0 arg_0           = dword ptr  8
.text$mn:000029E0 arg_4           = dword ptr  0Ch
.text$mn:000029E0
.text$mn:000029E0                 push    ebp
.text$mn:000029E1                 mov     ebp, esp
.text$mn:000029E3                 push    0FFFFFFFFh
.text$mn:000029E5                 push    offset __ehhandler$??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z
.text$mn:000029EA                 mov     eax, large fs:0
.text$mn:000029F0                 push    eax
.text$mn:000029F1                 sub     esp, 10h
.text$mn:000029F4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000029F9                 xor     eax, ebp
.text$mn:000029FB                 push    eax
.text$mn:000029FC                 lea     eax, [ebp+var_C]
.text$mn:000029FF                 mov     large fs:0, eax
.text$mn:00002A05                 mov     [ebp+var_18], ecx
.text$mn:00002A08                 mov     eax, [ebp+arg_0]
.text$mn:00002A0B                 push    eax             ; void *
.text$mn:00002A0C                 push    0Ch             ; unsigned int
.text$mn:00002A0E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002A13                 add     esp, 8
.text$mn:00002A16                 mov     [ebp+var_10], eax
.text$mn:00002A19                 mov     [ebp+var_4], 0
.text$mn:00002A20                 cmp     [ebp+var_10], 0
.text$mn:00002A24                 jz      short loc_2A4D
.text$mn:00002A26                 mov     ecx, [ebp+arg_4]
.text$mn:00002A29                 push    ecx
.text$mn:00002A2A                 call    ??$forward@AAUtDynamicList@@@std@@YAAAUtDynamicList@@AAU1@@Z ; std::forward<tDynamicList &>(tDynamicList &)
.text$mn:00002A2F                 add     esp, 4
.text$mn:00002A32                 mov     edx, [ebp+var_10]
.text$mn:00002A35                 mov     ecx, [eax]
.text$mn:00002A37                 mov     [edx], ecx
.text$mn:00002A39                 mov     ecx, [eax+4]
.text$mn:00002A3C                 mov     [edx+4], ecx
.text$mn:00002A3F                 mov     eax, [eax+8]
.text$mn:00002A42                 mov     [edx+8], eax
.text$mn:00002A45                 mov     ecx, [ebp+var_10]
.text$mn:00002A48                 mov     [ebp+var_14], ecx
.text$mn:00002A4B                 jmp     short loc_2A54
.text$mn:00002A4D ; ---------------------------------------------------------------------------
.text$mn:00002A4D
.text$mn:00002A4D loc_2A4D:                               ; CODE XREF: std::allocator<tDynamicList>::construct<tDynamicList,tDynamicList &>(tDynamicList *,tDynamicList &)+44j
.text$mn:00002A4D                 mov     [ebp+var_14], 0
.text$mn:00002A54
.text$mn:00002A54 loc_2A54:                               ; CODE XREF: std::allocator<tDynamicList>::construct<tDynamicList,tDynamicList &>(tDynamicList *,tDynamicList &)+6Bj
.text$mn:00002A54                 mov     edx, [ebp+var_14]
.text$mn:00002A57                 mov     [ebp+var_1C], edx
.text$mn:00002A5A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002A61                 mov     ecx, [ebp+var_C]
.text$mn:00002A64                 mov     large fs:0, ecx
.text$mn:00002A6B                 pop     ecx
.text$mn:00002A6C                 mov     esp, ebp
.text$mn:00002A6E                 pop     ebp
.text$mn:00002A6F                 retn    8
.text$mn:00002A6F ??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z endp
.text$mn:00002A6F
.text$mn:00002A6F ; ---------------------------------------------------------------------------
.text$mn:00002A72                 align 4
.text$mn:00002A72 _text$mn        ends
.text$mn:00002A72
.text$x:00002A74 ; ===========================================================================
.text$x:00002A74
.text$x:00002A74 ; Segment type: Pure code
.text$x:00002A74 ; Segment permissions: Read/Execute
.text$x:00002A74 _text$x         segment para public 'CODE' use32
.text$x:00002A74                 assume cs:_text$x
.text$x:00002A74                 ;org 2A74h
.text$x:00002A74 ; COMDAT (pick associative to section at 29E0)
.text$x:00002A74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002A74
.text$x:00002A74 ; =============== S U B R O U T I N E =======================================
.text$x:00002A74
.text$x:00002A74
.text$x:00002A74 __unwindfunclet$??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z$0 proc near
.text$x:00002A74                                         ; DATA XREF: .xdata$x:00008620o
.text$x:00002A74                 mov     eax, [ebp+8]
.text$x:00002A77                 push    eax
.text$x:00002A78                 mov     eax, [ebp-10h]
.text$x:00002A7B                 push    eax             ; void *
.text$x:00002A7C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002A81                 add     esp, 8
.text$x:00002A84                 retn
.text$x:00002A84 __unwindfunclet$??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z$0 endp
.text$x:00002A84
.text$x:00002A85
.text$x:00002A85 ; =============== S U B R O U T I N E =======================================
.text$x:00002A85
.text$x:00002A85
.text$x:00002A85 __ehhandler$??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z proc near
.text$x:00002A85                                         ; DATA XREF: std::allocator<tDynamicList>::construct<tDynamicList,tDynamicList &>(tDynamicList *,tDynamicList &)+5o
.text$x:00002A85
.text$x:00002A85 arg_4           = dword ptr  8
.text$x:00002A85
.text$x:00002A85                 mov     edx, [esp+arg_4]
.text$x:00002A89                 lea     eax, [edx+0Ch]
.text$x:00002A8C                 mov     ecx, [edx-14h]
.text$x:00002A8F                 xor     ecx, eax
.text$x:00002A91                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A96                 mov     eax, offset __ehfuncinfo$??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z
.text$x:00002A9B                 jmp     ___CxxFrameHandler3
.text$x:00002A9B __ehhandler$??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z endp
.text$x:00002A9B
.text$x:00002A9B _text$x         ends
.text$x:00002A9B
.text$mn:00002AA0 ; ===========================================================================
.text$mn:00002AA0
.text$mn:00002AA0 ; Segment type: Pure code
.text$mn:00002AA0 ; Segment permissions: Read/Execute
.text$mn:00002AA0 _text$mn        segment para public 'CODE' use32
.text$mn:00002AA0                 assume cs:_text$mn
.text$mn:00002AA0                 ;org 2AA0h
.text$mn:00002AA0 ; COMDAT (pick any)
.text$mn:00002AA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AA0
.text$mn:00002AA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AA0
.text$mn:00002AA0 ; Attributes: bp-based frame
.text$mn:00002AA0
.text$mn:00002AA0 ; int __cdecl std::allocator_traits<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList &>(int, void *, int)
.text$mn:00002AA0                 public ??$construct@UtDynamicList@@AAU1@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@AAU3@@Z
.text$mn:00002AA0 ??$construct@UtDynamicList@@AAU1@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@AAU3@@Z proc near
.text$mn:00002AA0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList &>(tDynamicList *,tDynamicList &)+1Cp
.text$mn:00002AA0
.text$mn:00002AA0 arg_0           = dword ptr  8
.text$mn:00002AA0 arg_4           = dword ptr  0Ch
.text$mn:00002AA0 arg_8           = dword ptr  10h
.text$mn:00002AA0
.text$mn:00002AA0                 push    ebp
.text$mn:00002AA1                 mov     ebp, esp
.text$mn:00002AA3                 mov     eax, [ebp+arg_8]
.text$mn:00002AA6                 push    eax
.text$mn:00002AA7                 call    ??$forward@AAUtDynamicList@@@std@@YAAAUtDynamicList@@AAU1@@Z ; std::forward<tDynamicList &>(tDynamicList &)
.text$mn:00002AAC                 add     esp, 4
.text$mn:00002AAF                 push    eax             ; int
.text$mn:00002AB0                 mov     ecx, [ebp+arg_4]
.text$mn:00002AB3                 push    ecx             ; void *
.text$mn:00002AB4                 mov     ecx, [ebp+arg_0]
.text$mn:00002AB7                 call    ??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z ; std::allocator<tDynamicList>::construct<tDynamicList,tDynamicList &>(tDynamicList *,tDynamicList &)
.text$mn:00002ABC                 pop     ebp
.text$mn:00002ABD                 retn
.text$mn:00002ABD ??$construct@UtDynamicList@@AAU1@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@AAU3@@Z endp
.text$mn:00002ABD
.text$mn:00002ABD ; ---------------------------------------------------------------------------
.text$mn:00002ABE                 align 10h
.text$mn:00002ABE _text$mn        ends
.text$mn:00002ABE
.text$mn:00002AC0 ; ===========================================================================
.text$mn:00002AC0
.text$mn:00002AC0 ; Segment type: Pure code
.text$mn:00002AC0 ; Segment permissions: Read/Execute
.text$mn:00002AC0 _text$mn        segment para public 'CODE' use32
.text$mn:00002AC0                 assume cs:_text$mn
.text$mn:00002AC0                 ;org 2AC0h
.text$mn:00002AC0 ; COMDAT (pick any)
.text$mn:00002AC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AC0
.text$mn:00002AC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AC0
.text$mn:00002AC0 ; Attributes: bp-based frame
.text$mn:00002AC0
.text$mn:00002AC0 ; int __stdcall std::_Wrap_alloc<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList const &>(void *, int)
.text$mn:00002AC0                 public ??$construct@UtDynamicList@@ABU1@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@ABU2@@Z
.text$mn:00002AC0 ??$construct@UtDynamicList@@ABU1@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@ABU2@@Z proc near
.text$mn:00002AC0                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::push_back(tDynamicList const &)+F1p
.text$mn:00002AC0
.text$mn:00002AC0 var_4           = dword ptr -4
.text$mn:00002AC0 arg_0           = dword ptr  8
.text$mn:00002AC0 arg_4           = dword ptr  0Ch
.text$mn:00002AC0
.text$mn:00002AC0                 push    ebp
.text$mn:00002AC1                 mov     ebp, esp
.text$mn:00002AC3                 push    ecx
.text$mn:00002AC4                 mov     [ebp+var_4], ecx
.text$mn:00002AC7                 mov     eax, [ebp+arg_4]
.text$mn:00002ACA                 push    eax
.text$mn:00002ACB                 call    ??$forward@ABUtDynamicList@@@std@@YAABUtDynamicList@@ABU1@@Z ; std::forward<tDynamicList const &>(tDynamicList const &)
.text$mn:00002AD0                 add     esp, 4
.text$mn:00002AD3                 push    eax             ; int
.text$mn:00002AD4                 mov     ecx, [ebp+arg_0]
.text$mn:00002AD7                 push    ecx             ; void *
.text$mn:00002AD8                 mov     edx, [ebp+var_4]
.text$mn:00002ADB                 push    edx             ; int
.text$mn:00002ADC                 call    ??$construct@UtDynamicList@@ABU1@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@ABU3@@Z ; std::allocator_traits<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList const &>(std::allocator<tDynamicList> &,tDynamicList *,tDynamicList const &)
.text$mn:00002AE1                 add     esp, 0Ch
.text$mn:00002AE4                 mov     esp, ebp
.text$mn:00002AE6                 pop     ebp
.text$mn:00002AE7                 retn    8
.text$mn:00002AE7 ??$construct@UtDynamicList@@ABU1@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@ABU2@@Z endp
.text$mn:00002AE7
.text$mn:00002AE7 ; ---------------------------------------------------------------------------
.text$mn:00002AEA                 align 4
.text$mn:00002AEA _text$mn        ends
.text$mn:00002AEA
.text$mn:00002AEC ; ===========================================================================
.text$mn:00002AEC
.text$mn:00002AEC ; Segment type: Pure code
.text$mn:00002AEC ; Segment permissions: Read/Execute
.text$mn:00002AEC _text$mn        segment para public 'CODE' use32
.text$mn:00002AEC                 assume cs:_text$mn
.text$mn:00002AEC                 ;org 2AECh
.text$mn:00002AEC ; COMDAT (pick any)
.text$mn:00002AEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AEC
.text$mn:00002AEC ; =============== S U B R O U T I N E =======================================
.text$mn:00002AEC
.text$mn:00002AEC ; Attributes: bp-based frame
.text$mn:00002AEC
.text$mn:00002AEC ; int __cdecl std::allocator_traits<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList const &>(int, void *, int)
.text$mn:00002AEC                 public ??$construct@UtDynamicList@@ABU1@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@ABU3@@Z
.text$mn:00002AEC ??$construct@UtDynamicList@@ABU1@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@ABU3@@Z proc near
.text$mn:00002AEC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList const &>(tDynamicList *,tDynamicList const &)+1Cp
.text$mn:00002AEC
.text$mn:00002AEC arg_0           = dword ptr  8
.text$mn:00002AEC arg_4           = dword ptr  0Ch
.text$mn:00002AEC arg_8           = dword ptr  10h
.text$mn:00002AEC
.text$mn:00002AEC                 push    ebp
.text$mn:00002AED                 mov     ebp, esp
.text$mn:00002AEF                 mov     eax, [ebp+arg_8]
.text$mn:00002AF2                 push    eax
.text$mn:00002AF3                 call    ??$forward@ABUtDynamicList@@@std@@YAABUtDynamicList@@ABU1@@Z ; std::forward<tDynamicList const &>(tDynamicList const &)
.text$mn:00002AF8                 add     esp, 4
.text$mn:00002AFB                 push    eax             ; int
.text$mn:00002AFC                 mov     ecx, [ebp+arg_4]
.text$mn:00002AFF                 push    ecx             ; void *
.text$mn:00002B00                 mov     ecx, [ebp+arg_0]
.text$mn:00002B03                 call    ?construct@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@ABU3@@Z ; std::allocator<tDynamicList>::construct(tDynamicList *,tDynamicList const &)
.text$mn:00002B08                 pop     ebp
.text$mn:00002B09                 retn
.text$mn:00002B09 ??$construct@UtDynamicList@@ABU1@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@ABU3@@Z endp
.text$mn:00002B09
.text$mn:00002B09 ; ---------------------------------------------------------------------------
.text$mn:00002B0A                 align 4
.text$mn:00002B0A _text$mn        ends
.text$mn:00002B0A
.text$mn:00002B0C ; ===========================================================================
.text$mn:00002B0C
.text$mn:00002B0C ; Segment type: Pure code
.text$mn:00002B0C ; Segment permissions: Read/Execute
.text$mn:00002B0C _text$mn        segment para public 'CODE' use32
.text$mn:00002B0C                 assume cs:_text$mn
.text$mn:00002B0C                 ;org 2B0Ch
.text$mn:00002B0C ; COMDAT (pick any)
.text$mn:00002B0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B0C
.text$mn:00002B0C ; =============== S U B R O U T I N E =======================================
.text$mn:00002B0C
.text$mn:00002B0C ; Attributes: bp-based frame
.text$mn:00002B0C
.text$mn:00002B0C ; int __stdcall std::_Wrap_alloc<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList>(void *, int)
.text$mn:00002B0C                 public ??$construct@UtDynamicList@@U1@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z
.text$mn:00002B0C ??$construct@UtDynamicList@@U1@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z proc near
.text$mn:00002B0C                                         ; CODE XREF: std::_Uninit_move<tDynamicList *,tDynamicList *,std::allocator<tDynamicList>,tDynamicList>(tDynamicList *,tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &,tDynamicList *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:00002B0C
.text$mn:00002B0C var_4           = dword ptr -4
.text$mn:00002B0C arg_0           = dword ptr  8
.text$mn:00002B0C arg_4           = dword ptr  0Ch
.text$mn:00002B0C
.text$mn:00002B0C                 push    ebp
.text$mn:00002B0D                 mov     ebp, esp
.text$mn:00002B0F                 push    ecx
.text$mn:00002B10                 mov     [ebp+var_4], ecx
.text$mn:00002B13                 mov     eax, [ebp+arg_4]
.text$mn:00002B16                 push    eax
.text$mn:00002B17                 call    ??$forward@UtDynamicList@@@std@@YA$$QAUtDynamicList@@AAU1@@Z ; std::forward<tDynamicList>(tDynamicList &)
.text$mn:00002B1C                 add     esp, 4
.text$mn:00002B1F                 push    eax             ; int
.text$mn:00002B20                 mov     ecx, [ebp+arg_0]
.text$mn:00002B23                 push    ecx             ; void *
.text$mn:00002B24                 mov     edx, [ebp+var_4]
.text$mn:00002B27                 push    edx             ; int
.text$mn:00002B28                 call    ??$construct@UtDynamicList@@U1@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@$$QAU3@@Z ; std::allocator_traits<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList>(std::allocator<tDynamicList> &,tDynamicList *,tDynamicList &&)
.text$mn:00002B2D                 add     esp, 0Ch
.text$mn:00002B30                 mov     esp, ebp
.text$mn:00002B32                 pop     ebp
.text$mn:00002B33                 retn    8
.text$mn:00002B33 ??$construct@UtDynamicList@@U1@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z endp
.text$mn:00002B33
.text$mn:00002B33 ; ---------------------------------------------------------------------------
.text$mn:00002B36                 align 4
.text$mn:00002B36 _text$mn        ends
.text$mn:00002B36
.text$mn:00002B38 ; ===========================================================================
.text$mn:00002B38
.text$mn:00002B38 ; Segment type: Pure code
.text$mn:00002B38 ; Segment permissions: Read/Execute
.text$mn:00002B38 _text$mn        segment para public 'CODE' use32
.text$mn:00002B38                 assume cs:_text$mn
.text$mn:00002B38                 ;org 2B38h
.text$mn:00002B38 ; COMDAT (pick any)
.text$mn:00002B38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B38
.text$mn:00002B38 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B38
.text$mn:00002B38 ; Attributes: bp-based frame
.text$mn:00002B38
.text$mn:00002B38 ; int __stdcall std::allocator<tDynamicList>::construct<tDynamicList,tDynamicList>(void *, int)
.text$mn:00002B38                 public ??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z
.text$mn:00002B38 ??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z proc near
.text$mn:00002B38                                         ; CODE XREF: std::allocator_traits<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList>(std::allocator<tDynamicList> &,tDynamicList *,tDynamicList &&)+17p
.text$mn:00002B38
.text$mn:00002B38 var_1C          = dword ptr -1Ch
.text$mn:00002B38 var_18          = dword ptr -18h
.text$mn:00002B38 var_14          = dword ptr -14h
.text$mn:00002B38 var_10          = dword ptr -10h
.text$mn:00002B38 var_C           = dword ptr -0Ch
.text$mn:00002B38 var_4           = dword ptr -4
.text$mn:00002B38 arg_0           = dword ptr  8
.text$mn:00002B38 arg_4           = dword ptr  0Ch
.text$mn:00002B38
.text$mn:00002B38                 push    ebp
.text$mn:00002B39                 mov     ebp, esp
.text$mn:00002B3B                 push    0FFFFFFFFh
.text$mn:00002B3D                 push    offset __ehhandler$??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z
.text$mn:00002B42                 mov     eax, large fs:0
.text$mn:00002B48                 push    eax
.text$mn:00002B49                 sub     esp, 10h
.text$mn:00002B4C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B51                 xor     eax, ebp
.text$mn:00002B53                 push    eax
.text$mn:00002B54                 lea     eax, [ebp+var_C]
.text$mn:00002B57                 mov     large fs:0, eax
.text$mn:00002B5D                 mov     [ebp+var_18], ecx
.text$mn:00002B60                 mov     eax, [ebp+arg_0]
.text$mn:00002B63                 push    eax             ; void *
.text$mn:00002B64                 push    0Ch             ; unsigned int
.text$mn:00002B66                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002B6B                 add     esp, 8
.text$mn:00002B6E                 mov     [ebp+var_10], eax
.text$mn:00002B71                 mov     [ebp+var_4], 0
.text$mn:00002B78                 cmp     [ebp+var_10], 0
.text$mn:00002B7C                 jz      short loc_2BA5
.text$mn:00002B7E                 mov     ecx, [ebp+arg_4]
.text$mn:00002B81                 push    ecx
.text$mn:00002B82                 call    ??$forward@UtDynamicList@@@std@@YA$$QAUtDynamicList@@AAU1@@Z ; std::forward<tDynamicList>(tDynamicList &)
.text$mn:00002B87                 add     esp, 4
.text$mn:00002B8A                 mov     edx, [ebp+var_10]
.text$mn:00002B8D                 mov     ecx, [eax]
.text$mn:00002B8F                 mov     [edx], ecx
.text$mn:00002B91                 mov     ecx, [eax+4]
.text$mn:00002B94                 mov     [edx+4], ecx
.text$mn:00002B97                 mov     eax, [eax+8]
.text$mn:00002B9A                 mov     [edx+8], eax
.text$mn:00002B9D                 mov     ecx, [ebp+var_10]
.text$mn:00002BA0                 mov     [ebp+var_14], ecx
.text$mn:00002BA3                 jmp     short loc_2BAC
.text$mn:00002BA5 ; ---------------------------------------------------------------------------
.text$mn:00002BA5
.text$mn:00002BA5 loc_2BA5:                               ; CODE XREF: std::allocator<tDynamicList>::construct<tDynamicList,tDynamicList>(tDynamicList *,tDynamicList &&)+44j
.text$mn:00002BA5                 mov     [ebp+var_14], 0
.text$mn:00002BAC
.text$mn:00002BAC loc_2BAC:                               ; CODE XREF: std::allocator<tDynamicList>::construct<tDynamicList,tDynamicList>(tDynamicList *,tDynamicList &&)+6Bj
.text$mn:00002BAC                 mov     edx, [ebp+var_14]
.text$mn:00002BAF                 mov     [ebp+var_1C], edx
.text$mn:00002BB2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002BB9                 mov     ecx, [ebp+var_C]
.text$mn:00002BBC                 mov     large fs:0, ecx
.text$mn:00002BC3                 pop     ecx
.text$mn:00002BC4                 mov     esp, ebp
.text$mn:00002BC6                 pop     ebp
.text$mn:00002BC7                 retn    8
.text$mn:00002BC7 ??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z endp
.text$mn:00002BC7
.text$mn:00002BC7 ; ---------------------------------------------------------------------------
.text$mn:00002BCA                 align 4
.text$mn:00002BCA _text$mn        ends
.text$mn:00002BCA
.text$x:00002BCC ; ===========================================================================
.text$x:00002BCC
.text$x:00002BCC ; Segment type: Pure code
.text$x:00002BCC ; Segment permissions: Read/Execute
.text$x:00002BCC _text$x         segment para public 'CODE' use32
.text$x:00002BCC                 assume cs:_text$x
.text$x:00002BCC                 ;org 2BCCh
.text$x:00002BCC ; COMDAT (pick associative to section at 2B38)
.text$x:00002BCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002BCC
.text$x:00002BCC ; =============== S U B R O U T I N E =======================================
.text$x:00002BCC
.text$x:00002BCC
.text$x:00002BCC __unwindfunclet$??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z$0 proc near
.text$x:00002BCC                                         ; DATA XREF: .xdata$x:000087ACo
.text$x:00002BCC                 mov     eax, [ebp+8]
.text$x:00002BCF                 push    eax
.text$x:00002BD0                 mov     eax, [ebp-10h]
.text$x:00002BD3                 push    eax             ; void *
.text$x:00002BD4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002BD9                 add     esp, 8
.text$x:00002BDC                 retn
.text$x:00002BDC __unwindfunclet$??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z$0 endp
.text$x:00002BDC
.text$x:00002BDD
.text$x:00002BDD ; =============== S U B R O U T I N E =======================================
.text$x:00002BDD
.text$x:00002BDD
.text$x:00002BDD __ehhandler$??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z proc near
.text$x:00002BDD                                         ; DATA XREF: std::allocator<tDynamicList>::construct<tDynamicList,tDynamicList>(tDynamicList *,tDynamicList &&)+5o
.text$x:00002BDD
.text$x:00002BDD arg_4           = dword ptr  8
.text$x:00002BDD
.text$x:00002BDD                 mov     edx, [esp+arg_4]
.text$x:00002BE1                 lea     eax, [edx+0Ch]
.text$x:00002BE4                 mov     ecx, [edx-14h]
.text$x:00002BE7                 xor     ecx, eax
.text$x:00002BE9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BEE                 mov     eax, offset __ehfuncinfo$??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z
.text$x:00002BF3                 jmp     ___CxxFrameHandler3
.text$x:00002BF3 __ehhandler$??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z endp
.text$x:00002BF3
.text$x:00002BF3 _text$x         ends
.text$x:00002BF3
.text$mn:00002BF8 ; ===========================================================================
.text$mn:00002BF8
.text$mn:00002BF8 ; Segment type: Pure code
.text$mn:00002BF8 ; Segment permissions: Read/Execute
.text$mn:00002BF8 _text$mn        segment para public 'CODE' use32
.text$mn:00002BF8                 assume cs:_text$mn
.text$mn:00002BF8                 ;org 2BF8h
.text$mn:00002BF8 ; COMDAT (pick any)
.text$mn:00002BF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BF8
.text$mn:00002BF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BF8
.text$mn:00002BF8 ; Attributes: bp-based frame
.text$mn:00002BF8
.text$mn:00002BF8 ; int __cdecl std::allocator_traits<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList>(int, void *, int)
.text$mn:00002BF8                 public ??$construct@UtDynamicList@@U1@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@$$QAU3@@Z
.text$mn:00002BF8 ??$construct@UtDynamicList@@U1@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@$$QAU3@@Z proc near
.text$mn:00002BF8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList>(tDynamicList *,tDynamicList &&)+1Cp
.text$mn:00002BF8
.text$mn:00002BF8 arg_0           = dword ptr  8
.text$mn:00002BF8 arg_4           = dword ptr  0Ch
.text$mn:00002BF8 arg_8           = dword ptr  10h
.text$mn:00002BF8
.text$mn:00002BF8                 push    ebp
.text$mn:00002BF9                 mov     ebp, esp
.text$mn:00002BFB                 mov     eax, [ebp+arg_8]
.text$mn:00002BFE                 push    eax
.text$mn:00002BFF                 call    ??$forward@UtDynamicList@@@std@@YA$$QAUtDynamicList@@AAU1@@Z ; std::forward<tDynamicList>(tDynamicList &)
.text$mn:00002C04                 add     esp, 4
.text$mn:00002C07                 push    eax             ; int
.text$mn:00002C08                 mov     ecx, [ebp+arg_4]
.text$mn:00002C0B                 push    ecx             ; void *
.text$mn:00002C0C                 mov     ecx, [ebp+arg_0]
.text$mn:00002C0F                 call    ??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z ; std::allocator<tDynamicList>::construct<tDynamicList,tDynamicList>(tDynamicList *,tDynamicList &&)
.text$mn:00002C14                 pop     ebp
.text$mn:00002C15                 retn
.text$mn:00002C15 ??$construct@UtDynamicList@@U1@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@$$QAU3@@Z endp
.text$mn:00002C15
.text$mn:00002C15 ; ---------------------------------------------------------------------------
.text$mn:00002C16                 align 4
.text$mn:00002C16 _text$mn        ends
.text$mn:00002C16
.text$mn:00002C18 ; ===========================================================================
.text$mn:00002C18
.text$mn:00002C18 ; Segment type: Pure code
.text$mn:00002C18 ; Segment permissions: Read/Execute
.text$mn:00002C18 _text$mn        segment para public 'CODE' use32
.text$mn:00002C18                 assume cs:_text$mn
.text$mn:00002C18                 ;org 2C18h
.text$mn:00002C18 ; COMDAT (pick any)
.text$mn:00002C18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C18
.text$mn:00002C18 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C18
.text$mn:00002C18 ; Attributes: bp-based frame
.text$mn:00002C18
.text$mn:00002C18 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00002C18                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00002C18 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00002C18                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00002C18
.text$mn:00002C18 var_4           = dword ptr -4
.text$mn:00002C18 arg_0           = dword ptr  8
.text$mn:00002C18
.text$mn:00002C18                 push    ebp
.text$mn:00002C19                 mov     ebp, esp
.text$mn:00002C1B                 push    ecx
.text$mn:00002C1C                 mov     [ebp+var_4], ecx
.text$mn:00002C1F                 mov     eax, [ebp+arg_0]
.text$mn:00002C22                 push    eax
.text$mn:00002C23                 mov     ecx, [ebp+var_4]
.text$mn:00002C26                 push    ecx
.text$mn:00002C27                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00002C2C                 add     esp, 8
.text$mn:00002C2F                 mov     esp, ebp
.text$mn:00002C31                 pop     ebp
.text$mn:00002C32                 retn    4
.text$mn:00002C32 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00002C32
.text$mn:00002C32 ; ---------------------------------------------------------------------------
.text$mn:00002C35                 align 4
.text$mn:00002C35 _text$mn        ends
.text$mn:00002C35
.text$mn:00002C38 ; ===========================================================================
.text$mn:00002C38
.text$mn:00002C38 ; Segment type: Pure code
.text$mn:00002C38 ; Segment permissions: Read/Execute
.text$mn:00002C38 _text$mn        segment para public 'CODE' use32
.text$mn:00002C38                 assume cs:_text$mn
.text$mn:00002C38                 ;org 2C38h
.text$mn:00002C38 ; COMDAT (pick any)
.text$mn:00002C38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C38
.text$mn:00002C38 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C38
.text$mn:00002C38 ; Attributes: bp-based frame
.text$mn:00002C38
.text$mn:00002C38 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00002C38                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00002C38 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00002C38                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00002C38
.text$mn:00002C38 var_4           = dword ptr -4
.text$mn:00002C38
.text$mn:00002C38                 push    ebp
.text$mn:00002C39                 mov     ebp, esp
.text$mn:00002C3B                 push    ecx
.text$mn:00002C3C                 mov     [ebp+var_4], ecx
.text$mn:00002C3F                 mov     esp, ebp
.text$mn:00002C41                 pop     ebp
.text$mn:00002C42                 retn    4
.text$mn:00002C42 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00002C42
.text$mn:00002C42 ; ---------------------------------------------------------------------------
.text$mn:00002C45                 align 4
.text$mn:00002C45 _text$mn        ends
.text$mn:00002C45
.text$mn:00002C48 ; ===========================================================================
.text$mn:00002C48
.text$mn:00002C48 ; Segment type: Pure code
.text$mn:00002C48 ; Segment permissions: Read/Execute
.text$mn:00002C48 _text$mn        segment para public 'CODE' use32
.text$mn:00002C48                 assume cs:_text$mn
.text$mn:00002C48                 ;org 2C48h
.text$mn:00002C48 ; COMDAT (pick any)
.text$mn:00002C48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C48
.text$mn:00002C48 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C48
.text$mn:00002C48 ; Attributes: bp-based frame
.text$mn:00002C48
.text$mn:00002C48 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00002C48                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00002C48 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00002C48                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00002C48
.text$mn:00002C48 arg_0           = dword ptr  8
.text$mn:00002C48 arg_4           = dword ptr  0Ch
.text$mn:00002C48
.text$mn:00002C48                 push    ebp
.text$mn:00002C49                 mov     ebp, esp
.text$mn:00002C4B                 mov     eax, [ebp+arg_4]
.text$mn:00002C4E                 push    eax
.text$mn:00002C4F                 mov     ecx, [ebp+arg_0]
.text$mn:00002C52                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00002C57                 pop     ebp
.text$mn:00002C58                 retn
.text$mn:00002C58 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00002C58
.text$mn:00002C58 ; ---------------------------------------------------------------------------
.text$mn:00002C59                 align 4
.text$mn:00002C59 _text$mn        ends
.text$mn:00002C59
.text$mn:00002C5C ; ===========================================================================
.text$mn:00002C5C
.text$mn:00002C5C ; Segment type: Pure code
.text$mn:00002C5C ; Segment permissions: Read/Execute
.text$mn:00002C5C _text$mn        segment para public 'CODE' use32
.text$mn:00002C5C                 assume cs:_text$mn
.text$mn:00002C5C                 ;org 2C5Ch
.text$mn:00002C5C ; COMDAT (pick any)
.text$mn:00002C5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C5C
.text$mn:00002C5C ; =============== S U B R O U T I N E =======================================
.text$mn:00002C5C
.text$mn:00002C5C ; Attributes: bp-based frame
.text$mn:00002C5C
.text$mn:00002C5C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00002C5C                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00002C5C ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00002C5C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00002C5C
.text$mn:00002C5C var_4           = dword ptr -4
.text$mn:00002C5C arg_0           = dword ptr  8
.text$mn:00002C5C
.text$mn:00002C5C                 push    ebp
.text$mn:00002C5D                 mov     ebp, esp
.text$mn:00002C5F                 push    ecx
.text$mn:00002C60                 mov     [ebp+var_4], ecx
.text$mn:00002C63                 mov     eax, [ebp+arg_0]
.text$mn:00002C66                 push    eax
.text$mn:00002C67                 mov     ecx, [ebp+var_4]
.text$mn:00002C6A                 push    ecx
.text$mn:00002C6B                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00002C70                 add     esp, 8
.text$mn:00002C73                 mov     esp, ebp
.text$mn:00002C75                 pop     ebp
.text$mn:00002C76                 retn    4
.text$mn:00002C76 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00002C76
.text$mn:00002C76 ; ---------------------------------------------------------------------------
.text$mn:00002C79                 align 4
.text$mn:00002C79 _text$mn        ends
.text$mn:00002C79
.text$mn:00002C7C ; ===========================================================================
.text$mn:00002C7C
.text$mn:00002C7C ; Segment type: Pure code
.text$mn:00002C7C ; Segment permissions: Read/Execute
.text$mn:00002C7C _text$mn        segment para public 'CODE' use32
.text$mn:00002C7C                 assume cs:_text$mn
.text$mn:00002C7C                 ;org 2C7Ch
.text$mn:00002C7C ; COMDAT (pick any)
.text$mn:00002C7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C7C
.text$mn:00002C7C ; =============== S U B R O U T I N E =======================================
.text$mn:00002C7C
.text$mn:00002C7C ; Attributes: bp-based frame
.text$mn:00002C7C
.text$mn:00002C7C ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00002C7C                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00002C7C ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00002C7C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00002C7C
.text$mn:00002C7C var_4           = dword ptr -4
.text$mn:00002C7C
.text$mn:00002C7C                 push    ebp
.text$mn:00002C7D                 mov     ebp, esp
.text$mn:00002C7F                 push    ecx
.text$mn:00002C80                 mov     [ebp+var_4], ecx
.text$mn:00002C83                 mov     esp, ebp
.text$mn:00002C85                 pop     ebp
.text$mn:00002C86                 retn    4
.text$mn:00002C86 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00002C86
.text$mn:00002C86 ; ---------------------------------------------------------------------------
.text$mn:00002C89                 align 4
.text$mn:00002C89 _text$mn        ends
.text$mn:00002C89
.text$mn:00002C8C ; ===========================================================================
.text$mn:00002C8C
.text$mn:00002C8C ; Segment type: Pure code
.text$mn:00002C8C ; Segment permissions: Read/Execute
.text$mn:00002C8C _text$mn        segment para public 'CODE' use32
.text$mn:00002C8C                 assume cs:_text$mn
.text$mn:00002C8C                 ;org 2C8Ch
.text$mn:00002C8C ; COMDAT (pick any)
.text$mn:00002C8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C8C
.text$mn:00002C8C ; =============== S U B R O U T I N E =======================================
.text$mn:00002C8C
.text$mn:00002C8C ; Attributes: bp-based frame
.text$mn:00002C8C
.text$mn:00002C8C ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00002C8C                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00002C8C ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00002C8C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00002C8C
.text$mn:00002C8C arg_0           = dword ptr  8
.text$mn:00002C8C arg_4           = dword ptr  0Ch
.text$mn:00002C8C
.text$mn:00002C8C                 push    ebp
.text$mn:00002C8D                 mov     ebp, esp
.text$mn:00002C8F                 mov     eax, [ebp+arg_4]
.text$mn:00002C92                 push    eax
.text$mn:00002C93                 mov     ecx, [ebp+arg_0]
.text$mn:00002C96                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00002C9B                 pop     ebp
.text$mn:00002C9C                 retn
.text$mn:00002C9C ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00002C9C
.text$mn:00002C9C ; ---------------------------------------------------------------------------
.text$mn:00002C9D                 align 10h
.text$mn:00002C9D _text$mn        ends
.text$mn:00002C9D
.text$mn:00002CA0 ; ===========================================================================
.text$mn:00002CA0
.text$mn:00002CA0 ; Segment type: Pure code
.text$mn:00002CA0 ; Segment permissions: Read/Execute
.text$mn:00002CA0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CA0                 assume cs:_text$mn
.text$mn:00002CA0                 ;org 2CA0h
.text$mn:00002CA0 ; COMDAT (pick any)
.text$mn:00002CA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CA0
.text$mn:00002CA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CA0
.text$mn:00002CA0 ; Attributes: bp-based frame
.text$mn:00002CA0
.text$mn:00002CA0 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00002CA0                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00002CA0 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00002CA0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00002CA0                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+22p
.text$mn:00002CA0
.text$mn:00002CA0 var_4           = dword ptr -4
.text$mn:00002CA0
.text$mn:00002CA0                 push    ebp
.text$mn:00002CA1                 mov     ebp, esp
.text$mn:00002CA3                 push    ecx
.text$mn:00002CA4                 mov     [ebp+var_4], ecx
.text$mn:00002CA7                 mov     esp, ebp
.text$mn:00002CA9                 pop     ebp
.text$mn:00002CAA                 retn    4
.text$mn:00002CAA ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00002CAA
.text$mn:00002CAA ; ---------------------------------------------------------------------------
.text$mn:00002CAD                 align 10h
.text$mn:00002CAD _text$mn        ends
.text$mn:00002CAD
.text$mn:00002CB0 ; ===========================================================================
.text$mn:00002CB0
.text$mn:00002CB0 ; Segment type: Pure code
.text$mn:00002CB0 ; Segment permissions: Read/Execute
.text$mn:00002CB0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CB0                 assume cs:_text$mn
.text$mn:00002CB0                 ;org 2CB0h
.text$mn:00002CB0 ; COMDAT (pick any)
.text$mn:00002CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CB0
.text$mn:00002CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CB0
.text$mn:00002CB0 ; Attributes: bp-based frame
.text$mn:00002CB0
.text$mn:00002CB0 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct iconLocator>>::destroy<struct iconLocator>(struct iconLocator *)
.text$mn:00002CB0                 public ??$destroy@UiconLocator@@@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@@Z
.text$mn:00002CB0 ??$destroy@UiconLocator@@@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@@Z proc near
.text$mn:00002CB0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00002CB0                                         ; __catch$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:00002CB0
.text$mn:00002CB0 var_4           = dword ptr -4
.text$mn:00002CB0 arg_0           = dword ptr  8
.text$mn:00002CB0
.text$mn:00002CB0                 push    ebp
.text$mn:00002CB1                 mov     ebp, esp
.text$mn:00002CB3                 push    ecx
.text$mn:00002CB4                 mov     [ebp+var_4], ecx
.text$mn:00002CB7                 mov     eax, [ebp+arg_0]
.text$mn:00002CBA                 push    eax
.text$mn:00002CBB                 mov     ecx, [ebp+var_4]
.text$mn:00002CBE                 push    ecx
.text$mn:00002CBF                 call    ??$destroy@UiconLocator@@@?$allocator_traits@V?$allocator@UiconLocator@@@std@@@std@@SAXAAV?$allocator@UiconLocator@@@1@PAUiconLocator@@@Z ; std::allocator_traits<std::allocator<iconLocator>>::destroy<iconLocator>(std::allocator<iconLocator> &,iconLocator *)
.text$mn:00002CC4                 add     esp, 8
.text$mn:00002CC7                 mov     esp, ebp
.text$mn:00002CC9                 pop     ebp
.text$mn:00002CCA                 retn    4
.text$mn:00002CCA ??$destroy@UiconLocator@@@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@@Z endp
.text$mn:00002CCA
.text$mn:00002CCA ; ---------------------------------------------------------------------------
.text$mn:00002CCD                 align 10h
.text$mn:00002CCD _text$mn        ends
.text$mn:00002CCD
.text$mn:00002CD0 ; ===========================================================================
.text$mn:00002CD0
.text$mn:00002CD0 ; Segment type: Pure code
.text$mn:00002CD0 ; Segment permissions: Read/Execute
.text$mn:00002CD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CD0                 assume cs:_text$mn
.text$mn:00002CD0                 ;org 2CD0h
.text$mn:00002CD0 ; COMDAT (pick any)
.text$mn:00002CD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CD0
.text$mn:00002CD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CD0
.text$mn:00002CD0 ; Attributes: bp-based frame
.text$mn:00002CD0
.text$mn:00002CD0 ; public: void __thiscall std::allocator<struct iconLocator>::destroy<struct iconLocator>(struct iconLocator *)
.text$mn:00002CD0                 public ??$destroy@UiconLocator@@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@@Z
.text$mn:00002CD0 ??$destroy@UiconLocator@@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@@Z proc near
.text$mn:00002CD0                                         ; CODE XREF: std::allocator_traits<std::allocator<iconLocator>>::destroy<iconLocator>(std::allocator<iconLocator> &,iconLocator *)+Ap
.text$mn:00002CD0
.text$mn:00002CD0 var_4           = dword ptr -4
.text$mn:00002CD0 arg_0           = dword ptr  8
.text$mn:00002CD0
.text$mn:00002CD0                 push    ebp
.text$mn:00002CD1                 mov     ebp, esp
.text$mn:00002CD3                 push    ecx
.text$mn:00002CD4                 mov     [ebp+var_4], ecx
.text$mn:00002CD7                 push    0
.text$mn:00002CD9                 mov     ecx, [ebp+arg_0]
.text$mn:00002CDC                 call    ??_GiconLocator@@QAEPAXI@Z ; iconLocator::`scalar deleting destructor'(uint)
.text$mn:00002CE1                 mov     esp, ebp
.text$mn:00002CE3                 pop     ebp
.text$mn:00002CE4                 retn    4
.text$mn:00002CE4 ??$destroy@UiconLocator@@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@@Z endp
.text$mn:00002CE4
.text$mn:00002CE4 ; ---------------------------------------------------------------------------
.text$mn:00002CE7                 align 4
.text$mn:00002CE7 _text$mn        ends
.text$mn:00002CE7
.text$mn:00002CE8 ; ===========================================================================
.text$mn:00002CE8
.text$mn:00002CE8 ; Segment type: Pure code
.text$mn:00002CE8 ; Segment permissions: Read/Execute
.text$mn:00002CE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002CE8                 assume cs:_text$mn
.text$mn:00002CE8                 ;org 2CE8h
.text$mn:00002CE8 ; COMDAT (pick any)
.text$mn:00002CE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CE8
.text$mn:00002CE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CE8
.text$mn:00002CE8 ; Attributes: bp-based frame
.text$mn:00002CE8
.text$mn:00002CE8 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct iconLocator>>::destroy<struct iconLocator>(class std::allocator<struct iconLocator> &, struct iconLocator *)
.text$mn:00002CE8                 public ??$destroy@UiconLocator@@@?$allocator_traits@V?$allocator@UiconLocator@@@std@@@std@@SAXAAV?$allocator@UiconLocator@@@1@PAUiconLocator@@@Z
.text$mn:00002CE8 ??$destroy@UiconLocator@@@?$allocator_traits@V?$allocator@UiconLocator@@@std@@@std@@SAXAAV?$allocator@UiconLocator@@@1@PAUiconLocator@@@Z proc near
.text$mn:00002CE8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<iconLocator>>::destroy<iconLocator>(iconLocator *)+Fp
.text$mn:00002CE8
.text$mn:00002CE8 arg_0           = dword ptr  8
.text$mn:00002CE8 arg_4           = dword ptr  0Ch
.text$mn:00002CE8
.text$mn:00002CE8                 push    ebp
.text$mn:00002CE9                 mov     ebp, esp
.text$mn:00002CEB                 mov     eax, [ebp+arg_4]
.text$mn:00002CEE                 push    eax
.text$mn:00002CEF                 mov     ecx, [ebp+arg_0]
.text$mn:00002CF2                 call    ??$destroy@UiconLocator@@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@@Z ; std::allocator<iconLocator>::destroy<iconLocator>(iconLocator *)
.text$mn:00002CF7                 pop     ebp
.text$mn:00002CF8                 retn
.text$mn:00002CF8 ??$destroy@UiconLocator@@@?$allocator_traits@V?$allocator@UiconLocator@@@std@@@std@@SAXAAV?$allocator@UiconLocator@@@1@PAUiconLocator@@@Z endp
.text$mn:00002CF8
.text$mn:00002CF8 ; ---------------------------------------------------------------------------
.text$mn:00002CF9                 align 4
.text$mn:00002CF9 _text$mn        ends
.text$mn:00002CF9
.text$mn:00002CFC ; ===========================================================================
.text$mn:00002CFC
.text$mn:00002CFC ; Segment type: Pure code
.text$mn:00002CFC ; Segment permissions: Read/Execute
.text$mn:00002CFC _text$mn        segment para public 'CODE' use32
.text$mn:00002CFC                 assume cs:_text$mn
.text$mn:00002CFC                 ;org 2CFCh
.text$mn:00002CFC ; COMDAT (pick any)
.text$mn:00002CFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CFC
.text$mn:00002CFC ; =============== S U B R O U T I N E =======================================
.text$mn:00002CFC
.text$mn:00002CFC ; Attributes: bp-based frame
.text$mn:00002CFC
.text$mn:00002CFC ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct tDynamicList>>::destroy<struct tDynamicList>(struct tDynamicList *)
.text$mn:00002CFC                 public ??$destroy@UtDynamicList@@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@@Z
.text$mn:00002CFC ??$destroy@UtDynamicList@@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@@Z proc near
.text$mn:00002CFC                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00002CFC                                         ; __catch$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:00002CFC
.text$mn:00002CFC var_4           = dword ptr -4
.text$mn:00002CFC arg_0           = dword ptr  8
.text$mn:00002CFC
.text$mn:00002CFC                 push    ebp
.text$mn:00002CFD                 mov     ebp, esp
.text$mn:00002CFF                 push    ecx
.text$mn:00002D00                 mov     [ebp+var_4], ecx
.text$mn:00002D03                 mov     eax, [ebp+arg_0]
.text$mn:00002D06                 push    eax
.text$mn:00002D07                 mov     ecx, [ebp+var_4]
.text$mn:00002D0A                 push    ecx
.text$mn:00002D0B                 call    ??$destroy@UtDynamicList@@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@@Z ; std::allocator_traits<std::allocator<tDynamicList>>::destroy<tDynamicList>(std::allocator<tDynamicList> &,tDynamicList *)
.text$mn:00002D10                 add     esp, 8
.text$mn:00002D13                 mov     esp, ebp
.text$mn:00002D15                 pop     ebp
.text$mn:00002D16                 retn    4
.text$mn:00002D16 ??$destroy@UtDynamicList@@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@@Z endp
.text$mn:00002D16
.text$mn:00002D16 ; ---------------------------------------------------------------------------
.text$mn:00002D19                 align 4
.text$mn:00002D19 _text$mn        ends
.text$mn:00002D19
.text$mn:00002D1C ; ===========================================================================
.text$mn:00002D1C
.text$mn:00002D1C ; Segment type: Pure code
.text$mn:00002D1C ; Segment permissions: Read/Execute
.text$mn:00002D1C _text$mn        segment para public 'CODE' use32
.text$mn:00002D1C                 assume cs:_text$mn
.text$mn:00002D1C                 ;org 2D1Ch
.text$mn:00002D1C ; COMDAT (pick any)
.text$mn:00002D1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D1C
.text$mn:00002D1C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D1C
.text$mn:00002D1C ; Attributes: bp-based frame
.text$mn:00002D1C
.text$mn:00002D1C ; public: void __thiscall std::allocator<struct tDynamicList>::destroy<struct tDynamicList>(struct tDynamicList *)
.text$mn:00002D1C                 public ??$destroy@UtDynamicList@@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@@Z
.text$mn:00002D1C ??$destroy@UtDynamicList@@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@@Z proc near
.text$mn:00002D1C                                         ; CODE XREF: std::allocator_traits<std::allocator<tDynamicList>>::destroy<tDynamicList>(std::allocator<tDynamicList> &,tDynamicList *)+Ap
.text$mn:00002D1C
.text$mn:00002D1C var_4           = dword ptr -4
.text$mn:00002D1C
.text$mn:00002D1C                 push    ebp
.text$mn:00002D1D                 mov     ebp, esp
.text$mn:00002D1F                 push    ecx
.text$mn:00002D20                 mov     [ebp+var_4], ecx
.text$mn:00002D23                 mov     esp, ebp
.text$mn:00002D25                 pop     ebp
.text$mn:00002D26                 retn    4
.text$mn:00002D26 ??$destroy@UtDynamicList@@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@@Z endp
.text$mn:00002D26
.text$mn:00002D26 ; ---------------------------------------------------------------------------
.text$mn:00002D29                 align 4
.text$mn:00002D29 _text$mn        ends
.text$mn:00002D29
.text$mn:00002D2C ; ===========================================================================
.text$mn:00002D2C
.text$mn:00002D2C ; Segment type: Pure code
.text$mn:00002D2C ; Segment permissions: Read/Execute
.text$mn:00002D2C _text$mn        segment para public 'CODE' use32
.text$mn:00002D2C                 assume cs:_text$mn
.text$mn:00002D2C                 ;org 2D2Ch
.text$mn:00002D2C ; COMDAT (pick any)
.text$mn:00002D2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D2C
.text$mn:00002D2C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D2C
.text$mn:00002D2C ; Attributes: bp-based frame
.text$mn:00002D2C
.text$mn:00002D2C ; public: static void __cdecl std::allocator_traits<class std::allocator<struct tDynamicList>>::destroy<struct tDynamicList>(class std::allocator<struct tDynamicList> &, struct tDynamicList *)
.text$mn:00002D2C                 public ??$destroy@UtDynamicList@@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@@Z
.text$mn:00002D2C ??$destroy@UtDynamicList@@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@@Z proc near
.text$mn:00002D2C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tDynamicList>>::destroy<tDynamicList>(tDynamicList *)+Fp
.text$mn:00002D2C
.text$mn:00002D2C arg_0           = dword ptr  8
.text$mn:00002D2C arg_4           = dword ptr  0Ch
.text$mn:00002D2C
.text$mn:00002D2C                 push    ebp
.text$mn:00002D2D                 mov     ebp, esp
.text$mn:00002D2F                 mov     eax, [ebp+arg_4]
.text$mn:00002D32                 push    eax
.text$mn:00002D33                 mov     ecx, [ebp+arg_0]
.text$mn:00002D36                 call    ??$destroy@UtDynamicList@@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@@Z ; std::allocator<tDynamicList>::destroy<tDynamicList>(tDynamicList *)
.text$mn:00002D3B                 pop     ebp
.text$mn:00002D3C                 retn
.text$mn:00002D3C ??$destroy@UtDynamicList@@@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAXAAV?$allocator@UtDynamicList@@@1@PAUtDynamicList@@@Z endp
.text$mn:00002D3C
.text$mn:00002D3C ; ---------------------------------------------------------------------------
.text$mn:00002D3D                 align 10h
.text$mn:00002D3D _text$mn        ends
.text$mn:00002D3D
.text$mn:00002D40 ; ===========================================================================
.text$mn:00002D40
.text$mn:00002D40 ; Segment type: Pure code
.text$mn:00002D40 ; Segment permissions: Read/Execute
.text$mn:00002D40 _text$mn        segment para public 'CODE' use32
.text$mn:00002D40                 assume cs:_text$mn
.text$mn:00002D40                 ;org 2D40h
.text$mn:00002D40 ; COMDAT (pick any)
.text$mn:00002D40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D40
.text$mn:00002D40 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D40
.text$mn:00002D40 ; Attributes: bp-based frame
.text$mn:00002D40
.text$mn:00002D40 ; int & __cdecl std::forward<int &>(int &)
.text$mn:00002D40                 public ??$forward@AAH@std@@YAAAHAAH@Z
.text$mn:00002D40 ??$forward@AAH@std@@YAAAHAAH@Z proc near
.text$mn:00002D40                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::construct<int,int &>(int *,int &)+Bp
.text$mn:00002D40                                         ; std::allocator<int>::construct<int,int &>(int *,int &)+4Ap ...
.text$mn:00002D40
.text$mn:00002D40 arg_0           = dword ptr  8
.text$mn:00002D40
.text$mn:00002D40                 push    ebp
.text$mn:00002D41                 mov     ebp, esp
.text$mn:00002D43                 mov     eax, [ebp+arg_0]
.text$mn:00002D46                 pop     ebp
.text$mn:00002D47                 retn
.text$mn:00002D47 ??$forward@AAH@std@@YAAAHAAH@Z endp
.text$mn:00002D47
.text$mn:00002D47 _text$mn        ends
.text$mn:00002D47
.text$mn:00002D48 ; ===========================================================================
.text$mn:00002D48
.text$mn:00002D48 ; Segment type: Pure code
.text$mn:00002D48 ; Segment permissions: Read/Execute
.text$mn:00002D48 _text$mn        segment para public 'CODE' use32
.text$mn:00002D48                 assume cs:_text$mn
.text$mn:00002D48                 ;org 2D48h
.text$mn:00002D48 ; COMDAT (pick any)
.text$mn:00002D48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D48
.text$mn:00002D48 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D48
.text$mn:00002D48 ; Attributes: bp-based frame
.text$mn:00002D48
.text$mn:00002D48 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00002D48                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00002D48 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00002D48                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00002D48                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00002D48
.text$mn:00002D48 arg_0           = dword ptr  8
.text$mn:00002D48
.text$mn:00002D48                 push    ebp
.text$mn:00002D49                 mov     ebp, esp
.text$mn:00002D4B                 mov     eax, [ebp+arg_0]
.text$mn:00002D4E                 pop     ebp
.text$mn:00002D4F                 retn
.text$mn:00002D4F ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00002D4F
.text$mn:00002D4F _text$mn        ends
.text$mn:00002D4F
.text$mn:00002D50 ; ===========================================================================
.text$mn:00002D50
.text$mn:00002D50 ; Segment type: Pure code
.text$mn:00002D50 ; Segment permissions: Read/Execute
.text$mn:00002D50 _text$mn        segment para public 'CODE' use32
.text$mn:00002D50                 assume cs:_text$mn
.text$mn:00002D50                 ;org 2D50h
.text$mn:00002D50 ; COMDAT (pick any)
.text$mn:00002D50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D50
.text$mn:00002D50 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D50
.text$mn:00002D50 ; Attributes: bp-based frame
.text$mn:00002D50
.text$mn:00002D50 ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00002D50                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:00002D50 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:00002D50                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:00002D50                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:00002D50
.text$mn:00002D50 arg_0           = dword ptr  8
.text$mn:00002D50
.text$mn:00002D50                 push    ebp
.text$mn:00002D51                 mov     ebp, esp
.text$mn:00002D53                 mov     eax, [ebp+arg_0]
.text$mn:00002D56                 pop     ebp
.text$mn:00002D57                 retn
.text$mn:00002D57 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:00002D57
.text$mn:00002D57 _text$mn        ends
.text$mn:00002D57
.text$mn:00002D58 ; ===========================================================================
.text$mn:00002D58
.text$mn:00002D58 ; Segment type: Pure code
.text$mn:00002D58 ; Segment permissions: Read/Execute
.text$mn:00002D58 _text$mn        segment para public 'CODE' use32
.text$mn:00002D58                 assume cs:_text$mn
.text$mn:00002D58                 ;org 2D58h
.text$mn:00002D58 ; COMDAT (pick any)
.text$mn:00002D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D58
.text$mn:00002D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D58
.text$mn:00002D58 ; Attributes: bp-based frame
.text$mn:00002D58
.text$mn:00002D58 ; struct tDynamicList & __cdecl std::forward<struct tDynamicList &>(struct tDynamicList &)
.text$mn:00002D58                 public ??$forward@AAUtDynamicList@@@std@@YAAAUtDynamicList@@AAU1@@Z
.text$mn:00002D58 ??$forward@AAUtDynamicList@@@std@@YAAAUtDynamicList@@AAU1@@Z proc near
.text$mn:00002D58                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList &>(tDynamicList *,tDynamicList &)+Bp
.text$mn:00002D58                                         ; std::allocator<tDynamicList>::construct<tDynamicList,tDynamicList &>(tDynamicList *,tDynamicList &)+4Ap ...
.text$mn:00002D58
.text$mn:00002D58 arg_0           = dword ptr  8
.text$mn:00002D58
.text$mn:00002D58                 push    ebp
.text$mn:00002D59                 mov     ebp, esp
.text$mn:00002D5B                 mov     eax, [ebp+arg_0]
.text$mn:00002D5E                 pop     ebp
.text$mn:00002D5F                 retn
.text$mn:00002D5F ??$forward@AAUtDynamicList@@@std@@YAAAUtDynamicList@@AAU1@@Z endp
.text$mn:00002D5F
.text$mn:00002D5F _text$mn        ends
.text$mn:00002D5F
.text$mn:00002D60 ; ===========================================================================
.text$mn:00002D60
.text$mn:00002D60 ; Segment type: Pure code
.text$mn:00002D60 ; Segment permissions: Read/Execute
.text$mn:00002D60 _text$mn        segment para public 'CODE' use32
.text$mn:00002D60                 assume cs:_text$mn
.text$mn:00002D60                 ;org 2D60h
.text$mn:00002D60 ; COMDAT (pick any)
.text$mn:00002D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D60
.text$mn:00002D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D60
.text$mn:00002D60 ; Attributes: bp-based frame
.text$mn:00002D60
.text$mn:00002D60 ; int const & __cdecl std::forward<int const &>(int const &)
.text$mn:00002D60                 public ??$forward@ABH@std@@YAABHABH@Z
.text$mn:00002D60 ??$forward@ABH@std@@YAABHABH@Z proc near
.text$mn:00002D60                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::construct<int,int const &>(int *,int const &)+Bp
.text$mn:00002D60                                         ; std::allocator_traits<std::allocator<int>>::construct<int,int const &>(std::allocator<int> &,int *,int const &)+7p
.text$mn:00002D60
.text$mn:00002D60 arg_0           = dword ptr  8
.text$mn:00002D60
.text$mn:00002D60                 push    ebp
.text$mn:00002D61                 mov     ebp, esp
.text$mn:00002D63                 mov     eax, [ebp+arg_0]
.text$mn:00002D66                 pop     ebp
.text$mn:00002D67                 retn
.text$mn:00002D67 ??$forward@ABH@std@@YAABHABH@Z endp
.text$mn:00002D67
.text$mn:00002D67 _text$mn        ends
.text$mn:00002D67
.text$mn:00002D68 ; ===========================================================================
.text$mn:00002D68
.text$mn:00002D68 ; Segment type: Pure code
.text$mn:00002D68 ; Segment permissions: Read/Execute
.text$mn:00002D68 _text$mn        segment para public 'CODE' use32
.text$mn:00002D68                 assume cs:_text$mn
.text$mn:00002D68                 ;org 2D68h
.text$mn:00002D68 ; COMDAT (pick any)
.text$mn:00002D68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D68
.text$mn:00002D68 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D68
.text$mn:00002D68 ; Attributes: bp-based frame
.text$mn:00002D68
.text$mn:00002D68 ; struct tDynamicList const & __cdecl std::forward<struct tDynamicList const &>(struct tDynamicList const &)
.text$mn:00002D68                 public ??$forward@ABUtDynamicList@@@std@@YAABUtDynamicList@@ABU1@@Z
.text$mn:00002D68 ??$forward@ABUtDynamicList@@@std@@YAABUtDynamicList@@ABU1@@Z proc near
.text$mn:00002D68                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList const &>(tDynamicList *,tDynamicList const &)+Bp
.text$mn:00002D68                                         ; std::allocator_traits<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList const &>(std::allocator<tDynamicList> &,tDynamicList *,tDynamicList const &)+7p
.text$mn:00002D68
.text$mn:00002D68 arg_0           = dword ptr  8
.text$mn:00002D68
.text$mn:00002D68                 push    ebp
.text$mn:00002D69                 mov     ebp, esp
.text$mn:00002D6B                 mov     eax, [ebp+arg_0]
.text$mn:00002D6E                 pop     ebp
.text$mn:00002D6F                 retn
.text$mn:00002D6F ??$forward@ABUtDynamicList@@@std@@YAABUtDynamicList@@ABU1@@Z endp
.text$mn:00002D6F
.text$mn:00002D6F _text$mn        ends
.text$mn:00002D6F
.text$mn:00002D70 ; ===========================================================================
.text$mn:00002D70
.text$mn:00002D70 ; Segment type: Pure code
.text$mn:00002D70 ; Segment permissions: Read/Execute
.text$mn:00002D70 _text$mn        segment para public 'CODE' use32
.text$mn:00002D70                 assume cs:_text$mn
.text$mn:00002D70                 ;org 2D70h
.text$mn:00002D70 ; COMDAT (pick any)
.text$mn:00002D70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D70
.text$mn:00002D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D70
.text$mn:00002D70 ; Attributes: bp-based frame
.text$mn:00002D70
.text$mn:00002D70 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00002D70                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00002D70 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00002D70                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00002D70
.text$mn:00002D70 arg_0           = dword ptr  8
.text$mn:00002D70
.text$mn:00002D70                 push    ebp
.text$mn:00002D71                 mov     ebp, esp
.text$mn:00002D73                 mov     eax, [ebp+arg_0]
.text$mn:00002D76                 pop     ebp
.text$mn:00002D77                 retn
.text$mn:00002D77 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00002D77
.text$mn:00002D77 _text$mn        ends
.text$mn:00002D77
.text$mn:00002D78 ; ===========================================================================
.text$mn:00002D78
.text$mn:00002D78 ; Segment type: Pure code
.text$mn:00002D78 ; Segment permissions: Read/Execute
.text$mn:00002D78 _text$mn        segment para public 'CODE' use32
.text$mn:00002D78                 assume cs:_text$mn
.text$mn:00002D78                 ;org 2D78h
.text$mn:00002D78 ; COMDAT (pick any)
.text$mn:00002D78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D78
.text$mn:00002D78 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D78
.text$mn:00002D78 ; Attributes: bp-based frame
.text$mn:00002D78
.text$mn:00002D78 ; struct iconLocator && __cdecl std::forward<struct iconLocator>(struct iconLocator &)
.text$mn:00002D78                 public ??$forward@UiconLocator@@@std@@YA$$QAUiconLocator@@AAU1@@Z
.text$mn:00002D78 ??$forward@UiconLocator@@@std@@YA$$QAUiconLocator@@AAU1@@Z proc near
.text$mn:00002D78                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<iconLocator>>::construct<iconLocator,iconLocator>(iconLocator *,iconLocator &&)+Bp
.text$mn:00002D78                                         ; std::allocator<iconLocator>::construct<iconLocator,iconLocator>(iconLocator *,iconLocator &&)+4Ap ...
.text$mn:00002D78
.text$mn:00002D78 arg_0           = dword ptr  8
.text$mn:00002D78
.text$mn:00002D78                 push    ebp
.text$mn:00002D79                 mov     ebp, esp
.text$mn:00002D7B                 mov     eax, [ebp+arg_0]
.text$mn:00002D7E                 pop     ebp
.text$mn:00002D7F                 retn
.text$mn:00002D7F ??$forward@UiconLocator@@@std@@YA$$QAUiconLocator@@AAU1@@Z endp
.text$mn:00002D7F
.text$mn:00002D7F _text$mn        ends
.text$mn:00002D7F
.text$mn:00002D80 ; ===========================================================================
.text$mn:00002D80
.text$mn:00002D80 ; Segment type: Pure code
.text$mn:00002D80 ; Segment permissions: Read/Execute
.text$mn:00002D80 _text$mn        segment para public 'CODE' use32
.text$mn:00002D80                 assume cs:_text$mn
.text$mn:00002D80                 ;org 2D80h
.text$mn:00002D80 ; COMDAT (pick any)
.text$mn:00002D80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D80
.text$mn:00002D80 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D80
.text$mn:00002D80 ; Attributes: bp-based frame
.text$mn:00002D80
.text$mn:00002D80 ; struct tDynamicList && __cdecl std::forward<struct tDynamicList>(struct tDynamicList &)
.text$mn:00002D80                 public ??$forward@UtDynamicList@@@std@@YA$$QAUtDynamicList@@AAU1@@Z
.text$mn:00002D80 ??$forward@UtDynamicList@@@std@@YA$$QAUtDynamicList@@AAU1@@Z proc near
.text$mn:00002D80                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList>(tDynamicList *,tDynamicList &&)+Bp
.text$mn:00002D80                                         ; std::allocator<tDynamicList>::construct<tDynamicList,tDynamicList>(tDynamicList *,tDynamicList &&)+4Ap ...
.text$mn:00002D80
.text$mn:00002D80 arg_0           = dword ptr  8
.text$mn:00002D80
.text$mn:00002D80                 push    ebp
.text$mn:00002D81                 mov     ebp, esp
.text$mn:00002D83                 mov     eax, [ebp+arg_0]
.text$mn:00002D86                 pop     ebp
.text$mn:00002D87                 retn
.text$mn:00002D87 ??$forward@UtDynamicList@@@std@@YA$$QAUtDynamicList@@AAU1@@Z endp
.text$mn:00002D87
.text$mn:00002D87 _text$mn        ends
.text$mn:00002D87
.text$mn:00002D88 ; ===========================================================================
.text$mn:00002D88
.text$mn:00002D88 ; Segment type: Pure code
.text$mn:00002D88 ; Segment permissions: Read/Execute
.text$mn:00002D88 _text$mn        segment para public 'CODE' use32
.text$mn:00002D88                 assume cs:_text$mn
.text$mn:00002D88                 ;org 2D88h
.text$mn:00002D88 ; COMDAT (pick any)
.text$mn:00002D88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D88
.text$mn:00002D88 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D88
.text$mn:00002D88 ; Attributes: bp-based frame
.text$mn:00002D88
.text$mn:00002D88 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00002D88                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00002D88 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00002D88                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+2Dp
.text$mn:00002D88
.text$mn:00002D88 var_10          = dword ptr -10h
.text$mn:00002D88 var_C           = dword ptr -0Ch
.text$mn:00002D88 var_4           = dword ptr -4
.text$mn:00002D88 arg_0           = dword ptr  8
.text$mn:00002D88
.text$mn:00002D88                 push    ebp
.text$mn:00002D89                 mov     ebp, esp
.text$mn:00002D8B                 push    0FFFFFFFFh
.text$mn:00002D8D                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00002D92                 mov     eax, large fs:0
.text$mn:00002D98                 push    eax
.text$mn:00002D99                 push    ecx
.text$mn:00002D9A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002D9F                 xor     eax, ebp
.text$mn:00002DA1                 push    eax
.text$mn:00002DA2                 lea     eax, [ebp+var_C]
.text$mn:00002DA5                 mov     large fs:0, eax
.text$mn:00002DAB                 mov     [ebp+var_10], ecx
.text$mn:00002DAE                 mov     eax, [ebp+arg_0]
.text$mn:00002DB1                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002DB2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002DB5                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:00002DBA                 mov     [ebp+var_4], 0
.text$mn:00002DC1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002DC8                 mov     eax, [ebp+var_10]
.text$mn:00002DCB                 mov     ecx, [ebp+var_C]
.text$mn:00002DCE                 mov     large fs:0, ecx
.text$mn:00002DD5                 pop     ecx
.text$mn:00002DD6                 mov     esp, ebp
.text$mn:00002DD8                 pop     ebp
.text$mn:00002DD9                 retn    4
.text$mn:00002DD9 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:00002DD9
.text$mn:00002DD9 _text$mn        ends
.text$mn:00002DD9
.text$x:00002DDC ; ===========================================================================
.text$x:00002DDC
.text$x:00002DDC ; Segment type: Pure code
.text$x:00002DDC ; Segment permissions: Read/Execute
.text$x:00002DDC _text$x         segment para public 'CODE' use32
.text$x:00002DDC                 assume cs:_text$x
.text$x:00002DDC                 ;org 2DDCh
.text$x:00002DDC ; COMDAT (pick associative to section at 2D88)
.text$x:00002DDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002DDC
.text$x:00002DDC ; =============== S U B R O U T I N E =======================================
.text$x:00002DDC
.text$x:00002DDC
.text$x:00002DDC __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:00002DDC                                         ; DATA XREF: .xdata$x:0000848Co
.text$x:00002DDC                 mov     ecx, [ebp-10h]  ; this
.text$x:00002DDF                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00002DDF __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:00002DDF
.text$x:00002DE4
.text$x:00002DE4 ; =============== S U B R O U T I N E =======================================
.text$x:00002DE4
.text$x:00002DE4
.text$x:00002DE4 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00002DE4                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12> const &)+5o
.text$x:00002DE4
.text$x:00002DE4 arg_4           = dword ptr  8
.text$x:00002DE4
.text$x:00002DE4                 mov     edx, [esp+arg_4]
.text$x:00002DE8                 lea     eax, [edx+0Ch]
.text$x:00002DEB                 mov     ecx, [edx-8]
.text$x:00002DEE                 xor     ecx, eax
.text$x:00002DF0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DF5                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:00002DFA                 jmp     ___CxxFrameHandler3
.text$x:00002DFA __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:00002DFA
.text$x:00002DFA ; ---------------------------------------------------------------------------
.text$x:00002DFF                 align 10h
.text$x:00002DFF _text$x         ends
.text$x:00002DFF
.text$mn:00002E00 ; ===========================================================================
.text$mn:00002E00
.text$mn:00002E00 ; Segment type: Pure code
.text$mn:00002E00 ; Segment permissions: Read/Execute
.text$mn:00002E00 _text$mn        segment para public 'CODE' use32
.text$mn:00002E00                 assume cs:_text$mn
.text$mn:00002E00                 ;org 2E00h
.text$mn:00002E00 ; COMDAT (pick any)
.text$mn:00002E00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E00
.text$mn:00002E00 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E00
.text$mn:00002E00 ; Attributes: bp-based frame
.text$mn:00002E00
.text$mn:00002E00 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>(void)
.text$mn:00002E00                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00002E00 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00002E00                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+29p
.text$mn:00002E00
.text$mn:00002E00 var_10          = dword ptr -10h
.text$mn:00002E00 var_C           = dword ptr -0Ch
.text$mn:00002E00 var_4           = dword ptr -4
.text$mn:00002E00
.text$mn:00002E00                 push    ebp
.text$mn:00002E01                 mov     ebp, esp
.text$mn:00002E03                 push    0FFFFFFFFh
.text$mn:00002E05                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00002E0A                 mov     eax, large fs:0
.text$mn:00002E10                 push    eax
.text$mn:00002E11                 push    ecx
.text$mn:00002E12                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002E17                 xor     eax, ebp
.text$mn:00002E19                 push    eax
.text$mn:00002E1A                 lea     eax, [ebp+var_C]
.text$mn:00002E1D                 mov     large fs:0, eax
.text$mn:00002E23                 mov     [ebp+var_10], ecx
.text$mn:00002E26                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002E29                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00002E2E                 mov     [ebp+var_4], 0
.text$mn:00002E35                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E3C                 mov     eax, [ebp+var_10]
.text$mn:00002E3F                 mov     ecx, [ebp+var_C]
.text$mn:00002E42                 mov     large fs:0, ecx
.text$mn:00002E49                 pop     ecx
.text$mn:00002E4A                 mov     esp, ebp
.text$mn:00002E4C                 pop     ebp
.text$mn:00002E4D                 retn
.text$mn:00002E4D ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00002E4D
.text$mn:00002E4D ; ---------------------------------------------------------------------------
.text$mn:00002E4E                 align 10h
.text$mn:00002E4E _text$mn        ends
.text$mn:00002E4E
.text$x:00002E50 ; ===========================================================================
.text$x:00002E50
.text$x:00002E50 ; Segment type: Pure code
.text$x:00002E50 ; Segment permissions: Read/Execute
.text$x:00002E50 _text$x         segment para public 'CODE' use32
.text$x:00002E50                 assume cs:_text$x
.text$x:00002E50                 ;org 2E50h
.text$x:00002E50 ; COMDAT (pick associative to section at 2E00)
.text$x:00002E50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002E50
.text$x:00002E50 ; =============== S U B R O U T I N E =======================================
.text$x:00002E50
.text$x:00002E50
.text$x:00002E50 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00002E50                                         ; DATA XREF: .xdata$x:00008434o
.text$x:00002E50                 mov     ecx, [ebp-10h]  ; this
.text$x:00002E53                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00002E53 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00002E53
.text$x:00002E58
.text$x:00002E58 ; =============== S U B R O U T I N E =======================================
.text$x:00002E58
.text$x:00002E58
.text$x:00002E58 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00002E58                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)+5o
.text$x:00002E58
.text$x:00002E58 arg_4           = dword ptr  8
.text$x:00002E58
.text$x:00002E58                 mov     edx, [esp+arg_4]
.text$x:00002E5C                 lea     eax, [edx+0Ch]
.text$x:00002E5F                 mov     ecx, [edx-8]
.text$x:00002E62                 xor     ecx, eax
.text$x:00002E64                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002E69                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$x:00002E6E                 jmp     ___CxxFrameHandler3
.text$x:00002E6E __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00002E6E
.text$x:00002E6E ; ---------------------------------------------------------------------------
.text$x:00002E73                 align 4
.text$x:00002E73 _text$x         ends
.text$x:00002E73
.text$mn:00002E74 ; ===========================================================================
.text$mn:00002E74
.text$mn:00002E74 ; Segment type: Pure code
.text$mn:00002E74 ; Segment permissions: Read/Execute
.text$mn:00002E74 _text$mn        segment para public 'CODE' use32
.text$mn:00002E74                 assume cs:_text$mn
.text$mn:00002E74                 ;org 2E74h
.text$mn:00002E74 ; COMDAT (pick any)
.text$mn:00002E74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E74
.text$mn:00002E74 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E74
.text$mn:00002E74 ; Attributes: bp-based frame
.text$mn:00002E74
.text$mn:00002E74 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00002E74                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002E74 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00002E74                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00002E74
.text$mn:00002E74 var_10          = dword ptr -10h
.text$mn:00002E74 var_C           = dword ptr -0Ch
.text$mn:00002E74 var_4           = dword ptr -4
.text$mn:00002E74
.text$mn:00002E74                 push    ebp
.text$mn:00002E75                 mov     ebp, esp
.text$mn:00002E77                 push    0FFFFFFFFh
.text$mn:00002E79                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002E7E                 mov     eax, large fs:0
.text$mn:00002E84                 push    eax
.text$mn:00002E85                 push    ecx
.text$mn:00002E86                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002E8B                 xor     eax, ebp
.text$mn:00002E8D                 push    eax
.text$mn:00002E8E                 lea     eax, [ebp+var_C]
.text$mn:00002E91                 mov     large fs:0, eax
.text$mn:00002E97                 mov     [ebp+var_10], ecx
.text$mn:00002E9A                 mov     ecx, [ebp+var_10]
.text$mn:00002E9D                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00002EA2                 mov     [ebp+var_4], 0
.text$mn:00002EA9                 mov     ecx, [ebp+var_10]
.text$mn:00002EAC                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00002EB1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002EB8                 mov     eax, [ebp+var_10]
.text$mn:00002EBB                 mov     ecx, [ebp+var_C]
.text$mn:00002EBE                 mov     large fs:0, ecx
.text$mn:00002EC5                 pop     ecx
.text$mn:00002EC6                 mov     esp, ebp
.text$mn:00002EC8                 pop     ebp
.text$mn:00002EC9                 retn    4
.text$mn:00002EC9 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00002EC9
.text$mn:00002EC9 _text$mn        ends
.text$mn:00002EC9
.text$x:00002ECC ; ===========================================================================
.text$x:00002ECC
.text$x:00002ECC ; Segment type: Pure code
.text$x:00002ECC ; Segment permissions: Read/Execute
.text$x:00002ECC _text$x         segment para public 'CODE' use32
.text$x:00002ECC                 assume cs:_text$x
.text$x:00002ECC                 ;org 2ECCh
.text$x:00002ECC ; COMDAT (pick associative to section at 2E74)
.text$x:00002ECC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002ECC
.text$x:00002ECC ; =============== S U B R O U T I N E =======================================
.text$x:00002ECC
.text$x:00002ECC
.text$x:00002ECC __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00002ECC                                         ; DATA XREF: .xdata$x:00007B74o
.text$x:00002ECC                 mov     ecx, [ebp-10h]
.text$x:00002ECF                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00002ECF __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00002ECF
.text$x:00002ED4
.text$x:00002ED4 ; =============== S U B R O U T I N E =======================================
.text$x:00002ED4
.text$x:00002ED4
.text$x:00002ED4 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00002ED4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00002ED4
.text$x:00002ED4 arg_4           = dword ptr  8
.text$x:00002ED4
.text$x:00002ED4                 mov     edx, [esp+arg_4]
.text$x:00002ED8                 lea     eax, [edx+0Ch]
.text$x:00002EDB                 mov     ecx, [edx-8]
.text$x:00002EDE                 xor     ecx, eax
.text$x:00002EE0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002EE5                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00002EEA                 jmp     ___CxxFrameHandler3
.text$x:00002EEA __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00002EEA
.text$x:00002EEA ; ---------------------------------------------------------------------------
.text$x:00002EEF                 align 10h
.text$x:00002EEF _text$x         ends
.text$x:00002EEF
.text$mn:00002EF0 ; ===========================================================================
.text$mn:00002EF0
.text$mn:00002EF0 ; Segment type: Pure code
.text$mn:00002EF0 ; Segment permissions: Read/Execute
.text$mn:00002EF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002EF0                 assume cs:_text$mn
.text$mn:00002EF0                 ;org 2EF0h
.text$mn:00002EF0 ; COMDAT (pick any)
.text$mn:00002EF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002EF0
.text$mn:00002EF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EF0
.text$mn:00002EF0 ; Attributes: bp-based frame
.text$mn:00002EF0
.text$mn:00002EF0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:00002EF0                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00002EF0 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00002EF0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+43p
.text$mn:00002EF0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+34p ...
.text$mn:00002EF0
.text$mn:00002EF0 var_10          = dword ptr -10h
.text$mn:00002EF0 var_C           = dword ptr -0Ch
.text$mn:00002EF0 var_4           = dword ptr -4
.text$mn:00002EF0
.text$mn:00002EF0                 push    ebp
.text$mn:00002EF1                 mov     ebp, esp
.text$mn:00002EF3                 push    0FFFFFFFFh
.text$mn:00002EF5                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00002EFA                 mov     eax, large fs:0
.text$mn:00002F00                 push    eax
.text$mn:00002F01                 push    ecx
.text$mn:00002F02                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002F07                 xor     eax, ebp
.text$mn:00002F09                 push    eax
.text$mn:00002F0A                 lea     eax, [ebp+var_C]
.text$mn:00002F0D                 mov     large fs:0, eax
.text$mn:00002F13                 mov     [ebp+var_10], ecx
.text$mn:00002F16                 mov     ecx, [ebp+var_10]
.text$mn:00002F19                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00002F1E                 mov     [ebp+var_4], 0
.text$mn:00002F25                 mov     ecx, [ebp+var_10]
.text$mn:00002F28                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00002F2D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002F34                 mov     eax, [ebp+var_10]
.text$mn:00002F37                 mov     ecx, [ebp+var_C]
.text$mn:00002F3A                 mov     large fs:0, ecx
.text$mn:00002F41                 pop     ecx
.text$mn:00002F42                 mov     esp, ebp
.text$mn:00002F44                 pop     ebp
.text$mn:00002F45                 retn    4
.text$mn:00002F45 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00002F45
.text$mn:00002F45 _text$mn        ends
.text$mn:00002F45
.text$x:00002F48 ; ===========================================================================
.text$x:00002F48
.text$x:00002F48 ; Segment type: Pure code
.text$x:00002F48 ; Segment permissions: Read/Execute
.text$x:00002F48 _text$x         segment para public 'CODE' use32
.text$x:00002F48                 assume cs:_text$x
.text$x:00002F48                 ;org 2F48h
.text$x:00002F48 ; COMDAT (pick associative to section at 2EF0)
.text$x:00002F48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002F48
.text$x:00002F48 ; =============== S U B R O U T I N E =======================================
.text$x:00002F48
.text$x:00002F48
.text$x:00002F48 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:00002F48                                         ; DATA XREF: .xdata$x:00007F18o
.text$x:00002F48                 mov     ecx, [ebp-10h]
.text$x:00002F4B                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00002F4B __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:00002F4B
.text$x:00002F50
.text$x:00002F50 ; =============== S U B R O U T I N E =======================================
.text$x:00002F50
.text$x:00002F50
.text$x:00002F50 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:00002F50                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:00002F50
.text$x:00002F50 arg_4           = dword ptr  8
.text$x:00002F50
.text$x:00002F50                 mov     edx, [esp+arg_4]
.text$x:00002F54                 lea     eax, [edx+0Ch]
.text$x:00002F57                 mov     ecx, [edx-8]
.text$x:00002F5A                 xor     ecx, eax
.text$x:00002F5C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F61                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:00002F66                 jmp     ___CxxFrameHandler3
.text$x:00002F66 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:00002F66
.text$x:00002F66 ; ---------------------------------------------------------------------------
.text$x:00002F6B                 align 4
.text$x:00002F6B _text$x         ends
.text$x:00002F6B
.text$mn:00002F6C ; ===========================================================================
.text$mn:00002F6C
.text$mn:00002F6C ; Segment type: Pure code
.text$mn:00002F6C ; Segment permissions: Read/Execute
.text$mn:00002F6C _text$mn        segment para public 'CODE' use32
.text$mn:00002F6C                 assume cs:_text$mn
.text$mn:00002F6C                 ;org 2F6Ch
.text$mn:00002F6C ; COMDAT (pick any)
.text$mn:00002F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F6C
.text$mn:00002F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00002F6C
.text$mn:00002F6C ; Attributes: bp-based frame
.text$mn:00002F6C
.text$mn:00002F6C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00002F6C                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002F6C ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00002F6C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00002F6C
.text$mn:00002F6C var_10          = dword ptr -10h
.text$mn:00002F6C var_C           = dword ptr -0Ch
.text$mn:00002F6C var_4           = dword ptr -4
.text$mn:00002F6C
.text$mn:00002F6C                 push    ebp
.text$mn:00002F6D                 mov     ebp, esp
.text$mn:00002F6F                 push    0FFFFFFFFh
.text$mn:00002F71                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002F76                 mov     eax, large fs:0
.text$mn:00002F7C                 push    eax
.text$mn:00002F7D                 push    ecx
.text$mn:00002F7E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002F83                 xor     eax, ebp
.text$mn:00002F85                 push    eax
.text$mn:00002F86                 lea     eax, [ebp+var_C]
.text$mn:00002F89                 mov     large fs:0, eax
.text$mn:00002F8F                 mov     [ebp+var_10], ecx
.text$mn:00002F92                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002F95                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00002F9A                 mov     [ebp+var_4], 0
.text$mn:00002FA1                 mov     eax, [ebp+var_10]
.text$mn:00002FA4                 mov     dword ptr [eax+14h], 0
.text$mn:00002FAB                 mov     ecx, [ebp+var_10]
.text$mn:00002FAE                 mov     dword ptr [ecx+18h], 0
.text$mn:00002FB5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002FBC                 mov     eax, [ebp+var_10]
.text$mn:00002FBF                 mov     ecx, [ebp+var_C]
.text$mn:00002FC2                 mov     large fs:0, ecx
.text$mn:00002FC9                 pop     ecx
.text$mn:00002FCA                 mov     esp, ebp
.text$mn:00002FCC                 pop     ebp
.text$mn:00002FCD                 retn
.text$mn:00002FCD ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00002FCD
.text$mn:00002FCD ; ---------------------------------------------------------------------------
.text$mn:00002FCE                 align 10h
.text$mn:00002FCE _text$mn        ends
.text$mn:00002FCE
.text$x:00002FD0 ; ===========================================================================
.text$x:00002FD0
.text$x:00002FD0 ; Segment type: Pure code
.text$x:00002FD0 ; Segment permissions: Read/Execute
.text$x:00002FD0 _text$x         segment para public 'CODE' use32
.text$x:00002FD0                 assume cs:_text$x
.text$x:00002FD0                 ;org 2FD0h
.text$x:00002FD0 ; COMDAT (pick associative to section at 2F6C)
.text$x:00002FD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002FD0
.text$x:00002FD0 ; =============== S U B R O U T I N E =======================================
.text$x:00002FD0
.text$x:00002FD0
.text$x:00002FD0 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00002FD0                                         ; DATA XREF: .xdata$x:00007B1Co
.text$x:00002FD0                 mov     ecx, [ebp-10h]  ; this
.text$x:00002FD3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002FD3 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00002FD3
.text$x:00002FD8
.text$x:00002FD8 ; =============== S U B R O U T I N E =======================================
.text$x:00002FD8
.text$x:00002FD8
.text$x:00002FD8 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00002FD8                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00002FD8
.text$x:00002FD8 arg_4           = dword ptr  8
.text$x:00002FD8
.text$x:00002FD8                 mov     edx, [esp+arg_4]
.text$x:00002FDC                 lea     eax, [edx+0Ch]
.text$x:00002FDF                 mov     ecx, [edx-8]
.text$x:00002FE2                 xor     ecx, eax
.text$x:00002FE4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002FE9                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00002FEE                 jmp     ___CxxFrameHandler3
.text$x:00002FEE __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00002FEE
.text$x:00002FEE ; ---------------------------------------------------------------------------
.text$x:00002FF3                 align 4
.text$x:00002FF3 _text$x         ends
.text$x:00002FF3
.text$mn:00002FF4 ; ===========================================================================
.text$mn:00002FF4
.text$mn:00002FF4 ; Segment type: Pure code
.text$mn:00002FF4 ; Segment permissions: Read/Execute
.text$mn:00002FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00002FF4                 assume cs:_text$mn
.text$mn:00002FF4                 ;org 2FF4h
.text$mn:00002FF4 ; COMDAT (pick any)
.text$mn:00002FF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FF4
.text$mn:00002FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FF4
.text$mn:00002FF4 ; Attributes: bp-based frame
.text$mn:00002FF4
.text$mn:00002FF4 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00002FF4                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00002FF4 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00002FF4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:00002FF4
.text$mn:00002FF4 var_10          = dword ptr -10h
.text$mn:00002FF4 var_C           = dword ptr -0Ch
.text$mn:00002FF4 var_4           = dword ptr -4
.text$mn:00002FF4
.text$mn:00002FF4                 push    ebp
.text$mn:00002FF5                 mov     ebp, esp
.text$mn:00002FF7                 push    0FFFFFFFFh
.text$mn:00002FF9                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00002FFE                 mov     eax, large fs:0
.text$mn:00003004                 push    eax
.text$mn:00003005                 push    ecx
.text$mn:00003006                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000300B                 xor     eax, ebp
.text$mn:0000300D                 push    eax
.text$mn:0000300E                 lea     eax, [ebp+var_C]
.text$mn:00003011                 mov     large fs:0, eax
.text$mn:00003017                 mov     [ebp+var_10], ecx
.text$mn:0000301A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000301D                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00003022                 mov     [ebp+var_4], 0
.text$mn:00003029                 mov     eax, [ebp+var_10]
.text$mn:0000302C                 mov     dword ptr [eax+14h], 0
.text$mn:00003033                 mov     ecx, [ebp+var_10]
.text$mn:00003036                 mov     dword ptr [ecx+18h], 0
.text$mn:0000303D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003044                 mov     eax, [ebp+var_10]
.text$mn:00003047                 mov     ecx, [ebp+var_C]
.text$mn:0000304A                 mov     large fs:0, ecx
.text$mn:00003051                 pop     ecx
.text$mn:00003052                 mov     esp, ebp
.text$mn:00003054                 pop     ebp
.text$mn:00003055                 retn
.text$mn:00003055 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00003055
.text$mn:00003055 ; ---------------------------------------------------------------------------
.text$mn:00003056                 align 4
.text$mn:00003056 _text$mn        ends
.text$mn:00003056
.text$x:00003058 ; ===========================================================================
.text$x:00003058
.text$x:00003058 ; Segment type: Pure code
.text$x:00003058 ; Segment permissions: Read/Execute
.text$x:00003058 _text$x         segment para public 'CODE' use32
.text$x:00003058                 assume cs:_text$x
.text$x:00003058                 ;org 3058h
.text$x:00003058 ; COMDAT (pick associative to section at 2FF4)
.text$x:00003058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003058
.text$x:00003058 ; =============== S U B R O U T I N E =======================================
.text$x:00003058
.text$x:00003058
.text$x:00003058 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00003058                                         ; DATA XREF: .xdata$x:00007EC0o
.text$x:00003058                 mov     ecx, [ebp-10h]  ; this
.text$x:0000305B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000305B __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:0000305B
.text$x:00003060
.text$x:00003060 ; =============== S U B R O U T I N E =======================================
.text$x:00003060
.text$x:00003060
.text$x:00003060 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00003060                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00003060
.text$x:00003060 arg_4           = dword ptr  8
.text$x:00003060
.text$x:00003060                 mov     edx, [esp+arg_4]
.text$x:00003064                 lea     eax, [edx+0Ch]
.text$x:00003067                 mov     ecx, [edx-8]
.text$x:0000306A                 xor     ecx, eax
.text$x:0000306C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003071                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00003076                 jmp     ___CxxFrameHandler3
.text$x:00003076 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00003076
.text$x:00003076 ; ---------------------------------------------------------------------------
.text$x:0000307B                 align 4
.text$x:0000307B _text$x         ends
.text$x:0000307B
.text$mn:0000307C ; ===========================================================================
.text$mn:0000307C
.text$mn:0000307C ; Segment type: Pure code
.text$mn:0000307C ; Segment permissions: Read/Execute
.text$mn:0000307C _text$mn        segment para public 'CODE' use32
.text$mn:0000307C                 assume cs:_text$mn
.text$mn:0000307C                 ;org 307Ch
.text$mn:0000307C ; COMDAT (pick any)
.text$mn:0000307C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000307C
.text$mn:0000307C ; =============== S U B R O U T I N E =======================================
.text$mn:0000307C
.text$mn:0000307C ; Attributes: bp-based frame
.text$mn:0000307C
.text$mn:0000307C ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(struct std::_Iterator_base12 *)
.text$mn:0000307C                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000307C ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000307C                                         ; CODE XREF: ReBar::releaseID(int)+B6p
.text$mn:0000307C                                         ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+2Dp ...
.text$mn:0000307C
.text$mn:0000307C var_10          = dword ptr -10h
.text$mn:0000307C var_C           = dword ptr -0Ch
.text$mn:0000307C var_4           = dword ptr -4
.text$mn:0000307C arg_0           = dword ptr  8
.text$mn:0000307C
.text$mn:0000307C                 push    ebp
.text$mn:0000307D                 mov     ebp, esp
.text$mn:0000307F                 push    0FFFFFFFFh
.text$mn:00003081                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00003086                 mov     eax, large fs:0
.text$mn:0000308C                 push    eax
.text$mn:0000308D                 push    ecx
.text$mn:0000308E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003093                 xor     eax, ebp
.text$mn:00003095                 push    eax
.text$mn:00003096                 lea     eax, [ebp+var_C]
.text$mn:00003099                 mov     large fs:0, eax
.text$mn:0000309F                 mov     [ebp+var_10], ecx
.text$mn:000030A2                 mov     eax, [ebp+arg_0]
.text$mn:000030A5                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000030A6                 mov     ecx, [ebp+var_10]
.text$mn:000030A9                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12> const &)
.text$mn:000030AE                 mov     [ebp+var_4], 0
.text$mn:000030B5                 mov     ecx, [ebp+var_10]
.text$mn:000030B8                 mov     edx, [ebp+arg_0]
.text$mn:000030BB                 mov     eax, [edx+8]
.text$mn:000030BE                 mov     [ecx+8], eax
.text$mn:000030C1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000030C8                 mov     eax, [ebp+var_10]
.text$mn:000030CB                 mov     ecx, [ebp+var_C]
.text$mn:000030CE                 mov     large fs:0, ecx
.text$mn:000030D5                 pop     ecx
.text$mn:000030D6                 mov     esp, ebp
.text$mn:000030D8                 pop     ebp
.text$mn:000030D9                 retn    4
.text$mn:000030D9 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:000030D9
.text$mn:000030D9 _text$mn        ends
.text$mn:000030D9
.text$x:000030DC ; ===========================================================================
.text$x:000030DC
.text$x:000030DC ; Segment type: Pure code
.text$x:000030DC ; Segment permissions: Read/Execute
.text$x:000030DC _text$x         segment para public 'CODE' use32
.text$x:000030DC                 assume cs:_text$x
.text$x:000030DC                 ;org 30DCh
.text$x:000030DC ; COMDAT (pick associative to section at 307C)
.text$x:000030DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000030DC
.text$x:000030DC ; =============== S U B R O U T I N E =======================================
.text$x:000030DC
.text$x:000030DC
.text$x:000030DC __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:000030DC                                         ; DATA XREF: .xdata$x:00008510o
.text$x:000030DC                 mov     ecx, [ebp-10h]
.text$x:000030DF                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$x:000030DF __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:000030DF
.text$x:000030E4
.text$x:000030E4 ; =============== S U B R O U T I N E =======================================
.text$x:000030E4
.text$x:000030E4
.text$x:000030E4 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:000030E4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+5o
.text$x:000030E4
.text$x:000030E4 arg_4           = dword ptr  8
.text$x:000030E4
.text$x:000030E4                 mov     edx, [esp+arg_4]
.text$x:000030E8                 lea     eax, [edx+0Ch]
.text$x:000030EB                 mov     ecx, [edx-8]
.text$x:000030EE                 xor     ecx, eax
.text$x:000030F0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000030F5                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:000030FA                 jmp     ___CxxFrameHandler3
.text$x:000030FA __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:000030FA
.text$x:000030FA ; ---------------------------------------------------------------------------
.text$x:000030FF                 align 10h
.text$x:000030FF _text$x         ends
.text$x:000030FF
.text$mn:00003100 ; ===========================================================================
.text$mn:00003100
.text$mn:00003100 ; Segment type: Pure code
.text$mn:00003100 ; Segment permissions: Read/Execute
.text$mn:00003100 _text$mn        segment para public 'CODE' use32
.text$mn:00003100                 assume cs:_text$mn
.text$mn:00003100                 ;org 3100h
.text$mn:00003100 ; COMDAT (pick any)
.text$mn:00003100                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003100
.text$mn:00003100 ; =============== S U B R O U T I N E =======================================
.text$mn:00003100
.text$mn:00003100 ; Attributes: bp-based frame
.text$mn:00003100
.text$mn:00003100 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int, struct std::_Container_base12 *)
.text$mn:00003100                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$mn:00003100 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z proc near
.text$mn:00003100                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+31p
.text$mn:00003100
.text$mn:00003100 var_10          = dword ptr -10h
.text$mn:00003100 var_C           = dword ptr -0Ch
.text$mn:00003100 var_4           = dword ptr -4
.text$mn:00003100 arg_0           = dword ptr  8
.text$mn:00003100 arg_4           = dword ptr  0Ch
.text$mn:00003100
.text$mn:00003100                 push    ebp
.text$mn:00003101                 mov     ebp, esp
.text$mn:00003103                 push    0FFFFFFFFh
.text$mn:00003105                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$mn:0000310A                 mov     eax, large fs:0
.text$mn:00003110                 push    eax
.text$mn:00003111                 push    ecx
.text$mn:00003112                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003117                 xor     eax, ebp
.text$mn:00003119                 push    eax
.text$mn:0000311A                 lea     eax, [ebp+var_C]
.text$mn:0000311D                 mov     large fs:0, eax
.text$mn:00003123                 mov     [ebp+var_10], ecx
.text$mn:00003126                 mov     ecx, [ebp+var_10]
.text$mn:00003129                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$mn:0000312E                 mov     [ebp+var_4], 0
.text$mn:00003135                 mov     eax, [ebp+var_10]
.text$mn:00003138                 mov     ecx, [ebp+arg_0]
.text$mn:0000313B                 mov     [eax+8], ecx
.text$mn:0000313E                 mov     edx, [ebp+arg_4]
.text$mn:00003141                 push    edx             ; struct std::_Container_base12 *
.text$mn:00003142                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003145                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:0000314A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003151                 mov     eax, [ebp+var_10]
.text$mn:00003154                 mov     ecx, [ebp+var_C]
.text$mn:00003157                 mov     large fs:0, ecx
.text$mn:0000315E                 pop     ecx
.text$mn:0000315F                 mov     esp, ebp
.text$mn:00003161                 pop     ebp
.text$mn:00003162                 retn    8
.text$mn:00003162 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z endp
.text$mn:00003162
.text$mn:00003162 ; ---------------------------------------------------------------------------
.text$mn:00003165                 align 4
.text$mn:00003165 _text$mn        ends
.text$mn:00003165
.text$x:00003168 ; ===========================================================================
.text$x:00003168
.text$x:00003168 ; Segment type: Pure code
.text$x:00003168 ; Segment permissions: Read/Execute
.text$x:00003168 _text$x         segment para public 'CODE' use32
.text$x:00003168                 assume cs:_text$x
.text$x:00003168                 ;org 3168h
.text$x:00003168 ; COMDAT (pick associative to section at 3100)
.text$x:00003168                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003168
.text$x:00003168 ; =============== S U B R O U T I N E =======================================
.text$x:00003168
.text$x:00003168
.text$x:00003168 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0 proc near
.text$x:00003168                                         ; DATA XREF: .xdata$x:000084B8o
.text$x:00003168                 mov     ecx, [ebp-10h]
.text$x:0000316B                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$x:0000316B __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0 endp
.text$x:0000316B
.text$x:00003170
.text$x:00003170 ; =============== S U B R O U T I N E =======================================
.text$x:00003170
.text$x:00003170
.text$x:00003170 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z proc near
.text$x:00003170                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+5o
.text$x:00003170
.text$x:00003170 arg_4           = dword ptr  8
.text$x:00003170
.text$x:00003170                 mov     edx, [esp+arg_4]
.text$x:00003174                 lea     eax, [edx+0Ch]
.text$x:00003177                 mov     ecx, [edx-8]
.text$x:0000317A                 xor     ecx, eax
.text$x:0000317C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003181                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$x:00003186                 jmp     ___CxxFrameHandler3
.text$x:00003186 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z endp
.text$x:00003186
.text$x:00003186 ; ---------------------------------------------------------------------------
.text$x:0000318B                 align 4
.text$x:0000318B _text$x         ends
.text$x:0000318B
.text$mn:0000318C ; ===========================================================================
.text$mn:0000318C
.text$mn:0000318C ; Segment type: Pure code
.text$mn:0000318C ; Segment permissions: Read/Execute
.text$mn:0000318C _text$mn        segment para public 'CODE' use32
.text$mn:0000318C                 assume cs:_text$mn
.text$mn:0000318C                 ;org 318Ch
.text$mn:0000318C ; COMDAT (pick any)
.text$mn:0000318C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000318C
.text$mn:0000318C ; =============== S U B R O U T I N E =======================================
.text$mn:0000318C
.text$mn:0000318C ; Attributes: bp-based frame
.text$mn:0000318C
.text$mn:0000318C ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(struct std::_Iterator_base12 *)
.text$mn:0000318C                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000318C ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000318C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+(int)+36p
.text$mn:0000318C                                         ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+(int)+52p
.text$mn:0000318C
.text$mn:0000318C var_10          = dword ptr -10h
.text$mn:0000318C var_C           = dword ptr -0Ch
.text$mn:0000318C var_4           = dword ptr -4
.text$mn:0000318C arg_0           = dword ptr  8
.text$mn:0000318C
.text$mn:0000318C                 push    ebp
.text$mn:0000318D                 mov     ebp, esp
.text$mn:0000318F                 push    0FFFFFFFFh
.text$mn:00003191                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00003196                 mov     eax, large fs:0
.text$mn:0000319C                 push    eax
.text$mn:0000319D                 push    ecx
.text$mn:0000319E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000031A3                 xor     eax, ebp
.text$mn:000031A5                 push    eax
.text$mn:000031A6                 lea     eax, [ebp+var_C]
.text$mn:000031A9                 mov     large fs:0, eax
.text$mn:000031AF                 mov     [ebp+var_10], ecx
.text$mn:000031B2                 mov     eax, [ebp+arg_0]
.text$mn:000031B5                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000031B6                 mov     ecx, [ebp+var_10]
.text$mn:000031B9                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:000031BE                 mov     [ebp+var_4], 0
.text$mn:000031C5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000031CC                 mov     eax, [ebp+var_10]
.text$mn:000031CF                 mov     ecx, [ebp+var_C]
.text$mn:000031D2                 mov     large fs:0, ecx
.text$mn:000031D9                 pop     ecx
.text$mn:000031DA                 mov     esp, ebp
.text$mn:000031DC                 pop     ebp
.text$mn:000031DD                 retn    4
.text$mn:000031DD ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:000031DD
.text$mn:000031DD _text$mn        ends
.text$mn:000031DD
.text$x:000031E0 ; ===========================================================================
.text$x:000031E0
.text$x:000031E0 ; Segment type: Pure code
.text$x:000031E0 ; Segment permissions: Read/Execute
.text$x:000031E0 _text$x         segment para public 'CODE' use32
.text$x:000031E0                 assume cs:_text$x
.text$x:000031E0                 ;org 31E0h
.text$x:000031E0 ; COMDAT (pick associative to section at 318C)
.text$x:000031E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000031E0
.text$x:000031E0 ; =============== S U B R O U T I N E =======================================
.text$x:000031E0
.text$x:000031E0
.text$x:000031E0 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:000031E0                                         ; DATA XREF: .xdata$x:000085C8o
.text$x:000031E0                 mov     ecx, [ebp-10h]
.text$x:000031E3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000031E3 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:000031E3
.text$x:000031E8
.text$x:000031E8 ; =============== S U B R O U T I N E =======================================
.text$x:000031E8
.text$x:000031E8
.text$x:000031E8 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:000031E8                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)+5o
.text$x:000031E8
.text$x:000031E8 arg_4           = dword ptr  8
.text$x:000031E8
.text$x:000031E8                 mov     edx, [esp+arg_4]
.text$x:000031EC                 lea     eax, [edx+0Ch]
.text$x:000031EF                 mov     ecx, [edx-8]
.text$x:000031F2                 xor     ecx, eax
.text$x:000031F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000031F9                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:000031FE                 jmp     ___CxxFrameHandler3
.text$x:000031FE __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:000031FE
.text$x:000031FE ; ---------------------------------------------------------------------------
.text$x:00003203                 align 4
.text$x:00003203 _text$x         ends
.text$x:00003203
.text$mn:00003204 ; ===========================================================================
.text$mn:00003204
.text$mn:00003204 ; Segment type: Pure code
.text$mn:00003204 ; Segment permissions: Read/Execute
.text$mn:00003204 _text$mn        segment para public 'CODE' use32
.text$mn:00003204                 assume cs:_text$mn
.text$mn:00003204                 ;org 3204h
.text$mn:00003204 ; COMDAT (pick any)
.text$mn:00003204                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003204
.text$mn:00003204 ; =============== S U B R O U T I N E =======================================
.text$mn:00003204
.text$mn:00003204 ; Attributes: bp-based frame
.text$mn:00003204
.text$mn:00003204 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int, struct std::_Container_base12 *)
.text$mn:00003204                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$mn:00003204 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z proc near
.text$mn:00003204                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+41p
.text$mn:00003204                                         ; std::vector<int,std::allocator<int>>::begin(void)+3Dp
.text$mn:00003204
.text$mn:00003204 var_10          = dword ptr -10h
.text$mn:00003204 var_C           = dword ptr -0Ch
.text$mn:00003204 var_4           = dword ptr -4
.text$mn:00003204 arg_0           = dword ptr  8
.text$mn:00003204 arg_4           = dword ptr  0Ch
.text$mn:00003204
.text$mn:00003204                 push    ebp
.text$mn:00003205                 mov     ebp, esp
.text$mn:00003207                 push    0FFFFFFFFh
.text$mn:00003209                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$mn:0000320E                 mov     eax, large fs:0
.text$mn:00003214                 push    eax
.text$mn:00003215                 push    ecx
.text$mn:00003216                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000321B                 xor     eax, ebp
.text$mn:0000321D                 push    eax
.text$mn:0000321E                 lea     eax, [ebp+var_C]
.text$mn:00003221                 mov     large fs:0, eax
.text$mn:00003227                 mov     [ebp+var_10], ecx
.text$mn:0000322A                 mov     eax, [ebp+arg_4]
.text$mn:0000322D                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000322E                 mov     ecx, [ebp+arg_0]
.text$mn:00003231                 push    ecx             ; int
.text$mn:00003232                 mov     ecx, [ebp+var_10]
.text$mn:00003235                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)
.text$mn:0000323A                 mov     [ebp+var_4], 0
.text$mn:00003241                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003248                 mov     eax, [ebp+var_10]
.text$mn:0000324B                 mov     ecx, [ebp+var_C]
.text$mn:0000324E                 mov     large fs:0, ecx
.text$mn:00003255                 pop     ecx
.text$mn:00003256                 mov     esp, ebp
.text$mn:00003258                 pop     ebp
.text$mn:00003259                 retn    8
.text$mn:00003259 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z endp
.text$mn:00003259
.text$mn:00003259 _text$mn        ends
.text$mn:00003259
.text$x:0000325C ; ===========================================================================
.text$x:0000325C
.text$x:0000325C ; Segment type: Pure code
.text$x:0000325C ; Segment permissions: Read/Execute
.text$x:0000325C _text$x         segment para public 'CODE' use32
.text$x:0000325C                 assume cs:_text$x
.text$x:0000325C                 ;org 325Ch
.text$x:0000325C ; COMDAT (pick associative to section at 3204)
.text$x:0000325C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000325C
.text$x:0000325C ; =============== S U B R O U T I N E =======================================
.text$x:0000325C
.text$x:0000325C
.text$x:0000325C __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0 proc near
.text$x:0000325C                                         ; DATA XREF: .xdata$x:0000853Co
.text$x:0000325C                 mov     ecx, [ebp-10h]
.text$x:0000325F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:0000325F __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0 endp
.text$x:0000325F
.text$x:00003264
.text$x:00003264 ; =============== S U B R O U T I N E =======================================
.text$x:00003264
.text$x:00003264
.text$x:00003264 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z proc near
.text$x:00003264                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+5o
.text$x:00003264
.text$x:00003264 arg_4           = dword ptr  8
.text$x:00003264
.text$x:00003264                 mov     edx, [esp+arg_4]
.text$x:00003268                 lea     eax, [edx+0Ch]
.text$x:0000326B                 mov     ecx, [edx-8]
.text$x:0000326E                 xor     ecx, eax
.text$x:00003270                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003275                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.text$x:0000327A                 jmp     ___CxxFrameHandler3
.text$x:0000327A __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z endp
.text$x:0000327A
.text$x:0000327A ; ---------------------------------------------------------------------------
.text$x:0000327F                 align 10h
.text$x:0000327F _text$x         ends
.text$x:0000327F
.text$mn:00003280 ; ===========================================================================
.text$mn:00003280
.text$mn:00003280 ; Segment type: Pure code
.text$mn:00003280 ; Segment permissions: Read/Execute
.text$mn:00003280 _text$mn        segment para public 'CODE' use32
.text$mn:00003280                 assume cs:_text$mn
.text$mn:00003280                 ;org 3280h
.text$mn:00003280 ; COMDAT (pick any)
.text$mn:00003280                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003280
.text$mn:00003280 ; =============== S U B R O U T I N E =======================================
.text$mn:00003280
.text$mn:00003280 ; Attributes: bp-based frame
.text$mn:00003280
.text$mn:00003280 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00003280                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00003280 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00003280                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00003280
.text$mn:00003280 var_4           = dword ptr -4
.text$mn:00003280
.text$mn:00003280                 push    ebp
.text$mn:00003281                 mov     ebp, esp
.text$mn:00003283                 push    ecx
.text$mn:00003284                 mov     [ebp+var_4], ecx
.text$mn:00003287                 mov     ecx, [ebp+var_4]
.text$mn:0000328A                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000328F                 mov     eax, [ebp+var_4]
.text$mn:00003292                 mov     esp, ebp
.text$mn:00003294                 pop     ebp
.text$mn:00003295                 retn
.text$mn:00003295 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00003295
.text$mn:00003295 ; ---------------------------------------------------------------------------
.text$mn:00003296                 align 4
.text$mn:00003296 _text$mn        ends
.text$mn:00003296
.text$mn:00003298 ; ===========================================================================
.text$mn:00003298
.text$mn:00003298 ; Segment type: Pure code
.text$mn:00003298 ; Segment permissions: Read/Execute
.text$mn:00003298 _text$mn        segment para public 'CODE' use32
.text$mn:00003298                 assume cs:_text$mn
.text$mn:00003298                 ;org 3298h
.text$mn:00003298 ; COMDAT (pick any)
.text$mn:00003298                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003298
.text$mn:00003298 ; =============== S U B R O U T I N E =======================================
.text$mn:00003298
.text$mn:00003298 ; Attributes: bp-based frame
.text$mn:00003298
.text$mn:00003298 ; public: __thiscall std::_Wrap_alloc<class std::allocator<int>>::_Wrap_alloc<class std::allocator<int>>(void)
.text$mn:00003298                 public ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ
.text$mn:00003298 ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ proc near
.text$mn:00003298                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)+Ap
.text$mn:00003298
.text$mn:00003298 var_4           = dword ptr -4
.text$mn:00003298
.text$mn:00003298                 push    ebp
.text$mn:00003299                 mov     ebp, esp
.text$mn:0000329B                 push    ecx
.text$mn:0000329C                 mov     [ebp+var_4], ecx
.text$mn:0000329F                 mov     ecx, [ebp+var_4]
.text$mn:000032A2                 call    ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>(void)
.text$mn:000032A7                 mov     eax, [ebp+var_4]
.text$mn:000032AA                 mov     esp, ebp
.text$mn:000032AC                 pop     ebp
.text$mn:000032AD                 retn
.text$mn:000032AD ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ endp
.text$mn:000032AD
.text$mn:000032AD ; ---------------------------------------------------------------------------
.text$mn:000032AE                 align 10h
.text$mn:000032AE _text$mn        ends
.text$mn:000032AE
.text$mn:000032B0 ; ===========================================================================
.text$mn:000032B0
.text$mn:000032B0 ; Segment type: Pure code
.text$mn:000032B0 ; Segment permissions: Read/Execute
.text$mn:000032B0 _text$mn        segment para public 'CODE' use32
.text$mn:000032B0                 assume cs:_text$mn
.text$mn:000032B0                 ;org 32B0h
.text$mn:000032B0 ; COMDAT (pick any)
.text$mn:000032B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032B0
.text$mn:000032B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000032B0
.text$mn:000032B0 ; Attributes: bp-based frame
.text$mn:000032B0
.text$mn:000032B0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct iconLocator>>::_Wrap_alloc<class std::allocator<struct iconLocator>>(void)
.text$mn:000032B0                 public ??0?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAE@XZ
.text$mn:000032B0 ??0?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAE@XZ proc near
.text$mn:000032B0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<iconLocator,std::allocator<iconLocator>>>::_Getal(void)+Ap
.text$mn:000032B0
.text$mn:000032B0 var_4           = dword ptr -4
.text$mn:000032B0
.text$mn:000032B0                 push    ebp
.text$mn:000032B1                 mov     ebp, esp
.text$mn:000032B3                 push    ecx
.text$mn:000032B4                 mov     [ebp+var_4], ecx
.text$mn:000032B7                 mov     ecx, [ebp+var_4]
.text$mn:000032BA                 call    ??0?$allocator@UiconLocator@@@std@@QAE@XZ ; std::allocator<iconLocator>::allocator<iconLocator>(void)
.text$mn:000032BF                 mov     eax, [ebp+var_4]
.text$mn:000032C2                 mov     esp, ebp
.text$mn:000032C4                 pop     ebp
.text$mn:000032C5                 retn
.text$mn:000032C5 ??0?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAE@XZ endp
.text$mn:000032C5
.text$mn:000032C5 ; ---------------------------------------------------------------------------
.text$mn:000032C6                 align 4
.text$mn:000032C6 _text$mn        ends
.text$mn:000032C6
.text$mn:000032C8 ; ===========================================================================
.text$mn:000032C8
.text$mn:000032C8 ; Segment type: Pure code
.text$mn:000032C8 ; Segment permissions: Read/Execute
.text$mn:000032C8 _text$mn        segment para public 'CODE' use32
.text$mn:000032C8                 assume cs:_text$mn
.text$mn:000032C8                 ;org 32C8h
.text$mn:000032C8 ; COMDAT (pick any)
.text$mn:000032C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032C8
.text$mn:000032C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000032C8
.text$mn:000032C8 ; Attributes: bp-based frame
.text$mn:000032C8
.text$mn:000032C8 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct tDynamicList>>::_Wrap_alloc<class std::allocator<struct tDynamicList>>(void)
.text$mn:000032C8                 public ??0?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAE@XZ
.text$mn:000032C8 ??0?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAE@XZ proc near
.text$mn:000032C8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<tDynamicList,std::allocator<tDynamicList>>>::_Getal(void)+Ap
.text$mn:000032C8
.text$mn:000032C8 var_4           = dword ptr -4
.text$mn:000032C8
.text$mn:000032C8                 push    ebp
.text$mn:000032C9                 mov     ebp, esp
.text$mn:000032CB                 push    ecx
.text$mn:000032CC                 mov     [ebp+var_4], ecx
.text$mn:000032CF                 mov     ecx, [ebp+var_4]
.text$mn:000032D2                 call    ??0?$allocator@UtDynamicList@@@std@@QAE@XZ ; std::allocator<tDynamicList>::allocator<tDynamicList>(void)
.text$mn:000032D7                 mov     eax, [ebp+var_4]
.text$mn:000032DA                 mov     esp, ebp
.text$mn:000032DC                 pop     ebp
.text$mn:000032DD                 retn
.text$mn:000032DD ??0?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAE@XZ endp
.text$mn:000032DD
.text$mn:000032DD ; ---------------------------------------------------------------------------
.text$mn:000032DE                 align 10h
.text$mn:000032DE _text$mn        ends
.text$mn:000032DE
.text$mn:000032E0 ; ===========================================================================
.text$mn:000032E0
.text$mn:000032E0 ; Segment type: Pure code
.text$mn:000032E0 ; Segment permissions: Read/Execute
.text$mn:000032E0 _text$mn        segment para public 'CODE' use32
.text$mn:000032E0                 assume cs:_text$mn
.text$mn:000032E0                 ;org 32E0h
.text$mn:000032E0 ; COMDAT (pick any)
.text$mn:000032E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032E0
.text$mn:000032E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000032E0
.text$mn:000032E0 ; Attributes: bp-based frame
.text$mn:000032E0
.text$mn:000032E0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(class std::allocator<wchar_t> const &)
.text$mn:000032E0                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:000032E0 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:000032E0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+1Dp
.text$mn:000032E0
.text$mn:000032E0 var_4           = dword ptr -4
.text$mn:000032E0 arg_0           = dword ptr  8
.text$mn:000032E0
.text$mn:000032E0                 push    ebp
.text$mn:000032E1                 mov     ebp, esp
.text$mn:000032E3                 push    ecx
.text$mn:000032E4                 mov     [ebp+var_4], ecx
.text$mn:000032E7                 mov     eax, [ebp+arg_0]
.text$mn:000032EA                 push    eax
.text$mn:000032EB                 mov     ecx, [ebp+var_4]
.text$mn:000032EE                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:000032F3                 mov     eax, [ebp+var_4]
.text$mn:000032F6                 mov     esp, ebp
.text$mn:000032F8                 pop     ebp
.text$mn:000032F9                 retn    4
.text$mn:000032F9 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:000032F9
.text$mn:000032F9 _text$mn        ends
.text$mn:000032F9
.text$mn:000032FC ; ===========================================================================
.text$mn:000032FC
.text$mn:000032FC ; Segment type: Pure code
.text$mn:000032FC ; Segment permissions: Read/Execute
.text$mn:000032FC _text$mn        segment para public 'CODE' use32
.text$mn:000032FC                 assume cs:_text$mn
.text$mn:000032FC                 ;org 32FCh
.text$mn:000032FC ; COMDAT (pick any)
.text$mn:000032FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032FC
.text$mn:000032FC ; =============== S U B R O U T I N E =======================================
.text$mn:000032FC
.text$mn:000032FC ; Attributes: bp-based frame
.text$mn:000032FC
.text$mn:000032FC ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:000032FC                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:000032FC ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:000032FC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:000032FC
.text$mn:000032FC var_4           = dword ptr -4
.text$mn:000032FC
.text$mn:000032FC                 push    ebp
.text$mn:000032FD                 mov     ebp, esp
.text$mn:000032FF                 push    ecx
.text$mn:00003300                 mov     [ebp+var_4], ecx
.text$mn:00003303                 mov     ecx, [ebp+var_4]
.text$mn:00003306                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:0000330B                 mov     eax, [ebp+var_4]
.text$mn:0000330E                 mov     esp, ebp
.text$mn:00003310                 pop     ebp
.text$mn:00003311                 retn
.text$mn:00003311 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00003311
.text$mn:00003311 ; ---------------------------------------------------------------------------
.text$mn:00003312                 align 4
.text$mn:00003312 _text$mn        ends
.text$mn:00003312
.text$mn:00003314 ; ===========================================================================
.text$mn:00003314
.text$mn:00003314 ; Segment type: Pure code
.text$mn:00003314 ; Segment permissions: Read/Execute
.text$mn:00003314 _text$mn        segment para public 'CODE' use32
.text$mn:00003314                 assume cs:_text$mn
.text$mn:00003314                 ;org 3314h
.text$mn:00003314 ; COMDAT (pick any)
.text$mn:00003314                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003314
.text$mn:00003314 ; =============== S U B R O U T I N E =======================================
.text$mn:00003314
.text$mn:00003314 ; Attributes: bp-based frame
.text$mn:00003314
.text$mn:00003314 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00003314                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00003314 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00003314                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00003314
.text$mn:00003314 var_4           = dword ptr -4
.text$mn:00003314
.text$mn:00003314                 push    ebp
.text$mn:00003315                 mov     ebp, esp
.text$mn:00003317                 push    ecx
.text$mn:00003318                 mov     [ebp+var_4], ecx
.text$mn:0000331B                 mov     eax, [ebp+var_4]
.text$mn:0000331E                 mov     esp, ebp
.text$mn:00003320                 pop     ebp
.text$mn:00003321                 retn
.text$mn:00003321 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00003321
.text$mn:00003321 ; ---------------------------------------------------------------------------
.text$mn:00003322                 align 4
.text$mn:00003322 _text$mn        ends
.text$mn:00003322
.text$mn:00003324 ; ===========================================================================
.text$mn:00003324
.text$mn:00003324 ; Segment type: Pure code
.text$mn:00003324 ; Segment permissions: Read/Execute
.text$mn:00003324 _text$mn        segment para public 'CODE' use32
.text$mn:00003324                 assume cs:_text$mn
.text$mn:00003324                 ;org 3324h
.text$mn:00003324 ; COMDAT (pick any)
.text$mn:00003324                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003324
.text$mn:00003324 ; =============== S U B R O U T I N E =======================================
.text$mn:00003324
.text$mn:00003324 ; Attributes: bp-based frame
.text$mn:00003324
.text$mn:00003324 ; public: __thiscall std::allocator<int>::allocator<int>(void)
.text$mn:00003324                 public ??0?$allocator@H@std@@QAE@XZ
.text$mn:00003324 ??0?$allocator@H@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::_Wrap_alloc<std::allocator<int>>(void)+Ap
.text$mn:00003324
.text$mn:00003324 var_4           = dword ptr -4
.text$mn:00003324
.text$mn:00003324                 push    ebp
.text$mn:00003325                 mov     ebp, esp
.text$mn:00003327                 push    ecx
.text$mn:00003328                 mov     [ebp+var_4], ecx
.text$mn:0000332B                 mov     eax, [ebp+var_4]
.text$mn:0000332E                 mov     esp, ebp
.text$mn:00003330                 pop     ebp
.text$mn:00003331                 retn
.text$mn:00003331 ??0?$allocator@H@std@@QAE@XZ endp
.text$mn:00003331
.text$mn:00003331 ; ---------------------------------------------------------------------------
.text$mn:00003332                 align 4
.text$mn:00003332 _text$mn        ends
.text$mn:00003332
.text$mn:00003334 ; ===========================================================================
.text$mn:00003334
.text$mn:00003334 ; Segment type: Pure code
.text$mn:00003334 ; Segment permissions: Read/Execute
.text$mn:00003334 _text$mn        segment para public 'CODE' use32
.text$mn:00003334                 assume cs:_text$mn
.text$mn:00003334                 ;org 3334h
.text$mn:00003334 ; COMDAT (pick any)
.text$mn:00003334                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003334
.text$mn:00003334 ; =============== S U B R O U T I N E =======================================
.text$mn:00003334
.text$mn:00003334 ; Attributes: bp-based frame
.text$mn:00003334
.text$mn:00003334 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00003334                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00003334 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00003334                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00003334                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00003334
.text$mn:00003334 var_4           = dword ptr -4
.text$mn:00003334
.text$mn:00003334                 push    ebp
.text$mn:00003335                 mov     ebp, esp
.text$mn:00003337                 push    ecx
.text$mn:00003338                 mov     [ebp+var_4], ecx
.text$mn:0000333B                 mov     eax, [ebp+var_4]
.text$mn:0000333E                 mov     esp, ebp
.text$mn:00003340                 pop     ebp
.text$mn:00003341                 retn
.text$mn:00003341 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00003341
.text$mn:00003341 ; ---------------------------------------------------------------------------
.text$mn:00003342                 align 4
.text$mn:00003342 _text$mn        ends
.text$mn:00003342
.text$mn:00003344 ; ===========================================================================
.text$mn:00003344
.text$mn:00003344 ; Segment type: Pure code
.text$mn:00003344 ; Segment permissions: Read/Execute
.text$mn:00003344 _text$mn        segment para public 'CODE' use32
.text$mn:00003344                 assume cs:_text$mn
.text$mn:00003344                 ;org 3344h
.text$mn:00003344 ; COMDAT (pick any)
.text$mn:00003344                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003344
.text$mn:00003344 ; =============== S U B R O U T I N E =======================================
.text$mn:00003344
.text$mn:00003344 ; Attributes: bp-based frame
.text$mn:00003344
.text$mn:00003344 ; public: __thiscall std::allocator<struct iconLocator>::allocator<struct iconLocator>(void)
.text$mn:00003344                 public ??0?$allocator@UiconLocator@@@std@@QAE@XZ
.text$mn:00003344 ??0?$allocator@UiconLocator@@@std@@QAE@XZ proc near
.text$mn:00003344                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<iconLocator>>::_Wrap_alloc<std::allocator<iconLocator>>(void)+Ap
.text$mn:00003344
.text$mn:00003344 var_4           = dword ptr -4
.text$mn:00003344
.text$mn:00003344                 push    ebp
.text$mn:00003345                 mov     ebp, esp
.text$mn:00003347                 push    ecx
.text$mn:00003348                 mov     [ebp+var_4], ecx
.text$mn:0000334B                 mov     eax, [ebp+var_4]
.text$mn:0000334E                 mov     esp, ebp
.text$mn:00003350                 pop     ebp
.text$mn:00003351                 retn
.text$mn:00003351 ??0?$allocator@UiconLocator@@@std@@QAE@XZ endp
.text$mn:00003351
.text$mn:00003351 ; ---------------------------------------------------------------------------
.text$mn:00003352                 align 4
.text$mn:00003352 _text$mn        ends
.text$mn:00003352
.text$mn:00003354 ; ===========================================================================
.text$mn:00003354
.text$mn:00003354 ; Segment type: Pure code
.text$mn:00003354 ; Segment permissions: Read/Execute
.text$mn:00003354 _text$mn        segment para public 'CODE' use32
.text$mn:00003354                 assume cs:_text$mn
.text$mn:00003354                 ;org 3354h
.text$mn:00003354 ; COMDAT (pick any)
.text$mn:00003354                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003354
.text$mn:00003354 ; =============== S U B R O U T I N E =======================================
.text$mn:00003354
.text$mn:00003354 ; Attributes: bp-based frame
.text$mn:00003354
.text$mn:00003354 ; public: __thiscall std::allocator<struct tDynamicList>::allocator<struct tDynamicList>(void)
.text$mn:00003354                 public ??0?$allocator@UtDynamicList@@@std@@QAE@XZ
.text$mn:00003354 ??0?$allocator@UtDynamicList@@@std@@QAE@XZ proc near
.text$mn:00003354                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tDynamicList>>::_Wrap_alloc<std::allocator<tDynamicList>>(void)+Ap
.text$mn:00003354
.text$mn:00003354 var_4           = dword ptr -4
.text$mn:00003354
.text$mn:00003354                 push    ebp
.text$mn:00003355                 mov     ebp, esp
.text$mn:00003357                 push    ecx
.text$mn:00003358                 mov     [ebp+var_4], ecx
.text$mn:0000335B                 mov     eax, [ebp+var_4]
.text$mn:0000335E                 mov     esp, ebp
.text$mn:00003360                 pop     ebp
.text$mn:00003361                 retn
.text$mn:00003361 ??0?$allocator@UtDynamicList@@@std@@QAE@XZ endp
.text$mn:00003361
.text$mn:00003361 ; ---------------------------------------------------------------------------
.text$mn:00003362                 align 4
.text$mn:00003362 _text$mn        ends
.text$mn:00003362
.text$mn:00003364 ; ===========================================================================
.text$mn:00003364
.text$mn:00003364 ; Segment type: Pure code
.text$mn:00003364 ; Segment permissions: Read/Execute
.text$mn:00003364 _text$mn        segment para public 'CODE' use32
.text$mn:00003364                 assume cs:_text$mn
.text$mn:00003364                 ;org 3364h
.text$mn:00003364 ; COMDAT (pick any)
.text$mn:00003364                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003364
.text$mn:00003364 ; =============== S U B R O U T I N E =======================================
.text$mn:00003364
.text$mn:00003364 ; Attributes: bp-based frame
.text$mn:00003364
.text$mn:00003364 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(class std::allocator<wchar_t> const &)
.text$mn:00003364                 public ??0?$allocator@_W@std@@QAE@ABV01@@Z
.text$mn:00003364 ??0?$allocator@_W@std@@QAE@ABV01@@Z proc near
.text$mn:00003364                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(std::allocator<wchar_t> const &)+Ep
.text$mn:00003364                                         ; std::allocator<wchar_t>::select_on_container_copy_construction(void)+Ep
.text$mn:00003364
.text$mn:00003364 var_4           = dword ptr -4
.text$mn:00003364
.text$mn:00003364                 push    ebp
.text$mn:00003365                 mov     ebp, esp
.text$mn:00003367                 push    ecx
.text$mn:00003368                 mov     [ebp+var_4], ecx
.text$mn:0000336B                 mov     eax, [ebp+var_4]
.text$mn:0000336E                 mov     esp, ebp
.text$mn:00003370                 pop     ebp
.text$mn:00003371                 retn    4
.text$mn:00003371 ??0?$allocator@_W@std@@QAE@ABV01@@Z endp
.text$mn:00003371
.text$mn:00003371 _text$mn        ends
.text$mn:00003371
.text$mn:00003374 ; ===========================================================================
.text$mn:00003374
.text$mn:00003374 ; Segment type: Pure code
.text$mn:00003374 ; Segment permissions: Read/Execute
.text$mn:00003374 _text$mn        segment para public 'CODE' use32
.text$mn:00003374                 assume cs:_text$mn
.text$mn:00003374                 ;org 3374h
.text$mn:00003374 ; COMDAT (pick any)
.text$mn:00003374                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003374
.text$mn:00003374 ; =============== S U B R O U T I N E =======================================
.text$mn:00003374
.text$mn:00003374 ; Attributes: bp-based frame
.text$mn:00003374
.text$mn:00003374 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00003374                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:00003374 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:00003374                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+2Bp ...
.text$mn:00003374
.text$mn:00003374 var_4           = dword ptr -4
.text$mn:00003374
.text$mn:00003374                 push    ebp
.text$mn:00003375                 mov     ebp, esp
.text$mn:00003377                 push    ecx
.text$mn:00003378                 mov     [ebp+var_4], ecx
.text$mn:0000337B                 mov     eax, [ebp+var_4]
.text$mn:0000337E                 mov     esp, ebp
.text$mn:00003380                 pop     ebp
.text$mn:00003381                 retn
.text$mn:00003381 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00003381
.text$mn:00003381 ; ---------------------------------------------------------------------------
.text$mn:00003382                 align 4
.text$mn:00003382 _text$mn        ends
.text$mn:00003382
.text$mn:00003384 ; ===========================================================================
.text$mn:00003384
.text$mn:00003384 ; Segment type: Pure code
.text$mn:00003384 ; Segment permissions: Read/Execute
.text$mn:00003384 _text$mn        segment para public 'CODE' use32
.text$mn:00003384                 assume cs:_text$mn
.text$mn:00003384                 ;org 3384h
.text$mn:00003384 ; COMDAT (pick any)
.text$mn:00003384                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003384
.text$mn:00003384 ; =============== S U B R O U T I N E =======================================
.text$mn:00003384
.text$mn:00003384 ; Attributes: bp-based frame
.text$mn:00003384
.text$mn:00003384 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00003384                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00003384 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00003384                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00003384                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00003384
.text$mn:00003384 var_14          = dword ptr -14h
.text$mn:00003384 var_D           = byte ptr -0Dh
.text$mn:00003384 var_C           = dword ptr -0Ch
.text$mn:00003384 var_4           = dword ptr -4
.text$mn:00003384 Str             = dword ptr  8
.text$mn:00003384
.text$mn:00003384                 push    ebp
.text$mn:00003385                 mov     ebp, esp
.text$mn:00003387                 push    0FFFFFFFFh
.text$mn:00003389                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000338E                 mov     eax, large fs:0
.text$mn:00003394                 push    eax
.text$mn:00003395                 sub     esp, 8
.text$mn:00003398                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000339D                 xor     eax, ebp
.text$mn:0000339F                 push    eax
.text$mn:000033A0                 lea     eax, [ebp+var_C]
.text$mn:000033A3                 mov     large fs:0, eax
.text$mn:000033A9                 mov     [ebp+var_14], ecx
.text$mn:000033AC                 lea     ecx, [ebp+var_D]
.text$mn:000033AF                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000033B4                 push    eax
.text$mn:000033B5                 mov     ecx, [ebp+var_14]
.text$mn:000033B8                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000033BD                 mov     [ebp+var_4], 0
.text$mn:000033C4                 push    0               ; Size
.text$mn:000033C6                 push    0               ; char
.text$mn:000033C8                 mov     ecx, [ebp+var_14]
.text$mn:000033CB                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000033D0                 mov     eax, [ebp+Str]
.text$mn:000033D3                 push    eax             ; Str
.text$mn:000033D4                 mov     ecx, [ebp+var_14]
.text$mn:000033D7                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000033DC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000033E3                 mov     eax, [ebp+var_14]
.text$mn:000033E6                 mov     ecx, [ebp+var_C]
.text$mn:000033E9                 mov     large fs:0, ecx
.text$mn:000033F0                 pop     ecx
.text$mn:000033F1                 mov     esp, ebp
.text$mn:000033F3                 pop     ebp
.text$mn:000033F4                 retn    4
.text$mn:000033F4 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:000033F4
.text$mn:000033F4 ; ---------------------------------------------------------------------------
.text$mn:000033F7                 align 4
.text$mn:000033F7 _text$mn        ends
.text$mn:000033F7
.text$x:000033F8 ; ===========================================================================
.text$x:000033F8
.text$x:000033F8 ; Segment type: Pure code
.text$x:000033F8 ; Segment permissions: Read/Execute
.text$x:000033F8 _text$x         segment para public 'CODE' use32
.text$x:000033F8                 assume cs:_text$x
.text$x:000033F8                 ;org 33F8h
.text$x:000033F8 ; COMDAT (pick associative to section at 3384)
.text$x:000033F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000033F8
.text$x:000033F8 ; =============== S U B R O U T I N E =======================================
.text$x:000033F8
.text$x:000033F8
.text$x:000033F8 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:000033F8                                         ; DATA XREF: .xdata$x:00007BCCo
.text$x:000033F8                 mov     ecx, [ebp-14h]
.text$x:000033FB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000033FB __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:000033FB
.text$x:00003400
.text$x:00003400 ; =============== S U B R O U T I N E =======================================
.text$x:00003400
.text$x:00003400
.text$x:00003400 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00003400                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00003400
.text$x:00003400 arg_4           = dword ptr  8
.text$x:00003400
.text$x:00003400                 mov     edx, [esp+arg_4]
.text$x:00003404                 lea     eax, [edx+0Ch]
.text$x:00003407                 mov     ecx, [edx-0Ch]
.text$x:0000340A                 xor     ecx, eax
.text$x:0000340C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003411                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00003416                 jmp     ___CxxFrameHandler3
.text$x:00003416 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00003416
.text$x:00003416 ; ---------------------------------------------------------------------------
.text$x:0000341B                 align 4
.text$x:0000341B _text$x         ends
.text$x:0000341B
.text$mn:0000341C ; ===========================================================================
.text$mn:0000341C
.text$mn:0000341C ; Segment type: Pure code
.text$mn:0000341C ; Segment permissions: Read/Execute
.text$mn:0000341C _text$mn        segment para public 'CODE' use32
.text$mn:0000341C                 assume cs:_text$mn
.text$mn:0000341C                 ;org 341Ch
.text$mn:0000341C ; COMDAT (pick any)
.text$mn:0000341C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000341C
.text$mn:0000341C ; =============== S U B R O U T I N E =======================================
.text$mn:0000341C
.text$mn:0000341C ; Attributes: bp-based frame
.text$mn:0000341C
.text$mn:0000341C ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:0000341C                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:0000341C ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$mn:0000341C                                         ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+1F7p
.text$mn:0000341C                                         ; ToolBar::initTheme(TiXmlDocument *)+311p ...
.text$mn:0000341C
.text$mn:0000341C var_14          = dword ptr -14h
.text$mn:0000341C var_E           = byte ptr -0Eh
.text$mn:0000341C var_D           = byte ptr -0Dh
.text$mn:0000341C var_C           = dword ptr -0Ch
.text$mn:0000341C var_4           = dword ptr -4
.text$mn:0000341C arg_0           = dword ptr  8
.text$mn:0000341C
.text$mn:0000341C                 push    ebp
.text$mn:0000341D                 mov     ebp, esp
.text$mn:0000341F                 push    0FFFFFFFFh
.text$mn:00003421                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:00003426                 mov     eax, large fs:0
.text$mn:0000342C                 push    eax
.text$mn:0000342D                 sub     esp, 8
.text$mn:00003430                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003435                 xor     eax, ebp
.text$mn:00003437                 push    eax
.text$mn:00003438                 lea     eax, [ebp+var_C]
.text$mn:0000343B                 mov     large fs:0, eax
.text$mn:00003441                 mov     [ebp+var_14], ecx
.text$mn:00003444                 lea     eax, [ebp+var_D]
.text$mn:00003447                 push    eax
.text$mn:00003448                 lea     ecx, [ebp+var_E]
.text$mn:0000344B                 push    ecx
.text$mn:0000344C                 mov     ecx, [ebp+arg_0]
.text$mn:0000344F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00003454                 mov     ecx, eax
.text$mn:00003456                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)
.text$mn:0000345B                 push    eax
.text$mn:0000345C                 mov     ecx, [ebp+var_14]
.text$mn:0000345F                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00003464                 mov     [ebp+var_4], 0
.text$mn:0000346B                 push    0
.text$mn:0000346D                 push    0
.text$mn:0000346F                 mov     ecx, [ebp+var_14]
.text$mn:00003472                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00003477                 mov     edx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:0000347D                 push    edx
.text$mn:0000347E                 push    0
.text$mn:00003480                 mov     eax, [ebp+arg_0]
.text$mn:00003483                 push    eax
.text$mn:00003484                 mov     ecx, [ebp+var_14]
.text$mn:00003487                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000348C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003493                 mov     eax, [ebp+var_14]
.text$mn:00003496                 mov     ecx, [ebp+var_C]
.text$mn:00003499                 mov     large fs:0, ecx
.text$mn:000034A0                 pop     ecx
.text$mn:000034A1                 mov     esp, ebp
.text$mn:000034A3                 pop     ebp
.text$mn:000034A4                 retn    4
.text$mn:000034A4 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$mn:000034A4
.text$mn:000034A4 ; ---------------------------------------------------------------------------
.text$mn:000034A7                 align 4
.text$mn:000034A7 _text$mn        ends
.text$mn:000034A7
.text$x:000034A8 ; ===========================================================================
.text$x:000034A8
.text$x:000034A8 ; Segment type: Pure code
.text$x:000034A8 ; Segment permissions: Read/Execute
.text$x:000034A8 _text$x         segment para public 'CODE' use32
.text$x:000034A8                 assume cs:_text$x
.text$x:000034A8                 ;org 34A8h
.text$x:000034A8 ; COMDAT (pick associative to section at 341C)
.text$x:000034A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000034A8
.text$x:000034A8 ; =============== S U B R O U T I N E =======================================
.text$x:000034A8
.text$x:000034A8
.text$x:000034A8 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 proc near
.text$x:000034A8                                         ; DATA XREF: .xdata$x:00007F70o
.text$x:000034A8                 mov     ecx, [ebp-14h]
.text$x:000034AB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000034AB __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 endp
.text$x:000034AB
.text$x:000034B0
.text$x:000034B0 ; =============== S U B R O U T I N E =======================================
.text$x:000034B0
.text$x:000034B0
.text$x:000034B0 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$x:000034B0                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:000034B0
.text$x:000034B0 arg_4           = dword ptr  8
.text$x:000034B0
.text$x:000034B0                 mov     edx, [esp+arg_4]
.text$x:000034B4                 lea     eax, [edx+0Ch]
.text$x:000034B7                 mov     ecx, [edx-0Ch]
.text$x:000034BA                 xor     ecx, eax
.text$x:000034BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000034C1                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$x:000034C6                 jmp     ___CxxFrameHandler3
.text$x:000034C6 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$x:000034C6
.text$x:000034C6 ; ---------------------------------------------------------------------------
.text$x:000034CB                 align 4
.text$x:000034CB _text$x         ends
.text$x:000034CB
.text$mn:000034CC ; ===========================================================================
.text$mn:000034CC
.text$mn:000034CC ; Segment type: Pure code
.text$mn:000034CC ; Segment permissions: Read/Execute
.text$mn:000034CC _text$mn        segment para public 'CODE' use32
.text$mn:000034CC                 assume cs:_text$mn
.text$mn:000034CC                 ;org 34CCh
.text$mn:000034CC ; COMDAT (pick any)
.text$mn:000034CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034CC
.text$mn:000034CC ; =============== S U B R O U T I N E =======================================
.text$mn:000034CC
.text$mn:000034CC ; Attributes: bp-based frame
.text$mn:000034CC
.text$mn:000034CC ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:000034CC                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:000034CC ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:000034CC                                         ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+1C8p
.text$mn:000034CC                                         ; ToolBar::initTheme(TiXmlDocument *)+2E2p ...
.text$mn:000034CC
.text$mn:000034CC var_14          = dword ptr -14h
.text$mn:000034CC var_D           = byte ptr -0Dh
.text$mn:000034CC var_C           = dword ptr -0Ch
.text$mn:000034CC var_4           = dword ptr -4
.text$mn:000034CC Str             = dword ptr  8
.text$mn:000034CC
.text$mn:000034CC                 push    ebp
.text$mn:000034CD                 mov     ebp, esp
.text$mn:000034CF                 push    0FFFFFFFFh
.text$mn:000034D1                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:000034D6                 mov     eax, large fs:0
.text$mn:000034DC                 push    eax
.text$mn:000034DD                 sub     esp, 8
.text$mn:000034E0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000034E5                 xor     eax, ebp
.text$mn:000034E7                 push    eax
.text$mn:000034E8                 lea     eax, [ebp+var_C]
.text$mn:000034EB                 mov     large fs:0, eax
.text$mn:000034F1                 mov     [ebp+var_14], ecx
.text$mn:000034F4                 lea     ecx, [ebp+var_D]
.text$mn:000034F7                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000034FC                 push    eax
.text$mn:000034FD                 mov     ecx, [ebp+var_14]
.text$mn:00003500                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00003505                 mov     [ebp+var_4], 0
.text$mn:0000350C                 push    0
.text$mn:0000350E                 push    0
.text$mn:00003510                 mov     ecx, [ebp+var_14]
.text$mn:00003513                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00003518                 mov     eax, [ebp+Str]
.text$mn:0000351B                 push    eax             ; Str
.text$mn:0000351C                 mov     ecx, [ebp+var_14]
.text$mn:0000351F                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00003524                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000352B                 mov     eax, [ebp+var_14]
.text$mn:0000352E                 mov     ecx, [ebp+var_C]
.text$mn:00003531                 mov     large fs:0, ecx
.text$mn:00003538                 pop     ecx
.text$mn:00003539                 mov     esp, ebp
.text$mn:0000353B                 pop     ebp
.text$mn:0000353C                 retn    4
.text$mn:0000353C ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:0000353C
.text$mn:0000353C ; ---------------------------------------------------------------------------
.text$mn:0000353F                 align 10h
.text$mn:0000353F _text$mn        ends
.text$mn:0000353F
.text$x:00003540 ; ===========================================================================
.text$x:00003540
.text$x:00003540 ; Segment type: Pure code
.text$x:00003540 ; Segment permissions: Read/Execute
.text$x:00003540 _text$x         segment para public 'CODE' use32
.text$x:00003540                 assume cs:_text$x
.text$x:00003540                 ;org 3540h
.text$x:00003540 ; COMDAT (pick associative to section at 34CC)
.text$x:00003540                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003540
.text$x:00003540 ; =============== S U B R O U T I N E =======================================
.text$x:00003540
.text$x:00003540
.text$x:00003540 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:00003540                                         ; DATA XREF: .xdata$x:00007FC8o
.text$x:00003540                 mov     ecx, [ebp-14h]
.text$x:00003543                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00003543 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:00003543
.text$x:00003548
.text$x:00003548 ; =============== S U B R O U T I N E =======================================
.text$x:00003548
.text$x:00003548
.text$x:00003548 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:00003548                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:00003548
.text$x:00003548 arg_4           = dword ptr  8
.text$x:00003548
.text$x:00003548                 mov     edx, [esp+arg_4]
.text$x:0000354C                 lea     eax, [edx+0Ch]
.text$x:0000354F                 mov     ecx, [edx-0Ch]
.text$x:00003552                 xor     ecx, eax
.text$x:00003554                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003559                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:0000355E                 jmp     ___CxxFrameHandler3
.text$x:0000355E __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:0000355E
.text$x:0000355E ; ---------------------------------------------------------------------------
.text$x:00003563                 align 4
.text$x:00003563 _text$x         ends
.text$x:00003563
.text$mn:00003564 ; ===========================================================================
.text$mn:00003564
.text$mn:00003564 ; Segment type: Pure code
.text$mn:00003564 ; Segment permissions: Read/Execute
.text$mn:00003564 _text$mn        segment para public 'CODE' use32
.text$mn:00003564                 assume cs:_text$mn
.text$mn:00003564                 ;org 3564h
.text$mn:00003564 ; COMDAT (pick any)
.text$mn:00003564                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003564
.text$mn:00003564 ; =============== S U B R O U T I N E =======================================
.text$mn:00003564
.text$mn:00003564 ; Attributes: bp-based frame
.text$mn:00003564
.text$mn:00003564 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00003564                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00003564 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00003564                                         ; CODE XREF: ToolBar::doPopop(tagPOINT)+B4p
.text$mn:00003564
.text$mn:00003564 var_14          = dword ptr -14h
.text$mn:00003564 var_D           = byte ptr -0Dh
.text$mn:00003564 var_C           = dword ptr -0Ch
.text$mn:00003564 var_4           = dword ptr -4
.text$mn:00003564
.text$mn:00003564                 push    ebp
.text$mn:00003565                 mov     ebp, esp
.text$mn:00003567                 push    0FFFFFFFFh
.text$mn:00003569                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000356E                 mov     eax, large fs:0
.text$mn:00003574                 push    eax
.text$mn:00003575                 sub     esp, 8
.text$mn:00003578                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000357D                 xor     eax, ebp
.text$mn:0000357F                 push    eax
.text$mn:00003580                 lea     eax, [ebp+var_C]
.text$mn:00003583                 mov     large fs:0, eax
.text$mn:00003589                 mov     [ebp+var_14], ecx
.text$mn:0000358C                 lea     ecx, [ebp+var_D]
.text$mn:0000358F                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00003594                 push    eax
.text$mn:00003595                 mov     ecx, [ebp+var_14]
.text$mn:00003598                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:0000359D                 mov     [ebp+var_4], 0
.text$mn:000035A4                 push    0
.text$mn:000035A6                 push    0
.text$mn:000035A8                 mov     ecx, [ebp+var_14]
.text$mn:000035AB                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000035B0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000035B7                 mov     eax, [ebp+var_14]
.text$mn:000035BA                 mov     ecx, [ebp+var_C]
.text$mn:000035BD                 mov     large fs:0, ecx
.text$mn:000035C4                 pop     ecx
.text$mn:000035C5                 mov     esp, ebp
.text$mn:000035C7                 pop     ebp
.text$mn:000035C8                 retn
.text$mn:000035C8 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:000035C8
.text$mn:000035C8 ; ---------------------------------------------------------------------------
.text$mn:000035C9                 align 4
.text$mn:000035C9 _text$mn        ends
.text$mn:000035C9
.text$x:000035CC ; ===========================================================================
.text$x:000035CC
.text$x:000035CC ; Segment type: Pure code
.text$x:000035CC ; Segment permissions: Read/Execute
.text$x:000035CC _text$x         segment para public 'CODE' use32
.text$x:000035CC                 assume cs:_text$x
.text$x:000035CC                 ;org 35CCh
.text$x:000035CC ; COMDAT (pick associative to section at 3564)
.text$x:000035CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000035CC
.text$x:000035CC ; =============== S U B R O U T I N E =======================================
.text$x:000035CC
.text$x:000035CC
.text$x:000035CC __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:000035CC                                         ; DATA XREF: .xdata$x:00007F9Co
.text$x:000035CC                 mov     ecx, [ebp-14h]
.text$x:000035CF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000035CF __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:000035CF
.text$x:000035D4
.text$x:000035D4 ; =============== S U B R O U T I N E =======================================
.text$x:000035D4
.text$x:000035D4
.text$x:000035D4 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:000035D4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:000035D4
.text$x:000035D4 arg_4           = dword ptr  8
.text$x:000035D4
.text$x:000035D4                 mov     edx, [esp+arg_4]
.text$x:000035D8                 lea     eax, [edx+0Ch]
.text$x:000035DB                 mov     ecx, [edx-0Ch]
.text$x:000035DE                 xor     ecx, eax
.text$x:000035E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000035E5                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:000035EA                 jmp     ___CxxFrameHandler3
.text$x:000035EA __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:000035EA
.text$x:000035EA ; ---------------------------------------------------------------------------
.text$x:000035EF                 align 10h
.text$x:000035EF _text$x         ends
.text$x:000035EF
.text$mn:000035F0 ; ===========================================================================
.text$mn:000035F0
.text$mn:000035F0 ; Segment type: Pure code
.text$mn:000035F0 ; Segment permissions: Read/Execute
.text$mn:000035F0 _text$mn        segment para public 'CODE' use32
.text$mn:000035F0                 assume cs:_text$mn
.text$mn:000035F0                 ;org 35F0h
.text$mn:000035F0 ; COMDAT (pick any)
.text$mn:000035F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000035F0
.text$mn:000035F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000035F0
.text$mn:000035F0 ; Attributes: bp-based frame
.text$mn:000035F0
.text$mn:000035F0 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000035F0                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:000035F0 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:000035F0                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:000035F0                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p
.text$mn:000035F0
.text$mn:000035F0 var_4           = dword ptr -4
.text$mn:000035F0
.text$mn:000035F0                 push    ebp
.text$mn:000035F1                 mov     ebp, esp
.text$mn:000035F3                 push    ecx
.text$mn:000035F4                 mov     [ebp+var_4], ecx
.text$mn:000035F7                 mov     eax, [ebp+var_4]
.text$mn:000035FA                 mov     dword ptr [eax], 0
.text$mn:00003600                 mov     eax, [ebp+var_4]
.text$mn:00003603                 mov     esp, ebp
.text$mn:00003605                 pop     ebp
.text$mn:00003606                 retn
.text$mn:00003606 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00003606
.text$mn:00003606 ; ---------------------------------------------------------------------------
.text$mn:00003607                 align 4
.text$mn:00003607 _text$mn        ends
.text$mn:00003607
.text$mn:00003608 ; ===========================================================================
.text$mn:00003608
.text$mn:00003608 ; Segment type: Pure code
.text$mn:00003608 ; Segment permissions: Read/Execute
.text$mn:00003608 _text$mn        segment para public 'CODE' use32
.text$mn:00003608                 assume cs:_text$mn
.text$mn:00003608                 ;org 3608h
.text$mn:00003608 ; COMDAT (pick any)
.text$mn:00003608                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003608
.text$mn:00003608 ; =============== S U B R O U T I N E =======================================
.text$mn:00003608
.text$mn:00003608 ; Attributes: bp-based frame
.text$mn:00003608
.text$mn:00003608 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00003608                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00003608 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00003608                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00003608                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p
.text$mn:00003608
.text$mn:00003608 var_4           = dword ptr -4
.text$mn:00003608
.text$mn:00003608                 push    ebp
.text$mn:00003609                 mov     ebp, esp
.text$mn:0000360B                 push    ecx
.text$mn:0000360C                 mov     [ebp+var_4], ecx
.text$mn:0000360F                 mov     eax, [ebp+var_4]
.text$mn:00003612                 mov     dword ptr [eax], 0
.text$mn:00003618                 mov     ecx, [ebp+var_4]
.text$mn:0000361B                 mov     dword ptr [ecx+4], 0
.text$mn:00003622                 mov     eax, [ebp+var_4]
.text$mn:00003625                 mov     esp, ebp
.text$mn:00003627                 pop     ebp
.text$mn:00003628                 retn
.text$mn:00003628 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00003628
.text$mn:00003628 ; ---------------------------------------------------------------------------
.text$mn:00003629                 align 4
.text$mn:00003629 _text$mn        ends
.text$mn:00003629
.text$mn:0000362C ; ===========================================================================
.text$mn:0000362C
.text$mn:0000362C ; Segment type: Pure code
.text$mn:0000362C ; Segment permissions: Read/Execute
.text$mn:0000362C _text$mn        segment para public 'CODE' use32
.text$mn:0000362C                 assume cs:_text$mn
.text$mn:0000362C                 ;org 362Ch
.text$mn:0000362C ; COMDAT (pick any)
.text$mn:0000362C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000362C
.text$mn:0000362C ; =============== S U B R O U T I N E =======================================
.text$mn:0000362C
.text$mn:0000362C ; Attributes: bp-based frame
.text$mn:0000362C
.text$mn:0000362C ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:0000362C                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000362C ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:0000362C                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:0000362C                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:0000362C
.text$mn:0000362C var_10          = dword ptr -10h
.text$mn:0000362C var_C           = dword ptr -0Ch
.text$mn:0000362C var_4           = dword ptr -4
.text$mn:0000362C
.text$mn:0000362C                 push    ebp
.text$mn:0000362D                 mov     ebp, esp
.text$mn:0000362F                 push    0FFFFFFFFh
.text$mn:00003631                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00003636                 mov     eax, large fs:0
.text$mn:0000363C                 push    eax
.text$mn:0000363D                 push    ecx
.text$mn:0000363E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003643                 xor     eax, ebp
.text$mn:00003645                 push    eax
.text$mn:00003646                 lea     eax, [ebp+var_C]
.text$mn:00003649                 mov     large fs:0, eax
.text$mn:0000364F                 mov     [ebp+var_10], ecx
.text$mn:00003652                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003655                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:0000365A                 mov     [ebp+var_4], 0
.text$mn:00003661                 mov     eax, [ebp+var_10]
.text$mn:00003664                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:0000366A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003671                 mov     eax, [ebp+var_10]
.text$mn:00003674                 mov     ecx, [ebp+var_C]
.text$mn:00003677                 mov     large fs:0, ecx
.text$mn:0000367E                 pop     ecx
.text$mn:0000367F                 mov     esp, ebp
.text$mn:00003681                 pop     ebp
.text$mn:00003682                 retn
.text$mn:00003682 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00003682
.text$mn:00003682 ; ---------------------------------------------------------------------------
.text$mn:00003683                 align 4
.text$mn:00003683 _text$mn        ends
.text$mn:00003683
.text$x:00003684 ; ===========================================================================
.text$x:00003684
.text$x:00003684 ; Segment type: Pure code
.text$x:00003684 ; Segment permissions: Read/Execute
.text$x:00003684 _text$x         segment para public 'CODE' use32
.text$x:00003684                 assume cs:_text$x
.text$x:00003684                 ;org 3684h
.text$x:00003684 ; COMDAT (pick associative to section at 362C)
.text$x:00003684                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003684
.text$x:00003684 ; =============== S U B R O U T I N E =======================================
.text$x:00003684
.text$x:00003684
.text$x:00003684 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00003684                                         ; DATA XREF: .xdata$x:00007D34o
.text$x:00003684                 mov     ecx, [ebp-10h]  ; this
.text$x:00003687                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00003687 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00003687
.text$x:0000368C
.text$x:0000368C ; =============== S U B R O U T I N E =======================================
.text$x:0000368C
.text$x:0000368C
.text$x:0000368C __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:0000368C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:0000368C
.text$x:0000368C arg_4           = dword ptr  8
.text$x:0000368C
.text$x:0000368C                 mov     edx, [esp+arg_4]
.text$x:00003690                 lea     eax, [edx+0Ch]
.text$x:00003693                 mov     ecx, [edx-8]
.text$x:00003696                 xor     ecx, eax
.text$x:00003698                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000369D                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000036A2                 jmp     ___CxxFrameHandler3
.text$x:000036A2 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000036A2
.text$x:000036A2 ; ---------------------------------------------------------------------------
.text$x:000036A7                 align 4
.text$x:000036A7 _text$x         ends
.text$x:000036A7
.text$mn:000036A8 ; ===========================================================================
.text$mn:000036A8
.text$mn:000036A8 ; Segment type: Pure code
.text$mn:000036A8 ; Segment permissions: Read/Execute
.text$mn:000036A8 _text$mn        segment para public 'CODE' use32
.text$mn:000036A8                 assume cs:_text$mn
.text$mn:000036A8                 ;org 36A8h
.text$mn:000036A8 ; COMDAT (pick any)
.text$mn:000036A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036A8
.text$mn:000036A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000036A8
.text$mn:000036A8 ; Attributes: bp-based frame
.text$mn:000036A8
.text$mn:000036A8 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000036A8                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000036A8 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:000036A8                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000036A8
.text$mn:000036A8 var_10          = dword ptr -10h
.text$mn:000036A8 var_C           = dword ptr -0Ch
.text$mn:000036A8 var_4           = dword ptr -4
.text$mn:000036A8
.text$mn:000036A8                 push    ebp
.text$mn:000036A9                 mov     ebp, esp
.text$mn:000036AB                 push    0FFFFFFFFh
.text$mn:000036AD                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000036B2                 mov     eax, large fs:0
.text$mn:000036B8                 push    eax
.text$mn:000036B9                 push    ecx
.text$mn:000036BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000036BF                 xor     eax, ebp
.text$mn:000036C1                 push    eax
.text$mn:000036C2                 lea     eax, [ebp+var_C]
.text$mn:000036C5                 mov     large fs:0, eax
.text$mn:000036CB                 mov     [ebp+var_10], ecx
.text$mn:000036CE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000036D1                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000036D6                 mov     [ebp+var_4], 0
.text$mn:000036DD                 mov     eax, [ebp+var_10]
.text$mn:000036E0                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:000036E6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000036ED                 mov     eax, [ebp+var_10]
.text$mn:000036F0                 mov     ecx, [ebp+var_C]
.text$mn:000036F3                 mov     large fs:0, ecx
.text$mn:000036FA                 pop     ecx
.text$mn:000036FB                 mov     esp, ebp
.text$mn:000036FD                 pop     ebp
.text$mn:000036FE                 retn
.text$mn:000036FE ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:000036FE
.text$mn:000036FE ; ---------------------------------------------------------------------------
.text$mn:000036FF                 align 10h
.text$mn:000036FF _text$mn        ends
.text$mn:000036FF
.text$x:00003700 ; ===========================================================================
.text$x:00003700
.text$x:00003700 ; Segment type: Pure code
.text$x:00003700 ; Segment permissions: Read/Execute
.text$x:00003700 _text$x         segment para public 'CODE' use32
.text$x:00003700                 assume cs:_text$x
.text$x:00003700                 ;org 3700h
.text$x:00003700 ; COMDAT (pick associative to section at 36A8)
.text$x:00003700                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003700
.text$x:00003700 ; =============== S U B R O U T I N E =======================================
.text$x:00003700
.text$x:00003700
.text$x:00003700 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00003700                                         ; DATA XREF: .xdata$x:00007DB8o
.text$x:00003700                 mov     ecx, [ebp-10h]  ; this
.text$x:00003703                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00003703 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00003703
.text$x:00003708
.text$x:00003708 ; =============== S U B R O U T I N E =======================================
.text$x:00003708
.text$x:00003708
.text$x:00003708 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00003708                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00003708
.text$x:00003708 arg_4           = dword ptr  8
.text$x:00003708
.text$x:00003708                 mov     edx, [esp+arg_4]
.text$x:0000370C                 lea     eax, [edx+0Ch]
.text$x:0000370F                 mov     ecx, [edx-8]
.text$x:00003712                 xor     ecx, eax
.text$x:00003714                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003719                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:0000371E                 jmp     ___CxxFrameHandler3
.text$x:0000371E __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:0000371E
.text$x:0000371E ; ---------------------------------------------------------------------------
.text$x:00003723                 align 4
.text$x:00003723 _text$x         ends
.text$x:00003723
.text$mn:00003724 ; ===========================================================================
.text$mn:00003724
.text$mn:00003724 ; Segment type: Pure code
.text$mn:00003724 ; Segment permissions: Read/Execute
.text$mn:00003724 _text$mn        segment para public 'CODE' use32
.text$mn:00003724                 assume cs:_text$mn
.text$mn:00003724                 ;org 3724h
.text$mn:00003724 ; COMDAT (pick any)
.text$mn:00003724                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003724
.text$mn:00003724 ; =============== S U B R O U T I N E =======================================
.text$mn:00003724
.text$mn:00003724 ; Attributes: bp-based frame
.text$mn:00003724
.text$mn:00003724 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:00003724                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:00003724 ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:00003724                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00003724
.text$mn:00003724 var_4           = dword ptr -4
.text$mn:00003724 arg_0           = dword ptr  8
.text$mn:00003724
.text$mn:00003724                 push    ebp
.text$mn:00003725                 mov     ebp, esp
.text$mn:00003727                 push    ecx
.text$mn:00003728                 mov     [ebp+var_4], ecx
.text$mn:0000372B                 mov     eax, [ebp+var_4]
.text$mn:0000372E                 mov     dword ptr [eax], 0
.text$mn:00003734                 mov     ecx, [ebp+var_4]
.text$mn:00003737                 mov     dword ptr [ecx+4], 0
.text$mn:0000373E                 mov     edx, [ebp+arg_0]
.text$mn:00003741                 push    edx
.text$mn:00003742                 mov     ecx, [ebp+var_4]
.text$mn:00003745                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:0000374A                 mov     eax, [ebp+var_4]
.text$mn:0000374D                 mov     esp, ebp
.text$mn:0000374F                 pop     ebp
.text$mn:00003750                 retn    4
.text$mn:00003750 ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:00003750
.text$mn:00003750 ; ---------------------------------------------------------------------------
.text$mn:00003753                 align 4
.text$mn:00003753 _text$mn        ends
.text$mn:00003753
.text$mn:00003754 ; ===========================================================================
.text$mn:00003754
.text$mn:00003754 ; Segment type: Pure code
.text$mn:00003754 ; Segment permissions: Read/Execute
.text$mn:00003754 _text$mn        segment para public 'CODE' use32
.text$mn:00003754                 assume cs:_text$mn
.text$mn:00003754                 ;org 3754h
.text$mn:00003754 ; COMDAT (pick any)
.text$mn:00003754                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003754
.text$mn:00003754 ; =============== S U B R O U T I N E =======================================
.text$mn:00003754
.text$mn:00003754 ; Attributes: bp-based frame
.text$mn:00003754
.text$mn:00003754 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00003754                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:00003754 ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00003754                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)+29p
.text$mn:00003754
.text$mn:00003754 var_4           = dword ptr -4
.text$mn:00003754
.text$mn:00003754                 push    ebp
.text$mn:00003755                 mov     ebp, esp
.text$mn:00003757                 push    ecx
.text$mn:00003758                 mov     [ebp+var_4], ecx
.text$mn:0000375B                 mov     eax, [ebp+var_4]
.text$mn:0000375E                 mov     dword ptr [eax], 0
.text$mn:00003764                 mov     ecx, [ebp+var_4]
.text$mn:00003767                 mov     dword ptr [ecx+4], 0
.text$mn:0000376E                 mov     eax, [ebp+var_4]
.text$mn:00003771                 mov     esp, ebp
.text$mn:00003773                 pop     ebp
.text$mn:00003774                 retn
.text$mn:00003774 ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:00003774
.text$mn:00003774 ; ---------------------------------------------------------------------------
.text$mn:00003775                 align 4
.text$mn:00003775 _text$mn        ends
.text$mn:00003775
.text$mn:00003778 ; ===========================================================================
.text$mn:00003778
.text$mn:00003778 ; Segment type: Pure code
.text$mn:00003778 ; Segment permissions: Read/Execute
.text$mn:00003778 _text$mn        segment para public 'CODE' use32
.text$mn:00003778                 assume cs:_text$mn
.text$mn:00003778                 ;org 3778h
.text$mn:00003778 ; COMDAT (pick any)
.text$mn:00003778                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003778
.text$mn:00003778 ; =============== S U B R O U T I N E =======================================
.text$mn:00003778
.text$mn:00003778 ; Attributes: bp-based frame
.text$mn:00003778
.text$mn:00003778 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00003778                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00003778 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00003778                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00003778
.text$mn:00003778 var_10          = dword ptr -10h
.text$mn:00003778 var_C           = dword ptr -0Ch
.text$mn:00003778 var_4           = dword ptr -4
.text$mn:00003778
.text$mn:00003778                 push    ebp
.text$mn:00003779                 mov     ebp, esp
.text$mn:0000377B                 push    0FFFFFFFFh
.text$mn:0000377D                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00003782                 mov     eax, large fs:0
.text$mn:00003788                 push    eax
.text$mn:00003789                 push    ecx
.text$mn:0000378A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000378F                 xor     eax, ebp
.text$mn:00003791                 push    eax
.text$mn:00003792                 lea     eax, [ebp+var_C]
.text$mn:00003795                 mov     large fs:0, eax
.text$mn:0000379B                 mov     [ebp+var_10], ecx
.text$mn:0000379E                 mov     ecx, [ebp+var_10] ; this
.text$mn:000037A1                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000037A6                 mov     [ebp+var_4], 0
.text$mn:000037AD                 mov     eax, [ebp+var_10]
.text$mn:000037B0                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:000037B6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000037BD                 mov     eax, [ebp+var_10]
.text$mn:000037C0                 mov     ecx, [ebp+var_C]
.text$mn:000037C3                 mov     large fs:0, ecx
.text$mn:000037CA                 pop     ecx
.text$mn:000037CB                 mov     esp, ebp
.text$mn:000037CD                 pop     ebp
.text$mn:000037CE                 retn
.text$mn:000037CE ??0_System_error_category@std@@QAE@XZ endp
.text$mn:000037CE
.text$mn:000037CE ; ---------------------------------------------------------------------------
.text$mn:000037CF                 align 10h
.text$mn:000037CF _text$mn        ends
.text$mn:000037CF
.text$x:000037D0 ; ===========================================================================
.text$x:000037D0
.text$x:000037D0 ; Segment type: Pure code
.text$x:000037D0 ; Segment permissions: Read/Execute
.text$x:000037D0 _text$x         segment para public 'CODE' use32
.text$x:000037D0                 assume cs:_text$x
.text$x:000037D0                 ;org 37D0h
.text$x:000037D0 ; COMDAT (pick associative to section at 3778)
.text$x:000037D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000037D0
.text$x:000037D0 ; =============== S U B R O U T I N E =======================================
.text$x:000037D0
.text$x:000037D0
.text$x:000037D0 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:000037D0                                         ; DATA XREF: .xdata$x:00007E3Co
.text$x:000037D0                 mov     ecx, [ebp-10h]  ; this
.text$x:000037D3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000037D3 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:000037D3
.text$x:000037D8
.text$x:000037D8 ; =============== S U B R O U T I N E =======================================
.text$x:000037D8
.text$x:000037D8
.text$x:000037D8 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000037D8                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000037D8
.text$x:000037D8 arg_4           = dword ptr  8
.text$x:000037D8
.text$x:000037D8                 mov     edx, [esp+arg_4]
.text$x:000037DC                 lea     eax, [edx+0Ch]
.text$x:000037DF                 mov     ecx, [edx-8]
.text$x:000037E2                 xor     ecx, eax
.text$x:000037E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000037E9                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000037EE                 jmp     ___CxxFrameHandler3
.text$x:000037EE __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000037EE
.text$x:000037EE ; ---------------------------------------------------------------------------
.text$x:000037F3                 align 4
.text$x:000037F3 _text$x         ends
.text$x:000037F3
.text$mn:000037F4 ; ===========================================================================
.text$mn:000037F4
.text$mn:000037F4 ; Segment type: Pure code
.text$mn:000037F4 ; Segment permissions: Read/Execute
.text$mn:000037F4 _text$mn        segment para public 'CODE' use32
.text$mn:000037F4                 assume cs:_text$mn
.text$mn:000037F4                 ;org 37F4h
.text$mn:000037F4 ; COMDAT (pick any)
.text$mn:000037F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037F4
.text$mn:000037F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000037F4
.text$mn:000037F4 ; Attributes: bp-based frame
.text$mn:000037F4
.text$mn:000037F4 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000037F4                 public ??0error_category@std@@QAE@XZ
.text$mn:000037F4 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000037F4
.text$mn:000037F4 var_4           = dword ptr -4
.text$mn:000037F4
.text$mn:000037F4                 push    ebp
.text$mn:000037F5                 mov     ebp, esp
.text$mn:000037F7                 push    ecx
.text$mn:000037F8                 mov     [ebp+var_4], ecx
.text$mn:000037FB                 mov     eax, [ebp+var_4]
.text$mn:000037FE                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00003804                 mov     eax, [ebp+var_4]
.text$mn:00003807                 mov     esp, ebp
.text$mn:00003809                 pop     ebp
.text$mn:0000380A                 retn
.text$mn:0000380A ??0error_category@std@@QAE@XZ endp
.text$mn:0000380A
.text$mn:0000380A ; ---------------------------------------------------------------------------
.text$mn:0000380B                 align 4
.text$mn:0000380B _text$mn        ends
.text$mn:0000380B
.text$mn:0000380C ; ===========================================================================
.text$mn:0000380C
.text$mn:0000380C ; Segment type: Pure code
.text$mn:0000380C ; Segment permissions: Read/Execute
.text$mn:0000380C _text$mn        segment para public 'CODE' use32
.text$mn:0000380C                 assume cs:_text$mn
.text$mn:0000380C                 ;org 380Ch
.text$mn:0000380C ; COMDAT (pick any)
.text$mn:0000380C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000380C
.text$mn:0000380C ; =============== S U B R O U T I N E =======================================
.text$mn:0000380C
.text$mn:0000380C ; Attributes: bp-based frame
.text$mn:0000380C
.text$mn:0000380C ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:0000380C                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:0000380C ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:0000380C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:0000380C                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:0000380C
.text$mn:0000380C var_4           = dword ptr -4
.text$mn:0000380C arg_0           = dword ptr  8
.text$mn:0000380C arg_4           = dword ptr  0Ch
.text$mn:0000380C
.text$mn:0000380C                 push    ebp
.text$mn:0000380D                 mov     ebp, esp
.text$mn:0000380F                 push    ecx
.text$mn:00003810                 mov     [ebp+var_4], ecx
.text$mn:00003813                 mov     eax, [ebp+var_4]
.text$mn:00003816                 mov     ecx, [ebp+arg_0]
.text$mn:00003819                 mov     [eax], ecx
.text$mn:0000381B                 mov     edx, [ebp+var_4]
.text$mn:0000381E                 mov     eax, [ebp+arg_4]
.text$mn:00003821                 mov     [edx+4], eax
.text$mn:00003824                 mov     eax, [ebp+var_4]
.text$mn:00003827                 mov     esp, ebp
.text$mn:00003829                 pop     ebp
.text$mn:0000382A                 retn    8
.text$mn:0000382A ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:0000382A
.text$mn:0000382A ; ---------------------------------------------------------------------------
.text$mn:0000382D                 align 10h
.text$mn:0000382D _text$mn        ends
.text$mn:0000382D
.text$mn:00003830 ; ===========================================================================
.text$mn:00003830
.text$mn:00003830 ; Segment type: Pure code
.text$mn:00003830 ; Segment permissions: Read/Execute
.text$mn:00003830 _text$mn        segment para public 'CODE' use32
.text$mn:00003830                 assume cs:_text$mn
.text$mn:00003830                 ;org 3830h
.text$mn:00003830 ; COMDAT (pick any)
.text$mn:00003830                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003830
.text$mn:00003830 ; =============== S U B R O U T I N E =======================================
.text$mn:00003830
.text$mn:00003830 ; Attributes: bp-based frame
.text$mn:00003830
.text$mn:00003830 ; public: __thiscall iconLocator::iconLocator(struct iconLocator const &)
.text$mn:00003830                 public ??0iconLocator@@QAE@ABU0@@Z
.text$mn:00003830 ??0iconLocator@@QAE@ABU0@@Z proc near   ; CODE XREF: std::allocator<iconLocator>::construct<iconLocator,iconLocator>(iconLocator *,iconLocator &&)+56p
.text$mn:00003830
.text$mn:00003830 var_10          = dword ptr -10h
.text$mn:00003830 var_C           = dword ptr -0Ch
.text$mn:00003830 var_4           = dword ptr -4
.text$mn:00003830 arg_0           = dword ptr  8
.text$mn:00003830
.text$mn:00003830                 push    ebp
.text$mn:00003831                 mov     ebp, esp
.text$mn:00003833                 push    0FFFFFFFFh
.text$mn:00003835                 push    offset __ehhandler$??0iconLocator@@QAE@ABU0@@Z
.text$mn:0000383A                 mov     eax, large fs:0
.text$mn:00003840                 push    eax
.text$mn:00003841                 push    ecx
.text$mn:00003842                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003847                 xor     eax, ebp
.text$mn:00003849                 push    eax
.text$mn:0000384A                 lea     eax, [ebp+var_C]
.text$mn:0000384D                 mov     large fs:0, eax
.text$mn:00003853                 mov     [ebp+var_10], ecx
.text$mn:00003856                 mov     eax, [ebp+var_10]
.text$mn:00003859                 mov     ecx, [ebp+arg_0]
.text$mn:0000385C                 mov     edx, [ecx]
.text$mn:0000385E                 mov     [eax], edx
.text$mn:00003860                 mov     eax, [ebp+var_10]
.text$mn:00003863                 mov     ecx, [ebp+arg_0]
.text$mn:00003866                 mov     edx, [ecx+4]
.text$mn:00003869                 mov     [eax+4], edx
.text$mn:0000386C                 mov     eax, [ebp+arg_0]
.text$mn:0000386F                 add     eax, 8
.text$mn:00003872                 push    eax
.text$mn:00003873                 mov     ecx, [ebp+var_10]
.text$mn:00003876                 add     ecx, 8
.text$mn:00003879                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000387E                 mov     [ebp+var_4], 0
.text$mn:00003885                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000388C                 mov     eax, [ebp+var_10]
.text$mn:0000388F                 mov     ecx, [ebp+var_C]
.text$mn:00003892                 mov     large fs:0, ecx
.text$mn:00003899                 pop     ecx
.text$mn:0000389A                 mov     esp, ebp
.text$mn:0000389C                 pop     ebp
.text$mn:0000389D                 retn    4
.text$mn:0000389D ??0iconLocator@@QAE@ABU0@@Z endp
.text$mn:0000389D
.text$mn:0000389D _text$mn        ends
.text$mn:0000389D
.text$x:000038A0 ; ===========================================================================
.text$x:000038A0
.text$x:000038A0 ; Segment type: Pure code
.text$x:000038A0 ; Segment permissions: Read/Execute
.text$x:000038A0 _text$x         segment para public 'CODE' use32
.text$x:000038A0                 assume cs:_text$x
.text$x:000038A0                 ;org 38A0h
.text$x:000038A0 ; COMDAT (pick associative to section at 3830)
.text$x:000038A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000038A0
.text$x:000038A0 ; =============== S U B R O U T I N E =======================================
.text$x:000038A0
.text$x:000038A0
.text$x:000038A0 __unwindfunclet$??0iconLocator@@QAE@ABU0@@Z$0 proc near
.text$x:000038A0                                         ; DATA XREF: .xdata$x:0000810Co
.text$x:000038A0                 mov     ecx, [ebp-10h]
.text$x:000038A3                 add     ecx, 8
.text$x:000038A6                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000038A6 __unwindfunclet$??0iconLocator@@QAE@ABU0@@Z$0 endp
.text$x:000038A6
.text$x:000038AB
.text$x:000038AB ; =============== S U B R O U T I N E =======================================
.text$x:000038AB
.text$x:000038AB
.text$x:000038AB __ehhandler$??0iconLocator@@QAE@ABU0@@Z proc near
.text$x:000038AB                                         ; DATA XREF: iconLocator::iconLocator(iconLocator const &)+5o
.text$x:000038AB
.text$x:000038AB arg_4           = dword ptr  8
.text$x:000038AB
.text$x:000038AB                 mov     edx, [esp+arg_4]
.text$x:000038AF                 lea     eax, [edx+0Ch]
.text$x:000038B2                 mov     ecx, [edx-8]
.text$x:000038B5                 xor     ecx, eax
.text$x:000038B7                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000038BC                 mov     eax, offset __ehfuncinfo$??0iconLocator@@QAE@ABU0@@Z
.text$x:000038C1                 jmp     ___CxxFrameHandler3
.text$x:000038C1 __ehhandler$??0iconLocator@@QAE@ABU0@@Z endp
.text$x:000038C1
.text$x:000038C1 ; ---------------------------------------------------------------------------
.text$x:000038C6                 align 4
.text$x:000038C6 _text$x         ends
.text$x:000038C6
.text$mn:000038C8 ; ===========================================================================
.text$mn:000038C8
.text$mn:000038C8 ; Segment type: Pure code
.text$mn:000038C8 ; Segment permissions: Read/Execute
.text$mn:000038C8 _text$mn        segment para public 'CODE' use32
.text$mn:000038C8                 assume cs:_text$mn
.text$mn:000038C8                 ;org 38C8h
.text$mn:000038C8 ; COMDAT (pick any)
.text$mn:000038C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038C8
.text$mn:000038C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000038C8
.text$mn:000038C8 ; Attributes: bp-based frame
.text$mn:000038C8
.text$mn:000038C8 ; public: __thiscall iconLocator::iconLocator(int, int, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>)
.text$mn:000038C8                 public ??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
.text$mn:000038C8 ??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z proc near
.text$mn:000038C8                                         ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+225p
.text$mn:000038C8                                         ; ToolBar::initTheme(TiXmlDocument *)+33Fp ...
.text$mn:000038C8
.text$mn:000038C8 var_10          = dword ptr -10h
.text$mn:000038C8 var_C           = dword ptr -0Ch
.text$mn:000038C8 var_4           = dword ptr -4
.text$mn:000038C8 arg_0           = dword ptr  8
.text$mn:000038C8 arg_4           = dword ptr  0Ch
.text$mn:000038C8 arg_8           = byte ptr  10h
.text$mn:000038C8
.text$mn:000038C8                 push    ebp
.text$mn:000038C9                 mov     ebp, esp
.text$mn:000038CB                 push    0FFFFFFFFh
.text$mn:000038CD                 push    offset __ehhandler$??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
.text$mn:000038D2                 mov     eax, large fs:0
.text$mn:000038D8                 push    eax
.text$mn:000038D9                 push    ecx
.text$mn:000038DA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000038DF                 xor     eax, ebp
.text$mn:000038E1                 push    eax
.text$mn:000038E2                 lea     eax, [ebp+var_C]
.text$mn:000038E5                 mov     large fs:0, eax
.text$mn:000038EB                 mov     [ebp+var_10], ecx
.text$mn:000038EE                 mov     [ebp+var_4], 0
.text$mn:000038F5                 mov     eax, [ebp+var_10]
.text$mn:000038F8                 mov     ecx, [ebp+arg_0]
.text$mn:000038FB                 mov     [eax], ecx
.text$mn:000038FD                 mov     edx, [ebp+var_10]
.text$mn:00003900                 mov     eax, [ebp+arg_4]
.text$mn:00003903                 mov     [edx+4], eax
.text$mn:00003906                 lea     ecx, [ebp+arg_8]
.text$mn:00003909                 push    ecx
.text$mn:0000390A                 mov     ecx, [ebp+var_10]
.text$mn:0000390D                 add     ecx, 8
.text$mn:00003910                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00003915                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003919                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003920                 lea     ecx, [ebp+arg_8]
.text$mn:00003923                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00003928                 mov     eax, [ebp+var_10]
.text$mn:0000392B                 mov     ecx, [ebp+var_C]
.text$mn:0000392E                 mov     large fs:0, ecx
.text$mn:00003935                 pop     ecx
.text$mn:00003936                 mov     esp, ebp
.text$mn:00003938                 pop     ebp
.text$mn:00003939                 retn    24h
.text$mn:00003939 ??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z endp
.text$mn:00003939
.text$mn:00003939 _text$mn        ends
.text$mn:00003939
.text$x:0000393C ; ===========================================================================
.text$x:0000393C
.text$x:0000393C ; Segment type: Pure code
.text$x:0000393C ; Segment permissions: Read/Execute
.text$x:0000393C _text$x         segment para public 'CODE' use32
.text$x:0000393C                 assume cs:_text$x
.text$x:0000393C                 ;org 393Ch
.text$x:0000393C ; COMDAT (pick associative to section at 38C8)
.text$x:0000393C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000393C
.text$x:0000393C ; =============== S U B R O U T I N E =======================================
.text$x:0000393C
.text$x:0000393C
.text$x:0000393C __unwindfunclet$??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$0 proc near
.text$x:0000393C                                         ; DATA XREF: .xdata$x:000080ACo
.text$x:0000393C                 lea     ecx, [ebp+10h]
.text$x:0000393F                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000393F __unwindfunclet$??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$0 endp
.text$x:0000393F
.text$x:00003944
.text$x:00003944 ; =============== S U B R O U T I N E =======================================
.text$x:00003944
.text$x:00003944
.text$x:00003944 __unwindfunclet$??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$1 proc near
.text$x:00003944                                         ; DATA XREF: .xdata$x:000080B4o
.text$x:00003944                 mov     ecx, [ebp-10h]
.text$x:00003947                 add     ecx, 8
.text$x:0000394A                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000394A __unwindfunclet$??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$1 endp
.text$x:0000394A
.text$x:0000394F
.text$x:0000394F ; =============== S U B R O U T I N E =======================================
.text$x:0000394F
.text$x:0000394F
.text$x:0000394F __ehhandler$??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z proc near
.text$x:0000394F                                         ; DATA XREF: iconLocator::iconLocator(int,int,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>)+5o
.text$x:0000394F
.text$x:0000394F arg_4           = dword ptr  8
.text$x:0000394F
.text$x:0000394F                 mov     edx, [esp+arg_4]
.text$x:00003953                 lea     eax, [edx+0Ch]
.text$x:00003956                 mov     ecx, [edx-8]
.text$x:00003959                 xor     ecx, eax
.text$x:0000395B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003960                 mov     eax, offset __ehfuncinfo$??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
.text$x:00003965                 jmp     ___CxxFrameHandler3
.text$x:00003965 __ehhandler$??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z endp
.text$x:00003965
.text$x:00003965 ; ---------------------------------------------------------------------------
.text$x:0000396A                 align 4
.text$x:0000396A _text$x         ends
.text$x:0000396A
.text$mn:0000396C ; ===========================================================================
.text$mn:0000396C
.text$mn:0000396C ; Segment type: Pure code
.text$mn:0000396C ; Segment permissions: Read/Execute
.text$mn:0000396C _text$mn        segment para public 'CODE' use32
.text$mn:0000396C                 assume cs:_text$mn
.text$mn:0000396C                 ;org 396Ch
.text$mn:0000396C ; COMDAT (pick any)
.text$mn:0000396C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000396C
.text$mn:0000396C ; =============== S U B R O U T I N E =======================================
.text$mn:0000396C
.text$mn:0000396C ; Attributes: bp-based frame
.text$mn:0000396C
.text$mn:0000396C ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:0000396C                 public ??0id@locale@std@@QAE@I@Z
.text$mn:0000396C ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:0000396C                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:0000396C
.text$mn:0000396C var_4           = dword ptr -4
.text$mn:0000396C arg_0           = dword ptr  8
.text$mn:0000396C
.text$mn:0000396C                 push    ebp
.text$mn:0000396D                 mov     ebp, esp
.text$mn:0000396F                 push    ecx
.text$mn:00003970                 mov     [ebp+var_4], ecx
.text$mn:00003973                 mov     eax, [ebp+var_4]
.text$mn:00003976                 mov     ecx, [ebp+arg_0]
.text$mn:00003979                 mov     [eax], ecx
.text$mn:0000397B                 mov     eax, [ebp+var_4]
.text$mn:0000397E                 mov     esp, ebp
.text$mn:00003980                 pop     ebp
.text$mn:00003981                 retn    4
.text$mn:00003981 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00003981
.text$mn:00003981 _text$mn        ends
.text$mn:00003981
.text$mn:00003984 ; ===========================================================================
.text$mn:00003984
.text$mn:00003984 ; Segment type: Pure code
.text$mn:00003984 ; Segment permissions: Read/Execute
.text$mn:00003984 _text$mn        segment para public 'CODE' use32
.text$mn:00003984                 assume cs:_text$mn
.text$mn:00003984                 ;org 3984h
.text$mn:00003984 ; COMDAT (pick any)
.text$mn:00003984                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003984
.text$mn:00003984 ; =============== S U B R O U T I N E =======================================
.text$mn:00003984
.text$mn:00003984 ; Attributes: bp-based frame
.text$mn:00003984
.text$mn:00003984 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:00003984                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00003984 ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:00003984                                         ; DATA XREF: .xdata$x:000088FCo
.text$mn:00003984
.text$mn:00003984 var_10          = dword ptr -10h
.text$mn:00003984 var_C           = dword ptr -0Ch
.text$mn:00003984 var_4           = dword ptr -4
.text$mn:00003984 arg_0           = dword ptr  8
.text$mn:00003984
.text$mn:00003984                 push    ebp
.text$mn:00003985                 mov     ebp, esp
.text$mn:00003987                 push    0FFFFFFFFh
.text$mn:00003989                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:0000398E                 mov     eax, large fs:0
.text$mn:00003994                 push    eax
.text$mn:00003995                 push    ecx
.text$mn:00003996                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000399B                 xor     eax, ebp
.text$mn:0000399D                 push    eax
.text$mn:0000399E                 lea     eax, [ebp+var_C]
.text$mn:000039A1                 mov     large fs:0, eax
.text$mn:000039A7                 mov     [ebp+var_10], ecx
.text$mn:000039AA                 mov     eax, [ebp+arg_0]
.text$mn:000039AD                 push    eax             ; struct std::exception *
.text$mn:000039AE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000039B1                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:000039B6                 mov     [ebp+var_4], 0
.text$mn:000039BD                 mov     ecx, [ebp+var_10]
.text$mn:000039C0                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:000039C6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000039CD                 mov     eax, [ebp+var_10]
.text$mn:000039D0                 mov     ecx, [ebp+var_C]
.text$mn:000039D3                 mov     large fs:0, ecx
.text$mn:000039DA                 pop     ecx
.text$mn:000039DB                 mov     esp, ebp
.text$mn:000039DD                 pop     ebp
.text$mn:000039DE                 retn    4
.text$mn:000039DE ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:000039DE
.text$mn:000039DE ; ---------------------------------------------------------------------------
.text$mn:000039E1                 align 4
.text$mn:000039E1 _text$mn        ends
.text$mn:000039E1
.text$x:000039E4 ; ===========================================================================
.text$x:000039E4
.text$x:000039E4 ; Segment type: Pure code
.text$x:000039E4 ; Segment permissions: Read/Execute
.text$x:000039E4 _text$x         segment para public 'CODE' use32
.text$x:000039E4                 assume cs:_text$x
.text$x:000039E4                 ;org 39E4h
.text$x:000039E4 ; COMDAT (pick associative to section at 3984)
.text$x:000039E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000039E4
.text$x:000039E4 ; =============== S U B R O U T I N E =======================================
.text$x:000039E4
.text$x:000039E4
.text$x:000039E4 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:000039E4                                         ; DATA XREF: .xdata$x:00007D08o
.text$x:000039E4                 mov     ecx, [ebp-10h]  ; this
.text$x:000039E7                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:000039E7 __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:000039E7
.text$x:000039EC
.text$x:000039EC ; =============== S U B R O U T I N E =======================================
.text$x:000039EC
.text$x:000039EC
.text$x:000039EC __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:000039EC                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:000039EC
.text$x:000039EC arg_4           = dword ptr  8
.text$x:000039EC
.text$x:000039EC                 mov     edx, [esp+arg_4]
.text$x:000039F0                 lea     eax, [edx+0Ch]
.text$x:000039F3                 mov     ecx, [edx-8]
.text$x:000039F6                 xor     ecx, eax
.text$x:000039F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000039FD                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:00003A02                 jmp     ___CxxFrameHandler3
.text$x:00003A02 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:00003A02
.text$x:00003A02 ; ---------------------------------------------------------------------------
.text$x:00003A07                 align 4
.text$x:00003A07 _text$x         ends
.text$x:00003A07
.text$mn:00003A08 ; ===========================================================================
.text$mn:00003A08
.text$mn:00003A08 ; Segment type: Pure code
.text$mn:00003A08 ; Segment permissions: Read/Execute
.text$mn:00003A08 _text$mn        segment para public 'CODE' use32
.text$mn:00003A08                 assume cs:_text$mn
.text$mn:00003A08                 ;org 3A08h
.text$mn:00003A08 ; COMDAT (pick any)
.text$mn:00003A08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A08
.text$mn:00003A08 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A08
.text$mn:00003A08 ; Attributes: bp-based frame
.text$mn:00003A08
.text$mn:00003A08 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:00003A08                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:00003A08 ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:00003A08                                         ; CODE XREF: ToolBar::reset(bool)+108p
.text$mn:00003A08
.text$mn:00003A08 var_10          = dword ptr -10h
.text$mn:00003A08 var_C           = dword ptr -0Ch
.text$mn:00003A08 var_4           = dword ptr -4
.text$mn:00003A08 arg_0           = dword ptr  8
.text$mn:00003A08
.text$mn:00003A08                 push    ebp
.text$mn:00003A09                 mov     ebp, esp
.text$mn:00003A0B                 push    0FFFFFFFFh
.text$mn:00003A0D                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:00003A12                 mov     eax, large fs:0
.text$mn:00003A18                 push    eax
.text$mn:00003A19                 push    ecx
.text$mn:00003A1A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003A1F                 xor     eax, ebp
.text$mn:00003A21                 push    eax
.text$mn:00003A22                 lea     eax, [ebp+var_C]
.text$mn:00003A25                 mov     large fs:0, eax
.text$mn:00003A2B                 mov     [ebp+var_10], ecx
.text$mn:00003A2E                 lea     eax, [ebp+arg_0]
.text$mn:00003A31                 push    eax             ; char **
.text$mn:00003A32                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003A35                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:00003A3A                 mov     [ebp+var_4], 0
.text$mn:00003A41                 mov     ecx, [ebp+var_10]
.text$mn:00003A44                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00003A4A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003A51                 mov     eax, [ebp+var_10]
.text$mn:00003A54                 mov     ecx, [ebp+var_C]
.text$mn:00003A57                 mov     large fs:0, ecx
.text$mn:00003A5E                 pop     ecx
.text$mn:00003A5F                 mov     esp, ebp
.text$mn:00003A61                 pop     ebp
.text$mn:00003A62                 retn    4
.text$mn:00003A62 ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:00003A62
.text$mn:00003A62 ; ---------------------------------------------------------------------------
.text$mn:00003A65                 align 4
.text$mn:00003A65 _text$mn        ends
.text$mn:00003A65
.text$x:00003A68 ; ===========================================================================
.text$x:00003A68
.text$x:00003A68 ; Segment type: Pure code
.text$x:00003A68 ; Segment permissions: Read/Execute
.text$x:00003A68 _text$x         segment para public 'CODE' use32
.text$x:00003A68                 assume cs:_text$x
.text$x:00003A68                 ;org 3A68h
.text$x:00003A68 ; COMDAT (pick associative to section at 3A08)
.text$x:00003A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003A68
.text$x:00003A68 ; =============== S U B R O U T I N E =======================================
.text$x:00003A68
.text$x:00003A68
.text$x:00003A68 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:00003A68                                         ; DATA XREF: .xdata$x:00007CB0o
.text$x:00003A68                 mov     ecx, [ebp-10h]  ; this
.text$x:00003A6B                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00003A6B __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:00003A6B
.text$x:00003A70
.text$x:00003A70 ; =============== S U B R O U T I N E =======================================
.text$x:00003A70
.text$x:00003A70
.text$x:00003A70 __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:00003A70                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:00003A70
.text$x:00003A70 arg_4           = dword ptr  8
.text$x:00003A70
.text$x:00003A70                 mov     edx, [esp+arg_4]
.text$x:00003A74                 lea     eax, [edx+0Ch]
.text$x:00003A77                 mov     ecx, [edx-8]
.text$x:00003A7A                 xor     ecx, eax
.text$x:00003A7C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003A81                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:00003A86                 jmp     ___CxxFrameHandler3
.text$x:00003A86 __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:00003A86
.text$x:00003A86 ; ---------------------------------------------------------------------------
.text$x:00003A8B                 align 4
.text$x:00003A8B _text$x         ends
.text$x:00003A8B
.text$mn:00003A8C ; ===========================================================================
.text$mn:00003A8C
.text$mn:00003A8C ; Segment type: Pure code
.text$mn:00003A8C ; Segment permissions: Read/Execute
.text$mn:00003A8C _text$mn        segment para public 'CODE' use32
.text$mn:00003A8C                 assume cs:_text$mn
.text$mn:00003A8C                 ;org 3A8Ch
.text$mn:00003A8C ; COMDAT (pick any)
.text$mn:00003A8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A8C
.text$mn:00003A8C ; =============== S U B R O U T I N E =======================================
.text$mn:00003A8C
.text$mn:00003A8C ; Attributes: bp-based frame
.text$mn:00003A8C
.text$mn:00003A8C ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, int, int, int const *, int const &, struct std::_Iterator_base12>(void)
.text$mn:00003A8C                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003A8C ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00003A8C                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00003A8C                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0+3j ...
.text$mn:00003A8C
.text$mn:00003A8C var_10          = dword ptr -10h
.text$mn:00003A8C var_C           = dword ptr -0Ch
.text$mn:00003A8C var_4           = dword ptr -4
.text$mn:00003A8C
.text$mn:00003A8C                 push    ebp
.text$mn:00003A8D                 mov     ebp, esp
.text$mn:00003A8F                 push    0FFFFFFFFh
.text$mn:00003A91                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003A96                 mov     eax, large fs:0
.text$mn:00003A9C                 push    eax
.text$mn:00003A9D                 push    ecx
.text$mn:00003A9E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003AA3                 xor     eax, ebp
.text$mn:00003AA5                 push    eax
.text$mn:00003AA6                 lea     eax, [ebp+var_C]
.text$mn:00003AA9                 mov     large fs:0, eax
.text$mn:00003AAF                 mov     [ebp+var_10], ecx
.text$mn:00003AB2                 mov     [ebp+var_4], 0
.text$mn:00003AB9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003AC0                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003AC3                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00003AC8                 mov     ecx, [ebp+var_C]
.text$mn:00003ACB                 mov     large fs:0, ecx
.text$mn:00003AD2                 pop     ecx
.text$mn:00003AD3                 mov     esp, ebp
.text$mn:00003AD5                 pop     ebp
.text$mn:00003AD6                 retn
.text$mn:00003AD6 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00003AD6
.text$mn:00003AD6 ; ---------------------------------------------------------------------------
.text$mn:00003AD7                 align 4
.text$mn:00003AD7 _text$mn        ends
.text$mn:00003AD7
.text$x:00003AD8 ; ===========================================================================
.text$x:00003AD8
.text$x:00003AD8 ; Segment type: Pure code
.text$x:00003AD8 ; Segment permissions: Read/Execute
.text$x:00003AD8 _text$x         segment para public 'CODE' use32
.text$x:00003AD8                 assume cs:_text$x
.text$x:00003AD8                 ;org 3AD8h
.text$x:00003AD8 ; COMDAT (pick associative to section at 3A8C)
.text$x:00003AD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003AD8
.text$x:00003AD8 ; =============== S U B R O U T I N E =======================================
.text$x:00003AD8
.text$x:00003AD8
.text$x:00003AD8 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00003AD8                                         ; DATA XREF: .xdata$x:00008460o
.text$x:00003AD8                 mov     ecx, [ebp-10h]  ; this
.text$x:00003ADB                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00003ADB __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00003ADB
.text$x:00003AE0
.text$x:00003AE0 ; =============== S U B R O U T I N E =======================================
.text$x:00003AE0
.text$x:00003AE0
.text$x:00003AE0 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00003AE0                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)+5o
.text$x:00003AE0
.text$x:00003AE0 arg_4           = dword ptr  8
.text$x:00003AE0
.text$x:00003AE0                 mov     edx, [esp+arg_4]
.text$x:00003AE4                 lea     eax, [edx+0Ch]
.text$x:00003AE7                 mov     ecx, [edx-8]
.text$x:00003AEA                 xor     ecx, eax
.text$x:00003AEC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003AF1                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.text$x:00003AF6                 jmp     ___CxxFrameHandler3
.text$x:00003AF6 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00003AF6
.text$x:00003AF6 ; ---------------------------------------------------------------------------
.text$x:00003AFB                 align 4
.text$x:00003AFB _text$x         ends
.text$x:00003AFB
.text$mn:00003AFC ; ===========================================================================
.text$mn:00003AFC
.text$mn:00003AFC ; Segment type: Pure code
.text$mn:00003AFC ; Segment permissions: Read/Execute
.text$mn:00003AFC _text$mn        segment para public 'CODE' use32
.text$mn:00003AFC                 assume cs:_text$mn
.text$mn:00003AFC                 ;org 3AFCh
.text$mn:00003AFC ; COMDAT (pick any)
.text$mn:00003AFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003AFC
.text$mn:00003AFC ; =============== S U B R O U T I N E =======================================
.text$mn:00003AFC
.text$mn:00003AFC ; Attributes: bp-based frame
.text$mn:00003AFC
.text$mn:00003AFC ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00003AFC                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00003AFC ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003AFC                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00003AFC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00003AFC
.text$mn:00003AFC var_10          = dword ptr -10h
.text$mn:00003AFC var_C           = dword ptr -0Ch
.text$mn:00003AFC var_4           = dword ptr -4
.text$mn:00003AFC
.text$mn:00003AFC                 push    ebp
.text$mn:00003AFD                 mov     ebp, esp
.text$mn:00003AFF                 push    0FFFFFFFFh
.text$mn:00003B01                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00003B06                 mov     eax, large fs:0
.text$mn:00003B0C                 push    eax
.text$mn:00003B0D                 push    ecx
.text$mn:00003B0E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003B13                 xor     eax, ebp
.text$mn:00003B15                 push    eax
.text$mn:00003B16                 lea     eax, [ebp+var_C]
.text$mn:00003B19                 mov     large fs:0, eax
.text$mn:00003B1F                 mov     [ebp+var_10], ecx
.text$mn:00003B22                 mov     [ebp+var_4], 0
.text$mn:00003B29                 mov     ecx, [ebp+var_10]
.text$mn:00003B2C                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00003B31                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003B38                 mov     ecx, [ebp+var_10]
.text$mn:00003B3B                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00003B40                 mov     ecx, [ebp+var_C]
.text$mn:00003B43                 mov     large fs:0, ecx
.text$mn:00003B4A                 pop     ecx
.text$mn:00003B4B                 mov     esp, ebp
.text$mn:00003B4D                 pop     ebp
.text$mn:00003B4E                 retn
.text$mn:00003B4E ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003B4E
.text$mn:00003B4E ; ---------------------------------------------------------------------------
.text$mn:00003B4F                 align 10h
.text$mn:00003B4F _text$mn        ends
.text$mn:00003B4F
.text$x:00003B50 ; ===========================================================================
.text$x:00003B50
.text$x:00003B50 ; Segment type: Pure code
.text$x:00003B50 ; Segment permissions: Read/Execute
.text$x:00003B50 _text$x         segment para public 'CODE' use32
.text$x:00003B50                 assume cs:_text$x
.text$x:00003B50                 ;org 3B50h
.text$x:00003B50 ; COMDAT (pick associative to section at 3AFC)
.text$x:00003B50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003B50
.text$x:00003B50 ; =============== S U B R O U T I N E =======================================
.text$x:00003B50
.text$x:00003B50
.text$x:00003B50 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003B50                                         ; DATA XREF: .xdata$x:00007BA0o
.text$x:00003B50                 mov     ecx, [ebp-10h]
.text$x:00003B53                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00003B53 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003B53
.text$x:00003B58
.text$x:00003B58 ; =============== S U B R O U T I N E =======================================
.text$x:00003B58
.text$x:00003B58
.text$x:00003B58 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003B58                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00003B58
.text$x:00003B58 arg_4           = dword ptr  8
.text$x:00003B58
.text$x:00003B58                 mov     edx, [esp+arg_4]
.text$x:00003B5C                 lea     eax, [edx+0Ch]
.text$x:00003B5F                 mov     ecx, [edx-8]
.text$x:00003B62                 xor     ecx, eax
.text$x:00003B64                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003B69                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00003B6E                 jmp     ___CxxFrameHandler3
.text$x:00003B6E __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00003B6E
.text$x:00003B6E ; ---------------------------------------------------------------------------
.text$x:00003B73                 align 4
.text$x:00003B73 _text$x         ends
.text$x:00003B73
.text$mn:00003B74 ; ===========================================================================
.text$mn:00003B74
.text$mn:00003B74 ; Segment type: Pure code
.text$mn:00003B74 ; Segment permissions: Read/Execute
.text$mn:00003B74 _text$mn        segment para public 'CODE' use32
.text$mn:00003B74                 assume cs:_text$mn
.text$mn:00003B74                 ;org 3B74h
.text$mn:00003B74 ; COMDAT (pick any)
.text$mn:00003B74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B74
.text$mn:00003B74 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B74
.text$mn:00003B74 ; Attributes: bp-based frame
.text$mn:00003B74
.text$mn:00003B74 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:00003B74                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00003B74 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003B74                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00003B74                                         ; __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0+3j ...
.text$mn:00003B74
.text$mn:00003B74 var_10          = dword ptr -10h
.text$mn:00003B74 var_C           = dword ptr -0Ch
.text$mn:00003B74 var_4           = dword ptr -4
.text$mn:00003B74
.text$mn:00003B74                 push    ebp
.text$mn:00003B75                 mov     ebp, esp
.text$mn:00003B77                 push    0FFFFFFFFh
.text$mn:00003B79                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00003B7E                 mov     eax, large fs:0
.text$mn:00003B84                 push    eax
.text$mn:00003B85                 push    ecx
.text$mn:00003B86                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003B8B                 xor     eax, ebp
.text$mn:00003B8D                 push    eax
.text$mn:00003B8E                 lea     eax, [ebp+var_C]
.text$mn:00003B91                 mov     large fs:0, eax
.text$mn:00003B97                 mov     [ebp+var_10], ecx
.text$mn:00003B9A                 mov     [ebp+var_4], 0
.text$mn:00003BA1                 mov     ecx, [ebp+var_10]
.text$mn:00003BA4                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00003BA9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003BB0                 mov     ecx, [ebp+var_10]
.text$mn:00003BB3                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00003BB8                 mov     ecx, [ebp+var_C]
.text$mn:00003BBB                 mov     large fs:0, ecx
.text$mn:00003BC2                 pop     ecx
.text$mn:00003BC3                 mov     esp, ebp
.text$mn:00003BC5                 pop     ebp
.text$mn:00003BC6                 retn
.text$mn:00003BC6 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003BC6
.text$mn:00003BC6 ; ---------------------------------------------------------------------------
.text$mn:00003BC7                 align 4
.text$mn:00003BC7 _text$mn        ends
.text$mn:00003BC7
.text$x:00003BC8 ; ===========================================================================
.text$x:00003BC8
.text$x:00003BC8 ; Segment type: Pure code
.text$x:00003BC8 ; Segment permissions: Read/Execute
.text$x:00003BC8 _text$x         segment para public 'CODE' use32
.text$x:00003BC8                 assume cs:_text$x
.text$x:00003BC8                 ;org 3BC8h
.text$x:00003BC8 ; COMDAT (pick associative to section at 3B74)
.text$x:00003BC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003BC8
.text$x:00003BC8 ; =============== S U B R O U T I N E =======================================
.text$x:00003BC8
.text$x:00003BC8
.text$x:00003BC8 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003BC8                                         ; DATA XREF: .xdata$x:00007F44o
.text$x:00003BC8                 mov     ecx, [ebp-10h]
.text$x:00003BCB                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00003BCB __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003BCB
.text$x:00003BD0
.text$x:00003BD0 ; =============== S U B R O U T I N E =======================================
.text$x:00003BD0
.text$x:00003BD0
.text$x:00003BD0 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003BD0                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:00003BD0
.text$x:00003BD0 arg_4           = dword ptr  8
.text$x:00003BD0
.text$x:00003BD0                 mov     edx, [esp+arg_4]
.text$x:00003BD4                 lea     eax, [edx+0Ch]
.text$x:00003BD7                 mov     ecx, [edx-8]
.text$x:00003BDA                 xor     ecx, eax
.text$x:00003BDC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BE1                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:00003BE6                 jmp     ___CxxFrameHandler3
.text$x:00003BE6 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:00003BE6
.text$x:00003BE6 ; ---------------------------------------------------------------------------
.text$x:00003BEB                 align 4
.text$x:00003BEB _text$x         ends
.text$x:00003BEB
.text$mn:00003BEC ; ===========================================================================
.text$mn:00003BEC
.text$mn:00003BEC ; Segment type: Pure code
.text$mn:00003BEC ; Segment permissions: Read/Execute
.text$mn:00003BEC _text$mn        segment para public 'CODE' use32
.text$mn:00003BEC                 assume cs:_text$mn
.text$mn:00003BEC                 ;org 3BECh
.text$mn:00003BEC ; COMDAT (pick any)
.text$mn:00003BEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BEC
.text$mn:00003BEC ; =============== S U B R O U T I N E =======================================
.text$mn:00003BEC
.text$mn:00003BEC ; Attributes: bp-based frame
.text$mn:00003BEC
.text$mn:00003BEC ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00003BEC                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00003BEC ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00003BEC                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00003BEC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00003BEC
.text$mn:00003BEC var_10          = dword ptr -10h
.text$mn:00003BEC var_C           = dword ptr -0Ch
.text$mn:00003BEC var_4           = dword ptr -4
.text$mn:00003BEC
.text$mn:00003BEC                 push    ebp
.text$mn:00003BED                 mov     ebp, esp
.text$mn:00003BEF                 push    0FFFFFFFFh
.text$mn:00003BF1                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00003BF6                 mov     eax, large fs:0
.text$mn:00003BFC                 push    eax
.text$mn:00003BFD                 push    ecx
.text$mn:00003BFE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003C03                 xor     eax, ebp
.text$mn:00003C05                 push    eax
.text$mn:00003C06                 lea     eax, [ebp+var_C]
.text$mn:00003C09                 mov     large fs:0, eax
.text$mn:00003C0F                 mov     [ebp+var_10], ecx
.text$mn:00003C12                 mov     [ebp+var_4], 0
.text$mn:00003C19                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003C20                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003C23                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00003C28                 mov     ecx, [ebp+var_C]
.text$mn:00003C2B                 mov     large fs:0, ecx
.text$mn:00003C32                 pop     ecx
.text$mn:00003C33                 mov     esp, ebp
.text$mn:00003C35                 pop     ebp
.text$mn:00003C36                 retn
.text$mn:00003C36 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00003C36
.text$mn:00003C36 ; ---------------------------------------------------------------------------
.text$mn:00003C37                 align 4
.text$mn:00003C37 _text$mn        ends
.text$mn:00003C37
.text$x:00003C38 ; ===========================================================================
.text$x:00003C38
.text$x:00003C38 ; Segment type: Pure code
.text$x:00003C38 ; Segment permissions: Read/Execute
.text$x:00003C38 _text$x         segment para public 'CODE' use32
.text$x:00003C38                 assume cs:_text$x
.text$x:00003C38                 ;org 3C38h
.text$x:00003C38 ; COMDAT (pick associative to section at 3BEC)
.text$x:00003C38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003C38
.text$x:00003C38 ; =============== S U B R O U T I N E =======================================
.text$x:00003C38
.text$x:00003C38
.text$x:00003C38 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00003C38                                         ; DATA XREF: .xdata$x:00007B48o
.text$x:00003C38                 mov     ecx, [ebp-10h]  ; this
.text$x:00003C3B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00003C3B __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00003C3B
.text$x:00003C40
.text$x:00003C40 ; =============== S U B R O U T I N E =======================================
.text$x:00003C40
.text$x:00003C40
.text$x:00003C40 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00003C40                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00003C40
.text$x:00003C40 arg_4           = dword ptr  8
.text$x:00003C40
.text$x:00003C40                 mov     edx, [esp+arg_4]
.text$x:00003C44                 lea     eax, [edx+0Ch]
.text$x:00003C47                 mov     ecx, [edx-8]
.text$x:00003C4A                 xor     ecx, eax
.text$x:00003C4C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003C51                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00003C56                 jmp     ___CxxFrameHandler3
.text$x:00003C56 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00003C56
.text$x:00003C56 ; ---------------------------------------------------------------------------
.text$x:00003C5B                 align 4
.text$x:00003C5B _text$x         ends
.text$x:00003C5B
.text$mn:00003C5C ; ===========================================================================
.text$mn:00003C5C
.text$mn:00003C5C ; Segment type: Pure code
.text$mn:00003C5C ; Segment permissions: Read/Execute
.text$mn:00003C5C _text$mn        segment para public 'CODE' use32
.text$mn:00003C5C                 assume cs:_text$mn
.text$mn:00003C5C                 ;org 3C5Ch
.text$mn:00003C5C ; COMDAT (pick any)
.text$mn:00003C5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C5C
.text$mn:00003C5C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C5C
.text$mn:00003C5C ; Attributes: bp-based frame
.text$mn:00003C5C
.text$mn:00003C5C ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00003C5C                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00003C5C ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00003C5C                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:00003C5C                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:00003C5C
.text$mn:00003C5C var_10          = dword ptr -10h
.text$mn:00003C5C var_C           = dword ptr -0Ch
.text$mn:00003C5C var_4           = dword ptr -4
.text$mn:00003C5C
.text$mn:00003C5C                 push    ebp
.text$mn:00003C5D                 mov     ebp, esp
.text$mn:00003C5F                 push    0FFFFFFFFh
.text$mn:00003C61                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00003C66                 mov     eax, large fs:0
.text$mn:00003C6C                 push    eax
.text$mn:00003C6D                 push    ecx
.text$mn:00003C6E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003C73                 xor     eax, ebp
.text$mn:00003C75                 push    eax
.text$mn:00003C76                 lea     eax, [ebp+var_C]
.text$mn:00003C79                 mov     large fs:0, eax
.text$mn:00003C7F                 mov     [ebp+var_10], ecx
.text$mn:00003C82                 mov     [ebp+var_4], 0
.text$mn:00003C89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003C90                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003C93                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00003C98                 mov     ecx, [ebp+var_C]
.text$mn:00003C9B                 mov     large fs:0, ecx
.text$mn:00003CA2                 pop     ecx
.text$mn:00003CA3                 mov     esp, ebp
.text$mn:00003CA5                 pop     ebp
.text$mn:00003CA6                 retn
.text$mn:00003CA6 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00003CA6
.text$mn:00003CA6 ; ---------------------------------------------------------------------------
.text$mn:00003CA7                 align 4
.text$mn:00003CA7 _text$mn        ends
.text$mn:00003CA7
.text$x:00003CA8 ; ===========================================================================
.text$x:00003CA8
.text$x:00003CA8 ; Segment type: Pure code
.text$x:00003CA8 ; Segment permissions: Read/Execute
.text$x:00003CA8 _text$x         segment para public 'CODE' use32
.text$x:00003CA8                 assume cs:_text$x
.text$x:00003CA8                 ;org 3CA8h
.text$x:00003CA8 ; COMDAT (pick associative to section at 3C5C)
.text$x:00003CA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003CA8
.text$x:00003CA8 ; =============== S U B R O U T I N E =======================================
.text$x:00003CA8
.text$x:00003CA8
.text$x:00003CA8 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00003CA8                                         ; DATA XREF: .xdata$x:00007EECo
.text$x:00003CA8                 mov     ecx, [ebp-10h]  ; this
.text$x:00003CAB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00003CAB __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00003CAB
.text$x:00003CB0
.text$x:00003CB0 ; =============== S U B R O U T I N E =======================================
.text$x:00003CB0
.text$x:00003CB0
.text$x:00003CB0 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00003CB0                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00003CB0
.text$x:00003CB0 arg_4           = dword ptr  8
.text$x:00003CB0
.text$x:00003CB0                 mov     edx, [esp+arg_4]
.text$x:00003CB4                 lea     eax, [edx+0Ch]
.text$x:00003CB7                 mov     ecx, [edx-8]
.text$x:00003CBA                 xor     ecx, eax
.text$x:00003CBC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003CC1                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00003CC6                 jmp     ___CxxFrameHandler3
.text$x:00003CC6 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00003CC6
.text$x:00003CC6 ; ---------------------------------------------------------------------------
.text$x:00003CCB                 align 4
.text$x:00003CCB _text$x         ends
.text$x:00003CCB
.text$mn:00003CCC ; ===========================================================================
.text$mn:00003CCC
.text$mn:00003CCC ; Segment type: Pure code
.text$mn:00003CCC ; Segment permissions: Read/Execute
.text$mn:00003CCC _text$mn        segment para public 'CODE' use32
.text$mn:00003CCC                 assume cs:_text$mn
.text$mn:00003CCC                 ;org 3CCCh
.text$mn:00003CCC ; COMDAT (pick any)
.text$mn:00003CCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CCC
.text$mn:00003CCC ; =============== S U B R O U T I N E =======================================
.text$mn:00003CCC
.text$mn:00003CCC ; Attributes: bp-based frame
.text$mn:00003CCC
.text$mn:00003CCC ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>(void)
.text$mn:00003CCC                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$mn:00003CCC ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003CCC                                         ; CODE XREF: __unwindfunclet$?releaseID@ReBar@@AAEXH@Z$2+3j
.text$mn:00003CCC                                         ; __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0+3j ...
.text$mn:00003CCC
.text$mn:00003CCC var_10          = dword ptr -10h
.text$mn:00003CCC var_C           = dword ptr -0Ch
.text$mn:00003CCC var_4           = dword ptr -4
.text$mn:00003CCC
.text$mn:00003CCC                 push    ebp
.text$mn:00003CCD                 mov     ebp, esp
.text$mn:00003CCF                 push    0FFFFFFFFh
.text$mn:00003CD1                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$mn:00003CD6                 mov     eax, large fs:0
.text$mn:00003CDC                 push    eax
.text$mn:00003CDD                 push    ecx
.text$mn:00003CDE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003CE3                 xor     eax, ebp
.text$mn:00003CE5                 push    eax
.text$mn:00003CE6                 lea     eax, [ebp+var_C]
.text$mn:00003CE9                 mov     large fs:0, eax
.text$mn:00003CEF                 mov     [ebp+var_10], ecx
.text$mn:00003CF2                 mov     [ebp+var_4], 0
.text$mn:00003CF9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003D00                 mov     ecx, [ebp+var_10]
.text$mn:00003D03                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$mn:00003D08                 mov     ecx, [ebp+var_C]
.text$mn:00003D0B                 mov     large fs:0, ecx
.text$mn:00003D12                 pop     ecx
.text$mn:00003D13                 mov     esp, ebp
.text$mn:00003D15                 pop     ebp
.text$mn:00003D16                 retn
.text$mn:00003D16 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003D16
.text$mn:00003D16 ; ---------------------------------------------------------------------------
.text$mn:00003D17                 align 4
.text$mn:00003D17 _text$mn        ends
.text$mn:00003D17
.text$x:00003D18 ; ===========================================================================
.text$x:00003D18
.text$x:00003D18 ; Segment type: Pure code
.text$x:00003D18 ; Segment permissions: Read/Execute
.text$x:00003D18 _text$x         segment para public 'CODE' use32
.text$x:00003D18                 assume cs:_text$x
.text$x:00003D18                 ;org 3D18h
.text$x:00003D18 ; COMDAT (pick associative to section at 3CCC)
.text$x:00003D18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003D18
.text$x:00003D18 ; =============== S U B R O U T I N E =======================================
.text$x:00003D18
.text$x:00003D18
.text$x:00003D18 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003D18                                         ; DATA XREF: .xdata$x:000084E4o
.text$x:00003D18                 mov     ecx, [ebp-10h]
.text$x:00003D1B                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>(void)
.text$x:00003D1B __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003D1B
.text$x:00003D20
.text$x:00003D20 ; =============== S U B R O U T I N E =======================================
.text$x:00003D20
.text$x:00003D20
.text$x:00003D20 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003D20                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)+5o
.text$x:00003D20
.text$x:00003D20 arg_4           = dword ptr  8
.text$x:00003D20
.text$x:00003D20                 mov     edx, [esp+arg_4]
.text$x:00003D24                 lea     eax, [edx+0Ch]
.text$x:00003D27                 mov     ecx, [edx-8]
.text$x:00003D2A                 xor     ecx, eax
.text$x:00003D2C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003D31                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$x:00003D36                 jmp     ___CxxFrameHandler3
.text$x:00003D36 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ endp
.text$x:00003D36
.text$x:00003D36 ; ---------------------------------------------------------------------------
.text$x:00003D3B                 align 4
.text$x:00003D3B _text$x         ends
.text$x:00003D3B
.text$mn:00003D3C ; ===========================================================================
.text$mn:00003D3C
.text$mn:00003D3C ; Segment type: Pure code
.text$mn:00003D3C ; Segment permissions: Read/Execute
.text$mn:00003D3C _text$mn        segment para public 'CODE' use32
.text$mn:00003D3C                 assume cs:_text$mn
.text$mn:00003D3C                 ;org 3D3Ch
.text$mn:00003D3C ; COMDAT (pick any)
.text$mn:00003D3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D3C
.text$mn:00003D3C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D3C
.text$mn:00003D3C ; Attributes: bp-based frame
.text$mn:00003D3C
.text$mn:00003D3C ; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>(void)
.text$mn:00003D3C                 public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$mn:00003D3C ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003D3C                                         ; CODE XREF: ReBar::releaseID(int)+E1p
.text$mn:00003D3C                                         ; ReBar::releaseID(int)+EDp ...
.text$mn:00003D3C
.text$mn:00003D3C var_10          = dword ptr -10h
.text$mn:00003D3C var_C           = dword ptr -0Ch
.text$mn:00003D3C var_4           = dword ptr -4
.text$mn:00003D3C
.text$mn:00003D3C                 push    ebp
.text$mn:00003D3D                 mov     ebp, esp
.text$mn:00003D3F                 push    0FFFFFFFFh
.text$mn:00003D41                 push    offset __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$mn:00003D46                 mov     eax, large fs:0
.text$mn:00003D4C                 push    eax
.text$mn:00003D4D                 push    ecx
.text$mn:00003D4E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003D53                 xor     eax, ebp
.text$mn:00003D55                 push    eax
.text$mn:00003D56                 lea     eax, [ebp+var_C]
.text$mn:00003D59                 mov     large fs:0, eax
.text$mn:00003D5F                 mov     [ebp+var_10], ecx
.text$mn:00003D62                 mov     [ebp+var_4], 0
.text$mn:00003D69                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003D70                 mov     ecx, [ebp+var_10]
.text$mn:00003D73                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00003D78                 mov     ecx, [ebp+var_C]
.text$mn:00003D7B                 mov     large fs:0, ecx
.text$mn:00003D82                 pop     ecx
.text$mn:00003D83                 mov     esp, ebp
.text$mn:00003D85                 pop     ebp
.text$mn:00003D86                 retn
.text$mn:00003D86 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003D86
.text$mn:00003D86 ; ---------------------------------------------------------------------------
.text$mn:00003D87                 align 4
.text$mn:00003D87 _text$mn        ends
.text$mn:00003D87
.text$x:00003D88 ; ===========================================================================
.text$x:00003D88
.text$x:00003D88 ; Segment type: Pure code
.text$x:00003D88 ; Segment permissions: Read/Execute
.text$x:00003D88 _text$x         segment para public 'CODE' use32
.text$x:00003D88                 assume cs:_text$x
.text$x:00003D88                 ;org 3D88h
.text$x:00003D88 ; COMDAT (pick associative to section at 3D3C)
.text$x:00003D88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003D88
.text$x:00003D88 ; =============== S U B R O U T I N E =======================================
.text$x:00003D88
.text$x:00003D88
.text$x:00003D88 __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003D88                                         ; DATA XREF: .xdata$x:0000859Co
.text$x:00003D88                 mov     ecx, [ebp-10h]
.text$x:00003D8B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00003D8B __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003D8B
.text$x:00003D90
.text$x:00003D90 ; =============== S U B R O U T I N E =======================================
.text$x:00003D90
.text$x:00003D90
.text$x:00003D90 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003D90                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)+5o
.text$x:00003D90
.text$x:00003D90 arg_4           = dword ptr  8
.text$x:00003D90
.text$x:00003D90                 mov     edx, [esp+arg_4]
.text$x:00003D94                 lea     eax, [edx+0Ch]
.text$x:00003D97                 mov     ecx, [edx-8]
.text$x:00003D9A                 xor     ecx, eax
.text$x:00003D9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003DA1                 mov     eax, offset __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.text$x:00003DA6                 jmp     ___CxxFrameHandler3
.text$x:00003DA6 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ endp
.text$x:00003DA6
.text$x:00003DA6 ; ---------------------------------------------------------------------------
.text$x:00003DAB                 align 4
.text$x:00003DAB _text$x         ends
.text$x:00003DAB
.text$mn:00003DAC ; ===========================================================================
.text$mn:00003DAC
.text$mn:00003DAC ; Segment type: Pure code
.text$mn:00003DAC ; Segment permissions: Read/Execute
.text$mn:00003DAC _text$mn        segment para public 'CODE' use32
.text$mn:00003DAC                 assume cs:_text$mn
.text$mn:00003DAC                 ;org 3DACh
.text$mn:00003DAC ; COMDAT (pick any)
.text$mn:00003DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DAC
.text$mn:00003DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00003DAC
.text$mn:00003DAC ; Attributes: bp-based frame
.text$mn:00003DAC
.text$mn:00003DAC ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00003DAC                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00003DAC ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00003DAC                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00003DAC                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00003DAC
.text$mn:00003DAC var_10          = dword ptr -10h
.text$mn:00003DAC var_C           = dword ptr -0Ch
.text$mn:00003DAC var_4           = dword ptr -4
.text$mn:00003DAC
.text$mn:00003DAC                 push    ebp
.text$mn:00003DAD                 mov     ebp, esp
.text$mn:00003DAF                 push    0FFFFFFFFh
.text$mn:00003DB1                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00003DB6                 mov     eax, large fs:0
.text$mn:00003DBC                 push    eax
.text$mn:00003DBD                 push    ecx
.text$mn:00003DBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003DC3                 xor     eax, ebp
.text$mn:00003DC5                 push    eax
.text$mn:00003DC6                 lea     eax, [ebp+var_C]
.text$mn:00003DC9                 mov     large fs:0, eax
.text$mn:00003DCF                 mov     [ebp+var_10], ecx
.text$mn:00003DD2                 mov     [ebp+var_4], 0
.text$mn:00003DD9                 push    0               ; Size
.text$mn:00003DDB                 push    1               ; char
.text$mn:00003DDD                 mov     ecx, [ebp+var_10]
.text$mn:00003DE0                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003DE5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003DEC                 mov     ecx, [ebp+var_10]
.text$mn:00003DEF                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00003DF4                 mov     ecx, [ebp+var_C]
.text$mn:00003DF7                 mov     large fs:0, ecx
.text$mn:00003DFE                 pop     ecx
.text$mn:00003DFF                 mov     esp, ebp
.text$mn:00003E01                 pop     ebp
.text$mn:00003E02                 retn
.text$mn:00003E02 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00003E02
.text$mn:00003E02 ; ---------------------------------------------------------------------------
.text$mn:00003E03                 align 4
.text$mn:00003E03 _text$mn        ends
.text$mn:00003E03
.text$x:00003E04 ; ===========================================================================
.text$x:00003E04
.text$x:00003E04 ; Segment type: Pure code
.text$x:00003E04 ; Segment permissions: Read/Execute
.text$x:00003E04 _text$x         segment para public 'CODE' use32
.text$x:00003E04                 assume cs:_text$x
.text$x:00003E04                 ;org 3E04h
.text$x:00003E04 ; COMDAT (pick associative to section at 3DAC)
.text$x:00003E04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003E04
.text$x:00003E04 ; =============== S U B R O U T I N E =======================================
.text$x:00003E04
.text$x:00003E04
.text$x:00003E04 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00003E04                                         ; DATA XREF: .xdata$x:00007BF8o
.text$x:00003E04                 mov     ecx, [ebp-10h]
.text$x:00003E07                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00003E07 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00003E07
.text$x:00003E0C
.text$x:00003E0C ; =============== S U B R O U T I N E =======================================
.text$x:00003E0C
.text$x:00003E0C
.text$x:00003E0C __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00003E0C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00003E0C
.text$x:00003E0C arg_4           = dword ptr  8
.text$x:00003E0C
.text$x:00003E0C                 mov     edx, [esp+arg_4]
.text$x:00003E10                 lea     eax, [edx+0Ch]
.text$x:00003E13                 mov     ecx, [edx-8]
.text$x:00003E16                 xor     ecx, eax
.text$x:00003E18                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003E1D                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00003E22                 jmp     ___CxxFrameHandler3
.text$x:00003E22 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00003E22
.text$x:00003E22 ; ---------------------------------------------------------------------------
.text$x:00003E27                 align 4
.text$x:00003E27 _text$x         ends
.text$x:00003E27
.text$mn:00003E28 ; ===========================================================================
.text$mn:00003E28
.text$mn:00003E28 ; Segment type: Pure code
.text$mn:00003E28 ; Segment permissions: Read/Execute
.text$mn:00003E28 _text$mn        segment para public 'CODE' use32
.text$mn:00003E28                 assume cs:_text$mn
.text$mn:00003E28                 ;org 3E28h
.text$mn:00003E28 ; COMDAT (pick any)
.text$mn:00003E28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E28
.text$mn:00003E28 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E28
.text$mn:00003E28 ; Attributes: bp-based frame
.text$mn:00003E28
.text$mn:00003E28 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00003E28                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00003E28 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00003E28                                         ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+271p
.text$mn:00003E28                                         ; ToolBar::initTheme(TiXmlDocument *)+38Bp ...
.text$mn:00003E28
.text$mn:00003E28 var_10          = dword ptr -10h
.text$mn:00003E28 var_C           = dword ptr -0Ch
.text$mn:00003E28 var_4           = dword ptr -4
.text$mn:00003E28
.text$mn:00003E28                 push    ebp
.text$mn:00003E29                 mov     ebp, esp
.text$mn:00003E2B                 push    0FFFFFFFFh
.text$mn:00003E2D                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00003E32                 mov     eax, large fs:0
.text$mn:00003E38                 push    eax
.text$mn:00003E39                 push    ecx
.text$mn:00003E3A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003E3F                 xor     eax, ebp
.text$mn:00003E41                 push    eax
.text$mn:00003E42                 lea     eax, [ebp+var_C]
.text$mn:00003E45                 mov     large fs:0, eax
.text$mn:00003E4B                 mov     [ebp+var_10], ecx
.text$mn:00003E4E                 mov     [ebp+var_4], 0
.text$mn:00003E55                 push    0
.text$mn:00003E57                 push    1
.text$mn:00003E59                 mov     ecx, [ebp+var_10]
.text$mn:00003E5C                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00003E61                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003E68                 mov     ecx, [ebp+var_10]
.text$mn:00003E6B                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00003E70                 mov     ecx, [ebp+var_C]
.text$mn:00003E73                 mov     large fs:0, ecx
.text$mn:00003E7A                 pop     ecx
.text$mn:00003E7B                 mov     esp, ebp
.text$mn:00003E7D                 pop     ebp
.text$mn:00003E7E                 retn
.text$mn:00003E7E ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00003E7E
.text$mn:00003E7E ; ---------------------------------------------------------------------------
.text$mn:00003E7F                 align 10h
.text$mn:00003E7F _text$mn        ends
.text$mn:00003E7F
.text$x:00003E80 ; ===========================================================================
.text$x:00003E80
.text$x:00003E80 ; Segment type: Pure code
.text$x:00003E80 ; Segment permissions: Read/Execute
.text$x:00003E80 _text$x         segment para public 'CODE' use32
.text$x:00003E80                 assume cs:_text$x
.text$x:00003E80                 ;org 3E80h
.text$x:00003E80 ; COMDAT (pick associative to section at 3E28)
.text$x:00003E80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003E80
.text$x:00003E80 ; =============== S U B R O U T I N E =======================================
.text$x:00003E80
.text$x:00003E80
.text$x:00003E80 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:00003E80                                         ; DATA XREF: .xdata$x:00007FF4o
.text$x:00003E80                 mov     ecx, [ebp-10h]
.text$x:00003E83                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00003E83 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:00003E83
.text$x:00003E88
.text$x:00003E88 ; =============== S U B R O U T I N E =======================================
.text$x:00003E88
.text$x:00003E88
.text$x:00003E88 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:00003E88                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:00003E88
.text$x:00003E88 arg_4           = dword ptr  8
.text$x:00003E88
.text$x:00003E88                 mov     edx, [esp+arg_4]
.text$x:00003E8C                 lea     eax, [edx+0Ch]
.text$x:00003E8F                 mov     ecx, [edx-8]
.text$x:00003E92                 xor     ecx, eax
.text$x:00003E94                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003E99                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00003E9E                 jmp     ___CxxFrameHandler3
.text$x:00003E9E __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00003E9E
.text$x:00003E9E ; ---------------------------------------------------------------------------
.text$x:00003EA3                 align 4
.text$x:00003EA3 _text$x         ends
.text$x:00003EA3
.text$mn:00003EA4 ; ===========================================================================
.text$mn:00003EA4
.text$mn:00003EA4 ; Segment type: Pure code
.text$mn:00003EA4 ; Segment permissions: Read/Execute
.text$mn:00003EA4 _text$mn        segment para public 'CODE' use32
.text$mn:00003EA4                 assume cs:_text$mn
.text$mn:00003EA4                 ;org 3EA4h
.text$mn:00003EA4 ; COMDAT (pick any)
.text$mn:00003EA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003EA4
.text$mn:00003EA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003EA4
.text$mn:00003EA4 ; Attributes: bp-based frame
.text$mn:00003EA4
.text$mn:00003EA4 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00003EA4                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00003EA4 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00003EA4                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00003EA4                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00003EA4
.text$mn:00003EA4 var_4           = dword ptr -4
.text$mn:00003EA4
.text$mn:00003EA4                 push    ebp
.text$mn:00003EA5                 mov     ebp, esp
.text$mn:00003EA7                 push    ecx
.text$mn:00003EA8                 mov     [ebp+var_4], ecx
.text$mn:00003EAB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003EAE                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00003EB3                 mov     esp, ebp
.text$mn:00003EB5                 pop     ebp
.text$mn:00003EB6                 retn
.text$mn:00003EB6 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00003EB6
.text$mn:00003EB6 ; ---------------------------------------------------------------------------
.text$mn:00003EB7                 align 4
.text$mn:00003EB7 _text$mn        ends
.text$mn:00003EB7
.text$mn:00003EB8 ; ===========================================================================
.text$mn:00003EB8
.text$mn:00003EB8 ; Segment type: Pure code
.text$mn:00003EB8 ; Segment permissions: Read/Execute
.text$mn:00003EB8 _text$mn        segment para public 'CODE' use32
.text$mn:00003EB8                 assume cs:_text$mn
.text$mn:00003EB8                 ;org 3EB8h
.text$mn:00003EB8 ; COMDAT (pick any)
.text$mn:00003EB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003EB8
.text$mn:00003EB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003EB8
.text$mn:00003EB8 ; Attributes: bp-based frame
.text$mn:00003EB8
.text$mn:00003EB8 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00003EB8                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00003EB8 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00003EB8                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00003EB8                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00003EB8
.text$mn:00003EB8 var_10          = dword ptr -10h
.text$mn:00003EB8 var_C           = dword ptr -0Ch
.text$mn:00003EB8 var_4           = dword ptr -4
.text$mn:00003EB8
.text$mn:00003EB8                 push    ebp
.text$mn:00003EB9                 mov     ebp, esp
.text$mn:00003EBB                 push    0FFFFFFFFh
.text$mn:00003EBD                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00003EC2                 mov     eax, large fs:0
.text$mn:00003EC8                 push    eax
.text$mn:00003EC9                 push    ecx
.text$mn:00003ECA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003ECF                 xor     eax, ebp
.text$mn:00003ED1                 push    eax
.text$mn:00003ED2                 lea     eax, [ebp+var_C]
.text$mn:00003ED5                 mov     large fs:0, eax
.text$mn:00003EDB                 mov     [ebp+var_10], ecx
.text$mn:00003EDE                 mov     [ebp+var_4], 0
.text$mn:00003EE5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003EEC                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003EEF                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00003EF4                 mov     ecx, [ebp+var_C]
.text$mn:00003EF7                 mov     large fs:0, ecx
.text$mn:00003EFE                 pop     ecx
.text$mn:00003EFF                 mov     esp, ebp
.text$mn:00003F01                 pop     ebp
.text$mn:00003F02                 retn
.text$mn:00003F02 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00003F02
.text$mn:00003F02 ; ---------------------------------------------------------------------------
.text$mn:00003F03                 align 4
.text$mn:00003F03 _text$mn        ends
.text$mn:00003F03
.text$x:00003F04 ; ===========================================================================
.text$x:00003F04
.text$x:00003F04 ; Segment type: Pure code
.text$x:00003F04 ; Segment permissions: Read/Execute
.text$x:00003F04 _text$x         segment para public 'CODE' use32
.text$x:00003F04                 assume cs:_text$x
.text$x:00003F04                 ;org 3F04h
.text$x:00003F04 ; COMDAT (pick associative to section at 3EB8)
.text$x:00003F04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003F04
.text$x:00003F04 ; =============== S U B R O U T I N E =======================================
.text$x:00003F04
.text$x:00003F04
.text$x:00003F04 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00003F04                                         ; DATA XREF: .xdata$x:00007D8Co
.text$x:00003F04                 mov     ecx, [ebp-10h]  ; this
.text$x:00003F07                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00003F07 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00003F07
.text$x:00003F0C
.text$x:00003F0C ; =============== S U B R O U T I N E =======================================
.text$x:00003F0C
.text$x:00003F0C
.text$x:00003F0C __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00003F0C                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00003F0C
.text$x:00003F0C arg_4           = dword ptr  8
.text$x:00003F0C
.text$x:00003F0C                 mov     edx, [esp+arg_4]
.text$x:00003F10                 lea     eax, [edx+0Ch]
.text$x:00003F13                 mov     ecx, [edx-8]
.text$x:00003F16                 xor     ecx, eax
.text$x:00003F18                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F1D                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00003F22                 jmp     ___CxxFrameHandler3
.text$x:00003F22 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00003F22
.text$x:00003F22 ; ---------------------------------------------------------------------------
.text$x:00003F27                 align 4
.text$x:00003F27 _text$x         ends
.text$x:00003F27
.text$mn:00003F28 ; ===========================================================================
.text$mn:00003F28
.text$mn:00003F28 ; Segment type: Pure code
.text$mn:00003F28 ; Segment permissions: Read/Execute
.text$mn:00003F28 _text$mn        segment para public 'CODE' use32
.text$mn:00003F28                 assume cs:_text$mn
.text$mn:00003F28                 ;org 3F28h
.text$mn:00003F28 ; COMDAT (pick any)
.text$mn:00003F28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F28
.text$mn:00003F28 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F28
.text$mn:00003F28 ; Attributes: bp-based frame
.text$mn:00003F28
.text$mn:00003F28 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00003F28                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00003F28 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00003F28                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00003F28                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00003F28
.text$mn:00003F28 var_10          = dword ptr -10h
.text$mn:00003F28 var_C           = dword ptr -0Ch
.text$mn:00003F28 var_4           = dword ptr -4
.text$mn:00003F28
.text$mn:00003F28                 push    ebp
.text$mn:00003F29                 mov     ebp, esp
.text$mn:00003F2B                 push    0FFFFFFFFh
.text$mn:00003F2D                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00003F32                 mov     eax, large fs:0
.text$mn:00003F38                 push    eax
.text$mn:00003F39                 push    ecx
.text$mn:00003F3A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003F3F                 xor     eax, ebp
.text$mn:00003F41                 push    eax
.text$mn:00003F42                 lea     eax, [ebp+var_C]
.text$mn:00003F45                 mov     large fs:0, eax
.text$mn:00003F4B                 mov     [ebp+var_10], ecx
.text$mn:00003F4E                 mov     [ebp+var_4], 0
.text$mn:00003F55                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003F5C                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003F5F                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00003F64                 mov     ecx, [ebp+var_C]
.text$mn:00003F67                 mov     large fs:0, ecx
.text$mn:00003F6E                 pop     ecx
.text$mn:00003F6F                 mov     esp, ebp
.text$mn:00003F71                 pop     ebp
.text$mn:00003F72                 retn
.text$mn:00003F72 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00003F72
.text$mn:00003F72 ; ---------------------------------------------------------------------------
.text$mn:00003F73                 align 4
.text$mn:00003F73 _text$mn        ends
.text$mn:00003F73
.text$x:00003F74 ; ===========================================================================
.text$x:00003F74
.text$x:00003F74 ; Segment type: Pure code
.text$x:00003F74 ; Segment permissions: Read/Execute
.text$x:00003F74 _text$x         segment para public 'CODE' use32
.text$x:00003F74                 assume cs:_text$x
.text$x:00003F74                 ;org 3F74h
.text$x:00003F74 ; COMDAT (pick associative to section at 3F28)
.text$x:00003F74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003F74
.text$x:00003F74 ; =============== S U B R O U T I N E =======================================
.text$x:00003F74
.text$x:00003F74
.text$x:00003F74 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00003F74                                         ; DATA XREF: .xdata$x:00007E10o
.text$x:00003F74                 mov     ecx, [ebp-10h]  ; this
.text$x:00003F77                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00003F77 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00003F77
.text$x:00003F7C
.text$x:00003F7C ; =============== S U B R O U T I N E =======================================
.text$x:00003F7C
.text$x:00003F7C
.text$x:00003F7C __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00003F7C                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00003F7C
.text$x:00003F7C arg_4           = dword ptr  8
.text$x:00003F7C
.text$x:00003F7C                 mov     edx, [esp+arg_4]
.text$x:00003F80                 lea     eax, [edx+0Ch]
.text$x:00003F83                 mov     ecx, [edx-8]
.text$x:00003F86                 xor     ecx, eax
.text$x:00003F88                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F8D                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00003F92                 jmp     ___CxxFrameHandler3
.text$x:00003F92 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00003F92
.text$x:00003F92 ; ---------------------------------------------------------------------------
.text$x:00003F97                 align 4
.text$x:00003F97 _text$x         ends
.text$x:00003F97
.text$mn:00003F98 ; ===========================================================================
.text$mn:00003F98
.text$mn:00003F98 ; Segment type: Pure code
.text$mn:00003F98 ; Segment permissions: Read/Execute
.text$mn:00003F98 _text$mn        segment para public 'CODE' use32
.text$mn:00003F98                 assume cs:_text$mn
.text$mn:00003F98                 ;org 3F98h
.text$mn:00003F98 ; COMDAT (pick any)
.text$mn:00003F98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F98
.text$mn:00003F98 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F98
.text$mn:00003F98 ; Attributes: bp-based frame
.text$mn:00003F98
.text$mn:00003F98 ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00003F98                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:00003F98 ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00003F98                                         ; CODE XREF: __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0+3j
.text$mn:00003F98                                         ; __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0+3j ...
.text$mn:00003F98
.text$mn:00003F98 var_14          = byte ptr -14h
.text$mn:00003F98 var_10          = dword ptr -10h
.text$mn:00003F98 var_C           = dword ptr -0Ch
.text$mn:00003F98 var_4           = dword ptr -4
.text$mn:00003F98
.text$mn:00003F98                 push    ebp
.text$mn:00003F99                 mov     ebp, esp
.text$mn:00003F9B                 push    0FFFFFFFFh
.text$mn:00003F9D                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:00003FA2                 mov     eax, large fs:0
.text$mn:00003FA8                 push    eax
.text$mn:00003FA9                 sub     esp, 8
.text$mn:00003FAC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003FB1                 xor     eax, ebp
.text$mn:00003FB3                 push    eax
.text$mn:00003FB4                 lea     eax, [ebp+var_C]
.text$mn:00003FB7                 mov     large fs:0, eax
.text$mn:00003FBD                 mov     [ebp+var_10], ecx
.text$mn:00003FC0                 push    3               ; int
.text$mn:00003FC2                 lea     ecx, [ebp+var_14] ; this
.text$mn:00003FC5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00003FCA                 mov     [ebp+var_4], 0
.text$mn:00003FD1                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003FD4                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00003FD9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003FE0                 lea     ecx, [ebp+var_14] ; this
.text$mn:00003FE3                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00003FE8                 mov     ecx, [ebp+var_C]
.text$mn:00003FEB                 mov     large fs:0, ecx
.text$mn:00003FF2                 pop     ecx
.text$mn:00003FF3                 mov     esp, ebp
.text$mn:00003FF5                 pop     ebp
.text$mn:00003FF6                 retn
.text$mn:00003FF6 ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:00003FF6
.text$mn:00003FF6 ; ---------------------------------------------------------------------------
.text$mn:00003FF7                 align 4
.text$mn:00003FF7 _text$mn        ends
.text$mn:00003FF7
.text$x:00003FF8 ; ===========================================================================
.text$x:00003FF8
.text$x:00003FF8 ; Segment type: Pure code
.text$x:00003FF8 ; Segment permissions: Read/Execute
.text$x:00003FF8 _text$x         segment para public 'CODE' use32
.text$x:00003FF8                 assume cs:_text$x
.text$x:00003FF8                 ;org 3FF8h
.text$x:00003FF8 ; COMDAT (pick associative to section at 3F98)
.text$x:00003FF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003FF8
.text$x:00003FF8 ; =============== S U B R O U T I N E =======================================
.text$x:00003FF8
.text$x:00003FF8
.text$x:00003FF8 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:00003FF8                                         ; DATA XREF: .xdata$x:00007ABCo
.text$x:00003FF8                 lea     ecx, [ebp-14h]  ; this
.text$x:00003FFB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00003FFB __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:00003FFB
.text$x:00004000
.text$x:00004000 ; =============== S U B R O U T I N E =======================================
.text$x:00004000
.text$x:00004000
.text$x:00004000 __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:00004000                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:00004000
.text$x:00004000 arg_4           = dword ptr  8
.text$x:00004000
.text$x:00004000                 mov     edx, [esp+arg_4]
.text$x:00004004                 lea     eax, [edx+0Ch]
.text$x:00004007                 mov     ecx, [edx-0Ch]
.text$x:0000400A                 xor     ecx, eax
.text$x:0000400C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004011                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:00004016                 jmp     ___CxxFrameHandler3
.text$x:00004016 __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:00004016
.text$x:00004016 ; ---------------------------------------------------------------------------
.text$x:0000401B                 align 4
.text$x:0000401B _text$x         ends
.text$x:0000401B
.text$mn:0000401C ; ===========================================================================
.text$mn:0000401C
.text$mn:0000401C ; Segment type: Pure code
.text$mn:0000401C ; Segment permissions: Read/Execute
.text$mn:0000401C _text$mn        segment para public 'CODE' use32
.text$mn:0000401C                 assume cs:_text$mn
.text$mn:0000401C                 ;org 401Ch
.text$mn:0000401C ; COMDAT (pick any)
.text$mn:0000401C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000401C
.text$mn:0000401C ; =============== S U B R O U T I N E =======================================
.text$mn:0000401C
.text$mn:0000401C ; Attributes: bp-based frame
.text$mn:0000401C
.text$mn:0000401C ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:0000401C                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:0000401C ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:0000401C                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:0000401C                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:0000401C
.text$mn:0000401C var_10          = dword ptr -10h
.text$mn:0000401C var_C           = dword ptr -0Ch
.text$mn:0000401C var_4           = dword ptr -4
.text$mn:0000401C
.text$mn:0000401C                 push    ebp
.text$mn:0000401D                 mov     ebp, esp
.text$mn:0000401F                 push    0FFFFFFFFh
.text$mn:00004021                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00004026                 mov     eax, large fs:0
.text$mn:0000402C                 push    eax
.text$mn:0000402D                 push    ecx
.text$mn:0000402E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004033                 xor     eax, ebp
.text$mn:00004035                 push    eax
.text$mn:00004036                 lea     eax, [ebp+var_C]
.text$mn:00004039                 mov     large fs:0, eax
.text$mn:0000403F                 mov     [ebp+var_10], ecx
.text$mn:00004042                 mov     [ebp+var_4], 0
.text$mn:00004049                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004050                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004053                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00004058                 mov     ecx, [ebp+var_C]
.text$mn:0000405B                 mov     large fs:0, ecx
.text$mn:00004062                 pop     ecx
.text$mn:00004063                 mov     esp, ebp
.text$mn:00004065                 pop     ebp
.text$mn:00004066                 retn
.text$mn:00004066 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00004066
.text$mn:00004066 ; ---------------------------------------------------------------------------
.text$mn:00004067                 align 4
.text$mn:00004067 _text$mn        ends
.text$mn:00004067
.text$x:00004068 ; ===========================================================================
.text$x:00004068
.text$x:00004068 ; Segment type: Pure code
.text$x:00004068 ; Segment permissions: Read/Execute
.text$x:00004068 _text$x         segment para public 'CODE' use32
.text$x:00004068                 assume cs:_text$x
.text$x:00004068                 ;org 4068h
.text$x:00004068 ; COMDAT (pick associative to section at 401C)
.text$x:00004068                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004068
.text$x:00004068 ; =============== S U B R O U T I N E =======================================
.text$x:00004068
.text$x:00004068
.text$x:00004068 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00004068                                         ; DATA XREF: .xdata$x:00007E94o
.text$x:00004068                 mov     ecx, [ebp-10h]  ; this
.text$x:0000406B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000406B __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000406B
.text$x:00004070
.text$x:00004070 ; =============== S U B R O U T I N E =======================================
.text$x:00004070
.text$x:00004070
.text$x:00004070 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00004070                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00004070
.text$x:00004070 arg_4           = dword ptr  8
.text$x:00004070
.text$x:00004070                 mov     edx, [esp+arg_4]
.text$x:00004074                 lea     eax, [edx+0Ch]
.text$x:00004077                 mov     ecx, [edx-8]
.text$x:0000407A                 xor     ecx, eax
.text$x:0000407C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004081                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00004086                 jmp     ___CxxFrameHandler3
.text$x:00004086 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00004086
.text$x:00004086 ; ---------------------------------------------------------------------------
.text$x:0000408B                 align 4
.text$x:0000408B _text$x         ends
.text$x:0000408B
.text$mn:0000408C ; ===========================================================================
.text$mn:0000408C
.text$mn:0000408C ; Segment type: Pure code
.text$mn:0000408C ; Segment permissions: Read/Execute
.text$mn:0000408C _text$mn        segment para public 'CODE' use32
.text$mn:0000408C                 assume cs:_text$mn
.text$mn:0000408C                 ;org 408Ch
.text$mn:0000408C ; COMDAT (pick any)
.text$mn:0000408C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000408C
.text$mn:0000408C ; =============== S U B R O U T I N E =======================================
.text$mn:0000408C
.text$mn:0000408C ; Attributes: bp-based frame
.text$mn:0000408C
.text$mn:0000408C ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:0000408C                 public ??1error_category@std@@UAE@XZ
.text$mn:0000408C ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:0000408C                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:0000408C
.text$mn:0000408C var_4           = dword ptr -4
.text$mn:0000408C
.text$mn:0000408C                 push    ebp
.text$mn:0000408D                 mov     ebp, esp
.text$mn:0000408F                 push    ecx
.text$mn:00004090                 mov     [ebp+var_4], ecx
.text$mn:00004093                 mov     eax, [ebp+var_4]
.text$mn:00004096                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:0000409C                 mov     esp, ebp
.text$mn:0000409E                 pop     ebp
.text$mn:0000409F                 retn
.text$mn:0000409F ??1error_category@std@@UAE@XZ endp
.text$mn:0000409F
.text$mn:0000409F _text$mn        ends
.text$mn:0000409F
.text$mn:000040A0 ; ===========================================================================
.text$mn:000040A0
.text$mn:000040A0 ; Segment type: Pure code
.text$mn:000040A0 ; Segment permissions: Read/Execute
.text$mn:000040A0 _text$mn        segment para public 'CODE' use32
.text$mn:000040A0                 assume cs:_text$mn
.text$mn:000040A0                 ;org 40A0h
.text$mn:000040A0 ; COMDAT (pick any)
.text$mn:000040A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040A0
.text$mn:000040A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000040A0
.text$mn:000040A0 ; Attributes: bp-based frame
.text$mn:000040A0
.text$mn:000040A0 ; _DWORD __thiscall iconLocator::~iconLocator(iconLocator *__hidden this)
.text$mn:000040A0                 public ??1iconLocator@@QAE@XZ
.text$mn:000040A0 ??1iconLocator@@QAE@XZ proc near        ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+262p
.text$mn:000040A0                                         ; ToolBar::initTheme(TiXmlDocument *)+37Cp ...
.text$mn:000040A0
.text$mn:000040A0 var_10          = dword ptr -10h
.text$mn:000040A0 var_C           = dword ptr -0Ch
.text$mn:000040A0 var_4           = dword ptr -4
.text$mn:000040A0
.text$mn:000040A0                 push    ebp
.text$mn:000040A1                 mov     ebp, esp
.text$mn:000040A3                 push    0FFFFFFFFh
.text$mn:000040A5                 push    offset __ehhandler$??1iconLocator@@QAE@XZ
.text$mn:000040AA                 mov     eax, large fs:0
.text$mn:000040B0                 push    eax
.text$mn:000040B1                 push    ecx
.text$mn:000040B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000040B7                 xor     eax, ebp
.text$mn:000040B9                 push    eax
.text$mn:000040BA                 lea     eax, [ebp+var_C]
.text$mn:000040BD                 mov     large fs:0, eax
.text$mn:000040C3                 mov     [ebp+var_10], ecx
.text$mn:000040C6                 mov     [ebp+var_4], 0
.text$mn:000040CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000040D4                 mov     ecx, [ebp+var_10]
.text$mn:000040D7                 add     ecx, 8
.text$mn:000040DA                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000040DF                 mov     ecx, [ebp+var_C]
.text$mn:000040E2                 mov     large fs:0, ecx
.text$mn:000040E9                 pop     ecx
.text$mn:000040EA                 mov     esp, ebp
.text$mn:000040EC                 pop     ebp
.text$mn:000040ED                 retn
.text$mn:000040ED ??1iconLocator@@QAE@XZ endp
.text$mn:000040ED
.text$mn:000040ED ; ---------------------------------------------------------------------------
.text$mn:000040EE                 align 10h
.text$mn:000040EE _text$mn        ends
.text$mn:000040EE
.text$x:000040F0 ; ===========================================================================
.text$x:000040F0
.text$x:000040F0 ; Segment type: Pure code
.text$x:000040F0 ; Segment permissions: Read/Execute
.text$x:000040F0 _text$x         segment para public 'CODE' use32
.text$x:000040F0                 assume cs:_text$x
.text$x:000040F0                 ;org 40F0h
.text$x:000040F0 ; COMDAT (pick associative to section at 40A0)
.text$x:000040F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000040F0
.text$x:000040F0 ; =============== S U B R O U T I N E =======================================
.text$x:000040F0
.text$x:000040F0
.text$x:000040F0 __unwindfunclet$??1iconLocator@@QAE@XZ$0 proc near
.text$x:000040F0                                         ; DATA XREF: .xdata$x:000080E0o
.text$x:000040F0                 mov     ecx, [ebp-10h]
.text$x:000040F3                 add     ecx, 8
.text$x:000040F6                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000040F6 __unwindfunclet$??1iconLocator@@QAE@XZ$0 endp
.text$x:000040F6
.text$x:000040FB
.text$x:000040FB ; =============== S U B R O U T I N E =======================================
.text$x:000040FB
.text$x:000040FB
.text$x:000040FB __ehhandler$??1iconLocator@@QAE@XZ proc near
.text$x:000040FB                                         ; DATA XREF: iconLocator::~iconLocator(void)+5o
.text$x:000040FB
.text$x:000040FB arg_4           = dword ptr  8
.text$x:000040FB
.text$x:000040FB                 mov     edx, [esp+arg_4]
.text$x:000040FF                 lea     eax, [edx+0Ch]
.text$x:00004102                 mov     ecx, [edx-8]
.text$x:00004105                 xor     ecx, eax
.text$x:00004107                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000410C                 mov     eax, offset __ehfuncinfo$??1iconLocator@@QAE@XZ
.text$x:00004111                 jmp     ___CxxFrameHandler3
.text$x:00004111 __ehhandler$??1iconLocator@@QAE@XZ endp
.text$x:00004111
.text$x:00004111 ; ---------------------------------------------------------------------------
.text$x:00004116                 align 4
.text$x:00004116 _text$x         ends
.text$x:00004116
.text$mn:00004118 ; ===========================================================================
.text$mn:00004118
.text$mn:00004118 ; Segment type: Pure code
.text$mn:00004118 ; Segment permissions: Read/Execute
.text$mn:00004118 _text$mn        segment para public 'CODE' use32
.text$mn:00004118                 assume cs:_text$mn
.text$mn:00004118                 ;org 4118h
.text$mn:00004118 ; COMDAT (pick any)
.text$mn:00004118                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004118
.text$mn:00004118 ; =============== S U B R O U T I N E =======================================
.text$mn:00004118
.text$mn:00004118 ; Attributes: bp-based frame
.text$mn:00004118
.text$mn:00004118 ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:00004118                 public ??1runtime_error@std@@UAE@XZ
.text$mn:00004118 ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+Ap
.text$mn:00004118                                         ; DATA XREF: .xdata$x:000088ACo
.text$mn:00004118
.text$mn:00004118 var_10          = dword ptr -10h
.text$mn:00004118 var_C           = dword ptr -0Ch
.text$mn:00004118 var_4           = dword ptr -4
.text$mn:00004118
.text$mn:00004118                 push    ebp
.text$mn:00004119                 mov     ebp, esp
.text$mn:0000411B                 push    0FFFFFFFFh
.text$mn:0000411D                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:00004122                 mov     eax, large fs:0
.text$mn:00004128                 push    eax
.text$mn:00004129                 push    ecx
.text$mn:0000412A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000412F                 xor     eax, ebp
.text$mn:00004131                 push    eax
.text$mn:00004132                 lea     eax, [ebp+var_C]
.text$mn:00004135                 mov     large fs:0, eax
.text$mn:0000413B                 mov     [ebp+var_10], ecx
.text$mn:0000413E                 mov     [ebp+var_4], 0
.text$mn:00004145                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000414C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000414F                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:00004154                 mov     ecx, [ebp+var_C]
.text$mn:00004157                 mov     large fs:0, ecx
.text$mn:0000415E                 pop     ecx
.text$mn:0000415F                 mov     esp, ebp
.text$mn:00004161                 pop     ebp
.text$mn:00004162                 retn
.text$mn:00004162 ??1runtime_error@std@@UAE@XZ endp
.text$mn:00004162
.text$mn:00004162 ; ---------------------------------------------------------------------------
.text$mn:00004163                 align 4
.text$mn:00004163 _text$mn        ends
.text$mn:00004163
.text$x:00004164 ; ===========================================================================
.text$x:00004164
.text$x:00004164 ; Segment type: Pure code
.text$x:00004164 ; Segment permissions: Read/Execute
.text$x:00004164 _text$x         segment para public 'CODE' use32
.text$x:00004164                 assume cs:_text$x
.text$x:00004164                 ;org 4164h
.text$x:00004164 ; COMDAT (pick associative to section at 4118)
.text$x:00004164                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004164
.text$x:00004164 ; =============== S U B R O U T I N E =======================================
.text$x:00004164
.text$x:00004164
.text$x:00004164 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:00004164                                         ; DATA XREF: .xdata$x:00007CDCo
.text$x:00004164                 mov     ecx, [ebp-10h]  ; this
.text$x:00004167                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00004167 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:00004167
.text$x:0000416C
.text$x:0000416C ; =============== S U B R O U T I N E =======================================
.text$x:0000416C
.text$x:0000416C
.text$x:0000416C __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:0000416C                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:0000416C
.text$x:0000416C arg_4           = dword ptr  8
.text$x:0000416C
.text$x:0000416C                 mov     edx, [esp+arg_4]
.text$x:00004170                 lea     eax, [edx+0Ch]
.text$x:00004173                 mov     ecx, [edx-8]
.text$x:00004176                 xor     ecx, eax
.text$x:00004178                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000417D                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:00004182                 jmp     ___CxxFrameHandler3
.text$x:00004182 __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:00004182
.text$x:00004182 ; ---------------------------------------------------------------------------
.text$x:00004187                 align 4
.text$x:00004187 _text$x         ends
.text$x:00004187
.text$mn:00004188 ; ===========================================================================
.text$mn:00004188
.text$mn:00004188 ; Segment type: Pure code
.text$mn:00004188 ; Segment permissions: Read/Execute
.text$mn:00004188 _text$mn        segment para public 'CODE' use32
.text$mn:00004188                 assume cs:_text$mn
.text$mn:00004188                 ;org 4188h
.text$mn:00004188 ; COMDAT (pick any)
.text$mn:00004188                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004188
.text$mn:00004188 ; =============== S U B R O U T I N E =======================================
.text$mn:00004188
.text$mn:00004188 ; Attributes: bp-based frame
.text$mn:00004188
.text$mn:00004188 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00004188                 public ??2@YAPAXIPAX@Z
.text$mn:00004188 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<int>::construct<int,int &>(int *,int &)+2Ep
.text$mn:00004188                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep ...
.text$mn:00004188
.text$mn:00004188 arg_4           = dword ptr  0Ch
.text$mn:00004188
.text$mn:00004188                 push    ebp
.text$mn:00004189                 mov     ebp, esp
.text$mn:0000418B                 mov     eax, [ebp+arg_4]
.text$mn:0000418E                 pop     ebp
.text$mn:0000418F                 retn
.text$mn:0000418F ??2@YAPAXIPAX@Z endp
.text$mn:0000418F
.text$mn:0000418F _text$mn        ends
.text$mn:0000418F
.text$mn:00004190 ; ===========================================================================
.text$mn:00004190
.text$mn:00004190 ; Segment type: Pure code
.text$mn:00004190 ; Segment permissions: Read/Execute
.text$mn:00004190 _text$mn        segment para public 'CODE' use32
.text$mn:00004190                 assume cs:_text$mn
.text$mn:00004190                 ;org 4190h
.text$mn:00004190 ; COMDAT (pick any)
.text$mn:00004190                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004190
.text$mn:00004190 ; =============== S U B R O U T I N E =======================================
.text$mn:00004190
.text$mn:00004190 ; Attributes: bp-based frame
.text$mn:00004190
.text$mn:00004190 ; void __cdecl operator delete(void *)
.text$mn:00004190                 public ??3@YAXPAX0@Z
.text$mn:00004190 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z$0+8p
.text$mn:00004190                                         ; __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p ...
.text$mn:00004190                 push    ebp
.text$mn:00004191                 mov     ebp, esp
.text$mn:00004193                 pop     ebp
.text$mn:00004194                 retn
.text$mn:00004194 ??3@YAXPAX0@Z   endp
.text$mn:00004194
.text$mn:00004194 ; ---------------------------------------------------------------------------
.text$mn:00004195                 align 4
.text$mn:00004195 _text$mn        ends
.text$mn:00004195
.text$mn:00004198 ; ===========================================================================
.text$mn:00004198
.text$mn:00004198 ; Segment type: Pure code
.text$mn:00004198 ; Segment permissions: Read/Execute
.text$mn:00004198 _text$mn        segment para public 'CODE' use32
.text$mn:00004198                 assume cs:_text$mn
.text$mn:00004198                 ;org 4198h
.text$mn:00004198 ; COMDAT (pick any)
.text$mn:00004198                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004198
.text$mn:00004198 ; =============== S U B R O U T I N E =======================================
.text$mn:00004198
.text$mn:00004198 ; Attributes: bp-based frame
.text$mn:00004198
.text$mn:00004198 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:00004198                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00004198 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:00004198                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:00004198
.text$mn:00004198 var_14          = byte ptr -14h
.text$mn:00004198 var_10          = dword ptr -10h
.text$mn:00004198 var_C           = dword ptr -0Ch
.text$mn:00004198 var_4           = dword ptr -4
.text$mn:00004198 arg_0           = dword ptr  8
.text$mn:00004198
.text$mn:00004198                 push    ebp
.text$mn:00004199                 mov     ebp, esp
.text$mn:0000419B                 push    0FFFFFFFFh
.text$mn:0000419D                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:000041A2                 mov     eax, large fs:0
.text$mn:000041A8                 push    eax
.text$mn:000041A9                 sub     esp, 8
.text$mn:000041AC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000041B1                 xor     eax, ebp
.text$mn:000041B3                 push    eax
.text$mn:000041B4                 lea     eax, [ebp+var_C]
.text$mn:000041B7                 mov     large fs:0, eax
.text$mn:000041BD                 mov     [ebp+var_10], ecx
.text$mn:000041C0                 mov     eax, [ebp+var_10]
.text$mn:000041C3                 mov     ecx, [ebp+arg_0]
.text$mn:000041C6                 mov     edx, [eax]
.text$mn:000041C8                 cmp     edx, [ecx]
.text$mn:000041CA                 jnz     short loc_41CE
.text$mn:000041CC                 jmp     short loc_4210
.text$mn:000041CE ; ---------------------------------------------------------------------------
.text$mn:000041CE
.text$mn:000041CE loc_41CE:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:000041CE                 mov     eax, [ebp+arg_0]
.text$mn:000041D1                 cmp     dword ptr [eax], 0
.text$mn:000041D4                 jz      short loc_41E8
.text$mn:000041D6                 mov     ecx, [ebp+arg_0]
.text$mn:000041D9                 mov     edx, [ecx]
.text$mn:000041DB                 mov     eax, [edx]
.text$mn:000041DD                 push    eax             ; struct std::_Container_base12 *
.text$mn:000041DE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000041E1                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:000041E6                 jmp     short loc_4210
.text$mn:000041E8 ; ---------------------------------------------------------------------------
.text$mn:000041E8
.text$mn:000041E8 loc_41E8:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:000041E8                 push    3               ; int
.text$mn:000041EA                 lea     ecx, [ebp+var_14] ; this
.text$mn:000041ED                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000041F2                 mov     [ebp+var_4], 0
.text$mn:000041F9                 mov     ecx, [ebp+var_10] ; this
.text$mn:000041FC                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00004201                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004208                 lea     ecx, [ebp+var_14] ; this
.text$mn:0000420B                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00004210
.text$mn:00004210 loc_4210:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:00004210                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:00004210                 mov     eax, [ebp+var_10]
.text$mn:00004213                 mov     ecx, [ebp+var_C]
.text$mn:00004216                 mov     large fs:0, ecx
.text$mn:0000421D                 pop     ecx
.text$mn:0000421E                 mov     esp, ebp
.text$mn:00004220                 pop     ebp
.text$mn:00004221                 retn    4
.text$mn:00004221 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:00004221
.text$mn:00004221 _text$mn        ends
.text$mn:00004221
.text$x:00004224 ; ===========================================================================
.text$x:00004224
.text$x:00004224 ; Segment type: Pure code
.text$x:00004224 ; Segment permissions: Read/Execute
.text$x:00004224 _text$x         segment para public 'CODE' use32
.text$x:00004224                 assume cs:_text$x
.text$x:00004224                 ;org 4224h
.text$x:00004224 ; COMDAT (pick associative to section at 4198)
.text$x:00004224                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004224
.text$x:00004224 ; =============== S U B R O U T I N E =======================================
.text$x:00004224
.text$x:00004224
.text$x:00004224 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:00004224                                         ; DATA XREF: .xdata$x:00007A90o
.text$x:00004224                 lea     ecx, [ebp-14h]  ; this
.text$x:00004227                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00004227 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:00004227
.text$x:0000422C
.text$x:0000422C ; =============== S U B R O U T I N E =======================================
.text$x:0000422C
.text$x:0000422C
.text$x:0000422C __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:0000422C                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:0000422C
.text$x:0000422C arg_4           = dword ptr  8
.text$x:0000422C
.text$x:0000422C                 mov     edx, [esp+arg_4]
.text$x:00004230                 lea     eax, [edx+0Ch]
.text$x:00004233                 mov     ecx, [edx-0Ch]
.text$x:00004236                 xor     ecx, eax
.text$x:00004238                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000423D                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:00004242                 jmp     ___CxxFrameHandler3
.text$x:00004242 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:00004242
.text$x:00004242 ; ---------------------------------------------------------------------------
.text$x:00004247                 align 4
.text$x:00004247 _text$x         ends
.text$x:00004247
.text$mn:00004248 ; ===========================================================================
.text$mn:00004248
.text$mn:00004248 ; Segment type: Pure code
.text$mn:00004248 ; Segment permissions: Read/Execute
.text$mn:00004248 _text$mn        segment para public 'CODE' use32
.text$mn:00004248                 assume cs:_text$mn
.text$mn:00004248                 ;org 4248h
.text$mn:00004248 ; COMDAT (pick any)
.text$mn:00004248                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004248
.text$mn:00004248 ; =============== S U B R O U T I N E =======================================
.text$mn:00004248
.text$mn:00004248 ; Attributes: bp-based frame
.text$mn:00004248
.text$mn:00004248 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00004248                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00004248 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00004248                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00004248                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00004248
.text$mn:00004248 var_8           = dword ptr -8
.text$mn:00004248 var_4           = dword ptr -4
.text$mn:00004248 arg_0           = dword ptr  8
.text$mn:00004248
.text$mn:00004248                 push    ebp
.text$mn:00004249                 mov     ebp, esp
.text$mn:0000424B                 sub     esp, 8
.text$mn:0000424E                 mov     [ebp+var_8], ecx
.text$mn:00004251                 mov     eax, [ebp+var_8]
.text$mn:00004254                 cmp     eax, [ebp+arg_0]
.text$mn:00004257                 jnz     short loc_4262
.text$mn:00004259                 mov     [ebp+var_4], 1
.text$mn:00004260                 jmp     short loc_4269
.text$mn:00004262 ; ---------------------------------------------------------------------------
.text$mn:00004262
.text$mn:00004262 loc_4262:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00004262                 mov     [ebp+var_4], 0
.text$mn:00004269
.text$mn:00004269 loc_4269:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00004269                 mov     al, byte ptr [ebp+var_4]
.text$mn:0000426C                 mov     esp, ebp
.text$mn:0000426E                 pop     ebp
.text$mn:0000426F                 retn    4
.text$mn:0000426F ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:0000426F
.text$mn:0000426F ; ---------------------------------------------------------------------------
.text$mn:00004272                 align 4
.text$mn:00004272 _text$mn        ends
.text$mn:00004272
.text$mn:00004274 ; ===========================================================================
.text$mn:00004274
.text$mn:00004274 ; Segment type: Pure code
.text$mn:00004274 ; Segment permissions: Read/Execute
.text$mn:00004274 _text$mn        segment para public 'CODE' use32
.text$mn:00004274                 assume cs:_text$mn
.text$mn:00004274                 ;org 4274h
.text$mn:00004274 ; COMDAT (pick any)
.text$mn:00004274                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004274
.text$mn:00004274 ; =============== S U B R O U T I N E =======================================
.text$mn:00004274
.text$mn:00004274 ; Attributes: bp-based frame
.text$mn:00004274
.text$mn:00004274 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00004274                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00004274 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00004274                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00004274
.text$mn:00004274 var_8           = dword ptr -8
.text$mn:00004274 var_4           = dword ptr -4
.text$mn:00004274 arg_0           = dword ptr  8
.text$mn:00004274
.text$mn:00004274                 push    ebp
.text$mn:00004275                 mov     ebp, esp
.text$mn:00004277                 sub     esp, 8
.text$mn:0000427A                 push    esi
.text$mn:0000427B                 mov     [ebp+var_4], ecx
.text$mn:0000427E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00004281                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00004286                 push    eax
.text$mn:00004287                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000428A                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000428F                 mov     ecx, eax
.text$mn:00004291                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00004296                 movzx   eax, al
.text$mn:00004299                 test    eax, eax
.text$mn:0000429B                 jz      short loc_42BC
.text$mn:0000429D                 mov     ecx, [ebp+var_4] ; this
.text$mn:000042A0                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000042A5                 mov     esi, eax
.text$mn:000042A7                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000042AA                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000042AF                 cmp     esi, eax
.text$mn:000042B1                 jnz     short loc_42BC
.text$mn:000042B3                 mov     [ebp+var_8], 1
.text$mn:000042BA                 jmp     short loc_42C3
.text$mn:000042BC ; ---------------------------------------------------------------------------
.text$mn:000042BC
.text$mn:000042BC loc_42BC:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:000042BC                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:000042BC                 mov     [ebp+var_8], 0
.text$mn:000042C3
.text$mn:000042C3 loc_42C3:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:000042C3                 mov     al, byte ptr [ebp+var_8]
.text$mn:000042C6                 pop     esi
.text$mn:000042C7                 mov     esp, ebp
.text$mn:000042C9                 pop     ebp
.text$mn:000042CA                 retn    4
.text$mn:000042CA ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:000042CA
.text$mn:000042CA ; ---------------------------------------------------------------------------
.text$mn:000042CD                 align 10h
.text$mn:000042CD _text$mn        ends
.text$mn:000042CD
.text$mn:000042D0 ; ===========================================================================
.text$mn:000042D0
.text$mn:000042D0 ; Segment type: Pure code
.text$mn:000042D0 ; Segment permissions: Read/Execute
.text$mn:000042D0 _text$mn        segment para public 'CODE' use32
.text$mn:000042D0                 assume cs:_text$mn
.text$mn:000042D0                 ;org 42D0h
.text$mn:000042D0 ; COMDAT (pick any)
.text$mn:000042D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000042D0
.text$mn:000042D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000042D0
.text$mn:000042D0 ; Attributes: bp-based frame
.text$mn:000042D0
.text$mn:000042D0 ; public: struct ToolBarButtonUnit const & __thiscall std::vector<struct ToolBarButtonUnit, class std::allocator<struct ToolBarButtonUnit>>::operator[](unsigned int)const
.text$mn:000042D0                 public ??A?$vector@UToolBarButtonUnit@@V?$allocator@UToolBarButtonUnit@@@std@@@std@@QBEABUToolBarButtonUnit@@I@Z
.text$mn:000042D0 ??A?$vector@UToolBarButtonUnit@@V?$allocator@UToolBarButtonUnit@@@std@@@std@@QBEABUToolBarButtonUnit@@I@Z proc near
.text$mn:000042D0                                         ; CODE XREF: ToolBarIcons::getStdIconAt(int)+11p
.text$mn:000042D0
.text$mn:000042D0 var_4           = dword ptr -4
.text$mn:000042D0 arg_0           = dword ptr  8
.text$mn:000042D0
.text$mn:000042D0                 push    ebp
.text$mn:000042D1                 mov     ebp, esp
.text$mn:000042D3                 push    ecx
.text$mn:000042D4                 mov     [ebp+var_4], ecx
.text$mn:000042D7                 mov     ecx, [ebp+var_4]
.text$mn:000042DA                 call    ?size@?$vector@UToolBarButtonUnit@@V?$allocator@UToolBarButtonUnit@@@std@@@std@@QBEIXZ ; std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::size(void)
.text$mn:000042DF                 cmp     eax, [ebp+arg_0]
.text$mn:000042E2                 ja      short loc_434C
.text$mn:000042E4                 push    4A1h            ; unsigned int
.text$mn:000042E9                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000042EE                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:000042F3                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000042F8                 add     esp, 0Ch
.text$mn:000042FB                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00004300                 test    eax, eax
.text$mn:00004302                 jz      short loc_4308
.text$mn:00004304                 xor     ecx, ecx
.text$mn:00004306                 jnz     short loc_432E
.text$mn:00004308
.text$mn:00004308 loc_4308:                               ; CODE XREF: std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)+32j
.text$mn:00004308                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000430D                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00004312                 push    0
.text$mn:00004314                 push    4A2h
.text$mn:00004319                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000431E                 push    2
.text$mn:00004320                 call    __CrtDbgReportW
.text$mn:00004325                 add     esp, 18h
.text$mn:00004328                 cmp     eax, 1
.text$mn:0000432B                 jnz     short loc_432E
.text$mn:0000432D                 int     3               ; Trap to Debugger
.text$mn:0000432E
.text$mn:0000432E loc_432E:                               ; CODE XREF: std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)+36j
.text$mn:0000432E                                         ; std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)+5Bj
.text$mn:0000432E                 push    0
.text$mn:00004330                 push    4A2h
.text$mn:00004335                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000433A                 push    offset ??_C@_1MG@CCKBFFHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAT?$AAo?$AAo?$AAl?$AAB?$AAa?$AAr?$AAB?$AAu?$AAt?$AAt?$AAo?$AAn@ ; "std::vector<struct ToolBarButtonUnit,cl"...
.text$mn:0000433F                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00004344                 call    __invalid_parameter
.text$mn:00004349                 add     esp, 14h
.text$mn:0000434C
.text$mn:0000434C loc_434C:                               ; CODE XREF: std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)+12j
.text$mn:0000434C                 imul    eax, [ebp+arg_0], 14h
.text$mn:00004350                 mov     ecx, [ebp+var_4]
.text$mn:00004353                 add     eax, [ecx+4]
.text$mn:00004356                 mov     esp, ebp
.text$mn:00004358                 pop     ebp
.text$mn:00004359                 retn    4
.text$mn:00004359 ??A?$vector@UToolBarButtonUnit@@V?$allocator@UToolBarButtonUnit@@@std@@@std@@QBEABUToolBarButtonUnit@@I@Z endp
.text$mn:00004359
.text$mn:00004359 _text$mn        ends
.text$mn:00004359
.text$mn:0000435C ; ===========================================================================
.text$mn:0000435C
.text$mn:0000435C ; Segment type: Pure code
.text$mn:0000435C ; Segment permissions: Read/Execute
.text$mn:0000435C _text$mn        segment para public 'CODE' use32
.text$mn:0000435C                 assume cs:_text$mn
.text$mn:0000435C                 ;org 435Ch
.text$mn:0000435C ; COMDAT (pick any)
.text$mn:0000435C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000435C
.text$mn:0000435C ; =============== S U B R O U T I N E =======================================
.text$mn:0000435C
.text$mn:0000435C ; Attributes: bp-based frame
.text$mn:0000435C
.text$mn:0000435C ; public: struct tDynamicList & __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::operator[](unsigned int)
.text$mn:0000435C                 public ??A?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QAEAAUtDynamicList@@I@Z
.text$mn:0000435C ??A?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QAEAAUtDynamicList@@I@Z proc near
.text$mn:0000435C                                         ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+2B7p
.text$mn:0000435C
.text$mn:0000435C var_4           = dword ptr -4
.text$mn:0000435C arg_0           = dword ptr  8
.text$mn:0000435C
.text$mn:0000435C                 push    ebp
.text$mn:0000435D                 mov     ebp, esp
.text$mn:0000435F                 push    ecx
.text$mn:00004360                 mov     [ebp+var_4], ecx
.text$mn:00004363                 mov     ecx, [ebp+var_4]
.text$mn:00004366                 call    ?size@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ ; std::vector<tDynamicList,std::allocator<tDynamicList>>::size(void)
.text$mn:0000436B                 cmp     eax, [ebp+arg_0]
.text$mn:0000436E                 ja      short loc_43D8
.text$mn:00004370                 push    4B1h            ; unsigned int
.text$mn:00004375                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000437A                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:0000437F                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00004384                 add     esp, 0Ch
.text$mn:00004387                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:0000438C                 test    eax, eax
.text$mn:0000438E                 jz      short loc_4394
.text$mn:00004390                 xor     ecx, ecx
.text$mn:00004392                 jnz     short loc_43BA
.text$mn:00004394
.text$mn:00004394 loc_4394:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::operator[](uint)+32j
.text$mn:00004394                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00004399                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000439E                 push    0
.text$mn:000043A0                 push    4B2h
.text$mn:000043A5                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000043AA                 push    2
.text$mn:000043AC                 call    __CrtDbgReportW
.text$mn:000043B1                 add     esp, 18h
.text$mn:000043B4                 cmp     eax, 1
.text$mn:000043B7                 jnz     short loc_43BA
.text$mn:000043B9                 int     3               ; Trap to Debugger
.text$mn:000043BA
.text$mn:000043BA loc_43BA:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::operator[](uint)+36j
.text$mn:000043BA                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::operator[](uint)+5Bj
.text$mn:000043BA                 push    0
.text$mn:000043BC                 push    4B2h
.text$mn:000043C1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000043C6                 push    offset ??_C@_1LC@PNCOBLPJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAt?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AAL?$AAi?$AAs?$AAt?$AA?0@ ; "std::vector<struct tDynamicList,class s"...
.text$mn:000043CB                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000043D0                 call    __invalid_parameter
.text$mn:000043D5                 add     esp, 14h
.text$mn:000043D8
.text$mn:000043D8 loc_43D8:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::operator[](uint)+12j
.text$mn:000043D8                 imul    eax, [ebp+arg_0], 0Ch
.text$mn:000043DC                 mov     ecx, [ebp+var_4]
.text$mn:000043DF                 add     eax, [ecx+4]
.text$mn:000043E2                 mov     esp, ebp
.text$mn:000043E4                 pop     ebp
.text$mn:000043E5                 retn    4
.text$mn:000043E5 ??A?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QAEAAUtDynamicList@@I@Z endp
.text$mn:000043E5
.text$mn:000043E5 _text$mn        ends
.text$mn:000043E5
.text$mn:000043E8 ; ===========================================================================
.text$mn:000043E8
.text$mn:000043E8 ; Segment type: Pure code
.text$mn:000043E8 ; Segment permissions: Read/Execute
.text$mn:000043E8 _text$mn        segment para public 'CODE' use32
.text$mn:000043E8                 assume cs:_text$mn
.text$mn:000043E8                 ;org 43E8h
.text$mn:000043E8 ; COMDAT (pick any)
.text$mn:000043E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043E8
.text$mn:000043E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000043E8
.text$mn:000043E8 ; Attributes: bp-based frame
.text$mn:000043E8
.text$mn:000043E8 ; public: class IconList const & __thiscall std::vector<class IconList, class std::allocator<class IconList>>::operator[](unsigned int)const
.text$mn:000043E8                 public ??A?$vector@VIconList@@V?$allocator@VIconList@@@std@@@std@@QBEABVIconList@@I@Z
.text$mn:000043E8 ??A?$vector@VIconList@@V?$allocator@VIconList@@@std@@@std@@QBEABVIconList@@I@Z proc near
.text$mn:000043E8                                         ; CODE XREF: IconLists::getImageListHandle(int)+Ep
.text$mn:000043E8
.text$mn:000043E8 var_4           = dword ptr -4
.text$mn:000043E8 arg_0           = dword ptr  8
.text$mn:000043E8
.text$mn:000043E8                 push    ebp
.text$mn:000043E9                 mov     ebp, esp
.text$mn:000043EB                 push    ecx
.text$mn:000043EC                 mov     [ebp+var_4], ecx
.text$mn:000043EF                 mov     ecx, [ebp+var_4]
.text$mn:000043F2                 call    ?size@?$vector@VIconList@@V?$allocator@VIconList@@@std@@@std@@QBEIXZ ; std::vector<IconList,std::allocator<IconList>>::size(void)
.text$mn:000043F7                 cmp     eax, [ebp+arg_0]
.text$mn:000043FA                 ja      short loc_4464
.text$mn:000043FC                 push    4A1h            ; unsigned int
.text$mn:00004401                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004406                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:0000440B                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00004410                 add     esp, 0Ch
.text$mn:00004413                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00004418                 test    eax, eax
.text$mn:0000441A                 jz      short loc_4420
.text$mn:0000441C                 xor     ecx, ecx
.text$mn:0000441E                 jnz     short loc_4446
.text$mn:00004420
.text$mn:00004420 loc_4420:                               ; CODE XREF: std::vector<IconList,std::allocator<IconList>>::operator[](uint)+32j
.text$mn:00004420                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00004425                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000442A                 push    0
.text$mn:0000442C                 push    4A2h
.text$mn:00004431                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004436                 push    2
.text$mn:00004438                 call    __CrtDbgReportW
.text$mn:0000443D                 add     esp, 18h
.text$mn:00004440                 cmp     eax, 1
.text$mn:00004443                 jnz     short loc_4446
.text$mn:00004445                 int     3               ; Trap to Debugger
.text$mn:00004446
.text$mn:00004446 loc_4446:                               ; CODE XREF: std::vector<IconList,std::allocator<IconList>>::operator[](uint)+36j
.text$mn:00004446                                         ; std::vector<IconList,std::allocator<IconList>>::operator[](uint)+5Bj
.text$mn:00004446                 push    0
.text$mn:00004448                 push    4A2h
.text$mn:0000444D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004452                 push    offset ??_C@_1JO@BHIHLBBA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAI?$AAc?$AAo?$AAn?$AAL?$AAi?$AAs?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@ ; "std::vector<class IconList,class std::a"...
.text$mn:00004457                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:0000445C                 call    __invalid_parameter
.text$mn:00004461                 add     esp, 14h
.text$mn:00004464
.text$mn:00004464 loc_4464:                               ; CODE XREF: std::vector<IconList,std::allocator<IconList>>::operator[](uint)+12j
.text$mn:00004464                 imul    eax, [ebp+arg_0], 14h
.text$mn:00004468                 mov     ecx, [ebp+var_4]
.text$mn:0000446B                 add     eax, [ecx+4]
.text$mn:0000446E                 mov     esp, ebp
.text$mn:00004470                 pop     ebp
.text$mn:00004471                 retn    4
.text$mn:00004471 ??A?$vector@VIconList@@V?$allocator@VIconList@@@std@@@std@@QBEABVIconList@@I@Z endp
.text$mn:00004471
.text$mn:00004471 _text$mn        ends
.text$mn:00004471
.text$mn:00004474 ; ===========================================================================
.text$mn:00004474
.text$mn:00004474 ; Segment type: Pure code
.text$mn:00004474 ; Segment permissions: Read/Execute
.text$mn:00004474 _text$mn        segment para public 'CODE' use32
.text$mn:00004474                 assume cs:_text$mn
.text$mn:00004474                 ;org 4474h
.text$mn:00004474 ; COMDAT (pick any)
.text$mn:00004474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004474
.text$mn:00004474 ; =============== S U B R O U T I N E =======================================
.text$mn:00004474
.text$mn:00004474 ; Attributes: bp-based frame
.text$mn:00004474
.text$mn:00004474 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator+(int)const
.text$mn:00004474                 public ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00004474 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:00004474                                         ; CODE XREF: ReBar::releaseID(int)+98p
.text$mn:00004474
.text$mn:00004474 var_20          = byte ptr -20h
.text$mn:00004474 var_14          = dword ptr -14h
.text$mn:00004474 var_10          = dword ptr -10h
.text$mn:00004474 var_C           = dword ptr -0Ch
.text$mn:00004474 var_4           = dword ptr -4
.text$mn:00004474 arg_0           = dword ptr  8
.text$mn:00004474 arg_4           = dword ptr  0Ch
.text$mn:00004474
.text$mn:00004474                 push    ebp
.text$mn:00004475                 mov     ebp, esp
.text$mn:00004477                 push    0FFFFFFFFh
.text$mn:00004479                 push    offset __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:0000447E                 mov     eax, large fs:0
.text$mn:00004484                 push    eax
.text$mn:00004485                 sub     esp, 14h
.text$mn:00004488                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000448D                 xor     eax, ebp
.text$mn:0000448F                 push    eax
.text$mn:00004490                 lea     eax, [ebp+var_C]
.text$mn:00004493                 mov     large fs:0, eax
.text$mn:00004499                 mov     [ebp+var_14], ecx
.text$mn:0000449C                 mov     [ebp+var_10], 0
.text$mn:000044A3                 mov     eax, [ebp+var_14]
.text$mn:000044A6                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000044A7                 lea     ecx, [ebp+var_20]
.text$mn:000044AA                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:000044AF                 mov     [ebp+var_4], 1
.text$mn:000044B6                 mov     ecx, [ebp+arg_4]
.text$mn:000044B9                 push    ecx
.text$mn:000044BA                 lea     ecx, [ebp+var_20]
.text$mn:000044BD                 call    ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+=(int)
.text$mn:000044C2                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000044C3                 mov     ecx, [ebp+arg_0]
.text$mn:000044C6                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:000044CB                 mov     edx, [ebp+var_10]
.text$mn:000044CE                 or      edx, 1
.text$mn:000044D1                 mov     [ebp+var_10], edx
.text$mn:000044D4                 mov     byte ptr [ebp+var_4], 0
.text$mn:000044D8                 lea     ecx, [ebp+var_20]
.text$mn:000044DB                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:000044E0                 mov     eax, [ebp+arg_0]
.text$mn:000044E3                 mov     ecx, [ebp+var_C]
.text$mn:000044E6                 mov     large fs:0, ecx
.text$mn:000044ED                 pop     ecx
.text$mn:000044EE                 mov     esp, ebp
.text$mn:000044F0                 pop     ebp
.text$mn:000044F1                 retn    8
.text$mn:000044F1 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:000044F1
.text$mn:000044F1 _text$mn        ends
.text$mn:000044F1
.text$x:000044F4 ; ===========================================================================
.text$x:000044F4
.text$x:000044F4 ; Segment type: Pure code
.text$x:000044F4 ; Segment permissions: Read/Execute
.text$x:000044F4 _text$x         segment para public 'CODE' use32
.text$x:000044F4                 assume cs:_text$x
.text$x:000044F4                 ;org 44F4h
.text$x:000044F4 ; COMDAT (pick associative to section at 4474)
.text$x:000044F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000044F4
.text$x:000044F4 ; =============== S U B R O U T I N E =======================================
.text$x:000044F4
.text$x:000044F4
.text$x:000044F4 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:000044F4                                         ; DATA XREF: .xdata$x:00008570o
.text$x:000044F4                 lea     ecx, [ebp-20h]
.text$x:000044F7                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:000044F7 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:000044F7
.text$x:000044FC
.text$x:000044FC ; =============== S U B R O U T I N E =======================================
.text$x:000044FC
.text$x:000044FC
.text$x:000044FC __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:000044FC                                         ; DATA XREF: .xdata$x:00008568o
.text$x:000044FC                 mov     eax, [ebp-10h]
.text$x:000044FF                 and     eax, 1
.text$x:00004502                 jz      $LN5_0
.text$x:00004508                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000450C                 mov     ecx, [ebp+8]
.text$x:0000450F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00004514 ; ---------------------------------------------------------------------------
.text$x:00004514
.text$x:00004514 $LN5_0:                                 ; CODE XREF: __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:00004514                 retn
.text$x:00004514 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:00004514
.text$x:00004515
.text$x:00004515 ; =============== S U B R O U T I N E =======================================
.text$x:00004515
.text$x:00004515
.text$x:00004515 __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:00004515                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+(int)+5o
.text$x:00004515
.text$x:00004515 arg_4           = dword ptr  8
.text$x:00004515
.text$x:00004515                 mov     edx, [esp+arg_4]
.text$x:00004519                 lea     eax, [edx+0Ch]
.text$x:0000451C                 mov     ecx, [edx-18h]
.text$x:0000451F                 xor     ecx, eax
.text$x:00004521                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004526                 mov     eax, offset __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:0000452B                 jmp     ___CxxFrameHandler3
.text$x:0000452B __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:0000452B
.text$x:0000452B _text$x         ends
.text$x:0000452B
.text$mn:00004530 ; ===========================================================================
.text$mn:00004530
.text$mn:00004530 ; Segment type: Pure code
.text$mn:00004530 ; Segment permissions: Read/Execute
.text$mn:00004530 _text$mn        segment para public 'CODE' use32
.text$mn:00004530                 assume cs:_text$mn
.text$mn:00004530                 ;org 4530h
.text$mn:00004530 ; COMDAT (pick any)
.text$mn:00004530                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004530
.text$mn:00004530 ; =============== S U B R O U T I N E =======================================
.text$mn:00004530
.text$mn:00004530 ; Attributes: bp-based frame
.text$mn:00004530
.text$mn:00004530 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator+=(int)
.text$mn:00004530                 public ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:00004530 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:00004530                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+=(int)+Ep
.text$mn:00004530
.text$mn:00004530 var_4           = dword ptr -4
.text$mn:00004530 arg_0           = dword ptr  8
.text$mn:00004530
.text$mn:00004530                 push    ebp
.text$mn:00004531                 mov     ebp, esp
.text$mn:00004533                 push    ecx
.text$mn:00004534                 push    esi
.text$mn:00004535                 mov     [ebp+var_4], ecx
.text$mn:00004538                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000453B                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00004540                 test    eax, eax
.text$mn:00004542                 jz      short loc_4576
.text$mn:00004544                 mov     eax, [ebp+var_4]
.text$mn:00004547                 mov     ecx, [eax+8]
.text$mn:0000454A                 mov     edx, [ebp+arg_0]
.text$mn:0000454D                 lea     esi, [ecx+edx*4]
.text$mn:00004550                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004553                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00004558                 cmp     esi, [eax+4]
.text$mn:0000455B                 jb      short loc_4576
.text$mn:0000455D                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004560                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00004565                 mov     ecx, [ebp+var_4]
.text$mn:00004568                 mov     edx, [ecx+8]
.text$mn:0000456B                 mov     ecx, [ebp+arg_0]
.text$mn:0000456E                 lea     edx, [edx+ecx*4]
.text$mn:00004571                 cmp     [eax+8], edx
.text$mn:00004574                 jnb     short loc_45DE
.text$mn:00004576
.text$mn:00004576 loc_4576:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+=(int)+12j
.text$mn:00004576                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+=(int)+2Bj
.text$mn:00004576                 push    9Fh ; 'ƒ'       ; unsigned int
.text$mn:0000457B                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004580                 push    offset ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ ; "vector iterator + offset out of range"
.text$mn:00004585                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000458A                 add     esp, 0Ch
.text$mn:0000458D                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00004592                 test    eax, eax
.text$mn:00004594                 jz      short loc_459A
.text$mn:00004596                 xor     ecx, ecx
.text$mn:00004598                 jnz     short loc_45C0
.text$mn:0000459A
.text$mn:0000459A loc_459A:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+=(int)+64j
.text$mn:0000459A                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000459F                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:000045A4                 push    0
.text$mn:000045A6                 push    0A0h ; 'á'
.text$mn:000045AB                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000045B0                 push    2
.text$mn:000045B2                 call    __CrtDbgReportW
.text$mn:000045B7                 add     esp, 18h
.text$mn:000045BA                 cmp     eax, 1
.text$mn:000045BD                 jnz     short loc_45C0
.text$mn:000045BF                 int     3               ; Trap to Debugger
.text$mn:000045C0
.text$mn:000045C0 loc_45C0:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+=(int)+68j
.text$mn:000045C0                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+=(int)+8Dj
.text$mn:000045C0                 push    0
.text$mn:000045C2                 push    0A0h ; 'á'
.text$mn:000045C7                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000045CC                 push    offset ??_C@_1MG@JKKENLGC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:000045D1                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000045D6                 call    __invalid_parameter
.text$mn:000045DB                 add     esp, 14h
.text$mn:000045DE
.text$mn:000045DE loc_45DE:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+=(int)+44j
.text$mn:000045DE                 mov     eax, [ebp+var_4]
.text$mn:000045E1                 mov     ecx, [eax+8]
.text$mn:000045E4                 mov     edx, [ebp+arg_0]
.text$mn:000045E7                 lea     eax, [ecx+edx*4]
.text$mn:000045EA                 mov     ecx, [ebp+var_4]
.text$mn:000045ED                 mov     [ecx+8], eax
.text$mn:000045F0                 mov     eax, [ebp+var_4]
.text$mn:000045F3                 pop     esi
.text$mn:000045F4                 mov     esp, ebp
.text$mn:000045F6                 pop     ebp
.text$mn:000045F7                 retn    4
.text$mn:000045F7 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:000045F7
.text$mn:000045F7 ; ---------------------------------------------------------------------------
.text$mn:000045FA                 align 4
.text$mn:000045FA _text$mn        ends
.text$mn:000045FA
.text$mn:000045FC ; ===========================================================================
.text$mn:000045FC
.text$mn:000045FC ; Segment type: Pure code
.text$mn:000045FC ; Segment permissions: Read/Execute
.text$mn:000045FC _text$mn        segment para public 'CODE' use32
.text$mn:000045FC                 assume cs:_text$mn
.text$mn:000045FC                 ;org 45FCh
.text$mn:000045FC ; COMDAT (pick any)
.text$mn:000045FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000045FC
.text$mn:000045FC ; =============== S U B R O U T I N E =======================================
.text$mn:000045FC
.text$mn:000045FC ; Attributes: bp-based frame
.text$mn:000045FC
.text$mn:000045FC ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>::operator+=(int)
.text$mn:000045FC                 public ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:000045FC ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:000045FC                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+(int)+49p
.text$mn:000045FC
.text$mn:000045FC var_4           = dword ptr -4
.text$mn:000045FC arg_0           = dword ptr  8
.text$mn:000045FC
.text$mn:000045FC                 push    ebp
.text$mn:000045FD                 mov     ebp, esp
.text$mn:000045FF                 push    ecx
.text$mn:00004600                 mov     [ebp+var_4], ecx
.text$mn:00004603                 mov     eax, [ebp+arg_0]
.text$mn:00004606                 push    eax
.text$mn:00004607                 mov     ecx, [ebp+var_4]
.text$mn:0000460A                 call    ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+=(int)
.text$mn:0000460F                 mov     eax, [ebp+var_4]
.text$mn:00004612                 mov     esp, ebp
.text$mn:00004614                 pop     ebp
.text$mn:00004615                 retn    4
.text$mn:00004615 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00004615
.text$mn:00004615 _text$mn        ends
.text$mn:00004615
.text$mn:00004618 ; ===========================================================================
.text$mn:00004618
.text$mn:00004618 ; Segment type: Pure code
.text$mn:00004618 ; Segment permissions: Read/Execute
.text$mn:00004618 _text$mn        segment para public 'CODE' use32
.text$mn:00004618                 assume cs:_text$mn
.text$mn:00004618                 ;org 4618h
.text$mn:00004618 ; COMDAT (pick any)
.text$mn:00004618                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004618
.text$mn:00004618 ; =============== S U B R O U T I N E =======================================
.text$mn:00004618
.text$mn:00004618 ; Attributes: bp-based frame
.text$mn:00004618
.text$mn:00004618 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t *Str)
.text$mn:00004618                 public ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:00004618 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:00004618                                         ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+1E3p
.text$mn:00004618                                         ; ToolBar::initTheme(TiXmlDocument *)+2FDp ...
.text$mn:00004618
.text$mn:00004618 var_4           = dword ptr -4
.text$mn:00004618 Str             = dword ptr  8
.text$mn:00004618
.text$mn:00004618                 push    ebp
.text$mn:00004619                 mov     ebp, esp
.text$mn:0000461B                 push    ecx
.text$mn:0000461C                 mov     [ebp+var_4], ecx
.text$mn:0000461F                 mov     eax, [ebp+Str]
.text$mn:00004622                 push    eax             ; Str
.text$mn:00004623                 mov     ecx, [ebp+var_4]
.text$mn:00004626                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:0000462B                 mov     esp, ebp
.text$mn:0000462D                 pop     ebp
.text$mn:0000462E                 retn    4
.text$mn:0000462E ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:0000462E
.text$mn:0000462E ; ---------------------------------------------------------------------------
.text$mn:00004631                 align 4
.text$mn:00004631 _text$mn        ends
.text$mn:00004631
.text$mn:00004634 ; ===========================================================================
.text$mn:00004634
.text$mn:00004634 ; Segment type: Pure code
.text$mn:00004634 ; Segment permissions: Read/Execute
.text$mn:00004634 _text$mn        segment para public 'CODE' use32
.text$mn:00004634                 assume cs:_text$mn
.text$mn:00004634                 ;org 4634h
.text$mn:00004634 ; COMDAT (pick any)
.text$mn:00004634                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004634
.text$mn:00004634 ; =============== S U B R O U T I N E =======================================
.text$mn:00004634
.text$mn:00004634 ; Attributes: bp-based frame
.text$mn:00004634
.text$mn:00004634 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00004634                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00004634 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00004634
.text$mn:00004634 var_4           = dword ptr -4
.text$mn:00004634 arg_0           = dword ptr  8
.text$mn:00004634
.text$mn:00004634                 push    ebp
.text$mn:00004635                 mov     ebp, esp
.text$mn:00004637                 push    ecx
.text$mn:00004638                 mov     [ebp+var_4], ecx
.text$mn:0000463B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000463E                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00004643                 mov     eax, [ebp+arg_0]
.text$mn:00004646                 and     eax, 1
.text$mn:00004649                 jz      short loc_4657
.text$mn:0000464B                 mov     ecx, [ebp+var_4]
.text$mn:0000464E                 push    ecx             ; void *
.text$mn:0000464F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004654                 add     esp, 4
.text$mn:00004657
.text$mn:00004657 loc_4657:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00004657                 mov     eax, [ebp+var_4]
.text$mn:0000465A                 mov     esp, ebp
.text$mn:0000465C                 pop     ebp
.text$mn:0000465D                 retn    4
.text$mn:0000465D ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:0000465D
.text$mn:0000465D _text$mn        ends
.text$mn:0000465D
.text$mn:00004660 ; ===========================================================================
.text$mn:00004660
.text$mn:00004660 ; Segment type: Pure code
.text$mn:00004660 ; Segment permissions: Read/Execute
.text$mn:00004660 _text$mn        segment para public 'CODE' use32
.text$mn:00004660                 assume cs:_text$mn
.text$mn:00004660                 ;org 4660h
.text$mn:00004660 ; COMDAT (pick any)
.text$mn:00004660                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004660
.text$mn:00004660 ; =============== S U B R O U T I N E =======================================
.text$mn:00004660
.text$mn:00004660 ; Attributes: bp-based frame
.text$mn:00004660
.text$mn:00004660 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00004660                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00004660 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00004660
.text$mn:00004660 var_4           = dword ptr -4
.text$mn:00004660 arg_0           = dword ptr  8
.text$mn:00004660
.text$mn:00004660                 push    ebp
.text$mn:00004661                 mov     ebp, esp
.text$mn:00004663                 push    ecx
.text$mn:00004664                 mov     [ebp+var_4], ecx
.text$mn:00004667                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000466A                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:0000466F                 mov     eax, [ebp+arg_0]
.text$mn:00004672                 and     eax, 1
.text$mn:00004675                 jz      short loc_4683
.text$mn:00004677                 mov     ecx, [ebp+var_4]
.text$mn:0000467A                 push    ecx             ; void *
.text$mn:0000467B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004680                 add     esp, 4
.text$mn:00004683
.text$mn:00004683 loc_4683:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00004683                 mov     eax, [ebp+var_4]
.text$mn:00004686                 mov     esp, ebp
.text$mn:00004688                 pop     ebp
.text$mn:00004689                 retn    4
.text$mn:00004689 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00004689
.text$mn:00004689 _text$mn        ends
.text$mn:00004689
.text$mn:0000468C ; ===========================================================================
.text$mn:0000468C
.text$mn:0000468C ; Segment type: Pure code
.text$mn:0000468C ; Segment permissions: Read/Execute
.text$mn:0000468C _text$mn        segment para public 'CODE' use32
.text$mn:0000468C                 assume cs:_text$mn
.text$mn:0000468C                 ;org 468Ch
.text$mn:0000468C ; COMDAT (pick any)
.text$mn:0000468C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000468C
.text$mn:0000468C ; =============== S U B R O U T I N E =======================================
.text$mn:0000468C
.text$mn:0000468C ; Attributes: bp-based frame
.text$mn:0000468C
.text$mn:0000468C ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000468C                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:0000468C ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000468C
.text$mn:0000468C var_4           = dword ptr -4
.text$mn:0000468C arg_0           = dword ptr  8
.text$mn:0000468C
.text$mn:0000468C                 push    ebp
.text$mn:0000468D                 mov     ebp, esp
.text$mn:0000468F                 push    ecx
.text$mn:00004690                 mov     [ebp+var_4], ecx
.text$mn:00004693                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004696                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:0000469B                 mov     eax, [ebp+arg_0]
.text$mn:0000469E                 and     eax, 1
.text$mn:000046A1                 jz      short loc_46AF
.text$mn:000046A3                 mov     ecx, [ebp+var_4]
.text$mn:000046A6                 push    ecx             ; void *
.text$mn:000046A7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000046AC                 add     esp, 4
.text$mn:000046AF
.text$mn:000046AF loc_46AF:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000046AF                 mov     eax, [ebp+var_4]
.text$mn:000046B2                 mov     esp, ebp
.text$mn:000046B4                 pop     ebp
.text$mn:000046B5                 retn    4
.text$mn:000046B5 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:000046B5
.text$mn:000046B5 _text$mn        ends
.text$mn:000046B5
.text$mn:000046B8 ; ===========================================================================
.text$mn:000046B8
.text$mn:000046B8 ; Segment type: Pure code
.text$mn:000046B8 ; Segment permissions: Read/Execute
.text$mn:000046B8 _text$mn        segment para public 'CODE' use32
.text$mn:000046B8                 assume cs:_text$mn
.text$mn:000046B8                 ;org 46B8h
.text$mn:000046B8 ; COMDAT (pick any)
.text$mn:000046B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046B8
.text$mn:000046B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000046B8
.text$mn:000046B8 ; Attributes: bp-based frame
.text$mn:000046B8
.text$mn:000046B8 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000046B8                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:000046B8 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:000046B8
.text$mn:000046B8 var_4           = dword ptr -4
.text$mn:000046B8 arg_0           = dword ptr  8
.text$mn:000046B8
.text$mn:000046B8                 push    ebp
.text$mn:000046B9                 mov     ebp, esp
.text$mn:000046BB                 push    ecx
.text$mn:000046BC                 mov     [ebp+var_4], ecx
.text$mn:000046BF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000046C2                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000046C7                 mov     eax, [ebp+arg_0]
.text$mn:000046CA                 and     eax, 1
.text$mn:000046CD                 jz      short loc_46DB
.text$mn:000046CF                 mov     ecx, [ebp+var_4]
.text$mn:000046D2                 push    ecx             ; void *
.text$mn:000046D3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000046D8                 add     esp, 4
.text$mn:000046DB
.text$mn:000046DB loc_46DB:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000046DB                 mov     eax, [ebp+var_4]
.text$mn:000046DE                 mov     esp, ebp
.text$mn:000046E0                 pop     ebp
.text$mn:000046E1                 retn    4
.text$mn:000046E1 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:000046E1
.text$mn:000046E1 _text$mn        ends
.text$mn:000046E1
.text$mn:000046E4 ; ===========================================================================
.text$mn:000046E4
.text$mn:000046E4 ; Segment type: Pure code
.text$mn:000046E4 ; Segment permissions: Read/Execute
.text$mn:000046E4 _text$mn        segment para public 'CODE' use32
.text$mn:000046E4                 assume cs:_text$mn
.text$mn:000046E4                 ;org 46E4h
.text$mn:000046E4 ; COMDAT (pick any)
.text$mn:000046E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046E4
.text$mn:000046E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000046E4
.text$mn:000046E4 ; Attributes: bp-based frame
.text$mn:000046E4
.text$mn:000046E4 ; public: void * __thiscall iconLocator::`scalar deleting destructor'(unsigned int)
.text$mn:000046E4                 public ??_GiconLocator@@QAEPAXI@Z
.text$mn:000046E4 ??_GiconLocator@@QAEPAXI@Z proc near    ; CODE XREF: std::allocator<iconLocator>::destroy<iconLocator>(iconLocator *)+Cp
.text$mn:000046E4
.text$mn:000046E4 var_4           = dword ptr -4
.text$mn:000046E4 arg_0           = dword ptr  8
.text$mn:000046E4
.text$mn:000046E4                 push    ebp
.text$mn:000046E5                 mov     ebp, esp
.text$mn:000046E7                 push    ecx
.text$mn:000046E8                 mov     [ebp+var_4], ecx
.text$mn:000046EB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000046EE                 call    ??1iconLocator@@QAE@XZ ; iconLocator::~iconLocator(void)
.text$mn:000046F3                 mov     eax, [ebp+arg_0]
.text$mn:000046F6                 and     eax, 1
.text$mn:000046F9                 jz      short loc_4707
.text$mn:000046FB                 mov     ecx, [ebp+var_4]
.text$mn:000046FE                 push    ecx             ; void *
.text$mn:000046FF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004704                 add     esp, 4
.text$mn:00004707
.text$mn:00004707 loc_4707:                               ; CODE XREF: iconLocator::`scalar deleting destructor'(uint)+15j
.text$mn:00004707                 mov     eax, [ebp+var_4]
.text$mn:0000470A                 mov     esp, ebp
.text$mn:0000470C                 pop     ebp
.text$mn:0000470D                 retn    4
.text$mn:0000470D ??_GiconLocator@@QAEPAXI@Z endp
.text$mn:0000470D
.text$mn:0000470D _text$mn        ends
.text$mn:0000470D
.text$mn:00004710 ; ===========================================================================
.text$mn:00004710
.text$mn:00004710 ; Segment type: Pure code
.text$mn:00004710 ; Segment permissions: Read/Execute
.text$mn:00004710 _text$mn        segment para public 'CODE' use32
.text$mn:00004710                 assume cs:_text$mn
.text$mn:00004710                 ;org 4710h
.text$mn:00004710 ; COMDAT (pick any)
.text$mn:00004710                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004710
.text$mn:00004710 ; =============== S U B R O U T I N E =======================================
.text$mn:00004710
.text$mn:00004710 ; Attributes: bp-based frame
.text$mn:00004710
.text$mn:00004710 ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:00004710                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:00004710 ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:00004710
.text$mn:00004710 var_4           = dword ptr -4
.text$mn:00004710 arg_0           = dword ptr  8
.text$mn:00004710
.text$mn:00004710                 push    ebp
.text$mn:00004711                 mov     ebp, esp
.text$mn:00004713                 push    ecx
.text$mn:00004714                 mov     [ebp+var_4], ecx
.text$mn:00004717                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000471A                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:0000471F                 mov     eax, [ebp+arg_0]
.text$mn:00004722                 and     eax, 1
.text$mn:00004725                 jz      short loc_4733
.text$mn:00004727                 mov     ecx, [ebp+var_4]
.text$mn:0000472A                 push    ecx             ; void *
.text$mn:0000472B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004730                 add     esp, 4
.text$mn:00004733
.text$mn:00004733 loc_4733:                               ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:00004733                 mov     eax, [ebp+var_4]
.text$mn:00004736                 mov     esp, ebp
.text$mn:00004738                 pop     ebp
.text$mn:00004739                 retn    4
.text$mn:00004739 ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:00004739
.text$mn:00004739 _text$mn        ends
.text$mn:00004739
.text$di:0000473C ; ===========================================================================
.text$di:0000473C
.text$di:0000473C ; Segment type: Pure code
.text$di:0000473C ; Segment permissions: Read/Execute
.text$di:0000473C _text$di        segment para public 'CODE' use32
.text$di:0000473C                 assume cs:_text$di
.text$di:0000473C                 ;org 473Ch
.text$di:0000473C ; COMDAT (pick any)
.text$di:0000473C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000473C
.text$di:0000473C ; =============== S U B R O U T I N E =======================================
.text$di:0000473C
.text$di:0000473C ; Attributes: bp-based frame
.text$di:0000473C
.text$di:0000473C ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:0000473C ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:0000473C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:0000473C                 push    ebp
.text$di:0000473D                 mov     ebp, esp
.text$di:0000473F                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00004744                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00004749                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000474E                 call    _atexit
.text$di:00004753                 add     esp, 4
.text$di:00004756                 pop     ebp
.text$di:00004757                 retn
.text$di:00004757 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00004757
.text$di:00004757 _text$di        ends
.text$di:00004757
.text$di:00004758 ; ===========================================================================
.text$di:00004758
.text$di:00004758 ; Segment type: Pure code
.text$di:00004758 ; Segment permissions: Read/Execute
.text$di:00004758 _text$di        segment para public 'CODE' use32
.text$di:00004758                 assume cs:_text$di
.text$di:00004758                 ;org 4758h
.text$di:00004758 ; COMDAT (pick any)
.text$di:00004758                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004758
.text$di:00004758 ; =============== S U B R O U T I N E =======================================
.text$di:00004758
.text$di:00004758 ; Attributes: bp-based frame
.text$di:00004758
.text$di:00004758 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00004758 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00004758                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00004758                 push    ebp
.text$di:00004759                 mov     ebp, esp
.text$di:0000475B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00004760                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00004765                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000476A                 call    _atexit
.text$di:0000476F                 add     esp, 4
.text$di:00004772                 pop     ebp
.text$di:00004773                 retn
.text$di:00004773 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00004773
.text$di:00004773 _text$di        ends
.text$di:00004773
.text$di:00004774 ; ===========================================================================
.text$di:00004774
.text$di:00004774 ; Segment type: Pure code
.text$di:00004774 ; Segment permissions: Read/Execute
.text$di:00004774 _text$di        segment para public 'CODE' use32
.text$di:00004774                 assume cs:_text$di
.text$di:00004774                 ;org 4774h
.text$di:00004774 ; COMDAT (pick any)
.text$di:00004774                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004774
.text$di:00004774 ; =============== S U B R O U T I N E =======================================
.text$di:00004774
.text$di:00004774 ; Attributes: bp-based frame
.text$di:00004774
.text$di:00004774 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00004774 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00004774                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00004774                 push    ebp
.text$di:00004775                 mov     ebp, esp
.text$di:00004777                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:0000477C                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00004781                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00004786                 call    _atexit
.text$di:0000478B                 add     esp, 4
.text$di:0000478E                 pop     ebp
.text$di:0000478F                 retn
.text$di:0000478F ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:0000478F
.text$di:0000478F _text$di        ends
.text$di:0000478F
.text$di:00004790 ; ===========================================================================
.text$di:00004790
.text$di:00004790 ; Segment type: Pure code
.text$di:00004790 ; Segment permissions: Read/Execute
.text$di:00004790 _text$di        segment para public 'CODE' use32
.text$di:00004790                 assume cs:_text$di
.text$di:00004790                 ;org 4790h
.text$di:00004790 ; COMDAT (pick any)
.text$di:00004790                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004790
.text$di:00004790 ; =============== S U B R O U T I N E =======================================
.text$di:00004790
.text$di:00004790 ; Attributes: bp-based frame
.text$di:00004790
.text$di:00004790 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00004790 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00004790                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00004790                 push    ebp
.text$di:00004791                 mov     ebp, esp
.text$di:00004793                 push    0               ; unsigned int
.text$di:00004795                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000479A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000479F                 pop     ebp
.text$di:000047A0                 retn
.text$di:000047A0 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000047A0
.text$di:000047A0 ; ---------------------------------------------------------------------------
.text$di:000047A1                 align 4
.text$di:000047A1 _text$di        ends
.text$di:000047A1
.text$di:000047A4 ; ===========================================================================
.text$di:000047A4
.text$di:000047A4 ; Segment type: Pure code
.text$di:000047A4 ; Segment permissions: Read/Execute
.text$di:000047A4 _text$di        segment para public 'CODE' use32
.text$di:000047A4                 assume cs:_text$di
.text$di:000047A4                 ;org 47A4h
.text$di:000047A4 ; COMDAT (pick any)
.text$di:000047A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000047A4
.text$di:000047A4 ; =============== S U B R O U T I N E =======================================
.text$di:000047A4
.text$di:000047A4 ; Attributes: bp-based frame
.text$di:000047A4
.text$di:000047A4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:000047A4 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000047A4                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:000047A4                 push    ebp
.text$di:000047A5                 mov     ebp, esp
.text$di:000047A7                 push    0               ; unsigned int
.text$di:000047A9                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000047AE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000047B3                 pop     ebp
.text$di:000047B4                 retn
.text$di:000047B4 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000047B4
.text$di:000047B4 ; ---------------------------------------------------------------------------
.text$di:000047B5                 align 4
.text$di:000047B5 _text$di        ends
.text$di:000047B5
.text$di:000047B8 ; ===========================================================================
.text$di:000047B8
.text$di:000047B8 ; Segment type: Pure code
.text$di:000047B8 ; Segment permissions: Read/Execute
.text$di:000047B8 _text$di        segment para public 'CODE' use32
.text$di:000047B8                 assume cs:_text$di
.text$di:000047B8                 ;org 47B8h
.text$di:000047B8 ; COMDAT (pick any)
.text$di:000047B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000047B8
.text$di:000047B8 ; =============== S U B R O U T I N E =======================================
.text$di:000047B8
.text$di:000047B8 ; Attributes: bp-based frame
.text$di:000047B8
.text$di:000047B8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:000047B8 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000047B8                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:000047B8                 push    ebp
.text$di:000047B9                 mov     ebp, esp
.text$di:000047BB                 push    0               ; unsigned int
.text$di:000047BD                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:000047C2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000047C7                 pop     ebp
.text$di:000047C8                 retn
.text$di:000047C8 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000047C8
.text$di:000047C8 ; ---------------------------------------------------------------------------
.text$di:000047C9                 align 4
.text$di:000047C9 _text$di        ends
.text$di:000047C9
.text$di:000047CC ; ===========================================================================
.text$di:000047CC
.text$di:000047CC ; Segment type: Pure code
.text$di:000047CC ; Segment permissions: Read/Execute
.text$di:000047CC _text$di        segment para public 'CODE' use32
.text$di:000047CC                 assume cs:_text$di
.text$di:000047CC                 ;org 47CCh
.text$di:000047CC ; COMDAT (pick any)
.text$di:000047CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000047CC
.text$di:000047CC ; =============== S U B R O U T I N E =======================================
.text$di:000047CC
.text$di:000047CC ; Attributes: bp-based frame
.text$di:000047CC
.text$di:000047CC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:000047CC ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000047CC                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:000047CC                 push    ebp
.text$di:000047CD                 mov     ebp, esp
.text$di:000047CF                 push    0               ; unsigned int
.text$di:000047D1                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:000047D6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000047DB                 pop     ebp
.text$di:000047DC                 retn
.text$di:000047DC ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000047DC
.text$di:000047DC ; ---------------------------------------------------------------------------
.text$di:000047DD                 align 10h
.text$di:000047DD _text$di        ends
.text$di:000047DD
.text$di:000047E0 ; ===========================================================================
.text$di:000047E0
.text$di:000047E0 ; Segment type: Pure code
.text$di:000047E0 ; Segment permissions: Read/Execute
.text$di:000047E0 _text$di        segment para public 'CODE' use32
.text$di:000047E0                 assume cs:_text$di
.text$di:000047E0                 ;org 47E0h
.text$di:000047E0 ; COMDAT (pick any)
.text$di:000047E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000047E0
.text$di:000047E0 ; =============== S U B R O U T I N E =======================================
.text$di:000047E0
.text$di:000047E0 ; Attributes: bp-based frame
.text$di:000047E0
.text$di:000047E0 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:000047E0 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:000047E0
.text$di:000047E0 var_1           = byte ptr -1
.text$di:000047E0
.text$di:000047E0                 push    ebp
.text$di:000047E1                 mov     ebp, esp
.text$di:000047E3                 push    ecx
.text$di:000047E4                 xor     eax, eax
.text$di:000047E6                 mov     [ebp+var_1], al
.text$di:000047E9                 mov     esp, ebp
.text$di:000047EB                 pop     ebp
.text$di:000047EC                 retn
.text$di:000047EC ??__Eallocator_arg@std@@YAXXZ endp
.text$di:000047EC
.text$di:000047EC ; ---------------------------------------------------------------------------
.text$di:000047ED                 align 10h
.text$di:000047ED _text$di        ends
.text$di:000047ED
.text$di:000047F0 ; ===========================================================================
.text$di:000047F0
.text$di:000047F0 ; Segment type: Pure code
.text$di:000047F0 ; Segment permissions: Read/Execute
.text$di:000047F0 _text$di        segment para public 'CODE' use32
.text$di:000047F0                 assume cs:_text$di
.text$di:000047F0                 ;org 47F0h
.text$di:000047F0 ; COMDAT (pick any)
.text$di:000047F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000047F0
.text$di:000047F0 ; =============== S U B R O U T I N E =======================================
.text$di:000047F0
.text$di:000047F0 ; Attributes: bp-based frame
.text$di:000047F0
.text$di:000047F0 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:000047F0 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:000047F0                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:000047F0
.text$di:000047F0 var_1           = byte ptr -1
.text$di:000047F0
.text$di:000047F0                 push    ebp
.text$di:000047F1                 mov     ebp, esp
.text$di:000047F3                 push    ecx
.text$di:000047F4                 xor     eax, eax
.text$di:000047F6                 mov     [ebp+var_1], al
.text$di:000047F9                 mov     esp, ebp
.text$di:000047FB                 pop     ebp
.text$di:000047FC                 retn
.text$di:000047FC ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:000047FC
.text$di:000047FC ; ---------------------------------------------------------------------------
.text$di:000047FD                 align 10h
.text$di:000047FD _text$di        ends
.text$di:000047FD
.text$yd:00004800 ; ===========================================================================
.text$yd:00004800
.text$yd:00004800 ; Segment type: Pure code
.text$yd:00004800 ; Segment permissions: Read/Execute
.text$yd:00004800 _text$yd        segment para public 'CODE' use32
.text$yd:00004800                 assume cs:_text$yd
.text$yd:00004800                 ;org 4800h
.text$yd:00004800 ; COMDAT (pick any)
.text$yd:00004800                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00004800
.text$yd:00004800 ; =============== S U B R O U T I N E =======================================
.text$yd:00004800
.text$yd:00004800 ; Attributes: bp-based frame
.text$yd:00004800
.text$yd:00004800 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00004800 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00004800                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00004800                 push    ebp
.text$yd:00004801                 mov     ebp, esp
.text$yd:00004803                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00004808                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:0000480D                 pop     ebp
.text$yd:0000480E                 retn
.text$yd:0000480E ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:0000480E
.text$yd:0000480E ; ---------------------------------------------------------------------------
.text$yd:0000480F                 align 10h
.text$yd:0000480F _text$yd        ends
.text$yd:0000480F
.text$yd:00004810 ; ===========================================================================
.text$yd:00004810
.text$yd:00004810 ; Segment type: Pure code
.text$yd:00004810 ; Segment permissions: Read/Execute
.text$yd:00004810 _text$yd        segment para public 'CODE' use32
.text$yd:00004810                 assume cs:_text$yd
.text$yd:00004810                 ;org 4810h
.text$yd:00004810 ; COMDAT (pick any)
.text$yd:00004810                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00004810
.text$yd:00004810 ; =============== S U B R O U T I N E =======================================
.text$yd:00004810
.text$yd:00004810 ; Attributes: bp-based frame
.text$yd:00004810
.text$yd:00004810 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00004810 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00004810                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00004810                 push    ebp
.text$yd:00004811                 mov     ebp, esp
.text$yd:00004813                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00004818                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:0000481D                 pop     ebp
.text$yd:0000481E                 retn
.text$yd:0000481E ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:0000481E
.text$yd:0000481E ; ---------------------------------------------------------------------------
.text$yd:0000481F                 align 10h
.text$yd:0000481F _text$yd        ends
.text$yd:0000481F
.text$yd:00004820 ; ===========================================================================
.text$yd:00004820
.text$yd:00004820 ; Segment type: Pure code
.text$yd:00004820 ; Segment permissions: Read/Execute
.text$yd:00004820 _text$yd        segment para public 'CODE' use32
.text$yd:00004820                 assume cs:_text$yd
.text$yd:00004820                 ;org 4820h
.text$yd:00004820 ; COMDAT (pick any)
.text$yd:00004820                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00004820
.text$yd:00004820 ; =============== S U B R O U T I N E =======================================
.text$yd:00004820
.text$yd:00004820 ; Attributes: bp-based frame
.text$yd:00004820
.text$yd:00004820 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00004820 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00004820                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00004820                 push    ebp
.text$yd:00004821                 mov     ebp, esp
.text$yd:00004823                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00004828                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:0000482D                 pop     ebp
.text$yd:0000482E                 retn
.text$yd:0000482E ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:0000482E
.text$yd:0000482E ; ---------------------------------------------------------------------------
.text$yd:0000482F                 align 10h
.text$yd:0000482F _text$yd        ends
.text$yd:0000482F
.text$mn:00004830 ; ===========================================================================
.text$mn:00004830
.text$mn:00004830 ; Segment type: Pure code
.text$mn:00004830 ; Segment permissions: Read/Execute
.text$mn:00004830 _text$mn        segment para public 'CODE' use32
.text$mn:00004830                 assume cs:_text$mn
.text$mn:00004830                 ;org 4830h
.text$mn:00004830 ; COMDAT (pick any)
.text$mn:00004830                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004830
.text$mn:00004830 ; =============== S U B R O U T I N E =======================================
.text$mn:00004830
.text$mn:00004830 ; Attributes: bp-based frame
.text$mn:00004830
.text$mn:00004830 ; struct TiXmlNode *__thiscall TiXmlNode::FirstChild(TiXmlNode *__hidden this)
.text$mn:00004830                 public ?FirstChild@TiXmlNode@@QBEPAV1@XZ
.text$mn:00004830 ?FirstChild@TiXmlNode@@QBEPAV1@XZ proc near
.text$mn:00004830                                         ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+185p
.text$mn:00004830                                         ; ToolBar::initTheme(TiXmlDocument *)+29Fp ...
.text$mn:00004830
.text$mn:00004830 var_4           = dword ptr -4
.text$mn:00004830
.text$mn:00004830                 push    ebp
.text$mn:00004831                 mov     ebp, esp
.text$mn:00004833                 push    ecx
.text$mn:00004834                 mov     [ebp+var_4], ecx
.text$mn:00004837                 mov     eax, [ebp+var_4]
.text$mn:0000483A                 mov     eax, [eax+14h]
.text$mn:0000483D                 mov     esp, ebp
.text$mn:0000483F                 pop     ebp
.text$mn:00004840                 retn
.text$mn:00004840 ?FirstChild@TiXmlNode@@QBEPAV1@XZ endp
.text$mn:00004840
.text$mn:00004840 ; ---------------------------------------------------------------------------
.text$mn:00004841                 align 4
.text$mn:00004841 _text$mn        ends
.text$mn:00004841
.text$mn:00004844 ; ===========================================================================
.text$mn:00004844
.text$mn:00004844 ; Segment type: Pure code
.text$mn:00004844 ; Segment permissions: Read/Execute
.text$mn:00004844 _text$mn        segment para public 'CODE' use32
.text$mn:00004844                 assume cs:_text$mn
.text$mn:00004844                 ;org 4844h
.text$mn:00004844 ; COMDAT (pick any)
.text$mn:00004844                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004844
.text$mn:00004844 ; =============== S U B R O U T I N E =======================================
.text$mn:00004844
.text$mn:00004844 ; Attributes: bp-based frame
.text$mn:00004844
.text$mn:00004844 ; struct TiXmlElement *__thiscall TiXmlNode::ToElement(TiXmlNode *__hidden this)
.text$mn:00004844                 public ?ToElement@TiXmlNode@@QBEPAVTiXmlElement@@XZ
.text$mn:00004844 ?ToElement@TiXmlNode@@QBEPAVTiXmlElement@@XZ proc near
.text$mn:00004844                                         ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+D8p
.text$mn:00004844                                         ; ToolBar::initTheme(TiXmlDocument *)+13Dp
.text$mn:00004844
.text$mn:00004844 var_8           = dword ptr -8
.text$mn:00004844 var_4           = dword ptr -4
.text$mn:00004844
.text$mn:00004844                 push    ebp
.text$mn:00004845                 mov     ebp, esp
.text$mn:00004847                 sub     esp, 8
.text$mn:0000484A                 mov     [ebp+var_4], ecx
.text$mn:0000484D                 cmp     [ebp+var_4], 0
.text$mn:00004851                 jz      short loc_4864
.text$mn:00004853                 mov     eax, [ebp+var_4]
.text$mn:00004856                 cmp     dword ptr [eax+10h], 1
.text$mn:0000485A                 jnz     short loc_4864
.text$mn:0000485C                 mov     ecx, [ebp+var_4]
.text$mn:0000485F                 mov     [ebp+var_8], ecx
.text$mn:00004862                 jmp     short loc_486B
.text$mn:00004864 ; ---------------------------------------------------------------------------
.text$mn:00004864
.text$mn:00004864 loc_4864:                               ; CODE XREF: TiXmlNode::ToElement(void)+Dj
.text$mn:00004864                                         ; TiXmlNode::ToElement(void)+16j
.text$mn:00004864                 mov     [ebp+var_8], 0
.text$mn:0000486B
.text$mn:0000486B loc_486B:                               ; CODE XREF: TiXmlNode::ToElement(void)+1Ej
.text$mn:0000486B                 mov     eax, [ebp+var_8]
.text$mn:0000486E                 mov     esp, ebp
.text$mn:00004870                 pop     ebp
.text$mn:00004871                 retn
.text$mn:00004871 ?ToElement@TiXmlNode@@QBEPAVTiXmlElement@@XZ endp
.text$mn:00004871
.text$mn:00004871 ; ---------------------------------------------------------------------------
.text$mn:00004872                 align 4
.text$mn:00004872 _text$mn        ends
.text$mn:00004872
.text$mn:00004874 ; ===========================================================================
.text$mn:00004874
.text$mn:00004874 ; Segment type: Pure code
.text$mn:00004874 ; Segment permissions: Read/Execute
.text$mn:00004874 _text$mn        segment para public 'CODE' use32
.text$mn:00004874                 assume cs:_text$mn
.text$mn:00004874                 ;org 4874h
.text$mn:00004874 ; COMDAT (pick any)
.text$mn:00004874                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004874
.text$mn:00004874 ; =============== S U B R O U T I N E =======================================
.text$mn:00004874
.text$mn:00004874 ; Attributes: bp-based frame
.text$mn:00004874
.text$mn:00004874 ; const wchar_t *__thiscall TiXmlNode::Value(TiXmlNode *__hidden this)
.text$mn:00004874                 public ?Value@TiXmlNode@@QBEPB_WXZ
.text$mn:00004874 ?Value@TiXmlNode@@QBEPB_WXZ proc near   ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+1DAp
.text$mn:00004874                                         ; ToolBar::initTheme(TiXmlDocument *)+2F4p ...
.text$mn:00004874
.text$mn:00004874 var_4           = dword ptr -4
.text$mn:00004874
.text$mn:00004874                 push    ebp
.text$mn:00004875                 mov     ebp, esp
.text$mn:00004877                 push    ecx
.text$mn:00004878                 mov     [ebp+var_4], ecx
.text$mn:0000487B                 mov     ecx, [ebp+var_4]
.text$mn:0000487E                 add     ecx, 1Ch
.text$mn:00004881                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00004886                 mov     esp, ebp
.text$mn:00004888                 pop     ebp
.text$mn:00004889                 retn
.text$mn:00004889 ?Value@TiXmlNode@@QBEPB_WXZ endp
.text$mn:00004889
.text$mn:00004889 ; ---------------------------------------------------------------------------
.text$mn:0000488A                 align 4
.text$mn:0000488A _text$mn        ends
.text$mn:0000488A
.text$mn:0000488C ; ===========================================================================
.text$mn:0000488C
.text$mn:0000488C ; Segment type: Pure code
.text$mn:0000488C ; Segment permissions: Read/Execute
.text$mn:0000488C _text$mn        segment para public 'CODE' use32
.text$mn:0000488C                 assume cs:_text$mn
.text$mn:0000488C                 ;org 488Ch
.text$mn:0000488C ; COMDAT (pick any)
.text$mn:0000488C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000488C
.text$mn:0000488C ; =============== S U B R O U T I N E =======================================
.text$mn:0000488C
.text$mn:0000488C ; Attributes: bp-based frame
.text$mn:0000488C
.text$mn:0000488C ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:0000488C                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:0000488C ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:0000488C                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)+45p
.text$mn:0000488C                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+49p
.text$mn:0000488C
.text$mn:0000488C var_1C          = byte ptr -1Ch
.text$mn:0000488C var_18          = byte ptr -18h
.text$mn:0000488C var_14          = dword ptr -14h
.text$mn:0000488C var_10          = dword ptr -10h
.text$mn:0000488C var_C           = dword ptr -0Ch
.text$mn:0000488C var_4           = dword ptr -4
.text$mn:0000488C arg_0           = dword ptr  8
.text$mn:0000488C
.text$mn:0000488C                 push    ebp
.text$mn:0000488D                 mov     ebp, esp
.text$mn:0000488F                 push    0FFFFFFFFh
.text$mn:00004891                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00004896                 mov     eax, large fs:0
.text$mn:0000489C                 push    eax
.text$mn:0000489D                 sub     esp, 10h
.text$mn:000048A0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000048A5                 xor     eax, ebp
.text$mn:000048A7                 push    eax
.text$mn:000048A8                 lea     eax, [ebp+var_C]
.text$mn:000048AB                 mov     large fs:0, eax
.text$mn:000048B1                 mov     [ebp+var_10], ecx
.text$mn:000048B4                 cmp     [ebp+arg_0], 0
.text$mn:000048B8                 jnz     short loc_48E4
.text$mn:000048BA                 push    3               ; int
.text$mn:000048BC                 lea     ecx, [ebp+var_18] ; this
.text$mn:000048BF                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000048C4                 mov     [ebp+var_4], 0
.text$mn:000048CB                 mov     ecx, [ebp+var_10] ; this
.text$mn:000048CE                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:000048D3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000048DA                 lea     ecx, [ebp+var_18] ; this
.text$mn:000048DD                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000048E2                 jmp     short loc_493B
.text$mn:000048E4 ; ---------------------------------------------------------------------------
.text$mn:000048E4
.text$mn:000048E4 loc_48E4:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:000048E4                 mov     eax, [ebp+arg_0]
.text$mn:000048E7                 mov     ecx, [eax]
.text$mn:000048E9                 mov     [ebp+var_14], ecx
.text$mn:000048EC                 mov     edx, [ebp+var_10]
.text$mn:000048EF                 mov     eax, [edx]
.text$mn:000048F1                 cmp     eax, [ebp+var_14]
.text$mn:000048F4                 jz      short loc_493B
.text$mn:000048F6                 push    3               ; int
.text$mn:000048F8                 lea     ecx, [ebp+var_1C] ; this
.text$mn:000048FB                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00004900                 mov     [ebp+var_4], 1
.text$mn:00004907                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000490A                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:0000490F                 mov     ecx, [ebp+var_10]
.text$mn:00004912                 mov     edx, [ebp+var_14]
.text$mn:00004915                 mov     eax, [edx+4]
.text$mn:00004918                 mov     [ecx+4], eax
.text$mn:0000491B                 mov     ecx, [ebp+var_14]
.text$mn:0000491E                 mov     edx, [ebp+var_10]
.text$mn:00004921                 mov     [ecx+4], edx
.text$mn:00004924                 mov     eax, [ebp+var_10]
.text$mn:00004927                 mov     ecx, [ebp+var_14]
.text$mn:0000492A                 mov     [eax], ecx
.text$mn:0000492C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004933                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00004936                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000493B
.text$mn:0000493B loc_493B:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:0000493B                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:0000493B                 mov     ecx, [ebp+var_C]
.text$mn:0000493E                 mov     large fs:0, ecx
.text$mn:00004945                 pop     ecx
.text$mn:00004946                 mov     esp, ebp
.text$mn:00004948                 pop     ebp
.text$mn:00004949                 retn    4
.text$mn:00004949 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00004949
.text$mn:00004949 _text$mn        ends
.text$mn:00004949
.text$x:0000494C ; ===========================================================================
.text$x:0000494C
.text$x:0000494C ; Segment type: Pure code
.text$x:0000494C ; Segment permissions: Read/Execute
.text$x:0000494C _text$x         segment para public 'CODE' use32
.text$x:0000494C                 assume cs:_text$x
.text$x:0000494C                 ;org 494Ch
.text$x:0000494C ; COMDAT (pick associative to section at 488C)
.text$x:0000494C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000494C
.text$x:0000494C ; =============== S U B R O U T I N E =======================================
.text$x:0000494C
.text$x:0000494C
.text$x:0000494C __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:0000494C                                         ; DATA XREF: .xdata$x:00007AE8o
.text$x:0000494C                 lea     ecx, [ebp-18h]  ; this
.text$x:0000494F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000494F __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:0000494F
.text$x:00004954
.text$x:00004954 ; =============== S U B R O U T I N E =======================================
.text$x:00004954
.text$x:00004954
.text$x:00004954 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:00004954                                         ; DATA XREF: .xdata$x:00007AF0o
.text$x:00004954                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00004957                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00004957 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:00004957
.text$x:0000495C
.text$x:0000495C ; =============== S U B R O U T I N E =======================================
.text$x:0000495C
.text$x:0000495C
.text$x:0000495C __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:0000495C                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:0000495C
.text$x:0000495C arg_4           = dword ptr  8
.text$x:0000495C
.text$x:0000495C                 mov     edx, [esp+arg_4]
.text$x:00004960                 lea     eax, [edx+0Ch]
.text$x:00004963                 mov     ecx, [edx-14h]
.text$x:00004966                 xor     ecx, eax
.text$x:00004968                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000496D                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:00004972                 jmp     ___CxxFrameHandler3
.text$x:00004972 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:00004972
.text$x:00004972 ; ---------------------------------------------------------------------------
.text$x:00004977                 align 4
.text$x:00004977 _text$x         ends
.text$x:00004977
.text$mn:00004978 ; ===========================================================================
.text$mn:00004978
.text$mn:00004978 ; Segment type: Pure code
.text$mn:00004978 ; Segment permissions: Read/Execute
.text$mn:00004978 _text$mn        segment para public 'CODE' use32
.text$mn:00004978                 assume cs:_text$mn
.text$mn:00004978                 ;org 4978h
.text$mn:00004978 ; COMDAT (pick any)
.text$mn:00004978                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004978
.text$mn:00004978 ; =============== S U B R O U T I N E =======================================
.text$mn:00004978
.text$mn:00004978 ; Attributes: bp-based frame
.text$mn:00004978
.text$mn:00004978 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00004978                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00004978 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00004978                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00004978
.text$mn:00004978 var_10          = byte ptr -10h
.text$mn:00004978 var_8           = dword ptr -8
.text$mn:00004978 var_1           = byte ptr -1
.text$mn:00004978
.text$mn:00004978                 push    ebp
.text$mn:00004979                 mov     ebp, esp
.text$mn:0000497B                 sub     esp, 10h
.text$mn:0000497E                 mov     [ebp+var_8], ecx
.text$mn:00004981                 lea     ecx, [ebp+var_1]
.text$mn:00004984                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00004989                 push    1
.text$mn:0000498B                 lea     ecx, [ebp+var_1]
.text$mn:0000498E                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00004993                 mov     ecx, [ebp+var_8]
.text$mn:00004996                 mov     [ecx], eax
.text$mn:00004998                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000499B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000049A0                 push    eax             ; int
.text$mn:000049A1                 mov     edx, [ebp+var_8]
.text$mn:000049A4                 mov     eax, [edx]
.text$mn:000049A6                 push    eax             ; void *
.text$mn:000049A7                 lea     ecx, [ebp+var_1]
.text$mn:000049AA                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000049AF                 mov     ecx, [ebp+var_8]
.text$mn:000049B2                 mov     edx, [ecx]
.text$mn:000049B4                 mov     eax, [ebp+var_8]
.text$mn:000049B7                 mov     [edx], eax
.text$mn:000049B9                 mov     esp, ebp
.text$mn:000049BB                 pop     ebp
.text$mn:000049BC                 retn
.text$mn:000049BC ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000049BC
.text$mn:000049BC ; ---------------------------------------------------------------------------
.text$mn:000049BD                 align 10h
.text$mn:000049BD _text$mn        ends
.text$mn:000049BD
.text$mn:000049C0 ; ===========================================================================
.text$mn:000049C0
.text$mn:000049C0 ; Segment type: Pure code
.text$mn:000049C0 ; Segment permissions: Read/Execute
.text$mn:000049C0 _text$mn        segment para public 'CODE' use32
.text$mn:000049C0                 assume cs:_text$mn
.text$mn:000049C0                 ;org 49C0h
.text$mn:000049C0 ; COMDAT (pick any)
.text$mn:000049C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000049C0
.text$mn:000049C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000049C0
.text$mn:000049C0 ; Attributes: bp-based frame
.text$mn:000049C0
.text$mn:000049C0 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:000049C0                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:000049C0 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000049C0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:000049C0
.text$mn:000049C0 var_10          = byte ptr -10h
.text$mn:000049C0 var_8           = dword ptr -8
.text$mn:000049C0 var_1           = byte ptr -1
.text$mn:000049C0
.text$mn:000049C0                 push    ebp
.text$mn:000049C1                 mov     ebp, esp
.text$mn:000049C3                 sub     esp, 10h
.text$mn:000049C6                 mov     [ebp+var_8], ecx
.text$mn:000049C9                 lea     ecx, [ebp+var_1]
.text$mn:000049CC                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000049D1                 push    1
.text$mn:000049D3                 lea     ecx, [ebp+var_1]
.text$mn:000049D6                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000049DB                 mov     ecx, [ebp+var_8]
.text$mn:000049DE                 mov     [ecx], eax
.text$mn:000049E0                 lea     ecx, [ebp+var_10] ; this
.text$mn:000049E3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000049E8                 push    eax             ; int
.text$mn:000049E9                 mov     edx, [ebp+var_8]
.text$mn:000049EC                 mov     eax, [edx]
.text$mn:000049EE                 push    eax             ; void *
.text$mn:000049EF                 lea     ecx, [ebp+var_1]
.text$mn:000049F2                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000049F7                 mov     ecx, [ebp+var_8]
.text$mn:000049FA                 mov     edx, [ecx]
.text$mn:000049FC                 mov     eax, [ebp+var_8]
.text$mn:000049FF                 mov     [edx], eax
.text$mn:00004A01                 mov     esp, ebp
.text$mn:00004A03                 pop     ebp
.text$mn:00004A04                 retn
.text$mn:00004A04 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00004A04
.text$mn:00004A04 ; ---------------------------------------------------------------------------
.text$mn:00004A05                 align 4
.text$mn:00004A05 _text$mn        ends
.text$mn:00004A05
.text$mn:00004A08 ; ===========================================================================
.text$mn:00004A08
.text$mn:00004A08 ; Segment type: Pure code
.text$mn:00004A08 ; Segment permissions: Read/Execute
.text$mn:00004A08 _text$mn        segment para public 'CODE' use32
.text$mn:00004A08                 assume cs:_text$mn
.text$mn:00004A08                 ;org 4A08h
.text$mn:00004A08 ; COMDAT (pick any)
.text$mn:00004A08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A08
.text$mn:00004A08 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A08
.text$mn:00004A08 ; Attributes: bp-based frame
.text$mn:00004A08
.text$mn:00004A08 ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:00004A08                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:00004A08 ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00004A08                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+80p
.text$mn:00004A08                                         ; std::vector<iconLocator,std::allocator<iconLocator>>::_Orphan_range(iconLocator *,iconLocator *)+80p ...
.text$mn:00004A08
.text$mn:00004A08 var_4           = dword ptr -4
.text$mn:00004A08
.text$mn:00004A08                 push    ebp
.text$mn:00004A09                 mov     ebp, esp
.text$mn:00004A0B                 push    ecx
.text$mn:00004A0C                 mov     [ebp+var_4], ecx
.text$mn:00004A0F                 mov     eax, [ebp+var_4]
.text$mn:00004A12                 mov     dword ptr [eax], 0
.text$mn:00004A18                 mov     esp, ebp
.text$mn:00004A1A                 pop     ebp
.text$mn:00004A1B                 retn
.text$mn:00004A1B ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00004A1B
.text$mn:00004A1B _text$mn        ends
.text$mn:00004A1B
.text$mn:00004A1C ; ===========================================================================
.text$mn:00004A1C
.text$mn:00004A1C ; Segment type: Pure code
.text$mn:00004A1C ; Segment permissions: Read/Execute
.text$mn:00004A1C _text$mn        segment para public 'CODE' use32
.text$mn:00004A1C                 assume cs:_text$mn
.text$mn:00004A1C                 ;org 4A1Ch
.text$mn:00004A1C ; COMDAT (pick any)
.text$mn:00004A1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A1C
.text$mn:00004A1C ; =============== S U B R O U T I N E =======================================
.text$mn:00004A1C
.text$mn:00004A1C ; Attributes: bp-based frame
.text$mn:00004A1C
.text$mn:00004A1C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00004A1C                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00004A1C ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00004A1C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00004A1C
.text$mn:00004A1C var_20          = dword ptr -20h
.text$mn:00004A1C var_1C          = dword ptr -1Ch
.text$mn:00004A1C var_18          = dword ptr -18h
.text$mn:00004A1C var_11          = byte ptr -11h
.text$mn:00004A1C var_10          = dword ptr -10h
.text$mn:00004A1C var_C           = byte ptr -0Ch
.text$mn:00004A1C var_4           = dword ptr -4
.text$mn:00004A1C arg_0           = dword ptr  8
.text$mn:00004A1C
.text$mn:00004A1C ; FUNCTION CHUNK AT .text$mn:00004B3E SIZE 00000009 BYTES
.text$mn:00004A1C
.text$mn:00004A1C                 push    ebp
.text$mn:00004A1D                 mov     ebp, esp
.text$mn:00004A1F                 push    0FFFFFFFFh
.text$mn:00004A21                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00004A26                 mov     eax, large fs:0
.text$mn:00004A2C                 push    eax
.text$mn:00004A2D                 push    ecx
.text$mn:00004A2E                 sub     esp, 10h
.text$mn:00004A31                 push    ebx
.text$mn:00004A32                 push    esi
.text$mn:00004A33                 push    edi
.text$mn:00004A34                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004A39                 xor     eax, ebp
.text$mn:00004A3B                 push    eax
.text$mn:00004A3C                 lea     eax, [ebp+var_C]
.text$mn:00004A3F                 mov     large fs:0, eax
.text$mn:00004A45                 mov     [ebp+var_10], esp
.text$mn:00004A48                 mov     [ebp+var_18], ecx
.text$mn:00004A4B                 mov     eax, [ebp+arg_0]
.text$mn:00004A4E                 or      eax, 0Fh
.text$mn:00004A51                 mov     [ebp+var_1C], eax
.text$mn:00004A54                 mov     ecx, [ebp+var_18]
.text$mn:00004A57                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00004A5C                 cmp     eax, [ebp+var_1C]
.text$mn:00004A5F                 jnb     short loc_4A69
.text$mn:00004A61                 mov     ecx, [ebp+arg_0]
.text$mn:00004A64                 mov     [ebp+var_1C], ecx
.text$mn:00004A67                 jmp     short loc_4ABB
.text$mn:00004A69 ; ---------------------------------------------------------------------------
.text$mn:00004A69
.text$mn:00004A69 loc_4A69:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00004A69                 mov     edx, [ebp+var_18]
.text$mn:00004A6C                 mov     ecx, [edx+18h]
.text$mn:00004A6F                 shr     ecx, 1
.text$mn:00004A71                 mov     eax, [ebp+var_1C]
.text$mn:00004A74                 xor     edx, edx
.text$mn:00004A76                 mov     esi, 3
.text$mn:00004A7B                 div     esi
.text$mn:00004A7D                 cmp     ecx, eax
.text$mn:00004A7F                 ja      short loc_4A83
.text$mn:00004A81                 jmp     short loc_4ABB
.text$mn:00004A83 ; ---------------------------------------------------------------------------
.text$mn:00004A83
.text$mn:00004A83 loc_4A83:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00004A83                 mov     ecx, [ebp+var_18]
.text$mn:00004A86                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00004A8B                 mov     edx, [ebp+var_18]
.text$mn:00004A8E                 mov     ecx, [edx+18h]
.text$mn:00004A91                 shr     ecx, 1
.text$mn:00004A93                 sub     eax, ecx
.text$mn:00004A95                 mov     edx, [ebp+var_18]
.text$mn:00004A98                 cmp     [edx+18h], eax
.text$mn:00004A9B                 ja      short loc_4AB0
.text$mn:00004A9D                 mov     eax, [ebp+var_18]
.text$mn:00004AA0                 mov     ecx, [eax+18h]
.text$mn:00004AA3                 shr     ecx, 1
.text$mn:00004AA5                 mov     edx, [ebp+var_18]
.text$mn:00004AA8                 add     ecx, [edx+18h]
.text$mn:00004AAB                 mov     [ebp+var_1C], ecx
.text$mn:00004AAE                 jmp     short loc_4ABB
.text$mn:00004AB0 ; ---------------------------------------------------------------------------
.text$mn:00004AB0
.text$mn:00004AB0 loc_4AB0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00004AB0                 mov     ecx, [ebp+var_18]
.text$mn:00004AB3                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00004AB8                 mov     [ebp+var_1C], eax
.text$mn:00004ABB
.text$mn:00004ABB loc_4ABB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00004ABB                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00004ABB                 mov     [ebp+var_4], 0
.text$mn:00004AC2                 mov     eax, [ebp+var_1C]
.text$mn:00004AC5                 add     eax, 1
.text$mn:00004AC8                 push    eax
.text$mn:00004AC9                 lea     ecx, [ebp+var_11]
.text$mn:00004ACC                 push    ecx
.text$mn:00004ACD                 mov     ecx, [ebp+var_18]
.text$mn:00004AD0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00004AD5                 mov     ecx, eax
.text$mn:00004AD7                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00004ADC                 mov     [ebp+var_20], eax
.text$mn:00004ADF                 jmp     short loc_4B3E
.text$mn:00004ADF ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00004ADF
.text$mn:00004AE1
.text$mn:00004AE1 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AE1
.text$mn:00004AE1
.text$mn:00004AE1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00004AE1                                         ; DATA XREF: .xdata$x:00007C2Co
.text$mn:00004AE1
.text$mn:00004AE1 ; FUNCTION CHUNK AT .text$mn:00004B28 SIZE 00000009 BYTES
.text$mn:00004AE1 ; FUNCTION CHUNK AT .text$mn:00004B38 SIZE 00000006 BYTES
.text$mn:00004AE1
.text$mn:00004AE1                 mov     [ebp-10h], esp
.text$mn:00004AE4                 mov     edx, [ebp+8]
.text$mn:00004AE7                 mov     [ebp-1Ch], edx
.text$mn:00004AEA                 mov     byte ptr [ebp-4], 2
.text$mn:00004AEE                 mov     eax, [ebp-1Ch]
.text$mn:00004AF1                 add     eax, 1
.text$mn:00004AF4                 push    eax
.text$mn:00004AF5                 lea     ecx, [ebp-12h]
.text$mn:00004AF8                 push    ecx
.text$mn:00004AF9                 mov     ecx, [ebp-18h]
.text$mn:00004AFC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00004B01                 mov     ecx, eax
.text$mn:00004B03                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00004B08                 mov     [ebp-20h], eax
.text$mn:00004B0B                 jmp     short loc_4B28
.text$mn:00004B0B __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00004B0B
.text$mn:00004B0D
.text$mn:00004B0D ; =============== S U B R O U T I N E =======================================
.text$mn:00004B0D
.text$mn:00004B0D ; Attributes: noreturn
.text$mn:00004B0D
.text$mn:00004B0D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00004B0D                                         ; DATA XREF: .xdata$x:00007C3Co
.text$mn:00004B0D                 push    0               ; Size
.text$mn:00004B0F                 push    1               ; char
.text$mn:00004B11                 mov     ecx, [ebp-18h]
.text$mn:00004B14                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00004B19                 push    0
.text$mn:00004B1B                 push    0
.text$mn:00004B1D                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00004B1D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00004B1D
.text$mn:00004B22 ; ---------------------------------------------------------------------------
.text$mn:00004B22                 mov     eax, offset $LN17
.text$mn:00004B27                 retn
.text$mn:00004B28 ; ---------------------------------------------------------------------------
.text$mn:00004B28 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00004B28
.text$mn:00004B28 loc_4B28:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00004B28                 mov     dword ptr [ebp-4], 1
.text$mn:00004B2F                 jmp     short loc_4B38
.text$mn:00004B2F ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00004B31
.text$mn:00004B31 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B31
.text$mn:00004B31
.text$mn:00004B31 $LN17           proc near               ; DATA XREF: .text$mn:00004B22o
.text$mn:00004B31                 mov     dword ptr [ebp-4], 1
.text$mn:00004B31 $LN17           endp ; sp-analysis failed
.text$mn:00004B31
.text$mn:00004B38 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00004B38
.text$mn:00004B38 loc_4B38:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00004B38                 mov     eax, offset $LN19
.text$mn:00004B3D                 retn
.text$mn:00004B3D ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00004B3E ; ---------------------------------------------------------------------------
.text$mn:00004B3E ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00004B3E
.text$mn:00004B3E loc_4B3E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00004B3E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004B45                 jmp     short loc_4B4E
.text$mn:00004B45 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00004B47
.text$mn:00004B47 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B47
.text$mn:00004B47
.text$mn:00004B47 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_4B38o
.text$mn:00004B47                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00004B4E
.text$mn:00004B4E loc_4B4E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00004B4E                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00004B52                 jbe     short loc_4B6D
.text$mn:00004B54                 mov     edx, [ebp+0Ch]
.text$mn:00004B57                 push    edx             ; Size
.text$mn:00004B58                 mov     ecx, [ebp-18h]
.text$mn:00004B5B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004B60                 push    eax             ; Src
.text$mn:00004B61                 mov     eax, [ebp-20h]
.text$mn:00004B64                 push    eax             ; Dst
.text$mn:00004B65                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00004B6A                 add     esp, 0Ch
.text$mn:00004B6D
.text$mn:00004B6D loc_4B6D:                               ; CODE XREF: $LN19+Bj
.text$mn:00004B6D                 push    0               ; Size
.text$mn:00004B6F                 push    1               ; char
.text$mn:00004B71                 mov     ecx, [ebp-18h]
.text$mn:00004B74                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00004B79                 lea     ecx, [ebp-20h]
.text$mn:00004B7C                 push    ecx             ; int
.text$mn:00004B7D                 mov     edx, [ebp-18h]
.text$mn:00004B80                 add     edx, 4
.text$mn:00004B83                 push    edx             ; void *
.text$mn:00004B84                 lea     eax, [ebp-13h]
.text$mn:00004B87                 push    eax
.text$mn:00004B88                 mov     ecx, [ebp-18h]
.text$mn:00004B8B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00004B90                 mov     ecx, eax
.text$mn:00004B92                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00004B97                 mov     ecx, [ebp-18h]
.text$mn:00004B9A                 mov     edx, [ebp-1Ch]
.text$mn:00004B9D                 mov     [ecx+18h], edx
.text$mn:00004BA0                 mov     eax, [ebp+0Ch]
.text$mn:00004BA3                 push    eax
.text$mn:00004BA4                 mov     ecx, [ebp-18h]
.text$mn:00004BA7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00004BAC                 mov     ecx, [ebp-0Ch]
.text$mn:00004BAF                 mov     large fs:0, ecx
.text$mn:00004BB6                 pop     ecx
.text$mn:00004BB7                 pop     edi
.text$mn:00004BB8                 pop     esi
.text$mn:00004BB9                 pop     ebx
.text$mn:00004BBA                 mov     esp, ebp
.text$mn:00004BBC                 pop     ebp
.text$mn:00004BBD                 retn    8
.text$mn:00004BBD $LN19           endp ; sp-analysis failed
.text$mn:00004BBD
.text$mn:00004BBD _text$mn        ends
.text$mn:00004BBD
.text$x:00004BC0 ; ===========================================================================
.text$x:00004BC0
.text$x:00004BC0 ; Segment type: Pure code
.text$x:00004BC0 ; Segment permissions: Read/Execute
.text$x:00004BC0 _text$x         segment para public 'CODE' use32
.text$x:00004BC0                 assume cs:_text$x
.text$x:00004BC0                 ;org 4BC0h
.text$x:00004BC0 ; COMDAT (pick associative to section at 4A1C)
.text$x:00004BC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004BC0
.text$x:00004BC0 ; =============== S U B R O U T I N E =======================================
.text$x:00004BC0
.text$x:00004BC0
.text$x:00004BC0 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00004BC0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00004BC0
.text$x:00004BC0 arg_4           = dword ptr  8
.text$x:00004BC0
.text$x:00004BC0                 mov     edx, [esp+arg_4]
.text$x:00004BC4                 lea     eax, [edx+0Ch]
.text$x:00004BC7                 mov     ecx, [edx-24h]
.text$x:00004BCA                 xor     ecx, eax
.text$x:00004BCC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004BD1                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00004BD6                 jmp     ___CxxFrameHandler3
.text$x:00004BD6 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00004BD6
.text$x:00004BD6 ; ---------------------------------------------------------------------------
.text$x:00004BDB                 align 4
.text$x:00004BDB _text$x         ends
.text$x:00004BDB
.text$mn:00004BDC ; ===========================================================================
.text$mn:00004BDC
.text$mn:00004BDC ; Segment type: Pure code
.text$mn:00004BDC ; Segment permissions: Read/Execute
.text$mn:00004BDC _text$mn        segment para public 'CODE' use32
.text$mn:00004BDC                 assume cs:_text$mn
.text$mn:00004BDC                 ;org 4BDCh
.text$mn:00004BDC ; COMDAT (pick any)
.text$mn:00004BDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BDC
.text$mn:00004BDC ; =============== S U B R O U T I N E =======================================
.text$mn:00004BDC
.text$mn:00004BDC ; Attributes: bp-based frame
.text$mn:00004BDC
.text$mn:00004BDC ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:00004BDC                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00004BDC ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:00004BDC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:00004BDC
.text$mn:00004BDC var_20          = dword ptr -20h
.text$mn:00004BDC var_1C          = dword ptr -1Ch
.text$mn:00004BDC var_18          = dword ptr -18h
.text$mn:00004BDC var_11          = byte ptr -11h
.text$mn:00004BDC var_10          = dword ptr -10h
.text$mn:00004BDC var_C           = byte ptr -0Ch
.text$mn:00004BDC var_4           = dword ptr -4
.text$mn:00004BDC arg_0           = dword ptr  8
.text$mn:00004BDC
.text$mn:00004BDC ; FUNCTION CHUNK AT .text$mn:00004CFE SIZE 00000009 BYTES
.text$mn:00004BDC
.text$mn:00004BDC                 push    ebp
.text$mn:00004BDD                 mov     ebp, esp
.text$mn:00004BDF                 push    0FFFFFFFFh
.text$mn:00004BE1                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00004BE6                 mov     eax, large fs:0
.text$mn:00004BEC                 push    eax
.text$mn:00004BED                 push    ecx
.text$mn:00004BEE                 sub     esp, 10h
.text$mn:00004BF1                 push    ebx
.text$mn:00004BF2                 push    esi
.text$mn:00004BF3                 push    edi
.text$mn:00004BF4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004BF9                 xor     eax, ebp
.text$mn:00004BFB                 push    eax
.text$mn:00004BFC                 lea     eax, [ebp+var_C]
.text$mn:00004BFF                 mov     large fs:0, eax
.text$mn:00004C05                 mov     [ebp+var_10], esp
.text$mn:00004C08                 mov     [ebp+var_18], ecx
.text$mn:00004C0B                 mov     eax, [ebp+arg_0]
.text$mn:00004C0E                 or      eax, 7
.text$mn:00004C11                 mov     [ebp+var_1C], eax
.text$mn:00004C14                 mov     ecx, [ebp+var_18]
.text$mn:00004C17                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00004C1C                 cmp     eax, [ebp+var_1C]
.text$mn:00004C1F                 jnb     short loc_4C29
.text$mn:00004C21                 mov     ecx, [ebp+arg_0]
.text$mn:00004C24                 mov     [ebp+var_1C], ecx
.text$mn:00004C27                 jmp     short loc_4C7B
.text$mn:00004C29 ; ---------------------------------------------------------------------------
.text$mn:00004C29
.text$mn:00004C29 loc_4C29:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:00004C29                 mov     edx, [ebp+var_18]
.text$mn:00004C2C                 mov     ecx, [edx+18h]
.text$mn:00004C2F                 shr     ecx, 1
.text$mn:00004C31                 mov     eax, [ebp+var_1C]
.text$mn:00004C34                 xor     edx, edx
.text$mn:00004C36                 mov     esi, 3
.text$mn:00004C3B                 div     esi
.text$mn:00004C3D                 cmp     ecx, eax
.text$mn:00004C3F                 ja      short loc_4C43
.text$mn:00004C41                 jmp     short loc_4C7B
.text$mn:00004C43 ; ---------------------------------------------------------------------------
.text$mn:00004C43
.text$mn:00004C43 loc_4C43:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:00004C43                 mov     ecx, [ebp+var_18]
.text$mn:00004C46                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00004C4B                 mov     edx, [ebp+var_18]
.text$mn:00004C4E                 mov     ecx, [edx+18h]
.text$mn:00004C51                 shr     ecx, 1
.text$mn:00004C53                 sub     eax, ecx
.text$mn:00004C55                 mov     edx, [ebp+var_18]
.text$mn:00004C58                 cmp     [edx+18h], eax
.text$mn:00004C5B                 ja      short loc_4C70
.text$mn:00004C5D                 mov     eax, [ebp+var_18]
.text$mn:00004C60                 mov     ecx, [eax+18h]
.text$mn:00004C63                 shr     ecx, 1
.text$mn:00004C65                 mov     edx, [ebp+var_18]
.text$mn:00004C68                 add     ecx, [edx+18h]
.text$mn:00004C6B                 mov     [ebp+var_1C], ecx
.text$mn:00004C6E                 jmp     short loc_4C7B
.text$mn:00004C70 ; ---------------------------------------------------------------------------
.text$mn:00004C70
.text$mn:00004C70 loc_4C70:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:00004C70                 mov     ecx, [ebp+var_18]
.text$mn:00004C73                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00004C78                 mov     [ebp+var_1C], eax
.text$mn:00004C7B
.text$mn:00004C7B loc_4C7B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:00004C7B                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:00004C7B                 mov     [ebp+var_4], 0
.text$mn:00004C82                 mov     eax, [ebp+var_1C]
.text$mn:00004C85                 add     eax, 1
.text$mn:00004C88                 push    eax
.text$mn:00004C89                 lea     ecx, [ebp+var_11]
.text$mn:00004C8C                 push    ecx
.text$mn:00004C8D                 mov     ecx, [ebp+var_18]
.text$mn:00004C90                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00004C95                 mov     ecx, eax
.text$mn:00004C97                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00004C9C                 mov     [ebp+var_20], eax
.text$mn:00004C9F                 jmp     short loc_4CFE
.text$mn:00004C9F ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:00004C9F
.text$mn:00004CA1
.text$mn:00004CA1 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CA1
.text$mn:00004CA1
.text$mn:00004CA1 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:00004CA1                                         ; DATA XREF: .xdata$x:00008028o
.text$mn:00004CA1
.text$mn:00004CA1 ; FUNCTION CHUNK AT .text$mn:00004CE8 SIZE 00000009 BYTES
.text$mn:00004CA1 ; FUNCTION CHUNK AT .text$mn:00004CF8 SIZE 00000006 BYTES
.text$mn:00004CA1
.text$mn:00004CA1                 mov     [ebp-10h], esp
.text$mn:00004CA4                 mov     edx, [ebp+8]
.text$mn:00004CA7                 mov     [ebp-1Ch], edx
.text$mn:00004CAA                 mov     byte ptr [ebp-4], 2
.text$mn:00004CAE                 mov     eax, [ebp-1Ch]
.text$mn:00004CB1                 add     eax, 1
.text$mn:00004CB4                 push    eax
.text$mn:00004CB5                 lea     ecx, [ebp-12h]
.text$mn:00004CB8                 push    ecx
.text$mn:00004CB9                 mov     ecx, [ebp-18h]
.text$mn:00004CBC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00004CC1                 mov     ecx, eax
.text$mn:00004CC3                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00004CC8                 mov     [ebp-20h], eax
.text$mn:00004CCB                 jmp     short loc_4CE8
.text$mn:00004CCB __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:00004CCB
.text$mn:00004CCD
.text$mn:00004CCD ; =============== S U B R O U T I N E =======================================
.text$mn:00004CCD
.text$mn:00004CCD ; Attributes: noreturn
.text$mn:00004CCD
.text$mn:00004CCD __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:00004CCD                                         ; DATA XREF: .xdata$x:00008038o
.text$mn:00004CCD                 push    0
.text$mn:00004CCF                 push    1
.text$mn:00004CD1                 mov     ecx, [ebp-18h]
.text$mn:00004CD4                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00004CD9                 push    0
.text$mn:00004CDB                 push    0
.text$mn:00004CDD                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00004CDD __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:00004CDD
.text$mn:00004CE2 ; ---------------------------------------------------------------------------
.text$mn:00004CE2                 mov     eax, offset $LN17_0
.text$mn:00004CE7                 retn
.text$mn:00004CE8 ; ---------------------------------------------------------------------------
.text$mn:00004CE8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00004CE8
.text$mn:00004CE8 loc_4CE8:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00004CE8                 mov     dword ptr [ebp-4], 1
.text$mn:00004CEF                 jmp     short loc_4CF8
.text$mn:00004CEF ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00004CF1
.text$mn:00004CF1 ; =============== S U B R O U T I N E =======================================
.text$mn:00004CF1
.text$mn:00004CF1
.text$mn:00004CF1 $LN17_0         proc near               ; DATA XREF: .text$mn:00004CE2o
.text$mn:00004CF1                 mov     dword ptr [ebp-4], 1
.text$mn:00004CF1 $LN17_0         endp ; sp-analysis failed
.text$mn:00004CF1
.text$mn:00004CF8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00004CF8
.text$mn:00004CF8 loc_4CF8:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00004CF8                 mov     eax, offset $LN19_0
.text$mn:00004CFD                 retn
.text$mn:00004CFD ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00004CFE ; ---------------------------------------------------------------------------
.text$mn:00004CFE ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00004CFE
.text$mn:00004CFE loc_4CFE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:00004CFE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004D05                 jmp     short loc_4D0E
.text$mn:00004D05 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00004D07
.text$mn:00004D07 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D07
.text$mn:00004D07
.text$mn:00004D07 $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_4CF8o
.text$mn:00004D07                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00004D0E
.text$mn:00004D0E loc_4D0E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:00004D0E                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00004D12                 jbe     short loc_4D2D
.text$mn:00004D14                 mov     edx, [ebp+0Ch]
.text$mn:00004D17                 push    edx             ; int
.text$mn:00004D18                 mov     ecx, [ebp-18h]
.text$mn:00004D1B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004D20                 push    eax             ; Src
.text$mn:00004D21                 mov     eax, [ebp-20h]
.text$mn:00004D24                 push    eax             ; Dst
.text$mn:00004D25                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00004D2A                 add     esp, 0Ch
.text$mn:00004D2D
.text$mn:00004D2D loc_4D2D:                               ; CODE XREF: $LN19_0+Bj
.text$mn:00004D2D                 push    0
.text$mn:00004D2F                 push    1
.text$mn:00004D31                 mov     ecx, [ebp-18h]
.text$mn:00004D34                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00004D39                 lea     ecx, [ebp-20h]
.text$mn:00004D3C                 push    ecx             ; int
.text$mn:00004D3D                 mov     edx, [ebp-18h]
.text$mn:00004D40                 add     edx, 4
.text$mn:00004D43                 push    edx             ; void *
.text$mn:00004D44                 lea     eax, [ebp-13h]
.text$mn:00004D47                 push    eax
.text$mn:00004D48                 mov     ecx, [ebp-18h]
.text$mn:00004D4B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00004D50                 mov     ecx, eax
.text$mn:00004D52                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00004D57                 mov     ecx, [ebp-18h]
.text$mn:00004D5A                 mov     edx, [ebp-1Ch]
.text$mn:00004D5D                 mov     [ecx+18h], edx
.text$mn:00004D60                 mov     eax, [ebp+0Ch]
.text$mn:00004D63                 push    eax
.text$mn:00004D64                 mov     ecx, [ebp-18h]
.text$mn:00004D67                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00004D6C                 mov     ecx, [ebp-0Ch]
.text$mn:00004D6F                 mov     large fs:0, ecx
.text$mn:00004D76                 pop     ecx
.text$mn:00004D77                 pop     edi
.text$mn:00004D78                 pop     esi
.text$mn:00004D79                 pop     ebx
.text$mn:00004D7A                 mov     esp, ebp
.text$mn:00004D7C                 pop     ebp
.text$mn:00004D7D                 retn    8
.text$mn:00004D7D $LN19_0         endp ; sp-analysis failed
.text$mn:00004D7D
.text$mn:00004D7D _text$mn        ends
.text$mn:00004D7D
.text$x:00004D80 ; ===========================================================================
.text$x:00004D80
.text$x:00004D80 ; Segment type: Pure code
.text$x:00004D80 ; Segment permissions: Read/Execute
.text$x:00004D80 _text$x         segment para public 'CODE' use32
.text$x:00004D80                 assume cs:_text$x
.text$x:00004D80                 ;org 4D80h
.text$x:00004D80 ; COMDAT (pick associative to section at 4BDC)
.text$x:00004D80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004D80
.text$x:00004D80 ; =============== S U B R O U T I N E =======================================
.text$x:00004D80
.text$x:00004D80
.text$x:00004D80 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:00004D80                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:00004D80
.text$x:00004D80 arg_4           = dword ptr  8
.text$x:00004D80
.text$x:00004D80                 mov     edx, [esp+arg_4]
.text$x:00004D84                 lea     eax, [edx+0Ch]
.text$x:00004D87                 mov     ecx, [edx-24h]
.text$x:00004D8A                 xor     ecx, eax
.text$x:00004D8C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004D91                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:00004D96                 jmp     ___CxxFrameHandler3
.text$x:00004D96 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:00004D96
.text$x:00004D96 ; ---------------------------------------------------------------------------
.text$x:00004D9B                 align 4
.text$x:00004D9B _text$x         ends
.text$x:00004D9B
.text$mn:00004D9C ; ===========================================================================
.text$mn:00004D9C
.text$mn:00004D9C ; Segment type: Pure code
.text$mn:00004D9C ; Segment permissions: Read/Execute
.text$mn:00004D9C _text$mn        segment para public 'CODE' use32
.text$mn:00004D9C                 assume cs:_text$mn
.text$mn:00004D9C                 ;org 4D9Ch
.text$mn:00004D9C ; COMDAT (pick any)
.text$mn:00004D9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D9C
.text$mn:00004D9C ; =============== S U B R O U T I N E =======================================
.text$mn:00004D9C
.text$mn:00004D9C ; Attributes: bp-based frame
.text$mn:00004D9C
.text$mn:00004D9C ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Destroy(int *, int *)
.text$mn:00004D9C                 public ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
.text$mn:00004D9C ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z proc near
.text$mn:00004D9C                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+CBp
.text$mn:00004D9C                                         ; std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+9Ep
.text$mn:00004D9C
.text$mn:00004D9C var_8           = dword ptr -8
.text$mn:00004D9C var_1           = byte ptr -1
.text$mn:00004D9C arg_0           = dword ptr  8
.text$mn:00004D9C arg_4           = dword ptr  0Ch
.text$mn:00004D9C
.text$mn:00004D9C                 push    ebp
.text$mn:00004D9D                 mov     ebp, esp
.text$mn:00004D9F                 sub     esp, 8
.text$mn:00004DA2                 mov     [ebp+var_8], ecx
.text$mn:00004DA5                 lea     eax, [ebp+var_1]
.text$mn:00004DA8                 push    eax
.text$mn:00004DA9                 mov     ecx, [ebp+var_8]
.text$mn:00004DAC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00004DB1                 lea     ecx, [ebp+var_1]
.text$mn:00004DB4                 push    ecx
.text$mn:00004DB5                 mov     edx, [ebp+arg_4]
.text$mn:00004DB8                 push    edx
.text$mn:00004DB9                 mov     eax, [ebp+arg_0]
.text$mn:00004DBC                 push    eax
.text$mn:00004DBD                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@@std@@YAXPAH0AAU?$_Wrap_alloc@V?$allocator@H@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<int>>>(int *,int *,std::_Wrap_alloc<std::allocator<int>> &)
.text$mn:00004DC2                 add     esp, 0Ch
.text$mn:00004DC5                 mov     esp, ebp
.text$mn:00004DC7                 pop     ebp
.text$mn:00004DC8                 retn    8
.text$mn:00004DC8 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z endp
.text$mn:00004DC8
.text$mn:00004DC8 ; ---------------------------------------------------------------------------
.text$mn:00004DCB                 align 4
.text$mn:00004DCB _text$mn        ends
.text$mn:00004DCB
.text$mn:00004DCC ; ===========================================================================
.text$mn:00004DCC
.text$mn:00004DCC ; Segment type: Pure code
.text$mn:00004DCC ; Segment permissions: Read/Execute
.text$mn:00004DCC _text$mn        segment para public 'CODE' use32
.text$mn:00004DCC                 assume cs:_text$mn
.text$mn:00004DCC                 ;org 4DCCh
.text$mn:00004DCC ; COMDAT (pick any)
.text$mn:00004DCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DCC
.text$mn:00004DCC ; =============== S U B R O U T I N E =======================================
.text$mn:00004DCC
.text$mn:00004DCC ; Attributes: bp-based frame
.text$mn:00004DCC
.text$mn:00004DCC ; protected: void __thiscall std::vector<struct iconLocator, class std::allocator<struct iconLocator>>::_Destroy(struct iconLocator *, struct iconLocator *)
.text$mn:00004DCC                 public ?_Destroy@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXPAUiconLocator@@0@Z
.text$mn:00004DCC ?_Destroy@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXPAUiconLocator@@0@Z proc near
.text$mn:00004DCC                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Reallocate(uint)+CBp
.text$mn:00004DCC
.text$mn:00004DCC var_8           = dword ptr -8
.text$mn:00004DCC var_1           = byte ptr -1
.text$mn:00004DCC arg_0           = dword ptr  8
.text$mn:00004DCC arg_4           = dword ptr  0Ch
.text$mn:00004DCC
.text$mn:00004DCC                 push    ebp
.text$mn:00004DCD                 mov     ebp, esp
.text$mn:00004DCF                 sub     esp, 8
.text$mn:00004DD2                 mov     [ebp+var_8], ecx
.text$mn:00004DD5                 lea     eax, [ebp+var_1]
.text$mn:00004DD8                 push    eax
.text$mn:00004DD9                 mov     ecx, [ebp+var_8]
.text$mn:00004DDC                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<iconLocator,std::allocator<iconLocator>>>::_Getal(void)
.text$mn:00004DE1                 lea     ecx, [ebp+var_1]
.text$mn:00004DE4                 push    ecx
.text$mn:00004DE5                 mov     edx, [ebp+arg_4]
.text$mn:00004DE8                 push    edx
.text$mn:00004DE9                 mov     eax, [ebp+arg_0]
.text$mn:00004DEC                 push    eax
.text$mn:00004DED                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@@std@@YAXPAUiconLocator@@0AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<iconLocator>>>(iconLocator *,iconLocator *,std::_Wrap_alloc<std::allocator<iconLocator>> &)
.text$mn:00004DF2                 add     esp, 0Ch
.text$mn:00004DF5                 mov     esp, ebp
.text$mn:00004DF7                 pop     ebp
.text$mn:00004DF8                 retn    8
.text$mn:00004DF8 ?_Destroy@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXPAUiconLocator@@0@Z endp
.text$mn:00004DF8
.text$mn:00004DF8 ; ---------------------------------------------------------------------------
.text$mn:00004DFB                 align 4
.text$mn:00004DFB _text$mn        ends
.text$mn:00004DFB
.text$mn:00004DFC ; ===========================================================================
.text$mn:00004DFC
.text$mn:00004DFC ; Segment type: Pure code
.text$mn:00004DFC ; Segment permissions: Read/Execute
.text$mn:00004DFC _text$mn        segment para public 'CODE' use32
.text$mn:00004DFC                 assume cs:_text$mn
.text$mn:00004DFC                 ;org 4DFCh
.text$mn:00004DFC ; COMDAT (pick any)
.text$mn:00004DFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DFC
.text$mn:00004DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00004DFC
.text$mn:00004DFC ; Attributes: bp-based frame
.text$mn:00004DFC
.text$mn:00004DFC ; protected: void __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::_Destroy(struct tDynamicList *, struct tDynamicList *)
.text$mn:00004DFC                 public ?_Destroy@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXPAUtDynamicList@@0@Z
.text$mn:00004DFC ?_Destroy@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXPAUtDynamicList@@0@Z proc near
.text$mn:00004DFC                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reallocate(uint)+CBp
.text$mn:00004DFC
.text$mn:00004DFC var_8           = dword ptr -8
.text$mn:00004DFC var_1           = byte ptr -1
.text$mn:00004DFC arg_0           = dword ptr  8
.text$mn:00004DFC arg_4           = dword ptr  0Ch
.text$mn:00004DFC
.text$mn:00004DFC                 push    ebp
.text$mn:00004DFD                 mov     ebp, esp
.text$mn:00004DFF                 sub     esp, 8
.text$mn:00004E02                 mov     [ebp+var_8], ecx
.text$mn:00004E05                 lea     eax, [ebp+var_1]
.text$mn:00004E08                 push    eax
.text$mn:00004E09                 mov     ecx, [ebp+var_8]
.text$mn:00004E0C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tDynamicList,std::allocator<tDynamicList>>>::_Getal(void)
.text$mn:00004E11                 lea     ecx, [ebp+var_1]
.text$mn:00004E14                 push    ecx
.text$mn:00004E15                 mov     edx, [ebp+arg_4]
.text$mn:00004E18                 push    edx
.text$mn:00004E19                 mov     eax, [ebp+arg_0]
.text$mn:00004E1C                 push    eax
.text$mn:00004E1D                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@@std@@YAXPAUtDynamicList@@0AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<tDynamicList>>>(tDynamicList *,tDynamicList *,std::_Wrap_alloc<std::allocator<tDynamicList>> &)
.text$mn:00004E22                 add     esp, 0Ch
.text$mn:00004E25                 mov     esp, ebp
.text$mn:00004E27                 pop     ebp
.text$mn:00004E28                 retn    8
.text$mn:00004E28 ?_Destroy@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXPAUtDynamicList@@0@Z endp
.text$mn:00004E28
.text$mn:00004E28 ; ---------------------------------------------------------------------------
.text$mn:00004E2B                 align 4
.text$mn:00004E2B _text$mn        ends
.text$mn:00004E2B
.text$mn:00004E2C ; ===========================================================================
.text$mn:00004E2C
.text$mn:00004E2C ; Segment type: Pure code
.text$mn:00004E2C ; Segment permissions: Read/Execute
.text$mn:00004E2C _text$mn        segment para public 'CODE' use32
.text$mn:00004E2C                 assume cs:_text$mn
.text$mn:00004E2C                 ;org 4E2Ch
.text$mn:00004E2C ; COMDAT (pick any)
.text$mn:00004E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E2C
.text$mn:00004E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00004E2C
.text$mn:00004E2C ; Attributes: bp-based frame
.text$mn:00004E2C
.text$mn:00004E2C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00004E2C                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00004E2C ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00004E2C                                         ; CODE XREF: $LN19+60p
.text$mn:00004E2C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00004E2C
.text$mn:00004E2C var_8           = dword ptr -8
.text$mn:00004E2C var_1           = byte ptr -1
.text$mn:00004E2C arg_0           = dword ptr  8
.text$mn:00004E2C
.text$mn:00004E2C                 push    ebp
.text$mn:00004E2D                 mov     ebp, esp
.text$mn:00004E2F                 sub     esp, 8
.text$mn:00004E32                 mov     [ebp+var_8], ecx
.text$mn:00004E35                 mov     [ebp+var_1], 0
.text$mn:00004E39                 mov     eax, [ebp+var_8]
.text$mn:00004E3C                 mov     ecx, [ebp+arg_0]
.text$mn:00004E3F                 mov     [eax+14h], ecx
.text$mn:00004E42                 lea     edx, [ebp+var_1]
.text$mn:00004E45                 push    edx
.text$mn:00004E46                 mov     ecx, [ebp+var_8]
.text$mn:00004E49                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004E4E                 add     eax, [ebp+arg_0]
.text$mn:00004E51                 push    eax
.text$mn:00004E52                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00004E57                 add     esp, 8
.text$mn:00004E5A                 mov     esp, ebp
.text$mn:00004E5C                 pop     ebp
.text$mn:00004E5D                 retn    4
.text$mn:00004E5D ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00004E5D
.text$mn:00004E5D _text$mn        ends
.text$mn:00004E5D
.text$mn:00004E60 ; ===========================================================================
.text$mn:00004E60
.text$mn:00004E60 ; Segment type: Pure code
.text$mn:00004E60 ; Segment permissions: Read/Execute
.text$mn:00004E60 _text$mn        segment para public 'CODE' use32
.text$mn:00004E60                 assume cs:_text$mn
.text$mn:00004E60                 ;org 4E60h
.text$mn:00004E60 ; COMDAT (pick any)
.text$mn:00004E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E60
.text$mn:00004E60 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E60
.text$mn:00004E60 ; Attributes: bp-based frame
.text$mn:00004E60
.text$mn:00004E60 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:00004E60                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00004E60 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00004E60                                         ; CODE XREF: $LN19_0+60p
.text$mn:00004E60                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:00004E60
.text$mn:00004E60 var_8           = dword ptr -8
.text$mn:00004E60 var_2           = word ptr -2
.text$mn:00004E60 arg_0           = dword ptr  8
.text$mn:00004E60
.text$mn:00004E60                 push    ebp
.text$mn:00004E61                 mov     ebp, esp
.text$mn:00004E63                 sub     esp, 8
.text$mn:00004E66                 mov     [ebp+var_8], ecx
.text$mn:00004E69                 xor     eax, eax
.text$mn:00004E6B                 mov     [ebp+var_2], ax
.text$mn:00004E6F                 mov     ecx, [ebp+var_8]
.text$mn:00004E72                 mov     edx, [ebp+arg_0]
.text$mn:00004E75                 mov     [ecx+14h], edx
.text$mn:00004E78                 lea     eax, [ebp+var_2]
.text$mn:00004E7B                 push    eax
.text$mn:00004E7C                 mov     ecx, [ebp+var_8]
.text$mn:00004E7F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00004E84                 mov     ecx, [ebp+arg_0]
.text$mn:00004E87                 lea     edx, [eax+ecx*2]
.text$mn:00004E8A                 push    edx
.text$mn:00004E8B                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00004E90                 add     esp, 8
.text$mn:00004E93                 mov     esp, ebp
.text$mn:00004E95                 pop     ebp
.text$mn:00004E96                 retn    4
.text$mn:00004E96 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:00004E96
.text$mn:00004E96 ; ---------------------------------------------------------------------------
.text$mn:00004E99                 align 4
.text$mn:00004E99 _text$mn        ends
.text$mn:00004E99
.text$mn:00004E9C ; ===========================================================================
.text$mn:00004E9C
.text$mn:00004E9C ; Segment type: Pure code
.text$mn:00004E9C ; Segment permissions: Read/Execute
.text$mn:00004E9C _text$mn        segment para public 'CODE' use32
.text$mn:00004E9C                 assume cs:_text$mn
.text$mn:00004E9C                 ;org 4E9Ch
.text$mn:00004E9C ; COMDAT (pick any)
.text$mn:00004E9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E9C
.text$mn:00004E9C ; =============== S U B R O U T I N E =======================================
.text$mn:00004E9C
.text$mn:00004E9C ; Attributes: bp-based frame
.text$mn:00004E9C
.text$mn:00004E9C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00004E9C                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00004E9C ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00004E9C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00004E9C
.text$mn:00004E9C var_8           = dword ptr -8
.text$mn:00004E9C var_1           = byte ptr -1
.text$mn:00004E9C
.text$mn:00004E9C                 push    ebp
.text$mn:00004E9D                 mov     ebp, esp
.text$mn:00004E9F                 sub     esp, 8
.text$mn:00004EA2                 mov     [ebp+var_8], ecx
.text$mn:00004EA5                 lea     ecx, [ebp+var_1]
.text$mn:00004EA8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00004EAD                 mov     ecx, [ebp+var_8] ; this
.text$mn:00004EB0                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00004EB5                 mov     eax, [ebp+var_8]
.text$mn:00004EB8                 mov     ecx, [eax]
.text$mn:00004EBA                 push    ecx
.text$mn:00004EBB                 lea     ecx, [ebp+var_1]
.text$mn:00004EBE                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00004EC3                 push    1               ; int
.text$mn:00004EC5                 mov     edx, [ebp+var_8]
.text$mn:00004EC8                 mov     eax, [edx]
.text$mn:00004ECA                 push    eax             ; void *
.text$mn:00004ECB                 lea     ecx, [ebp+var_1]
.text$mn:00004ECE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00004ED3                 mov     ecx, [ebp+var_8]
.text$mn:00004ED6                 mov     dword ptr [ecx], 0
.text$mn:00004EDC                 mov     esp, ebp
.text$mn:00004EDE                 pop     ebp
.text$mn:00004EDF                 retn
.text$mn:00004EDF ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00004EDF
.text$mn:00004EDF _text$mn        ends
.text$mn:00004EDF
.text$mn:00004EE0 ; ===========================================================================
.text$mn:00004EE0
.text$mn:00004EE0 ; Segment type: Pure code
.text$mn:00004EE0 ; Segment permissions: Read/Execute
.text$mn:00004EE0 _text$mn        segment para public 'CODE' use32
.text$mn:00004EE0                 assume cs:_text$mn
.text$mn:00004EE0                 ;org 4EE0h
.text$mn:00004EE0 ; COMDAT (pick any)
.text$mn:00004EE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004EE0
.text$mn:00004EE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EE0
.text$mn:00004EE0 ; Attributes: bp-based frame
.text$mn:00004EE0
.text$mn:00004EE0 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00004EE0                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00004EE0 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00004EE0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00004EE0
.text$mn:00004EE0 var_8           = dword ptr -8
.text$mn:00004EE0 var_1           = byte ptr -1
.text$mn:00004EE0
.text$mn:00004EE0                 push    ebp
.text$mn:00004EE1                 mov     ebp, esp
.text$mn:00004EE3                 sub     esp, 8
.text$mn:00004EE6                 mov     [ebp+var_8], ecx
.text$mn:00004EE9                 lea     ecx, [ebp+var_1]
.text$mn:00004EEC                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00004EF1                 mov     ecx, [ebp+var_8] ; this
.text$mn:00004EF4                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00004EF9                 mov     eax, [ebp+var_8]
.text$mn:00004EFC                 mov     ecx, [eax]
.text$mn:00004EFE                 push    ecx
.text$mn:00004EFF                 lea     ecx, [ebp+var_1]
.text$mn:00004F02                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00004F07                 push    1               ; int
.text$mn:00004F09                 mov     edx, [ebp+var_8]
.text$mn:00004F0C                 mov     eax, [edx]
.text$mn:00004F0E                 push    eax             ; void *
.text$mn:00004F0F                 lea     ecx, [ebp+var_1]
.text$mn:00004F12                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00004F17                 mov     ecx, [ebp+var_8]
.text$mn:00004F1A                 mov     dword ptr [ecx], 0
.text$mn:00004F20                 mov     esp, ebp
.text$mn:00004F22                 pop     ebp
.text$mn:00004F23                 retn
.text$mn:00004F23 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00004F23
.text$mn:00004F23 _text$mn        ends
.text$mn:00004F23
.text$mn:00004F24 ; ===========================================================================
.text$mn:00004F24
.text$mn:00004F24 ; Segment type: Pure code
.text$mn:00004F24 ; Segment permissions: Read/Execute
.text$mn:00004F24 _text$mn        segment para public 'CODE' use32
.text$mn:00004F24                 assume cs:_text$mn
.text$mn:00004F24                 ;org 4F24h
.text$mn:00004F24 ; COMDAT (pick any)
.text$mn:00004F24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F24
.text$mn:00004F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F24
.text$mn:00004F24 ; Attributes: bp-based frame
.text$mn:00004F24
.text$mn:00004F24 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00004F24                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00004F24 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00004F24                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00004F24                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00004F24
.text$mn:00004F24 var_4           = dword ptr -4
.text$mn:00004F24 arg_0           = dword ptr  8
.text$mn:00004F24
.text$mn:00004F24                 push    ebp
.text$mn:00004F25                 mov     ebp, esp
.text$mn:00004F27                 push    ecx
.text$mn:00004F28                 mov     [ebp+var_4], ecx
.text$mn:00004F2B                 mov     ecx, [ebp+arg_0]
.text$mn:00004F2E                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00004F33                 mov     eax, [ebp+arg_0]
.text$mn:00004F36                 mov     esp, ebp
.text$mn:00004F38                 pop     ebp
.text$mn:00004F39                 retn    4
.text$mn:00004F39 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00004F39
.text$mn:00004F39 _text$mn        ends
.text$mn:00004F39
.text$mn:00004F3C ; ===========================================================================
.text$mn:00004F3C
.text$mn:00004F3C ; Segment type: Pure code
.text$mn:00004F3C ; Segment permissions: Read/Execute
.text$mn:00004F3C _text$mn        segment para public 'CODE' use32
.text$mn:00004F3C                 assume cs:_text$mn
.text$mn:00004F3C                 ;org 4F3Ch
.text$mn:00004F3C ; COMDAT (pick any)
.text$mn:00004F3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F3C
.text$mn:00004F3C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F3C
.text$mn:00004F3C ; Attributes: bp-based frame
.text$mn:00004F3C
.text$mn:00004F3C ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00004F3C                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00004F3C ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00004F3C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+33p
.text$mn:00004F3C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+B4p ...
.text$mn:00004F3C
.text$mn:00004F3C var_4           = dword ptr -4
.text$mn:00004F3C arg_0           = dword ptr  8
.text$mn:00004F3C
.text$mn:00004F3C                 push    ebp
.text$mn:00004F3D                 mov     ebp, esp
.text$mn:00004F3F                 push    ecx
.text$mn:00004F40                 mov     [ebp+var_4], ecx
.text$mn:00004F43                 mov     ecx, [ebp+arg_0]
.text$mn:00004F46                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:00004F4B                 mov     eax, [ebp+arg_0]
.text$mn:00004F4E                 mov     esp, ebp
.text$mn:00004F50                 pop     ebp
.text$mn:00004F51                 retn    4
.text$mn:00004F51 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00004F51
.text$mn:00004F51 _text$mn        ends
.text$mn:00004F51
.text$mn:00004F54 ; ===========================================================================
.text$mn:00004F54
.text$mn:00004F54 ; Segment type: Pure code
.text$mn:00004F54 ; Segment permissions: Read/Execute
.text$mn:00004F54 _text$mn        segment para public 'CODE' use32
.text$mn:00004F54                 assume cs:_text$mn
.text$mn:00004F54                 ;org 4F54h
.text$mn:00004F54 ; COMDAT (pick any)
.text$mn:00004F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F54
.text$mn:00004F54 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F54
.text$mn:00004F54 ; Attributes: bp-based frame
.text$mn:00004F54
.text$mn:00004F54 ; public: struct std::_Wrap_alloc<class std::allocator<int>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<int, class std::allocator<int>>>::_Getal(void)const
.text$mn:00004F54                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ
.text$mn:00004F54 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ proc near
.text$mn:00004F54                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Umove<int *>(int *,int *,int *)+10p
.text$mn:00004F54                                         ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)+10p ...
.text$mn:00004F54
.text$mn:00004F54 var_4           = dword ptr -4
.text$mn:00004F54 arg_0           = dword ptr  8
.text$mn:00004F54
.text$mn:00004F54                 push    ebp
.text$mn:00004F55                 mov     ebp, esp
.text$mn:00004F57                 push    ecx
.text$mn:00004F58                 mov     [ebp+var_4], ecx
.text$mn:00004F5B                 mov     ecx, [ebp+arg_0]
.text$mn:00004F5E                 call    ??0?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<int>>::_Wrap_alloc<std::allocator<int>>(void)
.text$mn:00004F63                 mov     eax, [ebp+arg_0]
.text$mn:00004F66                 mov     esp, ebp
.text$mn:00004F68                 pop     ebp
.text$mn:00004F69                 retn    4
.text$mn:00004F69 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ endp
.text$mn:00004F69
.text$mn:00004F69 _text$mn        ends
.text$mn:00004F69
.text$mn:00004F6C ; ===========================================================================
.text$mn:00004F6C
.text$mn:00004F6C ; Segment type: Pure code
.text$mn:00004F6C ; Segment permissions: Read/Execute
.text$mn:00004F6C _text$mn        segment para public 'CODE' use32
.text$mn:00004F6C                 assume cs:_text$mn
.text$mn:00004F6C                 ;org 4F6Ch
.text$mn:00004F6C ; COMDAT (pick any)
.text$mn:00004F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F6C
.text$mn:00004F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F6C
.text$mn:00004F6C ; Attributes: bp-based frame
.text$mn:00004F6C
.text$mn:00004F6C ; public: struct std::_Wrap_alloc<class std::allocator<struct iconLocator>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct iconLocator, class std::allocator<struct iconLocator>>>::_Getal(void)const
.text$mn:00004F6C                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@2@XZ
.text$mn:00004F6C ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@2@XZ proc near
.text$mn:00004F6C                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Umove<iconLocator *>(iconLocator *,iconLocator *,iconLocator *)+10p
.text$mn:00004F6C                                         ; std::vector<iconLocator,std::allocator<iconLocator>>::_Destroy(iconLocator *,iconLocator *)+10p ...
.text$mn:00004F6C
.text$mn:00004F6C var_4           = dword ptr -4
.text$mn:00004F6C arg_0           = dword ptr  8
.text$mn:00004F6C
.text$mn:00004F6C                 push    ebp
.text$mn:00004F6D                 mov     ebp, esp
.text$mn:00004F6F                 push    ecx
.text$mn:00004F70                 mov     [ebp+var_4], ecx
.text$mn:00004F73                 mov     ecx, [ebp+arg_0]
.text$mn:00004F76                 call    ??0?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<iconLocator>>::_Wrap_alloc<std::allocator<iconLocator>>(void)
.text$mn:00004F7B                 mov     eax, [ebp+arg_0]
.text$mn:00004F7E                 mov     esp, ebp
.text$mn:00004F80                 pop     ebp
.text$mn:00004F81                 retn    4
.text$mn:00004F81 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@2@XZ endp
.text$mn:00004F81
.text$mn:00004F81 _text$mn        ends
.text$mn:00004F81
.text$mn:00004F84 ; ===========================================================================
.text$mn:00004F84
.text$mn:00004F84 ; Segment type: Pure code
.text$mn:00004F84 ; Segment permissions: Read/Execute
.text$mn:00004F84 _text$mn        segment para public 'CODE' use32
.text$mn:00004F84                 assume cs:_text$mn
.text$mn:00004F84                 ;org 4F84h
.text$mn:00004F84 ; COMDAT (pick any)
.text$mn:00004F84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F84
.text$mn:00004F84 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F84
.text$mn:00004F84 ; Attributes: bp-based frame
.text$mn:00004F84
.text$mn:00004F84 ; public: struct std::_Wrap_alloc<class std::allocator<struct tDynamicList>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<struct tDynamicList, class std::allocator<struct tDynamicList>>>::_Getal(void)const
.text$mn:00004F84                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@2@XZ
.text$mn:00004F84 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@2@XZ proc near
.text$mn:00004F84                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Umove<tDynamicList *>(tDynamicList *,tDynamicList *,tDynamicList *)+10p
.text$mn:00004F84                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Destroy(tDynamicList *,tDynamicList *)+10p ...
.text$mn:00004F84
.text$mn:00004F84 var_4           = dword ptr -4
.text$mn:00004F84 arg_0           = dword ptr  8
.text$mn:00004F84
.text$mn:00004F84                 push    ebp
.text$mn:00004F85                 mov     ebp, esp
.text$mn:00004F87                 push    ecx
.text$mn:00004F88                 mov     [ebp+var_4], ecx
.text$mn:00004F8B                 mov     ecx, [ebp+arg_0]
.text$mn:00004F8E                 call    ??0?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<tDynamicList>>::_Wrap_alloc<std::allocator<tDynamicList>>(void)
.text$mn:00004F93                 mov     eax, [ebp+arg_0]
.text$mn:00004F96                 mov     esp, ebp
.text$mn:00004F98                 pop     ebp
.text$mn:00004F99                 retn    4
.text$mn:00004F99 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@2@XZ endp
.text$mn:00004F99
.text$mn:00004F99 _text$mn        ends
.text$mn:00004F99
.text$mn:00004F9C ; ===========================================================================
.text$mn:00004F9C
.text$mn:00004F9C ; Segment type: Pure code
.text$mn:00004F9C ; Segment permissions: Read/Execute
.text$mn:00004F9C _text$mn        segment para public 'CODE' use32
.text$mn:00004F9C                 assume cs:_text$mn
.text$mn:00004F9C                 ;org 4F9Ch
.text$mn:00004F9C ; COMDAT (pick any)
.text$mn:00004F9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F9C
.text$mn:00004F9C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F9C
.text$mn:00004F9C ; Attributes: bp-based frame
.text$mn:00004F9C
.text$mn:00004F9C ; const struct std::_Container_base12 *__thiscall std::_Iterator_base12::_Getcont(std::_Iterator_base12 *__hidden this)
.text$mn:00004F9C                 public ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
.text$mn:00004F9C ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ proc near
.text$mn:00004F9C                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+=(int)+Bp
.text$mn:00004F9C                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+=(int)+23p ...
.text$mn:00004F9C
.text$mn:00004F9C var_8           = dword ptr -8
.text$mn:00004F9C var_4           = dword ptr -4
.text$mn:00004F9C
.text$mn:00004F9C                 push    ebp
.text$mn:00004F9D                 mov     ebp, esp
.text$mn:00004F9F                 sub     esp, 8
.text$mn:00004FA2                 mov     [ebp+var_4], ecx
.text$mn:00004FA5                 mov     eax, [ebp+var_4]
.text$mn:00004FA8                 cmp     dword ptr [eax], 0
.text$mn:00004FAB                 jnz     short loc_4FB6
.text$mn:00004FAD                 mov     [ebp+var_8], 0
.text$mn:00004FB4                 jmp     short loc_4FC0
.text$mn:00004FB6 ; ---------------------------------------------------------------------------
.text$mn:00004FB6
.text$mn:00004FB6 loc_4FB6:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+Fj
.text$mn:00004FB6                 mov     ecx, [ebp+var_4]
.text$mn:00004FB9                 mov     edx, [ecx]
.text$mn:00004FBB                 mov     eax, [edx]
.text$mn:00004FBD                 mov     [ebp+var_8], eax
.text$mn:00004FC0
.text$mn:00004FC0 loc_4FC0:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+18j
.text$mn:00004FC0                 mov     eax, [ebp+var_8]
.text$mn:00004FC3                 mov     esp, ebp
.text$mn:00004FC5                 pop     ebp
.text$mn:00004FC6                 retn
.text$mn:00004FC6 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ endp
.text$mn:00004FC6
.text$mn:00004FC6 ; ---------------------------------------------------------------------------
.text$mn:00004FC7                 align 4
.text$mn:00004FC7 _text$mn        ends
.text$mn:00004FC7
.text$mn:00004FC8 ; ===========================================================================
.text$mn:00004FC8
.text$mn:00004FC8 ; Segment type: Pure code
.text$mn:00004FC8 ; Segment permissions: Read/Execute
.text$mn:00004FC8 _text$mn        segment para public 'CODE' use32
.text$mn:00004FC8                 assume cs:_text$mn
.text$mn:00004FC8                 ;org 4FC8h
.text$mn:00004FC8 ; COMDAT (pick any)
.text$mn:00004FC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FC8
.text$mn:00004FC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FC8
.text$mn:00004FC8 ; Attributes: bp-based frame
.text$mn:00004FC8
.text$mn:00004FC8 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:00004FC8                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:00004FC8 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:00004FC8                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+3Cp
.text$mn:00004FC8                                         ; std::vector<iconLocator,std::allocator<iconLocator>>::_Orphan_range(iconLocator *,iconLocator *)+3Cp ...
.text$mn:00004FC8
.text$mn:00004FC8 var_8           = dword ptr -8
.text$mn:00004FC8 var_4           = dword ptr -4
.text$mn:00004FC8
.text$mn:00004FC8                 push    ebp
.text$mn:00004FC9                 mov     ebp, esp
.text$mn:00004FCB                 sub     esp, 8
.text$mn:00004FCE                 mov     [ebp+var_4], ecx
.text$mn:00004FD1                 mov     eax, [ebp+var_4]
.text$mn:00004FD4                 cmp     dword ptr [eax], 0
.text$mn:00004FD7                 jnz     short loc_4FE2
.text$mn:00004FD9                 mov     [ebp+var_8], 0
.text$mn:00004FE0                 jmp     short loc_4FED
.text$mn:00004FE2 ; ---------------------------------------------------------------------------
.text$mn:00004FE2
.text$mn:00004FE2 loc_4FE2:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:00004FE2                 mov     ecx, [ebp+var_4]
.text$mn:00004FE5                 mov     edx, [ecx]
.text$mn:00004FE7                 add     edx, 4
.text$mn:00004FEA                 mov     [ebp+var_8], edx
.text$mn:00004FED
.text$mn:00004FED loc_4FED:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:00004FED                 mov     eax, [ebp+var_8]
.text$mn:00004FF0                 mov     esp, ebp
.text$mn:00004FF2                 pop     ebp
.text$mn:00004FF3                 retn
.text$mn:00004FF3 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:00004FF3
.text$mn:00004FF3 _text$mn        ends
.text$mn:00004FF3
.text$mn:00004FF4 ; ===========================================================================
.text$mn:00004FF4
.text$mn:00004FF4 ; Segment type: Pure code
.text$mn:00004FF4 ; Segment permissions: Read/Execute
.text$mn:00004FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004FF4                 assume cs:_text$mn
.text$mn:00004FF4                 ;org 4FF4h
.text$mn:00004FF4 ; COMDAT (pick any)
.text$mn:00004FF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FF4
.text$mn:00004FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FF4
.text$mn:00004FF4 ; Attributes: bp-based frame
.text$mn:00004FF4
.text$mn:00004FF4 ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:00004FF4                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:00004FF4 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:00004FF4                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+71p
.text$mn:00004FF4                                         ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+8Ap ...
.text$mn:00004FF4
.text$mn:00004FF4 var_4           = dword ptr -4
.text$mn:00004FF4
.text$mn:00004FF4                 push    ebp
.text$mn:00004FF5                 mov     ebp, esp
.text$mn:00004FF7                 push    ecx
.text$mn:00004FF8                 mov     [ebp+var_4], ecx
.text$mn:00004FFB                 mov     eax, [ebp+var_4]
.text$mn:00004FFE                 add     eax, 4
.text$mn:00005001                 mov     esp, ebp
.text$mn:00005003                 pop     ebp
.text$mn:00005004                 retn
.text$mn:00005004 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:00005004
.text$mn:00005004 ; ---------------------------------------------------------------------------
.text$mn:00005005                 align 4
.text$mn:00005005 _text$mn        ends
.text$mn:00005005
.text$mn:00005008 ; ===========================================================================
.text$mn:00005008
.text$mn:00005008 ; Segment type: Pure code
.text$mn:00005008 ; Segment permissions: Read/Execute
.text$mn:00005008 _text$mn        segment para public 'CODE' use32
.text$mn:00005008                 assume cs:_text$mn
.text$mn:00005008                 ;org 5008h
.text$mn:00005008 ; COMDAT (pick any)
.text$mn:00005008                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005008
.text$mn:00005008 ; =============== S U B R O U T I N E =======================================
.text$mn:00005008
.text$mn:00005008 ; Attributes: bp-based frame
.text$mn:00005008
.text$mn:00005008 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00005008                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00005008 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00005008                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00005008                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00005008
.text$mn:00005008 var_C           = dword ptr -0Ch
.text$mn:00005008 Size            = dword ptr -8
.text$mn:00005008 var_4           = dword ptr -4
.text$mn:00005008 arg_0           = dword ptr  8
.text$mn:00005008 arg_4           = byte ptr  0Ch
.text$mn:00005008
.text$mn:00005008                 push    ebp
.text$mn:00005009                 mov     ebp, esp
.text$mn:0000500B                 sub     esp, 0Ch
.text$mn:0000500E                 mov     [ebp+var_4], ecx
.text$mn:00005011                 mov     ecx, [ebp+var_4]
.text$mn:00005014                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00005019                 cmp     eax, [ebp+arg_0]
.text$mn:0000501C                 jnb     short loc_5026
.text$mn:0000501E                 mov     ecx, [ebp+var_4]
.text$mn:00005021                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00005026
.text$mn:00005026 loc_5026:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00005026                 mov     eax, [ebp+var_4]
.text$mn:00005029                 mov     ecx, [eax+18h]
.text$mn:0000502C                 cmp     ecx, [ebp+arg_0]
.text$mn:0000502F                 jnb     short loc_5046
.text$mn:00005031                 mov     edx, [ebp+var_4]
.text$mn:00005034                 mov     eax, [edx+14h]
.text$mn:00005037                 push    eax
.text$mn:00005038                 mov     ecx, [ebp+arg_0]
.text$mn:0000503B                 push    ecx
.text$mn:0000503C                 mov     ecx, [ebp+var_4]
.text$mn:0000503F                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00005044                 jmp     short loc_5090
.text$mn:00005046 ; ---------------------------------------------------------------------------
.text$mn:00005046
.text$mn:00005046 loc_5046:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00005046                 movzx   edx, [ebp+arg_4]
.text$mn:0000504A                 test    edx, edx
.text$mn:0000504C                 jz      short loc_5080
.text$mn:0000504E                 cmp     [ebp+arg_0], 10h
.text$mn:00005052                 jnb     short loc_5080
.text$mn:00005054                 mov     eax, [ebp+var_4]
.text$mn:00005057                 mov     ecx, [ebp+arg_0]
.text$mn:0000505A                 cmp     ecx, [eax+14h]
.text$mn:0000505D                 jnb     short loc_5067
.text$mn:0000505F                 mov     edx, [ebp+arg_0]
.text$mn:00005062                 mov     [ebp+Size], edx
.text$mn:00005065                 jmp     short loc_5070
.text$mn:00005067 ; ---------------------------------------------------------------------------
.text$mn:00005067
.text$mn:00005067 loc_5067:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00005067                 mov     eax, [ebp+var_4]
.text$mn:0000506A                 mov     ecx, [eax+14h]
.text$mn:0000506D                 mov     [ebp+Size], ecx
.text$mn:00005070
.text$mn:00005070 loc_5070:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00005070                 mov     edx, [ebp+Size]
.text$mn:00005073                 push    edx             ; Size
.text$mn:00005074                 push    1               ; char
.text$mn:00005076                 mov     ecx, [ebp+var_4]
.text$mn:00005079                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000507E                 jmp     short loc_5090
.text$mn:00005080 ; ---------------------------------------------------------------------------
.text$mn:00005080
.text$mn:00005080 loc_5080:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00005080                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00005080                 cmp     [ebp+arg_0], 0
.text$mn:00005084                 jnz     short loc_5090
.text$mn:00005086                 push    0
.text$mn:00005088                 mov     ecx, [ebp+var_4]
.text$mn:0000508B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005090
.text$mn:00005090 loc_5090:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00005090                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00005090                 cmp     [ebp+arg_0], 0
.text$mn:00005094                 jbe     short loc_509F
.text$mn:00005096                 mov     [ebp+var_C], 1
.text$mn:0000509D                 jmp     short loc_50A6
.text$mn:0000509F ; ---------------------------------------------------------------------------
.text$mn:0000509F
.text$mn:0000509F loc_509F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000509F                 mov     [ebp+var_C], 0
.text$mn:000050A6
.text$mn:000050A6 loc_50A6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:000050A6                 mov     al, byte ptr [ebp+var_C]
.text$mn:000050A9                 mov     esp, ebp
.text$mn:000050AB                 pop     ebp
.text$mn:000050AC                 retn    8
.text$mn:000050AC ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:000050AC
.text$mn:000050AC ; ---------------------------------------------------------------------------
.text$mn:000050AF                 align 10h
.text$mn:000050AF _text$mn        ends
.text$mn:000050AF
.text$mn:000050B0 ; ===========================================================================
.text$mn:000050B0
.text$mn:000050B0 ; Segment type: Pure code
.text$mn:000050B0 ; Segment permissions: Read/Execute
.text$mn:000050B0 _text$mn        segment para public 'CODE' use32
.text$mn:000050B0                 assume cs:_text$mn
.text$mn:000050B0                 ;org 50B0h
.text$mn:000050B0 ; COMDAT (pick any)
.text$mn:000050B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050B0
.text$mn:000050B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000050B0
.text$mn:000050B0 ; Attributes: bp-based frame
.text$mn:000050B0
.text$mn:000050B0 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:000050B0                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:000050B0 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:000050B0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Dp
.text$mn:000050B0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+8Ep ...
.text$mn:000050B0
.text$mn:000050B0 var_C           = dword ptr -0Ch
.text$mn:000050B0 var_8           = dword ptr -8
.text$mn:000050B0 var_4           = dword ptr -4
.text$mn:000050B0 arg_0           = dword ptr  8
.text$mn:000050B0 arg_4           = byte ptr  0Ch
.text$mn:000050B0
.text$mn:000050B0                 push    ebp
.text$mn:000050B1                 mov     ebp, esp
.text$mn:000050B3                 sub     esp, 0Ch
.text$mn:000050B6                 mov     [ebp+var_4], ecx
.text$mn:000050B9                 mov     ecx, [ebp+var_4]
.text$mn:000050BC                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000050C1                 cmp     eax, [ebp+arg_0]
.text$mn:000050C4                 jnb     short loc_50CE
.text$mn:000050C6                 mov     ecx, [ebp+var_4]
.text$mn:000050C9                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:000050CE
.text$mn:000050CE loc_50CE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:000050CE                 mov     eax, [ebp+var_4]
.text$mn:000050D1                 mov     ecx, [eax+18h]
.text$mn:000050D4                 cmp     ecx, [ebp+arg_0]
.text$mn:000050D7                 jnb     short loc_50EE
.text$mn:000050D9                 mov     edx, [ebp+var_4]
.text$mn:000050DC                 mov     eax, [edx+14h]
.text$mn:000050DF                 push    eax
.text$mn:000050E0                 mov     ecx, [ebp+arg_0]
.text$mn:000050E3                 push    ecx
.text$mn:000050E4                 mov     ecx, [ebp+var_4]
.text$mn:000050E7                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:000050EC                 jmp     short loc_5138
.text$mn:000050EE ; ---------------------------------------------------------------------------
.text$mn:000050EE
.text$mn:000050EE loc_50EE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:000050EE                 movzx   edx, [ebp+arg_4]
.text$mn:000050F2                 test    edx, edx
.text$mn:000050F4                 jz      short loc_5128
.text$mn:000050F6                 cmp     [ebp+arg_0], 8
.text$mn:000050FA                 jnb     short loc_5128
.text$mn:000050FC                 mov     eax, [ebp+var_4]
.text$mn:000050FF                 mov     ecx, [ebp+arg_0]
.text$mn:00005102                 cmp     ecx, [eax+14h]
.text$mn:00005105                 jnb     short loc_510F
.text$mn:00005107                 mov     edx, [ebp+arg_0]
.text$mn:0000510A                 mov     [ebp+var_8], edx
.text$mn:0000510D                 jmp     short loc_5118
.text$mn:0000510F ; ---------------------------------------------------------------------------
.text$mn:0000510F
.text$mn:0000510F loc_510F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:0000510F                 mov     eax, [ebp+var_4]
.text$mn:00005112                 mov     ecx, [eax+14h]
.text$mn:00005115                 mov     [ebp+var_8], ecx
.text$mn:00005118
.text$mn:00005118 loc_5118:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:00005118                 mov     edx, [ebp+var_8]
.text$mn:0000511B                 push    edx
.text$mn:0000511C                 push    1
.text$mn:0000511E                 mov     ecx, [ebp+var_4]
.text$mn:00005121                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00005126                 jmp     short loc_5138
.text$mn:00005128 ; ---------------------------------------------------------------------------
.text$mn:00005128
.text$mn:00005128 loc_5128:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:00005128                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:00005128                 cmp     [ebp+arg_0], 0
.text$mn:0000512C                 jnz     short loc_5138
.text$mn:0000512E                 push    0
.text$mn:00005130                 mov     ecx, [ebp+var_4]
.text$mn:00005133                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00005138
.text$mn:00005138 loc_5138:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:00005138                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:00005138                 cmp     [ebp+arg_0], 0
.text$mn:0000513C                 jbe     short loc_5147
.text$mn:0000513E                 mov     [ebp+var_C], 1
.text$mn:00005145                 jmp     short loc_514E
.text$mn:00005147 ; ---------------------------------------------------------------------------
.text$mn:00005147
.text$mn:00005147 loc_5147:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:00005147                 mov     [ebp+var_C], 0
.text$mn:0000514E
.text$mn:0000514E loc_514E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:0000514E                 mov     al, byte ptr [ebp+var_C]
.text$mn:00005151                 mov     esp, ebp
.text$mn:00005153                 pop     ebp
.text$mn:00005154                 retn    8
.text$mn:00005154 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:00005154
.text$mn:00005154 ; ---------------------------------------------------------------------------
.text$mn:00005157                 align 4
.text$mn:00005157 _text$mn        ends
.text$mn:00005157
.text$mn:00005158 ; ===========================================================================
.text$mn:00005158
.text$mn:00005158 ; Segment type: Pure code
.text$mn:00005158 ; Segment permissions: Read/Execute
.text$mn:00005158 _text$mn        segment para public 'CODE' use32
.text$mn:00005158                 assume cs:_text$mn
.text$mn:00005158                 ;org 5158h
.text$mn:00005158 ; COMDAT (pick any)
.text$mn:00005158                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005158
.text$mn:00005158 ; =============== S U B R O U T I N E =======================================
.text$mn:00005158
.text$mn:00005158 ; Attributes: bp-based frame
.text$mn:00005158
.text$mn:00005158 ; protected: unsigned int __thiscall std::vector<int, class std::allocator<int>>::_Grow_to(unsigned int)const
.text$mn:00005158                 public ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z
.text$mn:00005158 ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z proc near
.text$mn:00005158                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+45p
.text$mn:00005158
.text$mn:00005158 var_C           = dword ptr -0Ch
.text$mn:00005158 var_8           = dword ptr -8
.text$mn:00005158 var_4           = dword ptr -4
.text$mn:00005158 arg_0           = dword ptr  8
.text$mn:00005158
.text$mn:00005158                 push    ebp
.text$mn:00005159                 mov     ebp, esp
.text$mn:0000515B                 sub     esp, 0Ch
.text$mn:0000515E                 mov     [ebp+var_8], ecx
.text$mn:00005161                 mov     ecx, [ebp+var_8]
.text$mn:00005164                 call    ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::capacity(void)
.text$mn:00005169                 mov     [ebp+var_4], eax
.text$mn:0000516C                 mov     ecx, [ebp+var_8]
.text$mn:0000516F                 call    ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::max_size(void)
.text$mn:00005174                 mov     ecx, [ebp+var_4]
.text$mn:00005177                 shr     ecx, 1
.text$mn:00005179                 sub     eax, ecx
.text$mn:0000517B                 cmp     eax, [ebp+var_4]
.text$mn:0000517E                 jnb     short loc_5189
.text$mn:00005180                 mov     [ebp+var_C], 0
.text$mn:00005187                 jmp     short loc_5194
.text$mn:00005189 ; ---------------------------------------------------------------------------
.text$mn:00005189
.text$mn:00005189 loc_5189:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+26j
.text$mn:00005189                 mov     edx, [ebp+var_4]
.text$mn:0000518C                 shr     edx, 1
.text$mn:0000518E                 add     edx, [ebp+var_4]
.text$mn:00005191                 mov     [ebp+var_C], edx
.text$mn:00005194
.text$mn:00005194 loc_5194:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+2Fj
.text$mn:00005194                 mov     eax, [ebp+var_C]
.text$mn:00005197                 mov     [ebp+var_4], eax
.text$mn:0000519A                 mov     ecx, [ebp+var_4]
.text$mn:0000519D                 cmp     ecx, [ebp+arg_0]
.text$mn:000051A0                 jnb     short loc_51A8
.text$mn:000051A2                 mov     edx, [ebp+arg_0]
.text$mn:000051A5                 mov     [ebp+var_4], edx
.text$mn:000051A8
.text$mn:000051A8 loc_51A8:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+48j
.text$mn:000051A8                 mov     eax, [ebp+var_4]
.text$mn:000051AB                 mov     esp, ebp
.text$mn:000051AD                 pop     ebp
.text$mn:000051AE                 retn    4
.text$mn:000051AE ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z endp
.text$mn:000051AE
.text$mn:000051AE ; ---------------------------------------------------------------------------
.text$mn:000051B1                 align 4
.text$mn:000051B1 _text$mn        ends
.text$mn:000051B1
.text$mn:000051B4 ; ===========================================================================
.text$mn:000051B4
.text$mn:000051B4 ; Segment type: Pure code
.text$mn:000051B4 ; Segment permissions: Read/Execute
.text$mn:000051B4 _text$mn        segment para public 'CODE' use32
.text$mn:000051B4                 assume cs:_text$mn
.text$mn:000051B4                 ;org 51B4h
.text$mn:000051B4 ; COMDAT (pick any)
.text$mn:000051B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000051B4
.text$mn:000051B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000051B4
.text$mn:000051B4 ; Attributes: bp-based frame
.text$mn:000051B4
.text$mn:000051B4 ; protected: unsigned int __thiscall std::vector<struct iconLocator, class std::allocator<struct iconLocator>>::_Grow_to(unsigned int)const
.text$mn:000051B4                 public ?_Grow_to@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEII@Z
.text$mn:000051B4 ?_Grow_to@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEII@Z proc near
.text$mn:000051B4                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Reserve(uint)+45p
.text$mn:000051B4
.text$mn:000051B4 var_C           = dword ptr -0Ch
.text$mn:000051B4 var_8           = dword ptr -8
.text$mn:000051B4 var_4           = dword ptr -4
.text$mn:000051B4 arg_0           = dword ptr  8
.text$mn:000051B4
.text$mn:000051B4                 push    ebp
.text$mn:000051B5                 mov     ebp, esp
.text$mn:000051B7                 sub     esp, 0Ch
.text$mn:000051BA                 mov     [ebp+var_8], ecx
.text$mn:000051BD                 mov     ecx, [ebp+var_8]
.text$mn:000051C0                 call    ?capacity@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ ; std::vector<iconLocator,std::allocator<iconLocator>>::capacity(void)
.text$mn:000051C5                 mov     [ebp+var_4], eax
.text$mn:000051C8                 mov     ecx, [ebp+var_8]
.text$mn:000051CB                 call    ?max_size@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ ; std::vector<iconLocator,std::allocator<iconLocator>>::max_size(void)
.text$mn:000051D0                 mov     ecx, [ebp+var_4]
.text$mn:000051D3                 shr     ecx, 1
.text$mn:000051D5                 sub     eax, ecx
.text$mn:000051D7                 cmp     eax, [ebp+var_4]
.text$mn:000051DA                 jnb     short loc_51E5
.text$mn:000051DC                 mov     [ebp+var_C], 0
.text$mn:000051E3                 jmp     short loc_51F0
.text$mn:000051E5 ; ---------------------------------------------------------------------------
.text$mn:000051E5
.text$mn:000051E5 loc_51E5:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Grow_to(uint)+26j
.text$mn:000051E5                 mov     edx, [ebp+var_4]
.text$mn:000051E8                 shr     edx, 1
.text$mn:000051EA                 add     edx, [ebp+var_4]
.text$mn:000051ED                 mov     [ebp+var_C], edx
.text$mn:000051F0
.text$mn:000051F0 loc_51F0:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Grow_to(uint)+2Fj
.text$mn:000051F0                 mov     eax, [ebp+var_C]
.text$mn:000051F3                 mov     [ebp+var_4], eax
.text$mn:000051F6                 mov     ecx, [ebp+var_4]
.text$mn:000051F9                 cmp     ecx, [ebp+arg_0]
.text$mn:000051FC                 jnb     short loc_5204
.text$mn:000051FE                 mov     edx, [ebp+arg_0]
.text$mn:00005201                 mov     [ebp+var_4], edx
.text$mn:00005204
.text$mn:00005204 loc_5204:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Grow_to(uint)+48j
.text$mn:00005204                 mov     eax, [ebp+var_4]
.text$mn:00005207                 mov     esp, ebp
.text$mn:00005209                 pop     ebp
.text$mn:0000520A                 retn    4
.text$mn:0000520A ?_Grow_to@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEII@Z endp
.text$mn:0000520A
.text$mn:0000520A ; ---------------------------------------------------------------------------
.text$mn:0000520D                 align 10h
.text$mn:0000520D _text$mn        ends
.text$mn:0000520D
.text$mn:00005210 ; ===========================================================================
.text$mn:00005210
.text$mn:00005210 ; Segment type: Pure code
.text$mn:00005210 ; Segment permissions: Read/Execute
.text$mn:00005210 _text$mn        segment para public 'CODE' use32
.text$mn:00005210                 assume cs:_text$mn
.text$mn:00005210                 ;org 5210h
.text$mn:00005210 ; COMDAT (pick any)
.text$mn:00005210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005210
.text$mn:00005210 ; =============== S U B R O U T I N E =======================================
.text$mn:00005210
.text$mn:00005210 ; Attributes: bp-based frame
.text$mn:00005210
.text$mn:00005210 ; protected: unsigned int __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::_Grow_to(unsigned int)const
.text$mn:00005210                 public ?_Grow_to@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEII@Z
.text$mn:00005210 ?_Grow_to@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEII@Z proc near
.text$mn:00005210                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reserve(uint)+45p
.text$mn:00005210
.text$mn:00005210 var_C           = dword ptr -0Ch
.text$mn:00005210 var_8           = dword ptr -8
.text$mn:00005210 var_4           = dword ptr -4
.text$mn:00005210 arg_0           = dword ptr  8
.text$mn:00005210
.text$mn:00005210                 push    ebp
.text$mn:00005211                 mov     ebp, esp
.text$mn:00005213                 sub     esp, 0Ch
.text$mn:00005216                 mov     [ebp+var_8], ecx
.text$mn:00005219                 mov     ecx, [ebp+var_8]
.text$mn:0000521C                 call    ?capacity@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ ; std::vector<tDynamicList,std::allocator<tDynamicList>>::capacity(void)
.text$mn:00005221                 mov     [ebp+var_4], eax
.text$mn:00005224                 mov     ecx, [ebp+var_8]
.text$mn:00005227                 call    ?max_size@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ ; std::vector<tDynamicList,std::allocator<tDynamicList>>::max_size(void)
.text$mn:0000522C                 mov     ecx, [ebp+var_4]
.text$mn:0000522F                 shr     ecx, 1
.text$mn:00005231                 sub     eax, ecx
.text$mn:00005233                 cmp     eax, [ebp+var_4]
.text$mn:00005236                 jnb     short loc_5241
.text$mn:00005238                 mov     [ebp+var_C], 0
.text$mn:0000523F                 jmp     short loc_524C
.text$mn:00005241 ; ---------------------------------------------------------------------------
.text$mn:00005241
.text$mn:00005241 loc_5241:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Grow_to(uint)+26j
.text$mn:00005241                 mov     edx, [ebp+var_4]
.text$mn:00005244                 shr     edx, 1
.text$mn:00005246                 add     edx, [ebp+var_4]
.text$mn:00005249                 mov     [ebp+var_C], edx
.text$mn:0000524C
.text$mn:0000524C loc_524C:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Grow_to(uint)+2Fj
.text$mn:0000524C                 mov     eax, [ebp+var_C]
.text$mn:0000524F                 mov     [ebp+var_4], eax
.text$mn:00005252                 mov     ecx, [ebp+var_4]
.text$mn:00005255                 cmp     ecx, [ebp+arg_0]
.text$mn:00005258                 jnb     short loc_5260
.text$mn:0000525A                 mov     edx, [ebp+arg_0]
.text$mn:0000525D                 mov     [ebp+var_4], edx
.text$mn:00005260
.text$mn:00005260 loc_5260:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Grow_to(uint)+48j
.text$mn:00005260                 mov     eax, [ebp+var_4]
.text$mn:00005263                 mov     esp, ebp
.text$mn:00005265                 pop     ebp
.text$mn:00005266                 retn    4
.text$mn:00005266 ?_Grow_to@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEII@Z endp
.text$mn:00005266
.text$mn:00005266 ; ---------------------------------------------------------------------------
.text$mn:00005269                 align 4
.text$mn:00005269 _text$mn        ends
.text$mn:00005269
.text$mn:0000526C ; ===========================================================================
.text$mn:0000526C
.text$mn:0000526C ; Segment type: Pure code
.text$mn:0000526C ; Segment permissions: Read/Execute
.text$mn:0000526C _text$mn        segment para public 'CODE' use32
.text$mn:0000526C                 assume cs:_text$mn
.text$mn:0000526C                 ;org 526Ch
.text$mn:0000526C ; COMDAT (pick any)
.text$mn:0000526C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000526C
.text$mn:0000526C ; =============== S U B R O U T I N E =======================================
.text$mn:0000526C
.text$mn:0000526C ; Attributes: bp-based frame
.text$mn:0000526C
.text$mn:0000526C ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:0000526C                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:0000526C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:0000526C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:0000526C
.text$mn:0000526C var_4           = dword ptr -4
.text$mn:0000526C arg_0           = dword ptr  8
.text$mn:0000526C
.text$mn:0000526C                 push    ebp
.text$mn:0000526D                 mov     ebp, esp
.text$mn:0000526F                 push    ecx
.text$mn:00005270                 mov     [ebp+var_4], ecx
.text$mn:00005273                 cmp     [ebp+arg_0], 0
.text$mn:00005277                 jz      short loc_5299
.text$mn:00005279                 mov     ecx, [ebp+var_4]
.text$mn:0000527C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00005281                 cmp     [ebp+arg_0], eax
.text$mn:00005284                 jb      short loc_5299
.text$mn:00005286                 mov     ecx, [ebp+var_4]
.text$mn:00005289                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000528E                 mov     ecx, [ebp+var_4]
.text$mn:00005291                 add     eax, [ecx+14h]
.text$mn:00005294                 cmp     eax, [ebp+arg_0]
.text$mn:00005297                 ja      short loc_529F
.text$mn:00005299
.text$mn:00005299 loc_5299:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00005299                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00005299                 xor     al, al
.text$mn:0000529B                 jmp     short loc_52A1
.text$mn:0000529D ; ---------------------------------------------------------------------------
.text$mn:0000529D                 jmp     short loc_52A1
.text$mn:0000529F ; ---------------------------------------------------------------------------
.text$mn:0000529F
.text$mn:0000529F loc_529F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000529F                 mov     al, 1
.text$mn:000052A1
.text$mn:000052A1 loc_52A1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000052A1                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000052A1                 mov     esp, ebp
.text$mn:000052A3                 pop     ebp
.text$mn:000052A4                 retn    4
.text$mn:000052A4 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000052A4
.text$mn:000052A4 ; ---------------------------------------------------------------------------
.text$mn:000052A7                 align 4
.text$mn:000052A7 _text$mn        ends
.text$mn:000052A7
.text$mn:000052A8 ; ===========================================================================
.text$mn:000052A8
.text$mn:000052A8 ; Segment type: Pure code
.text$mn:000052A8 ; Segment permissions: Read/Execute
.text$mn:000052A8 _text$mn        segment para public 'CODE' use32
.text$mn:000052A8                 assume cs:_text$mn
.text$mn:000052A8                 ;org 52A8h
.text$mn:000052A8 ; COMDAT (pick any)
.text$mn:000052A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000052A8
.text$mn:000052A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000052A8
.text$mn:000052A8 ; Attributes: bp-based frame
.text$mn:000052A8
.text$mn:000052A8 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:000052A8                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:000052A8 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:000052A8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+2Cp
.text$mn:000052A8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:000052A8
.text$mn:000052A8 var_4           = dword ptr -4
.text$mn:000052A8 arg_0           = dword ptr  8
.text$mn:000052A8
.text$mn:000052A8                 push    ebp
.text$mn:000052A9                 mov     ebp, esp
.text$mn:000052AB                 push    ecx
.text$mn:000052AC                 mov     [ebp+var_4], ecx
.text$mn:000052AF                 cmp     [ebp+arg_0], 0
.text$mn:000052B3                 jz      short loc_52D8
.text$mn:000052B5                 mov     ecx, [ebp+var_4]
.text$mn:000052B8                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000052BD                 cmp     [ebp+arg_0], eax
.text$mn:000052C0                 jb      short loc_52D8
.text$mn:000052C2                 mov     ecx, [ebp+var_4]
.text$mn:000052C5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000052CA                 mov     ecx, [ebp+var_4]
.text$mn:000052CD                 mov     edx, [ecx+14h]
.text$mn:000052D0                 lea     eax, [eax+edx*2]
.text$mn:000052D3                 cmp     eax, [ebp+arg_0]
.text$mn:000052D6                 ja      short loc_52DE
.text$mn:000052D8
.text$mn:000052D8 loc_52D8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:000052D8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:000052D8                 xor     al, al
.text$mn:000052DA                 jmp     short loc_52E0
.text$mn:000052DC ; ---------------------------------------------------------------------------
.text$mn:000052DC                 jmp     short loc_52E0
.text$mn:000052DE ; ---------------------------------------------------------------------------
.text$mn:000052DE
.text$mn:000052DE loc_52DE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:000052DE                 mov     al, 1
.text$mn:000052E0
.text$mn:000052E0 loc_52E0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:000052E0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:000052E0                 mov     esp, ebp
.text$mn:000052E2                 pop     ebp
.text$mn:000052E3                 retn    4
.text$mn:000052E3 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:000052E3
.text$mn:000052E3 ; ---------------------------------------------------------------------------
.text$mn:000052E6                 align 4
.text$mn:000052E6 _text$mn        ends
.text$mn:000052E6
.text$mn:000052E8 ; ===========================================================================
.text$mn:000052E8
.text$mn:000052E8 ; Segment type: Pure code
.text$mn:000052E8 ; Segment permissions: Read/Execute
.text$mn:000052E8 _text$mn        segment para public 'CODE' use32
.text$mn:000052E8                 assume cs:_text$mn
.text$mn:000052E8                 ;org 52E8h
.text$mn:000052E8 ; COMDAT (pick any)
.text$mn:000052E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000052E8
.text$mn:000052E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000052E8
.text$mn:000052E8 ; Attributes: bp-based frame
.text$mn:000052E8
.text$mn:000052E8 ; protected: bool __thiscall std::vector<int, class std::allocator<int>>::_Inside(int const *)const
.text$mn:000052E8                 public ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z
.text$mn:000052E8 ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z proc near
.text$mn:000052E8                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+19p
.text$mn:000052E8
.text$mn:000052E8 var_8           = dword ptr -8
.text$mn:000052E8 var_4           = dword ptr -4
.text$mn:000052E8 arg_0           = dword ptr  8
.text$mn:000052E8
.text$mn:000052E8                 push    ebp
.text$mn:000052E9                 mov     ebp, esp
.text$mn:000052EB                 sub     esp, 8
.text$mn:000052EE                 mov     [ebp+var_4], ecx
.text$mn:000052F1                 mov     eax, [ebp+var_4]
.text$mn:000052F4                 mov     ecx, [ebp+arg_0]
.text$mn:000052F7                 cmp     ecx, [eax+8]
.text$mn:000052FA                 jnb     short loc_5310
.text$mn:000052FC                 mov     edx, [ebp+var_4]
.text$mn:000052FF                 mov     eax, [edx+4]
.text$mn:00005302                 cmp     eax, [ebp+arg_0]
.text$mn:00005305                 ja      short loc_5310
.text$mn:00005307                 mov     [ebp+var_8], 1
.text$mn:0000530E                 jmp     short loc_5317
.text$mn:00005310 ; ---------------------------------------------------------------------------
.text$mn:00005310
.text$mn:00005310 loc_5310:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Inside(int const *)+12j
.text$mn:00005310                                         ; std::vector<int,std::allocator<int>>::_Inside(int const *)+1Dj
.text$mn:00005310                 mov     [ebp+var_8], 0
.text$mn:00005317
.text$mn:00005317 loc_5317:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Inside(int const *)+26j
.text$mn:00005317                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000531A                 mov     esp, ebp
.text$mn:0000531C                 pop     ebp
.text$mn:0000531D                 retn    4
.text$mn:0000531D ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z endp
.text$mn:0000531D
.text$mn:0000531D _text$mn        ends
.text$mn:0000531D
.text$mn:00005320 ; ===========================================================================
.text$mn:00005320
.text$mn:00005320 ; Segment type: Pure code
.text$mn:00005320 ; Segment permissions: Read/Execute
.text$mn:00005320 _text$mn        segment para public 'CODE' use32
.text$mn:00005320                 assume cs:_text$mn
.text$mn:00005320                 ;org 5320h
.text$mn:00005320 ; COMDAT (pick any)
.text$mn:00005320                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005320
.text$mn:00005320 ; =============== S U B R O U T I N E =======================================
.text$mn:00005320
.text$mn:00005320 ; Attributes: bp-based frame
.text$mn:00005320
.text$mn:00005320 ; protected: bool __thiscall std::vector<struct iconLocator, class std::allocator<struct iconLocator>>::_Inside(struct iconLocator const *)const
.text$mn:00005320                 public ?_Inside@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBE_NPBUiconLocator@@@Z
.text$mn:00005320 ?_Inside@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBE_NPBUiconLocator@@@Z proc near
.text$mn:00005320                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)+19p
.text$mn:00005320
.text$mn:00005320 var_8           = dword ptr -8
.text$mn:00005320 var_4           = dword ptr -4
.text$mn:00005320 arg_0           = dword ptr  8
.text$mn:00005320
.text$mn:00005320                 push    ebp
.text$mn:00005321                 mov     ebp, esp
.text$mn:00005323                 sub     esp, 8
.text$mn:00005326                 mov     [ebp+var_4], ecx
.text$mn:00005329                 mov     eax, [ebp+var_4]
.text$mn:0000532C                 mov     ecx, [ebp+arg_0]
.text$mn:0000532F                 cmp     ecx, [eax+8]
.text$mn:00005332                 jnb     short loc_5348
.text$mn:00005334                 mov     edx, [ebp+var_4]
.text$mn:00005337                 mov     eax, [edx+4]
.text$mn:0000533A                 cmp     eax, [ebp+arg_0]
.text$mn:0000533D                 ja      short loc_5348
.text$mn:0000533F                 mov     [ebp+var_8], 1
.text$mn:00005346                 jmp     short loc_534F
.text$mn:00005348 ; ---------------------------------------------------------------------------
.text$mn:00005348
.text$mn:00005348 loc_5348:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Inside(iconLocator const *)+12j
.text$mn:00005348                                         ; std::vector<iconLocator,std::allocator<iconLocator>>::_Inside(iconLocator const *)+1Dj
.text$mn:00005348                 mov     [ebp+var_8], 0
.text$mn:0000534F
.text$mn:0000534F loc_534F:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Inside(iconLocator const *)+26j
.text$mn:0000534F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00005352                 mov     esp, ebp
.text$mn:00005354                 pop     ebp
.text$mn:00005355                 retn    4
.text$mn:00005355 ?_Inside@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBE_NPBUiconLocator@@@Z endp
.text$mn:00005355
.text$mn:00005355 _text$mn        ends
.text$mn:00005355
.text$mn:00005358 ; ===========================================================================
.text$mn:00005358
.text$mn:00005358 ; Segment type: Pure code
.text$mn:00005358 ; Segment permissions: Read/Execute
.text$mn:00005358 _text$mn        segment para public 'CODE' use32
.text$mn:00005358                 assume cs:_text$mn
.text$mn:00005358                 ;org 5358h
.text$mn:00005358 ; COMDAT (pick any)
.text$mn:00005358                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005358
.text$mn:00005358 ; =============== S U B R O U T I N E =======================================
.text$mn:00005358
.text$mn:00005358 ; Attributes: bp-based frame
.text$mn:00005358
.text$mn:00005358 ; protected: bool __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::_Inside(struct tDynamicList const *)const
.text$mn:00005358                 public ?_Inside@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBE_NPBUtDynamicList@@@Z
.text$mn:00005358 ?_Inside@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBE_NPBUtDynamicList@@@Z proc near
.text$mn:00005358                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::push_back(tDynamicList const &)+19p
.text$mn:00005358
.text$mn:00005358 var_8           = dword ptr -8
.text$mn:00005358 var_4           = dword ptr -4
.text$mn:00005358 arg_0           = dword ptr  8
.text$mn:00005358
.text$mn:00005358                 push    ebp
.text$mn:00005359                 mov     ebp, esp
.text$mn:0000535B                 sub     esp, 8
.text$mn:0000535E                 mov     [ebp+var_4], ecx
.text$mn:00005361                 mov     eax, [ebp+var_4]
.text$mn:00005364                 mov     ecx, [ebp+arg_0]
.text$mn:00005367                 cmp     ecx, [eax+8]
.text$mn:0000536A                 jnb     short loc_5380
.text$mn:0000536C                 mov     edx, [ebp+var_4]
.text$mn:0000536F                 mov     eax, [edx+4]
.text$mn:00005372                 cmp     eax, [ebp+arg_0]
.text$mn:00005375                 ja      short loc_5380
.text$mn:00005377                 mov     [ebp+var_8], 1
.text$mn:0000537E                 jmp     short loc_5387
.text$mn:00005380 ; ---------------------------------------------------------------------------
.text$mn:00005380
.text$mn:00005380 loc_5380:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Inside(tDynamicList const *)+12j
.text$mn:00005380                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Inside(tDynamicList const *)+1Dj
.text$mn:00005380                 mov     [ebp+var_8], 0
.text$mn:00005387
.text$mn:00005387 loc_5387:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Inside(tDynamicList const *)+26j
.text$mn:00005387                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000538A                 mov     esp, ebp
.text$mn:0000538C                 pop     ebp
.text$mn:0000538D                 retn    4
.text$mn:0000538D ?_Inside@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBE_NPBUtDynamicList@@@Z endp
.text$mn:0000538D
.text$mn:0000538D _text$mn        ends
.text$mn:0000538D
.text$mn:00005390 ; ===========================================================================
.text$mn:00005390
.text$mn:00005390 ; Segment type: Pure code
.text$mn:00005390 ; Segment permissions: Read/Execute
.text$mn:00005390 _text$mn        segment para public 'CODE' use32
.text$mn:00005390                 assume cs:_text$mn
.text$mn:00005390                 ;org 5390h
.text$mn:00005390 ; COMDAT (pick any)
.text$mn:00005390                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005390
.text$mn:00005390 ; =============== S U B R O U T I N E =======================================
.text$mn:00005390
.text$mn:00005390 ; Attributes: bp-based frame
.text$mn:00005390
.text$mn:00005390 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> __thiscall std::vector<int, class std::allocator<int>>::_Make_iter(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<int>>>)const
.text$mn:00005390                 public ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z
.text$mn:00005390 ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z proc near
.text$mn:00005390                                         ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+EEp
.text$mn:00005390
.text$mn:00005390 var_14          = dword ptr -14h
.text$mn:00005390 var_10          = dword ptr -10h
.text$mn:00005390 var_C           = dword ptr -0Ch
.text$mn:00005390 var_4           = dword ptr -4
.text$mn:00005390 arg_0           = dword ptr  8
.text$mn:00005390 arg_4           = byte ptr  0Ch
.text$mn:00005390 arg_C           = dword ptr  14h
.text$mn:00005390
.text$mn:00005390                 push    ebp
.text$mn:00005391                 mov     ebp, esp
.text$mn:00005393                 push    0FFFFFFFFh
.text$mn:00005395                 push    offset __ehhandler$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z
.text$mn:0000539A                 mov     eax, large fs:0
.text$mn:000053A0                 push    eax
.text$mn:000053A1                 sub     esp, 8
.text$mn:000053A4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000053A9                 xor     eax, ebp
.text$mn:000053AB                 push    eax
.text$mn:000053AC                 lea     eax, [ebp+var_C]
.text$mn:000053AF                 mov     large fs:0, eax
.text$mn:000053B5                 mov     [ebp+var_14], ecx
.text$mn:000053B8                 mov     [ebp+var_10], 0
.text$mn:000053BF                 mov     [ebp+var_4], 1
.text$mn:000053C6                 mov     eax, [ebp+var_14]
.text$mn:000053C9                 push    eax             ; struct std::_Container_base12 *
.text$mn:000053CA                 mov     ecx, [ebp+arg_C]
.text$mn:000053CD                 push    ecx             ; int
.text$mn:000053CE                 mov     ecx, [ebp+arg_0]
.text$mn:000053D1                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)
.text$mn:000053D6                 mov     edx, [ebp+var_10]
.text$mn:000053D9                 or      edx, 1
.text$mn:000053DC                 mov     [ebp+var_10], edx
.text$mn:000053DF                 mov     byte ptr [ebp+var_4], 0
.text$mn:000053E3                 lea     ecx, [ebp+arg_4]
.text$mn:000053E6                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:000053EB                 mov     eax, [ebp+arg_0]
.text$mn:000053EE                 mov     ecx, [ebp+var_C]
.text$mn:000053F1                 mov     large fs:0, ecx
.text$mn:000053F8                 pop     ecx
.text$mn:000053F9                 mov     esp, ebp
.text$mn:000053FB                 pop     ebp
.text$mn:000053FC                 retn    10h
.text$mn:000053FC ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z endp
.text$mn:000053FC
.text$mn:000053FC ; ---------------------------------------------------------------------------
.text$mn:000053FF                 align 10h
.text$mn:000053FF _text$mn        ends
.text$mn:000053FF
.text$x:00005400 ; ===========================================================================
.text$x:00005400
.text$x:00005400 ; Segment type: Pure code
.text$x:00005400 ; Segment permissions: Read/Execute
.text$x:00005400 _text$x         segment para public 'CODE' use32
.text$x:00005400                 assume cs:_text$x
.text$x:00005400                 ;org 5400h
.text$x:00005400 ; COMDAT (pick associative to section at 5390)
.text$x:00005400                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005400
.text$x:00005400 ; =============== S U B R O U T I N E =======================================
.text$x:00005400
.text$x:00005400
.text$x:00005400 __unwindfunclet$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$0 proc near
.text$x:00005400                                         ; DATA XREF: .xdata$x:00008348o
.text$x:00005400                 lea     ecx, [ebp+0Ch]
.text$x:00005403                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005403 __unwindfunclet$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$0 endp
.text$x:00005403
.text$x:00005408
.text$x:00005408 ; =============== S U B R O U T I N E =======================================
.text$x:00005408
.text$x:00005408
.text$x:00005408 __unwindfunclet$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$1 proc near
.text$x:00005408                                         ; DATA XREF: .xdata$x:00008340o
.text$x:00005408                 mov     eax, [ebp-10h]
.text$x:0000540B                 and     eax, 1
.text$x:0000540E                 jz      $LN5
.text$x:00005414                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00005418                 mov     ecx, [ebp+8]
.text$x:0000541B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00005420 ; ---------------------------------------------------------------------------
.text$x:00005420
.text$x:00005420 $LN5:                                   ; CODE XREF: __unwindfunclet$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$1+6j
.text$x:00005420                 retn
.text$x:00005420 __unwindfunclet$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$1 endp
.text$x:00005420
.text$x:00005421
.text$x:00005421 ; =============== S U B R O U T I N E =======================================
.text$x:00005421
.text$x:00005421
.text$x:00005421 __ehhandler$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z proc near
.text$x:00005421                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+5o
.text$x:00005421
.text$x:00005421 arg_4           = dword ptr  8
.text$x:00005421
.text$x:00005421                 mov     edx, [esp+arg_4]
.text$x:00005425                 lea     eax, [edx+0Ch]
.text$x:00005428                 mov     ecx, [edx-0Ch]
.text$x:0000542B                 xor     ecx, eax
.text$x:0000542D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005432                 mov     eax, offset __ehfuncinfo$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z
.text$x:00005437                 jmp     ___CxxFrameHandler3
.text$x:00005437 __ehhandler$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z endp
.text$x:00005437
.text$x:00005437 _text$x         ends
.text$x:00005437
.text$mn:0000543C ; ===========================================================================
.text$mn:0000543C
.text$mn:0000543C ; Segment type: Pure code
.text$mn:0000543C ; Segment permissions: Read/Execute
.text$mn:0000543C _text$mn        segment para public 'CODE' use32
.text$mn:0000543C                 assume cs:_text$mn
.text$mn:0000543C                 ;org 543Ch
.text$mn:0000543C ; COMDAT (pick any)
.text$mn:0000543C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000543C
.text$mn:0000543C ; =============== S U B R O U T I N E =======================================
.text$mn:0000543C
.text$mn:0000543C ; Attributes: bp-based frame
.text$mn:0000543C
.text$mn:0000543C ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000543C                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:0000543C ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:0000543C                                         ; CODE XREF: $LN19+14p
.text$mn:0000543C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:0000543C
.text$mn:0000543C var_8           = dword ptr -8
.text$mn:0000543C var_4           = dword ptr -4
.text$mn:0000543C
.text$mn:0000543C                 push    ebp
.text$mn:0000543D                 mov     ebp, esp
.text$mn:0000543F                 sub     esp, 8
.text$mn:00005442                 mov     [ebp+var_4], ecx
.text$mn:00005445                 mov     eax, [ebp+var_4]
.text$mn:00005448                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000544C                 jb      short loc_5462
.text$mn:0000544E                 mov     ecx, [ebp+var_4]
.text$mn:00005451                 mov     edx, [ecx+4]
.text$mn:00005454                 push    edx
.text$mn:00005455                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000545A                 add     esp, 4
.text$mn:0000545D                 mov     [ebp+var_8], eax
.text$mn:00005460                 jmp     short loc_546B
.text$mn:00005462 ; ---------------------------------------------------------------------------
.text$mn:00005462
.text$mn:00005462 loc_5462:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00005462                 mov     eax, [ebp+var_4]
.text$mn:00005465                 add     eax, 4
.text$mn:00005468                 mov     [ebp+var_8], eax
.text$mn:0000546B
.text$mn:0000546B loc_546B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000546B                 mov     eax, [ebp+var_8]
.text$mn:0000546E                 mov     esp, ebp
.text$mn:00005470                 pop     ebp
.text$mn:00005471                 retn
.text$mn:00005471 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00005471
.text$mn:00005471 ; ---------------------------------------------------------------------------
.text$mn:00005472                 align 4
.text$mn:00005472 _text$mn        ends
.text$mn:00005472
.text$mn:00005474 ; ===========================================================================
.text$mn:00005474
.text$mn:00005474 ; Segment type: Pure code
.text$mn:00005474 ; Segment permissions: Read/Execute
.text$mn:00005474 _text$mn        segment para public 'CODE' use32
.text$mn:00005474                 assume cs:_text$mn
.text$mn:00005474                 ;org 5474h
.text$mn:00005474 ; COMDAT (pick any)
.text$mn:00005474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005474
.text$mn:00005474 ; =============== S U B R O U T I N E =======================================
.text$mn:00005474
.text$mn:00005474 ; Attributes: bp-based frame
.text$mn:00005474
.text$mn:00005474 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00005474                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00005474 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00005474                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00005474
.text$mn:00005474 var_8           = dword ptr -8
.text$mn:00005474 var_4           = dword ptr -4
.text$mn:00005474
.text$mn:00005474                 push    ebp
.text$mn:00005475                 mov     ebp, esp
.text$mn:00005477                 sub     esp, 8
.text$mn:0000547A                 mov     [ebp+var_4], ecx
.text$mn:0000547D                 mov     eax, [ebp+var_4]
.text$mn:00005480                 cmp     dword ptr [eax+18h], 10h
.text$mn:00005484                 jb      short loc_549A
.text$mn:00005486                 mov     ecx, [ebp+var_4]
.text$mn:00005489                 mov     edx, [ecx+4]
.text$mn:0000548C                 push    edx
.text$mn:0000548D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00005492                 add     esp, 4
.text$mn:00005495                 mov     [ebp+var_8], eax
.text$mn:00005498                 jmp     short loc_54A3
.text$mn:0000549A ; ---------------------------------------------------------------------------
.text$mn:0000549A
.text$mn:0000549A loc_549A:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000549A                 mov     eax, [ebp+var_4]
.text$mn:0000549D                 add     eax, 4
.text$mn:000054A0                 mov     [ebp+var_8], eax
.text$mn:000054A3
.text$mn:000054A3 loc_54A3:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000054A3                 mov     eax, [ebp+var_8]
.text$mn:000054A6                 mov     esp, ebp
.text$mn:000054A8                 pop     ebp
.text$mn:000054A9                 retn
.text$mn:000054A9 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:000054A9
.text$mn:000054A9 ; ---------------------------------------------------------------------------
.text$mn:000054AA                 align 4
.text$mn:000054AA _text$mn        ends
.text$mn:000054AA
.text$mn:000054AC ; ===========================================================================
.text$mn:000054AC
.text$mn:000054AC ; Segment type: Pure code
.text$mn:000054AC ; Segment permissions: Read/Execute
.text$mn:000054AC _text$mn        segment para public 'CODE' use32
.text$mn:000054AC                 assume cs:_text$mn
.text$mn:000054AC                 ;org 54ACh
.text$mn:000054AC ; COMDAT (pick any)
.text$mn:000054AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000054AC
.text$mn:000054AC ; =============== S U B R O U T I N E =======================================
.text$mn:000054AC
.text$mn:000054AC ; Attributes: bp-based frame
.text$mn:000054AC
.text$mn:000054AC ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000054AC                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:000054AC ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:000054AC                                         ; CODE XREF: $LN19_0+14p
.text$mn:000054AC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:000054AC
.text$mn:000054AC var_8           = dword ptr -8
.text$mn:000054AC var_4           = dword ptr -4
.text$mn:000054AC
.text$mn:000054AC                 push    ebp
.text$mn:000054AD                 mov     ebp, esp
.text$mn:000054AF                 sub     esp, 8
.text$mn:000054B2                 mov     [ebp+var_4], ecx
.text$mn:000054B5                 mov     eax, [ebp+var_4]
.text$mn:000054B8                 cmp     dword ptr [eax+18h], 8
.text$mn:000054BC                 jb      short loc_54D2
.text$mn:000054BE                 mov     ecx, [ebp+var_4]
.text$mn:000054C1                 mov     edx, [ecx+4]
.text$mn:000054C4                 push    edx
.text$mn:000054C5                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000054CA                 add     esp, 4
.text$mn:000054CD                 mov     [ebp+var_8], eax
.text$mn:000054D0                 jmp     short loc_54DB
.text$mn:000054D2 ; ---------------------------------------------------------------------------
.text$mn:000054D2
.text$mn:000054D2 loc_54D2:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:000054D2                 mov     eax, [ebp+var_4]
.text$mn:000054D5                 add     eax, 4
.text$mn:000054D8                 mov     [ebp+var_8], eax
.text$mn:000054DB
.text$mn:000054DB loc_54DB:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:000054DB                 mov     eax, [ebp+var_8]
.text$mn:000054DE                 mov     esp, ebp
.text$mn:000054E0                 pop     ebp
.text$mn:000054E1                 retn
.text$mn:000054E1 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:000054E1
.text$mn:000054E1 ; ---------------------------------------------------------------------------
.text$mn:000054E2                 align 4
.text$mn:000054E2 _text$mn        ends
.text$mn:000054E2
.text$mn:000054E4 ; ===========================================================================
.text$mn:000054E4
.text$mn:000054E4 ; Segment type: Pure code
.text$mn:000054E4 ; Segment permissions: Read/Execute
.text$mn:000054E4 _text$mn        segment para public 'CODE' use32
.text$mn:000054E4                 assume cs:_text$mn
.text$mn:000054E4                 ;org 54E4h
.text$mn:000054E4 ; COMDAT (pick any)
.text$mn:000054E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000054E4
.text$mn:000054E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000054E4
.text$mn:000054E4 ; Attributes: bp-based frame
.text$mn:000054E4
.text$mn:000054E4 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:000054E4                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:000054E4 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:000054E4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+80p
.text$mn:000054E4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp ...
.text$mn:000054E4
.text$mn:000054E4 var_8           = dword ptr -8
.text$mn:000054E4 var_4           = dword ptr -4
.text$mn:000054E4
.text$mn:000054E4                 push    ebp
.text$mn:000054E5                 mov     ebp, esp
.text$mn:000054E7                 sub     esp, 8
.text$mn:000054EA                 mov     [ebp+var_4], ecx
.text$mn:000054ED                 mov     eax, [ebp+var_4]
.text$mn:000054F0                 cmp     dword ptr [eax+18h], 8
.text$mn:000054F4                 jb      short loc_550A
.text$mn:000054F6                 mov     ecx, [ebp+var_4]
.text$mn:000054F9                 mov     edx, [ecx+4]
.text$mn:000054FC                 push    edx
.text$mn:000054FD                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00005502                 add     esp, 4
.text$mn:00005505                 mov     [ebp+var_8], eax
.text$mn:00005508                 jmp     short loc_5513
.text$mn:0000550A ; ---------------------------------------------------------------------------
.text$mn:0000550A
.text$mn:0000550A loc_550A:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000550A                 mov     eax, [ebp+var_4]
.text$mn:0000550D                 add     eax, 4
.text$mn:00005510                 mov     [ebp+var_8], eax
.text$mn:00005513
.text$mn:00005513 loc_5513:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00005513                 mov     eax, [ebp+var_8]
.text$mn:00005516                 mov     esp, ebp
.text$mn:00005518                 pop     ebp
.text$mn:00005519                 retn
.text$mn:00005519 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:00005519
.text$mn:00005519 ; ---------------------------------------------------------------------------
.text$mn:0000551A                 align 4
.text$mn:0000551A _text$mn        ends
.text$mn:0000551A
.text$mn:0000551C ; ===========================================================================
.text$mn:0000551C
.text$mn:0000551C ; Segment type: Pure code
.text$mn:0000551C ; Segment permissions: Read/Execute
.text$mn:0000551C _text$mn        segment para public 'CODE' use32
.text$mn:0000551C                 assume cs:_text$mn
.text$mn:0000551C                 ;org 551Ch
.text$mn:0000551C ; COMDAT (pick any)
.text$mn:0000551C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000551C
.text$mn:0000551C ; =============== S U B R O U T I N E =======================================
.text$mn:0000551C
.text$mn:0000551C ; Attributes: bp-based frame
.text$mn:0000551C
.text$mn:0000551C ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:0000551C                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000551C ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:0000551C                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:0000551C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:0000551C
.text$mn:0000551C var_18          = byte ptr -18h
.text$mn:0000551C var_14          = dword ptr -14h
.text$mn:0000551C var_10          = dword ptr -10h
.text$mn:0000551C var_C           = dword ptr -0Ch
.text$mn:0000551C var_4           = dword ptr -4
.text$mn:0000551C
.text$mn:0000551C                 push    ebp
.text$mn:0000551D                 mov     ebp, esp
.text$mn:0000551F                 push    0FFFFFFFFh
.text$mn:00005521                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00005526                 mov     eax, large fs:0
.text$mn:0000552C                 push    eax
.text$mn:0000552D                 sub     esp, 0Ch
.text$mn:00005530                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005535                 xor     eax, ebp
.text$mn:00005537                 push    eax
.text$mn:00005538                 lea     eax, [ebp+var_C]
.text$mn:0000553B                 mov     large fs:0, eax
.text$mn:00005541                 mov     [ebp+var_14], ecx
.text$mn:00005544                 mov     eax, [ebp+var_14]
.text$mn:00005547                 cmp     dword ptr [eax], 0
.text$mn:0000554A                 jz      short loc_55A7
.text$mn:0000554C                 push    3               ; int
.text$mn:0000554E                 lea     ecx, [ebp+var_18] ; this
.text$mn:00005551                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00005556                 mov     [ebp+var_4], 0
.text$mn:0000555D                 mov     ecx, [ebp+var_14]
.text$mn:00005560                 mov     edx, [ecx]
.text$mn:00005562                 add     edx, 4
.text$mn:00005565                 mov     [ebp+var_10], edx
.text$mn:00005568                 jmp     short loc_5577
.text$mn:0000556A ; ---------------------------------------------------------------------------
.text$mn:0000556A
.text$mn:0000556A loc_556A:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000556A                 mov     eax, [ebp+var_10]
.text$mn:0000556D                 mov     ecx, [eax]
.text$mn:0000556F                 mov     edx, [ebp+var_10]
.text$mn:00005572                 mov     eax, [ecx+4]
.text$mn:00005575                 mov     [edx], eax
.text$mn:00005577
.text$mn:00005577 loc_5577:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00005577                 mov     ecx, [ebp+var_10]
.text$mn:0000557A                 cmp     dword ptr [ecx], 0
.text$mn:0000557D                 jz      short loc_558C
.text$mn:0000557F                 mov     edx, [ebp+var_10]
.text$mn:00005582                 mov     eax, [edx]
.text$mn:00005584                 mov     dword ptr [eax], 0
.text$mn:0000558A                 jmp     short loc_556A
.text$mn:0000558C ; ---------------------------------------------------------------------------
.text$mn:0000558C
.text$mn:0000558C loc_558C:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:0000558C                 mov     ecx, [ebp+var_14]
.text$mn:0000558F                 mov     edx, [ecx]
.text$mn:00005591                 mov     dword ptr [edx+4], 0
.text$mn:00005598                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000559F                 lea     ecx, [ebp+var_18] ; this
.text$mn:000055A2                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000055A7
.text$mn:000055A7 loc_55A7:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000055A7                 mov     ecx, [ebp+var_C]
.text$mn:000055AA                 mov     large fs:0, ecx
.text$mn:000055B1                 pop     ecx
.text$mn:000055B2                 mov     esp, ebp
.text$mn:000055B4                 pop     ebp
.text$mn:000055B5                 retn
.text$mn:000055B5 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000055B5
.text$mn:000055B5 ; ---------------------------------------------------------------------------
.text$mn:000055B6                 align 4
.text$mn:000055B6 _text$mn        ends
.text$mn:000055B6
.text$x:000055B8 ; ===========================================================================
.text$x:000055B8
.text$x:000055B8 ; Segment type: Pure code
.text$x:000055B8 ; Segment permissions: Read/Execute
.text$x:000055B8 _text$x         segment para public 'CODE' use32
.text$x:000055B8                 assume cs:_text$x
.text$x:000055B8                 ;org 55B8h
.text$x:000055B8 ; COMDAT (pick associative to section at 551C)
.text$x:000055B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000055B8
.text$x:000055B8 ; =============== S U B R O U T I N E =======================================
.text$x:000055B8
.text$x:000055B8
.text$x:000055B8 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000055B8                                         ; DATA XREF: .xdata$x:00007A64o
.text$x:000055B8                 lea     ecx, [ebp-18h]  ; this
.text$x:000055BB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000055BB __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000055BB
.text$x:000055C0
.text$x:000055C0 ; =============== S U B R O U T I N E =======================================
.text$x:000055C0
.text$x:000055C0
.text$x:000055C0 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:000055C0                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:000055C0
.text$x:000055C0 arg_4           = dword ptr  8
.text$x:000055C0
.text$x:000055C0                 mov     edx, [esp+arg_4]
.text$x:000055C4                 lea     eax, [edx+0Ch]
.text$x:000055C7                 mov     ecx, [edx-10h]
.text$x:000055CA                 xor     ecx, eax
.text$x:000055CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000055D1                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:000055D6                 jmp     ___CxxFrameHandler3
.text$x:000055D6 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:000055D6
.text$x:000055D6 ; ---------------------------------------------------------------------------
.text$x:000055DB                 align 4
.text$x:000055DB _text$x         ends
.text$x:000055DB
.text$mn:000055DC ; ===========================================================================
.text$mn:000055DC
.text$mn:000055DC ; Segment type: Pure code
.text$mn:000055DC ; Segment permissions: Read/Execute
.text$mn:000055DC _text$mn        segment para public 'CODE' use32
.text$mn:000055DC                 assume cs:_text$mn
.text$mn:000055DC                 ;org 55DCh
.text$mn:000055DC ; COMDAT (pick any)
.text$mn:000055DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000055DC
.text$mn:000055DC ; =============== S U B R O U T I N E =======================================
.text$mn:000055DC
.text$mn:000055DC ; Attributes: bp-based frame
.text$mn:000055DC
.text$mn:000055DC ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:000055DC                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:000055DC ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:000055DC                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:000055DC                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:000055DC
.text$mn:000055DC var_8           = dword ptr -8
.text$mn:000055DC var_4           = dword ptr -4
.text$mn:000055DC
.text$mn:000055DC                 push    ebp
.text$mn:000055DD                 mov     ebp, esp
.text$mn:000055DF                 sub     esp, 8
.text$mn:000055E2                 mov     [ebp+var_8], ecx
.text$mn:000055E5                 mov     eax, [ebp+var_8]
.text$mn:000055E8                 cmp     dword ptr [eax], 0
.text$mn:000055EB                 jz      short loc_564A
.text$mn:000055ED                 mov     ecx, [ebp+var_8]
.text$mn:000055F0                 mov     edx, [ecx]
.text$mn:000055F2                 add     edx, 4
.text$mn:000055F5                 mov     [ebp+var_4], edx
.text$mn:000055F8
.text$mn:000055F8 loc_55F8:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:000055F8                 mov     eax, [ebp+var_4]
.text$mn:000055FB                 cmp     dword ptr [eax], 0
.text$mn:000055FE                 jz      short loc_5617
.text$mn:00005600                 mov     ecx, [ebp+var_4]
.text$mn:00005603                 mov     edx, [ecx]
.text$mn:00005605                 cmp     edx, [ebp+var_8]
.text$mn:00005608                 jz      short loc_5617
.text$mn:0000560A                 mov     eax, [ebp+var_4]
.text$mn:0000560D                 mov     ecx, [eax]
.text$mn:0000560F                 add     ecx, 4
.text$mn:00005612                 mov     [ebp+var_4], ecx
.text$mn:00005615                 jmp     short loc_55F8
.text$mn:00005617 ; ---------------------------------------------------------------------------
.text$mn:00005617
.text$mn:00005617 loc_5617:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:00005617                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:00005617                 mov     edx, [ebp+var_4]
.text$mn:0000561A                 cmp     dword ptr [edx], 0
.text$mn:0000561D                 jnz     short loc_5636
.text$mn:0000561F                 push    0C9h ; '+'      ; unsigned int
.text$mn:00005624                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005629                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:0000562E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005633                 add     esp, 0Ch
.text$mn:00005636
.text$mn:00005636 loc_5636:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:00005636                 mov     eax, [ebp+var_4]
.text$mn:00005639                 mov     ecx, [ebp+var_8]
.text$mn:0000563C                 mov     edx, [ecx+4]
.text$mn:0000563F                 mov     [eax], edx
.text$mn:00005641                 mov     eax, [ebp+var_8]
.text$mn:00005644                 mov     dword ptr [eax], 0
.text$mn:0000564A
.text$mn:0000564A loc_564A:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:0000564A                 mov     esp, ebp
.text$mn:0000564C                 pop     ebp
.text$mn:0000564D                 retn
.text$mn:0000564D ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:0000564D
.text$mn:0000564D ; ---------------------------------------------------------------------------
.text$mn:0000564E                 align 10h
.text$mn:0000564E _text$mn        ends
.text$mn:0000564E
.text$mn:00005650 ; ===========================================================================
.text$mn:00005650
.text$mn:00005650 ; Segment type: Pure code
.text$mn:00005650 ; Segment permissions: Read/Execute
.text$mn:00005650 _text$mn        segment para public 'CODE' use32
.text$mn:00005650                 assume cs:_text$mn
.text$mn:00005650                 ;org 5650h
.text$mn:00005650 ; COMDAT (pick any)
.text$mn:00005650                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005650
.text$mn:00005650 ; =============== S U B R O U T I N E =======================================
.text$mn:00005650
.text$mn:00005650 ; Attributes: bp-based frame
.text$mn:00005650
.text$mn:00005650 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Orphan_range(int *, int *)const
.text$mn:00005650                 public ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.text$mn:00005650 ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z proc near
.text$mn:00005650                                         ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+B1p
.text$mn:00005650                                         ; std::vector<int,std::allocator<int>>::push_back(int const &)+66p ...
.text$mn:00005650
.text$mn:00005650 var_18          = byte ptr -18h
.text$mn:00005650 var_14          = dword ptr -14h
.text$mn:00005650 var_10          = dword ptr -10h
.text$mn:00005650 var_C           = dword ptr -0Ch
.text$mn:00005650 var_4           = dword ptr -4
.text$mn:00005650 arg_0           = dword ptr  8
.text$mn:00005650 arg_4           = dword ptr  0Ch
.text$mn:00005650
.text$mn:00005650                 push    ebp
.text$mn:00005651                 mov     ebp, esp
.text$mn:00005653                 push    0FFFFFFFFh
.text$mn:00005655                 push    offset __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.text$mn:0000565A                 mov     eax, large fs:0
.text$mn:00005660                 push    eax
.text$mn:00005661                 sub     esp, 0Ch
.text$mn:00005664                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005669                 xor     eax, ebp
.text$mn:0000566B                 push    eax
.text$mn:0000566C                 lea     eax, [ebp+var_C]
.text$mn:0000566F                 mov     large fs:0, eax
.text$mn:00005675                 mov     [ebp+var_14], ecx
.text$mn:00005678                 push    3               ; int
.text$mn:0000567A                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000567D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00005682                 mov     [ebp+var_4], 0
.text$mn:00005689                 mov     ecx, [ebp+var_14] ; this
.text$mn:0000568C                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00005691                 mov     [ebp+var_10], eax
.text$mn:00005694                 cmp     [ebp+var_10], 0
.text$mn:00005698                 jz      short loc_56E8
.text$mn:0000569A
.text$mn:0000569A loc_569A:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *):loc_56E6j
.text$mn:0000569A                 mov     eax, [ebp+var_10]
.text$mn:0000569D                 cmp     dword ptr [eax], 0
.text$mn:000056A0                 jz      short loc_56E8
.text$mn:000056A2                 mov     ecx, [ebp+var_10]
.text$mn:000056A5                 mov     edx, [ecx]
.text$mn:000056A7                 mov     eax, [edx+8]
.text$mn:000056AA                 cmp     eax, [ebp+arg_0]
.text$mn:000056AD                 jb      short loc_56BC
.text$mn:000056AF                 mov     ecx, [ebp+var_10]
.text$mn:000056B2                 mov     edx, [ecx]
.text$mn:000056B4                 mov     eax, [ebp+arg_4]
.text$mn:000056B7                 cmp     eax, [edx+8]
.text$mn:000056BA                 jnb     short loc_56CB
.text$mn:000056BC
.text$mn:000056BC loc_56BC:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+5Dj
.text$mn:000056BC                 mov     ecx, [ebp+var_10]
.text$mn:000056BF                 mov     ecx, [ecx]      ; this
.text$mn:000056C1                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:000056C6                 mov     [ebp+var_10], eax
.text$mn:000056C9                 jmp     short loc_56E6
.text$mn:000056CB ; ---------------------------------------------------------------------------
.text$mn:000056CB
.text$mn:000056CB loc_56CB:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+6Aj
.text$mn:000056CB                 mov     edx, [ebp+var_10]
.text$mn:000056CE                 mov     ecx, [edx]      ; this
.text$mn:000056D0                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:000056D5                 mov     eax, [ebp+var_10]
.text$mn:000056D8                 mov     ecx, [eax]      ; this
.text$mn:000056DA                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:000056DF                 mov     ecx, [ebp+var_10]
.text$mn:000056E2                 mov     edx, [eax]
.text$mn:000056E4                 mov     [ecx], edx
.text$mn:000056E6
.text$mn:000056E6 loc_56E6:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+79j
.text$mn:000056E6                 jmp     short loc_569A
.text$mn:000056E8 ; ---------------------------------------------------------------------------
.text$mn:000056E8
.text$mn:000056E8 loc_56E8:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+48j
.text$mn:000056E8                                         ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+50j
.text$mn:000056E8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000056EF                 lea     ecx, [ebp+var_18] ; this
.text$mn:000056F2                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000056F7                 mov     ecx, [ebp+var_C]
.text$mn:000056FA                 mov     large fs:0, ecx
.text$mn:00005701                 pop     ecx
.text$mn:00005702                 mov     esp, ebp
.text$mn:00005704                 pop     ebp
.text$mn:00005705                 retn    8
.text$mn:00005705 ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z endp
.text$mn:00005705
.text$mn:00005705 _text$mn        ends
.text$mn:00005705
.text$x:00005708 ; ===========================================================================
.text$x:00005708
.text$x:00005708 ; Segment type: Pure code
.text$x:00005708 ; Segment permissions: Read/Execute
.text$x:00005708 _text$x         segment para public 'CODE' use32
.text$x:00005708                 assume cs:_text$x
.text$x:00005708                 ;org 5708h
.text$x:00005708 ; COMDAT (pick associative to section at 5650)
.text$x:00005708                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005708
.text$x:00005708 ; =============== S U B R O U T I N E =======================================
.text$x:00005708
.text$x:00005708
.text$x:00005708 __unwindfunclet$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z$0 proc near
.text$x:00005708                                         ; DATA XREF: .xdata$x:00008408o
.text$x:00005708                 lea     ecx, [ebp-18h]  ; this
.text$x:0000570B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000570B __unwindfunclet$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z$0 endp
.text$x:0000570B
.text$x:00005710
.text$x:00005710 ; =============== S U B R O U T I N E =======================================
.text$x:00005710
.text$x:00005710
.text$x:00005710 __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z proc near
.text$x:00005710                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)+5o
.text$x:00005710
.text$x:00005710 arg_4           = dword ptr  8
.text$x:00005710
.text$x:00005710                 mov     edx, [esp+arg_4]
.text$x:00005714                 lea     eax, [edx+0Ch]
.text$x:00005717                 mov     ecx, [edx-10h]
.text$x:0000571A                 xor     ecx, eax
.text$x:0000571C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005721                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.text$x:00005726                 jmp     ___CxxFrameHandler3
.text$x:00005726 __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z endp
.text$x:00005726
.text$x:00005726 ; ---------------------------------------------------------------------------
.text$x:0000572B                 align 4
.text$x:0000572B _text$x         ends
.text$x:0000572B
.text$mn:0000572C ; ===========================================================================
.text$mn:0000572C
.text$mn:0000572C ; Segment type: Pure code
.text$mn:0000572C ; Segment permissions: Read/Execute
.text$mn:0000572C _text$mn        segment para public 'CODE' use32
.text$mn:0000572C                 assume cs:_text$mn
.text$mn:0000572C                 ;org 572Ch
.text$mn:0000572C ; COMDAT (pick any)
.text$mn:0000572C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000572C
.text$mn:0000572C ; =============== S U B R O U T I N E =======================================
.text$mn:0000572C
.text$mn:0000572C ; Attributes: bp-based frame
.text$mn:0000572C
.text$mn:0000572C ; protected: void __thiscall std::vector<struct iconLocator, class std::allocator<struct iconLocator>>::_Orphan_range(struct iconLocator *, struct iconLocator *)const
.text$mn:0000572C                 public ?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z
.text$mn:0000572C ?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z proc near
.text$mn:0000572C                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)+6Fp
.text$mn:0000572C                                         ; std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)+DCp
.text$mn:0000572C
.text$mn:0000572C var_18          = byte ptr -18h
.text$mn:0000572C var_14          = dword ptr -14h
.text$mn:0000572C var_10          = dword ptr -10h
.text$mn:0000572C var_C           = dword ptr -0Ch
.text$mn:0000572C var_4           = dword ptr -4
.text$mn:0000572C arg_0           = dword ptr  8
.text$mn:0000572C arg_4           = dword ptr  0Ch
.text$mn:0000572C
.text$mn:0000572C                 push    ebp
.text$mn:0000572D                 mov     ebp, esp
.text$mn:0000572F                 push    0FFFFFFFFh
.text$mn:00005731                 push    offset __ehhandler$?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z
.text$mn:00005736                 mov     eax, large fs:0
.text$mn:0000573C                 push    eax
.text$mn:0000573D                 sub     esp, 0Ch
.text$mn:00005740                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005745                 xor     eax, ebp
.text$mn:00005747                 push    eax
.text$mn:00005748                 lea     eax, [ebp+var_C]
.text$mn:0000574B                 mov     large fs:0, eax
.text$mn:00005751                 mov     [ebp+var_14], ecx
.text$mn:00005754                 push    3               ; int
.text$mn:00005756                 lea     ecx, [ebp+var_18] ; this
.text$mn:00005759                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000575E                 mov     [ebp+var_4], 0
.text$mn:00005765                 mov     ecx, [ebp+var_14] ; this
.text$mn:00005768                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:0000576D                 mov     [ebp+var_10], eax
.text$mn:00005770                 cmp     [ebp+var_10], 0
.text$mn:00005774                 jz      short loc_57C4
.text$mn:00005776
.text$mn:00005776 loc_5776:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Orphan_range(iconLocator *,iconLocator *):loc_57C2j
.text$mn:00005776                 mov     eax, [ebp+var_10]
.text$mn:00005779                 cmp     dword ptr [eax], 0
.text$mn:0000577C                 jz      short loc_57C4
.text$mn:0000577E                 mov     ecx, [ebp+var_10]
.text$mn:00005781                 mov     edx, [ecx]
.text$mn:00005783                 mov     eax, [edx+8]
.text$mn:00005786                 cmp     eax, [ebp+arg_0]
.text$mn:00005789                 jb      short loc_5798
.text$mn:0000578B                 mov     ecx, [ebp+var_10]
.text$mn:0000578E                 mov     edx, [ecx]
.text$mn:00005790                 mov     eax, [ebp+arg_4]
.text$mn:00005793                 cmp     eax, [edx+8]
.text$mn:00005796                 jnb     short loc_57A7
.text$mn:00005798
.text$mn:00005798 loc_5798:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Orphan_range(iconLocator *,iconLocator *)+5Dj
.text$mn:00005798                 mov     ecx, [ebp+var_10]
.text$mn:0000579B                 mov     ecx, [ecx]      ; this
.text$mn:0000579D                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:000057A2                 mov     [ebp+var_10], eax
.text$mn:000057A5                 jmp     short loc_57C2
.text$mn:000057A7 ; ---------------------------------------------------------------------------
.text$mn:000057A7
.text$mn:000057A7 loc_57A7:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Orphan_range(iconLocator *,iconLocator *)+6Aj
.text$mn:000057A7                 mov     edx, [ebp+var_10]
.text$mn:000057AA                 mov     ecx, [edx]      ; this
.text$mn:000057AC                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:000057B1                 mov     eax, [ebp+var_10]
.text$mn:000057B4                 mov     ecx, [eax]      ; this
.text$mn:000057B6                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:000057BB                 mov     ecx, [ebp+var_10]
.text$mn:000057BE                 mov     edx, [eax]
.text$mn:000057C0                 mov     [ecx], edx
.text$mn:000057C2
.text$mn:000057C2 loc_57C2:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Orphan_range(iconLocator *,iconLocator *)+79j
.text$mn:000057C2                 jmp     short loc_5776
.text$mn:000057C4 ; ---------------------------------------------------------------------------
.text$mn:000057C4
.text$mn:000057C4 loc_57C4:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Orphan_range(iconLocator *,iconLocator *)+48j
.text$mn:000057C4                                         ; std::vector<iconLocator,std::allocator<iconLocator>>::_Orphan_range(iconLocator *,iconLocator *)+50j
.text$mn:000057C4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000057CB                 lea     ecx, [ebp+var_18] ; this
.text$mn:000057CE                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000057D3                 mov     ecx, [ebp+var_C]
.text$mn:000057D6                 mov     large fs:0, ecx
.text$mn:000057DD                 pop     ecx
.text$mn:000057DE                 mov     esp, ebp
.text$mn:000057E0                 pop     ebp
.text$mn:000057E1                 retn    8
.text$mn:000057E1 ?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z endp
.text$mn:000057E1
.text$mn:000057E1 _text$mn        ends
.text$mn:000057E1
.text$x:000057E4 ; ===========================================================================
.text$x:000057E4
.text$x:000057E4 ; Segment type: Pure code
.text$x:000057E4 ; Segment permissions: Read/Execute
.text$x:000057E4 _text$x         segment para public 'CODE' use32
.text$x:000057E4                 assume cs:_text$x
.text$x:000057E4                 ;org 57E4h
.text$x:000057E4 ; COMDAT (pick associative to section at 572C)
.text$x:000057E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000057E4
.text$x:000057E4 ; =============== S U B R O U T I N E =======================================
.text$x:000057E4
.text$x:000057E4
.text$x:000057E4 __unwindfunclet$?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z$0 proc near
.text$x:000057E4                                         ; DATA XREF: .xdata$x:000082E8o
.text$x:000057E4                 lea     ecx, [ebp-18h]  ; this
.text$x:000057E7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000057E7 __unwindfunclet$?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z$0 endp
.text$x:000057E7
.text$x:000057EC
.text$x:000057EC ; =============== S U B R O U T I N E =======================================
.text$x:000057EC
.text$x:000057EC
.text$x:000057EC __ehhandler$?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z proc near
.text$x:000057EC                                         ; DATA XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Orphan_range(iconLocator *,iconLocator *)+5o
.text$x:000057EC
.text$x:000057EC arg_4           = dword ptr  8
.text$x:000057EC
.text$x:000057EC                 mov     edx, [esp+arg_4]
.text$x:000057F0                 lea     eax, [edx+0Ch]
.text$x:000057F3                 mov     ecx, [edx-10h]
.text$x:000057F6                 xor     ecx, eax
.text$x:000057F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000057FD                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z
.text$x:00005802                 jmp     ___CxxFrameHandler3
.text$x:00005802 __ehhandler$?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z endp
.text$x:00005802
.text$x:00005802 ; ---------------------------------------------------------------------------
.text$x:00005807                 align 4
.text$x:00005807 _text$x         ends
.text$x:00005807
.text$mn:00005808 ; ===========================================================================
.text$mn:00005808
.text$mn:00005808 ; Segment type: Pure code
.text$mn:00005808 ; Segment permissions: Read/Execute
.text$mn:00005808 _text$mn        segment para public 'CODE' use32
.text$mn:00005808                 assume cs:_text$mn
.text$mn:00005808                 ;org 5808h
.text$mn:00005808 ; COMDAT (pick any)
.text$mn:00005808                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005808
.text$mn:00005808 ; =============== S U B R O U T I N E =======================================
.text$mn:00005808
.text$mn:00005808 ; Attributes: bp-based frame
.text$mn:00005808
.text$mn:00005808 ; protected: void __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::_Orphan_range(struct tDynamicList *, struct tDynamicList *)const
.text$mn:00005808                 public ?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z
.text$mn:00005808 ?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z proc near
.text$mn:00005808                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::push_back(tDynamicList const &)+6Fp
.text$mn:00005808                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::push_back(tDynamicList const &)+D3p
.text$mn:00005808
.text$mn:00005808 var_18          = byte ptr -18h
.text$mn:00005808 var_14          = dword ptr -14h
.text$mn:00005808 var_10          = dword ptr -10h
.text$mn:00005808 var_C           = dword ptr -0Ch
.text$mn:00005808 var_4           = dword ptr -4
.text$mn:00005808 arg_0           = dword ptr  8
.text$mn:00005808 arg_4           = dword ptr  0Ch
.text$mn:00005808
.text$mn:00005808                 push    ebp
.text$mn:00005809                 mov     ebp, esp
.text$mn:0000580B                 push    0FFFFFFFFh
.text$mn:0000580D                 push    offset __ehhandler$?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z
.text$mn:00005812                 mov     eax, large fs:0
.text$mn:00005818                 push    eax
.text$mn:00005819                 sub     esp, 0Ch
.text$mn:0000581C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005821                 xor     eax, ebp
.text$mn:00005823                 push    eax
.text$mn:00005824                 lea     eax, [ebp+var_C]
.text$mn:00005827                 mov     large fs:0, eax
.text$mn:0000582D                 mov     [ebp+var_14], ecx
.text$mn:00005830                 push    3               ; int
.text$mn:00005832                 lea     ecx, [ebp+var_18] ; this
.text$mn:00005835                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000583A                 mov     [ebp+var_4], 0
.text$mn:00005841                 mov     ecx, [ebp+var_14] ; this
.text$mn:00005844                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00005849                 mov     [ebp+var_10], eax
.text$mn:0000584C                 cmp     [ebp+var_10], 0
.text$mn:00005850                 jz      short loc_58A0
.text$mn:00005852
.text$mn:00005852 loc_5852:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Orphan_range(tDynamicList *,tDynamicList *):loc_589Ej
.text$mn:00005852                 mov     eax, [ebp+var_10]
.text$mn:00005855                 cmp     dword ptr [eax], 0
.text$mn:00005858                 jz      short loc_58A0
.text$mn:0000585A                 mov     ecx, [ebp+var_10]
.text$mn:0000585D                 mov     edx, [ecx]
.text$mn:0000585F                 mov     eax, [edx+8]
.text$mn:00005862                 cmp     eax, [ebp+arg_0]
.text$mn:00005865                 jb      short loc_5874
.text$mn:00005867                 mov     ecx, [ebp+var_10]
.text$mn:0000586A                 mov     edx, [ecx]
.text$mn:0000586C                 mov     eax, [ebp+arg_4]
.text$mn:0000586F                 cmp     eax, [edx+8]
.text$mn:00005872                 jnb     short loc_5883
.text$mn:00005874
.text$mn:00005874 loc_5874:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Orphan_range(tDynamicList *,tDynamicList *)+5Dj
.text$mn:00005874                 mov     ecx, [ebp+var_10]
.text$mn:00005877                 mov     ecx, [ecx]      ; this
.text$mn:00005879                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000587E                 mov     [ebp+var_10], eax
.text$mn:00005881                 jmp     short loc_589E
.text$mn:00005883 ; ---------------------------------------------------------------------------
.text$mn:00005883
.text$mn:00005883 loc_5883:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Orphan_range(tDynamicList *,tDynamicList *)+6Aj
.text$mn:00005883                 mov     edx, [ebp+var_10]
.text$mn:00005886                 mov     ecx, [edx]      ; this
.text$mn:00005888                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:0000588D                 mov     eax, [ebp+var_10]
.text$mn:00005890                 mov     ecx, [eax]      ; this
.text$mn:00005892                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00005897                 mov     ecx, [ebp+var_10]
.text$mn:0000589A                 mov     edx, [eax]
.text$mn:0000589C                 mov     [ecx], edx
.text$mn:0000589E
.text$mn:0000589E loc_589E:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Orphan_range(tDynamicList *,tDynamicList *)+79j
.text$mn:0000589E                 jmp     short loc_5852
.text$mn:000058A0 ; ---------------------------------------------------------------------------
.text$mn:000058A0
.text$mn:000058A0 loc_58A0:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Orphan_range(tDynamicList *,tDynamicList *)+48j
.text$mn:000058A0                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Orphan_range(tDynamicList *,tDynamicList *)+50j
.text$mn:000058A0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000058A7                 lea     ecx, [ebp+var_18] ; this
.text$mn:000058AA                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000058AF                 mov     ecx, [ebp+var_C]
.text$mn:000058B2                 mov     large fs:0, ecx
.text$mn:000058B9                 pop     ecx
.text$mn:000058BA                 mov     esp, ebp
.text$mn:000058BC                 pop     ebp
.text$mn:000058BD                 retn    8
.text$mn:000058BD ?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z endp
.text$mn:000058BD
.text$mn:000058BD _text$mn        ends
.text$mn:000058BD
.text$x:000058C0 ; ===========================================================================
.text$x:000058C0
.text$x:000058C0 ; Segment type: Pure code
.text$x:000058C0 ; Segment permissions: Read/Execute
.text$x:000058C0 _text$x         segment para public 'CODE' use32
.text$x:000058C0                 assume cs:_text$x
.text$x:000058C0                 ;org 58C0h
.text$x:000058C0 ; COMDAT (pick associative to section at 5808)
.text$x:000058C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000058C0
.text$x:000058C0 ; =============== S U B R O U T I N E =======================================
.text$x:000058C0
.text$x:000058C0
.text$x:000058C0 __unwindfunclet$?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z$0 proc near
.text$x:000058C0                                         ; DATA XREF: .xdata$x:00008264o
.text$x:000058C0                 lea     ecx, [ebp-18h]  ; this
.text$x:000058C3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000058C3 __unwindfunclet$?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z$0 endp
.text$x:000058C3
.text$x:000058C8
.text$x:000058C8 ; =============== S U B R O U T I N E =======================================
.text$x:000058C8
.text$x:000058C8
.text$x:000058C8 __ehhandler$?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z proc near
.text$x:000058C8                                         ; DATA XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Orphan_range(tDynamicList *,tDynamicList *)+5o
.text$x:000058C8
.text$x:000058C8 arg_4           = dword ptr  8
.text$x:000058C8
.text$x:000058C8                 mov     edx, [esp+arg_4]
.text$x:000058CC                 lea     eax, [edx+0Ch]
.text$x:000058CF                 mov     ecx, [edx-10h]
.text$x:000058D2                 xor     ecx, eax
.text$x:000058D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000058D9                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z
.text$x:000058DE                 jmp     ___CxxFrameHandler3
.text$x:000058DE __ehhandler$?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z endp
.text$x:000058DE
.text$x:000058DE ; ---------------------------------------------------------------------------
.text$x:000058E3                 align 4
.text$x:000058E3 _text$x         ends
.text$x:000058E3
.text$mn:000058E4 ; ===========================================================================
.text$mn:000058E4
.text$mn:000058E4 ; Segment type: Pure code
.text$mn:000058E4 ; Segment permissions: Read/Execute
.text$mn:000058E4 _text$mn        segment para public 'CODE' use32
.text$mn:000058E4                 assume cs:_text$mn
.text$mn:000058E4                 ;org 58E4h
.text$mn:000058E4 ; COMDAT (pick any)
.text$mn:000058E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000058E4
.text$mn:000058E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000058E4
.text$mn:000058E4 ; Attributes: bp-based frame
.text$mn:000058E4
.text$mn:000058E4 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Reallocate(unsigned int)
.text$mn:000058E4                 public ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:000058E4 ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z proc near
.text$mn:000058E4                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+4Ep
.text$mn:000058E4
.text$mn:000058E4 var_20          = dword ptr -20h
.text$mn:000058E4 var_1C          = dword ptr -1Ch
.text$mn:000058E4 var_18          = dword ptr -18h
.text$mn:000058E4 var_13          = byte ptr -13h
.text$mn:000058E4 var_11          = byte ptr -11h
.text$mn:000058E4 var_10          = dword ptr -10h
.text$mn:000058E4 var_C           = dword ptr -0Ch
.text$mn:000058E4 var_4           = dword ptr -4
.text$mn:000058E4 arg_0           = dword ptr  8
.text$mn:000058E4
.text$mn:000058E4 ; FUNCTION CHUNK AT .text$mn:0000597A SIZE 00000009 BYTES
.text$mn:000058E4 ; FUNCTION CHUNK AT .text$mn:0000598A SIZE 00000097 BYTES
.text$mn:000058E4
.text$mn:000058E4                 push    ebp
.text$mn:000058E5                 mov     ebp, esp
.text$mn:000058E7                 push    0FFFFFFFFh
.text$mn:000058E9                 push    offset __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:000058EE                 mov     eax, large fs:0
.text$mn:000058F4                 push    eax
.text$mn:000058F5                 push    ecx
.text$mn:000058F6                 sub     esp, 10h
.text$mn:000058F9                 push    ebx
.text$mn:000058FA                 push    esi
.text$mn:000058FB                 push    edi
.text$mn:000058FC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005901                 xor     eax, ebp
.text$mn:00005903                 push    eax
.text$mn:00005904                 lea     eax, [ebp+var_C]
.text$mn:00005907                 mov     large fs:0, eax
.text$mn:0000590D                 mov     [ebp+var_10], esp
.text$mn:00005910                 mov     [ebp+var_18], ecx
.text$mn:00005913                 mov     eax, [ebp+arg_0]
.text$mn:00005916                 push    eax
.text$mn:00005917                 lea     ecx, [ebp+var_11]
.text$mn:0000591A                 push    ecx
.text$mn:0000591B                 mov     ecx, [ebp+var_18]
.text$mn:0000591E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00005923                 mov     ecx, eax
.text$mn:00005925                 call    ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::allocate(uint)
.text$mn:0000592A                 mov     [ebp+var_1C], eax
.text$mn:0000592D                 mov     [ebp+var_4], 0
.text$mn:00005934                 mov     edx, [ebp+var_1C]
.text$mn:00005937                 push    edx
.text$mn:00005938                 mov     eax, [ebp+var_18]
.text$mn:0000593B                 mov     ecx, [eax+8]
.text$mn:0000593E                 push    ecx
.text$mn:0000593F                 mov     edx, [ebp+var_18]
.text$mn:00005942                 mov     eax, [edx+4]
.text$mn:00005945                 push    eax
.text$mn:00005946                 mov     ecx, [ebp+var_18]
.text$mn:00005949                 call    ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int>>::_Umove<int *>(int *,int *,int *)
.text$mn:0000594E                 jmp     short loc_597A
.text$mn:0000594E ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z endp
.text$mn:0000594E
.text$mn:00005950
.text$mn:00005950 ; =============== S U B R O U T I N E =======================================
.text$mn:00005950
.text$mn:00005950 ; Attributes: noreturn
.text$mn:00005950
.text$mn:00005950 __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00005950                                         ; DATA XREF: .xdata$x:000083B8o
.text$mn:00005950                 mov     ecx, [ebp+8]
.text$mn:00005953                 push    ecx             ; int
.text$mn:00005954                 mov     edx, [ebp-1Ch]
.text$mn:00005957                 push    edx             ; void *
.text$mn:00005958                 lea     eax, [ebp-12h]
.text$mn:0000595B                 push    eax
.text$mn:0000595C                 mov     ecx, [ebp-18h]
.text$mn:0000595F                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00005964                 mov     ecx, eax
.text$mn:00005966                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)
.text$mn:0000596B                 push    0
.text$mn:0000596D                 push    0
.text$mn:0000596F                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000596F __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0 endp
.text$mn:0000596F
.text$mn:00005974 ; ---------------------------------------------------------------------------
.text$mn:00005974                 mov     eax, offset $LN8_2
.text$mn:00005979                 retn
.text$mn:0000597A ; ---------------------------------------------------------------------------
.text$mn:0000597A ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:0000597A
.text$mn:0000597A loc_597A:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+6Aj
.text$mn:0000597A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005981                 jmp     short loc_598A
.text$mn:00005981 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:00005983
.text$mn:00005983 ; =============== S U B R O U T I N E =======================================
.text$mn:00005983
.text$mn:00005983
.text$mn:00005983 $LN8_2          proc near               ; DATA XREF: .text$mn:00005974o
.text$mn:00005983                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00005983 $LN8_2          endp ; sp-analysis failed
.text$mn:00005983
.text$mn:0000598A ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:0000598A
.text$mn:0000598A loc_598A:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+9Dj
.text$mn:0000598A                 mov     ecx, [ebp+var_18]
.text$mn:0000598D                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00005992                 mov     [ebp+var_20], eax
.text$mn:00005995                 mov     ecx, [ebp+var_18]
.text$mn:00005998                 cmp     dword ptr [ecx+4], 0
.text$mn:0000599C                 jz      short loc_59DE
.text$mn:0000599E                 mov     edx, [ebp+var_18]
.text$mn:000059A1                 mov     eax, [edx+8]
.text$mn:000059A4                 push    eax
.text$mn:000059A5                 mov     ecx, [ebp+var_18]
.text$mn:000059A8                 mov     edx, [ecx+4]
.text$mn:000059AB                 push    edx
.text$mn:000059AC                 mov     ecx, [ebp+var_18]
.text$mn:000059AF                 call    ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)
.text$mn:000059B4                 mov     eax, [ebp+var_18]
.text$mn:000059B7                 mov     ecx, [ebp+var_18]
.text$mn:000059BA                 mov     edx, [eax+0Ch]
.text$mn:000059BD                 sub     edx, [ecx+4]
.text$mn:000059C0                 sar     edx, 2
.text$mn:000059C3                 push    edx             ; int
.text$mn:000059C4                 mov     eax, [ebp+var_18]
.text$mn:000059C7                 mov     ecx, [eax+4]
.text$mn:000059CA                 push    ecx             ; void *
.text$mn:000059CB                 lea     edx, [ebp+var_13]
.text$mn:000059CE                 push    edx
.text$mn:000059CF                 mov     ecx, [ebp+var_18]
.text$mn:000059D2                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:000059D7                 mov     ecx, eax
.text$mn:000059D9                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z ; std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)
.text$mn:000059DE
.text$mn:000059DE loc_59DE:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+B8j
.text$mn:000059DE                 mov     ecx, [ebp+var_18] ; this
.text$mn:000059E1                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000059E6                 mov     eax, [ebp+arg_0]
.text$mn:000059E9                 mov     ecx, [ebp+var_1C]
.text$mn:000059EC                 lea     edx, [ecx+eax*4]
.text$mn:000059EF                 mov     eax, [ebp+var_18]
.text$mn:000059F2                 mov     [eax+0Ch], edx
.text$mn:000059F5                 mov     ecx, [ebp+var_20]
.text$mn:000059F8                 mov     edx, [ebp+var_1C]
.text$mn:000059FB                 lea     eax, [edx+ecx*4]
.text$mn:000059FE                 mov     ecx, [ebp+var_18]
.text$mn:00005A01                 mov     [ecx+8], eax
.text$mn:00005A04                 mov     edx, [ebp+var_18]
.text$mn:00005A07                 mov     eax, [ebp+var_1C]
.text$mn:00005A0A                 mov     [edx+4], eax
.text$mn:00005A0D                 mov     ecx, [ebp+var_C]
.text$mn:00005A10                 mov     large fs:0, ecx
.text$mn:00005A17                 pop     ecx
.text$mn:00005A18                 pop     edi
.text$mn:00005A19                 pop     esi
.text$mn:00005A1A                 pop     ebx
.text$mn:00005A1B                 mov     esp, ebp
.text$mn:00005A1D                 pop     ebp
.text$mn:00005A1E                 retn    4
.text$mn:00005A1E ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:00005A1E ; ---------------------------------------------------------------------------
.text$mn:00005A21                 align 4
.text$mn:00005A21 _text$mn        ends
.text$mn:00005A21
.text$x:00005A24 ; ===========================================================================
.text$x:00005A24
.text$x:00005A24 ; Segment type: Pure code
.text$x:00005A24 ; Segment permissions: Read/Execute
.text$x:00005A24 _text$x         segment para public 'CODE' use32
.text$x:00005A24                 assume cs:_text$x
.text$x:00005A24                 ;org 5A24h
.text$x:00005A24 ; COMDAT (pick associative to section at 58E4)
.text$x:00005A24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005A24
.text$x:00005A24 ; =============== S U B R O U T I N E =======================================
.text$x:00005A24
.text$x:00005A24
.text$x:00005A24 __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z proc near
.text$x:00005A24                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+5o
.text$x:00005A24
.text$x:00005A24 arg_4           = dword ptr  8
.text$x:00005A24
.text$x:00005A24                 mov     edx, [esp+arg_4]
.text$x:00005A28                 lea     eax, [edx+0Ch]
.text$x:00005A2B                 mov     ecx, [edx-24h]
.text$x:00005A2E                 xor     ecx, eax
.text$x:00005A30                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005A35                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$x:00005A3A                 jmp     ___CxxFrameHandler3
.text$x:00005A3A __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z endp
.text$x:00005A3A
.text$x:00005A3A ; ---------------------------------------------------------------------------
.text$x:00005A3F                 align 10h
.text$x:00005A3F _text$x         ends
.text$x:00005A3F
.text$mn:00005A40 ; ===========================================================================
.text$mn:00005A40
.text$mn:00005A40 ; Segment type: Pure code
.text$mn:00005A40 ; Segment permissions: Read/Execute
.text$mn:00005A40 _text$mn        segment para public 'CODE' use32
.text$mn:00005A40                 assume cs:_text$mn
.text$mn:00005A40                 ;org 5A40h
.text$mn:00005A40 ; COMDAT (pick any)
.text$mn:00005A40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A40
.text$mn:00005A40 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A40
.text$mn:00005A40 ; Attributes: bp-based frame
.text$mn:00005A40
.text$mn:00005A40 ; protected: void __thiscall std::vector<struct iconLocator, class std::allocator<struct iconLocator>>::_Reallocate(unsigned int)
.text$mn:00005A40                 public ?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z
.text$mn:00005A40 ?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z proc near
.text$mn:00005A40                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Reserve(uint)+4Ep
.text$mn:00005A40
.text$mn:00005A40 var_20          = dword ptr -20h
.text$mn:00005A40 var_1C          = dword ptr -1Ch
.text$mn:00005A40 var_18          = dword ptr -18h
.text$mn:00005A40 var_13          = byte ptr -13h
.text$mn:00005A40 var_11          = byte ptr -11h
.text$mn:00005A40 var_10          = dword ptr -10h
.text$mn:00005A40 var_C           = dword ptr -0Ch
.text$mn:00005A40 var_4           = dword ptr -4
.text$mn:00005A40 arg_0           = dword ptr  8
.text$mn:00005A40
.text$mn:00005A40 ; FUNCTION CHUNK AT .text$mn:00005AD6 SIZE 00000009 BYTES
.text$mn:00005A40 ; FUNCTION CHUNK AT .text$mn:00005AE6 SIZE 00000098 BYTES
.text$mn:00005A40
.text$mn:00005A40                 push    ebp
.text$mn:00005A41                 mov     ebp, esp
.text$mn:00005A43                 push    0FFFFFFFFh
.text$mn:00005A45                 push    offset __ehhandler$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z
.text$mn:00005A4A                 mov     eax, large fs:0
.text$mn:00005A50                 push    eax
.text$mn:00005A51                 push    ecx
.text$mn:00005A52                 sub     esp, 10h
.text$mn:00005A55                 push    ebx
.text$mn:00005A56                 push    esi
.text$mn:00005A57                 push    edi
.text$mn:00005A58                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005A5D                 xor     eax, ebp
.text$mn:00005A5F                 push    eax
.text$mn:00005A60                 lea     eax, [ebp+var_C]
.text$mn:00005A63                 mov     large fs:0, eax
.text$mn:00005A69                 mov     [ebp+var_10], esp
.text$mn:00005A6C                 mov     [ebp+var_18], ecx
.text$mn:00005A6F                 mov     eax, [ebp+arg_0]
.text$mn:00005A72                 push    eax
.text$mn:00005A73                 lea     ecx, [ebp+var_11]
.text$mn:00005A76                 push    ecx
.text$mn:00005A77                 mov     ecx, [ebp+var_18]
.text$mn:00005A7A                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<iconLocator,std::allocator<iconLocator>>>::_Getal(void)
.text$mn:00005A7F                 mov     ecx, eax
.text$mn:00005A81                 call    ?allocate@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEPAUiconLocator@@I@Z ; std::_Wrap_alloc<std::allocator<iconLocator>>::allocate(uint)
.text$mn:00005A86                 mov     [ebp+var_1C], eax
.text$mn:00005A89                 mov     [ebp+var_4], 0
.text$mn:00005A90                 mov     edx, [ebp+var_1C]
.text$mn:00005A93                 push    edx
.text$mn:00005A94                 mov     eax, [ebp+var_18]
.text$mn:00005A97                 mov     ecx, [eax+8]
.text$mn:00005A9A                 push    ecx
.text$mn:00005A9B                 mov     edx, [ebp+var_18]
.text$mn:00005A9E                 mov     eax, [edx+4]
.text$mn:00005AA1                 push    eax
.text$mn:00005AA2                 mov     ecx, [ebp+var_18]
.text$mn:00005AA5                 call    ??$_Umove@PAUiconLocator@@@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEPAUiconLocator@@PAU2@00@Z ; std::vector<iconLocator,std::allocator<iconLocator>>::_Umove<iconLocator *>(iconLocator *,iconLocator *,iconLocator *)
.text$mn:00005AAA                 jmp     short loc_5AD6
.text$mn:00005AAA ?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z endp
.text$mn:00005AAA
.text$mn:00005AAC
.text$mn:00005AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00005AAC
.text$mn:00005AAC ; Attributes: noreturn
.text$mn:00005AAC
.text$mn:00005AAC __catch$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00005AAC                                         ; DATA XREF: .xdata$x:00008298o
.text$mn:00005AAC                 mov     ecx, [ebp+8]
.text$mn:00005AAF                 push    ecx             ; int
.text$mn:00005AB0                 mov     edx, [ebp-1Ch]
.text$mn:00005AB3                 push    edx             ; void *
.text$mn:00005AB4                 lea     eax, [ebp-12h]
.text$mn:00005AB7                 push    eax
.text$mn:00005AB8                 mov     ecx, [ebp-18h]
.text$mn:00005ABB                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<iconLocator,std::allocator<iconLocator>>>::_Getal(void)
.text$mn:00005AC0                 mov     ecx, eax
.text$mn:00005AC2                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@I@Z ; std::_Wrap_alloc<std::allocator<iconLocator>>::deallocate(iconLocator *,uint)
.text$mn:00005AC7                 push    0
.text$mn:00005AC9                 push    0
.text$mn:00005ACB                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00005ACB __catch$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:00005ACB
.text$mn:00005AD0 ; ---------------------------------------------------------------------------
.text$mn:00005AD0                 mov     eax, offset $LN8_0
.text$mn:00005AD5                 retn
.text$mn:00005AD6 ; ---------------------------------------------------------------------------
.text$mn:00005AD6 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z
.text$mn:00005AD6
.text$mn:00005AD6 loc_5AD6:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Reallocate(uint)+6Aj
.text$mn:00005AD6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005ADD                 jmp     short loc_5AE6
.text$mn:00005ADD ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z
.text$mn:00005ADF
.text$mn:00005ADF ; =============== S U B R O U T I N E =======================================
.text$mn:00005ADF
.text$mn:00005ADF
.text$mn:00005ADF $LN8_0          proc near               ; DATA XREF: .text$mn:00005AD0o
.text$mn:00005ADF                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00005ADF $LN8_0          endp ; sp-analysis failed
.text$mn:00005ADF
.text$mn:00005AE6 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z
.text$mn:00005AE6
.text$mn:00005AE6 loc_5AE6:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Reallocate(uint)+9Dj
.text$mn:00005AE6                 mov     ecx, [ebp+var_18]
.text$mn:00005AE9                 call    ?size@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ ; std::vector<iconLocator,std::allocator<iconLocator>>::size(void)
.text$mn:00005AEE                 mov     [ebp+var_20], eax
.text$mn:00005AF1                 mov     ecx, [ebp+var_18]
.text$mn:00005AF4                 cmp     dword ptr [ecx+4], 0
.text$mn:00005AF8                 jz      short loc_5B3F
.text$mn:00005AFA                 mov     edx, [ebp+var_18]
.text$mn:00005AFD                 mov     eax, [edx+8]
.text$mn:00005B00                 push    eax
.text$mn:00005B01                 mov     ecx, [ebp+var_18]
.text$mn:00005B04                 mov     edx, [ecx+4]
.text$mn:00005B07                 push    edx
.text$mn:00005B08                 mov     ecx, [ebp+var_18]
.text$mn:00005B0B                 call    ?_Destroy@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXPAUiconLocator@@0@Z ; std::vector<iconLocator,std::allocator<iconLocator>>::_Destroy(iconLocator *,iconLocator *)
.text$mn:00005B10                 mov     eax, [ebp+var_18]
.text$mn:00005B13                 mov     ecx, [ebp+var_18]
.text$mn:00005B16                 mov     eax, [eax+0Ch]
.text$mn:00005B19                 sub     eax, [ecx+4]
.text$mn:00005B1C                 cdq
.text$mn:00005B1D                 mov     ecx, 24h ; '$'
.text$mn:00005B22                 idiv    ecx
.text$mn:00005B24                 push    eax             ; int
.text$mn:00005B25                 mov     edx, [ebp+var_18]
.text$mn:00005B28                 mov     eax, [edx+4]
.text$mn:00005B2B                 push    eax             ; void *
.text$mn:00005B2C                 lea     ecx, [ebp+var_13]
.text$mn:00005B2F                 push    ecx
.text$mn:00005B30                 mov     ecx, [ebp+var_18]
.text$mn:00005B33                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<iconLocator,std::allocator<iconLocator>>>::_Getal(void)
.text$mn:00005B38                 mov     ecx, eax
.text$mn:00005B3A                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@I@Z ; std::_Wrap_alloc<std::allocator<iconLocator>>::deallocate(iconLocator *,uint)
.text$mn:00005B3F
.text$mn:00005B3F loc_5B3F:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Reallocate(uint)+B8j
.text$mn:00005B3F                 mov     ecx, [ebp+var_18] ; this
.text$mn:00005B42                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00005B47                 imul    edx, [ebp+arg_0], 24h
.text$mn:00005B4B                 add     edx, [ebp+var_1C]
.text$mn:00005B4E                 mov     eax, [ebp+var_18]
.text$mn:00005B51                 mov     [eax+0Ch], edx
.text$mn:00005B54                 imul    ecx, [ebp+var_20], 24h
.text$mn:00005B58                 add     ecx, [ebp+var_1C]
.text$mn:00005B5B                 mov     edx, [ebp+var_18]
.text$mn:00005B5E                 mov     [edx+8], ecx
.text$mn:00005B61                 mov     eax, [ebp+var_18]
.text$mn:00005B64                 mov     ecx, [ebp+var_1C]
.text$mn:00005B67                 mov     [eax+4], ecx
.text$mn:00005B6A                 mov     ecx, [ebp+var_C]
.text$mn:00005B6D                 mov     large fs:0, ecx
.text$mn:00005B74                 pop     ecx
.text$mn:00005B75                 pop     edi
.text$mn:00005B76                 pop     esi
.text$mn:00005B77                 pop     ebx
.text$mn:00005B78                 mov     esp, ebp
.text$mn:00005B7A                 pop     ebp
.text$mn:00005B7B                 retn    4
.text$mn:00005B7B ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z
.text$mn:00005B7B ; ---------------------------------------------------------------------------
.text$mn:00005B7E                 align 10h
.text$mn:00005B7E _text$mn        ends
.text$mn:00005B7E
.text$x:00005B80 ; ===========================================================================
.text$x:00005B80
.text$x:00005B80 ; Segment type: Pure code
.text$x:00005B80 ; Segment permissions: Read/Execute
.text$x:00005B80 _text$x         segment para public 'CODE' use32
.text$x:00005B80                 assume cs:_text$x
.text$x:00005B80                 ;org 5B80h
.text$x:00005B80 ; COMDAT (pick associative to section at 5A40)
.text$x:00005B80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005B80
.text$x:00005B80 ; =============== S U B R O U T I N E =======================================
.text$x:00005B80
.text$x:00005B80
.text$x:00005B80 __ehhandler$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z proc near
.text$x:00005B80                                         ; DATA XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Reallocate(uint)+5o
.text$x:00005B80
.text$x:00005B80 arg_4           = dword ptr  8
.text$x:00005B80
.text$x:00005B80                 mov     edx, [esp+arg_4]
.text$x:00005B84                 lea     eax, [edx+0Ch]
.text$x:00005B87                 mov     ecx, [edx-24h]
.text$x:00005B8A                 xor     ecx, eax
.text$x:00005B8C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005B91                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z
.text$x:00005B96                 jmp     ___CxxFrameHandler3
.text$x:00005B96 __ehhandler$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z endp
.text$x:00005B96
.text$x:00005B96 ; ---------------------------------------------------------------------------
.text$x:00005B9B                 align 4
.text$x:00005B9B _text$x         ends
.text$x:00005B9B
.text$mn:00005B9C ; ===========================================================================
.text$mn:00005B9C
.text$mn:00005B9C ; Segment type: Pure code
.text$mn:00005B9C ; Segment permissions: Read/Execute
.text$mn:00005B9C _text$mn        segment para public 'CODE' use32
.text$mn:00005B9C                 assume cs:_text$mn
.text$mn:00005B9C                 ;org 5B9Ch
.text$mn:00005B9C ; COMDAT (pick any)
.text$mn:00005B9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005B9C
.text$mn:00005B9C ; =============== S U B R O U T I N E =======================================
.text$mn:00005B9C
.text$mn:00005B9C ; Attributes: bp-based frame
.text$mn:00005B9C
.text$mn:00005B9C ; protected: void __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::_Reallocate(unsigned int)
.text$mn:00005B9C                 public ?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z
.text$mn:00005B9C ?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z proc near
.text$mn:00005B9C                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reserve(uint)+4Ep
.text$mn:00005B9C
.text$mn:00005B9C var_20          = dword ptr -20h
.text$mn:00005B9C var_1C          = dword ptr -1Ch
.text$mn:00005B9C var_18          = dword ptr -18h
.text$mn:00005B9C var_13          = byte ptr -13h
.text$mn:00005B9C var_11          = byte ptr -11h
.text$mn:00005B9C var_10          = dword ptr -10h
.text$mn:00005B9C var_C           = dword ptr -0Ch
.text$mn:00005B9C var_4           = dword ptr -4
.text$mn:00005B9C arg_0           = dword ptr  8
.text$mn:00005B9C
.text$mn:00005B9C ; FUNCTION CHUNK AT .text$mn:00005C32 SIZE 00000009 BYTES
.text$mn:00005B9C ; FUNCTION CHUNK AT .text$mn:00005C42 SIZE 00000098 BYTES
.text$mn:00005B9C
.text$mn:00005B9C                 push    ebp
.text$mn:00005B9D                 mov     ebp, esp
.text$mn:00005B9F                 push    0FFFFFFFFh
.text$mn:00005BA1                 push    offset __ehhandler$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z
.text$mn:00005BA6                 mov     eax, large fs:0
.text$mn:00005BAC                 push    eax
.text$mn:00005BAD                 push    ecx
.text$mn:00005BAE                 sub     esp, 10h
.text$mn:00005BB1                 push    ebx
.text$mn:00005BB2                 push    esi
.text$mn:00005BB3                 push    edi
.text$mn:00005BB4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005BB9                 xor     eax, ebp
.text$mn:00005BBB                 push    eax
.text$mn:00005BBC                 lea     eax, [ebp+var_C]
.text$mn:00005BBF                 mov     large fs:0, eax
.text$mn:00005BC5                 mov     [ebp+var_10], esp
.text$mn:00005BC8                 mov     [ebp+var_18], ecx
.text$mn:00005BCB                 mov     eax, [ebp+arg_0]
.text$mn:00005BCE                 push    eax
.text$mn:00005BCF                 lea     ecx, [ebp+var_11]
.text$mn:00005BD2                 push    ecx
.text$mn:00005BD3                 mov     ecx, [ebp+var_18]
.text$mn:00005BD6                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tDynamicList,std::allocator<tDynamicList>>>::_Getal(void)
.text$mn:00005BDB                 mov     ecx, eax
.text$mn:00005BDD                 call    ?allocate@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEPAUtDynamicList@@I@Z ; std::_Wrap_alloc<std::allocator<tDynamicList>>::allocate(uint)
.text$mn:00005BE2                 mov     [ebp+var_1C], eax
.text$mn:00005BE5                 mov     [ebp+var_4], 0
.text$mn:00005BEC                 mov     edx, [ebp+var_1C]
.text$mn:00005BEF                 push    edx
.text$mn:00005BF0                 mov     eax, [ebp+var_18]
.text$mn:00005BF3                 mov     ecx, [eax+8]
.text$mn:00005BF6                 push    ecx
.text$mn:00005BF7                 mov     edx, [ebp+var_18]
.text$mn:00005BFA                 mov     eax, [edx+4]
.text$mn:00005BFD                 push    eax
.text$mn:00005BFE                 mov     ecx, [ebp+var_18]
.text$mn:00005C01                 call    ??$_Umove@PAUtDynamicList@@@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEPAUtDynamicList@@PAU2@00@Z ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Umove<tDynamicList *>(tDynamicList *,tDynamicList *,tDynamicList *)
.text$mn:00005C06                 jmp     short loc_5C32
.text$mn:00005C06 ?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z endp
.text$mn:00005C06
.text$mn:00005C08
.text$mn:00005C08 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C08
.text$mn:00005C08 ; Attributes: noreturn
.text$mn:00005C08
.text$mn:00005C08 __catch$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00005C08                                         ; DATA XREF: .xdata$x:00008214o
.text$mn:00005C08                 mov     ecx, [ebp+8]
.text$mn:00005C0B                 push    ecx             ; int
.text$mn:00005C0C                 mov     edx, [ebp-1Ch]
.text$mn:00005C0F                 push    edx             ; void *
.text$mn:00005C10                 lea     eax, [ebp-12h]
.text$mn:00005C13                 push    eax
.text$mn:00005C14                 mov     ecx, [ebp-18h]
.text$mn:00005C17                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tDynamicList,std::allocator<tDynamicList>>>::_Getal(void)
.text$mn:00005C1C                 mov     ecx, eax
.text$mn:00005C1E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@I@Z ; std::_Wrap_alloc<std::allocator<tDynamicList>>::deallocate(tDynamicList *,uint)
.text$mn:00005C23                 push    0
.text$mn:00005C25                 push    0
.text$mn:00005C27                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00005C27 __catch$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:00005C27
.text$mn:00005C2C ; ---------------------------------------------------------------------------
.text$mn:00005C2C                 mov     eax, offset $LN8
.text$mn:00005C31                 retn
.text$mn:00005C32 ; ---------------------------------------------------------------------------
.text$mn:00005C32 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z
.text$mn:00005C32
.text$mn:00005C32 loc_5C32:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reallocate(uint)+6Aj
.text$mn:00005C32                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005C39                 jmp     short loc_5C42
.text$mn:00005C39 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z
.text$mn:00005C3B
.text$mn:00005C3B ; =============== S U B R O U T I N E =======================================
.text$mn:00005C3B
.text$mn:00005C3B
.text$mn:00005C3B $LN8            proc near               ; DATA XREF: .text$mn:00005C2Co
.text$mn:00005C3B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00005C3B $LN8            endp ; sp-analysis failed
.text$mn:00005C3B
.text$mn:00005C42 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z
.text$mn:00005C42
.text$mn:00005C42 loc_5C42:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reallocate(uint)+9Dj
.text$mn:00005C42                 mov     ecx, [ebp+var_18]
.text$mn:00005C45                 call    ?size@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ ; std::vector<tDynamicList,std::allocator<tDynamicList>>::size(void)
.text$mn:00005C4A                 mov     [ebp+var_20], eax
.text$mn:00005C4D                 mov     ecx, [ebp+var_18]
.text$mn:00005C50                 cmp     dword ptr [ecx+4], 0
.text$mn:00005C54                 jz      short loc_5C9B
.text$mn:00005C56                 mov     edx, [ebp+var_18]
.text$mn:00005C59                 mov     eax, [edx+8]
.text$mn:00005C5C                 push    eax
.text$mn:00005C5D                 mov     ecx, [ebp+var_18]
.text$mn:00005C60                 mov     edx, [ecx+4]
.text$mn:00005C63                 push    edx
.text$mn:00005C64                 mov     ecx, [ebp+var_18]
.text$mn:00005C67                 call    ?_Destroy@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXPAUtDynamicList@@0@Z ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Destroy(tDynamicList *,tDynamicList *)
.text$mn:00005C6C                 mov     eax, [ebp+var_18]
.text$mn:00005C6F                 mov     ecx, [ebp+var_18]
.text$mn:00005C72                 mov     eax, [eax+0Ch]
.text$mn:00005C75                 sub     eax, [ecx+4]
.text$mn:00005C78                 cdq
.text$mn:00005C79                 mov     ecx, 0Ch
.text$mn:00005C7E                 idiv    ecx
.text$mn:00005C80                 push    eax             ; int
.text$mn:00005C81                 mov     edx, [ebp+var_18]
.text$mn:00005C84                 mov     eax, [edx+4]
.text$mn:00005C87                 push    eax             ; void *
.text$mn:00005C88                 lea     ecx, [ebp+var_13]
.text$mn:00005C8B                 push    ecx
.text$mn:00005C8C                 mov     ecx, [ebp+var_18]
.text$mn:00005C8F                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tDynamicList,std::allocator<tDynamicList>>>::_Getal(void)
.text$mn:00005C94                 mov     ecx, eax
.text$mn:00005C96                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@I@Z ; std::_Wrap_alloc<std::allocator<tDynamicList>>::deallocate(tDynamicList *,uint)
.text$mn:00005C9B
.text$mn:00005C9B loc_5C9B:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reallocate(uint)+B8j
.text$mn:00005C9B                 mov     ecx, [ebp+var_18] ; this
.text$mn:00005C9E                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00005CA3                 imul    edx, [ebp+arg_0], 0Ch
.text$mn:00005CA7                 add     edx, [ebp+var_1C]
.text$mn:00005CAA                 mov     eax, [ebp+var_18]
.text$mn:00005CAD                 mov     [eax+0Ch], edx
.text$mn:00005CB0                 imul    ecx, [ebp+var_20], 0Ch
.text$mn:00005CB4                 add     ecx, [ebp+var_1C]
.text$mn:00005CB7                 mov     edx, [ebp+var_18]
.text$mn:00005CBA                 mov     [edx+8], ecx
.text$mn:00005CBD                 mov     eax, [ebp+var_18]
.text$mn:00005CC0                 mov     ecx, [ebp+var_1C]
.text$mn:00005CC3                 mov     [eax+4], ecx
.text$mn:00005CC6                 mov     ecx, [ebp+var_C]
.text$mn:00005CC9                 mov     large fs:0, ecx
.text$mn:00005CD0                 pop     ecx
.text$mn:00005CD1                 pop     edi
.text$mn:00005CD2                 pop     esi
.text$mn:00005CD3                 pop     ebx
.text$mn:00005CD4                 mov     esp, ebp
.text$mn:00005CD6                 pop     ebp
.text$mn:00005CD7                 retn    4
.text$mn:00005CD7 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z
.text$mn:00005CD7 ; ---------------------------------------------------------------------------
.text$mn:00005CDA                 align 4
.text$mn:00005CDA _text$mn        ends
.text$mn:00005CDA
.text$x:00005CDC ; ===========================================================================
.text$x:00005CDC
.text$x:00005CDC ; Segment type: Pure code
.text$x:00005CDC ; Segment permissions: Read/Execute
.text$x:00005CDC _text$x         segment para public 'CODE' use32
.text$x:00005CDC                 assume cs:_text$x
.text$x:00005CDC                 ;org 5CDCh
.text$x:00005CDC ; COMDAT (pick associative to section at 5B9C)
.text$x:00005CDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005CDC
.text$x:00005CDC ; =============== S U B R O U T I N E =======================================
.text$x:00005CDC
.text$x:00005CDC
.text$x:00005CDC __ehhandler$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z proc near
.text$x:00005CDC                                         ; DATA XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reallocate(uint)+5o
.text$x:00005CDC
.text$x:00005CDC arg_4           = dword ptr  8
.text$x:00005CDC
.text$x:00005CDC                 mov     edx, [esp+arg_4]
.text$x:00005CE0                 lea     eax, [edx+0Ch]
.text$x:00005CE3                 mov     ecx, [edx-24h]
.text$x:00005CE6                 xor     ecx, eax
.text$x:00005CE8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005CED                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z
.text$x:00005CF2                 jmp     ___CxxFrameHandler3
.text$x:00005CF2 __ehhandler$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z endp
.text$x:00005CF2
.text$x:00005CF2 ; ---------------------------------------------------------------------------
.text$x:00005CF7                 align 4
.text$x:00005CF7 _text$x         ends
.text$x:00005CF7
.text$mn:00005CF8 ; ===========================================================================
.text$mn:00005CF8
.text$mn:00005CF8 ; Segment type: Pure code
.text$mn:00005CF8 ; Segment permissions: Read/Execute
.text$mn:00005CF8 _text$mn        segment para public 'CODE' use32
.text$mn:00005CF8                 assume cs:_text$mn
.text$mn:00005CF8                 ;org 5CF8h
.text$mn:00005CF8 ; COMDAT (pick any)
.text$mn:00005CF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005CF8
.text$mn:00005CF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005CF8
.text$mn:00005CF8 ; Attributes: bp-based frame
.text$mn:00005CF8
.text$mn:00005CF8 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Reserve(unsigned int)
.text$mn:00005CF8                 public ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.text$mn:00005CF8 ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z proc near
.text$mn:00005CF8                                         ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+50p
.text$mn:00005CF8                                         ; std::vector<int,std::allocator<int>>::push_back(int const &)+B6p
.text$mn:00005CF8
.text$mn:00005CF8 var_4           = dword ptr -4
.text$mn:00005CF8 arg_0           = dword ptr  8
.text$mn:00005CF8
.text$mn:00005CF8                 push    ebp
.text$mn:00005CF9                 mov     ebp, esp
.text$mn:00005CFB                 push    ecx
.text$mn:00005CFC                 push    esi
.text$mn:00005CFD                 mov     [ebp+var_4], ecx
.text$mn:00005D00                 mov     ecx, [ebp+var_4]
.text$mn:00005D03                 call    ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::_Unused_capacity(void)
.text$mn:00005D08                 cmp     eax, [ebp+arg_0]
.text$mn:00005D0B                 jnb     short loc_5D4B
.text$mn:00005D0D                 mov     ecx, [ebp+var_4]
.text$mn:00005D10                 call    ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::max_size(void)
.text$mn:00005D15                 mov     esi, eax
.text$mn:00005D17                 mov     ecx, [ebp+var_4]
.text$mn:00005D1A                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00005D1F                 sub     esi, eax
.text$mn:00005D21                 cmp     esi, [ebp+arg_0]
.text$mn:00005D24                 jnb     short loc_5D2E
.text$mn:00005D26                 mov     ecx, [ebp+var_4]
.text$mn:00005D29                 call    ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int>>::_Xlen(void)
.text$mn:00005D2E
.text$mn:00005D2E loc_5D2E:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+2Cj
.text$mn:00005D2E                 mov     ecx, [ebp+var_4]
.text$mn:00005D31                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:00005D36                 add     eax, [ebp+arg_0]
.text$mn:00005D39                 push    eax
.text$mn:00005D3A                 mov     ecx, [ebp+var_4]
.text$mn:00005D3D                 call    ?_Grow_to@?$vector@HV?$allocator@H@std@@@std@@IBEII@Z ; std::vector<int,std::allocator<int>>::_Grow_to(uint)
.text$mn:00005D42                 push    eax
.text$mn:00005D43                 mov     ecx, [ebp+var_4]
.text$mn:00005D46                 call    ?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int>>::_Reallocate(uint)
.text$mn:00005D4B
.text$mn:00005D4B loc_5D4B:                               ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+13j
.text$mn:00005D4B                 pop     esi
.text$mn:00005D4C                 mov     esp, ebp
.text$mn:00005D4E                 pop     ebp
.text$mn:00005D4F                 retn    4
.text$mn:00005D4F ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z endp
.text$mn:00005D4F
.text$mn:00005D4F ; ---------------------------------------------------------------------------
.text$mn:00005D52                 align 4
.text$mn:00005D52 _text$mn        ends
.text$mn:00005D52
.text$mn:00005D54 ; ===========================================================================
.text$mn:00005D54
.text$mn:00005D54 ; Segment type: Pure code
.text$mn:00005D54 ; Segment permissions: Read/Execute
.text$mn:00005D54 _text$mn        segment para public 'CODE' use32
.text$mn:00005D54                 assume cs:_text$mn
.text$mn:00005D54                 ;org 5D54h
.text$mn:00005D54 ; COMDAT (pick any)
.text$mn:00005D54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D54
.text$mn:00005D54 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D54
.text$mn:00005D54 ; Attributes: bp-based frame
.text$mn:00005D54
.text$mn:00005D54 ; protected: void __thiscall std::vector<struct iconLocator, class std::allocator<struct iconLocator>>::_Reserve(unsigned int)
.text$mn:00005D54                 public ?_Reserve@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z
.text$mn:00005D54 ?_Reserve@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z proc near
.text$mn:00005D54                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)+59p
.text$mn:00005D54                                         ; std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)+C6p
.text$mn:00005D54
.text$mn:00005D54 var_4           = dword ptr -4
.text$mn:00005D54 arg_0           = dword ptr  8
.text$mn:00005D54
.text$mn:00005D54                 push    ebp
.text$mn:00005D55                 mov     ebp, esp
.text$mn:00005D57                 push    ecx
.text$mn:00005D58                 push    esi
.text$mn:00005D59                 mov     [ebp+var_4], ecx
.text$mn:00005D5C                 mov     ecx, [ebp+var_4]
.text$mn:00005D5F                 call    ?_Unused_capacity@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ ; std::vector<iconLocator,std::allocator<iconLocator>>::_Unused_capacity(void)
.text$mn:00005D64                 cmp     eax, [ebp+arg_0]
.text$mn:00005D67                 jnb     short loc_5DA7
.text$mn:00005D69                 mov     ecx, [ebp+var_4]
.text$mn:00005D6C                 call    ?max_size@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ ; std::vector<iconLocator,std::allocator<iconLocator>>::max_size(void)
.text$mn:00005D71                 mov     esi, eax
.text$mn:00005D73                 mov     ecx, [ebp+var_4]
.text$mn:00005D76                 call    ?size@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ ; std::vector<iconLocator,std::allocator<iconLocator>>::size(void)
.text$mn:00005D7B                 sub     esi, eax
.text$mn:00005D7D                 cmp     esi, [ebp+arg_0]
.text$mn:00005D80                 jnb     short loc_5D8A
.text$mn:00005D82                 mov     ecx, [ebp+var_4]
.text$mn:00005D85                 call    ?_Xlen@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXXZ ; std::vector<iconLocator,std::allocator<iconLocator>>::_Xlen(void)
.text$mn:00005D8A
.text$mn:00005D8A loc_5D8A:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Reserve(uint)+2Cj
.text$mn:00005D8A                 mov     ecx, [ebp+var_4]
.text$mn:00005D8D                 call    ?size@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ ; std::vector<iconLocator,std::allocator<iconLocator>>::size(void)
.text$mn:00005D92                 add     eax, [ebp+arg_0]
.text$mn:00005D95                 push    eax
.text$mn:00005D96                 mov     ecx, [ebp+var_4]
.text$mn:00005D99                 call    ?_Grow_to@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEII@Z ; std::vector<iconLocator,std::allocator<iconLocator>>::_Grow_to(uint)
.text$mn:00005D9E                 push    eax
.text$mn:00005D9F                 mov     ecx, [ebp+var_4]
.text$mn:00005DA2                 call    ?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z ; std::vector<iconLocator,std::allocator<iconLocator>>::_Reallocate(uint)
.text$mn:00005DA7
.text$mn:00005DA7 loc_5DA7:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Reserve(uint)+13j
.text$mn:00005DA7                 pop     esi
.text$mn:00005DA8                 mov     esp, ebp
.text$mn:00005DAA                 pop     ebp
.text$mn:00005DAB                 retn    4
.text$mn:00005DAB ?_Reserve@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z endp
.text$mn:00005DAB
.text$mn:00005DAB ; ---------------------------------------------------------------------------
.text$mn:00005DAE                 align 10h
.text$mn:00005DAE _text$mn        ends
.text$mn:00005DAE
.text$mn:00005DB0 ; ===========================================================================
.text$mn:00005DB0
.text$mn:00005DB0 ; Segment type: Pure code
.text$mn:00005DB0 ; Segment permissions: Read/Execute
.text$mn:00005DB0 _text$mn        segment para public 'CODE' use32
.text$mn:00005DB0                 assume cs:_text$mn
.text$mn:00005DB0                 ;org 5DB0h
.text$mn:00005DB0 ; COMDAT (pick any)
.text$mn:00005DB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DB0
.text$mn:00005DB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005DB0
.text$mn:00005DB0 ; Attributes: bp-based frame
.text$mn:00005DB0
.text$mn:00005DB0 ; protected: void __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::_Reserve(unsigned int)
.text$mn:00005DB0                 public ?_Reserve@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z
.text$mn:00005DB0 ?_Reserve@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z proc near
.text$mn:00005DB0                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::push_back(tDynamicList const &)+59p
.text$mn:00005DB0                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::push_back(tDynamicList const &)+BDp
.text$mn:00005DB0
.text$mn:00005DB0 var_4           = dword ptr -4
.text$mn:00005DB0 arg_0           = dword ptr  8
.text$mn:00005DB0
.text$mn:00005DB0                 push    ebp
.text$mn:00005DB1                 mov     ebp, esp
.text$mn:00005DB3                 push    ecx
.text$mn:00005DB4                 push    esi
.text$mn:00005DB5                 mov     [ebp+var_4], ecx
.text$mn:00005DB8                 mov     ecx, [ebp+var_4]
.text$mn:00005DBB                 call    ?_Unused_capacity@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Unused_capacity(void)
.text$mn:00005DC0                 cmp     eax, [ebp+arg_0]
.text$mn:00005DC3                 jnb     short loc_5E03
.text$mn:00005DC5                 mov     ecx, [ebp+var_4]
.text$mn:00005DC8                 call    ?max_size@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ ; std::vector<tDynamicList,std::allocator<tDynamicList>>::max_size(void)
.text$mn:00005DCD                 mov     esi, eax
.text$mn:00005DCF                 mov     ecx, [ebp+var_4]
.text$mn:00005DD2                 call    ?size@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ ; std::vector<tDynamicList,std::allocator<tDynamicList>>::size(void)
.text$mn:00005DD7                 sub     esi, eax
.text$mn:00005DD9                 cmp     esi, [ebp+arg_0]
.text$mn:00005DDC                 jnb     short loc_5DE6
.text$mn:00005DDE                 mov     ecx, [ebp+var_4]
.text$mn:00005DE1                 call    ?_Xlen@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXXZ ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Xlen(void)
.text$mn:00005DE6
.text$mn:00005DE6 loc_5DE6:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reserve(uint)+2Cj
.text$mn:00005DE6                 mov     ecx, [ebp+var_4]
.text$mn:00005DE9                 call    ?size@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ ; std::vector<tDynamicList,std::allocator<tDynamicList>>::size(void)
.text$mn:00005DEE                 add     eax, [ebp+arg_0]
.text$mn:00005DF1                 push    eax
.text$mn:00005DF2                 mov     ecx, [ebp+var_4]
.text$mn:00005DF5                 call    ?_Grow_to@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEII@Z ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Grow_to(uint)
.text$mn:00005DFA                 push    eax
.text$mn:00005DFB                 mov     ecx, [ebp+var_4]
.text$mn:00005DFE                 call    ?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reallocate(uint)
.text$mn:00005E03
.text$mn:00005E03 loc_5E03:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reserve(uint)+13j
.text$mn:00005E03                 pop     esi
.text$mn:00005E04                 mov     esp, ebp
.text$mn:00005E06                 pop     ebp
.text$mn:00005E07                 retn    4
.text$mn:00005E07 ?_Reserve@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z endp
.text$mn:00005E07
.text$mn:00005E07 ; ---------------------------------------------------------------------------
.text$mn:00005E0A                 align 4
.text$mn:00005E0A _text$mn        ends
.text$mn:00005E0A
.text$mn:00005E0C ; ===========================================================================
.text$mn:00005E0C
.text$mn:00005E0C ; Segment type: Pure code
.text$mn:00005E0C ; Segment permissions: Read/Execute
.text$mn:00005E0C _text$mn        segment para public 'CODE' use32
.text$mn:00005E0C                 assume cs:_text$mn
.text$mn:00005E0C                 ;org 5E0Ch
.text$mn:00005E0C ; COMDAT (pick any)
.text$mn:00005E0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E0C
.text$mn:00005E0C ; =============== S U B R O U T I N E =======================================
.text$mn:00005E0C
.text$mn:00005E0C ; Attributes: bp-based frame
.text$mn:00005E0C
.text$mn:00005E0C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00005E0C                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00005E0C ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00005E0C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00005E0C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00005E0C
.text$mn:00005E0C var_C           = dword ptr -0Ch
.text$mn:00005E0C var_8           = dword ptr -8
.text$mn:00005E0C var_2           = byte ptr -2
.text$mn:00005E0C var_1           = byte ptr -1
.text$mn:00005E0C arg_0           = byte ptr  8
.text$mn:00005E0C Size            = dword ptr  0Ch
.text$mn:00005E0C
.text$mn:00005E0C                 push    ebp
.text$mn:00005E0D                 mov     ebp, esp
.text$mn:00005E0F                 sub     esp, 0Ch
.text$mn:00005E12                 mov     [ebp+var_8], ecx
.text$mn:00005E15                 movzx   eax, [ebp+arg_0]
.text$mn:00005E19                 test    eax, eax
.text$mn:00005E1B                 jnz     short loc_5E1F
.text$mn:00005E1D                 jmp     short loc_5E92
.text$mn:00005E1F ; ---------------------------------------------------------------------------
.text$mn:00005E1F
.text$mn:00005E1F loc_5E1F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00005E1F                 mov     ecx, [ebp+var_8]
.text$mn:00005E22                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00005E26                 jb      short loc_5E92
.text$mn:00005E28                 mov     edx, [ebp+var_8]
.text$mn:00005E2B                 mov     eax, [edx+4]
.text$mn:00005E2E                 mov     [ebp+var_C], eax
.text$mn:00005E31                 mov     ecx, [ebp+var_8]
.text$mn:00005E34                 add     ecx, 4
.text$mn:00005E37                 push    ecx
.text$mn:00005E38                 lea     edx, [ebp+var_1]
.text$mn:00005E3B                 push    edx
.text$mn:00005E3C                 mov     ecx, [ebp+var_8]
.text$mn:00005E3F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00005E44                 mov     ecx, eax
.text$mn:00005E46                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00005E4B                 cmp     [ebp+Size], 0
.text$mn:00005E4F                 jbe     short loc_5E71
.text$mn:00005E51                 mov     eax, [ebp+Size]
.text$mn:00005E54                 push    eax             ; Size
.text$mn:00005E55                 mov     ecx, [ebp+var_C]
.text$mn:00005E58                 push    ecx
.text$mn:00005E59                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00005E5E                 add     esp, 4
.text$mn:00005E61                 push    eax             ; Src
.text$mn:00005E62                 mov     edx, [ebp+var_8]
.text$mn:00005E65                 add     edx, 4
.text$mn:00005E68                 push    edx             ; Dst
.text$mn:00005E69                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00005E6E                 add     esp, 0Ch
.text$mn:00005E71
.text$mn:00005E71 loc_5E71:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00005E71                 mov     eax, [ebp+var_8]
.text$mn:00005E74                 mov     ecx, [eax+18h]
.text$mn:00005E77                 add     ecx, 1
.text$mn:00005E7A                 push    ecx             ; int
.text$mn:00005E7B                 mov     edx, [ebp+var_C]
.text$mn:00005E7E                 push    edx             ; void *
.text$mn:00005E7F                 lea     eax, [ebp+var_2]
.text$mn:00005E82                 push    eax
.text$mn:00005E83                 mov     ecx, [ebp+var_8]
.text$mn:00005E86                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00005E8B                 mov     ecx, eax
.text$mn:00005E8D                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00005E92
.text$mn:00005E92 loc_5E92:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00005E92                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00005E92                 mov     ecx, [ebp+var_8]
.text$mn:00005E95                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00005E9C                 mov     edx, [ebp+Size]
.text$mn:00005E9F                 push    edx
.text$mn:00005EA0                 mov     ecx, [ebp+var_8]
.text$mn:00005EA3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005EA8                 mov     esp, ebp
.text$mn:00005EAA                 pop     ebp
.text$mn:00005EAB                 retn    8
.text$mn:00005EAB ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00005EAB
.text$mn:00005EAB ; ---------------------------------------------------------------------------
.text$mn:00005EAE                 align 10h
.text$mn:00005EAE _text$mn        ends
.text$mn:00005EAE
.text$mn:00005EB0 ; ===========================================================================
.text$mn:00005EB0
.text$mn:00005EB0 ; Segment type: Pure code
.text$mn:00005EB0 ; Segment permissions: Read/Execute
.text$mn:00005EB0 _text$mn        segment para public 'CODE' use32
.text$mn:00005EB0                 assume cs:_text$mn
.text$mn:00005EB0                 ;org 5EB0h
.text$mn:00005EB0 ; COMDAT (pick any)
.text$mn:00005EB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EB0
.text$mn:00005EB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005EB0
.text$mn:00005EB0 ; Attributes: bp-based frame
.text$mn:00005EB0
.text$mn:00005EB0 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00005EB0                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00005EB0 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00005EB0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+56p
.text$mn:00005EB0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+47p ...
.text$mn:00005EB0
.text$mn:00005EB0 var_C           = dword ptr -0Ch
.text$mn:00005EB0 var_8           = dword ptr -8
.text$mn:00005EB0 var_2           = byte ptr -2
.text$mn:00005EB0 var_1           = byte ptr -1
.text$mn:00005EB0 arg_0           = byte ptr  8
.text$mn:00005EB0 arg_4           = dword ptr  0Ch
.text$mn:00005EB0
.text$mn:00005EB0                 push    ebp
.text$mn:00005EB1                 mov     ebp, esp
.text$mn:00005EB3                 sub     esp, 0Ch
.text$mn:00005EB6                 mov     [ebp+var_8], ecx
.text$mn:00005EB9                 movzx   eax, [ebp+arg_0]
.text$mn:00005EBD                 test    eax, eax
.text$mn:00005EBF                 jnz     short loc_5EC3
.text$mn:00005EC1                 jmp     short loc_5F36
.text$mn:00005EC3 ; ---------------------------------------------------------------------------
.text$mn:00005EC3
.text$mn:00005EC3 loc_5EC3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:00005EC3                 mov     ecx, [ebp+var_8]
.text$mn:00005EC6                 cmp     dword ptr [ecx+18h], 8
.text$mn:00005ECA                 jb      short loc_5F36
.text$mn:00005ECC                 mov     edx, [ebp+var_8]
.text$mn:00005ECF                 mov     eax, [edx+4]
.text$mn:00005ED2                 mov     [ebp+var_C], eax
.text$mn:00005ED5                 mov     ecx, [ebp+var_8]
.text$mn:00005ED8                 add     ecx, 4
.text$mn:00005EDB                 push    ecx
.text$mn:00005EDC                 lea     edx, [ebp+var_1]
.text$mn:00005EDF                 push    edx
.text$mn:00005EE0                 mov     ecx, [ebp+var_8]
.text$mn:00005EE3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00005EE8                 mov     ecx, eax
.text$mn:00005EEA                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00005EEF                 cmp     [ebp+arg_4], 0
.text$mn:00005EF3                 jbe     short loc_5F15
.text$mn:00005EF5                 mov     eax, [ebp+arg_4]
.text$mn:00005EF8                 push    eax             ; int
.text$mn:00005EF9                 mov     ecx, [ebp+var_C]
.text$mn:00005EFC                 push    ecx
.text$mn:00005EFD                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00005F02                 add     esp, 4
.text$mn:00005F05                 push    eax             ; Src
.text$mn:00005F06                 mov     edx, [ebp+var_8]
.text$mn:00005F09                 add     edx, 4
.text$mn:00005F0C                 push    edx             ; Dst
.text$mn:00005F0D                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00005F12                 add     esp, 0Ch
.text$mn:00005F15
.text$mn:00005F15 loc_5F15:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:00005F15                 mov     eax, [ebp+var_8]
.text$mn:00005F18                 mov     ecx, [eax+18h]
.text$mn:00005F1B                 add     ecx, 1
.text$mn:00005F1E                 push    ecx             ; int
.text$mn:00005F1F                 mov     edx, [ebp+var_C]
.text$mn:00005F22                 push    edx             ; void *
.text$mn:00005F23                 lea     eax, [ebp+var_2]
.text$mn:00005F26                 push    eax
.text$mn:00005F27                 mov     ecx, [ebp+var_8]
.text$mn:00005F2A                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00005F2F                 mov     ecx, eax
.text$mn:00005F31                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:00005F36
.text$mn:00005F36 loc_5F36:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:00005F36                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:00005F36                 mov     ecx, [ebp+var_8]
.text$mn:00005F39                 mov     dword ptr [ecx+18h], 7
.text$mn:00005F40                 mov     edx, [ebp+arg_4]
.text$mn:00005F43                 push    edx
.text$mn:00005F44                 mov     ecx, [ebp+var_8]
.text$mn:00005F47                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00005F4C                 mov     esp, ebp
.text$mn:00005F4E                 pop     ebp
.text$mn:00005F4F                 retn    8
.text$mn:00005F4F ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:00005F4F
.text$mn:00005F4F ; ---------------------------------------------------------------------------
.text$mn:00005F52                 align 4
.text$mn:00005F52 _text$mn        ends
.text$mn:00005F52
.text$mn:00005F54 ; ===========================================================================
.text$mn:00005F54
.text$mn:00005F54 ; Segment type: Pure code
.text$mn:00005F54 ; Segment permissions: Read/Execute
.text$mn:00005F54 _text$mn        segment para public 'CODE' use32
.text$mn:00005F54                 assume cs:_text$mn
.text$mn:00005F54                 ;org 5F54h
.text$mn:00005F54 ; COMDAT (pick any)
.text$mn:00005F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F54
.text$mn:00005F54 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F54
.text$mn:00005F54 ; Attributes: bp-based frame
.text$mn:00005F54
.text$mn:00005F54 ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::_Unused_capacity(void)const
.text$mn:00005F54                 public ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:00005F54 ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:00005F54                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+Bp
.text$mn:00005F54
.text$mn:00005F54 var_4           = dword ptr -4
.text$mn:00005F54
.text$mn:00005F54                 push    ebp
.text$mn:00005F55                 mov     ebp, esp
.text$mn:00005F57                 push    ecx
.text$mn:00005F58                 mov     [ebp+var_4], ecx
.text$mn:00005F5B                 mov     eax, [ebp+var_4]
.text$mn:00005F5E                 mov     ecx, [ebp+var_4]
.text$mn:00005F61                 mov     eax, [eax+0Ch]
.text$mn:00005F64                 sub     eax, [ecx+8]
.text$mn:00005F67                 sar     eax, 2
.text$mn:00005F6A                 mov     esp, ebp
.text$mn:00005F6C                 pop     ebp
.text$mn:00005F6D                 retn
.text$mn:00005F6D ?_Unused_capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:00005F6D
.text$mn:00005F6D ; ---------------------------------------------------------------------------
.text$mn:00005F6E                 align 10h
.text$mn:00005F6E _text$mn        ends
.text$mn:00005F6E
.text$mn:00005F70 ; ===========================================================================
.text$mn:00005F70
.text$mn:00005F70 ; Segment type: Pure code
.text$mn:00005F70 ; Segment permissions: Read/Execute
.text$mn:00005F70 _text$mn        segment para public 'CODE' use32
.text$mn:00005F70                 assume cs:_text$mn
.text$mn:00005F70                 ;org 5F70h
.text$mn:00005F70 ; COMDAT (pick any)
.text$mn:00005F70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F70
.text$mn:00005F70 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F70
.text$mn:00005F70 ; Attributes: bp-based frame
.text$mn:00005F70
.text$mn:00005F70 ; public: unsigned int __thiscall std::vector<struct iconLocator, class std::allocator<struct iconLocator>>::_Unused_capacity(void)const
.text$mn:00005F70                 public ?_Unused_capacity@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ
.text$mn:00005F70 ?_Unused_capacity@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ proc near
.text$mn:00005F70                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Reserve(uint)+Bp
.text$mn:00005F70
.text$mn:00005F70 var_4           = dword ptr -4
.text$mn:00005F70
.text$mn:00005F70                 push    ebp
.text$mn:00005F71                 mov     ebp, esp
.text$mn:00005F73                 push    ecx
.text$mn:00005F74                 mov     [ebp+var_4], ecx
.text$mn:00005F77                 mov     eax, [ebp+var_4]
.text$mn:00005F7A                 mov     ecx, [ebp+var_4]
.text$mn:00005F7D                 mov     eax, [eax+0Ch]
.text$mn:00005F80                 sub     eax, [ecx+8]
.text$mn:00005F83                 cdq
.text$mn:00005F84                 mov     ecx, 24h ; '$'
.text$mn:00005F89                 idiv    ecx
.text$mn:00005F8B                 mov     esp, ebp
.text$mn:00005F8D                 pop     ebp
.text$mn:00005F8E                 retn
.text$mn:00005F8E ?_Unused_capacity@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ endp
.text$mn:00005F8E
.text$mn:00005F8E ; ---------------------------------------------------------------------------
.text$mn:00005F8F                 align 10h
.text$mn:00005F8F _text$mn        ends
.text$mn:00005F8F
.text$mn:00005F90 ; ===========================================================================
.text$mn:00005F90
.text$mn:00005F90 ; Segment type: Pure code
.text$mn:00005F90 ; Segment permissions: Read/Execute
.text$mn:00005F90 _text$mn        segment para public 'CODE' use32
.text$mn:00005F90                 assume cs:_text$mn
.text$mn:00005F90                 ;org 5F90h
.text$mn:00005F90 ; COMDAT (pick any)
.text$mn:00005F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F90
.text$mn:00005F90 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F90
.text$mn:00005F90 ; Attributes: bp-based frame
.text$mn:00005F90
.text$mn:00005F90 ; public: unsigned int __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::_Unused_capacity(void)const
.text$mn:00005F90                 public ?_Unused_capacity@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ
.text$mn:00005F90 ?_Unused_capacity@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ proc near
.text$mn:00005F90                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reserve(uint)+Bp
.text$mn:00005F90
.text$mn:00005F90 var_4           = dword ptr -4
.text$mn:00005F90
.text$mn:00005F90                 push    ebp
.text$mn:00005F91                 mov     ebp, esp
.text$mn:00005F93                 push    ecx
.text$mn:00005F94                 mov     [ebp+var_4], ecx
.text$mn:00005F97                 mov     eax, [ebp+var_4]
.text$mn:00005F9A                 mov     ecx, [ebp+var_4]
.text$mn:00005F9D                 mov     eax, [eax+0Ch]
.text$mn:00005FA0                 sub     eax, [ecx+8]
.text$mn:00005FA3                 cdq
.text$mn:00005FA4                 mov     ecx, 0Ch
.text$mn:00005FA9                 idiv    ecx
.text$mn:00005FAB                 mov     esp, ebp
.text$mn:00005FAD                 pop     ebp
.text$mn:00005FAE                 retn
.text$mn:00005FAE ?_Unused_capacity@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ endp
.text$mn:00005FAE
.text$mn:00005FAE ; ---------------------------------------------------------------------------
.text$mn:00005FAF                 align 10h
.text$mn:00005FAF _text$mn        ends
.text$mn:00005FAF
.text$mn:00005FB0 ; ===========================================================================
.text$mn:00005FB0
.text$mn:00005FB0 ; Segment type: Pure code
.text$mn:00005FB0 ; Segment permissions: Read/Execute
.text$mn:00005FB0 _text$mn        segment para public 'CODE' use32
.text$mn:00005FB0                 assume cs:_text$mn
.text$mn:00005FB0                 ;org 5FB0h
.text$mn:00005FB0 ; COMDAT (pick any)
.text$mn:00005FB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005FB0
.text$mn:00005FB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005FB0
.text$mn:00005FB0 ; Attributes: bp-based frame
.text$mn:00005FB0
.text$mn:00005FB0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00005FB0                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00005FB0 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00005FB0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00005FB0
.text$mn:00005FB0 var_4           = dword ptr -4
.text$mn:00005FB0
.text$mn:00005FB0                 push    ebp
.text$mn:00005FB1                 mov     ebp, esp
.text$mn:00005FB3                 push    ecx
.text$mn:00005FB4                 mov     [ebp+var_4], ecx
.text$mn:00005FB7                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00005FBC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00005FC1                 mov     esp, ebp
.text$mn:00005FC3                 pop     ebp
.text$mn:00005FC4                 retn
.text$mn:00005FC4 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00005FC4
.text$mn:00005FC4 ; ---------------------------------------------------------------------------
.text$mn:00005FC5                 align 4
.text$mn:00005FC5 _text$mn        ends
.text$mn:00005FC5
.text$mn:00005FC8 ; ===========================================================================
.text$mn:00005FC8
.text$mn:00005FC8 ; Segment type: Pure code
.text$mn:00005FC8 ; Segment permissions: Read/Execute
.text$mn:00005FC8 _text$mn        segment para public 'CODE' use32
.text$mn:00005FC8                 assume cs:_text$mn
.text$mn:00005FC8                 ;org 5FC8h
.text$mn:00005FC8 ; COMDAT (pick any)
.text$mn:00005FC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005FC8
.text$mn:00005FC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005FC8
.text$mn:00005FC8 ; Attributes: bp-based frame
.text$mn:00005FC8
.text$mn:00005FC8 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:00005FC8                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00005FC8 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00005FC8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:00005FC8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Dp ...
.text$mn:00005FC8
.text$mn:00005FC8 var_4           = dword ptr -4
.text$mn:00005FC8
.text$mn:00005FC8                 push    ebp
.text$mn:00005FC9                 mov     ebp, esp
.text$mn:00005FCB                 push    ecx
.text$mn:00005FCC                 mov     [ebp+var_4], ecx
.text$mn:00005FCF                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00005FD4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00005FD9                 mov     esp, ebp
.text$mn:00005FDB                 pop     ebp
.text$mn:00005FDC                 retn
.text$mn:00005FDC ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00005FDC
.text$mn:00005FDC ; ---------------------------------------------------------------------------
.text$mn:00005FDD                 align 10h
.text$mn:00005FDD _text$mn        ends
.text$mn:00005FDD
.text$mn:00005FE0 ; ===========================================================================
.text$mn:00005FE0
.text$mn:00005FE0 ; Segment type: Pure code
.text$mn:00005FE0 ; Segment permissions: Read/Execute
.text$mn:00005FE0 _text$mn        segment para public 'CODE' use32
.text$mn:00005FE0                 assume cs:_text$mn
.text$mn:00005FE0                 ;org 5FE0h
.text$mn:00005FE0 ; COMDAT (pick any)
.text$mn:00005FE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005FE0
.text$mn:00005FE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005FE0
.text$mn:00005FE0 ; Attributes: bp-based frame
.text$mn:00005FE0
.text$mn:00005FE0 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Xlen(void)const
.text$mn:00005FE0                 public ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
.text$mn:00005FE0 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ proc near
.text$mn:00005FE0                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reserve(uint)+31p
.text$mn:00005FE0
.text$mn:00005FE0 var_4           = dword ptr -4
.text$mn:00005FE0
.text$mn:00005FE0                 push    ebp
.text$mn:00005FE1                 mov     ebp, esp
.text$mn:00005FE3                 push    ecx
.text$mn:00005FE4                 mov     [ebp+var_4], ecx
.text$mn:00005FE7                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00005FEC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00005FF1                 mov     esp, ebp
.text$mn:00005FF3                 pop     ebp
.text$mn:00005FF4                 retn
.text$mn:00005FF4 ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ endp
.text$mn:00005FF4
.text$mn:00005FF4 ; ---------------------------------------------------------------------------
.text$mn:00005FF5                 align 4
.text$mn:00005FF5 _text$mn        ends
.text$mn:00005FF5
.text$mn:00005FF8 ; ===========================================================================
.text$mn:00005FF8
.text$mn:00005FF8 ; Segment type: Pure code
.text$mn:00005FF8 ; Segment permissions: Read/Execute
.text$mn:00005FF8 _text$mn        segment para public 'CODE' use32
.text$mn:00005FF8                 assume cs:_text$mn
.text$mn:00005FF8                 ;org 5FF8h
.text$mn:00005FF8 ; COMDAT (pick any)
.text$mn:00005FF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005FF8
.text$mn:00005FF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005FF8
.text$mn:00005FF8 ; Attributes: bp-based frame
.text$mn:00005FF8
.text$mn:00005FF8 ; protected: void __thiscall std::vector<struct iconLocator, class std::allocator<struct iconLocator>>::_Xlen(void)const
.text$mn:00005FF8                 public ?_Xlen@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXXZ
.text$mn:00005FF8 ?_Xlen@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXXZ proc near
.text$mn:00005FF8                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Reserve(uint)+31p
.text$mn:00005FF8
.text$mn:00005FF8 var_4           = dword ptr -4
.text$mn:00005FF8
.text$mn:00005FF8                 push    ebp
.text$mn:00005FF9                 mov     ebp, esp
.text$mn:00005FFB                 push    ecx
.text$mn:00005FFC                 mov     [ebp+var_4], ecx
.text$mn:00005FFF                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00006004                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00006009                 mov     esp, ebp
.text$mn:0000600B                 pop     ebp
.text$mn:0000600C                 retn
.text$mn:0000600C ?_Xlen@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXXZ endp
.text$mn:0000600C
.text$mn:0000600C ; ---------------------------------------------------------------------------
.text$mn:0000600D                 align 10h
.text$mn:0000600D _text$mn        ends
.text$mn:0000600D
.text$mn:00006010 ; ===========================================================================
.text$mn:00006010
.text$mn:00006010 ; Segment type: Pure code
.text$mn:00006010 ; Segment permissions: Read/Execute
.text$mn:00006010 _text$mn        segment para public 'CODE' use32
.text$mn:00006010                 assume cs:_text$mn
.text$mn:00006010                 ;org 6010h
.text$mn:00006010 ; COMDAT (pick any)
.text$mn:00006010                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006010
.text$mn:00006010 ; =============== S U B R O U T I N E =======================================
.text$mn:00006010
.text$mn:00006010 ; Attributes: bp-based frame
.text$mn:00006010
.text$mn:00006010 ; protected: void __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::_Xlen(void)const
.text$mn:00006010                 public ?_Xlen@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXXZ
.text$mn:00006010 ?_Xlen@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXXZ proc near
.text$mn:00006010                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reserve(uint)+31p
.text$mn:00006010
.text$mn:00006010 var_4           = dword ptr -4
.text$mn:00006010
.text$mn:00006010                 push    ebp
.text$mn:00006011                 mov     ebp, esp
.text$mn:00006013                 push    ecx
.text$mn:00006014                 mov     [ebp+var_4], ecx
.text$mn:00006017                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:0000601C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00006021                 mov     esp, ebp
.text$mn:00006023                 pop     ebp
.text$mn:00006024                 retn
.text$mn:00006024 ?_Xlen@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXXZ endp
.text$mn:00006024
.text$mn:00006024 ; ---------------------------------------------------------------------------
.text$mn:00006025                 align 4
.text$mn:00006025 _text$mn        ends
.text$mn:00006025
.text$mn:00006028 ; ===========================================================================
.text$mn:00006028
.text$mn:00006028 ; Segment type: Pure code
.text$mn:00006028 ; Segment permissions: Read/Execute
.text$mn:00006028 _text$mn        segment para public 'CODE' use32
.text$mn:00006028                 assume cs:_text$mn
.text$mn:00006028                 ;org 6028h
.text$mn:00006028 ; COMDAT (pick any)
.text$mn:00006028                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006028
.text$mn:00006028 ; =============== S U B R O U T I N E =======================================
.text$mn:00006028
.text$mn:00006028 ; Attributes: bp-based frame
.text$mn:00006028
.text$mn:00006028 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00006028                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00006028 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00006028                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00006028                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00006028
.text$mn:00006028 var_4           = dword ptr -4
.text$mn:00006028
.text$mn:00006028                 push    ebp
.text$mn:00006029                 mov     ebp, esp
.text$mn:0000602B                 push    ecx
.text$mn:0000602C                 mov     [ebp+var_4], ecx
.text$mn:0000602F                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00006034                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00006039                 mov     esp, ebp
.text$mn:0000603B                 pop     ebp
.text$mn:0000603C                 retn
.text$mn:0000603C ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000603C
.text$mn:0000603C ; ---------------------------------------------------------------------------
.text$mn:0000603D                 align 10h
.text$mn:0000603D _text$mn        ends
.text$mn:0000603D
.text$mn:00006040 ; ===========================================================================
.text$mn:00006040
.text$mn:00006040 ; Segment type: Pure code
.text$mn:00006040 ; Segment permissions: Read/Execute
.text$mn:00006040 _text$mn        segment para public 'CODE' use32
.text$mn:00006040                 assume cs:_text$mn
.text$mn:00006040                 ;org 6040h
.text$mn:00006040 ; COMDAT (pick any)
.text$mn:00006040                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006040
.text$mn:00006040 ; =============== S U B R O U T I N E =======================================
.text$mn:00006040
.text$mn:00006040 ; Attributes: bp-based frame
.text$mn:00006040
.text$mn:00006040 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:00006040                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00006040 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00006040                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:00006040                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p ...
.text$mn:00006040
.text$mn:00006040 var_4           = dword ptr -4
.text$mn:00006040
.text$mn:00006040                 push    ebp
.text$mn:00006041                 mov     ebp, esp
.text$mn:00006043                 push    ecx
.text$mn:00006044                 mov     [ebp+var_4], ecx
.text$mn:00006047                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:0000604C                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00006051                 mov     esp, ebp
.text$mn:00006053                 pop     ebp
.text$mn:00006054                 retn
.text$mn:00006054 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00006054
.text$mn:00006054 ; ---------------------------------------------------------------------------
.text$mn:00006055                 align 4
.text$mn:00006055 _text$mn        ends
.text$mn:00006055
.text$mn:00006058 ; ===========================================================================
.text$mn:00006058
.text$mn:00006058 ; Segment type: Pure code
.text$mn:00006058 ; Segment permissions: Read/Execute
.text$mn:00006058 _text$mn        segment para public 'CODE' use32
.text$mn:00006058                 assume cs:_text$mn
.text$mn:00006058                 ;org 6058h
.text$mn:00006058 ; COMDAT (pick any)
.text$mn:00006058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006058
.text$mn:00006058 ; =============== S U B R O U T I N E =======================================
.text$mn:00006058
.text$mn:00006058 ; Attributes: bp-based frame
.text$mn:00006058
.text$mn:00006058 ; protected: void __thiscall std::vector<int, class std::allocator<int>>::_Xran(void)const
.text$mn:00006058                 public ?_Xran@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ
.text$mn:00006058 ?_Xran@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ proc near
.text$mn:00006058                                         ; CODE XREF: std::vector<int,std::allocator<int>>::at(uint)+17p
.text$mn:00006058
.text$mn:00006058 var_4           = dword ptr -4
.text$mn:00006058
.text$mn:00006058                 push    ebp
.text$mn:00006059                 mov     ebp, esp
.text$mn:0000605B                 push    ecx
.text$mn:0000605C                 mov     [ebp+var_4], ecx
.text$mn:0000605F                 push    offset ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; "invalid vector<T> subscript"
.text$mn:00006064                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00006069                 mov     esp, ebp
.text$mn:0000606B                 pop     ebp
.text$mn:0000606C                 retn
.text$mn:0000606C ?_Xran@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ endp
.text$mn:0000606C
.text$mn:0000606C ; ---------------------------------------------------------------------------
.text$mn:0000606D                 align 10h
.text$mn:0000606D _text$mn        ends
.text$mn:0000606D
.text$mn:00006070 ; ===========================================================================
.text$mn:00006070
.text$mn:00006070 ; Segment type: Pure code
.text$mn:00006070 ; Segment permissions: Read/Execute
.text$mn:00006070 _text$mn        segment para public 'CODE' use32
.text$mn:00006070                 assume cs:_text$mn
.text$mn:00006070                 ;org 6070h
.text$mn:00006070 ; COMDAT (pick any)
.text$mn:00006070                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006070
.text$mn:00006070 ; =============== S U B R O U T I N E =======================================
.text$mn:00006070
.text$mn:00006070 ; Attributes: bp-based frame
.text$mn:00006070
.text$mn:00006070 ; protected: void __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::_Xran(void)const
.text$mn:00006070                 public ?_Xran@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXXZ
.text$mn:00006070 ?_Xran@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXXZ proc near
.text$mn:00006070                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::at(uint)+17p
.text$mn:00006070
.text$mn:00006070 var_4           = dword ptr -4
.text$mn:00006070
.text$mn:00006070                 push    ebp
.text$mn:00006071                 mov     ebp, esp
.text$mn:00006073                 push    ecx
.text$mn:00006074                 mov     [ebp+var_4], ecx
.text$mn:00006077                 push    offset ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; "invalid vector<T> subscript"
.text$mn:0000607C                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00006081                 mov     esp, ebp
.text$mn:00006083                 pop     ebp
.text$mn:00006084                 retn
.text$mn:00006084 ?_Xran@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXXZ endp
.text$mn:00006084
.text$mn:00006084 ; ---------------------------------------------------------------------------
.text$mn:00006085                 align 4
.text$mn:00006085 _text$mn        ends
.text$mn:00006085
.text$mn:00006088 ; ===========================================================================
.text$mn:00006088
.text$mn:00006088 ; Segment type: Pure code
.text$mn:00006088 ; Segment permissions: Read/Execute
.text$mn:00006088 _text$mn        segment para public 'CODE' use32
.text$mn:00006088                 assume cs:_text$mn
.text$mn:00006088                 ;org 6088h
.text$mn:00006088 ; COMDAT (pick any)
.text$mn:00006088                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006088
.text$mn:00006088 ; =============== S U B R O U T I N E =======================================
.text$mn:00006088
.text$mn:00006088 ; Attributes: bp-based frame
.text$mn:00006088
.text$mn:00006088 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00006088                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00006088 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00006088                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00006088                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00006088
.text$mn:00006088 var_4           = dword ptr -4
.text$mn:00006088 arg_0           = dword ptr  8
.text$mn:00006088
.text$mn:00006088                 push    ebp
.text$mn:00006089                 mov     ebp, esp
.text$mn:0000608B                 push    ecx
.text$mn:0000608C                 mov     [ebp+var_4], ecx
.text$mn:0000608F                 mov     eax, [ebp+arg_0]
.text$mn:00006092                 push    eax
.text$mn:00006093                 mov     ecx, [ebp+var_4]
.text$mn:00006096                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000609B                 mov     esp, ebp
.text$mn:0000609D                 pop     ebp
.text$mn:0000609E                 retn    4
.text$mn:0000609E ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:0000609E
.text$mn:0000609E ; ---------------------------------------------------------------------------
.text$mn:000060A1                 align 4
.text$mn:000060A1 _text$mn        ends
.text$mn:000060A1
.text$mn:000060A4 ; ===========================================================================
.text$mn:000060A4
.text$mn:000060A4 ; Segment type: Pure code
.text$mn:000060A4 ; Segment permissions: Read/Execute
.text$mn:000060A4 _text$mn        segment para public 'CODE' use32
.text$mn:000060A4                 assume cs:_text$mn
.text$mn:000060A4                 ;org 60A4h
.text$mn:000060A4 ; COMDAT (pick any)
.text$mn:000060A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000060A4
.text$mn:000060A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000060A4
.text$mn:000060A4 ; Attributes: bp-based frame
.text$mn:000060A4
.text$mn:000060A4 ; public: int * __thiscall std::_Wrap_alloc<class std::allocator<int>>::allocate(unsigned int)
.text$mn:000060A4                 public ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z
.text$mn:000060A4 ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z proc near
.text$mn:000060A4                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Reallocate(uint)+41p
.text$mn:000060A4
.text$mn:000060A4 var_4           = dword ptr -4
.text$mn:000060A4 arg_0           = dword ptr  8
.text$mn:000060A4
.text$mn:000060A4                 push    ebp
.text$mn:000060A5                 mov     ebp, esp
.text$mn:000060A7                 push    ecx
.text$mn:000060A8                 mov     [ebp+var_4], ecx
.text$mn:000060AB                 mov     eax, [ebp+arg_0]
.text$mn:000060AE                 push    eax
.text$mn:000060AF                 mov     ecx, [ebp+var_4]
.text$mn:000060B2                 call    ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate(uint)
.text$mn:000060B7                 mov     esp, ebp
.text$mn:000060B9                 pop     ebp
.text$mn:000060BA                 retn    4
.text$mn:000060BA ?allocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEPAHI@Z endp
.text$mn:000060BA
.text$mn:000060BA ; ---------------------------------------------------------------------------
.text$mn:000060BD                 align 10h
.text$mn:000060BD _text$mn        ends
.text$mn:000060BD
.text$mn:000060C0 ; ===========================================================================
.text$mn:000060C0
.text$mn:000060C0 ; Segment type: Pure code
.text$mn:000060C0 ; Segment permissions: Read/Execute
.text$mn:000060C0 _text$mn        segment para public 'CODE' use32
.text$mn:000060C0                 assume cs:_text$mn
.text$mn:000060C0                 ;org 60C0h
.text$mn:000060C0 ; COMDAT (pick any)
.text$mn:000060C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000060C0
.text$mn:000060C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000060C0
.text$mn:000060C0 ; Attributes: bp-based frame
.text$mn:000060C0
.text$mn:000060C0 ; public: struct iconLocator * __thiscall std::_Wrap_alloc<class std::allocator<struct iconLocator>>::allocate(unsigned int)
.text$mn:000060C0                 public ?allocate@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEPAUiconLocator@@I@Z
.text$mn:000060C0 ?allocate@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEPAUiconLocator@@I@Z proc near
.text$mn:000060C0                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Reallocate(uint)+41p
.text$mn:000060C0
.text$mn:000060C0 var_4           = dword ptr -4
.text$mn:000060C0 arg_0           = dword ptr  8
.text$mn:000060C0
.text$mn:000060C0                 push    ebp
.text$mn:000060C1                 mov     ebp, esp
.text$mn:000060C3                 push    ecx
.text$mn:000060C4                 mov     [ebp+var_4], ecx
.text$mn:000060C7                 mov     eax, [ebp+arg_0]
.text$mn:000060CA                 push    eax
.text$mn:000060CB                 mov     ecx, [ebp+var_4]
.text$mn:000060CE                 call    ?allocate@?$allocator@UiconLocator@@@std@@QAEPAUiconLocator@@I@Z ; std::allocator<iconLocator>::allocate(uint)
.text$mn:000060D3                 mov     esp, ebp
.text$mn:000060D5                 pop     ebp
.text$mn:000060D6                 retn    4
.text$mn:000060D6 ?allocate@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEPAUiconLocator@@I@Z endp
.text$mn:000060D6
.text$mn:000060D6 ; ---------------------------------------------------------------------------
.text$mn:000060D9                 align 4
.text$mn:000060D9 _text$mn        ends
.text$mn:000060D9
.text$mn:000060DC ; ===========================================================================
.text$mn:000060DC
.text$mn:000060DC ; Segment type: Pure code
.text$mn:000060DC ; Segment permissions: Read/Execute
.text$mn:000060DC _text$mn        segment para public 'CODE' use32
.text$mn:000060DC                 assume cs:_text$mn
.text$mn:000060DC                 ;org 60DCh
.text$mn:000060DC ; COMDAT (pick any)
.text$mn:000060DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000060DC
.text$mn:000060DC ; =============== S U B R O U T I N E =======================================
.text$mn:000060DC
.text$mn:000060DC ; Attributes: bp-based frame
.text$mn:000060DC
.text$mn:000060DC ; public: struct tDynamicList * __thiscall std::_Wrap_alloc<class std::allocator<struct tDynamicList>>::allocate(unsigned int)
.text$mn:000060DC                 public ?allocate@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEPAUtDynamicList@@I@Z
.text$mn:000060DC ?allocate@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEPAUtDynamicList@@I@Z proc near
.text$mn:000060DC                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reallocate(uint)+41p
.text$mn:000060DC
.text$mn:000060DC var_4           = dword ptr -4
.text$mn:000060DC arg_0           = dword ptr  8
.text$mn:000060DC
.text$mn:000060DC                 push    ebp
.text$mn:000060DD                 mov     ebp, esp
.text$mn:000060DF                 push    ecx
.text$mn:000060E0                 mov     [ebp+var_4], ecx
.text$mn:000060E3                 mov     eax, [ebp+arg_0]
.text$mn:000060E6                 push    eax
.text$mn:000060E7                 mov     ecx, [ebp+var_4]
.text$mn:000060EA                 call    ?allocate@?$allocator@UtDynamicList@@@std@@QAEPAUtDynamicList@@I@Z ; std::allocator<tDynamicList>::allocate(uint)
.text$mn:000060EF                 mov     esp, ebp
.text$mn:000060F1                 pop     ebp
.text$mn:000060F2                 retn    4
.text$mn:000060F2 ?allocate@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEPAUtDynamicList@@I@Z endp
.text$mn:000060F2
.text$mn:000060F2 ; ---------------------------------------------------------------------------
.text$mn:000060F5                 align 4
.text$mn:000060F5 _text$mn        ends
.text$mn:000060F5
.text$mn:000060F8 ; ===========================================================================
.text$mn:000060F8
.text$mn:000060F8 ; Segment type: Pure code
.text$mn:000060F8 ; Segment permissions: Read/Execute
.text$mn:000060F8 _text$mn        segment para public 'CODE' use32
.text$mn:000060F8                 assume cs:_text$mn
.text$mn:000060F8                 ;org 60F8h
.text$mn:000060F8 ; COMDAT (pick any)
.text$mn:000060F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000060F8
.text$mn:000060F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000060F8
.text$mn:000060F8 ; Attributes: bp-based frame
.text$mn:000060F8
.text$mn:000060F8 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:000060F8                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:000060F8 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:000060F8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:000060F8                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:000060F8
.text$mn:000060F8 var_4           = dword ptr -4
.text$mn:000060F8 arg_0           = dword ptr  8
.text$mn:000060F8
.text$mn:000060F8                 push    ebp
.text$mn:000060F9                 mov     ebp, esp
.text$mn:000060FB                 push    ecx
.text$mn:000060FC                 mov     [ebp+var_4], ecx
.text$mn:000060FF                 mov     eax, [ebp+arg_0]
.text$mn:00006102                 push    eax
.text$mn:00006103                 mov     ecx, [ebp+var_4]
.text$mn:00006106                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:0000610B                 mov     esp, ebp
.text$mn:0000610D                 pop     ebp
.text$mn:0000610E                 retn    4
.text$mn:0000610E ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:0000610E
.text$mn:0000610E ; ---------------------------------------------------------------------------
.text$mn:00006111                 align 4
.text$mn:00006111 _text$mn        ends
.text$mn:00006111
.text$mn:00006114 ; ===========================================================================
.text$mn:00006114
.text$mn:00006114 ; Segment type: Pure code
.text$mn:00006114 ; Segment permissions: Read/Execute
.text$mn:00006114 _text$mn        segment para public 'CODE' use32
.text$mn:00006114                 assume cs:_text$mn
.text$mn:00006114                 ;org 6114h
.text$mn:00006114 ; COMDAT (pick any)
.text$mn:00006114                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006114
.text$mn:00006114 ; =============== S U B R O U T I N E =======================================
.text$mn:00006114
.text$mn:00006114 ; Attributes: bp-based frame
.text$mn:00006114
.text$mn:00006114 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00006114                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00006114 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00006114                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00006114
.text$mn:00006114 var_4           = dword ptr -4
.text$mn:00006114 arg_0           = dword ptr  8
.text$mn:00006114
.text$mn:00006114                 push    ebp
.text$mn:00006115                 mov     ebp, esp
.text$mn:00006117                 push    ecx
.text$mn:00006118                 mov     [ebp+var_4], ecx
.text$mn:0000611B                 push    0
.text$mn:0000611D                 mov     eax, [ebp+arg_0]
.text$mn:00006120                 push    eax
.text$mn:00006121                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00006126                 add     esp, 8
.text$mn:00006129                 mov     esp, ebp
.text$mn:0000612B                 pop     ebp
.text$mn:0000612C                 retn    4
.text$mn:0000612C ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:0000612C
.text$mn:0000612C ; ---------------------------------------------------------------------------
.text$mn:0000612F                 align 10h
.text$mn:0000612F _text$mn        ends
.text$mn:0000612F
.text$mn:00006130 ; ===========================================================================
.text$mn:00006130
.text$mn:00006130 ; Segment type: Pure code
.text$mn:00006130 ; Segment permissions: Read/Execute
.text$mn:00006130 _text$mn        segment para public 'CODE' use32
.text$mn:00006130                 assume cs:_text$mn
.text$mn:00006130                 ;org 6130h
.text$mn:00006130 ; COMDAT (pick any)
.text$mn:00006130                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006130
.text$mn:00006130 ; =============== S U B R O U T I N E =======================================
.text$mn:00006130
.text$mn:00006130 ; Attributes: bp-based frame
.text$mn:00006130
.text$mn:00006130 ; public: int * __thiscall std::allocator<int>::allocate(unsigned int)
.text$mn:00006130                 public ?allocate@?$allocator@H@std@@QAEPAHI@Z
.text$mn:00006130 ?allocate@?$allocator@H@std@@QAEPAHI@Z proc near
.text$mn:00006130                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::allocate(uint)+Ep
.text$mn:00006130
.text$mn:00006130 var_4           = dword ptr -4
.text$mn:00006130 arg_0           = dword ptr  8
.text$mn:00006130
.text$mn:00006130                 push    ebp
.text$mn:00006131                 mov     ebp, esp
.text$mn:00006133                 push    ecx
.text$mn:00006134                 mov     [ebp+var_4], ecx
.text$mn:00006137                 push    0
.text$mn:00006139                 mov     eax, [ebp+arg_0]
.text$mn:0000613C                 push    eax
.text$mn:0000613D                 call    ??$_Allocate@H@std@@YAPAHIPAH@Z ; std::_Allocate<int>(uint,int *)
.text$mn:00006142                 add     esp, 8
.text$mn:00006145                 mov     esp, ebp
.text$mn:00006147                 pop     ebp
.text$mn:00006148                 retn    4
.text$mn:00006148 ?allocate@?$allocator@H@std@@QAEPAHI@Z endp
.text$mn:00006148
.text$mn:00006148 ; ---------------------------------------------------------------------------
.text$mn:0000614B                 align 4
.text$mn:0000614B _text$mn        ends
.text$mn:0000614B
.text$mn:0000614C ; ===========================================================================
.text$mn:0000614C
.text$mn:0000614C ; Segment type: Pure code
.text$mn:0000614C ; Segment permissions: Read/Execute
.text$mn:0000614C _text$mn        segment para public 'CODE' use32
.text$mn:0000614C                 assume cs:_text$mn
.text$mn:0000614C                 ;org 614Ch
.text$mn:0000614C ; COMDAT (pick any)
.text$mn:0000614C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000614C
.text$mn:0000614C ; =============== S U B R O U T I N E =======================================
.text$mn:0000614C
.text$mn:0000614C ; Attributes: bp-based frame
.text$mn:0000614C
.text$mn:0000614C ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:0000614C                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:0000614C ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:0000614C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:0000614C                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p
.text$mn:0000614C
.text$mn:0000614C var_4           = dword ptr -4
.text$mn:0000614C arg_0           = dword ptr  8
.text$mn:0000614C
.text$mn:0000614C                 push    ebp
.text$mn:0000614D                 mov     ebp, esp
.text$mn:0000614F                 push    ecx
.text$mn:00006150                 mov     [ebp+var_4], ecx
.text$mn:00006153                 push    0
.text$mn:00006155                 mov     eax, [ebp+arg_0]
.text$mn:00006158                 push    eax
.text$mn:00006159                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000615E                 add     esp, 8
.text$mn:00006161                 mov     esp, ebp
.text$mn:00006163                 pop     ebp
.text$mn:00006164                 retn    4
.text$mn:00006164 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00006164
.text$mn:00006164 ; ---------------------------------------------------------------------------
.text$mn:00006167                 align 4
.text$mn:00006167 _text$mn        ends
.text$mn:00006167
.text$mn:00006168 ; ===========================================================================
.text$mn:00006168
.text$mn:00006168 ; Segment type: Pure code
.text$mn:00006168 ; Segment permissions: Read/Execute
.text$mn:00006168 _text$mn        segment para public 'CODE' use32
.text$mn:00006168                 assume cs:_text$mn
.text$mn:00006168                 ;org 6168h
.text$mn:00006168 ; COMDAT (pick any)
.text$mn:00006168                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006168
.text$mn:00006168 ; =============== S U B R O U T I N E =======================================
.text$mn:00006168
.text$mn:00006168 ; Attributes: bp-based frame
.text$mn:00006168
.text$mn:00006168 ; public: struct iconLocator * __thiscall std::allocator<struct iconLocator>::allocate(unsigned int)
.text$mn:00006168                 public ?allocate@?$allocator@UiconLocator@@@std@@QAEPAUiconLocator@@I@Z
.text$mn:00006168 ?allocate@?$allocator@UiconLocator@@@std@@QAEPAUiconLocator@@I@Z proc near
.text$mn:00006168                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<iconLocator>>::allocate(uint)+Ep
.text$mn:00006168
.text$mn:00006168 var_4           = dword ptr -4
.text$mn:00006168 arg_0           = dword ptr  8
.text$mn:00006168
.text$mn:00006168                 push    ebp
.text$mn:00006169                 mov     ebp, esp
.text$mn:0000616B                 push    ecx
.text$mn:0000616C                 mov     [ebp+var_4], ecx
.text$mn:0000616F                 push    0
.text$mn:00006171                 mov     eax, [ebp+arg_0]
.text$mn:00006174                 push    eax
.text$mn:00006175                 call    ??$_Allocate@UiconLocator@@@std@@YAPAUiconLocator@@IPAU1@@Z ; std::_Allocate<iconLocator>(uint,iconLocator *)
.text$mn:0000617A                 add     esp, 8
.text$mn:0000617D                 mov     esp, ebp
.text$mn:0000617F                 pop     ebp
.text$mn:00006180                 retn    4
.text$mn:00006180 ?allocate@?$allocator@UiconLocator@@@std@@QAEPAUiconLocator@@I@Z endp
.text$mn:00006180
.text$mn:00006180 ; ---------------------------------------------------------------------------
.text$mn:00006183                 align 4
.text$mn:00006183 _text$mn        ends
.text$mn:00006183
.text$mn:00006184 ; ===========================================================================
.text$mn:00006184
.text$mn:00006184 ; Segment type: Pure code
.text$mn:00006184 ; Segment permissions: Read/Execute
.text$mn:00006184 _text$mn        segment para public 'CODE' use32
.text$mn:00006184                 assume cs:_text$mn
.text$mn:00006184                 ;org 6184h
.text$mn:00006184 ; COMDAT (pick any)
.text$mn:00006184                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006184
.text$mn:00006184 ; =============== S U B R O U T I N E =======================================
.text$mn:00006184
.text$mn:00006184 ; Attributes: bp-based frame
.text$mn:00006184
.text$mn:00006184 ; public: struct tDynamicList * __thiscall std::allocator<struct tDynamicList>::allocate(unsigned int)
.text$mn:00006184                 public ?allocate@?$allocator@UtDynamicList@@@std@@QAEPAUtDynamicList@@I@Z
.text$mn:00006184 ?allocate@?$allocator@UtDynamicList@@@std@@QAEPAUtDynamicList@@I@Z proc near
.text$mn:00006184                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tDynamicList>>::allocate(uint)+Ep
.text$mn:00006184
.text$mn:00006184 var_4           = dword ptr -4
.text$mn:00006184 arg_0           = dword ptr  8
.text$mn:00006184
.text$mn:00006184                 push    ebp
.text$mn:00006185                 mov     ebp, esp
.text$mn:00006187                 push    ecx
.text$mn:00006188                 mov     [ebp+var_4], ecx
.text$mn:0000618B                 push    0
.text$mn:0000618D                 mov     eax, [ebp+arg_0]
.text$mn:00006190                 push    eax
.text$mn:00006191                 call    ??$_Allocate@UtDynamicList@@@std@@YAPAUtDynamicList@@IPAU1@@Z ; std::_Allocate<tDynamicList>(uint,tDynamicList *)
.text$mn:00006196                 add     esp, 8
.text$mn:00006199                 mov     esp, ebp
.text$mn:0000619B                 pop     ebp
.text$mn:0000619C                 retn    4
.text$mn:0000619C ?allocate@?$allocator@UtDynamicList@@@std@@QAEPAUtDynamicList@@I@Z endp
.text$mn:0000619C
.text$mn:0000619C ; ---------------------------------------------------------------------------
.text$mn:0000619F                 align 10h
.text$mn:0000619F _text$mn        ends
.text$mn:0000619F
.text$mn:000061A0 ; ===========================================================================
.text$mn:000061A0
.text$mn:000061A0 ; Segment type: Pure code
.text$mn:000061A0 ; Segment permissions: Read/Execute
.text$mn:000061A0 _text$mn        segment para public 'CODE' use32
.text$mn:000061A0                 assume cs:_text$mn
.text$mn:000061A0                 ;org 61A0h
.text$mn:000061A0 ; COMDAT (pick any)
.text$mn:000061A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000061A0
.text$mn:000061A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000061A0
.text$mn:000061A0 ; Attributes: bp-based frame
.text$mn:000061A0
.text$mn:000061A0 ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:000061A0                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:000061A0 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:000061A0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:000061A0
.text$mn:000061A0 var_4           = dword ptr -4
.text$mn:000061A0 arg_0           = dword ptr  8
.text$mn:000061A0
.text$mn:000061A0                 push    ebp
.text$mn:000061A1                 mov     ebp, esp
.text$mn:000061A3                 push    ecx
.text$mn:000061A4                 mov     [ebp+var_4], ecx
.text$mn:000061A7                 push    0
.text$mn:000061A9                 mov     eax, [ebp+arg_0]
.text$mn:000061AC                 push    eax
.text$mn:000061AD                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:000061B2                 add     esp, 8
.text$mn:000061B5                 mov     esp, ebp
.text$mn:000061B7                 pop     ebp
.text$mn:000061B8                 retn    4
.text$mn:000061B8 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:000061B8
.text$mn:000061B8 ; ---------------------------------------------------------------------------
.text$mn:000061BB                 align 4
.text$mn:000061BB _text$mn        ends
.text$mn:000061BB
.text$mn:000061BC ; ===========================================================================
.text$mn:000061BC
.text$mn:000061BC ; Segment type: Pure code
.text$mn:000061BC ; Segment permissions: Read/Execute
.text$mn:000061BC _text$mn        segment para public 'CODE' use32
.text$mn:000061BC                 assume cs:_text$mn
.text$mn:000061BC                 ;org 61BCh
.text$mn:000061BC ; COMDAT (pick any)
.text$mn:000061BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000061BC
.text$mn:000061BC ; =============== S U B R O U T I N E =======================================
.text$mn:000061BC
.text$mn:000061BC ; Attributes: bp-based frame
.text$mn:000061BC
.text$mn:000061BC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:000061BC                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:000061BC ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:000061BC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+53p
.text$mn:000061BC
.text$mn:000061BC var_8           = dword ptr -8
.text$mn:000061BC var_4           = dword ptr -4
.text$mn:000061BC arg_0           = dword ptr  8
.text$mn:000061BC arg_4           = dword ptr  0Ch
.text$mn:000061BC arg_8           = dword ptr  10h
.text$mn:000061BC
.text$mn:000061BC                 push    ebp
.text$mn:000061BD                 mov     ebp, esp
.text$mn:000061BF                 sub     esp, 8
.text$mn:000061C2                 mov     [ebp+var_4], ecx
.text$mn:000061C5                 mov     ecx, [ebp+arg_0]
.text$mn:000061C8                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:000061CD                 cmp     eax, [ebp+arg_4]
.text$mn:000061D0                 jnb     short loc_61DA
.text$mn:000061D2                 mov     ecx, [ebp+var_4]
.text$mn:000061D5                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:000061DA
.text$mn:000061DA loc_61DA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:000061DA                 mov     ecx, [ebp+arg_0]
.text$mn:000061DD                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:000061E2                 sub     eax, [ebp+arg_4]
.text$mn:000061E5                 mov     [ebp+var_8], eax
.text$mn:000061E8                 mov     eax, [ebp+var_8]
.text$mn:000061EB                 cmp     eax, [ebp+arg_8]
.text$mn:000061EE                 jnb     short loc_61F6
.text$mn:000061F0                 mov     ecx, [ebp+var_8]
.text$mn:000061F3                 mov     [ebp+arg_8], ecx
.text$mn:000061F6
.text$mn:000061F6 loc_61F6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:000061F6                 mov     edx, [ebp+var_4]
.text$mn:000061F9                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:000061FE                 sub     eax, [edx+14h]
.text$mn:00006201                 cmp     eax, [ebp+arg_8]
.text$mn:00006204                 ja      short loc_620E
.text$mn:00006206                 mov     ecx, [ebp+var_4]
.text$mn:00006209                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000620E
.text$mn:0000620E loc_620E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+48j
.text$mn:0000620E                 cmp     [ebp+arg_8], 0
.text$mn:00006212                 jbe     short loc_626E
.text$mn:00006214                 mov     ecx, [ebp+var_4]
.text$mn:00006217                 mov     edx, [ecx+14h]
.text$mn:0000621A                 add     edx, [ebp+arg_8]
.text$mn:0000621D                 mov     [ebp+var_8], edx
.text$mn:00006220                 push    0
.text$mn:00006222                 mov     eax, [ebp+var_8]
.text$mn:00006225                 push    eax
.text$mn:00006226                 mov     ecx, [ebp+var_4]
.text$mn:00006229                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000622E                 movzx   ecx, al
.text$mn:00006231                 test    ecx, ecx
.text$mn:00006233                 jz      short loc_626E
.text$mn:00006235                 mov     edx, [ebp+arg_8]
.text$mn:00006238                 push    edx             ; int
.text$mn:00006239                 mov     ecx, [ebp+arg_0]
.text$mn:0000623C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00006241                 mov     ecx, [ebp+arg_4]
.text$mn:00006244                 lea     edx, [eax+ecx*2]
.text$mn:00006247                 push    edx             ; Src
.text$mn:00006248                 mov     ecx, [ebp+var_4]
.text$mn:0000624B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00006250                 mov     ecx, [ebp+var_4]
.text$mn:00006253                 mov     edx, [ecx+14h]
.text$mn:00006256                 lea     eax, [eax+edx*2]
.text$mn:00006259                 push    eax             ; Dst
.text$mn:0000625A                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000625F                 add     esp, 0Ch
.text$mn:00006262                 mov     ecx, [ebp+var_8]
.text$mn:00006265                 push    ecx
.text$mn:00006266                 mov     ecx, [ebp+var_4]
.text$mn:00006269                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000626E
.text$mn:0000626E loc_626E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+56j
.text$mn:0000626E                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+77j
.text$mn:0000626E                 mov     eax, [ebp+var_4]
.text$mn:00006271                 mov     esp, ebp
.text$mn:00006273                 pop     ebp
.text$mn:00006274                 retn    0Ch
.text$mn:00006274 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00006274
.text$mn:00006274 ; ---------------------------------------------------------------------------
.text$mn:00006277                 align 4
.text$mn:00006277 _text$mn        ends
.text$mn:00006277
.text$mn:00006278 ; ===========================================================================
.text$mn:00006278
.text$mn:00006278 ; Segment type: Pure code
.text$mn:00006278 ; Segment permissions: Read/Execute
.text$mn:00006278 _text$mn        segment para public 'CODE' use32
.text$mn:00006278                 assume cs:_text$mn
.text$mn:00006278                 ;org 6278h
.text$mn:00006278 ; COMDAT (pick any)
.text$mn:00006278                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006278
.text$mn:00006278 ; =============== S U B R O U T I N E =======================================
.text$mn:00006278
.text$mn:00006278 ; Attributes: bp-based frame
.text$mn:00006278
.text$mn:00006278 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t *Str)
.text$mn:00006278                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:00006278 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:00006278                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)+Ep
.text$mn:00006278
.text$mn:00006278 var_4           = dword ptr -4
.text$mn:00006278 Str             = dword ptr  8
.text$mn:00006278
.text$mn:00006278                 push    ebp
.text$mn:00006279                 mov     ebp, esp
.text$mn:0000627B                 push    ecx
.text$mn:0000627C                 mov     [ebp+var_4], ecx
.text$mn:0000627F                 push    43Eh            ; unsigned int
.text$mn:00006284                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006289                 mov     eax, [ebp+Str]
.text$mn:0000628C                 push    eax             ; int
.text$mn:0000628D                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00006292                 add     esp, 0Ch
.text$mn:00006295                 mov     ecx, [ebp+Str]
.text$mn:00006298                 push    ecx             ; Str
.text$mn:00006299                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000629E                 add     esp, 4
.text$mn:000062A1                 push    eax             ; int
.text$mn:000062A2                 mov     edx, [ebp+Str]
.text$mn:000062A5                 push    edx             ; Src
.text$mn:000062A6                 mov     ecx, [ebp+var_4]
.text$mn:000062A9                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)
.text$mn:000062AE                 mov     esp, ebp
.text$mn:000062B0                 pop     ebp
.text$mn:000062B1                 retn    4
.text$mn:000062B1 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:000062B1
.text$mn:000062B1 _text$mn        ends
.text$mn:000062B1
.text$mn:000062B4 ; ===========================================================================
.text$mn:000062B4
.text$mn:000062B4 ; Segment type: Pure code
.text$mn:000062B4 ; Segment permissions: Read/Execute
.text$mn:000062B4 _text$mn        segment para public 'CODE' use32
.text$mn:000062B4                 assume cs:_text$mn
.text$mn:000062B4                 ;org 62B4h
.text$mn:000062B4 ; COMDAT (pick any)
.text$mn:000062B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000062B4
.text$mn:000062B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000062B4
.text$mn:000062B4 ; Attributes: bp-based frame
.text$mn:000062B4
.text$mn:000062B4 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(void *Src, int)
.text$mn:000062B4                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:000062B4 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:000062B4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+31p
.text$mn:000062B4
.text$mn:000062B4 var_8           = dword ptr -8
.text$mn:000062B4 var_4           = dword ptr -4
.text$mn:000062B4 Src             = dword ptr  8
.text$mn:000062B4 arg_4           = dword ptr  0Ch
.text$mn:000062B4
.text$mn:000062B4                 push    ebp
.text$mn:000062B5                 mov     ebp, esp
.text$mn:000062B7                 sub     esp, 8
.text$mn:000062BA                 mov     [ebp+var_4], ecx
.text$mn:000062BD                 cmp     [ebp+arg_4], 0
.text$mn:000062C1                 jz      short loc_62D9
.text$mn:000062C3                 push    42Ah            ; unsigned int
.text$mn:000062C8                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000062CD                 mov     eax, [ebp+Src]
.text$mn:000062D0                 push    eax             ; int
.text$mn:000062D1                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000062D6                 add     esp, 0Ch
.text$mn:000062D9
.text$mn:000062D9 loc_62D9:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+Dj
.text$mn:000062D9                 mov     ecx, [ebp+Src]
.text$mn:000062DC                 push    ecx
.text$mn:000062DD                 mov     ecx, [ebp+var_4]
.text$mn:000062E0                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:000062E5                 movzx   edx, al
.text$mn:000062E8                 test    edx, edx
.text$mn:000062EA                 jz      short loc_630E
.text$mn:000062EC                 mov     eax, [ebp+arg_4]
.text$mn:000062EF                 push    eax
.text$mn:000062F0                 mov     ecx, [ebp+var_4]
.text$mn:000062F3                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000062F8                 mov     ecx, [ebp+Src]
.text$mn:000062FB                 sub     ecx, eax
.text$mn:000062FD                 sar     ecx, 1
.text$mn:000062FF                 push    ecx
.text$mn:00006300                 mov     edx, [ebp+var_4]
.text$mn:00006303                 push    edx
.text$mn:00006304                 mov     ecx, [ebp+var_4]
.text$mn:00006307                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000630C                 jmp     short loc_637F
.text$mn:0000630E ; ---------------------------------------------------------------------------
.text$mn:0000630E
.text$mn:0000630E loc_630E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+36j
.text$mn:0000630E                 mov     eax, [ebp+var_4]
.text$mn:00006311                 mov     ecx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00006317                 sub     ecx, [eax+14h]
.text$mn:0000631A                 cmp     ecx, [ebp+arg_4]
.text$mn:0000631D                 ja      short loc_6327
.text$mn:0000631F                 mov     ecx, [ebp+var_4]
.text$mn:00006322                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00006327
.text$mn:00006327 loc_6327:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+69j
.text$mn:00006327                 cmp     [ebp+arg_4], 0
.text$mn:0000632B                 jbe     short loc_637C
.text$mn:0000632D                 mov     edx, [ebp+var_4]
.text$mn:00006330                 mov     eax, [edx+14h]
.text$mn:00006333                 add     eax, [ebp+arg_4]
.text$mn:00006336                 mov     [ebp+var_8], eax
.text$mn:00006339                 push    0
.text$mn:0000633B                 mov     ecx, [ebp+var_8]
.text$mn:0000633E                 push    ecx
.text$mn:0000633F                 mov     ecx, [ebp+var_4]
.text$mn:00006342                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00006347                 movzx   edx, al
.text$mn:0000634A                 test    edx, edx
.text$mn:0000634C                 jz      short loc_637C
.text$mn:0000634E                 mov     eax, [ebp+arg_4]
.text$mn:00006351                 push    eax             ; int
.text$mn:00006352                 mov     ecx, [ebp+Src]
.text$mn:00006355                 push    ecx             ; Src
.text$mn:00006356                 mov     ecx, [ebp+var_4]
.text$mn:00006359                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000635E                 mov     edx, [ebp+var_4]
.text$mn:00006361                 mov     ecx, [edx+14h]
.text$mn:00006364                 lea     edx, [eax+ecx*2]
.text$mn:00006367                 push    edx             ; Dst
.text$mn:00006368                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000636D                 add     esp, 0Ch
.text$mn:00006370                 mov     eax, [ebp+var_8]
.text$mn:00006373                 push    eax
.text$mn:00006374                 mov     ecx, [ebp+var_4]
.text$mn:00006377                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000637C
.text$mn:0000637C loc_637C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+77j
.text$mn:0000637C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+98j
.text$mn:0000637C                 mov     eax, [ebp+var_4]
.text$mn:0000637F
.text$mn:0000637F loc_637F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+58j
.text$mn:0000637F                 mov     esp, ebp
.text$mn:00006381                 pop     ebp
.text$mn:00006382                 retn    8
.text$mn:00006382 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:00006382
.text$mn:00006382 ; ---------------------------------------------------------------------------
.text$mn:00006385                 align 4
.text$mn:00006385 _text$mn        ends
.text$mn:00006385
.text$mn:00006388 ; ===========================================================================
.text$mn:00006388
.text$mn:00006388 ; Segment type: Pure code
.text$mn:00006388 ; Segment permissions: Read/Execute
.text$mn:00006388 _text$mn        segment para public 'CODE' use32
.text$mn:00006388                 assume cs:_text$mn
.text$mn:00006388                 ;org 6388h
.text$mn:00006388 ; COMDAT (pick any)
.text$mn:00006388                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006388
.text$mn:00006388 ; =============== S U B R O U T I N E =======================================
.text$mn:00006388
.text$mn:00006388 ; Attributes: bp-based frame
.text$mn:00006388
.text$mn:00006388 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00006388                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00006388 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00006388                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00006388
.text$mn:00006388 Size            = dword ptr -8
.text$mn:00006388 var_4           = dword ptr -4
.text$mn:00006388 arg_0           = dword ptr  8
.text$mn:00006388 arg_4           = dword ptr  0Ch
.text$mn:00006388 arg_8           = dword ptr  10h
.text$mn:00006388
.text$mn:00006388                 push    ebp
.text$mn:00006389                 mov     ebp, esp
.text$mn:0000638B                 sub     esp, 8
.text$mn:0000638E                 mov     [ebp+var_4], ecx
.text$mn:00006391                 mov     ecx, [ebp+arg_0]
.text$mn:00006394                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00006399                 cmp     eax, [ebp+arg_4]
.text$mn:0000639C                 jnb     short loc_63A6
.text$mn:0000639E                 mov     ecx, [ebp+var_4]
.text$mn:000063A1                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000063A6
.text$mn:000063A6 loc_63A6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:000063A6                 mov     ecx, [ebp+arg_0]
.text$mn:000063A9                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000063AE                 sub     eax, [ebp+arg_4]
.text$mn:000063B1                 mov     [ebp+Size], eax
.text$mn:000063B4                 mov     eax, [ebp+arg_8]
.text$mn:000063B7                 cmp     eax, [ebp+Size]
.text$mn:000063BA                 jnb     short loc_63C2
.text$mn:000063BC                 mov     ecx, [ebp+arg_8]
.text$mn:000063BF                 mov     [ebp+Size], ecx
.text$mn:000063C2
.text$mn:000063C2 loc_63C2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:000063C2                 mov     edx, [ebp+var_4]
.text$mn:000063C5                 cmp     edx, [ebp+arg_0]
.text$mn:000063C8                 jnz     short loc_63E9
.text$mn:000063CA                 mov     eax, [ebp+arg_4]
.text$mn:000063CD                 add     eax, [ebp+Size]
.text$mn:000063D0                 push    eax
.text$mn:000063D1                 mov     ecx, [ebp+var_4]
.text$mn:000063D4                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:000063D9                 mov     ecx, [ebp+arg_4]
.text$mn:000063DC                 push    ecx
.text$mn:000063DD                 push    0
.text$mn:000063DF                 mov     ecx, [ebp+var_4]
.text$mn:000063E2                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000063E7                 jmp     short loc_642B
.text$mn:000063E9 ; ---------------------------------------------------------------------------
.text$mn:000063E9
.text$mn:000063E9 loc_63E9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000063E9                 push    0
.text$mn:000063EB                 mov     edx, [ebp+Size]
.text$mn:000063EE                 push    edx
.text$mn:000063EF                 mov     ecx, [ebp+var_4]
.text$mn:000063F2                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000063F7                 movzx   eax, al
.text$mn:000063FA                 test    eax, eax
.text$mn:000063FC                 jz      short loc_642B
.text$mn:000063FE                 mov     ecx, [ebp+Size]
.text$mn:00006401                 push    ecx             ; Size
.text$mn:00006402                 mov     ecx, [ebp+arg_0]
.text$mn:00006405                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000640A                 add     eax, [ebp+arg_4]
.text$mn:0000640D                 push    eax             ; Src
.text$mn:0000640E                 mov     ecx, [ebp+var_4]
.text$mn:00006411                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006416                 push    eax             ; Dst
.text$mn:00006417                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000641C                 add     esp, 0Ch
.text$mn:0000641F                 mov     edx, [ebp+Size]
.text$mn:00006422                 push    edx
.text$mn:00006423                 mov     ecx, [ebp+var_4]
.text$mn:00006426                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000642B
.text$mn:0000642B loc_642B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:0000642B                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:0000642B                 mov     eax, [ebp+var_4]
.text$mn:0000642E                 mov     esp, ebp
.text$mn:00006430                 pop     ebp
.text$mn:00006431                 retn    0Ch
.text$mn:00006431 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00006431
.text$mn:00006431 _text$mn        ends
.text$mn:00006431
.text$mn:00006434 ; ===========================================================================
.text$mn:00006434
.text$mn:00006434 ; Segment type: Pure code
.text$mn:00006434 ; Segment permissions: Read/Execute
.text$mn:00006434 _text$mn        segment para public 'CODE' use32
.text$mn:00006434                 assume cs:_text$mn
.text$mn:00006434                 ;org 6434h
.text$mn:00006434 ; COMDAT (pick any)
.text$mn:00006434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006434
.text$mn:00006434 ; =============== S U B R O U T I N E =======================================
.text$mn:00006434
.text$mn:00006434 ; Attributes: bp-based frame
.text$mn:00006434
.text$mn:00006434 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00006434                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00006434 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00006434                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00006434
.text$mn:00006434 var_4           = dword ptr -4
.text$mn:00006434 Str             = dword ptr  8
.text$mn:00006434
.text$mn:00006434                 push    ebp
.text$mn:00006435                 mov     ebp, esp
.text$mn:00006437                 push    ecx
.text$mn:00006438                 mov     [ebp+var_4], ecx
.text$mn:0000643B                 push    490h            ; unsigned int
.text$mn:00006440                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006445                 mov     eax, [ebp+Str]
.text$mn:00006448                 push    eax             ; int
.text$mn:00006449                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000644E                 add     esp, 0Ch
.text$mn:00006451                 mov     ecx, [ebp+Str]
.text$mn:00006454                 push    ecx             ; Str
.text$mn:00006455                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:0000645A                 add     esp, 4
.text$mn:0000645D                 push    eax             ; Size
.text$mn:0000645E                 mov     edx, [ebp+Str]
.text$mn:00006461                 push    edx             ; Src
.text$mn:00006462                 mov     ecx, [ebp+var_4]
.text$mn:00006465                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:0000646A                 mov     esp, ebp
.text$mn:0000646C                 pop     ebp
.text$mn:0000646D                 retn    4
.text$mn:0000646D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:0000646D
.text$mn:0000646D _text$mn        ends
.text$mn:0000646D
.text$mn:00006470 ; ===========================================================================
.text$mn:00006470
.text$mn:00006470 ; Segment type: Pure code
.text$mn:00006470 ; Segment permissions: Read/Execute
.text$mn:00006470 _text$mn        segment para public 'CODE' use32
.text$mn:00006470                 assume cs:_text$mn
.text$mn:00006470                 ;org 6470h
.text$mn:00006470 ; COMDAT (pick any)
.text$mn:00006470                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006470
.text$mn:00006470 ; =============== S U B R O U T I N E =======================================
.text$mn:00006470
.text$mn:00006470 ; Attributes: bp-based frame
.text$mn:00006470
.text$mn:00006470 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00006470                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00006470 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00006470                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00006470
.text$mn:00006470 var_4           = dword ptr -4
.text$mn:00006470 Src             = dword ptr  8
.text$mn:00006470 Size            = dword ptr  0Ch
.text$mn:00006470
.text$mn:00006470                 push    ebp
.text$mn:00006471                 mov     ebp, esp
.text$mn:00006473                 push    ecx
.text$mn:00006474                 mov     [ebp+var_4], ecx
.text$mn:00006477                 cmp     [ebp+Size], 0
.text$mn:0000647B                 jz      short loc_6493
.text$mn:0000647D                 push    47Fh            ; unsigned int
.text$mn:00006482                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006487                 mov     eax, [ebp+Src]
.text$mn:0000648A                 push    eax             ; int
.text$mn:0000648B                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00006490                 add     esp, 0Ch
.text$mn:00006493
.text$mn:00006493 loc_6493:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00006493                 mov     ecx, [ebp+Src]
.text$mn:00006496                 push    ecx
.text$mn:00006497                 mov     ecx, [ebp+var_4]
.text$mn:0000649A                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000649F                 movzx   edx, al
.text$mn:000064A2                 test    edx, edx
.text$mn:000064A4                 jz      short loc_64C6
.text$mn:000064A6                 mov     eax, [ebp+Size]
.text$mn:000064A9                 push    eax
.text$mn:000064AA                 mov     ecx, [ebp+var_4]
.text$mn:000064AD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000064B2                 mov     ecx, [ebp+Src]
.text$mn:000064B5                 sub     ecx, eax
.text$mn:000064B7                 push    ecx
.text$mn:000064B8                 mov     edx, [ebp+var_4]
.text$mn:000064BB                 push    edx
.text$mn:000064BC                 mov     ecx, [ebp+var_4]
.text$mn:000064BF                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:000064C4                 jmp     short loc_6503
.text$mn:000064C6 ; ---------------------------------------------------------------------------
.text$mn:000064C6
.text$mn:000064C6 loc_64C6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:000064C6                 push    0
.text$mn:000064C8                 mov     eax, [ebp+Size]
.text$mn:000064CB                 push    eax
.text$mn:000064CC                 mov     ecx, [ebp+var_4]
.text$mn:000064CF                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000064D4                 movzx   ecx, al
.text$mn:000064D7                 test    ecx, ecx
.text$mn:000064D9                 jz      short loc_6500
.text$mn:000064DB                 mov     edx, [ebp+Size]
.text$mn:000064DE                 push    edx             ; Size
.text$mn:000064DF                 mov     eax, [ebp+Src]
.text$mn:000064E2                 push    eax             ; Src
.text$mn:000064E3                 mov     ecx, [ebp+var_4]
.text$mn:000064E6                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000064EB                 push    eax             ; Dst
.text$mn:000064EC                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000064F1                 add     esp, 0Ch
.text$mn:000064F4                 mov     ecx, [ebp+Size]
.text$mn:000064F7                 push    ecx
.text$mn:000064F8                 mov     ecx, [ebp+var_4]
.text$mn:000064FB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00006500
.text$mn:00006500 loc_6500:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00006500                 mov     eax, [ebp+var_4]
.text$mn:00006503
.text$mn:00006503 loc_6503:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00006503                 mov     esp, ebp
.text$mn:00006505                 pop     ebp
.text$mn:00006506                 retn    8
.text$mn:00006506 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00006506
.text$mn:00006506 ; ---------------------------------------------------------------------------
.text$mn:00006509                 align 4
.text$mn:00006509 _text$mn        ends
.text$mn:00006509
.text$mn:0000650C ; ===========================================================================
.text$mn:0000650C
.text$mn:0000650C ; Segment type: Pure code
.text$mn:0000650C ; Segment permissions: Read/Execute
.text$mn:0000650C _text$mn        segment para public 'CODE' use32
.text$mn:0000650C                 assume cs:_text$mn
.text$mn:0000650C                 ;org 650Ch
.text$mn:0000650C ; COMDAT (pick any)
.text$mn:0000650C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000650C
.text$mn:0000650C ; =============== S U B R O U T I N E =======================================
.text$mn:0000650C
.text$mn:0000650C ; Attributes: bp-based frame
.text$mn:0000650C
.text$mn:0000650C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:0000650C                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000650C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000650C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Bp
.text$mn:0000650C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+51p
.text$mn:0000650C
.text$mn:0000650C var_8           = dword ptr -8
.text$mn:0000650C var_4           = dword ptr -4
.text$mn:0000650C arg_0           = dword ptr  8
.text$mn:0000650C arg_4           = dword ptr  0Ch
.text$mn:0000650C arg_8           = dword ptr  10h
.text$mn:0000650C
.text$mn:0000650C                 push    ebp
.text$mn:0000650D                 mov     ebp, esp
.text$mn:0000650F                 sub     esp, 8
.text$mn:00006512                 mov     [ebp+var_4], ecx
.text$mn:00006515                 mov     ecx, [ebp+arg_0]
.text$mn:00006518                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000651D                 cmp     eax, [ebp+arg_4]
.text$mn:00006520                 jnb     short loc_652A
.text$mn:00006522                 mov     ecx, [ebp+var_4]
.text$mn:00006525                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000652A
.text$mn:0000652A loc_652A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:0000652A                 mov     ecx, [ebp+arg_0]
.text$mn:0000652D                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00006532                 sub     eax, [ebp+arg_4]
.text$mn:00006535                 mov     [ebp+var_8], eax
.text$mn:00006538                 mov     eax, [ebp+arg_8]
.text$mn:0000653B                 cmp     eax, [ebp+var_8]
.text$mn:0000653E                 jnb     short loc_6546
.text$mn:00006540                 mov     ecx, [ebp+arg_8]
.text$mn:00006543                 mov     [ebp+var_8], ecx
.text$mn:00006546
.text$mn:00006546 loc_6546:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:00006546                 mov     edx, [ebp+var_4]
.text$mn:00006549                 cmp     edx, [ebp+arg_0]
.text$mn:0000654C                 jnz     short loc_656D
.text$mn:0000654E                 mov     eax, [ebp+arg_4]
.text$mn:00006551                 add     eax, [ebp+var_8]
.text$mn:00006554                 push    eax
.text$mn:00006555                 mov     ecx, [ebp+var_4]
.text$mn:00006558                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:0000655D                 mov     ecx, [ebp+arg_4]
.text$mn:00006560                 push    ecx
.text$mn:00006561                 push    0
.text$mn:00006563                 mov     ecx, [ebp+var_4]
.text$mn:00006566                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:0000656B                 jmp     short loc_65B2
.text$mn:0000656D ; ---------------------------------------------------------------------------
.text$mn:0000656D
.text$mn:0000656D loc_656D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:0000656D                 push    0
.text$mn:0000656F                 mov     edx, [ebp+var_8]
.text$mn:00006572                 push    edx
.text$mn:00006573                 mov     ecx, [ebp+var_4]
.text$mn:00006576                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000657B                 movzx   eax, al
.text$mn:0000657E                 test    eax, eax
.text$mn:00006580                 jz      short loc_65B2
.text$mn:00006582                 mov     ecx, [ebp+var_8]
.text$mn:00006585                 push    ecx             ; int
.text$mn:00006586                 mov     ecx, [ebp+arg_0]
.text$mn:00006589                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000658E                 mov     edx, [ebp+arg_4]
.text$mn:00006591                 lea     eax, [eax+edx*2]
.text$mn:00006594                 push    eax             ; Src
.text$mn:00006595                 mov     ecx, [ebp+var_4]
.text$mn:00006598                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000659D                 push    eax             ; Dst
.text$mn:0000659E                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:000065A3                 add     esp, 0Ch
.text$mn:000065A6                 mov     ecx, [ebp+var_8]
.text$mn:000065A9                 push    ecx
.text$mn:000065AA                 mov     ecx, [ebp+var_4]
.text$mn:000065AD                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000065B2
.text$mn:000065B2 loc_65B2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:000065B2                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:000065B2                 mov     eax, [ebp+var_4]
.text$mn:000065B5                 mov     esp, ebp
.text$mn:000065B7                 pop     ebp
.text$mn:000065B8                 retn    0Ch
.text$mn:000065B8 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000065B8
.text$mn:000065B8 ; ---------------------------------------------------------------------------
.text$mn:000065BB                 align 4
.text$mn:000065BB _text$mn        ends
.text$mn:000065BB
.text$mn:000065BC ; ===========================================================================
.text$mn:000065BC
.text$mn:000065BC ; Segment type: Pure code
.text$mn:000065BC ; Segment permissions: Read/Execute
.text$mn:000065BC _text$mn        segment para public 'CODE' use32
.text$mn:000065BC                 assume cs:_text$mn
.text$mn:000065BC                 ;org 65BCh
.text$mn:000065BC ; COMDAT (pick any)
.text$mn:000065BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000065BC
.text$mn:000065BC ; =============== S U B R O U T I N E =======================================
.text$mn:000065BC
.text$mn:000065BC ; Attributes: bp-based frame
.text$mn:000065BC
.text$mn:000065BC ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:000065BC                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:000065BC ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:000065BC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:000065BC
.text$mn:000065BC var_4           = dword ptr -4
.text$mn:000065BC Str             = dword ptr  8
.text$mn:000065BC
.text$mn:000065BC                 push    ebp
.text$mn:000065BD                 mov     ebp, esp
.text$mn:000065BF                 push    ecx
.text$mn:000065C0                 mov     [ebp+var_4], ecx
.text$mn:000065C3                 push    490h            ; unsigned int
.text$mn:000065C8                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000065CD                 mov     eax, [ebp+Str]
.text$mn:000065D0                 push    eax             ; int
.text$mn:000065D1                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000065D6                 add     esp, 0Ch
.text$mn:000065D9                 mov     ecx, [ebp+Str]
.text$mn:000065DC                 push    ecx             ; Str
.text$mn:000065DD                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:000065E2                 add     esp, 4
.text$mn:000065E5                 push    eax             ; int
.text$mn:000065E6                 mov     edx, [ebp+Str]
.text$mn:000065E9                 push    edx             ; Src
.text$mn:000065EA                 mov     ecx, [ebp+var_4]
.text$mn:000065ED                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:000065F2                 mov     esp, ebp
.text$mn:000065F4                 pop     ebp
.text$mn:000065F5                 retn    4
.text$mn:000065F5 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:000065F5
.text$mn:000065F5 _text$mn        ends
.text$mn:000065F5
.text$mn:000065F8 ; ===========================================================================
.text$mn:000065F8
.text$mn:000065F8 ; Segment type: Pure code
.text$mn:000065F8 ; Segment permissions: Read/Execute
.text$mn:000065F8 _text$mn        segment para public 'CODE' use32
.text$mn:000065F8                 assume cs:_text$mn
.text$mn:000065F8                 ;org 65F8h
.text$mn:000065F8 ; COMDAT (pick any)
.text$mn:000065F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000065F8
.text$mn:000065F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000065F8
.text$mn:000065F8 ; Attributes: bp-based frame
.text$mn:000065F8
.text$mn:000065F8 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:000065F8                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:000065F8 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:000065F8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:000065F8
.text$mn:000065F8 var_4           = dword ptr -4
.text$mn:000065F8 Src             = dword ptr  8
.text$mn:000065F8 arg_4           = dword ptr  0Ch
.text$mn:000065F8
.text$mn:000065F8                 push    ebp
.text$mn:000065F9                 mov     ebp, esp
.text$mn:000065FB                 push    ecx
.text$mn:000065FC                 mov     [ebp+var_4], ecx
.text$mn:000065FF                 cmp     [ebp+arg_4], 0
.text$mn:00006603                 jz      short loc_661B
.text$mn:00006605                 push    47Fh            ; unsigned int
.text$mn:0000660A                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000660F                 mov     eax, [ebp+Src]
.text$mn:00006612                 push    eax             ; int
.text$mn:00006613                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00006618                 add     esp, 0Ch
.text$mn:0000661B
.text$mn:0000661B loc_661B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:0000661B                 mov     ecx, [ebp+Src]
.text$mn:0000661E                 push    ecx
.text$mn:0000661F                 mov     ecx, [ebp+var_4]
.text$mn:00006622                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00006627                 movzx   edx, al
.text$mn:0000662A                 test    edx, edx
.text$mn:0000662C                 jz      short loc_6650
.text$mn:0000662E                 mov     eax, [ebp+arg_4]
.text$mn:00006631                 push    eax
.text$mn:00006632                 mov     ecx, [ebp+var_4]
.text$mn:00006635                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000663A                 mov     ecx, [ebp+Src]
.text$mn:0000663D                 sub     ecx, eax
.text$mn:0000663F                 sar     ecx, 1
.text$mn:00006641                 push    ecx
.text$mn:00006642                 mov     edx, [ebp+var_4]
.text$mn:00006645                 push    edx
.text$mn:00006646                 mov     ecx, [ebp+var_4]
.text$mn:00006649                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000664E                 jmp     short loc_668D
.text$mn:00006650 ; ---------------------------------------------------------------------------
.text$mn:00006650
.text$mn:00006650 loc_6650:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:00006650                 push    0
.text$mn:00006652                 mov     eax, [ebp+arg_4]
.text$mn:00006655                 push    eax
.text$mn:00006656                 mov     ecx, [ebp+var_4]
.text$mn:00006659                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000665E                 movzx   ecx, al
.text$mn:00006661                 test    ecx, ecx
.text$mn:00006663                 jz      short loc_668A
.text$mn:00006665                 mov     edx, [ebp+arg_4]
.text$mn:00006668                 push    edx             ; int
.text$mn:00006669                 mov     eax, [ebp+Src]
.text$mn:0000666C                 push    eax             ; Src
.text$mn:0000666D                 mov     ecx, [ebp+var_4]
.text$mn:00006670                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00006675                 push    eax             ; Dst
.text$mn:00006676                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000667B                 add     esp, 0Ch
.text$mn:0000667E                 mov     ecx, [ebp+arg_4]
.text$mn:00006681                 push    ecx
.text$mn:00006682                 mov     ecx, [ebp+var_4]
.text$mn:00006685                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000668A
.text$mn:0000668A loc_668A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:0000668A                 mov     eax, [ebp+var_4]
.text$mn:0000668D
.text$mn:0000668D loc_668D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:0000668D                 mov     esp, ebp
.text$mn:0000668F                 pop     ebp
.text$mn:00006690                 retn    8
.text$mn:00006690 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:00006690
.text$mn:00006690 ; ---------------------------------------------------------------------------
.text$mn:00006693                 align 4
.text$mn:00006693 _text$mn        ends
.text$mn:00006693
.text$mn:00006694 ; ===========================================================================
.text$mn:00006694
.text$mn:00006694 ; Segment type: Pure code
.text$mn:00006694 ; Segment permissions: Read/Execute
.text$mn:00006694 _text$mn        segment para public 'CODE' use32
.text$mn:00006694                 assume cs:_text$mn
.text$mn:00006694                 ;org 6694h
.text$mn:00006694 ; COMDAT (pick any)
.text$mn:00006694                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006694
.text$mn:00006694 ; =============== S U B R O U T I N E =======================================
.text$mn:00006694
.text$mn:00006694 ; Attributes: bp-based frame
.text$mn:00006694
.text$mn:00006694 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00006694                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00006694 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00006694                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00006694
.text$mn:00006694 arg_0           = dword ptr  8
.text$mn:00006694 arg_4           = dword ptr  0Ch
.text$mn:00006694
.text$mn:00006694                 push    ebp
.text$mn:00006695                 mov     ebp, esp
.text$mn:00006697                 mov     eax, [ebp+arg_0]
.text$mn:0000669A                 mov     ecx, [ebp+arg_4]
.text$mn:0000669D                 mov     dl, [ecx]
.text$mn:0000669F                 mov     [eax], dl
.text$mn:000066A1                 pop     ebp
.text$mn:000066A2                 retn
.text$mn:000066A2 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:000066A2
.text$mn:000066A2 ; ---------------------------------------------------------------------------
.text$mn:000066A3                 align 4
.text$mn:000066A3 _text$mn        ends
.text$mn:000066A3
.text$mn:000066A4 ; ===========================================================================
.text$mn:000066A4
.text$mn:000066A4 ; Segment type: Pure code
.text$mn:000066A4 ; Segment permissions: Read/Execute
.text$mn:000066A4 _text$mn        segment para public 'CODE' use32
.text$mn:000066A4                 assume cs:_text$mn
.text$mn:000066A4                 ;org 66A4h
.text$mn:000066A4 ; COMDAT (pick any)
.text$mn:000066A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066A4
.text$mn:000066A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000066A4
.text$mn:000066A4 ; Attributes: bp-based frame
.text$mn:000066A4
.text$mn:000066A4 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:000066A4                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:000066A4 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:000066A4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:000066A4
.text$mn:000066A4 arg_0           = dword ptr  8
.text$mn:000066A4 arg_4           = dword ptr  0Ch
.text$mn:000066A4
.text$mn:000066A4                 push    ebp
.text$mn:000066A5                 mov     ebp, esp
.text$mn:000066A7                 mov     eax, [ebp+arg_0]
.text$mn:000066AA                 mov     ecx, [ebp+arg_4]
.text$mn:000066AD                 mov     dx, [ecx]
.text$mn:000066B0                 mov     [eax], dx
.text$mn:000066B3                 pop     ebp
.text$mn:000066B4                 retn
.text$mn:000066B4 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:000066B4
.text$mn:000066B4 ; ---------------------------------------------------------------------------
.text$mn:000066B5                 align 4
.text$mn:000066B5 _text$mn        ends
.text$mn:000066B5
.text$mn:000066B8 ; ===========================================================================
.text$mn:000066B8
.text$mn:000066B8 ; Segment type: Pure code
.text$mn:000066B8 ; Segment permissions: Read/Execute
.text$mn:000066B8 _text$mn        segment para public 'CODE' use32
.text$mn:000066B8                 assume cs:_text$mn
.text$mn:000066B8                 ;org 66B8h
.text$mn:000066B8 ; COMDAT (pick any)
.text$mn:000066B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066B8
.text$mn:000066B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000066B8
.text$mn:000066B8 ; Attributes: bp-based frame
.text$mn:000066B8
.text$mn:000066B8 ; public: int & __thiscall std::vector<int, class std::allocator<int>>::at(unsigned int)
.text$mn:000066B8                 public ?at@?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
.text$mn:000066B8 ?at@?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z proc near
.text$mn:000066B8                                         ; CODE XREF: ReBar::getNewID(void)+49p
.text$mn:000066B8                                         ; ReBar::releaseID(int)+5Ep ...
.text$mn:000066B8
.text$mn:000066B8 var_4           = dword ptr -4
.text$mn:000066B8 arg_0           = dword ptr  8
.text$mn:000066B8
.text$mn:000066B8                 push    ebp
.text$mn:000066B9                 mov     ebp, esp
.text$mn:000066BB                 push    ecx
.text$mn:000066BC                 mov     [ebp+var_4], ecx
.text$mn:000066BF                 mov     ecx, [ebp+var_4]
.text$mn:000066C2                 call    ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int>>::size(void)
.text$mn:000066C7                 cmp     eax, [ebp+arg_0]
.text$mn:000066CA                 ja      short loc_66D4
.text$mn:000066CC                 mov     ecx, [ebp+var_4]
.text$mn:000066CF                 call    ?_Xran@?$vector@HV?$allocator@H@std@@@std@@IBEXXZ ; std::vector<int,std::allocator<int>>::_Xran(void)
.text$mn:000066D4
.text$mn:000066D4 loc_66D4:                               ; CODE XREF: std::vector<int,std::allocator<int>>::at(uint)+12j
.text$mn:000066D4                 mov     eax, [ebp+var_4]
.text$mn:000066D7                 mov     ecx, [eax+4]
.text$mn:000066DA                 mov     edx, [ebp+arg_0]
.text$mn:000066DD                 lea     eax, [ecx+edx*4]
.text$mn:000066E0                 mov     esp, ebp
.text$mn:000066E2                 pop     ebp
.text$mn:000066E3                 retn    4
.text$mn:000066E3 ?at@?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z endp
.text$mn:000066E3
.text$mn:000066E3 ; ---------------------------------------------------------------------------
.text$mn:000066E6                 align 4
.text$mn:000066E6 _text$mn        ends
.text$mn:000066E6
.text$mn:000066E8 ; ===========================================================================
.text$mn:000066E8
.text$mn:000066E8 ; Segment type: Pure code
.text$mn:000066E8 ; Segment permissions: Read/Execute
.text$mn:000066E8 _text$mn        segment para public 'CODE' use32
.text$mn:000066E8                 assume cs:_text$mn
.text$mn:000066E8                 ;org 66E8h
.text$mn:000066E8 ; COMDAT (pick any)
.text$mn:000066E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066E8
.text$mn:000066E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000066E8
.text$mn:000066E8 ; Attributes: bp-based frame
.text$mn:000066E8
.text$mn:000066E8 ; public: struct tDynamicList & __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::at(unsigned int)
.text$mn:000066E8                 public ?at@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QAEAAUtDynamicList@@I@Z
.text$mn:000066E8 ?at@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QAEAAUtDynamicList@@I@Z proc near
.text$mn:000066E8                                         ; CODE XREF: ToolBar::reset(bool)+250p
.text$mn:000066E8
.text$mn:000066E8 var_4           = dword ptr -4
.text$mn:000066E8 arg_0           = dword ptr  8
.text$mn:000066E8
.text$mn:000066E8                 push    ebp
.text$mn:000066E9                 mov     ebp, esp
.text$mn:000066EB                 push    ecx
.text$mn:000066EC                 mov     [ebp+var_4], ecx
.text$mn:000066EF                 mov     ecx, [ebp+var_4]
.text$mn:000066F2                 call    ?size@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ ; std::vector<tDynamicList,std::allocator<tDynamicList>>::size(void)
.text$mn:000066F7                 cmp     eax, [ebp+arg_0]
.text$mn:000066FA                 ja      short loc_6704
.text$mn:000066FC                 mov     ecx, [ebp+var_4]
.text$mn:000066FF                 call    ?_Xran@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXXZ ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Xran(void)
.text$mn:00006704
.text$mn:00006704 loc_6704:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::at(uint)+12j
.text$mn:00006704                 imul    eax, [ebp+arg_0], 0Ch
.text$mn:00006708                 mov     ecx, [ebp+var_4]
.text$mn:0000670B                 add     eax, [ecx+4]
.text$mn:0000670E                 mov     esp, ebp
.text$mn:00006710                 pop     ebp
.text$mn:00006711                 retn    4
.text$mn:00006711 ?at@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QAEAAUtDynamicList@@I@Z endp
.text$mn:00006711
.text$mn:00006711 _text$mn        ends
.text$mn:00006711
.text$mn:00006714 ; ===========================================================================
.text$mn:00006714
.text$mn:00006714 ; Segment type: Pure code
.text$mn:00006714 ; Segment permissions: Read/Execute
.text$mn:00006714 _text$mn        segment para public 'CODE' use32
.text$mn:00006714                 assume cs:_text$mn
.text$mn:00006714                 ;org 6714h
.text$mn:00006714 ; COMDAT (pick any)
.text$mn:00006714                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006714
.text$mn:00006714 ; =============== S U B R O U T I N E =======================================
.text$mn:00006714
.text$mn:00006714 ; Attributes: bp-based frame
.text$mn:00006714
.text$mn:00006714 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int>>> __thiscall std::vector<int, class std::allocator<int>>::begin(void)
.text$mn:00006714                 public ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$mn:00006714 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ proc near
.text$mn:00006714                                         ; CODE XREF: ReBar::releaseID(int)+80p
.text$mn:00006714
.text$mn:00006714 var_14          = dword ptr -14h
.text$mn:00006714 var_10          = dword ptr -10h
.text$mn:00006714 var_C           = dword ptr -0Ch
.text$mn:00006714 var_4           = dword ptr -4
.text$mn:00006714 arg_0           = dword ptr  8
.text$mn:00006714
.text$mn:00006714                 push    ebp
.text$mn:00006715                 mov     ebp, esp
.text$mn:00006717                 push    0FFFFFFFFh
.text$mn:00006719                 push    offset __ehhandler$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$mn:0000671E                 mov     eax, large fs:0
.text$mn:00006724                 push    eax
.text$mn:00006725                 sub     esp, 8
.text$mn:00006728                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000672D                 xor     eax, ebp
.text$mn:0000672F                 push    eax
.text$mn:00006730                 lea     eax, [ebp+var_C]
.text$mn:00006733                 mov     large fs:0, eax
.text$mn:00006739                 mov     [ebp+var_10], ecx
.text$mn:0000673C                 mov     [ebp+var_14], 0
.text$mn:00006743                 mov     eax, [ebp+var_10]
.text$mn:00006746                 push    eax             ; struct std::_Container_base12 *
.text$mn:00006747                 mov     ecx, [ebp+var_10]
.text$mn:0000674A                 mov     edx, [ecx+4]
.text$mn:0000674D                 push    edx             ; int
.text$mn:0000674E                 mov     ecx, [ebp+arg_0]
.text$mn:00006751                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(int *,std::_Container_base12 const *)
.text$mn:00006756                 mov     [ebp+var_4], 0
.text$mn:0000675D                 mov     eax, [ebp+var_14]
.text$mn:00006760                 or      eax, 1
.text$mn:00006763                 mov     [ebp+var_14], eax
.text$mn:00006766                 mov     eax, [ebp+arg_0]
.text$mn:00006769                 mov     ecx, [ebp+var_C]
.text$mn:0000676C                 mov     large fs:0, ecx
.text$mn:00006773                 pop     ecx
.text$mn:00006774                 mov     esp, ebp
.text$mn:00006776                 pop     ebp
.text$mn:00006777                 retn    4
.text$mn:00006777 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ endp
.text$mn:00006777
.text$mn:00006777 ; ---------------------------------------------------------------------------
.text$mn:0000677A                 align 4
.text$mn:0000677A _text$mn        ends
.text$mn:0000677A
.text$x:0000677C ; ===========================================================================
.text$x:0000677C
.text$x:0000677C ; Segment type: Pure code
.text$x:0000677C ; Segment permissions: Read/Execute
.text$x:0000677C _text$x         segment para public 'CODE' use32
.text$x:0000677C                 assume cs:_text$x
.text$x:0000677C                 ;org 677Ch
.text$x:0000677C ; COMDAT (pick associative to section at 6714)
.text$x:0000677C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000677C
.text$x:0000677C ; =============== S U B R O U T I N E =======================================
.text$x:0000677C
.text$x:0000677C
.text$x:0000677C __unwindfunclet$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0 proc near
.text$x:0000677C                                         ; DATA XREF: .xdata$x:00008314o
.text$x:0000677C                 mov     eax, [ebp-14h]
.text$x:0000677F                 and     eax, 1
.text$x:00006782                 jz      $LN4
.text$x:00006788                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:0000678C                 mov     ecx, [ebp+8]
.text$x:0000678F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006794 ; ---------------------------------------------------------------------------
.text$x:00006794
.text$x:00006794 $LN4:                                   ; CODE XREF: __unwindfunclet$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0+6j
.text$x:00006794                 retn
.text$x:00006794 __unwindfunclet$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0 endp
.text$x:00006794
.text$x:00006795
.text$x:00006795 ; =============== S U B R O U T I N E =======================================
.text$x:00006795
.text$x:00006795
.text$x:00006795 __ehhandler$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ proc near
.text$x:00006795                                         ; DATA XREF: std::vector<int,std::allocator<int>>::begin(void)+5o
.text$x:00006795
.text$x:00006795 arg_4           = dword ptr  8
.text$x:00006795
.text$x:00006795                 mov     edx, [esp+arg_4]
.text$x:00006799                 lea     eax, [edx+0Ch]
.text$x:0000679C                 mov     ecx, [edx-0Ch]
.text$x:0000679F                 xor     ecx, eax
.text$x:000067A1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000067A6                 mov     eax, offset __ehfuncinfo$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.text$x:000067AB                 jmp     ___CxxFrameHandler3
.text$x:000067AB __ehhandler$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ endp
.text$x:000067AB
.text$x:000067AB _text$x         ends
.text$x:000067AB
.text$mn:000067B0 ; ===========================================================================
.text$mn:000067B0
.text$mn:000067B0 ; Segment type: Pure code
.text$mn:000067B0 ; Segment permissions: Read/Execute
.text$mn:000067B0 _text$mn        segment para public 'CODE' use32
.text$mn:000067B0                 assume cs:_text$mn
.text$mn:000067B0                 ;org 67B0h
.text$mn:000067B0 ; COMDAT (pick any)
.text$mn:000067B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000067B0
.text$mn:000067B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000067B0
.text$mn:000067B0 ; Attributes: bp-based frame
.text$mn:000067B0
.text$mn:000067B0 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:000067B0                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:000067B0 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:000067B0                                         ; CODE XREF: ToolBar::doPopop(tagPOINT)+123p
.text$mn:000067B0                                         ; ToolBar::doPopop(tagPOINT)+13Ep ...
.text$mn:000067B0
.text$mn:000067B0 var_4           = dword ptr -4
.text$mn:000067B0
.text$mn:000067B0                 push    ebp
.text$mn:000067B1                 mov     ebp, esp
.text$mn:000067B3                 push    ecx
.text$mn:000067B4                 mov     [ebp+var_4], ecx
.text$mn:000067B7                 mov     ecx, [ebp+var_4]
.text$mn:000067BA                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000067BF                 mov     esp, ebp
.text$mn:000067C1                 pop     ebp
.text$mn:000067C2                 retn
.text$mn:000067C2 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:000067C2
.text$mn:000067C2 ; ---------------------------------------------------------------------------
.text$mn:000067C3                 align 4
.text$mn:000067C3 _text$mn        ends
.text$mn:000067C3
.text$mn:000067C4 ; ===========================================================================
.text$mn:000067C4
.text$mn:000067C4 ; Segment type: Pure code
.text$mn:000067C4 ; Segment permissions: Read/Execute
.text$mn:000067C4 _text$mn        segment para public 'CODE' use32
.text$mn:000067C4                 assume cs:_text$mn
.text$mn:000067C4                 ;org 67C4h
.text$mn:000067C4 ; COMDAT (pick any)
.text$mn:000067C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000067C4
.text$mn:000067C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000067C4
.text$mn:000067C4 ; Attributes: bp-based frame
.text$mn:000067C4
.text$mn:000067C4 ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::capacity(void)const
.text$mn:000067C4                 public ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:000067C4 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:000067C4                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+Cp
.text$mn:000067C4
.text$mn:000067C4 var_4           = dword ptr -4
.text$mn:000067C4
.text$mn:000067C4                 push    ebp
.text$mn:000067C5                 mov     ebp, esp
.text$mn:000067C7                 push    ecx
.text$mn:000067C8                 mov     [ebp+var_4], ecx
.text$mn:000067CB                 mov     eax, [ebp+var_4]
.text$mn:000067CE                 mov     ecx, [ebp+var_4]
.text$mn:000067D1                 mov     eax, [eax+0Ch]
.text$mn:000067D4                 sub     eax, [ecx+4]
.text$mn:000067D7                 sar     eax, 2
.text$mn:000067DA                 mov     esp, ebp
.text$mn:000067DC                 pop     ebp
.text$mn:000067DD                 retn
.text$mn:000067DD ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:000067DD
.text$mn:000067DD ; ---------------------------------------------------------------------------
.text$mn:000067DE                 align 10h
.text$mn:000067DE _text$mn        ends
.text$mn:000067DE
.text$mn:000067E0 ; ===========================================================================
.text$mn:000067E0
.text$mn:000067E0 ; Segment type: Pure code
.text$mn:000067E0 ; Segment permissions: Read/Execute
.text$mn:000067E0 _text$mn        segment para public 'CODE' use32
.text$mn:000067E0                 assume cs:_text$mn
.text$mn:000067E0                 ;org 67E0h
.text$mn:000067E0 ; COMDAT (pick any)
.text$mn:000067E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000067E0
.text$mn:000067E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000067E0
.text$mn:000067E0 ; Attributes: bp-based frame
.text$mn:000067E0
.text$mn:000067E0 ; public: unsigned int __thiscall std::vector<struct iconLocator, class std::allocator<struct iconLocator>>::capacity(void)const
.text$mn:000067E0                 public ?capacity@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ
.text$mn:000067E0 ?capacity@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ proc near
.text$mn:000067E0                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Grow_to(uint)+Cp
.text$mn:000067E0
.text$mn:000067E0 var_4           = dword ptr -4
.text$mn:000067E0
.text$mn:000067E0                 push    ebp
.text$mn:000067E1                 mov     ebp, esp
.text$mn:000067E3                 push    ecx
.text$mn:000067E4                 mov     [ebp+var_4], ecx
.text$mn:000067E7                 mov     eax, [ebp+var_4]
.text$mn:000067EA                 mov     ecx, [ebp+var_4]
.text$mn:000067ED                 mov     eax, [eax+0Ch]
.text$mn:000067F0                 sub     eax, [ecx+4]
.text$mn:000067F3                 cdq
.text$mn:000067F4                 mov     ecx, 24h ; '$'
.text$mn:000067F9                 idiv    ecx
.text$mn:000067FB                 mov     esp, ebp
.text$mn:000067FD                 pop     ebp
.text$mn:000067FE                 retn
.text$mn:000067FE ?capacity@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ endp
.text$mn:000067FE
.text$mn:000067FE ; ---------------------------------------------------------------------------
.text$mn:000067FF                 align 10h
.text$mn:000067FF _text$mn        ends
.text$mn:000067FF
.text$mn:00006800 ; ===========================================================================
.text$mn:00006800
.text$mn:00006800 ; Segment type: Pure code
.text$mn:00006800 ; Segment permissions: Read/Execute
.text$mn:00006800 _text$mn        segment para public 'CODE' use32
.text$mn:00006800                 assume cs:_text$mn
.text$mn:00006800                 ;org 6800h
.text$mn:00006800 ; COMDAT (pick any)
.text$mn:00006800                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006800
.text$mn:00006800 ; =============== S U B R O U T I N E =======================================
.text$mn:00006800
.text$mn:00006800 ; Attributes: bp-based frame
.text$mn:00006800
.text$mn:00006800 ; public: unsigned int __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::capacity(void)const
.text$mn:00006800                 public ?capacity@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ
.text$mn:00006800 ?capacity@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ proc near
.text$mn:00006800                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Grow_to(uint)+Cp
.text$mn:00006800
.text$mn:00006800 var_4           = dword ptr -4
.text$mn:00006800
.text$mn:00006800                 push    ebp
.text$mn:00006801                 mov     ebp, esp
.text$mn:00006803                 push    ecx
.text$mn:00006804                 mov     [ebp+var_4], ecx
.text$mn:00006807                 mov     eax, [ebp+var_4]
.text$mn:0000680A                 mov     ecx, [ebp+var_4]
.text$mn:0000680D                 mov     eax, [eax+0Ch]
.text$mn:00006810                 sub     eax, [ecx+4]
.text$mn:00006813                 cdq
.text$mn:00006814                 mov     ecx, 0Ch
.text$mn:00006819                 idiv    ecx
.text$mn:0000681B                 mov     esp, ebp
.text$mn:0000681D                 pop     ebp
.text$mn:0000681E                 retn
.text$mn:0000681E ?capacity@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ endp
.text$mn:0000681E
.text$mn:0000681E ; ---------------------------------------------------------------------------
.text$mn:0000681F                 align 10h
.text$mn:0000681F _text$mn        ends
.text$mn:0000681F
.text$mn:00006820 ; ===========================================================================
.text$mn:00006820
.text$mn:00006820 ; Segment type: Pure code
.text$mn:00006820 ; Segment permissions: Read/Execute
.text$mn:00006820 _text$mn        segment para public 'CODE' use32
.text$mn:00006820                 assume cs:_text$mn
.text$mn:00006820                 ;org 6820h
.text$mn:00006820 ; COMDAT (pick any)
.text$mn:00006820                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006820
.text$mn:00006820 ; =============== S U B R O U T I N E =======================================
.text$mn:00006820
.text$mn:00006820 ; Attributes: bp-based frame
.text$mn:00006820
.text$mn:00006820 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00006820                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00006820 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00006820                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00006820
.text$mn:00006820 var_4           = dword ptr -4
.text$mn:00006820
.text$mn:00006820                 push    ebp
.text$mn:00006821                 mov     ebp, esp
.text$mn:00006823                 push    ecx
.text$mn:00006824                 mov     [ebp+var_4], ecx
.text$mn:00006827                 mov     eax, [ebp+var_4]
.text$mn:0000682A                 mov     eax, [eax+4]
.text$mn:0000682D                 mov     esp, ebp
.text$mn:0000682F                 pop     ebp
.text$mn:00006830                 retn
.text$mn:00006830 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00006830
.text$mn:00006830 ; ---------------------------------------------------------------------------
.text$mn:00006831                 align 4
.text$mn:00006831 _text$mn        ends
.text$mn:00006831
.text$mn:00006834 ; ===========================================================================
.text$mn:00006834
.text$mn:00006834 ; Segment type: Pure code
.text$mn:00006834 ; Segment permissions: Read/Execute
.text$mn:00006834 _text$mn        segment para public 'CODE' use32
.text$mn:00006834                 assume cs:_text$mn
.text$mn:00006834                 ;org 6834h
.text$mn:00006834 ; COMDAT (pick any)
.text$mn:00006834                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006834
.text$mn:00006834 ; =============== S U B R O U T I N E =======================================
.text$mn:00006834
.text$mn:00006834 ; Attributes: bp-based frame
.text$mn:00006834
.text$mn:00006834 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00006834                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00006834 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00006834                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00006834                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00006834
.text$mn:00006834 var_4           = dword ptr -4
.text$mn:00006834
.text$mn:00006834                 push    ebp
.text$mn:00006835                 mov     ebp, esp
.text$mn:00006837                 push    ecx
.text$mn:00006838                 mov     [ebp+var_4], ecx
.text$mn:0000683B                 mov     eax, [ebp+var_4]
.text$mn:0000683E                 mov     eax, [eax+4]
.text$mn:00006841                 mov     esp, ebp
.text$mn:00006843                 pop     ebp
.text$mn:00006844                 retn
.text$mn:00006844 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00006844
.text$mn:00006844 ; ---------------------------------------------------------------------------
.text$mn:00006845                 align 4
.text$mn:00006845 _text$mn        ends
.text$mn:00006845
.text$mn:00006848 ; ===========================================================================
.text$mn:00006848
.text$mn:00006848 ; Segment type: Pure code
.text$mn:00006848 ; Segment permissions: Read/Execute
.text$mn:00006848 _text$mn        segment para public 'CODE' use32
.text$mn:00006848                 assume cs:_text$mn
.text$mn:00006848                 ;org 6848h
.text$mn:00006848 ; COMDAT (pick any)
.text$mn:00006848                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006848
.text$mn:00006848 ; =============== S U B R O U T I N E =======================================
.text$mn:00006848
.text$mn:00006848 ; Attributes: bp-based frame
.text$mn:00006848
.text$mn:00006848 ; int __stdcall std::allocator<int>::construct(void *, int)
.text$mn:00006848                 public ?construct@?$allocator@H@std@@QAEXPAHABH@Z
.text$mn:00006848 ?construct@?$allocator@H@std@@QAEXPAHABH@Z proc near
.text$mn:00006848                                         ; CODE XREF: std::allocator_traits<std::allocator<int>>::construct<int,int const &>(std::allocator<int> &,int *,int const &)+17p
.text$mn:00006848
.text$mn:00006848 var_C           = dword ptr -0Ch
.text$mn:00006848 var_8           = dword ptr -8
.text$mn:00006848 var_4           = dword ptr -4
.text$mn:00006848 arg_0           = dword ptr  8
.text$mn:00006848 arg_4           = dword ptr  0Ch
.text$mn:00006848
.text$mn:00006848                 push    ebp
.text$mn:00006849                 mov     ebp, esp
.text$mn:0000684B                 sub     esp, 0Ch
.text$mn:0000684E                 mov     [ebp+var_C], ecx
.text$mn:00006851                 mov     eax, [ebp+arg_0]
.text$mn:00006854                 push    eax             ; void *
.text$mn:00006855                 push    4               ; unsigned int
.text$mn:00006857                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000685C                 add     esp, 8
.text$mn:0000685F                 mov     [ebp+var_4], eax
.text$mn:00006862                 cmp     [ebp+var_4], 0
.text$mn:00006866                 jz      short loc_687A
.text$mn:00006868                 mov     ecx, [ebp+var_4]
.text$mn:0000686B                 mov     edx, [ebp+arg_4]
.text$mn:0000686E                 mov     eax, [edx]
.text$mn:00006870                 mov     [ecx], eax
.text$mn:00006872                 mov     ecx, [ebp+var_4]
.text$mn:00006875                 mov     [ebp+var_8], ecx
.text$mn:00006878                 jmp     short loc_6881
.text$mn:0000687A ; ---------------------------------------------------------------------------
.text$mn:0000687A
.text$mn:0000687A loc_687A:                               ; CODE XREF: std::allocator<int>::construct(int *,int const &)+1Ej
.text$mn:0000687A                 mov     [ebp+var_8], 0
.text$mn:00006881
.text$mn:00006881 loc_6881:                               ; CODE XREF: std::allocator<int>::construct(int *,int const &)+30j
.text$mn:00006881                 mov     esp, ebp
.text$mn:00006883                 pop     ebp
.text$mn:00006884                 retn    8
.text$mn:00006884 ?construct@?$allocator@H@std@@QAEXPAHABH@Z endp
.text$mn:00006884
.text$mn:00006884 ; ---------------------------------------------------------------------------
.text$mn:00006887                 align 4
.text$mn:00006887 _text$mn        ends
.text$mn:00006887
.text$mn:00006888 ; ===========================================================================
.text$mn:00006888
.text$mn:00006888 ; Segment type: Pure code
.text$mn:00006888 ; Segment permissions: Read/Execute
.text$mn:00006888 _text$mn        segment para public 'CODE' use32
.text$mn:00006888                 assume cs:_text$mn
.text$mn:00006888                 ;org 6888h
.text$mn:00006888 ; COMDAT (pick any)
.text$mn:00006888                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006888
.text$mn:00006888 ; =============== S U B R O U T I N E =======================================
.text$mn:00006888
.text$mn:00006888 ; Attributes: bp-based frame
.text$mn:00006888
.text$mn:00006888 ; int __stdcall std::allocator<tDynamicList>::construct(void *, int)
.text$mn:00006888                 public ?construct@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@ABU3@@Z
.text$mn:00006888 ?construct@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@ABU3@@Z proc near
.text$mn:00006888                                         ; CODE XREF: std::allocator_traits<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList const &>(std::allocator<tDynamicList> &,tDynamicList *,tDynamicList const &)+17p
.text$mn:00006888
.text$mn:00006888 var_C           = dword ptr -0Ch
.text$mn:00006888 var_8           = dword ptr -8
.text$mn:00006888 var_4           = dword ptr -4
.text$mn:00006888 arg_0           = dword ptr  8
.text$mn:00006888 arg_4           = dword ptr  0Ch
.text$mn:00006888
.text$mn:00006888                 push    ebp
.text$mn:00006889                 mov     ebp, esp
.text$mn:0000688B                 sub     esp, 0Ch
.text$mn:0000688E                 mov     [ebp+var_C], ecx
.text$mn:00006891                 mov     eax, [ebp+arg_0]
.text$mn:00006894                 push    eax             ; void *
.text$mn:00006895                 push    0Ch             ; unsigned int
.text$mn:00006897                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000689C                 add     esp, 8
.text$mn:0000689F                 mov     [ebp+var_4], eax
.text$mn:000068A2                 cmp     [ebp+var_4], 0
.text$mn:000068A6                 jz      short loc_68C6
.text$mn:000068A8                 mov     ecx, [ebp+arg_4]
.text$mn:000068AB                 mov     edx, [ebp+var_4]
.text$mn:000068AE                 mov     eax, [ecx]
.text$mn:000068B0                 mov     [edx], eax
.text$mn:000068B2                 mov     eax, [ecx+4]
.text$mn:000068B5                 mov     [edx+4], eax
.text$mn:000068B8                 mov     ecx, [ecx+8]
.text$mn:000068BB                 mov     [edx+8], ecx
.text$mn:000068BE                 mov     edx, [ebp+var_4]
.text$mn:000068C1                 mov     [ebp+var_8], edx
.text$mn:000068C4                 jmp     short loc_68CD
.text$mn:000068C6 ; ---------------------------------------------------------------------------
.text$mn:000068C6
.text$mn:000068C6 loc_68C6:                               ; CODE XREF: std::allocator<tDynamicList>::construct(tDynamicList *,tDynamicList const &)+1Ej
.text$mn:000068C6                 mov     [ebp+var_8], 0
.text$mn:000068CD
.text$mn:000068CD loc_68CD:                               ; CODE XREF: std::allocator<tDynamicList>::construct(tDynamicList *,tDynamicList const &)+3Cj
.text$mn:000068CD                 mov     esp, ebp
.text$mn:000068CF                 pop     ebp
.text$mn:000068D0                 retn    8
.text$mn:000068D0 ?construct@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@ABU3@@Z endp
.text$mn:000068D0
.text$mn:000068D0 ; ---------------------------------------------------------------------------
.text$mn:000068D3                 align 4
.text$mn:000068D3 _text$mn        ends
.text$mn:000068D3
.text$mn:000068D4 ; ===========================================================================
.text$mn:000068D4
.text$mn:000068D4 ; Segment type: Pure code
.text$mn:000068D4 ; Segment permissions: Read/Execute
.text$mn:000068D4 _text$mn        segment para public 'CODE' use32
.text$mn:000068D4                 assume cs:_text$mn
.text$mn:000068D4                 ;org 68D4h
.text$mn:000068D4 ; COMDAT (pick any)
.text$mn:000068D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000068D4
.text$mn:000068D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000068D4
.text$mn:000068D4 ; Attributes: bp-based frame
.text$mn:000068D4
.text$mn:000068D4 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:000068D4                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000068D4 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:000068D4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:000068D4
.text$mn:000068D4 var_4           = dword ptr -4
.text$mn:000068D4 Dst             = dword ptr  8
.text$mn:000068D4 Src             = dword ptr  0Ch
.text$mn:000068D4 Size            = dword ptr  10h
.text$mn:000068D4
.text$mn:000068D4                 push    ebp
.text$mn:000068D5                 mov     ebp, esp
.text$mn:000068D7                 push    ecx
.text$mn:000068D8                 cmp     [ebp+Size], 0
.text$mn:000068DC                 jnz     short loc_68E6
.text$mn:000068DE                 mov     eax, [ebp+Dst]
.text$mn:000068E1                 mov     [ebp+var_4], eax
.text$mn:000068E4                 jmp     short loc_68FD
.text$mn:000068E6 ; ---------------------------------------------------------------------------
.text$mn:000068E6
.text$mn:000068E6 loc_68E6:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:000068E6                 mov     ecx, [ebp+Size]
.text$mn:000068E9                 push    ecx             ; Size
.text$mn:000068EA                 mov     edx, [ebp+Src]
.text$mn:000068ED                 push    edx             ; Src
.text$mn:000068EE                 mov     eax, [ebp+Dst]
.text$mn:000068F1                 push    eax             ; Dst
.text$mn:000068F2                 call    _memcpy
.text$mn:000068F7                 add     esp, 0Ch
.text$mn:000068FA                 mov     [ebp+var_4], eax
.text$mn:000068FD
.text$mn:000068FD loc_68FD:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:000068FD                 mov     eax, [ebp+var_4]
.text$mn:00006900                 mov     esp, ebp
.text$mn:00006902                 pop     ebp
.text$mn:00006903                 retn
.text$mn:00006903 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00006903
.text$mn:00006903 _text$mn        ends
.text$mn:00006903
.text$mn:00006904 ; ===========================================================================
.text$mn:00006904
.text$mn:00006904 ; Segment type: Pure code
.text$mn:00006904 ; Segment permissions: Read/Execute
.text$mn:00006904 _text$mn        segment para public 'CODE' use32
.text$mn:00006904                 assume cs:_text$mn
.text$mn:00006904                 ;org 6904h
.text$mn:00006904 ; COMDAT (pick any)
.text$mn:00006904                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006904
.text$mn:00006904 ; =============== S U B R O U T I N E =======================================
.text$mn:00006904
.text$mn:00006904 ; Attributes: bp-based frame
.text$mn:00006904
.text$mn:00006904 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:00006904                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00006904 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00006904                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:00006904                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00006904
.text$mn:00006904 var_4           = dword ptr -4
.text$mn:00006904 Dst             = dword ptr  8
.text$mn:00006904 Src             = dword ptr  0Ch
.text$mn:00006904 arg_8           = dword ptr  10h
.text$mn:00006904
.text$mn:00006904                 push    ebp
.text$mn:00006905                 mov     ebp, esp
.text$mn:00006907                 push    ecx
.text$mn:00006908                 cmp     [ebp+arg_8], 0
.text$mn:0000690C                 jnz     short loc_6916
.text$mn:0000690E                 mov     eax, [ebp+Dst]
.text$mn:00006911                 mov     [ebp+var_4], eax
.text$mn:00006914                 jmp     short loc_692D
.text$mn:00006916 ; ---------------------------------------------------------------------------
.text$mn:00006916
.text$mn:00006916 loc_6916:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00006916                 mov     ecx, [ebp+arg_8]
.text$mn:00006919                 push    ecx             ; int
.text$mn:0000691A                 mov     edx, [ebp+Src]
.text$mn:0000691D                 push    edx             ; Src
.text$mn:0000691E                 mov     eax, [ebp+Dst]
.text$mn:00006921                 push    eax             ; Dst
.text$mn:00006922                 call    _wmemcpy
.text$mn:00006927                 add     esp, 0Ch
.text$mn:0000692A                 mov     [ebp+var_4], eax
.text$mn:0000692D
.text$mn:0000692D loc_692D:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000692D                 mov     eax, [ebp+var_4]
.text$mn:00006930                 mov     esp, ebp
.text$mn:00006932                 pop     ebp
.text$mn:00006933                 retn
.text$mn:00006933 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00006933
.text$mn:00006933 _text$mn        ends
.text$mn:00006933
.text$mn:00006934 ; ===========================================================================
.text$mn:00006934
.text$mn:00006934 ; Segment type: Pure code
.text$mn:00006934 ; Segment permissions: Read/Execute
.text$mn:00006934 _text$mn        segment para public 'CODE' use32
.text$mn:00006934                 assume cs:_text$mn
.text$mn:00006934                 ;org 6934h
.text$mn:00006934 ; COMDAT (pick any)
.text$mn:00006934                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006934
.text$mn:00006934 ; =============== S U B R O U T I N E =======================================
.text$mn:00006934
.text$mn:00006934 ; Attributes: bp-based frame
.text$mn:00006934
.text$mn:00006934 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00006934                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00006934 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00006934                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00006934
.text$mn:00006934 var_4           = dword ptr -4
.text$mn:00006934 arg_0           = dword ptr  8
.text$mn:00006934 arg_4           = dword ptr  0Ch
.text$mn:00006934
.text$mn:00006934                 push    ebp
.text$mn:00006935                 mov     ebp, esp
.text$mn:00006937                 push    ecx
.text$mn:00006938                 mov     [ebp+var_4], ecx
.text$mn:0000693B                 mov     eax, [ebp+arg_4]
.text$mn:0000693E                 push    eax             ; int
.text$mn:0000693F                 mov     ecx, [ebp+arg_0]
.text$mn:00006942                 push    ecx             ; void *
.text$mn:00006943                 mov     ecx, [ebp+var_4]
.text$mn:00006946                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000694B                 mov     esp, ebp
.text$mn:0000694D                 pop     ebp
.text$mn:0000694E                 retn    8
.text$mn:0000694E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000694E
.text$mn:0000694E ; ---------------------------------------------------------------------------
.text$mn:00006951                 align 4
.text$mn:00006951 _text$mn        ends
.text$mn:00006951
.text$mn:00006954 ; ===========================================================================
.text$mn:00006954
.text$mn:00006954 ; Segment type: Pure code
.text$mn:00006954 ; Segment permissions: Read/Execute
.text$mn:00006954 _text$mn        segment para public 'CODE' use32
.text$mn:00006954                 assume cs:_text$mn
.text$mn:00006954                 ;org 6954h
.text$mn:00006954 ; COMDAT (pick any)
.text$mn:00006954                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006954
.text$mn:00006954 ; =============== S U B R O U T I N E =======================================
.text$mn:00006954
.text$mn:00006954 ; Attributes: bp-based frame
.text$mn:00006954
.text$mn:00006954 ; int __stdcall std::_Wrap_alloc<std::allocator<int>>::deallocate(void *, int)
.text$mn:00006954                 public ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z
.text$mn:00006954 ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z proc near
.text$mn:00006954                                         ; CODE XREF: __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0+16p
.text$mn:00006954                                         ; std::vector<int,std::allocator<int>>::_Reallocate(uint)+F5p
.text$mn:00006954
.text$mn:00006954 var_4           = dword ptr -4
.text$mn:00006954 arg_0           = dword ptr  8
.text$mn:00006954 arg_4           = dword ptr  0Ch
.text$mn:00006954
.text$mn:00006954                 push    ebp
.text$mn:00006955                 mov     ebp, esp
.text$mn:00006957                 push    ecx
.text$mn:00006958                 mov     [ebp+var_4], ecx
.text$mn:0000695B                 mov     eax, [ebp+arg_4]
.text$mn:0000695E                 push    eax             ; int
.text$mn:0000695F                 mov     ecx, [ebp+arg_0]
.text$mn:00006962                 push    ecx             ; void *
.text$mn:00006963                 mov     ecx, [ebp+var_4]
.text$mn:00006966                 call    ?deallocate@?$allocator@H@std@@QAEXPAHI@Z ; std::allocator<int>::deallocate(int *,uint)
.text$mn:0000696B                 mov     esp, ebp
.text$mn:0000696D                 pop     ebp
.text$mn:0000696E                 retn    8
.text$mn:0000696E ?deallocate@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHI@Z endp
.text$mn:0000696E
.text$mn:0000696E ; ---------------------------------------------------------------------------
.text$mn:00006971                 align 4
.text$mn:00006971 _text$mn        ends
.text$mn:00006971
.text$mn:00006974 ; ===========================================================================
.text$mn:00006974
.text$mn:00006974 ; Segment type: Pure code
.text$mn:00006974 ; Segment permissions: Read/Execute
.text$mn:00006974 _text$mn        segment para public 'CODE' use32
.text$mn:00006974                 assume cs:_text$mn
.text$mn:00006974                 ;org 6974h
.text$mn:00006974 ; COMDAT (pick any)
.text$mn:00006974                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006974
.text$mn:00006974 ; =============== S U B R O U T I N E =======================================
.text$mn:00006974
.text$mn:00006974 ; Attributes: bp-based frame
.text$mn:00006974
.text$mn:00006974 ; int __stdcall std::_Wrap_alloc<std::allocator<iconLocator>>::deallocate(void *, int)
.text$mn:00006974                 public ?deallocate@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@I@Z
.text$mn:00006974 ?deallocate@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@I@Z proc near
.text$mn:00006974                                         ; CODE XREF: __catch$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:00006974                                         ; std::vector<iconLocator,std::allocator<iconLocator>>::_Reallocate(uint)+FAp
.text$mn:00006974
.text$mn:00006974 var_4           = dword ptr -4
.text$mn:00006974 arg_0           = dword ptr  8
.text$mn:00006974 arg_4           = dword ptr  0Ch
.text$mn:00006974
.text$mn:00006974                 push    ebp
.text$mn:00006975                 mov     ebp, esp
.text$mn:00006977                 push    ecx
.text$mn:00006978                 mov     [ebp+var_4], ecx
.text$mn:0000697B                 mov     eax, [ebp+arg_4]
.text$mn:0000697E                 push    eax             ; int
.text$mn:0000697F                 mov     ecx, [ebp+arg_0]
.text$mn:00006982                 push    ecx             ; void *
.text$mn:00006983                 mov     ecx, [ebp+var_4]
.text$mn:00006986                 call    ?deallocate@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@I@Z ; std::allocator<iconLocator>::deallocate(iconLocator *,uint)
.text$mn:0000698B                 mov     esp, ebp
.text$mn:0000698D                 pop     ebp
.text$mn:0000698E                 retn    8
.text$mn:0000698E ?deallocate@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@I@Z endp
.text$mn:0000698E
.text$mn:0000698E ; ---------------------------------------------------------------------------
.text$mn:00006991                 align 4
.text$mn:00006991 _text$mn        ends
.text$mn:00006991
.text$mn:00006994 ; ===========================================================================
.text$mn:00006994
.text$mn:00006994 ; Segment type: Pure code
.text$mn:00006994 ; Segment permissions: Read/Execute
.text$mn:00006994 _text$mn        segment para public 'CODE' use32
.text$mn:00006994                 assume cs:_text$mn
.text$mn:00006994                 ;org 6994h
.text$mn:00006994 ; COMDAT (pick any)
.text$mn:00006994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006994
.text$mn:00006994 ; =============== S U B R O U T I N E =======================================
.text$mn:00006994
.text$mn:00006994 ; Attributes: bp-based frame
.text$mn:00006994
.text$mn:00006994 ; int __stdcall std::_Wrap_alloc<std::allocator<tDynamicList>>::deallocate(void *, int)
.text$mn:00006994                 public ?deallocate@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@I@Z
.text$mn:00006994 ?deallocate@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@I@Z proc near
.text$mn:00006994                                         ; CODE XREF: __catch$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:00006994                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reallocate(uint)+FAp
.text$mn:00006994
.text$mn:00006994 var_4           = dword ptr -4
.text$mn:00006994 arg_0           = dword ptr  8
.text$mn:00006994 arg_4           = dword ptr  0Ch
.text$mn:00006994
.text$mn:00006994                 push    ebp
.text$mn:00006995                 mov     ebp, esp
.text$mn:00006997                 push    ecx
.text$mn:00006998                 mov     [ebp+var_4], ecx
.text$mn:0000699B                 mov     eax, [ebp+arg_4]
.text$mn:0000699E                 push    eax             ; int
.text$mn:0000699F                 mov     ecx, [ebp+arg_0]
.text$mn:000069A2                 push    ecx             ; void *
.text$mn:000069A3                 mov     ecx, [ebp+var_4]
.text$mn:000069A6                 call    ?deallocate@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@I@Z ; std::allocator<tDynamicList>::deallocate(tDynamicList *,uint)
.text$mn:000069AB                 mov     esp, ebp
.text$mn:000069AD                 pop     ebp
.text$mn:000069AE                 retn    8
.text$mn:000069AE ?deallocate@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@I@Z endp
.text$mn:000069AE
.text$mn:000069AE ; ---------------------------------------------------------------------------
.text$mn:000069B1                 align 4
.text$mn:000069B1 _text$mn        ends
.text$mn:000069B1
.text$mn:000069B4 ; ===========================================================================
.text$mn:000069B4
.text$mn:000069B4 ; Segment type: Pure code
.text$mn:000069B4 ; Segment permissions: Read/Execute
.text$mn:000069B4 _text$mn        segment para public 'CODE' use32
.text$mn:000069B4                 assume cs:_text$mn
.text$mn:000069B4                 ;org 69B4h
.text$mn:000069B4 ; COMDAT (pick any)
.text$mn:000069B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000069B4
.text$mn:000069B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000069B4
.text$mn:000069B4 ; Attributes: bp-based frame
.text$mn:000069B4
.text$mn:000069B4 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:000069B4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:000069B4 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:000069B4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:000069B4
.text$mn:000069B4 var_4           = dword ptr -4
.text$mn:000069B4 arg_0           = dword ptr  8
.text$mn:000069B4 arg_4           = dword ptr  0Ch
.text$mn:000069B4
.text$mn:000069B4                 push    ebp
.text$mn:000069B5                 mov     ebp, esp
.text$mn:000069B7                 push    ecx
.text$mn:000069B8                 mov     [ebp+var_4], ecx
.text$mn:000069BB                 mov     eax, [ebp+arg_4]
.text$mn:000069BE                 push    eax             ; int
.text$mn:000069BF                 mov     ecx, [ebp+arg_0]
.text$mn:000069C2                 push    ecx             ; void *
.text$mn:000069C3                 mov     ecx, [ebp+var_4]
.text$mn:000069C6                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:000069CB                 mov     esp, ebp
.text$mn:000069CD                 pop     ebp
.text$mn:000069CE                 retn    8
.text$mn:000069CE ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:000069CE
.text$mn:000069CE ; ---------------------------------------------------------------------------
.text$mn:000069D1                 align 4
.text$mn:000069D1 _text$mn        ends
.text$mn:000069D1
.text$mn:000069D4 ; ===========================================================================
.text$mn:000069D4
.text$mn:000069D4 ; Segment type: Pure code
.text$mn:000069D4 ; Segment permissions: Read/Execute
.text$mn:000069D4 _text$mn        segment para public 'CODE' use32
.text$mn:000069D4                 assume cs:_text$mn
.text$mn:000069D4                 ;org 69D4h
.text$mn:000069D4 ; COMDAT (pick any)
.text$mn:000069D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000069D4
.text$mn:000069D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000069D4
.text$mn:000069D4 ; Attributes: bp-based frame
.text$mn:000069D4
.text$mn:000069D4 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:000069D4                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:000069D4 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:000069D4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:000069D4
.text$mn:000069D4 var_4           = dword ptr -4
.text$mn:000069D4 arg_0           = dword ptr  8
.text$mn:000069D4
.text$mn:000069D4                 push    ebp
.text$mn:000069D5                 mov     ebp, esp
.text$mn:000069D7                 push    ecx
.text$mn:000069D8                 mov     [ebp+var_4], ecx
.text$mn:000069DB                 mov     eax, [ebp+arg_0]
.text$mn:000069DE                 push    eax             ; void *
.text$mn:000069DF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000069E4                 add     esp, 4
.text$mn:000069E7                 mov     esp, ebp
.text$mn:000069E9                 pop     ebp
.text$mn:000069EA                 retn    8
.text$mn:000069EA ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:000069EA
.text$mn:000069EA ; ---------------------------------------------------------------------------
.text$mn:000069ED                 align 10h
.text$mn:000069ED _text$mn        ends
.text$mn:000069ED
.text$mn:000069F0 ; ===========================================================================
.text$mn:000069F0
.text$mn:000069F0 ; Segment type: Pure code
.text$mn:000069F0 ; Segment permissions: Read/Execute
.text$mn:000069F0 _text$mn        segment para public 'CODE' use32
.text$mn:000069F0                 assume cs:_text$mn
.text$mn:000069F0                 ;org 69F0h
.text$mn:000069F0 ; COMDAT (pick any)
.text$mn:000069F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000069F0
.text$mn:000069F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000069F0
.text$mn:000069F0 ; Attributes: bp-based frame
.text$mn:000069F0
.text$mn:000069F0 ; int __stdcall std::allocator<int>::deallocate(void *, int)
.text$mn:000069F0                 public ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
.text$mn:000069F0 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z proc near
.text$mn:000069F0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::deallocate(int *,uint)+12p
.text$mn:000069F0
.text$mn:000069F0 var_4           = dword ptr -4
.text$mn:000069F0 arg_0           = dword ptr  8
.text$mn:000069F0
.text$mn:000069F0                 push    ebp
.text$mn:000069F1                 mov     ebp, esp
.text$mn:000069F3                 push    ecx
.text$mn:000069F4                 mov     [ebp+var_4], ecx
.text$mn:000069F7                 mov     eax, [ebp+arg_0]
.text$mn:000069FA                 push    eax             ; void *
.text$mn:000069FB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00006A00                 add     esp, 4
.text$mn:00006A03                 mov     esp, ebp
.text$mn:00006A05                 pop     ebp
.text$mn:00006A06                 retn    8
.text$mn:00006A06 ?deallocate@?$allocator@H@std@@QAEXPAHI@Z endp
.text$mn:00006A06
.text$mn:00006A06 ; ---------------------------------------------------------------------------
.text$mn:00006A09                 align 4
.text$mn:00006A09 _text$mn        ends
.text$mn:00006A09
.text$mn:00006A0C ; ===========================================================================
.text$mn:00006A0C
.text$mn:00006A0C ; Segment type: Pure code
.text$mn:00006A0C ; Segment permissions: Read/Execute
.text$mn:00006A0C _text$mn        segment para public 'CODE' use32
.text$mn:00006A0C                 assume cs:_text$mn
.text$mn:00006A0C                 ;org 6A0Ch
.text$mn:00006A0C ; COMDAT (pick any)
.text$mn:00006A0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A0C
.text$mn:00006A0C ; =============== S U B R O U T I N E =======================================
.text$mn:00006A0C
.text$mn:00006A0C ; Attributes: bp-based frame
.text$mn:00006A0C
.text$mn:00006A0C ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00006A0C                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00006A0C ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00006A0C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00006A0C                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p
.text$mn:00006A0C
.text$mn:00006A0C var_4           = dword ptr -4
.text$mn:00006A0C arg_0           = dword ptr  8
.text$mn:00006A0C
.text$mn:00006A0C                 push    ebp
.text$mn:00006A0D                 mov     ebp, esp
.text$mn:00006A0F                 push    ecx
.text$mn:00006A10                 mov     [ebp+var_4], ecx
.text$mn:00006A13                 mov     eax, [ebp+arg_0]
.text$mn:00006A16                 push    eax             ; void *
.text$mn:00006A17                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00006A1C                 add     esp, 4
.text$mn:00006A1F                 mov     esp, ebp
.text$mn:00006A21                 pop     ebp
.text$mn:00006A22                 retn    8
.text$mn:00006A22 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00006A22
.text$mn:00006A22 ; ---------------------------------------------------------------------------
.text$mn:00006A25                 align 4
.text$mn:00006A25 _text$mn        ends
.text$mn:00006A25
.text$mn:00006A28 ; ===========================================================================
.text$mn:00006A28
.text$mn:00006A28 ; Segment type: Pure code
.text$mn:00006A28 ; Segment permissions: Read/Execute
.text$mn:00006A28 _text$mn        segment para public 'CODE' use32
.text$mn:00006A28                 assume cs:_text$mn
.text$mn:00006A28                 ;org 6A28h
.text$mn:00006A28 ; COMDAT (pick any)
.text$mn:00006A28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A28
.text$mn:00006A28 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A28
.text$mn:00006A28 ; Attributes: bp-based frame
.text$mn:00006A28
.text$mn:00006A28 ; int __stdcall std::allocator<iconLocator>::deallocate(void *, int)
.text$mn:00006A28                 public ?deallocate@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@I@Z
.text$mn:00006A28 ?deallocate@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@I@Z proc near
.text$mn:00006A28                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<iconLocator>>::deallocate(iconLocator *,uint)+12p
.text$mn:00006A28
.text$mn:00006A28 var_4           = dword ptr -4
.text$mn:00006A28 arg_0           = dword ptr  8
.text$mn:00006A28
.text$mn:00006A28                 push    ebp
.text$mn:00006A29                 mov     ebp, esp
.text$mn:00006A2B                 push    ecx
.text$mn:00006A2C                 mov     [ebp+var_4], ecx
.text$mn:00006A2F                 mov     eax, [ebp+arg_0]
.text$mn:00006A32                 push    eax             ; void *
.text$mn:00006A33                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00006A38                 add     esp, 4
.text$mn:00006A3B                 mov     esp, ebp
.text$mn:00006A3D                 pop     ebp
.text$mn:00006A3E                 retn    8
.text$mn:00006A3E ?deallocate@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@I@Z endp
.text$mn:00006A3E
.text$mn:00006A3E ; ---------------------------------------------------------------------------
.text$mn:00006A41                 align 4
.text$mn:00006A41 _text$mn        ends
.text$mn:00006A41
.text$mn:00006A44 ; ===========================================================================
.text$mn:00006A44
.text$mn:00006A44 ; Segment type: Pure code
.text$mn:00006A44 ; Segment permissions: Read/Execute
.text$mn:00006A44 _text$mn        segment para public 'CODE' use32
.text$mn:00006A44                 assume cs:_text$mn
.text$mn:00006A44                 ;org 6A44h
.text$mn:00006A44 ; COMDAT (pick any)
.text$mn:00006A44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A44
.text$mn:00006A44 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A44
.text$mn:00006A44 ; Attributes: bp-based frame
.text$mn:00006A44
.text$mn:00006A44 ; int __stdcall std::allocator<tDynamicList>::deallocate(void *, int)
.text$mn:00006A44                 public ?deallocate@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@I@Z
.text$mn:00006A44 ?deallocate@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@I@Z proc near
.text$mn:00006A44                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tDynamicList>>::deallocate(tDynamicList *,uint)+12p
.text$mn:00006A44
.text$mn:00006A44 var_4           = dword ptr -4
.text$mn:00006A44 arg_0           = dword ptr  8
.text$mn:00006A44
.text$mn:00006A44                 push    ebp
.text$mn:00006A45                 mov     ebp, esp
.text$mn:00006A47                 push    ecx
.text$mn:00006A48                 mov     [ebp+var_4], ecx
.text$mn:00006A4B                 mov     eax, [ebp+arg_0]
.text$mn:00006A4E                 push    eax             ; void *
.text$mn:00006A4F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00006A54                 add     esp, 4
.text$mn:00006A57                 mov     esp, ebp
.text$mn:00006A59                 pop     ebp
.text$mn:00006A5A                 retn    8
.text$mn:00006A5A ?deallocate@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@I@Z endp
.text$mn:00006A5A
.text$mn:00006A5A ; ---------------------------------------------------------------------------
.text$mn:00006A5D                 align 10h
.text$mn:00006A5D _text$mn        ends
.text$mn:00006A5D
.text$mn:00006A60 ; ===========================================================================
.text$mn:00006A60
.text$mn:00006A60 ; Segment type: Pure code
.text$mn:00006A60 ; Segment permissions: Read/Execute
.text$mn:00006A60 _text$mn        segment para public 'CODE' use32
.text$mn:00006A60                 assume cs:_text$mn
.text$mn:00006A60                 ;org 6A60h
.text$mn:00006A60 ; COMDAT (pick any)
.text$mn:00006A60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A60
.text$mn:00006A60 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A60
.text$mn:00006A60 ; Attributes: bp-based frame
.text$mn:00006A60
.text$mn:00006A60 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:00006A60                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:00006A60 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:00006A60                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:00006A60
.text$mn:00006A60 var_4           = dword ptr -4
.text$mn:00006A60 arg_0           = dword ptr  8
.text$mn:00006A60
.text$mn:00006A60                 push    ebp
.text$mn:00006A61                 mov     ebp, esp
.text$mn:00006A63                 push    ecx
.text$mn:00006A64                 mov     [ebp+var_4], ecx
.text$mn:00006A67                 mov     eax, [ebp+arg_0]
.text$mn:00006A6A                 push    eax             ; void *
.text$mn:00006A6B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00006A70                 add     esp, 4
.text$mn:00006A73                 mov     esp, ebp
.text$mn:00006A75                 pop     ebp
.text$mn:00006A76                 retn    8
.text$mn:00006A76 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:00006A76
.text$mn:00006A76 ; ---------------------------------------------------------------------------
.text$mn:00006A79                 align 4
.text$mn:00006A79 _text$mn        ends
.text$mn:00006A79
.text$mn:00006A7C ; ===========================================================================
.text$mn:00006A7C
.text$mn:00006A7C ; Segment type: Pure code
.text$mn:00006A7C ; Segment permissions: Read/Execute
.text$mn:00006A7C _text$mn        segment para public 'CODE' use32
.text$mn:00006A7C                 assume cs:_text$mn
.text$mn:00006A7C                 ;org 6A7Ch
.text$mn:00006A7C ; COMDAT (pick any)
.text$mn:00006A7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A7C
.text$mn:00006A7C ; =============== S U B R O U T I N E =======================================
.text$mn:00006A7C
.text$mn:00006A7C ; Attributes: bp-based frame
.text$mn:00006A7C
.text$mn:00006A7C ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00006A7C                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00006A7C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00006A7C                                         ; DATA XREF: .rdata:000089D8o
.text$mn:00006A7C
.text$mn:00006A7C var_4           = dword ptr -4
.text$mn:00006A7C arg_0           = dword ptr  8
.text$mn:00006A7C arg_4           = dword ptr  0Ch
.text$mn:00006A7C
.text$mn:00006A7C                 push    ebp
.text$mn:00006A7D                 mov     ebp, esp
.text$mn:00006A7F                 push    ecx
.text$mn:00006A80                 mov     [ebp+var_4], ecx
.text$mn:00006A83                 mov     eax, [ebp+arg_4]
.text$mn:00006A86                 push    eax             ; int
.text$mn:00006A87                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00006A8C                 add     esp, 4
.text$mn:00006A8F                 test    eax, eax
.text$mn:00006A91                 jz      short loc_6AAC
.text$mn:00006A93                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00006A98                 push    eax             ; struct std::error_category *
.text$mn:00006A99                 mov     ecx, [ebp+arg_4]
.text$mn:00006A9C                 push    ecx             ; int
.text$mn:00006A9D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006AA0                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00006AA5                 mov     eax, [ebp+arg_0]
.text$mn:00006AA8                 jmp     short loc_6AC1
.text$mn:00006AAA ; ---------------------------------------------------------------------------
.text$mn:00006AAA                 jmp     short loc_6AC1
.text$mn:00006AAC ; ---------------------------------------------------------------------------
.text$mn:00006AAC
.text$mn:00006AAC loc_6AAC:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00006AAC                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00006AB1                 push    eax             ; struct std::error_category *
.text$mn:00006AB2                 mov     edx, [ebp+arg_4]
.text$mn:00006AB5                 push    edx             ; int
.text$mn:00006AB6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006AB9                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00006ABE                 mov     eax, [ebp+arg_0]
.text$mn:00006AC1
.text$mn:00006AC1 loc_6AC1:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00006AC1                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00006AC1                 mov     esp, ebp
.text$mn:00006AC3                 pop     ebp
.text$mn:00006AC4                 retn    8
.text$mn:00006AC4 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00006AC4
.text$mn:00006AC4 ; ---------------------------------------------------------------------------
.text$mn:00006AC7                 align 4
.text$mn:00006AC7 _text$mn        ends
.text$mn:00006AC7
.text$mn:00006AC8 ; ===========================================================================
.text$mn:00006AC8
.text$mn:00006AC8 ; Segment type: Pure code
.text$mn:00006AC8 ; Segment permissions: Read/Execute
.text$mn:00006AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00006AC8                 assume cs:_text$mn
.text$mn:00006AC8                 ;org 6AC8h
.text$mn:00006AC8 ; COMDAT (pick any)
.text$mn:00006AC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006AC8
.text$mn:00006AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006AC8
.text$mn:00006AC8 ; Attributes: bp-based frame
.text$mn:00006AC8
.text$mn:00006AC8 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00006AC8                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00006AC8 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00006AC8                                         ; DATA XREF: .rdata:00008948o
.text$mn:00006AC8                                         ; .rdata:00008964o ...
.text$mn:00006AC8
.text$mn:00006AC8 var_4           = dword ptr -4
.text$mn:00006AC8 arg_0           = dword ptr  8
.text$mn:00006AC8 arg_4           = dword ptr  0Ch
.text$mn:00006AC8
.text$mn:00006AC8                 push    ebp
.text$mn:00006AC9                 mov     ebp, esp
.text$mn:00006ACB                 push    ecx
.text$mn:00006ACC                 mov     [ebp+var_4], ecx
.text$mn:00006ACF                 mov     eax, [ebp+var_4]
.text$mn:00006AD2                 push    eax             ; struct std::error_category *
.text$mn:00006AD3                 mov     ecx, [ebp+arg_4]
.text$mn:00006AD6                 push    ecx             ; int
.text$mn:00006AD7                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006ADA                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00006ADF                 mov     eax, [ebp+arg_0]
.text$mn:00006AE2                 mov     esp, ebp
.text$mn:00006AE4                 pop     ebp
.text$mn:00006AE5                 retn    8
.text$mn:00006AE5 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00006AE5
.text$mn:00006AE5 _text$mn        ends
.text$mn:00006AE5
.text$mn:00006AE8 ; ===========================================================================
.text$mn:00006AE8
.text$mn:00006AE8 ; Segment type: Pure code
.text$mn:00006AE8 ; Segment permissions: Read/Execute
.text$mn:00006AE8 _text$mn        segment para public 'CODE' use32
.text$mn:00006AE8                 assume cs:_text$mn
.text$mn:00006AE8                 ;org 6AE8h
.text$mn:00006AE8 ; COMDAT (pick any)
.text$mn:00006AE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006AE8
.text$mn:00006AE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006AE8
.text$mn:00006AE8 ; Attributes: bp-based frame
.text$mn:00006AE8
.text$mn:00006AE8 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00006AE8                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00006AE8 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00006AE8                                         ; DATA XREF: .rdata:0000894Co
.text$mn:00006AE8                                         ; .rdata:00008968o ...
.text$mn:00006AE8
.text$mn:00006AE8 var_8           = dword ptr -8
.text$mn:00006AE8 var_4           = dword ptr -4
.text$mn:00006AE8 arg_0           = dword ptr  8
.text$mn:00006AE8 arg_4           = dword ptr  0Ch
.text$mn:00006AE8
.text$mn:00006AE8                 push    ebp
.text$mn:00006AE9                 mov     ebp, esp
.text$mn:00006AEB                 sub     esp, 8
.text$mn:00006AEE                 mov     [ebp+var_8], ecx
.text$mn:00006AF1                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006AF4                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00006AF9                 push    eax
.text$mn:00006AFA                 mov     ecx, [ebp+var_8]
.text$mn:00006AFD                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00006B02                 movzx   eax, al
.text$mn:00006B05                 test    eax, eax
.text$mn:00006B07                 jz      short loc_6B1F
.text$mn:00006B09                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006B0C                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00006B11                 cmp     eax, [ebp+arg_4]
.text$mn:00006B14                 jnz     short loc_6B1F
.text$mn:00006B16                 mov     [ebp+var_4], 1
.text$mn:00006B1D                 jmp     short loc_6B26
.text$mn:00006B1F ; ---------------------------------------------------------------------------
.text$mn:00006B1F
.text$mn:00006B1F loc_6B1F:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00006B1F                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00006B1F                 mov     [ebp+var_4], 0
.text$mn:00006B26
.text$mn:00006B26 loc_6B26:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00006B26                 mov     al, byte ptr [ebp+var_4]
.text$mn:00006B29                 mov     esp, ebp
.text$mn:00006B2B                 pop     ebp
.text$mn:00006B2C                 retn    8
.text$mn:00006B2C ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00006B2C
.text$mn:00006B2C ; ---------------------------------------------------------------------------
.text$mn:00006B2F                 align 10h
.text$mn:00006B2F _text$mn        ends
.text$mn:00006B2F
.text$mn:00006B30 ; ===========================================================================
.text$mn:00006B30
.text$mn:00006B30 ; Segment type: Pure code
.text$mn:00006B30 ; Segment permissions: Read/Execute
.text$mn:00006B30 _text$mn        segment para public 'CODE' use32
.text$mn:00006B30                 assume cs:_text$mn
.text$mn:00006B30                 ;org 6B30h
.text$mn:00006B30 ; COMDAT (pick any)
.text$mn:00006B30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B30
.text$mn:00006B30 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B30
.text$mn:00006B30 ; Attributes: bp-based frame
.text$mn:00006B30
.text$mn:00006B30 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00006B30                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00006B30 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00006B30                                         ; DATA XREF: .rdata:00008950o
.text$mn:00006B30                                         ; .rdata:0000896Co ...
.text$mn:00006B30
.text$mn:00006B30 var_C           = byte ptr -0Ch
.text$mn:00006B30 var_4           = dword ptr -4
.text$mn:00006B30 arg_0           = dword ptr  8
.text$mn:00006B30 arg_4           = dword ptr  0Ch
.text$mn:00006B30
.text$mn:00006B30                 push    ebp
.text$mn:00006B31                 mov     ebp, esp
.text$mn:00006B33                 sub     esp, 0Ch
.text$mn:00006B36                 mov     [ebp+var_4], ecx
.text$mn:00006B39                 mov     eax, [ebp+arg_4]
.text$mn:00006B3C                 push    eax             ; std::error_condition *
.text$mn:00006B3D                 mov     ecx, [ebp+arg_0]
.text$mn:00006B40                 push    ecx
.text$mn:00006B41                 lea     edx, [ebp+var_C]
.text$mn:00006B44                 push    edx
.text$mn:00006B45                 mov     eax, [ebp+var_4]
.text$mn:00006B48                 mov     edx, [eax]
.text$mn:00006B4A                 mov     ecx, [ebp+var_4]
.text$mn:00006B4D                 mov     eax, [edx+0Ch]
.text$mn:00006B50                 call    eax
.text$mn:00006B52                 mov     ecx, eax
.text$mn:00006B54                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00006B59                 mov     esp, ebp
.text$mn:00006B5B                 pop     ebp
.text$mn:00006B5C                 retn    8
.text$mn:00006B5C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00006B5C
.text$mn:00006B5C ; ---------------------------------------------------------------------------
.text$mn:00006B5F                 align 10h
.text$mn:00006B5F _text$mn        ends
.text$mn:00006B5F
.text$mn:00006B60 ; ===========================================================================
.text$mn:00006B60
.text$mn:00006B60 ; Segment type: Pure code
.text$mn:00006B60 ; Segment permissions: Read/Execute
.text$mn:00006B60 _text$mn        segment para public 'CODE' use32
.text$mn:00006B60                 assume cs:_text$mn
.text$mn:00006B60                 ;org 6B60h
.text$mn:00006B60 ; COMDAT (pick any)
.text$mn:00006B60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B60
.text$mn:00006B60 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B60
.text$mn:00006B60 ; Attributes: bp-based frame
.text$mn:00006B60
.text$mn:00006B60 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00006B60                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00006B60 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00006B60                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00006B60
.text$mn:00006B60 var_4           = dword ptr -4
.text$mn:00006B60 arg_0           = dword ptr  8
.text$mn:00006B60
.text$mn:00006B60                 push    ebp
.text$mn:00006B61                 mov     ebp, esp
.text$mn:00006B63                 push    ecx
.text$mn:00006B64                 mov     [ebp+var_4], ecx
.text$mn:00006B67                 mov     eax, [ebp+var_4]
.text$mn:00006B6A                 mov     ecx, [eax+14h]
.text$mn:00006B6D                 cmp     ecx, [ebp+arg_0]
.text$mn:00006B70                 jnb     short loc_6B7A
.text$mn:00006B72                 mov     ecx, [ebp+var_4]
.text$mn:00006B75                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00006B7A
.text$mn:00006B7A loc_6B7A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00006B7A                 mov     edx, [ebp+arg_0]
.text$mn:00006B7D                 push    edx
.text$mn:00006B7E                 mov     ecx, [ebp+var_4]
.text$mn:00006B81                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00006B86                 mov     eax, [ebp+var_4]
.text$mn:00006B89                 mov     esp, ebp
.text$mn:00006B8B                 pop     ebp
.text$mn:00006B8C                 retn    4
.text$mn:00006B8C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00006B8C
.text$mn:00006B8C ; ---------------------------------------------------------------------------
.text$mn:00006B8F                 align 10h
.text$mn:00006B8F _text$mn        ends
.text$mn:00006B8F
.text$mn:00006B90 ; ===========================================================================
.text$mn:00006B90
.text$mn:00006B90 ; Segment type: Pure code
.text$mn:00006B90 ; Segment permissions: Read/Execute
.text$mn:00006B90 _text$mn        segment para public 'CODE' use32
.text$mn:00006B90                 assume cs:_text$mn
.text$mn:00006B90                 ;org 6B90h
.text$mn:00006B90 ; COMDAT (pick any)
.text$mn:00006B90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B90
.text$mn:00006B90 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B90
.text$mn:00006B90 ; Attributes: bp-based frame
.text$mn:00006B90
.text$mn:00006B90 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00006B90                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00006B90 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00006B90                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00006B90
.text$mn:00006B90 var_C           = dword ptr -0Ch
.text$mn:00006B90 Dst             = dword ptr -8
.text$mn:00006B90 var_4           = dword ptr -4
.text$mn:00006B90 arg_0           = dword ptr  8
.text$mn:00006B90 arg_4           = dword ptr  0Ch
.text$mn:00006B90
.text$mn:00006B90                 push    ebp
.text$mn:00006B91                 mov     ebp, esp
.text$mn:00006B93                 sub     esp, 0Ch
.text$mn:00006B96                 mov     [ebp+var_4], ecx
.text$mn:00006B99                 mov     eax, [ebp+var_4]
.text$mn:00006B9C                 mov     ecx, [eax+14h]
.text$mn:00006B9F                 cmp     ecx, [ebp+arg_0]
.text$mn:00006BA2                 jnb     short loc_6BAC
.text$mn:00006BA4                 mov     ecx, [ebp+var_4]
.text$mn:00006BA7                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00006BAC
.text$mn:00006BAC loc_6BAC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00006BAC                 mov     edx, [ebp+var_4]
.text$mn:00006BAF                 mov     eax, [edx+14h]
.text$mn:00006BB2                 sub     eax, [ebp+arg_0]
.text$mn:00006BB5                 cmp     eax, [ebp+arg_4]
.text$mn:00006BB8                 ja      short loc_6BC8
.text$mn:00006BBA                 mov     ecx, [ebp+arg_0]
.text$mn:00006BBD                 push    ecx
.text$mn:00006BBE                 mov     ecx, [ebp+var_4]
.text$mn:00006BC1                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00006BC6                 jmp     short loc_6C0E
.text$mn:00006BC8 ; ---------------------------------------------------------------------------
.text$mn:00006BC8
.text$mn:00006BC8 loc_6BC8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00006BC8                 cmp     [ebp+arg_4], 0
.text$mn:00006BCC                 jbe     short loc_6C0E
.text$mn:00006BCE                 mov     ecx, [ebp+var_4]
.text$mn:00006BD1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006BD6                 add     eax, [ebp+arg_0]
.text$mn:00006BD9                 mov     [ebp+Dst], eax
.text$mn:00006BDC                 mov     edx, [ebp+var_4]
.text$mn:00006BDF                 mov     eax, [edx+14h]
.text$mn:00006BE2                 sub     eax, [ebp+arg_4]
.text$mn:00006BE5                 mov     [ebp+var_C], eax
.text$mn:00006BE8                 mov     ecx, [ebp+var_C]
.text$mn:00006BEB                 sub     ecx, [ebp+arg_0]
.text$mn:00006BEE                 push    ecx             ; Size
.text$mn:00006BEF                 mov     edx, [ebp+Dst]
.text$mn:00006BF2                 add     edx, [ebp+arg_4]
.text$mn:00006BF5                 push    edx             ; Src
.text$mn:00006BF6                 mov     eax, [ebp+Dst]
.text$mn:00006BF9                 push    eax             ; Dst
.text$mn:00006BFA                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00006BFF                 add     esp, 0Ch
.text$mn:00006C02                 mov     ecx, [ebp+var_C]
.text$mn:00006C05                 push    ecx
.text$mn:00006C06                 mov     ecx, [ebp+var_4]
.text$mn:00006C09                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00006C0E
.text$mn:00006C0E loc_6C0E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00006C0E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00006C0E                 mov     eax, [ebp+var_4]
.text$mn:00006C11                 mov     esp, ebp
.text$mn:00006C13                 pop     ebp
.text$mn:00006C14                 retn    8
.text$mn:00006C14 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00006C14
.text$mn:00006C14 ; ---------------------------------------------------------------------------
.text$mn:00006C17                 align 4
.text$mn:00006C17 _text$mn        ends
.text$mn:00006C17
.text$mn:00006C18 ; ===========================================================================
.text$mn:00006C18
.text$mn:00006C18 ; Segment type: Pure code
.text$mn:00006C18 ; Segment permissions: Read/Execute
.text$mn:00006C18 _text$mn        segment para public 'CODE' use32
.text$mn:00006C18                 assume cs:_text$mn
.text$mn:00006C18                 ;org 6C18h
.text$mn:00006C18 ; COMDAT (pick any)
.text$mn:00006C18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C18
.text$mn:00006C18 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C18
.text$mn:00006C18 ; Attributes: bp-based frame
.text$mn:00006C18
.text$mn:00006C18 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:00006C18                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:00006C18 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00006C18                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:00006C18
.text$mn:00006C18 var_4           = dword ptr -4
.text$mn:00006C18 arg_0           = dword ptr  8
.text$mn:00006C18
.text$mn:00006C18                 push    ebp
.text$mn:00006C19                 mov     ebp, esp
.text$mn:00006C1B                 push    ecx
.text$mn:00006C1C                 mov     [ebp+var_4], ecx
.text$mn:00006C1F                 mov     eax, [ebp+var_4]
.text$mn:00006C22                 mov     ecx, [eax+14h]
.text$mn:00006C25                 cmp     ecx, [ebp+arg_0]
.text$mn:00006C28                 jnb     short loc_6C32
.text$mn:00006C2A                 mov     ecx, [ebp+var_4]
.text$mn:00006C2D                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00006C32
.text$mn:00006C32 loc_6C32:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:00006C32                 mov     edx, [ebp+arg_0]
.text$mn:00006C35                 push    edx
.text$mn:00006C36                 mov     ecx, [ebp+var_4]
.text$mn:00006C39                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00006C3E                 mov     eax, [ebp+var_4]
.text$mn:00006C41                 mov     esp, ebp
.text$mn:00006C43                 pop     ebp
.text$mn:00006C44                 retn    4
.text$mn:00006C44 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:00006C44
.text$mn:00006C44 ; ---------------------------------------------------------------------------
.text$mn:00006C47                 align 4
.text$mn:00006C47 _text$mn        ends
.text$mn:00006C47
.text$mn:00006C48 ; ===========================================================================
.text$mn:00006C48
.text$mn:00006C48 ; Segment type: Pure code
.text$mn:00006C48 ; Segment permissions: Read/Execute
.text$mn:00006C48 _text$mn        segment para public 'CODE' use32
.text$mn:00006C48                 assume cs:_text$mn
.text$mn:00006C48                 ;org 6C48h
.text$mn:00006C48 ; COMDAT (pick any)
.text$mn:00006C48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C48
.text$mn:00006C48 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C48
.text$mn:00006C48 ; Attributes: bp-based frame
.text$mn:00006C48
.text$mn:00006C48 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:00006C48                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:00006C48 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00006C48                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:00006C48
.text$mn:00006C48 var_C           = dword ptr -0Ch
.text$mn:00006C48 Dst             = dword ptr -8
.text$mn:00006C48 var_4           = dword ptr -4
.text$mn:00006C48 arg_0           = dword ptr  8
.text$mn:00006C48 arg_4           = dword ptr  0Ch
.text$mn:00006C48
.text$mn:00006C48                 push    ebp
.text$mn:00006C49                 mov     ebp, esp
.text$mn:00006C4B                 sub     esp, 0Ch
.text$mn:00006C4E                 mov     [ebp+var_4], ecx
.text$mn:00006C51                 mov     eax, [ebp+var_4]
.text$mn:00006C54                 mov     ecx, [eax+14h]
.text$mn:00006C57                 cmp     ecx, [ebp+arg_0]
.text$mn:00006C5A                 jnb     short loc_6C64
.text$mn:00006C5C                 mov     ecx, [ebp+var_4]
.text$mn:00006C5F                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00006C64
.text$mn:00006C64 loc_6C64:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:00006C64                 mov     edx, [ebp+var_4]
.text$mn:00006C67                 mov     eax, [edx+14h]
.text$mn:00006C6A                 sub     eax, [ebp+arg_0]
.text$mn:00006C6D                 cmp     eax, [ebp+arg_4]
.text$mn:00006C70                 ja      short loc_6C80
.text$mn:00006C72                 mov     ecx, [ebp+arg_0]
.text$mn:00006C75                 push    ecx
.text$mn:00006C76                 mov     ecx, [ebp+var_4]
.text$mn:00006C79                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00006C7E                 jmp     short loc_6CCC
.text$mn:00006C80 ; ---------------------------------------------------------------------------
.text$mn:00006C80
.text$mn:00006C80 loc_6C80:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:00006C80                 cmp     [ebp+arg_4], 0
.text$mn:00006C84                 jbe     short loc_6CCC
.text$mn:00006C86                 mov     ecx, [ebp+var_4]
.text$mn:00006C89                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00006C8E                 mov     edx, [ebp+arg_0]
.text$mn:00006C91                 lea     eax, [eax+edx*2]
.text$mn:00006C94                 mov     [ebp+Dst], eax
.text$mn:00006C97                 mov     ecx, [ebp+var_4]
.text$mn:00006C9A                 mov     edx, [ecx+14h]
.text$mn:00006C9D                 sub     edx, [ebp+arg_4]
.text$mn:00006CA0                 mov     [ebp+var_C], edx
.text$mn:00006CA3                 mov     eax, [ebp+var_C]
.text$mn:00006CA6                 sub     eax, [ebp+arg_0]
.text$mn:00006CA9                 push    eax             ; int
.text$mn:00006CAA                 mov     ecx, [ebp+arg_4]
.text$mn:00006CAD                 mov     edx, [ebp+Dst]
.text$mn:00006CB0                 lea     eax, [edx+ecx*2]
.text$mn:00006CB3                 push    eax             ; Src
.text$mn:00006CB4                 mov     ecx, [ebp+Dst]
.text$mn:00006CB7                 push    ecx             ; Dst
.text$mn:00006CB8                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00006CBD                 add     esp, 0Ch
.text$mn:00006CC0                 mov     edx, [ebp+var_C]
.text$mn:00006CC3                 push    edx
.text$mn:00006CC4                 mov     ecx, [ebp+var_4]
.text$mn:00006CC7                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00006CCC
.text$mn:00006CCC loc_6CCC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:00006CCC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:00006CCC                 mov     eax, [ebp+var_4]
.text$mn:00006CCF                 mov     esp, ebp
.text$mn:00006CD1                 pop     ebp
.text$mn:00006CD2                 retn    8
.text$mn:00006CD2 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:00006CD2
.text$mn:00006CD2 ; ---------------------------------------------------------------------------
.text$mn:00006CD5                 align 4
.text$mn:00006CD5 _text$mn        ends
.text$mn:00006CD5
.text$mn:00006CD8 ; ===========================================================================
.text$mn:00006CD8
.text$mn:00006CD8 ; Segment type: Pure code
.text$mn:00006CD8 ; Segment permissions: Read/Execute
.text$mn:00006CD8 _text$mn        segment para public 'CODE' use32
.text$mn:00006CD8                 assume cs:_text$mn
.text$mn:00006CD8                 ;org 6CD8h
.text$mn:00006CD8 ; COMDAT (pick any)
.text$mn:00006CD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006CD8
.text$mn:00006CD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006CD8
.text$mn:00006CD8 ; Attributes: bp-based frame
.text$mn:00006CD8
.text$mn:00006CD8 ; int __stdcall std::vector<int,std::allocator<int>>::erase(int, char, int, void *Dst)
.text$mn:00006CD8                 public ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z
.text$mn:00006CD8 ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z proc near
.text$mn:00006CD8                                         ; CODE XREF: ReBar::releaseID(int)+D6p
.text$mn:00006CD8
.text$mn:00006CD8 var_24          = dword ptr -24h
.text$mn:00006CD8 var_20          = dword ptr -20h
.text$mn:00006CD8 var_1C          = dword ptr -1Ch
.text$mn:00006CD8 var_18          = dword ptr -18h
.text$mn:00006CD8 var_14          = dword ptr -14h
.text$mn:00006CD8 var_10          = dword ptr -10h
.text$mn:00006CD8 var_C           = dword ptr -0Ch
.text$mn:00006CD8 var_4           = dword ptr -4
.text$mn:00006CD8 arg_0           = dword ptr  8
.text$mn:00006CD8 arg_4           = byte ptr  0Ch
.text$mn:00006CD8 Dst             = dword ptr  14h
.text$mn:00006CD8
.text$mn:00006CD8                 push    ebp
.text$mn:00006CD9                 mov     ebp, esp
.text$mn:00006CDB                 push    0FFFFFFFFh
.text$mn:00006CDD                 push    offset __ehhandler$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z
.text$mn:00006CE2                 mov     eax, large fs:0
.text$mn:00006CE8                 push    eax
.text$mn:00006CE9                 sub     esp, 18h
.text$mn:00006CEC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006CF1                 xor     eax, ebp
.text$mn:00006CF3                 push    eax
.text$mn:00006CF4                 lea     eax, [ebp+var_C]
.text$mn:00006CF7                 mov     large fs:0, eax
.text$mn:00006CFD                 mov     [ebp+var_10], ecx
.text$mn:00006D00                 mov     [ebp+var_14], 0
.text$mn:00006D07                 mov     [ebp+var_4], 1
.text$mn:00006D0E                 lea     ecx, [ebp+arg_4] ; this
.text$mn:00006D11                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00006D16                 cmp     eax, [ebp+var_10]
.text$mn:00006D19                 jnz     short loc_6D31
.text$mn:00006D1B                 mov     eax, [ebp+var_10]
.text$mn:00006D1E                 mov     ecx, [ebp+Dst]
.text$mn:00006D21                 cmp     ecx, [eax+4]
.text$mn:00006D24                 jb      short loc_6D31
.text$mn:00006D26                 mov     edx, [ebp+var_10]
.text$mn:00006D29                 mov     eax, [edx+8]
.text$mn:00006D2C                 cmp     eax, [ebp+Dst]
.text$mn:00006D2F                 ja      short loc_6D48
.text$mn:00006D31
.text$mn:00006D31 loc_6D31:                               ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+41j
.text$mn:00006D31                                         ; std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+4Cj
.text$mn:00006D31                 push    5A2h            ; unsigned int
.text$mn:00006D36                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006D3B                 push    offset ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ ; "vector erase iterator outside range"
.text$mn:00006D40                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00006D45                 add     esp, 0Ch
.text$mn:00006D48
.text$mn:00006D48 loc_6D48:                               ; CODE XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+57j
.text$mn:00006D48                 mov     ecx, [ebp+Dst]
.text$mn:00006D4B                 push    ecx             ; Dst
.text$mn:00006D4C                 mov     edx, [ebp+var_10]
.text$mn:00006D4F                 mov     eax, [edx+8]
.text$mn:00006D52                 push    eax             ; int
.text$mn:00006D53                 mov     ecx, [ebp+Dst]
.text$mn:00006D56                 add     ecx, 4
.text$mn:00006D59                 push    ecx             ; Src
.text$mn:00006D5A                 call    ??$_Move@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move<int *,int *>(int *,int *,int *)
.text$mn:00006D5F                 add     esp, 0Ch
.text$mn:00006D62                 mov     edx, [ebp+var_10]
.text$mn:00006D65                 mov     eax, [edx+8]
.text$mn:00006D68                 push    eax
.text$mn:00006D69                 mov     ecx, [ebp+var_10]
.text$mn:00006D6C                 mov     edx, [ecx+8]
.text$mn:00006D6F                 sub     edx, 4
.text$mn:00006D72                 push    edx
.text$mn:00006D73                 mov     ecx, [ebp+var_10]
.text$mn:00006D76                 call    ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Destroy(int *,int *)
.text$mn:00006D7B                 mov     eax, [ebp+var_10]
.text$mn:00006D7E                 mov     ecx, [eax+8]
.text$mn:00006D81                 push    ecx
.text$mn:00006D82                 mov     edx, [ebp+Dst]
.text$mn:00006D85                 push    edx
.text$mn:00006D86                 mov     ecx, [ebp+var_10]
.text$mn:00006D89                 call    ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)
.text$mn:00006D8E                 mov     eax, [ebp+var_10]
.text$mn:00006D91                 mov     ecx, [eax+8]
.text$mn:00006D94                 sub     ecx, 4
.text$mn:00006D97                 mov     edx, [ebp+var_10]
.text$mn:00006D9A                 mov     [edx+8], ecx
.text$mn:00006D9D                 sub     esp, 0Ch
.text$mn:00006DA0                 mov     ecx, esp
.text$mn:00006DA2                 mov     [ebp+var_1C], esp
.text$mn:00006DA5                 lea     eax, [ebp+arg_4]
.text$mn:00006DA8                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00006DA9                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>> const &)
.text$mn:00006DAE                 mov     [ebp+var_18], eax
.text$mn:00006DB1                 mov     ecx, [ebp+var_18]
.text$mn:00006DB4                 mov     [ebp+var_20], ecx
.text$mn:00006DB7                 mov     byte ptr [ebp+var_4], 2
.text$mn:00006DBB                 mov     edx, [ebp+arg_0]
.text$mn:00006DBE                 push    edx
.text$mn:00006DBF                 mov     byte ptr [ebp+var_4], 1
.text$mn:00006DC3                 mov     ecx, [ebp+var_10]
.text$mn:00006DC6                 call    ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z ; std::vector<int,std::allocator<int>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)
.text$mn:00006DCB                 mov     [ebp+var_24], eax
.text$mn:00006DCE                 mov     eax, [ebp+var_14]
.text$mn:00006DD1                 or      eax, 1
.text$mn:00006DD4                 mov     [ebp+var_14], eax
.text$mn:00006DD7                 mov     byte ptr [ebp+var_4], 0
.text$mn:00006DDB                 lea     ecx, [ebp+arg_4]
.text$mn:00006DDE                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$mn:00006DE3                 mov     eax, [ebp+arg_0]
.text$mn:00006DE6                 mov     ecx, [ebp+var_C]
.text$mn:00006DE9                 mov     large fs:0, ecx
.text$mn:00006DF0                 pop     ecx
.text$mn:00006DF1                 mov     esp, ebp
.text$mn:00006DF3                 pop     ebp
.text$mn:00006DF4                 retn    10h
.text$mn:00006DF4 ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z endp
.text$mn:00006DF4
.text$mn:00006DF4 ; ---------------------------------------------------------------------------
.text$mn:00006DF7                 align 4
.text$mn:00006DF7 _text$mn        ends
.text$mn:00006DF7
.text$x:00006DF8 ; ===========================================================================
.text$x:00006DF8
.text$x:00006DF8 ; Segment type: Pure code
.text$x:00006DF8 ; Segment permissions: Read/Execute
.text$x:00006DF8 _text$x         segment para public 'CODE' use32
.text$x:00006DF8                 assume cs:_text$x
.text$x:00006DF8                 ;org 6DF8h
.text$x:00006DF8 ; COMDAT (pick associative to section at 6CD8)
.text$x:00006DF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006DF8
.text$x:00006DF8 ; =============== S U B R O U T I N E =======================================
.text$x:00006DF8
.text$x:00006DF8
.text$x:00006DF8 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$0 proc near
.text$x:00006DF8                                         ; DATA XREF: .xdata$x:0000837Co
.text$x:00006DF8                 lea     ecx, [ebp+0Ch]
.text$x:00006DFB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006DFB __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$0 endp
.text$x:00006DFB
.text$x:00006E00
.text$x:00006E00 ; =============== S U B R O U T I N E =======================================
.text$x:00006E00
.text$x:00006E00
.text$x:00006E00 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$1 proc near
.text$x:00006E00                                         ; DATA XREF: .xdata$x:00008384o
.text$x:00006E00                 mov     ecx, [ebp-1Ch]
.text$x:00006E03                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006E03 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$1 endp
.text$x:00006E03
.text$x:00006E08
.text$x:00006E08 ; =============== S U B R O U T I N E =======================================
.text$x:00006E08
.text$x:00006E08
.text$x:00006E08 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$2 proc near
.text$x:00006E08                                         ; DATA XREF: .xdata$x:00008374o
.text$x:00006E08                 mov     eax, [ebp-14h]
.text$x:00006E0B                 and     eax, 1
.text$x:00006E0E                 jz      $LN8_1
.text$x:00006E14                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00006E18                 mov     ecx, [ebp+8]
.text$x:00006E1B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int>>>(void)
.text$x:00006E20 ; ---------------------------------------------------------------------------
.text$x:00006E20
.text$x:00006E20 $LN8_1:                                 ; CODE XREF: __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$2+6j
.text$x:00006E20                 retn
.text$x:00006E20 __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$2 endp
.text$x:00006E20
.text$x:00006E21
.text$x:00006E21 ; =============== S U B R O U T I N E =======================================
.text$x:00006E21
.text$x:00006E21
.text$x:00006E21 __ehhandler$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z proc near
.text$x:00006E21                                         ; DATA XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+5o
.text$x:00006E21
.text$x:00006E21 arg_4           = dword ptr  8
.text$x:00006E21
.text$x:00006E21                 mov     edx, [esp+arg_4]
.text$x:00006E25                 lea     eax, [edx+0Ch]
.text$x:00006E28                 mov     ecx, [edx-1Ch]
.text$x:00006E2B                 xor     ecx, eax
.text$x:00006E2D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006E32                 mov     eax, offset __ehfuncinfo$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z
.text$x:00006E37                 jmp     ___CxxFrameHandler3
.text$x:00006E37 __ehhandler$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z endp
.text$x:00006E37
.text$x:00006E37 _text$x         ends
.text$x:00006E37
.text$mn:00006E3C ; ===========================================================================
.text$mn:00006E3C
.text$mn:00006E3C ; Segment type: Pure code
.text$mn:00006E3C ; Segment permissions: Read/Execute
.text$mn:00006E3C _text$mn        segment para public 'CODE' use32
.text$mn:00006E3C                 assume cs:_text$mn
.text$mn:00006E3C                 ;org 6E3Ch
.text$mn:00006E3C ; COMDAT (pick any)
.text$mn:00006E3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E3C
.text$mn:00006E3C ; =============== S U B R O U T I N E =======================================
.text$mn:00006E3C
.text$mn:00006E3C ; Attributes: bp-based frame
.text$mn:00006E3C
.text$mn:00006E3C ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00006E3C                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00006E3C ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00006E3C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00006E3C                 push    ebp
.text$mn:00006E3D                 mov     ebp, esp
.text$mn:00006E3F                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00006E44                 pop     ebp
.text$mn:00006E45                 retn
.text$mn:00006E45 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00006E45
.text$mn:00006E45 ; ---------------------------------------------------------------------------
.text$mn:00006E46                 align 4
.text$mn:00006E46 _text$mn        ends
.text$mn:00006E46
.text$mn:00006E48 ; ===========================================================================
.text$mn:00006E48
.text$mn:00006E48 ; Segment type: Pure code
.text$mn:00006E48 ; Segment permissions: Read/Execute
.text$mn:00006E48 _text$mn        segment para public 'CODE' use32
.text$mn:00006E48                 assume cs:_text$mn
.text$mn:00006E48                 ;org 6E48h
.text$mn:00006E48 ; COMDAT (pick any)
.text$mn:00006E48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E48
.text$mn:00006E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00006E48
.text$mn:00006E48 ; Attributes: bp-based frame
.text$mn:00006E48
.text$mn:00006E48 ; struct _IMAGELIST *__thiscall ToolBarIcons::getDefaultLst(ToolBarIcons *__hidden this)
.text$mn:00006E48                 public ?getDefaultLst@ToolBarIcons@@QBEPAU_IMAGELIST@@XZ
.text$mn:00006E48 ?getDefaultLst@ToolBarIcons@@QBEPAU_IMAGELIST@@XZ proc near
.text$mn:00006E48                                         ; CODE XREF: ToolBar::setDefaultImageList(void)+Dp
.text$mn:00006E48
.text$mn:00006E48 var_4           = dword ptr -4
.text$mn:00006E48
.text$mn:00006E48                 push    ebp
.text$mn:00006E49                 mov     ebp, esp
.text$mn:00006E4B                 push    ecx
.text$mn:00006E4C                 mov     [ebp+var_4], ecx
.text$mn:00006E4F                 push    0               ; int
.text$mn:00006E51                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006E54                 call    ?getImageListHandle@IconLists@@QBEPAU_IMAGELIST@@H@Z ; IconLists::getImageListHandle(int)
.text$mn:00006E59                 mov     esp, ebp
.text$mn:00006E5B                 pop     ebp
.text$mn:00006E5C                 retn
.text$mn:00006E5C ?getDefaultLst@ToolBarIcons@@QBEPAU_IMAGELIST@@XZ endp
.text$mn:00006E5C
.text$mn:00006E5C ; ---------------------------------------------------------------------------
.text$mn:00006E5D                 align 10h
.text$mn:00006E5D _text$mn        ends
.text$mn:00006E5D
.text$mn:00006E60 ; ===========================================================================
.text$mn:00006E60
.text$mn:00006E60 ; Segment type: Pure code
.text$mn:00006E60 ; Segment permissions: Read/Execute
.text$mn:00006E60 _text$mn        segment para public 'CODE' use32
.text$mn:00006E60                 assume cs:_text$mn
.text$mn:00006E60                 ;org 6E60h
.text$mn:00006E60 ; COMDAT (pick any)
.text$mn:00006E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E60
.text$mn:00006E60 ; =============== S U B R O U T I N E =======================================
.text$mn:00006E60
.text$mn:00006E60 ; Attributes: bp-based frame
.text$mn:00006E60
.text$mn:00006E60 ; struct _IMAGELIST *__thiscall ToolBarIcons::getDisableLst(ToolBarIcons *__hidden this)
.text$mn:00006E60                 public ?getDisableLst@ToolBarIcons@@QBEPAU_IMAGELIST@@XZ
.text$mn:00006E60 ?getDisableLst@ToolBarIcons@@QBEPAU_IMAGELIST@@XZ proc near
.text$mn:00006E60                                         ; CODE XREF: ToolBar::setDisableImageList(void)+Dp
.text$mn:00006E60
.text$mn:00006E60 var_4           = dword ptr -4
.text$mn:00006E60
.text$mn:00006E60                 push    ebp
.text$mn:00006E61                 mov     ebp, esp
.text$mn:00006E63                 push    ecx
.text$mn:00006E64                 mov     [ebp+var_4], ecx
.text$mn:00006E67                 push    2               ; int
.text$mn:00006E69                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006E6C                 call    ?getImageListHandle@IconLists@@QBEPAU_IMAGELIST@@H@Z ; IconLists::getImageListHandle(int)
.text$mn:00006E71                 mov     esp, ebp
.text$mn:00006E73                 pop     ebp
.text$mn:00006E74                 retn
.text$mn:00006E74 ?getDisableLst@ToolBarIcons@@QBEPAU_IMAGELIST@@XZ endp
.text$mn:00006E74
.text$mn:00006E74 ; ---------------------------------------------------------------------------
.text$mn:00006E75                 align 4
.text$mn:00006E75 _text$mn        ends
.text$mn:00006E75
.text$mn:00006E78 ; ===========================================================================
.text$mn:00006E78
.text$mn:00006E78 ; Segment type: Pure code
.text$mn:00006E78 ; Segment permissions: Read/Execute
.text$mn:00006E78 _text$mn        segment para public 'CODE' use32
.text$mn:00006E78                 assume cs:_text$mn
.text$mn:00006E78                 ;org 6E78h
.text$mn:00006E78 ; COMDAT (pick any)
.text$mn:00006E78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E78
.text$mn:00006E78 ; =============== S U B R O U T I N E =======================================
.text$mn:00006E78
.text$mn:00006E78 ; Attributes: bp-based frame
.text$mn:00006E78
.text$mn:00006E78 ; HWND __thiscall Window::getHSelf(Window *__hidden this)
.text$mn:00006E78                 public ?getHSelf@Window@@QBEPAUHWND__@@XZ
.text$mn:00006E78 ?getHSelf@Window@@QBEPAUHWND__@@XZ proc near
.text$mn:00006E78                                         ; CODE XREF: ToolBar::addToRebar(ReBar *)+65p
.text$mn:00006E78                                         ; ToolBar::reset(bool)+356p
.text$mn:00006E78
.text$mn:00006E78 var_4           = dword ptr -4
.text$mn:00006E78
.text$mn:00006E78                 push    ebp
.text$mn:00006E79                 mov     ebp, esp
.text$mn:00006E7B                 push    ecx
.text$mn:00006E7C                 mov     [ebp+var_4], ecx
.text$mn:00006E7F                 mov     eax, [ebp+var_4]
.text$mn:00006E82                 mov     eax, [eax+0Ch]
.text$mn:00006E85                 mov     esp, ebp
.text$mn:00006E87                 pop     ebp
.text$mn:00006E88                 retn
.text$mn:00006E88 ?getHSelf@Window@@QBEPAUHWND__@@XZ endp
.text$mn:00006E88
.text$mn:00006E88 ; ---------------------------------------------------------------------------
.text$mn:00006E89                 align 4
.text$mn:00006E89 _text$mn        ends
.text$mn:00006E89
.text$mn:00006E8C ; ===========================================================================
.text$mn:00006E8C
.text$mn:00006E8C ; Segment type: Pure code
.text$mn:00006E8C ; Segment permissions: Read/Execute
.text$mn:00006E8C _text$mn        segment para public 'CODE' use32
.text$mn:00006E8C                 assume cs:_text$mn
.text$mn:00006E8C                 ;org 6E8Ch
.text$mn:00006E8C ; COMDAT (pick any)
.text$mn:00006E8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E8C
.text$mn:00006E8C ; =============== S U B R O U T I N E =======================================
.text$mn:00006E8C
.text$mn:00006E8C ; Attributes: bp-based frame
.text$mn:00006E8C
.text$mn:00006E8C ; struct _IMAGELIST *__thiscall IconList::getHandle(IconList *__hidden this)
.text$mn:00006E8C                 public ?getHandle@IconList@@QBEPAU_IMAGELIST@@XZ
.text$mn:00006E8C ?getHandle@IconList@@QBEPAU_IMAGELIST@@XZ proc near
.text$mn:00006E8C                                         ; CODE XREF: IconLists::getImageListHandle(int)+15p
.text$mn:00006E8C
.text$mn:00006E8C var_4           = dword ptr -4
.text$mn:00006E8C
.text$mn:00006E8C                 push    ebp
.text$mn:00006E8D                 mov     ebp, esp
.text$mn:00006E8F                 push    ecx
.text$mn:00006E90                 mov     [ebp+var_4], ecx
.text$mn:00006E93                 mov     eax, [ebp+var_4]
.text$mn:00006E96                 mov     eax, [eax]
.text$mn:00006E98                 mov     esp, ebp
.text$mn:00006E9A                 pop     ebp
.text$mn:00006E9B                 retn
.text$mn:00006E9B ?getHandle@IconList@@QBEPAU_IMAGELIST@@XZ endp
.text$mn:00006E9B
.text$mn:00006E9B _text$mn        ends
.text$mn:00006E9B
.text$mn:00006E9C ; ===========================================================================
.text$mn:00006E9C
.text$mn:00006E9C ; Segment type: Pure code
.text$mn:00006E9C ; Segment permissions: Read/Execute
.text$mn:00006E9C _text$mn        segment para public 'CODE' use32
.text$mn:00006E9C                 assume cs:_text$mn
.text$mn:00006E9C                 ;org 6E9Ch
.text$mn:00006E9C ; COMDAT (pick any)
.text$mn:00006E9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006E9C
.text$mn:00006E9C ; =============== S U B R O U T I N E =======================================
.text$mn:00006E9C
.text$mn:00006E9C ; Attributes: bp-based frame
.text$mn:00006E9C
.text$mn:00006E9C ; struct _IMAGELIST *__thiscall ToolBarIcons::getHotLst(ToolBarIcons *__hidden this)
.text$mn:00006E9C                 public ?getHotLst@ToolBarIcons@@QBEPAU_IMAGELIST@@XZ
.text$mn:00006E9C ?getHotLst@ToolBarIcons@@QBEPAU_IMAGELIST@@XZ proc near
.text$mn:00006E9C                                         ; CODE XREF: ToolBar::setHotImageList(void)+Dp
.text$mn:00006E9C
.text$mn:00006E9C var_4           = dword ptr -4
.text$mn:00006E9C
.text$mn:00006E9C                 push    ebp
.text$mn:00006E9D                 mov     ebp, esp
.text$mn:00006E9F                 push    ecx
.text$mn:00006EA0                 mov     [ebp+var_4], ecx
.text$mn:00006EA3                 push    1               ; int
.text$mn:00006EA5                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006EA8                 call    ?getImageListHandle@IconLists@@QBEPAU_IMAGELIST@@H@Z ; IconLists::getImageListHandle(int)
.text$mn:00006EAD                 mov     esp, ebp
.text$mn:00006EAF                 pop     ebp
.text$mn:00006EB0                 retn
.text$mn:00006EB0 ?getHotLst@ToolBarIcons@@QBEPAU_IMAGELIST@@XZ endp
.text$mn:00006EB0
.text$mn:00006EB0 ; ---------------------------------------------------------------------------
.text$mn:00006EB1                 align 4
.text$mn:00006EB1 _text$mn        ends
.text$mn:00006EB1
.text$mn:00006EB4 ; ===========================================================================
.text$mn:00006EB4
.text$mn:00006EB4 ; Segment type: Pure code
.text$mn:00006EB4 ; Segment permissions: Read/Execute
.text$mn:00006EB4 _text$mn        segment para public 'CODE' use32
.text$mn:00006EB4                 assume cs:_text$mn
.text$mn:00006EB4                 ;org 6EB4h
.text$mn:00006EB4 ; COMDAT (pick any)
.text$mn:00006EB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006EB4
.text$mn:00006EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006EB4
.text$mn:00006EB4 ; Attributes: bp-based frame
.text$mn:00006EB4
.text$mn:00006EB4 ; struct _IMAGELIST *__thiscall IconLists::getImageListHandle(IconLists *this, int)
.text$mn:00006EB4                 public ?getImageListHandle@IconLists@@QBEPAU_IMAGELIST@@H@Z
.text$mn:00006EB4 ?getImageListHandle@IconLists@@QBEPAU_IMAGELIST@@H@Z proc near
.text$mn:00006EB4                                         ; CODE XREF: ToolBarIcons::getDefaultLst(void)+Cp
.text$mn:00006EB4                                         ; ToolBarIcons::getDisableLst(void)+Cp ...
.text$mn:00006EB4
.text$mn:00006EB4 var_4           = dword ptr -4
.text$mn:00006EB4 arg_0           = dword ptr  8
.text$mn:00006EB4
.text$mn:00006EB4                 push    ebp
.text$mn:00006EB5                 mov     ebp, esp
.text$mn:00006EB7                 push    ecx
.text$mn:00006EB8                 mov     [ebp+var_4], ecx
.text$mn:00006EBB                 mov     eax, [ebp+arg_0]
.text$mn:00006EBE                 push    eax
.text$mn:00006EBF                 mov     ecx, [ebp+var_4]
.text$mn:00006EC2                 call    ??A?$vector@VIconList@@V?$allocator@VIconList@@@std@@@std@@QBEABVIconList@@I@Z ; std::vector<IconList,std::allocator<IconList>>::operator[](uint)
.text$mn:00006EC7                 mov     ecx, eax        ; this
.text$mn:00006EC9                 call    ?getHandle@IconList@@QBEPAU_IMAGELIST@@XZ ; IconList::getHandle(void)
.text$mn:00006ECE                 mov     esp, ebp
.text$mn:00006ED0                 pop     ebp
.text$mn:00006ED1                 retn    4
.text$mn:00006ED1 ?getImageListHandle@IconLists@@QBEPAU_IMAGELIST@@H@Z endp
.text$mn:00006ED1
.text$mn:00006ED1 _text$mn        ends
.text$mn:00006ED1
.text$mn:00006ED4 ; ===========================================================================
.text$mn:00006ED4
.text$mn:00006ED4 ; Segment type: Pure code
.text$mn:00006ED4 ; Segment permissions: Read/Execute
.text$mn:00006ED4 _text$mn        segment para public 'CODE' use32
.text$mn:00006ED4                 assume cs:_text$mn
.text$mn:00006ED4                 ;org 6ED4h
.text$mn:00006ED4 ; COMDAT (pick any)
.text$mn:00006ED4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006ED4
.text$mn:00006ED4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006ED4
.text$mn:00006ED4 ; Attributes: bp-based frame
.text$mn:00006ED4
.text$mn:00006ED4 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:00006ED4                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:00006ED4 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:00006ED4                                         ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+45p
.text$mn:00006ED4                                         ; ToolBar::reduce(void)+19p ...
.text$mn:00006ED4                 push    ebp
.text$mn:00006ED5                 mov     ebp, esp
.text$mn:00006ED7                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:00006EDC                 pop     ebp
.text$mn:00006EDD                 retn
.text$mn:00006EDD ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:00006EDD
.text$mn:00006EDD ; ---------------------------------------------------------------------------
.text$mn:00006EDE                 align 10h
.text$mn:00006EDE _text$mn        ends
.text$mn:00006EDE
.text$mn:00006EE0 ; ===========================================================================
.text$mn:00006EE0
.text$mn:00006EE0 ; Segment type: Pure code
.text$mn:00006EE0 ; Segment permissions: Read/Execute
.text$mn:00006EE0 _text$mn        segment para public 'CODE' use32
.text$mn:00006EE0                 assume cs:_text$mn
.text$mn:00006EE0                 ;org 6EE0h
.text$mn:00006EE0 ; COMDAT (pick any)
.text$mn:00006EE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006EE0
.text$mn:00006EE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006EE0
.text$mn:00006EE0 ; Attributes: bp-based frame
.text$mn:00006EE0
.text$mn:00006EE0 ; int __thiscall ToolBarIcons::getStdIconAt(ToolBarIcons *this, int)
.text$mn:00006EE0                 public ?getStdIconAt@ToolBarIcons@@QBEHH@Z
.text$mn:00006EE0 ?getStdIconAt@ToolBarIcons@@QBEHH@Z proc near
.text$mn:00006EE0                                         ; CODE XREF: ToolBar::reset(bool)+1DEp
.text$mn:00006EE0
.text$mn:00006EE0 var_4           = dword ptr -4
.text$mn:00006EE0 arg_0           = dword ptr  8
.text$mn:00006EE0
.text$mn:00006EE0                 push    ebp
.text$mn:00006EE1                 mov     ebp, esp
.text$mn:00006EE3                 push    ecx
.text$mn:00006EE4                 mov     [ebp+var_4], ecx
.text$mn:00006EE7                 mov     eax, [ebp+arg_0]
.text$mn:00006EEA                 push    eax
.text$mn:00006EEB                 mov     ecx, [ebp+var_4]
.text$mn:00006EEE                 add     ecx, 10h
.text$mn:00006EF1                 call    ??A?$vector@UToolBarButtonUnit@@V?$allocator@UToolBarButtonUnit@@@std@@@std@@QBEABUToolBarButtonUnit@@I@Z ; std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)
.text$mn:00006EF6                 mov     eax, [eax+10h]
.text$mn:00006EF9                 mov     esp, ebp
.text$mn:00006EFB                 pop     ebp
.text$mn:00006EFC                 retn    4
.text$mn:00006EFC ?getStdIconAt@ToolBarIcons@@QBEHH@Z endp
.text$mn:00006EFC
.text$mn:00006EFC ; ---------------------------------------------------------------------------
.text$mn:00006EFF                 align 10h
.text$mn:00006EFF _text$mn        ends
.text$mn:00006EFF
.text$mn:00006F00 ; ===========================================================================
.text$mn:00006F00
.text$mn:00006F00 ; Segment type: Pure code
.text$mn:00006F00 ; Segment permissions: Read/Execute
.text$mn:00006F00 _text$mn        segment para public 'CODE' use32
.text$mn:00006F00                 assume cs:_text$mn
.text$mn:00006F00                 ;org 6F00h
.text$mn:00006F00 ; COMDAT (pick any)
.text$mn:00006F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F00
.text$mn:00006F00 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F00
.text$mn:00006F00 ; Attributes: bp-based frame
.text$mn:00006F00
.text$mn:00006F00 ; int __thiscall Window::getWidth(Window *__hidden this)
.text$mn:00006F00                 public ?getWidth@Window@@UBEHXZ
.text$mn:00006F00 ?getWidth@Window@@UBEHXZ proc near      ; CODE XREF: ToolBar::doPopop(tagPOINT)+2Ep
.text$mn:00006F00
.text$mn:00006F00 var_18          = dword ptr -18h
.text$mn:00006F00 Rect            = tagRECT ptr -14h
.text$mn:00006F00 var_4           = dword ptr -4
.text$mn:00006F00
.text$mn:00006F00                 push    ebp
.text$mn:00006F01                 mov     ebp, esp
.text$mn:00006F03                 sub     esp, 18h
.text$mn:00006F06                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006F0B                 xor     eax, ebp
.text$mn:00006F0D                 mov     [ebp+var_4], eax
.text$mn:00006F10                 mov     [ebp+var_18], ecx
.text$mn:00006F13                 lea     eax, [ebp+Rect]
.text$mn:00006F16                 push    eax             ; lpRect
.text$mn:00006F17                 mov     ecx, [ebp+var_18]
.text$mn:00006F1A                 mov     edx, [ecx+0Ch]
.text$mn:00006F1D                 push    edx             ; hWnd
.text$mn:00006F1E                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00006F24                 mov     eax, [ebp+Rect.right]
.text$mn:00006F27                 sub     eax, [ebp+Rect.left]
.text$mn:00006F2A                 mov     ecx, [ebp+var_4]
.text$mn:00006F2D                 xor     ecx, ebp
.text$mn:00006F2F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00006F34                 mov     esp, ebp
.text$mn:00006F36                 pop     ebp
.text$mn:00006F37                 retn
.text$mn:00006F37 ?getWidth@Window@@UBEHXZ endp
.text$mn:00006F37
.text$mn:00006F37 _text$mn        ends
.text$mn:00006F37
.text$mn:00006F38 ; ===========================================================================
.text$mn:00006F38
.text$mn:00006F38 ; Segment type: Pure code
.text$mn:00006F38 ; Segment permissions: Read/Execute
.text$mn:00006F38 _text$mn        segment para public 'CODE' use32
.text$mn:00006F38                 assume cs:_text$mn
.text$mn:00006F38                 ;org 6F38h
.text$mn:00006F38 ; COMDAT (pick any)
.text$mn:00006F38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F38
.text$mn:00006F38 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F38
.text$mn:00006F38 ; Attributes: bp-based frame
.text$mn:00006F38
.text$mn:00006F38 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:00006F38                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00006F38 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00006F38                                         ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+14p
.text$mn:00006F38                                         ; ReBar::init(HINSTANCE__ *,HWND__ *)+14p
.text$mn:00006F38
.text$mn:00006F38 var_4           = dword ptr -4
.text$mn:00006F38 arg_0           = dword ptr  8
.text$mn:00006F38 arg_4           = dword ptr  0Ch
.text$mn:00006F38
.text$mn:00006F38                 push    ebp
.text$mn:00006F39                 mov     ebp, esp
.text$mn:00006F3B                 push    ecx
.text$mn:00006F3C                 mov     [ebp+var_4], ecx
.text$mn:00006F3F                 mov     eax, [ebp+var_4]
.text$mn:00006F42                 mov     ecx, [ebp+arg_0]
.text$mn:00006F45                 mov     [eax+4], ecx
.text$mn:00006F48                 mov     edx, [ebp+var_4]
.text$mn:00006F4B                 mov     eax, [ebp+arg_4]
.text$mn:00006F4E                 mov     [edx+8], eax
.text$mn:00006F51                 mov     esp, ebp
.text$mn:00006F53                 pop     ebp
.text$mn:00006F54                 retn    8
.text$mn:00006F54 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:00006F54
.text$mn:00006F54 ; ---------------------------------------------------------------------------
.text$mn:00006F57                 align 4
.text$mn:00006F57 _text$mn        ends
.text$mn:00006F57
.text$mn:00006F58 ; ===========================================================================
.text$mn:00006F58
.text$mn:00006F58 ; Segment type: Pure code
.text$mn:00006F58 ; Segment permissions: Read/Execute
.text$mn:00006F58 _text$mn        segment para public 'CODE' use32
.text$mn:00006F58                 assume cs:_text$mn
.text$mn:00006F58                 ;org 6F58h
.text$mn:00006F58 ; COMDAT (pick any)
.text$mn:00006F58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F58
.text$mn:00006F58 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F58
.text$mn:00006F58 ; Attributes: bp-based frame
.text$mn:00006F58
.text$mn:00006F58 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00006F58                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00006F58 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00006F58                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00006F58
.text$mn:00006F58 var_4           = dword ptr -4
.text$mn:00006F58 Str             = dword ptr  8
.text$mn:00006F58
.text$mn:00006F58                 push    ebp
.text$mn:00006F59                 mov     ebp, esp
.text$mn:00006F5B                 push    ecx
.text$mn:00006F5C                 mov     eax, [ebp+Str]
.text$mn:00006F5F                 movsx   ecx, byte ptr [eax]
.text$mn:00006F62                 test    ecx, ecx
.text$mn:00006F64                 jnz     short loc_6F6F
.text$mn:00006F66                 mov     [ebp+var_4], 0
.text$mn:00006F6D                 jmp     short loc_6F7E
.text$mn:00006F6F ; ---------------------------------------------------------------------------
.text$mn:00006F6F
.text$mn:00006F6F loc_6F6F:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00006F6F                 mov     edx, [ebp+Str]
.text$mn:00006F72                 push    edx             ; Str
.text$mn:00006F73                 call    _strlen
.text$mn:00006F78                 add     esp, 4
.text$mn:00006F7B                 mov     [ebp+var_4], eax
.text$mn:00006F7E
.text$mn:00006F7E loc_6F7E:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00006F7E                 mov     eax, [ebp+var_4]
.text$mn:00006F81                 mov     esp, ebp
.text$mn:00006F83                 pop     ebp
.text$mn:00006F84                 retn
.text$mn:00006F84 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00006F84
.text$mn:00006F84 ; ---------------------------------------------------------------------------
.text$mn:00006F85                 align 4
.text$mn:00006F85 _text$mn        ends
.text$mn:00006F85
.text$mn:00006F88 ; ===========================================================================
.text$mn:00006F88
.text$mn:00006F88 ; Segment type: Pure code
.text$mn:00006F88 ; Segment permissions: Read/Execute
.text$mn:00006F88 _text$mn        segment para public 'CODE' use32
.text$mn:00006F88                 assume cs:_text$mn
.text$mn:00006F88                 ;org 6F88h
.text$mn:00006F88 ; COMDAT (pick any)
.text$mn:00006F88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F88
.text$mn:00006F88 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F88
.text$mn:00006F88 ; Attributes: bp-based frame
.text$mn:00006F88
.text$mn:00006F88 ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:00006F88                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:00006F88 ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:00006F88                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+21p
.text$mn:00006F88                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p
.text$mn:00006F88
.text$mn:00006F88 var_4           = dword ptr -4
.text$mn:00006F88 Str             = dword ptr  8
.text$mn:00006F88
.text$mn:00006F88                 push    ebp
.text$mn:00006F89                 mov     ebp, esp
.text$mn:00006F8B                 push    ecx
.text$mn:00006F8C                 mov     eax, [ebp+Str]
.text$mn:00006F8F                 movzx   ecx, word ptr [eax]
.text$mn:00006F92                 test    ecx, ecx
.text$mn:00006F94                 jnz     short loc_6F9F
.text$mn:00006F96                 mov     [ebp+var_4], 0
.text$mn:00006F9D                 jmp     short loc_6FAE
.text$mn:00006F9F ; ---------------------------------------------------------------------------
.text$mn:00006F9F
.text$mn:00006F9F loc_6F9F:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:00006F9F                 mov     edx, [ebp+Str]
.text$mn:00006FA2                 push    edx             ; Str
.text$mn:00006FA3                 call    _wcslen
.text$mn:00006FA8                 add     esp, 4
.text$mn:00006FAB                 mov     [ebp+var_4], eax
.text$mn:00006FAE
.text$mn:00006FAE loc_6FAE:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:00006FAE                 mov     eax, [ebp+var_4]
.text$mn:00006FB1                 mov     esp, ebp
.text$mn:00006FB3                 pop     ebp
.text$mn:00006FB4                 retn
.text$mn:00006FB4 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:00006FB4
.text$mn:00006FB4 ; ---------------------------------------------------------------------------
.text$mn:00006FB5                 align 4
.text$mn:00006FB5 _text$mn        ends
.text$mn:00006FB5
.text$mn:00006FB8 ; ===========================================================================
.text$mn:00006FB8
.text$mn:00006FB8 ; Segment type: Pure code
.text$mn:00006FB8 ; Segment permissions: Read/Execute
.text$mn:00006FB8 _text$mn        segment para public 'CODE' use32
.text$mn:00006FB8                 assume cs:_text$mn
.text$mn:00006FB8                 ;org 6FB8h
.text$mn:00006FB8 ; COMDAT (pick any)
.text$mn:00006FB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FB8
.text$mn:00006FB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FB8
.text$mn:00006FB8 ; Attributes: bp-based frame
.text$mn:00006FB8
.text$mn:00006FB8 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00006FB8                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00006FB8 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00006FB8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00006FB8
.text$mn:00006FB8 var_4           = dword ptr -4
.text$mn:00006FB8
.text$mn:00006FB8                 push    ebp
.text$mn:00006FB9                 mov     ebp, esp
.text$mn:00006FBB                 push    ecx
.text$mn:00006FBC                 mov     [ebp+var_4], ecx
.text$mn:00006FBF                 mov     eax, [ebp+var_4]
.text$mn:00006FC2                 push    eax
.text$mn:00006FC3                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00006FC8                 add     esp, 4
.text$mn:00006FCB                 mov     esp, ebp
.text$mn:00006FCD                 pop     ebp
.text$mn:00006FCE                 retn
.text$mn:00006FCE ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00006FCE
.text$mn:00006FCE ; ---------------------------------------------------------------------------
.text$mn:00006FCF                 align 10h
.text$mn:00006FCF _text$mn        ends
.text$mn:00006FCF
.text$mn:00006FD0 ; ===========================================================================
.text$mn:00006FD0
.text$mn:00006FD0 ; Segment type: Pure code
.text$mn:00006FD0 ; Segment permissions: Read/Execute
.text$mn:00006FD0 _text$mn        segment para public 'CODE' use32
.text$mn:00006FD0                 assume cs:_text$mn
.text$mn:00006FD0                 ;org 6FD0h
.text$mn:00006FD0 ; COMDAT (pick any)
.text$mn:00006FD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FD0
.text$mn:00006FD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FD0
.text$mn:00006FD0 ; Attributes: bp-based frame
.text$mn:00006FD0
.text$mn:00006FD0 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<int>>::max_size(void)const
.text$mn:00006FD0                 public ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ
.text$mn:00006FD0 ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:00006FD0                                         ; CODE XREF: std::vector<int,std::allocator<int>>::max_size(void)+17p
.text$mn:00006FD0
.text$mn:00006FD0 var_4           = dword ptr -4
.text$mn:00006FD0
.text$mn:00006FD0                 push    ebp
.text$mn:00006FD1                 mov     ebp, esp
.text$mn:00006FD3                 push    ecx
.text$mn:00006FD4                 mov     [ebp+var_4], ecx
.text$mn:00006FD7                 mov     eax, [ebp+var_4]
.text$mn:00006FDA                 push    eax
.text$mn:00006FDB                 call    ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::allocator_traits<std::allocator<int>>::max_size(std::allocator<int> const &)
.text$mn:00006FE0                 add     esp, 4
.text$mn:00006FE3                 mov     esp, ebp
.text$mn:00006FE5                 pop     ebp
.text$mn:00006FE6                 retn
.text$mn:00006FE6 ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:00006FE6
.text$mn:00006FE6 ; ---------------------------------------------------------------------------
.text$mn:00006FE7                 align 4
.text$mn:00006FE7 _text$mn        ends
.text$mn:00006FE7
.text$mn:00006FE8 ; ===========================================================================
.text$mn:00006FE8
.text$mn:00006FE8 ; Segment type: Pure code
.text$mn:00006FE8 ; Segment permissions: Read/Execute
.text$mn:00006FE8 _text$mn        segment para public 'CODE' use32
.text$mn:00006FE8                 assume cs:_text$mn
.text$mn:00006FE8                 ;org 6FE8h
.text$mn:00006FE8 ; COMDAT (pick any)
.text$mn:00006FE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FE8
.text$mn:00006FE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006FE8
.text$mn:00006FE8 ; Attributes: bp-based frame
.text$mn:00006FE8
.text$mn:00006FE8 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct iconLocator>>::max_size(void)const
.text$mn:00006FE8                 public ?max_size@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ
.text$mn:00006FE8 ?max_size@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ proc near
.text$mn:00006FE8                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::max_size(void)+17p
.text$mn:00006FE8
.text$mn:00006FE8 var_4           = dword ptr -4
.text$mn:00006FE8
.text$mn:00006FE8                 push    ebp
.text$mn:00006FE9                 mov     ebp, esp
.text$mn:00006FEB                 push    ecx
.text$mn:00006FEC                 mov     [ebp+var_4], ecx
.text$mn:00006FEF                 mov     eax, [ebp+var_4]
.text$mn:00006FF2                 push    eax
.text$mn:00006FF3                 call    ?max_size@?$allocator_traits@V?$allocator@UiconLocator@@@std@@@std@@SAIABV?$allocator@UiconLocator@@@2@@Z ; std::allocator_traits<std::allocator<iconLocator>>::max_size(std::allocator<iconLocator> const &)
.text$mn:00006FF8                 add     esp, 4
.text$mn:00006FFB                 mov     esp, ebp
.text$mn:00006FFD                 pop     ebp
.text$mn:00006FFE                 retn
.text$mn:00006FFE ?max_size@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ endp
.text$mn:00006FFE
.text$mn:00006FFE ; ---------------------------------------------------------------------------
.text$mn:00006FFF                 align 10h
.text$mn:00006FFF _text$mn        ends
.text$mn:00006FFF
.text$mn:00007000 ; ===========================================================================
.text$mn:00007000
.text$mn:00007000 ; Segment type: Pure code
.text$mn:00007000 ; Segment permissions: Read/Execute
.text$mn:00007000 _text$mn        segment para public 'CODE' use32
.text$mn:00007000                 assume cs:_text$mn
.text$mn:00007000                 ;org 7000h
.text$mn:00007000 ; COMDAT (pick any)
.text$mn:00007000                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007000
.text$mn:00007000 ; =============== S U B R O U T I N E =======================================
.text$mn:00007000
.text$mn:00007000 ; Attributes: bp-based frame
.text$mn:00007000
.text$mn:00007000 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<struct tDynamicList>>::max_size(void)const
.text$mn:00007000                 public ?max_size@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ
.text$mn:00007000 ?max_size@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ proc near
.text$mn:00007000                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::max_size(void)+17p
.text$mn:00007000
.text$mn:00007000 var_4           = dword ptr -4
.text$mn:00007000
.text$mn:00007000                 push    ebp
.text$mn:00007001                 mov     ebp, esp
.text$mn:00007003                 push    ecx
.text$mn:00007004                 mov     [ebp+var_4], ecx
.text$mn:00007007                 mov     eax, [ebp+var_4]
.text$mn:0000700A                 push    eax
.text$mn:0000700B                 call    ?max_size@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAIABV?$allocator@UtDynamicList@@@2@@Z ; std::allocator_traits<std::allocator<tDynamicList>>::max_size(std::allocator<tDynamicList> const &)
.text$mn:00007010                 add     esp, 4
.text$mn:00007013                 mov     esp, ebp
.text$mn:00007015                 pop     ebp
.text$mn:00007016                 retn
.text$mn:00007016 ?max_size@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ endp
.text$mn:00007016
.text$mn:00007016 ; ---------------------------------------------------------------------------
.text$mn:00007017                 align 4
.text$mn:00007017 _text$mn        ends
.text$mn:00007017
.text$mn:00007018 ; ===========================================================================
.text$mn:00007018
.text$mn:00007018 ; Segment type: Pure code
.text$mn:00007018 ; Segment permissions: Read/Execute
.text$mn:00007018 _text$mn        segment para public 'CODE' use32
.text$mn:00007018                 assume cs:_text$mn
.text$mn:00007018                 ;org 7018h
.text$mn:00007018 ; COMDAT (pick any)
.text$mn:00007018                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007018
.text$mn:00007018 ; =============== S U B R O U T I N E =======================================
.text$mn:00007018
.text$mn:00007018 ; Attributes: bp-based frame
.text$mn:00007018
.text$mn:00007018 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:00007018                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:00007018 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:00007018                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:00007018
.text$mn:00007018 var_4           = dword ptr -4
.text$mn:00007018
.text$mn:00007018                 push    ebp
.text$mn:00007019                 mov     ebp, esp
.text$mn:0000701B                 push    ecx
.text$mn:0000701C                 mov     [ebp+var_4], ecx
.text$mn:0000701F                 mov     eax, [ebp+var_4]
.text$mn:00007022                 push    eax
.text$mn:00007023                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:00007028                 add     esp, 4
.text$mn:0000702B                 mov     esp, ebp
.text$mn:0000702D                 pop     ebp
.text$mn:0000702E                 retn
.text$mn:0000702E ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:0000702E
.text$mn:0000702E ; ---------------------------------------------------------------------------
.text$mn:0000702F                 align 10h
.text$mn:0000702F _text$mn        ends
.text$mn:0000702F
.text$mn:00007030 ; ===========================================================================
.text$mn:00007030
.text$mn:00007030 ; Segment type: Pure code
.text$mn:00007030 ; Segment permissions: Read/Execute
.text$mn:00007030 _text$mn        segment para public 'CODE' use32
.text$mn:00007030                 assume cs:_text$mn
.text$mn:00007030                 ;org 7030h
.text$mn:00007030 ; COMDAT (pick any)
.text$mn:00007030                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007030
.text$mn:00007030 ; =============== S U B R O U T I N E =======================================
.text$mn:00007030
.text$mn:00007030 ; Attributes: bp-based frame
.text$mn:00007030
.text$mn:00007030 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00007030                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00007030 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00007030                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00007030
.text$mn:00007030 var_4           = dword ptr -4
.text$mn:00007030
.text$mn:00007030                 push    ebp
.text$mn:00007031                 mov     ebp, esp
.text$mn:00007033                 push    ecx
.text$mn:00007034                 mov     [ebp+var_4], ecx
.text$mn:00007037                 or      eax, 0FFFFFFFFh
.text$mn:0000703A                 mov     esp, ebp
.text$mn:0000703C                 pop     ebp
.text$mn:0000703D                 retn
.text$mn:0000703D ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:0000703D
.text$mn:0000703D ; ---------------------------------------------------------------------------
.text$mn:0000703E                 align 10h
.text$mn:0000703E _text$mn        ends
.text$mn:0000703E
.text$mn:00007040 ; ===========================================================================
.text$mn:00007040
.text$mn:00007040 ; Segment type: Pure code
.text$mn:00007040 ; Segment permissions: Read/Execute
.text$mn:00007040 _text$mn        segment para public 'CODE' use32
.text$mn:00007040                 assume cs:_text$mn
.text$mn:00007040                 ;org 7040h
.text$mn:00007040 ; COMDAT (pick any)
.text$mn:00007040                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007040
.text$mn:00007040 ; =============== S U B R O U T I N E =======================================
.text$mn:00007040
.text$mn:00007040 ; Attributes: bp-based frame
.text$mn:00007040
.text$mn:00007040 ; public: unsigned int __thiscall std::allocator<int>::max_size(void)const
.text$mn:00007040                 public ?max_size@?$allocator@H@std@@QBEIXZ
.text$mn:00007040 ?max_size@?$allocator@H@std@@QBEIXZ proc near
.text$mn:00007040                                         ; CODE XREF: std::allocator_traits<std::allocator<int>>::max_size(std::allocator<int> const &)+6p
.text$mn:00007040
.text$mn:00007040 var_4           = dword ptr -4
.text$mn:00007040
.text$mn:00007040                 push    ebp
.text$mn:00007041                 mov     ebp, esp
.text$mn:00007043                 push    ecx
.text$mn:00007044                 mov     [ebp+var_4], ecx
.text$mn:00007047                 mov     eax, 3FFFFFFFh
.text$mn:0000704C                 mov     esp, ebp
.text$mn:0000704E                 pop     ebp
.text$mn:0000704F                 retn
.text$mn:0000704F ?max_size@?$allocator@H@std@@QBEIXZ endp
.text$mn:0000704F
.text$mn:0000704F _text$mn        ends
.text$mn:0000704F
.text$mn:00007050 ; ===========================================================================
.text$mn:00007050
.text$mn:00007050 ; Segment type: Pure code
.text$mn:00007050 ; Segment permissions: Read/Execute
.text$mn:00007050 _text$mn        segment para public 'CODE' use32
.text$mn:00007050                 assume cs:_text$mn
.text$mn:00007050                 ;org 7050h
.text$mn:00007050 ; COMDAT (pick any)
.text$mn:00007050                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007050
.text$mn:00007050 ; =============== S U B R O U T I N E =======================================
.text$mn:00007050
.text$mn:00007050 ; Attributes: bp-based frame
.text$mn:00007050
.text$mn:00007050 ; public: unsigned int __thiscall std::allocator<struct iconLocator>::max_size(void)const
.text$mn:00007050                 public ?max_size@?$allocator@UiconLocator@@@std@@QBEIXZ
.text$mn:00007050 ?max_size@?$allocator@UiconLocator@@@std@@QBEIXZ proc near
.text$mn:00007050                                         ; CODE XREF: std::allocator_traits<std::allocator<iconLocator>>::max_size(std::allocator<iconLocator> const &)+6p
.text$mn:00007050
.text$mn:00007050 var_4           = dword ptr -4
.text$mn:00007050
.text$mn:00007050                 push    ebp
.text$mn:00007051                 mov     ebp, esp
.text$mn:00007053                 push    ecx
.text$mn:00007054                 mov     [ebp+var_4], ecx
.text$mn:00007057                 mov     eax, 71C71C7h
.text$mn:0000705C                 mov     esp, ebp
.text$mn:0000705E                 pop     ebp
.text$mn:0000705F                 retn
.text$mn:0000705F ?max_size@?$allocator@UiconLocator@@@std@@QBEIXZ endp
.text$mn:0000705F
.text$mn:0000705F _text$mn        ends
.text$mn:0000705F
.text$mn:00007060 ; ===========================================================================
.text$mn:00007060
.text$mn:00007060 ; Segment type: Pure code
.text$mn:00007060 ; Segment permissions: Read/Execute
.text$mn:00007060 _text$mn        segment para public 'CODE' use32
.text$mn:00007060                 assume cs:_text$mn
.text$mn:00007060                 ;org 7060h
.text$mn:00007060 ; COMDAT (pick any)
.text$mn:00007060                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007060
.text$mn:00007060 ; =============== S U B R O U T I N E =======================================
.text$mn:00007060
.text$mn:00007060 ; Attributes: bp-based frame
.text$mn:00007060
.text$mn:00007060 ; public: unsigned int __thiscall std::allocator<struct tDynamicList>::max_size(void)const
.text$mn:00007060                 public ?max_size@?$allocator@UtDynamicList@@@std@@QBEIXZ
.text$mn:00007060 ?max_size@?$allocator@UtDynamicList@@@std@@QBEIXZ proc near
.text$mn:00007060                                         ; CODE XREF: std::allocator_traits<std::allocator<tDynamicList>>::max_size(std::allocator<tDynamicList> const &)+6p
.text$mn:00007060
.text$mn:00007060 var_4           = dword ptr -4
.text$mn:00007060
.text$mn:00007060                 push    ebp
.text$mn:00007061                 mov     ebp, esp
.text$mn:00007063                 push    ecx
.text$mn:00007064                 mov     [ebp+var_4], ecx
.text$mn:00007067                 mov     eax, 15555555h
.text$mn:0000706C                 mov     esp, ebp
.text$mn:0000706E                 pop     ebp
.text$mn:0000706F                 retn
.text$mn:0000706F ?max_size@?$allocator@UtDynamicList@@@std@@QBEIXZ endp
.text$mn:0000706F
.text$mn:0000706F _text$mn        ends
.text$mn:0000706F
.text$mn:00007070 ; ===========================================================================
.text$mn:00007070
.text$mn:00007070 ; Segment type: Pure code
.text$mn:00007070 ; Segment permissions: Read/Execute
.text$mn:00007070 _text$mn        segment para public 'CODE' use32
.text$mn:00007070                 assume cs:_text$mn
.text$mn:00007070                 ;org 7070h
.text$mn:00007070 ; COMDAT (pick any)
.text$mn:00007070                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007070
.text$mn:00007070 ; =============== S U B R O U T I N E =======================================
.text$mn:00007070
.text$mn:00007070 ; Attributes: bp-based frame
.text$mn:00007070
.text$mn:00007070 ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:00007070                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:00007070 ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:00007070                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:00007070
.text$mn:00007070 var_4           = dword ptr -4
.text$mn:00007070
.text$mn:00007070                 push    ebp
.text$mn:00007071                 mov     ebp, esp
.text$mn:00007073                 push    ecx
.text$mn:00007074                 mov     [ebp+var_4], ecx
.text$mn:00007077                 mov     eax, 7FFFFFFFh
.text$mn:0000707C                 mov     esp, ebp
.text$mn:0000707E                 pop     ebp
.text$mn:0000707F                 retn
.text$mn:0000707F ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:0000707F
.text$mn:0000707F _text$mn        ends
.text$mn:0000707F
.text$mn:00007080 ; ===========================================================================
.text$mn:00007080
.text$mn:00007080 ; Segment type: Pure code
.text$mn:00007080 ; Segment permissions: Read/Execute
.text$mn:00007080 _text$mn        segment para public 'CODE' use32
.text$mn:00007080                 assume cs:_text$mn
.text$mn:00007080                 ;org 7080h
.text$mn:00007080 ; COMDAT (pick any)
.text$mn:00007080                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007080
.text$mn:00007080 ; =============== S U B R O U T I N E =======================================
.text$mn:00007080
.text$mn:00007080 ; Attributes: bp-based frame
.text$mn:00007080
.text$mn:00007080 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00007080                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00007080 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00007080                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00007080
.text$mn:00007080 arg_0           = dword ptr  8
.text$mn:00007080
.text$mn:00007080                 push    ebp
.text$mn:00007081                 mov     ebp, esp
.text$mn:00007083                 mov     ecx, [ebp+arg_0]
.text$mn:00007086                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:0000708B                 pop     ebp
.text$mn:0000708C                 retn
.text$mn:0000708C ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:0000708C
.text$mn:0000708C ; ---------------------------------------------------------------------------
.text$mn:0000708D                 align 10h
.text$mn:0000708D _text$mn        ends
.text$mn:0000708D
.text$mn:00007090 ; ===========================================================================
.text$mn:00007090
.text$mn:00007090 ; Segment type: Pure code
.text$mn:00007090 ; Segment permissions: Read/Execute
.text$mn:00007090 _text$mn        segment para public 'CODE' use32
.text$mn:00007090                 assume cs:_text$mn
.text$mn:00007090                 ;org 7090h
.text$mn:00007090 ; COMDAT (pick any)
.text$mn:00007090                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007090
.text$mn:00007090 ; =============== S U B R O U T I N E =======================================
.text$mn:00007090
.text$mn:00007090 ; Attributes: bp-based frame
.text$mn:00007090
.text$mn:00007090 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<int>>::max_size(class std::allocator<int> const &)
.text$mn:00007090                 public ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z
.text$mn:00007090 ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z proc near
.text$mn:00007090                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<int>>::max_size(void)+Bp
.text$mn:00007090
.text$mn:00007090 arg_0           = dword ptr  8
.text$mn:00007090
.text$mn:00007090                 push    ebp
.text$mn:00007091                 mov     ebp, esp
.text$mn:00007093                 mov     ecx, [ebp+arg_0]
.text$mn:00007096                 call    ?max_size@?$allocator@H@std@@QBEIXZ ; std::allocator<int>::max_size(void)
.text$mn:0000709B                 pop     ebp
.text$mn:0000709C                 retn
.text$mn:0000709C ?max_size@?$allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z endp
.text$mn:0000709C
.text$mn:0000709C ; ---------------------------------------------------------------------------
.text$mn:0000709D                 align 10h
.text$mn:0000709D _text$mn        ends
.text$mn:0000709D
.text$mn:000070A0 ; ===========================================================================
.text$mn:000070A0
.text$mn:000070A0 ; Segment type: Pure code
.text$mn:000070A0 ; Segment permissions: Read/Execute
.text$mn:000070A0 _text$mn        segment para public 'CODE' use32
.text$mn:000070A0                 assume cs:_text$mn
.text$mn:000070A0                 ;org 70A0h
.text$mn:000070A0 ; COMDAT (pick any)
.text$mn:000070A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000070A0
.text$mn:000070A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000070A0
.text$mn:000070A0 ; Attributes: bp-based frame
.text$mn:000070A0
.text$mn:000070A0 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct iconLocator>>::max_size(class std::allocator<struct iconLocator> const &)
.text$mn:000070A0                 public ?max_size@?$allocator_traits@V?$allocator@UiconLocator@@@std@@@std@@SAIABV?$allocator@UiconLocator@@@2@@Z
.text$mn:000070A0 ?max_size@?$allocator_traits@V?$allocator@UiconLocator@@@std@@@std@@SAIABV?$allocator@UiconLocator@@@2@@Z proc near
.text$mn:000070A0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<iconLocator>>::max_size(void)+Bp
.text$mn:000070A0
.text$mn:000070A0 arg_0           = dword ptr  8
.text$mn:000070A0
.text$mn:000070A0                 push    ebp
.text$mn:000070A1                 mov     ebp, esp
.text$mn:000070A3                 mov     ecx, [ebp+arg_0]
.text$mn:000070A6                 call    ?max_size@?$allocator@UiconLocator@@@std@@QBEIXZ ; std::allocator<iconLocator>::max_size(void)
.text$mn:000070AB                 pop     ebp
.text$mn:000070AC                 retn
.text$mn:000070AC ?max_size@?$allocator_traits@V?$allocator@UiconLocator@@@std@@@std@@SAIABV?$allocator@UiconLocator@@@2@@Z endp
.text$mn:000070AC
.text$mn:000070AC ; ---------------------------------------------------------------------------
.text$mn:000070AD                 align 10h
.text$mn:000070AD _text$mn        ends
.text$mn:000070AD
.text$mn:000070B0 ; ===========================================================================
.text$mn:000070B0
.text$mn:000070B0 ; Segment type: Pure code
.text$mn:000070B0 ; Segment permissions: Read/Execute
.text$mn:000070B0 _text$mn        segment para public 'CODE' use32
.text$mn:000070B0                 assume cs:_text$mn
.text$mn:000070B0                 ;org 70B0h
.text$mn:000070B0 ; COMDAT (pick any)
.text$mn:000070B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000070B0
.text$mn:000070B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000070B0
.text$mn:000070B0 ; Attributes: bp-based frame
.text$mn:000070B0
.text$mn:000070B0 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<struct tDynamicList>>::max_size(class std::allocator<struct tDynamicList> const &)
.text$mn:000070B0                 public ?max_size@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAIABV?$allocator@UtDynamicList@@@2@@Z
.text$mn:000070B0 ?max_size@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAIABV?$allocator@UtDynamicList@@@2@@Z proc near
.text$mn:000070B0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<tDynamicList>>::max_size(void)+Bp
.text$mn:000070B0
.text$mn:000070B0 arg_0           = dword ptr  8
.text$mn:000070B0
.text$mn:000070B0                 push    ebp
.text$mn:000070B1                 mov     ebp, esp
.text$mn:000070B3                 mov     ecx, [ebp+arg_0]
.text$mn:000070B6                 call    ?max_size@?$allocator@UtDynamicList@@@std@@QBEIXZ ; std::allocator<tDynamicList>::max_size(void)
.text$mn:000070BB                 pop     ebp
.text$mn:000070BC                 retn
.text$mn:000070BC ?max_size@?$allocator_traits@V?$allocator@UtDynamicList@@@std@@@std@@SAIABV?$allocator@UtDynamicList@@@2@@Z endp
.text$mn:000070BC
.text$mn:000070BC ; ---------------------------------------------------------------------------
.text$mn:000070BD                 align 10h
.text$mn:000070BD _text$mn        ends
.text$mn:000070BD
.text$mn:000070C0 ; ===========================================================================
.text$mn:000070C0
.text$mn:000070C0 ; Segment type: Pure code
.text$mn:000070C0 ; Segment permissions: Read/Execute
.text$mn:000070C0 _text$mn        segment para public 'CODE' use32
.text$mn:000070C0                 assume cs:_text$mn
.text$mn:000070C0                 ;org 70C0h
.text$mn:000070C0 ; COMDAT (pick any)
.text$mn:000070C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000070C0
.text$mn:000070C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000070C0
.text$mn:000070C0 ; Attributes: bp-based frame
.text$mn:000070C0
.text$mn:000070C0 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:000070C0                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:000070C0 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:000070C0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:000070C0
.text$mn:000070C0 arg_0           = dword ptr  8
.text$mn:000070C0
.text$mn:000070C0                 push    ebp
.text$mn:000070C1                 mov     ebp, esp
.text$mn:000070C3                 mov     ecx, [ebp+arg_0]
.text$mn:000070C6                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:000070CB                 pop     ebp
.text$mn:000070CC                 retn
.text$mn:000070CC ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:000070CC
.text$mn:000070CC ; ---------------------------------------------------------------------------
.text$mn:000070CD                 align 10h
.text$mn:000070CD _text$mn        ends
.text$mn:000070CD
.text$mn:000070D0 ; ===========================================================================
.text$mn:000070D0
.text$mn:000070D0 ; Segment type: Pure code
.text$mn:000070D0 ; Segment permissions: Read/Execute
.text$mn:000070D0 _text$mn        segment para public 'CODE' use32
.text$mn:000070D0                 assume cs:_text$mn
.text$mn:000070D0                 ;org 70D0h
.text$mn:000070D0 ; COMDAT (pick any)
.text$mn:000070D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000070D0
.text$mn:000070D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000070D0
.text$mn:000070D0 ; Attributes: bp-based frame
.text$mn:000070D0
.text$mn:000070D0 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000070D0                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000070D0 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000070D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000070D0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000070D0
.text$mn:000070D0 var_10          = dword ptr -10h
.text$mn:000070D0 var_C           = dword ptr -0Ch
.text$mn:000070D0 var_8           = dword ptr -8
.text$mn:000070D0 var_1           = byte ptr -1
.text$mn:000070D0
.text$mn:000070D0                 push    ebp
.text$mn:000070D1                 mov     ebp, esp
.text$mn:000070D3                 sub     esp, 10h
.text$mn:000070D6                 mov     [ebp+var_10], ecx
.text$mn:000070D9                 lea     eax, [ebp+var_1]
.text$mn:000070DC                 push    eax
.text$mn:000070DD                 mov     ecx, [ebp+var_10]
.text$mn:000070E0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000070E5                 mov     ecx, eax
.text$mn:000070E7                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000070EC                 mov     [ebp+var_8], eax
.text$mn:000070EF                 cmp     [ebp+var_8], 1
.text$mn:000070F3                 ja      short loc_70FE
.text$mn:000070F5                 mov     [ebp+var_C], 1
.text$mn:000070FC                 jmp     short loc_7107
.text$mn:000070FE ; ---------------------------------------------------------------------------
.text$mn:000070FE
.text$mn:000070FE loc_70FE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000070FE                 mov     ecx, [ebp+var_8]
.text$mn:00007101                 sub     ecx, 1
.text$mn:00007104                 mov     [ebp+var_C], ecx
.text$mn:00007107
.text$mn:00007107 loc_7107:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00007107                 mov     eax, [ebp+var_C]
.text$mn:0000710A                 mov     esp, ebp
.text$mn:0000710C                 pop     ebp
.text$mn:0000710D                 retn
.text$mn:0000710D ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:0000710D
.text$mn:0000710D ; ---------------------------------------------------------------------------
.text$mn:0000710E                 align 10h
.text$mn:0000710E _text$mn        ends
.text$mn:0000710E
.text$mn:00007110 ; ===========================================================================
.text$mn:00007110
.text$mn:00007110 ; Segment type: Pure code
.text$mn:00007110 ; Segment permissions: Read/Execute
.text$mn:00007110 _text$mn        segment para public 'CODE' use32
.text$mn:00007110                 assume cs:_text$mn
.text$mn:00007110                 ;org 7110h
.text$mn:00007110 ; COMDAT (pick any)
.text$mn:00007110                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007110
.text$mn:00007110 ; =============== S U B R O U T I N E =======================================
.text$mn:00007110
.text$mn:00007110 ; Attributes: bp-based frame
.text$mn:00007110
.text$mn:00007110 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:00007110                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00007110 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00007110                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:00007110                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:00007110
.text$mn:00007110 var_10          = dword ptr -10h
.text$mn:00007110 var_C           = dword ptr -0Ch
.text$mn:00007110 var_8           = dword ptr -8
.text$mn:00007110 var_1           = byte ptr -1
.text$mn:00007110
.text$mn:00007110                 push    ebp
.text$mn:00007111                 mov     ebp, esp
.text$mn:00007113                 sub     esp, 10h
.text$mn:00007116                 mov     [ebp+var_10], ecx
.text$mn:00007119                 lea     eax, [ebp+var_1]
.text$mn:0000711C                 push    eax
.text$mn:0000711D                 mov     ecx, [ebp+var_10]
.text$mn:00007120                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00007125                 mov     ecx, eax
.text$mn:00007127                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:0000712C                 mov     [ebp+var_8], eax
.text$mn:0000712F                 cmp     [ebp+var_8], 1
.text$mn:00007133                 ja      short loc_713E
.text$mn:00007135                 mov     [ebp+var_C], 1
.text$mn:0000713C                 jmp     short loc_7147
.text$mn:0000713E ; ---------------------------------------------------------------------------
.text$mn:0000713E
.text$mn:0000713E loc_713E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:0000713E                 mov     ecx, [ebp+var_8]
.text$mn:00007141                 sub     ecx, 1
.text$mn:00007144                 mov     [ebp+var_C], ecx
.text$mn:00007147
.text$mn:00007147 loc_7147:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:00007147                 mov     eax, [ebp+var_C]
.text$mn:0000714A                 mov     esp, ebp
.text$mn:0000714C                 pop     ebp
.text$mn:0000714D                 retn
.text$mn:0000714D ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:0000714D
.text$mn:0000714D ; ---------------------------------------------------------------------------
.text$mn:0000714E                 align 10h
.text$mn:0000714E _text$mn        ends
.text$mn:0000714E
.text$mn:00007150 ; ===========================================================================
.text$mn:00007150
.text$mn:00007150 ; Segment type: Pure code
.text$mn:00007150 ; Segment permissions: Read/Execute
.text$mn:00007150 _text$mn        segment para public 'CODE' use32
.text$mn:00007150                 assume cs:_text$mn
.text$mn:00007150                 ;org 7150h
.text$mn:00007150 ; COMDAT (pick any)
.text$mn:00007150                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007150
.text$mn:00007150 ; =============== S U B R O U T I N E =======================================
.text$mn:00007150
.text$mn:00007150 ; Attributes: bp-based frame
.text$mn:00007150
.text$mn:00007150 ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::max_size(void)const
.text$mn:00007150                 public ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:00007150 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:00007150                                         ; CODE XREF: std::vector<int,std::allocator<int>>::_Grow_to(uint)+17p
.text$mn:00007150                                         ; std::vector<int,std::allocator<int>>::_Reserve(uint)+18p
.text$mn:00007150
.text$mn:00007150 var_8           = dword ptr -8
.text$mn:00007150 var_1           = byte ptr -1
.text$mn:00007150
.text$mn:00007150                 push    ebp
.text$mn:00007151                 mov     ebp, esp
.text$mn:00007153                 sub     esp, 8
.text$mn:00007156                 mov     [ebp+var_8], ecx
.text$mn:00007159                 lea     eax, [ebp+var_1]
.text$mn:0000715C                 push    eax
.text$mn:0000715D                 mov     ecx, [ebp+var_8]
.text$mn:00007160                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:00007165                 mov     ecx, eax
.text$mn:00007167                 call    ?max_size@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<int>>::max_size(void)
.text$mn:0000716C                 mov     esp, ebp
.text$mn:0000716E                 pop     ebp
.text$mn:0000716F                 retn
.text$mn:0000716F ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:0000716F
.text$mn:0000716F _text$mn        ends
.text$mn:0000716F
.text$mn:00007170 ; ===========================================================================
.text$mn:00007170
.text$mn:00007170 ; Segment type: Pure code
.text$mn:00007170 ; Segment permissions: Read/Execute
.text$mn:00007170 _text$mn        segment para public 'CODE' use32
.text$mn:00007170                 assume cs:_text$mn
.text$mn:00007170                 ;org 7170h
.text$mn:00007170 ; COMDAT (pick any)
.text$mn:00007170                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007170
.text$mn:00007170 ; =============== S U B R O U T I N E =======================================
.text$mn:00007170
.text$mn:00007170 ; Attributes: bp-based frame
.text$mn:00007170
.text$mn:00007170 ; public: unsigned int __thiscall std::vector<struct iconLocator, class std::allocator<struct iconLocator>>::max_size(void)const
.text$mn:00007170                 public ?max_size@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ
.text$mn:00007170 ?max_size@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ proc near
.text$mn:00007170                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Grow_to(uint)+17p
.text$mn:00007170                                         ; std::vector<iconLocator,std::allocator<iconLocator>>::_Reserve(uint)+18p
.text$mn:00007170
.text$mn:00007170 var_8           = dword ptr -8
.text$mn:00007170 var_1           = byte ptr -1
.text$mn:00007170
.text$mn:00007170                 push    ebp
.text$mn:00007171                 mov     ebp, esp
.text$mn:00007173                 sub     esp, 8
.text$mn:00007176                 mov     [ebp+var_8], ecx
.text$mn:00007179                 lea     eax, [ebp+var_1]
.text$mn:0000717C                 push    eax
.text$mn:0000717D                 mov     ecx, [ebp+var_8]
.text$mn:00007180                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<iconLocator,std::allocator<iconLocator>>>::_Getal(void)
.text$mn:00007185                 mov     ecx, eax
.text$mn:00007187                 call    ?max_size@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<iconLocator>>::max_size(void)
.text$mn:0000718C                 mov     esp, ebp
.text$mn:0000718E                 pop     ebp
.text$mn:0000718F                 retn
.text$mn:0000718F ?max_size@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ endp
.text$mn:0000718F
.text$mn:0000718F _text$mn        ends
.text$mn:0000718F
.text$mn:00007190 ; ===========================================================================
.text$mn:00007190
.text$mn:00007190 ; Segment type: Pure code
.text$mn:00007190 ; Segment permissions: Read/Execute
.text$mn:00007190 _text$mn        segment para public 'CODE' use32
.text$mn:00007190                 assume cs:_text$mn
.text$mn:00007190                 ;org 7190h
.text$mn:00007190 ; COMDAT (pick any)
.text$mn:00007190                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007190
.text$mn:00007190 ; =============== S U B R O U T I N E =======================================
.text$mn:00007190
.text$mn:00007190 ; Attributes: bp-based frame
.text$mn:00007190
.text$mn:00007190 ; public: unsigned int __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::max_size(void)const
.text$mn:00007190                 public ?max_size@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ
.text$mn:00007190 ?max_size@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ proc near
.text$mn:00007190                                         ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::_Grow_to(uint)+17p
.text$mn:00007190                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reserve(uint)+18p
.text$mn:00007190
.text$mn:00007190 var_8           = dword ptr -8
.text$mn:00007190 var_1           = byte ptr -1
.text$mn:00007190
.text$mn:00007190                 push    ebp
.text$mn:00007191                 mov     ebp, esp
.text$mn:00007193                 sub     esp, 8
.text$mn:00007196                 mov     [ebp+var_8], ecx
.text$mn:00007199                 lea     eax, [ebp+var_1]
.text$mn:0000719C                 push    eax
.text$mn:0000719D                 mov     ecx, [ebp+var_8]
.text$mn:000071A0                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tDynamicList,std::allocator<tDynamicList>>>::_Getal(void)
.text$mn:000071A5                 mov     ecx, eax
.text$mn:000071A7                 call    ?max_size@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<tDynamicList>>::max_size(void)
.text$mn:000071AC                 mov     esp, ebp
.text$mn:000071AE                 pop     ebp
.text$mn:000071AF                 retn
.text$mn:000071AF ?max_size@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ endp
.text$mn:000071AF
.text$mn:000071AF _text$mn        ends
.text$mn:000071AF
.text$mn:000071B0 ; ===========================================================================
.text$mn:000071B0
.text$mn:000071B0 ; Segment type: Pure code
.text$mn:000071B0 ; Segment permissions: Read/Execute
.text$mn:000071B0 _text$mn        segment para public 'CODE' use32
.text$mn:000071B0                 assume cs:_text$mn
.text$mn:000071B0                 ;org 71B0h
.text$mn:000071B0 ; COMDAT (pick any)
.text$mn:000071B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000071B0
.text$mn:000071B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000071B0
.text$mn:000071B0 ; Attributes: bp-based frame
.text$mn:000071B0
.text$mn:000071B0 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:000071B0                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000071B0 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000071B0                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:000071B0                                         ; DATA XREF: .rdata:00008960o
.text$mn:000071B0
.text$mn:000071B0 var_1C          = dword ptr -1Ch
.text$mn:000071B0 var_18          = dword ptr -18h
.text$mn:000071B0 Str             = dword ptr -14h
.text$mn:000071B0 var_10          = dword ptr -10h
.text$mn:000071B0 var_C           = dword ptr -0Ch
.text$mn:000071B0 var_4           = dword ptr -4
.text$mn:000071B0 arg_0           = dword ptr  8
.text$mn:000071B0 arg_4           = dword ptr  0Ch
.text$mn:000071B0
.text$mn:000071B0                 push    ebp
.text$mn:000071B1                 mov     ebp, esp
.text$mn:000071B3                 push    0FFFFFFFFh
.text$mn:000071B5                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000071BA                 mov     eax, large fs:0
.text$mn:000071C0                 push    eax
.text$mn:000071C1                 sub     esp, 10h
.text$mn:000071C4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000071C9                 xor     eax, ebp
.text$mn:000071CB                 push    eax
.text$mn:000071CC                 lea     eax, [ebp+var_C]
.text$mn:000071CF                 mov     large fs:0, eax
.text$mn:000071D5                 mov     [ebp+var_1C], ecx
.text$mn:000071D8                 mov     [ebp+var_18], 0
.text$mn:000071DF                 mov     eax, [ebp+arg_4]
.text$mn:000071E2                 push    eax             ; int
.text$mn:000071E3                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000071E8                 add     esp, 4
.text$mn:000071EB                 mov     [ebp+var_10], eax
.text$mn:000071EE                 cmp     [ebp+var_10], 0
.text$mn:000071F2                 jz      short loc_71FC
.text$mn:000071F4                 mov     ecx, [ebp+var_10]
.text$mn:000071F7                 mov     [ebp+Str], ecx
.text$mn:000071FA                 jmp     short loc_7203
.text$mn:000071FC ; ---------------------------------------------------------------------------
.text$mn:000071FC
.text$mn:000071FC loc_71FC:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:000071FC                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00007203
.text$mn:00007203 loc_7203:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00007203                 mov     edx, [ebp+Str]
.text$mn:00007206                 push    edx             ; Str
.text$mn:00007207                 mov     ecx, [ebp+arg_0]
.text$mn:0000720A                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000720F                 mov     [ebp+var_4], 0
.text$mn:00007216                 mov     eax, [ebp+var_18]
.text$mn:00007219                 or      eax, 1
.text$mn:0000721C                 mov     [ebp+var_18], eax
.text$mn:0000721F                 mov     eax, [ebp+arg_0]
.text$mn:00007222                 mov     ecx, [ebp+var_C]
.text$mn:00007225                 mov     large fs:0, ecx
.text$mn:0000722C                 pop     ecx
.text$mn:0000722D                 mov     esp, ebp
.text$mn:0000722F                 pop     ebp
.text$mn:00007230                 retn    8
.text$mn:00007230 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00007230
.text$mn:00007230 ; ---------------------------------------------------------------------------
.text$mn:00007233                 align 4
.text$mn:00007233 _text$mn        ends
.text$mn:00007233
.text$x:00007234 ; ===========================================================================
.text$x:00007234
.text$x:00007234 ; Segment type: Pure code
.text$x:00007234 ; Segment permissions: Read/Execute
.text$x:00007234 _text$x         segment para public 'CODE' use32
.text$x:00007234                 assume cs:_text$x
.text$x:00007234                 ;org 7234h
.text$x:00007234 ; COMDAT (pick associative to section at 71B0)
.text$x:00007234                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007234
.text$x:00007234 ; =============== S U B R O U T I N E =======================================
.text$x:00007234
.text$x:00007234
.text$x:00007234 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00007234                                         ; DATA XREF: .xdata$x:00007D60o
.text$x:00007234                 mov     eax, [ebp-18h]
.text$x:00007237                 and     eax, 1
.text$x:0000723A                 jz      $LN6
.text$x:00007240                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00007244                 mov     ecx, [ebp+8]
.text$x:00007247                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000724C ; ---------------------------------------------------------------------------
.text$x:0000724C
.text$x:0000724C $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:0000724C                 retn
.text$x:0000724C __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:0000724C
.text$x:0000724D
.text$x:0000724D ; =============== S U B R O U T I N E =======================================
.text$x:0000724D
.text$x:0000724D
.text$x:0000724D __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:0000724D                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:0000724D
.text$x:0000724D arg_4           = dword ptr  8
.text$x:0000724D
.text$x:0000724D                 mov     edx, [esp+arg_4]
.text$x:00007251                 lea     eax, [edx+0Ch]
.text$x:00007254                 mov     ecx, [edx-14h]
.text$x:00007257                 xor     ecx, eax
.text$x:00007259                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000725E                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00007263                 jmp     ___CxxFrameHandler3
.text$x:00007263 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00007263
.text$x:00007263 _text$x         ends
.text$x:00007263
.text$mn:00007268 ; ===========================================================================
.text$mn:00007268
.text$mn:00007268 ; Segment type: Pure code
.text$mn:00007268 ; Segment permissions: Read/Execute
.text$mn:00007268 _text$mn        segment para public 'CODE' use32
.text$mn:00007268                 assume cs:_text$mn
.text$mn:00007268                 ;org 7268h
.text$mn:00007268 ; COMDAT (pick any)
.text$mn:00007268                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007268
.text$mn:00007268 ; =============== S U B R O U T I N E =======================================
.text$mn:00007268
.text$mn:00007268 ; Attributes: bp-based frame
.text$mn:00007268
.text$mn:00007268 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00007268                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00007268 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00007268                                         ; DATA XREF: .rdata:00008994o
.text$mn:00007268
.text$mn:00007268 var_14          = dword ptr -14h
.text$mn:00007268 var_10          = dword ptr -10h
.text$mn:00007268 var_C           = dword ptr -0Ch
.text$mn:00007268 var_4           = dword ptr -4
.text$mn:00007268 arg_0           = dword ptr  8
.text$mn:00007268 arg_4           = dword ptr  0Ch
.text$mn:00007268
.text$mn:00007268                 push    ebp
.text$mn:00007269                 mov     ebp, esp
.text$mn:0000726B                 push    0FFFFFFFFh
.text$mn:0000726D                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00007272                 mov     eax, large fs:0
.text$mn:00007278                 push    eax
.text$mn:00007279                 sub     esp, 8
.text$mn:0000727C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007281                 xor     eax, ebp
.text$mn:00007283                 push    eax
.text$mn:00007284                 lea     eax, [ebp+var_C]
.text$mn:00007287                 mov     large fs:0, eax
.text$mn:0000728D                 mov     [ebp+var_14], ecx
.text$mn:00007290                 mov     [ebp+var_10], 0
.text$mn:00007297                 cmp     [ebp+arg_4], 1
.text$mn:0000729B                 jnz     short loc_72C1
.text$mn:0000729D                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:000072A2                 mov     ecx, [ebp+arg_0]
.text$mn:000072A5                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000072AA                 mov     [ebp+var_4], 0
.text$mn:000072B1                 mov     eax, [ebp+var_10]
.text$mn:000072B4                 or      eax, 1
.text$mn:000072B7                 mov     [ebp+var_10], eax
.text$mn:000072BA                 mov     eax, [ebp+arg_0]
.text$mn:000072BD                 jmp     short loc_72E4
.text$mn:000072BF ; ---------------------------------------------------------------------------
.text$mn:000072BF                 jmp     short loc_72E4
.text$mn:000072C1 ; ---------------------------------------------------------------------------
.text$mn:000072C1
.text$mn:000072C1 loc_72C1:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:000072C1                 mov     ecx, [ebp+arg_4]
.text$mn:000072C4                 push    ecx
.text$mn:000072C5                 mov     edx, [ebp+arg_0]
.text$mn:000072C8                 push    edx
.text$mn:000072C9                 mov     ecx, [ebp+var_14]
.text$mn:000072CC                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:000072D1                 mov     [ebp+var_4], 0
.text$mn:000072D8                 mov     eax, [ebp+var_10]
.text$mn:000072DB                 or      eax, 1
.text$mn:000072DE                 mov     [ebp+var_10], eax
.text$mn:000072E1                 mov     eax, [ebp+arg_0]
.text$mn:000072E4
.text$mn:000072E4 loc_72E4:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:000072E4                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:000072E4                 mov     ecx, [ebp+var_C]
.text$mn:000072E7                 mov     large fs:0, ecx
.text$mn:000072EE                 pop     ecx
.text$mn:000072EF                 mov     esp, ebp
.text$mn:000072F1                 pop     ebp
.text$mn:000072F2                 retn    8
.text$mn:000072F2 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000072F2
.text$mn:000072F2 ; ---------------------------------------------------------------------------
.text$mn:000072F5                 align 4
.text$mn:000072F5 _text$mn        ends
.text$mn:000072F5
.text$x:000072F8 ; ===========================================================================
.text$x:000072F8
.text$x:000072F8 ; Segment type: Pure code
.text$x:000072F8 ; Segment permissions: Read/Execute
.text$x:000072F8 _text$x         segment para public 'CODE' use32
.text$x:000072F8                 assume cs:_text$x
.text$x:000072F8                 ;org 72F8h
.text$x:000072F8 ; COMDAT (pick associative to section at 7268)
.text$x:000072F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000072F8
.text$x:000072F8 ; =============== S U B R O U T I N E =======================================
.text$x:000072F8
.text$x:000072F8
.text$x:000072F8 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000072F8                                         ; DATA XREF: .xdata$x:00007DE4o
.text$x:000072F8                 mov     eax, [ebp-10h]
.text$x:000072FB                 and     eax, 1
.text$x:000072FE                 jz      $LN6_0
.text$x:00007304                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00007308                 mov     ecx, [ebp+8]
.text$x:0000730B                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00007310 ; ---------------------------------------------------------------------------
.text$x:00007310
.text$x:00007310 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00007310                 retn
.text$x:00007310 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00007310
.text$x:00007311
.text$x:00007311 ; =============== S U B R O U T I N E =======================================
.text$x:00007311
.text$x:00007311
.text$x:00007311 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00007311                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00007311
.text$x:00007311 arg_4           = dword ptr  8
.text$x:00007311
.text$x:00007311                 mov     edx, [esp+arg_4]
.text$x:00007315                 lea     eax, [edx+0Ch]
.text$x:00007318                 mov     ecx, [edx-0Ch]
.text$x:0000731B                 xor     ecx, eax
.text$x:0000731D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007322                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00007327                 jmp     ___CxxFrameHandler3
.text$x:00007327 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00007327
.text$x:00007327 _text$x         ends
.text$x:00007327
.text$mn:0000732C ; ===========================================================================
.text$mn:0000732C
.text$mn:0000732C ; Segment type: Pure code
.text$mn:0000732C ; Segment permissions: Read/Execute
.text$mn:0000732C _text$mn        segment para public 'CODE' use32
.text$mn:0000732C                 assume cs:_text$mn
.text$mn:0000732C                 ;org 732Ch
.text$mn:0000732C ; COMDAT (pick any)
.text$mn:0000732C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000732C
.text$mn:0000732C ; =============== S U B R O U T I N E =======================================
.text$mn:0000732C
.text$mn:0000732C ; Attributes: bp-based frame
.text$mn:0000732C
.text$mn:0000732C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:0000732C                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000732C ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000732C                                         ; DATA XREF: .rdata:000089D4o
.text$mn:0000732C
.text$mn:0000732C var_1C          = dword ptr -1Ch
.text$mn:0000732C var_18          = dword ptr -18h
.text$mn:0000732C Str             = dword ptr -14h
.text$mn:0000732C var_10          = dword ptr -10h
.text$mn:0000732C var_C           = dword ptr -0Ch
.text$mn:0000732C var_4           = dword ptr -4
.text$mn:0000732C arg_0           = dword ptr  8
.text$mn:0000732C arg_4           = dword ptr  0Ch
.text$mn:0000732C
.text$mn:0000732C                 push    ebp
.text$mn:0000732D                 mov     ebp, esp
.text$mn:0000732F                 push    0FFFFFFFFh
.text$mn:00007331                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00007336                 mov     eax, large fs:0
.text$mn:0000733C                 push    eax
.text$mn:0000733D                 sub     esp, 10h
.text$mn:00007340                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007345                 xor     eax, ebp
.text$mn:00007347                 push    eax
.text$mn:00007348                 lea     eax, [ebp+var_C]
.text$mn:0000734B                 mov     large fs:0, eax
.text$mn:00007351                 mov     [ebp+var_1C], ecx
.text$mn:00007354                 mov     [ebp+var_18], 0
.text$mn:0000735B                 mov     eax, [ebp+arg_4]
.text$mn:0000735E                 push    eax             ; int
.text$mn:0000735F                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00007364                 add     esp, 4
.text$mn:00007367                 mov     [ebp+var_10], eax
.text$mn:0000736A                 cmp     [ebp+var_10], 0
.text$mn:0000736E                 jz      short loc_7378
.text$mn:00007370                 mov     ecx, [ebp+var_10]
.text$mn:00007373                 mov     [ebp+Str], ecx
.text$mn:00007376                 jmp     short loc_737F
.text$mn:00007378 ; ---------------------------------------------------------------------------
.text$mn:00007378
.text$mn:00007378 loc_7378:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00007378                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000737F
.text$mn:0000737F loc_737F:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:0000737F                 mov     edx, [ebp+Str]
.text$mn:00007382                 push    edx             ; Str
.text$mn:00007383                 mov     ecx, [ebp+arg_0]
.text$mn:00007386                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:0000738B                 mov     [ebp+var_4], 0
.text$mn:00007392                 mov     eax, [ebp+var_18]
.text$mn:00007395                 or      eax, 1
.text$mn:00007398                 mov     [ebp+var_18], eax
.text$mn:0000739B                 mov     eax, [ebp+arg_0]
.text$mn:0000739E                 mov     ecx, [ebp+var_C]
.text$mn:000073A1                 mov     large fs:0, ecx
.text$mn:000073A8                 pop     ecx
.text$mn:000073A9                 mov     esp, ebp
.text$mn:000073AB                 pop     ebp
.text$mn:000073AC                 retn    8
.text$mn:000073AC ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000073AC
.text$mn:000073AC ; ---------------------------------------------------------------------------
.text$mn:000073AF                 align 10h
.text$mn:000073AF _text$mn        ends
.text$mn:000073AF
.text$x:000073B0 ; ===========================================================================
.text$x:000073B0
.text$x:000073B0 ; Segment type: Pure code
.text$x:000073B0 ; Segment permissions: Read/Execute
.text$x:000073B0 _text$x         segment para public 'CODE' use32
.text$x:000073B0                 assume cs:_text$x
.text$x:000073B0                 ;org 73B0h
.text$x:000073B0 ; COMDAT (pick associative to section at 732C)
.text$x:000073B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000073B0
.text$x:000073B0 ; =============== S U B R O U T I N E =======================================
.text$x:000073B0
.text$x:000073B0
.text$x:000073B0 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000073B0                                         ; DATA XREF: .xdata$x:00007E68o
.text$x:000073B0                 mov     eax, [ebp-18h]
.text$x:000073B3                 and     eax, 1
.text$x:000073B6                 jz      $LN6_1
.text$x:000073BC                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000073C0                 mov     ecx, [ebp+8]
.text$x:000073C3                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000073C8 ; ---------------------------------------------------------------------------
.text$x:000073C8
.text$x:000073C8 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000073C8                 retn
.text$x:000073C8 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000073C8
.text$x:000073C9
.text$x:000073C9 ; =============== S U B R O U T I N E =======================================
.text$x:000073C9
.text$x:000073C9
.text$x:000073C9 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000073C9                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:000073C9
.text$x:000073C9 arg_4           = dword ptr  8
.text$x:000073C9
.text$x:000073C9                 mov     edx, [esp+arg_4]
.text$x:000073CD                 lea     eax, [edx+0Ch]
.text$x:000073D0                 mov     ecx, [edx-14h]
.text$x:000073D3                 xor     ecx, eax
.text$x:000073D5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000073DA                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000073DF                 jmp     ___CxxFrameHandler3
.text$x:000073DF __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000073DF
.text$x:000073DF _text$x         ends
.text$x:000073DF
.text$mn:000073E4 ; ===========================================================================
.text$mn:000073E4
.text$mn:000073E4 ; Segment type: Pure code
.text$mn:000073E4 ; Segment permissions: Read/Execute
.text$mn:000073E4 _text$mn        segment para public 'CODE' use32
.text$mn:000073E4                 assume cs:_text$mn
.text$mn:000073E4                 ;org 73E4h
.text$mn:000073E4 ; COMDAT (pick any)
.text$mn:000073E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000073E4
.text$mn:000073E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000073E4
.text$mn:000073E4 ; Attributes: bp-based frame
.text$mn:000073E4
.text$mn:000073E4 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000073E4                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000073E4 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000073E4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000073E4
.text$mn:000073E4 var_4           = dword ptr -4
.text$mn:000073E4 Dst             = dword ptr  8
.text$mn:000073E4 Src             = dword ptr  0Ch
.text$mn:000073E4 Size            = dword ptr  10h
.text$mn:000073E4
.text$mn:000073E4                 push    ebp
.text$mn:000073E5                 mov     ebp, esp
.text$mn:000073E7                 push    ecx
.text$mn:000073E8                 cmp     [ebp+Size], 0
.text$mn:000073EC                 jnz     short loc_73F6
.text$mn:000073EE                 mov     eax, [ebp+Dst]
.text$mn:000073F1                 mov     [ebp+var_4], eax
.text$mn:000073F4                 jmp     short loc_740D
.text$mn:000073F6 ; ---------------------------------------------------------------------------
.text$mn:000073F6
.text$mn:000073F6 loc_73F6:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:000073F6                 mov     ecx, [ebp+Size]
.text$mn:000073F9                 push    ecx             ; Size
.text$mn:000073FA                 mov     edx, [ebp+Src]
.text$mn:000073FD                 push    edx             ; Src
.text$mn:000073FE                 mov     eax, [ebp+Dst]
.text$mn:00007401                 push    eax             ; Dst
.text$mn:00007402                 call    _memmove
.text$mn:00007407                 add     esp, 0Ch
.text$mn:0000740A                 mov     [ebp+var_4], eax
.text$mn:0000740D
.text$mn:0000740D loc_740D:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:0000740D                 mov     eax, [ebp+var_4]
.text$mn:00007410                 mov     esp, ebp
.text$mn:00007412                 pop     ebp
.text$mn:00007413                 retn
.text$mn:00007413 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00007413
.text$mn:00007413 _text$mn        ends
.text$mn:00007413
.text$mn:00007414 ; ===========================================================================
.text$mn:00007414
.text$mn:00007414 ; Segment type: Pure code
.text$mn:00007414 ; Segment permissions: Read/Execute
.text$mn:00007414 _text$mn        segment para public 'CODE' use32
.text$mn:00007414                 assume cs:_text$mn
.text$mn:00007414                 ;org 7414h
.text$mn:00007414 ; COMDAT (pick any)
.text$mn:00007414                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007414
.text$mn:00007414 ; =============== S U B R O U T I N E =======================================
.text$mn:00007414
.text$mn:00007414 ; Attributes: bp-based frame
.text$mn:00007414
.text$mn:00007414 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:00007414                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00007414 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00007414                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:00007414
.text$mn:00007414 var_4           = dword ptr -4
.text$mn:00007414 Dst             = dword ptr  8
.text$mn:00007414 Src             = dword ptr  0Ch
.text$mn:00007414 arg_8           = dword ptr  10h
.text$mn:00007414
.text$mn:00007414                 push    ebp
.text$mn:00007415                 mov     ebp, esp
.text$mn:00007417                 push    ecx
.text$mn:00007418                 cmp     [ebp+arg_8], 0
.text$mn:0000741C                 jnz     short loc_7426
.text$mn:0000741E                 mov     eax, [ebp+Dst]
.text$mn:00007421                 mov     [ebp+var_4], eax
.text$mn:00007424                 jmp     short loc_743D
.text$mn:00007426 ; ---------------------------------------------------------------------------
.text$mn:00007426
.text$mn:00007426 loc_7426:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00007426                 mov     ecx, [ebp+arg_8]
.text$mn:00007429                 push    ecx             ; int
.text$mn:0000742A                 mov     edx, [ebp+Src]
.text$mn:0000742D                 push    edx             ; Src
.text$mn:0000742E                 mov     eax, [ebp+Dst]
.text$mn:00007431                 push    eax             ; Dst
.text$mn:00007432                 call    _wmemmove
.text$mn:00007437                 add     esp, 0Ch
.text$mn:0000743A                 mov     [ebp+var_4], eax
.text$mn:0000743D
.text$mn:0000743D loc_743D:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:0000743D                 mov     eax, [ebp+var_4]
.text$mn:00007440                 mov     esp, ebp
.text$mn:00007442                 pop     ebp
.text$mn:00007443                 retn
.text$mn:00007443 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00007443
.text$mn:00007443 _text$mn        ends
.text$mn:00007443
.text$mn:00007444 ; ===========================================================================
.text$mn:00007444
.text$mn:00007444 ; Segment type: Pure code
.text$mn:00007444 ; Segment permissions: Read/Execute
.text$mn:00007444 _text$mn        segment para public 'CODE' use32
.text$mn:00007444                 assume cs:_text$mn
.text$mn:00007444                 ;org 7444h
.text$mn:00007444 ; COMDAT (pick any)
.text$mn:00007444                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007444
.text$mn:00007444 ; =============== S U B R O U T I N E =======================================
.text$mn:00007444
.text$mn:00007444 ; Attributes: bp-based frame
.text$mn:00007444
.text$mn:00007444 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00007444                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00007444 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00007444                                         ; DATA XREF: .rdata:0000895Co
.text$mn:00007444
.text$mn:00007444 var_4           = dword ptr -4
.text$mn:00007444
.text$mn:00007444                 push    ebp
.text$mn:00007445                 mov     ebp, esp
.text$mn:00007447                 push    ecx
.text$mn:00007448                 mov     [ebp+var_4], ecx
.text$mn:0000744B                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00007450                 mov     esp, ebp
.text$mn:00007452                 pop     ebp
.text$mn:00007453                 retn
.text$mn:00007453 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00007453
.text$mn:00007453 _text$mn        ends
.text$mn:00007453
.text$mn:00007454 ; ===========================================================================
.text$mn:00007454
.text$mn:00007454 ; Segment type: Pure code
.text$mn:00007454 ; Segment permissions: Read/Execute
.text$mn:00007454 _text$mn        segment para public 'CODE' use32
.text$mn:00007454                 assume cs:_text$mn
.text$mn:00007454                 ;org 7454h
.text$mn:00007454 ; COMDAT (pick any)
.text$mn:00007454                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007454
.text$mn:00007454 ; =============== S U B R O U T I N E =======================================
.text$mn:00007454
.text$mn:00007454 ; Attributes: bp-based frame
.text$mn:00007454
.text$mn:00007454 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00007454                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00007454 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00007454                                         ; DATA XREF: .rdata:00008990o
.text$mn:00007454
.text$mn:00007454 var_4           = dword ptr -4
.text$mn:00007454
.text$mn:00007454                 push    ebp
.text$mn:00007455                 mov     ebp, esp
.text$mn:00007457                 push    ecx
.text$mn:00007458                 mov     [ebp+var_4], ecx
.text$mn:0000745B                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00007460                 mov     esp, ebp
.text$mn:00007462                 pop     ebp
.text$mn:00007463                 retn
.text$mn:00007463 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00007463
.text$mn:00007463 _text$mn        ends
.text$mn:00007463
.text$mn:00007464 ; ===========================================================================
.text$mn:00007464
.text$mn:00007464 ; Segment type: Pure code
.text$mn:00007464 ; Segment permissions: Read/Execute
.text$mn:00007464 _text$mn        segment para public 'CODE' use32
.text$mn:00007464                 assume cs:_text$mn
.text$mn:00007464                 ;org 7464h
.text$mn:00007464 ; COMDAT (pick any)
.text$mn:00007464                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007464
.text$mn:00007464 ; =============== S U B R O U T I N E =======================================
.text$mn:00007464
.text$mn:00007464 ; Attributes: bp-based frame
.text$mn:00007464
.text$mn:00007464 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00007464                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00007464 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00007464                                         ; DATA XREF: .rdata:000089D0o
.text$mn:00007464
.text$mn:00007464 var_4           = dword ptr -4
.text$mn:00007464
.text$mn:00007464                 push    ebp
.text$mn:00007465                 mov     ebp, esp
.text$mn:00007467                 push    ecx
.text$mn:00007468                 mov     [ebp+var_4], ecx
.text$mn:0000746B                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00007470                 mov     esp, ebp
.text$mn:00007472                 pop     ebp
.text$mn:00007473                 retn
.text$mn:00007473 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00007473
.text$mn:00007473 _text$mn        ends
.text$mn:00007473
.text$mn:00007474 ; ===========================================================================
.text$mn:00007474
.text$mn:00007474 ; Segment type: Pure code
.text$mn:00007474 ; Segment permissions: Read/Execute
.text$mn:00007474 _text$mn        segment para public 'CODE' use32
.text$mn:00007474                 assume cs:_text$mn
.text$mn:00007474                 ;org 7474h
.text$mn:00007474 ; COMDAT (pick any)
.text$mn:00007474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007474
.text$mn:00007474 ; =============== S U B R O U T I N E =======================================
.text$mn:00007474
.text$mn:00007474 ; Attributes: bp-based frame
.text$mn:00007474
.text$mn:00007474 ; public: void __thiscall std::vector<int, class std::allocator<int>>::push_back(int const &)
.text$mn:00007474                 public ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
.text$mn:00007474 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z proc near
.text$mn:00007474                                         ; CODE XREF: ReBar::getNewID(void)+80p
.text$mn:00007474
.text$mn:00007474 var_C           = dword ptr -0Ch
.text$mn:00007474 var_8           = dword ptr -8
.text$mn:00007474 var_2           = byte ptr -2
.text$mn:00007474 var_1           = byte ptr -1
.text$mn:00007474 arg_0           = dword ptr  8
.text$mn:00007474
.text$mn:00007474                 push    ebp
.text$mn:00007475                 mov     ebp, esp
.text$mn:00007477                 sub     esp, 0Ch
.text$mn:0000747A                 mov     [ebp+var_8], ecx
.text$mn:0000747D                 mov     eax, [ebp+arg_0]
.text$mn:00007480                 push    eax
.text$mn:00007481                 call    ??$addressof@$$CBH@std@@YAPBHABH@Z ; std::addressof<int const>(int const &)
.text$mn:00007486                 add     esp, 4
.text$mn:00007489                 push    eax
.text$mn:0000748A                 mov     ecx, [ebp+var_8]
.text$mn:0000748D                 call    ?_Inside@?$vector@HV?$allocator@H@std@@@std@@IBE_NPBH@Z ; std::vector<int,std::allocator<int>>::_Inside(int const *)
.text$mn:00007492                 movzx   ecx, al
.text$mn:00007495                 test    ecx, ecx
.text$mn:00007497                 jz      short loc_7517
.text$mn:00007499                 mov     edx, [ebp+arg_0]
.text$mn:0000749C                 push    edx
.text$mn:0000749D                 call    ??$addressof@$$CBH@std@@YAPBHABH@Z ; std::addressof<int const>(int const &)
.text$mn:000074A2                 add     esp, 4
.text$mn:000074A5                 mov     ecx, [ebp+var_8]
.text$mn:000074A8                 sub     eax, [ecx+4]
.text$mn:000074AB                 sar     eax, 2
.text$mn:000074AE                 mov     [ebp+var_C], eax
.text$mn:000074B1                 mov     edx, [ebp+var_8]
.text$mn:000074B4                 mov     eax, [ebp+var_8]
.text$mn:000074B7                 mov     ecx, [edx+8]
.text$mn:000074BA                 cmp     ecx, [eax+0Ch]
.text$mn:000074BD                 jnz     short loc_74C9
.text$mn:000074BF                 push    1
.text$mn:000074C1                 mov     ecx, [ebp+var_8]
.text$mn:000074C4                 call    ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int>>::_Reserve(uint)
.text$mn:000074C9
.text$mn:000074C9 loc_74C9:                               ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+49j
.text$mn:000074C9                 mov     edx, [ebp+var_8]
.text$mn:000074CC                 mov     eax, [edx+8]
.text$mn:000074CF                 push    eax
.text$mn:000074D0                 mov     ecx, [ebp+var_8]
.text$mn:000074D3                 mov     edx, [ecx+8]
.text$mn:000074D6                 push    edx
.text$mn:000074D7                 mov     ecx, [ebp+var_8]
.text$mn:000074DA                 call    ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)
.text$mn:000074DF                 mov     eax, [ebp+var_8]
.text$mn:000074E2                 mov     ecx, [eax+4]
.text$mn:000074E5                 mov     edx, [ebp+var_C]
.text$mn:000074E8                 lea     eax, [ecx+edx*4]
.text$mn:000074EB                 push    eax             ; int
.text$mn:000074EC                 mov     ecx, [ebp+var_8]
.text$mn:000074EF                 mov     edx, [ecx+8]
.text$mn:000074F2                 push    edx             ; void *
.text$mn:000074F3                 lea     eax, [ebp+var_1]
.text$mn:000074F6                 push    eax
.text$mn:000074F7                 mov     ecx, [ebp+var_8]
.text$mn:000074FA                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:000074FF                 mov     ecx, eax
.text$mn:00007501                 call    ??$construct@HAAH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHAAH@Z ; std::_Wrap_alloc<std::allocator<int>>::construct<int,int &>(int *,int &)
.text$mn:00007506                 mov     ecx, [ebp+var_8]
.text$mn:00007509                 mov     edx, [ecx+8]
.text$mn:0000750C                 add     edx, 4
.text$mn:0000750F                 mov     eax, [ebp+var_8]
.text$mn:00007512                 mov     [eax+8], edx
.text$mn:00007515                 jmp     short loc_7572
.text$mn:00007517 ; ---------------------------------------------------------------------------
.text$mn:00007517
.text$mn:00007517 loc_7517:                               ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+23j
.text$mn:00007517                 mov     ecx, [ebp+var_8]
.text$mn:0000751A                 mov     edx, [ebp+var_8]
.text$mn:0000751D                 mov     eax, [ecx+8]
.text$mn:00007520                 cmp     eax, [edx+0Ch]
.text$mn:00007523                 jnz     short loc_752F
.text$mn:00007525                 push    1
.text$mn:00007527                 mov     ecx, [ebp+var_8]
.text$mn:0000752A                 call    ?_Reserve@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::vector<int,std::allocator<int>>::_Reserve(uint)
.text$mn:0000752F
.text$mn:0000752F loc_752F:                               ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+AFj
.text$mn:0000752F                 mov     ecx, [ebp+var_8]
.text$mn:00007532                 mov     edx, [ecx+8]
.text$mn:00007535                 push    edx
.text$mn:00007536                 mov     eax, [ebp+var_8]
.text$mn:00007539                 mov     ecx, [eax+8]
.text$mn:0000753C                 push    ecx
.text$mn:0000753D                 mov     ecx, [ebp+var_8]
.text$mn:00007540                 call    ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z ; std::vector<int,std::allocator<int>>::_Orphan_range(int *,int *)
.text$mn:00007545                 mov     edx, [ebp+arg_0]
.text$mn:00007548                 push    edx             ; int
.text$mn:00007549                 mov     eax, [ebp+var_8]
.text$mn:0000754C                 mov     ecx, [eax+8]
.text$mn:0000754F                 push    ecx             ; void *
.text$mn:00007550                 lea     edx, [ebp+var_2]
.text$mn:00007553                 push    edx
.text$mn:00007554                 mov     ecx, [ebp+var_8]
.text$mn:00007557                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@H@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<int,std::allocator<int>>>::_Getal(void)
.text$mn:0000755C                 mov     ecx, eax
.text$mn:0000755E                 call    ??$construct@HABH@?$_Wrap_alloc@V?$allocator@H@std@@@std@@QAEXPAHABH@Z ; std::_Wrap_alloc<std::allocator<int>>::construct<int,int const &>(int *,int const &)
.text$mn:00007563                 mov     eax, [ebp+var_8]
.text$mn:00007566                 mov     ecx, [eax+8]
.text$mn:00007569                 add     ecx, 4
.text$mn:0000756C                 mov     edx, [ebp+var_8]
.text$mn:0000756F                 mov     [edx+8], ecx
.text$mn:00007572
.text$mn:00007572 loc_7572:                               ; CODE XREF: std::vector<int,std::allocator<int>>::push_back(int const &)+A1j
.text$mn:00007572                 mov     esp, ebp
.text$mn:00007574                 pop     ebp
.text$mn:00007575                 retn    4
.text$mn:00007575 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z endp
.text$mn:00007575
.text$mn:00007575 _text$mn        ends
.text$mn:00007575
.text$mn:00007578 ; ===========================================================================
.text$mn:00007578
.text$mn:00007578 ; Segment type: Pure code
.text$mn:00007578 ; Segment permissions: Read/Execute
.text$mn:00007578 _text$mn        segment para public 'CODE' use32
.text$mn:00007578                 assume cs:_text$mn
.text$mn:00007578                 ;org 7578h
.text$mn:00007578 ; COMDAT (pick any)
.text$mn:00007578                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007578
.text$mn:00007578 ; =============== S U B R O U T I N E =======================================
.text$mn:00007578
.text$mn:00007578 ; Attributes: bp-based frame
.text$mn:00007578
.text$mn:00007578 ; public: void __thiscall std::vector<struct iconLocator, class std::allocator<struct iconLocator>>::push_back(struct iconLocator &&)
.text$mn:00007578                 public ?push_back@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QAEX$$QAUiconLocator@@@Z
.text$mn:00007578 ?push_back@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QAEX$$QAUiconLocator@@@Z proc near
.text$mn:00007578                                         ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+253p
.text$mn:00007578                                         ; ToolBar::initTheme(TiXmlDocument *)+36Dp ...
.text$mn:00007578
.text$mn:00007578 var_C           = dword ptr -0Ch
.text$mn:00007578 var_8           = dword ptr -8
.text$mn:00007578 var_2           = byte ptr -2
.text$mn:00007578 var_1           = byte ptr -1
.text$mn:00007578 arg_0           = dword ptr  8
.text$mn:00007578
.text$mn:00007578                 push    ebp
.text$mn:00007579                 mov     ebp, esp
.text$mn:0000757B                 sub     esp, 0Ch
.text$mn:0000757E                 mov     [ebp+var_8], ecx
.text$mn:00007581                 mov     eax, [ebp+arg_0]
.text$mn:00007584                 push    eax
.text$mn:00007585                 call    ??$addressof@UiconLocator@@@std@@YAPAUiconLocator@@AAU1@@Z ; std::addressof<iconLocator>(iconLocator &)
.text$mn:0000758A                 add     esp, 4
.text$mn:0000758D                 push    eax
.text$mn:0000758E                 mov     ecx, [ebp+var_8]
.text$mn:00007591                 call    ?_Inside@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBE_NPBUiconLocator@@@Z ; std::vector<iconLocator,std::allocator<iconLocator>>::_Inside(iconLocator const *)
.text$mn:00007596                 movzx   ecx, al
.text$mn:00007599                 test    ecx, ecx
.text$mn:0000759B                 jz      loc_762B
.text$mn:000075A1                 mov     edx, [ebp+arg_0]
.text$mn:000075A4                 push    edx
.text$mn:000075A5                 call    ??$addressof@UiconLocator@@@std@@YAPAUiconLocator@@AAU1@@Z ; std::addressof<iconLocator>(iconLocator &)
.text$mn:000075AA                 add     esp, 4
.text$mn:000075AD                 mov     ecx, [ebp+var_8]
.text$mn:000075B0                 sub     eax, [ecx+4]
.text$mn:000075B3                 cdq
.text$mn:000075B4                 mov     ecx, 24h ; '$'
.text$mn:000075B9                 idiv    ecx
.text$mn:000075BB                 mov     [ebp+var_C], eax
.text$mn:000075BE                 mov     edx, [ebp+var_8]
.text$mn:000075C1                 mov     eax, [ebp+var_8]
.text$mn:000075C4                 mov     ecx, [edx+8]
.text$mn:000075C7                 cmp     ecx, [eax+0Ch]
.text$mn:000075CA                 jnz     short loc_75D6
.text$mn:000075CC                 push    1
.text$mn:000075CE                 mov     ecx, [ebp+var_8]
.text$mn:000075D1                 call    ?_Reserve@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z ; std::vector<iconLocator,std::allocator<iconLocator>>::_Reserve(uint)
.text$mn:000075D6
.text$mn:000075D6 loc_75D6:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)+52j
.text$mn:000075D6                 mov     edx, [ebp+var_8]
.text$mn:000075D9                 mov     eax, [edx+8]
.text$mn:000075DC                 push    eax
.text$mn:000075DD                 mov     ecx, [ebp+var_8]
.text$mn:000075E0                 mov     edx, [ecx+8]
.text$mn:000075E3                 push    edx
.text$mn:000075E4                 mov     ecx, [ebp+var_8]
.text$mn:000075E7                 call    ?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z ; std::vector<iconLocator,std::allocator<iconLocator>>::_Orphan_range(iconLocator *,iconLocator *)
.text$mn:000075EC                 imul    eax, [ebp+var_C], 24h
.text$mn:000075F0                 mov     ecx, [ebp+var_8]
.text$mn:000075F3                 add     eax, [ecx+4]
.text$mn:000075F6                 push    eax
.text$mn:000075F7                 call    ??$forward@UiconLocator@@@std@@YA$$QAUiconLocator@@AAU1@@Z ; std::forward<iconLocator>(iconLocator &)
.text$mn:000075FC                 add     esp, 4
.text$mn:000075FF                 push    eax             ; int
.text$mn:00007600                 mov     edx, [ebp+var_8]
.text$mn:00007603                 mov     eax, [edx+8]
.text$mn:00007606                 push    eax             ; void *
.text$mn:00007607                 lea     ecx, [ebp+var_1]
.text$mn:0000760A                 push    ecx
.text$mn:0000760B                 mov     ecx, [ebp+var_8]
.text$mn:0000760E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<iconLocator,std::allocator<iconLocator>>>::_Getal(void)
.text$mn:00007613                 mov     ecx, eax
.text$mn:00007615                 call    ??$construct@UiconLocator@@U1@@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<iconLocator>>::construct<iconLocator,iconLocator>(iconLocator *,iconLocator &&)
.text$mn:0000761A                 mov     edx, [ebp+var_8]
.text$mn:0000761D                 mov     eax, [edx+8]
.text$mn:00007620                 add     eax, 24h ; '$'
.text$mn:00007623                 mov     ecx, [ebp+var_8]
.text$mn:00007626                 mov     [ecx+8], eax
.text$mn:00007629                 jmp     short loc_768F
.text$mn:0000762B ; ---------------------------------------------------------------------------
.text$mn:0000762B
.text$mn:0000762B loc_762B:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)+23j
.text$mn:0000762B                 mov     edx, [ebp+var_8]
.text$mn:0000762E                 mov     eax, [ebp+var_8]
.text$mn:00007631                 mov     ecx, [edx+8]
.text$mn:00007634                 cmp     ecx, [eax+0Ch]
.text$mn:00007637                 jnz     short loc_7643
.text$mn:00007639                 push    1
.text$mn:0000763B                 mov     ecx, [ebp+var_8]
.text$mn:0000763E                 call    ?_Reserve@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z ; std::vector<iconLocator,std::allocator<iconLocator>>::_Reserve(uint)
.text$mn:00007643
.text$mn:00007643 loc_7643:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)+BFj
.text$mn:00007643                 mov     edx, [ebp+var_8]
.text$mn:00007646                 mov     eax, [edx+8]
.text$mn:00007649                 push    eax
.text$mn:0000764A                 mov     ecx, [ebp+var_8]
.text$mn:0000764D                 mov     edx, [ecx+8]
.text$mn:00007650                 push    edx
.text$mn:00007651                 mov     ecx, [ebp+var_8]
.text$mn:00007654                 call    ?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z ; std::vector<iconLocator,std::allocator<iconLocator>>::_Orphan_range(iconLocator *,iconLocator *)
.text$mn:00007659                 mov     eax, [ebp+arg_0]
.text$mn:0000765C                 push    eax
.text$mn:0000765D                 call    ??$forward@UiconLocator@@@std@@YA$$QAUiconLocator@@AAU1@@Z ; std::forward<iconLocator>(iconLocator &)
.text$mn:00007662                 add     esp, 4
.text$mn:00007665                 push    eax             ; int
.text$mn:00007666                 mov     ecx, [ebp+var_8]
.text$mn:00007669                 mov     edx, [ecx+8]
.text$mn:0000766C                 push    edx             ; void *
.text$mn:0000766D                 lea     eax, [ebp+var_2]
.text$mn:00007670                 push    eax
.text$mn:00007671                 mov     ecx, [ebp+var_8]
.text$mn:00007674                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<iconLocator,std::allocator<iconLocator>>>::_Getal(void)
.text$mn:00007679                 mov     ecx, eax
.text$mn:0000767B                 call    ??$construct@UiconLocator@@U1@@?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<iconLocator>>::construct<iconLocator,iconLocator>(iconLocator *,iconLocator &&)
.text$mn:00007680                 mov     ecx, [ebp+var_8]
.text$mn:00007683                 mov     edx, [ecx+8]
.text$mn:00007686                 add     edx, 24h ; '$'
.text$mn:00007689                 mov     eax, [ebp+var_8]
.text$mn:0000768C                 mov     [eax+8], edx
.text$mn:0000768F
.text$mn:0000768F loc_768F:                               ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::push_back(iconLocator &&)+B1j
.text$mn:0000768F                 mov     esp, ebp
.text$mn:00007691                 pop     ebp
.text$mn:00007692                 retn    4
.text$mn:00007692 ?push_back@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QAEX$$QAUiconLocator@@@Z endp
.text$mn:00007692
.text$mn:00007692 ; ---------------------------------------------------------------------------
.text$mn:00007695                 align 4
.text$mn:00007695 _text$mn        ends
.text$mn:00007695
.text$mn:00007698 ; ===========================================================================
.text$mn:00007698
.text$mn:00007698 ; Segment type: Pure code
.text$mn:00007698 ; Segment permissions: Read/Execute
.text$mn:00007698 _text$mn        segment para public 'CODE' use32
.text$mn:00007698                 assume cs:_text$mn
.text$mn:00007698                 ;org 7698h
.text$mn:00007698 ; COMDAT (pick any)
.text$mn:00007698                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007698
.text$mn:00007698 ; =============== S U B R O U T I N E =======================================
.text$mn:00007698
.text$mn:00007698 ; Attributes: bp-based frame
.text$mn:00007698
.text$mn:00007698 ; public: void __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::push_back(struct tDynamicList const &)
.text$mn:00007698                 public ?push_back@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QAEXABUtDynamicList@@@Z
.text$mn:00007698 ?push_back@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QAEXABUtDynamicList@@@Z proc near
.text$mn:00007698                                         ; CODE XREF: ToolBar::registerDynBtn(uint,toolbarIcons *)+44p
.text$mn:00007698
.text$mn:00007698 var_C           = dword ptr -0Ch
.text$mn:00007698 var_8           = dword ptr -8
.text$mn:00007698 var_2           = byte ptr -2
.text$mn:00007698 var_1           = byte ptr -1
.text$mn:00007698 arg_0           = dword ptr  8
.text$mn:00007698
.text$mn:00007698                 push    ebp
.text$mn:00007699                 mov     ebp, esp
.text$mn:0000769B                 sub     esp, 0Ch
.text$mn:0000769E                 mov     [ebp+var_8], ecx
.text$mn:000076A1                 mov     eax, [ebp+arg_0]
.text$mn:000076A4                 push    eax
.text$mn:000076A5                 call    ??$addressof@$$CBUtDynamicList@@@std@@YAPBUtDynamicList@@ABU1@@Z ; std::addressof<tDynamicList const>(tDynamicList const &)
.text$mn:000076AA                 add     esp, 4
.text$mn:000076AD                 push    eax
.text$mn:000076AE                 mov     ecx, [ebp+var_8]
.text$mn:000076B1                 call    ?_Inside@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBE_NPBUtDynamicList@@@Z ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Inside(tDynamicList const *)
.text$mn:000076B6                 movzx   ecx, al
.text$mn:000076B9                 test    ecx, ecx
.text$mn:000076BB                 jz      loc_7742
.text$mn:000076C1                 mov     edx, [ebp+arg_0]
.text$mn:000076C4                 push    edx
.text$mn:000076C5                 call    ??$addressof@$$CBUtDynamicList@@@std@@YAPBUtDynamicList@@ABU1@@Z ; std::addressof<tDynamicList const>(tDynamicList const &)
.text$mn:000076CA                 add     esp, 4
.text$mn:000076CD                 mov     ecx, [ebp+var_8]
.text$mn:000076D0                 sub     eax, [ecx+4]
.text$mn:000076D3                 cdq
.text$mn:000076D4                 mov     ecx, 0Ch
.text$mn:000076D9                 idiv    ecx
.text$mn:000076DB                 mov     [ebp+var_C], eax
.text$mn:000076DE                 mov     edx, [ebp+var_8]
.text$mn:000076E1                 mov     eax, [ebp+var_8]
.text$mn:000076E4                 mov     ecx, [edx+8]
.text$mn:000076E7                 cmp     ecx, [eax+0Ch]
.text$mn:000076EA                 jnz     short loc_76F6
.text$mn:000076EC                 push    1
.text$mn:000076EE                 mov     ecx, [ebp+var_8]
.text$mn:000076F1                 call    ?_Reserve@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reserve(uint)
.text$mn:000076F6
.text$mn:000076F6 loc_76F6:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::push_back(tDynamicList const &)+52j
.text$mn:000076F6                 mov     edx, [ebp+var_8]
.text$mn:000076F9                 mov     eax, [edx+8]
.text$mn:000076FC                 push    eax
.text$mn:000076FD                 mov     ecx, [ebp+var_8]
.text$mn:00007700                 mov     edx, [ecx+8]
.text$mn:00007703                 push    edx
.text$mn:00007704                 mov     ecx, [ebp+var_8]
.text$mn:00007707                 call    ?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Orphan_range(tDynamicList *,tDynamicList *)
.text$mn:0000770C                 imul    eax, [ebp+var_C], 0Ch
.text$mn:00007710                 mov     ecx, [ebp+var_8]
.text$mn:00007713                 add     eax, [ecx+4]
.text$mn:00007716                 push    eax             ; int
.text$mn:00007717                 mov     edx, [ebp+var_8]
.text$mn:0000771A                 mov     eax, [edx+8]
.text$mn:0000771D                 push    eax             ; void *
.text$mn:0000771E                 lea     ecx, [ebp+var_1]
.text$mn:00007721                 push    ecx
.text$mn:00007722                 mov     ecx, [ebp+var_8]
.text$mn:00007725                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tDynamicList,std::allocator<tDynamicList>>>::_Getal(void)
.text$mn:0000772A                 mov     ecx, eax
.text$mn:0000772C                 call    ??$construct@UtDynamicList@@AAU1@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@AAU2@@Z ; std::_Wrap_alloc<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList &>(tDynamicList *,tDynamicList &)
.text$mn:00007731                 mov     edx, [ebp+var_8]
.text$mn:00007734                 mov     eax, [edx+8]
.text$mn:00007737                 add     eax, 0Ch
.text$mn:0000773A                 mov     ecx, [ebp+var_8]
.text$mn:0000773D                 mov     [ecx+8], eax
.text$mn:00007740                 jmp     short loc_779D
.text$mn:00007742 ; ---------------------------------------------------------------------------
.text$mn:00007742
.text$mn:00007742 loc_7742:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::push_back(tDynamicList const &)+23j
.text$mn:00007742                 mov     edx, [ebp+var_8]
.text$mn:00007745                 mov     eax, [ebp+var_8]
.text$mn:00007748                 mov     ecx, [edx+8]
.text$mn:0000774B                 cmp     ecx, [eax+0Ch]
.text$mn:0000774E                 jnz     short loc_775A
.text$mn:00007750                 push    1
.text$mn:00007752                 mov     ecx, [ebp+var_8]
.text$mn:00007755                 call    ?_Reserve@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Reserve(uint)
.text$mn:0000775A
.text$mn:0000775A loc_775A:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::push_back(tDynamicList const &)+B6j
.text$mn:0000775A                 mov     edx, [ebp+var_8]
.text$mn:0000775D                 mov     eax, [edx+8]
.text$mn:00007760                 push    eax
.text$mn:00007761                 mov     ecx, [ebp+var_8]
.text$mn:00007764                 mov     edx, [ecx+8]
.text$mn:00007767                 push    edx
.text$mn:00007768                 mov     ecx, [ebp+var_8]
.text$mn:0000776B                 call    ?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Orphan_range(tDynamicList *,tDynamicList *)
.text$mn:00007770                 mov     eax, [ebp+arg_0]
.text$mn:00007773                 push    eax             ; int
.text$mn:00007774                 mov     ecx, [ebp+var_8]
.text$mn:00007777                 mov     edx, [ecx+8]
.text$mn:0000777A                 push    edx             ; void *
.text$mn:0000777B                 lea     eax, [ebp+var_2]
.text$mn:0000777E                 push    eax
.text$mn:0000777F                 mov     ecx, [ebp+var_8]
.text$mn:00007782                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<tDynamicList,std::allocator<tDynamicList>>>::_Getal(void)
.text$mn:00007787                 mov     ecx, eax
.text$mn:00007789                 call    ??$construct@UtDynamicList@@ABU1@@?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@std@@QAEXPAUtDynamicList@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<tDynamicList>>::construct<tDynamicList,tDynamicList const &>(tDynamicList *,tDynamicList const &)
.text$mn:0000778E                 mov     ecx, [ebp+var_8]
.text$mn:00007791                 mov     edx, [ecx+8]
.text$mn:00007794                 add     edx, 0Ch
.text$mn:00007797                 mov     eax, [ebp+var_8]
.text$mn:0000779A                 mov     [eax+8], edx
.text$mn:0000779D
.text$mn:0000779D loc_779D:                               ; CODE XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::push_back(tDynamicList const &)+A8j
.text$mn:0000779D                 mov     esp, ebp
.text$mn:0000779F                 pop     ebp
.text$mn:000077A0                 retn    4
.text$mn:000077A0 ?push_back@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QAEXABUtDynamicList@@@Z endp
.text$mn:000077A0
.text$mn:000077A0 ; ---------------------------------------------------------------------------
.text$mn:000077A3                 align 4
.text$mn:000077A3 _text$mn        ends
.text$mn:000077A3
.text$mn:000077A4 ; ===========================================================================
.text$mn:000077A4
.text$mn:000077A4 ; Segment type: Pure code
.text$mn:000077A4 ; Segment permissions: Read/Execute
.text$mn:000077A4 _text$mn        segment para public 'CODE' use32
.text$mn:000077A4                 assume cs:_text$mn
.text$mn:000077A4                 ;org 77A4h
.text$mn:000077A4 ; COMDAT (pick any)
.text$mn:000077A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000077A4
.text$mn:000077A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000077A4
.text$mn:000077A4 ; Attributes: bp-based frame
.text$mn:000077A4
.text$mn:000077A4 ; void __thiscall Window::redraw(Window *this, bool)
.text$mn:000077A4                 public ?redraw@Window@@UBEX_N@Z
.text$mn:000077A4 ?redraw@Window@@UBEX_N@Z proc near      ; CODE XREF: ToolBar::reduce(void)+78p
.text$mn:000077A4                                         ; ToolBar::enlarge(void)+78p ...
.text$mn:000077A4
.text$mn:000077A4 var_4           = dword ptr -4
.text$mn:000077A4 arg_0           = byte ptr  8
.text$mn:000077A4
.text$mn:000077A4                 push    ebp
.text$mn:000077A5                 mov     ebp, esp
.text$mn:000077A7                 push    ecx
.text$mn:000077A8                 mov     [ebp+var_4], ecx
.text$mn:000077AB                 push    1               ; bErase
.text$mn:000077AD                 push    0               ; lpRect
.text$mn:000077AF                 mov     eax, [ebp+var_4]
.text$mn:000077B2                 mov     ecx, [eax+0Ch]
.text$mn:000077B5                 push    ecx             ; hWnd
.text$mn:000077B6                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:000077BC                 movzx   edx, [ebp+arg_0]
.text$mn:000077C0                 test    edx, edx
.text$mn:000077C2                 jz      short loc_77D1
.text$mn:000077C4                 mov     eax, [ebp+var_4]
.text$mn:000077C7                 mov     ecx, [eax+0Ch]
.text$mn:000077CA                 push    ecx             ; hWnd
.text$mn:000077CB                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:000077D1
.text$mn:000077D1 loc_77D1:                               ; CODE XREF: Window::redraw(bool)+1Ej
.text$mn:000077D1                 mov     esp, ebp
.text$mn:000077D3                 pop     ebp
.text$mn:000077D4                 retn    4
.text$mn:000077D4 ?redraw@Window@@UBEX_N@Z endp
.text$mn:000077D4
.text$mn:000077D4 ; ---------------------------------------------------------------------------
.text$mn:000077D7                 align 4
.text$mn:000077D7 _text$mn        ends
.text$mn:000077D7
.text$mn:000077D8 ; ===========================================================================
.text$mn:000077D8
.text$mn:000077D8 ; Segment type: Pure code
.text$mn:000077D8 ; Segment permissions: Read/Execute
.text$mn:000077D8 _text$mn        segment para public 'CODE' use32
.text$mn:000077D8                 assume cs:_text$mn
.text$mn:000077D8                 ;org 77D8h
.text$mn:000077D8 ; COMDAT (pick any)
.text$mn:000077D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000077D8
.text$mn:000077D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000077D8
.text$mn:000077D8 ; Attributes: bp-based frame
.text$mn:000077D8
.text$mn:000077D8 ; void __thiscall ToolBarIcons::resizeIcon(ToolBarIcons *this, int)
.text$mn:000077D8                 public ?resizeIcon@ToolBarIcons@@QAEXH@Z
.text$mn:000077D8 ?resizeIcon@ToolBarIcons@@QAEXH@Z proc near
.text$mn:000077D8                                         ; CODE XREF: ToolBar::reduce(void)+35p
.text$mn:000077D8                                         ; ToolBar::enlarge(void)+35p
.text$mn:000077D8
.text$mn:000077D8 var_4           = dword ptr -4
.text$mn:000077D8 arg_0           = dword ptr  8
.text$mn:000077D8
.text$mn:000077D8                 push    ebp
.text$mn:000077D9                 mov     ebp, esp
.text$mn:000077DB                 push    ecx
.text$mn:000077DC                 mov     [ebp+var_4], ecx
.text$mn:000077DF                 mov     eax, [ebp+arg_0]
.text$mn:000077E2                 push    eax             ; int
.text$mn:000077E3                 mov     ecx, [ebp+var_4] ; this
.text$mn:000077E6                 call    ?reInit@ToolBarIcons@@QAEXH@Z ; ToolBarIcons::reInit(int)
.text$mn:000077EB                 mov     esp, ebp
.text$mn:000077ED                 pop     ebp
.text$mn:000077EE                 retn    4
.text$mn:000077EE ?resizeIcon@ToolBarIcons@@QAEXH@Z endp
.text$mn:000077EE
.text$mn:000077EE ; ---------------------------------------------------------------------------
.text$mn:000077F1                 align 4
.text$mn:000077F1 _text$mn        ends
.text$mn:000077F1
.text$mn:000077F4 ; ===========================================================================
.text$mn:000077F4
.text$mn:000077F4 ; Segment type: Pure code
.text$mn:000077F4 ; Segment permissions: Read/Execute
.text$mn:000077F4 _text$mn        segment para public 'CODE' use32
.text$mn:000077F4                 assume cs:_text$mn
.text$mn:000077F4                 ;org 77F4h
.text$mn:000077F4 ; COMDAT (pick any)
.text$mn:000077F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000077F4
.text$mn:000077F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000077F4
.text$mn:000077F4 ; Attributes: bp-based frame
.text$mn:000077F4
.text$mn:000077F4 ; int __thiscall DPIManager::scaleX(DPIManager *this, int)
.text$mn:000077F4                 public ?scaleX@DPIManager@@QAEHH@Z
.text$mn:000077F4 ?scaleX@DPIManager@@QAEHH@Z proc near   ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+4Fp
.text$mn:000077F4                                         ; ToolBar::reduce(void)+23p ...
.text$mn:000077F4
.text$mn:000077F4 var_4           = dword ptr -4
.text$mn:000077F4 nNumber         = dword ptr  8
.text$mn:000077F4
.text$mn:000077F4                 push    ebp
.text$mn:000077F5                 mov     ebp, esp
.text$mn:000077F7                 push    ecx
.text$mn:000077F8                 mov     [ebp+var_4], ecx
.text$mn:000077FB                 push    60h ; '`'       ; nDenominator
.text$mn:000077FD                 mov     eax, [ebp+var_4]
.text$mn:00007800                 mov     ecx, [eax]
.text$mn:00007802                 push    ecx             ; nNumerator
.text$mn:00007803                 mov     edx, [ebp+nNumber]
.text$mn:00007806                 push    edx             ; nNumber
.text$mn:00007807                 call    dword ptr ds:__imp__MulDiv@12 ; MulDiv(x,x,x)
.text$mn:0000780D                 mov     esp, ebp
.text$mn:0000780F                 pop     ebp
.text$mn:00007810                 retn    4
.text$mn:00007810 ?scaleX@DPIManager@@QAEHH@Z endp
.text$mn:00007810
.text$mn:00007810 ; ---------------------------------------------------------------------------
.text$mn:00007813                 align 4
.text$mn:00007813 _text$mn        ends
.text$mn:00007813
.text$mn:00007814 ; ===========================================================================
.text$mn:00007814
.text$mn:00007814 ; Segment type: Pure code
.text$mn:00007814 ; Segment permissions: Read/Execute
.text$mn:00007814 _text$mn        segment para public 'CODE' use32
.text$mn:00007814                 assume cs:_text$mn
.text$mn:00007814                 ;org 7814h
.text$mn:00007814 ; COMDAT (pick any)
.text$mn:00007814                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007814
.text$mn:00007814 ; =============== S U B R O U T I N E =======================================
.text$mn:00007814
.text$mn:00007814 ; Attributes: bp-based frame
.text$mn:00007814
.text$mn:00007814 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::select_on_container_copy_construction(void)const
.text$mn:00007814                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ
.text$mn:00007814 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ proc near
.text$mn:00007814                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Ap
.text$mn:00007814
.text$mn:00007814 var_8           = dword ptr -8
.text$mn:00007814 var_1           = byte ptr -1
.text$mn:00007814 arg_0           = dword ptr  8
.text$mn:00007814
.text$mn:00007814                 push    ebp
.text$mn:00007815                 mov     ebp, esp
.text$mn:00007817                 sub     esp, 8
.text$mn:0000781A                 mov     [ebp+var_8], ecx
.text$mn:0000781D                 mov     eax, [ebp+var_8]
.text$mn:00007820                 push    eax
.text$mn:00007821                 lea     ecx, [ebp+var_1]
.text$mn:00007824                 push    ecx
.text$mn:00007825                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)
.text$mn:0000782A                 add     esp, 8
.text$mn:0000782D                 push    eax
.text$mn:0000782E                 mov     ecx, [ebp+arg_0]
.text$mn:00007831                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(std::allocator<wchar_t> const &)
.text$mn:00007836                 mov     eax, [ebp+arg_0]
.text$mn:00007839                 mov     esp, ebp
.text$mn:0000783B                 pop     ebp
.text$mn:0000783C                 retn    4
.text$mn:0000783C ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ endp
.text$mn:0000783C
.text$mn:0000783C ; ---------------------------------------------------------------------------
.text$mn:0000783F                 align 10h
.text$mn:0000783F _text$mn        ends
.text$mn:0000783F
.text$mn:00007840 ; ===========================================================================
.text$mn:00007840
.text$mn:00007840 ; Segment type: Pure code
.text$mn:00007840 ; Segment permissions: Read/Execute
.text$mn:00007840 _text$mn        segment para public 'CODE' use32
.text$mn:00007840                 assume cs:_text$mn
.text$mn:00007840                 ;org 7840h
.text$mn:00007840 ; COMDAT (pick any)
.text$mn:00007840                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007840
.text$mn:00007840 ; =============== S U B R O U T I N E =======================================
.text$mn:00007840
.text$mn:00007840 ; Attributes: bp-based frame
.text$mn:00007840
.text$mn:00007840 ; public: class std::allocator<wchar_t> __thiscall std::allocator<wchar_t>::select_on_container_copy_construction(void)const
.text$mn:00007840                 public ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ
.text$mn:00007840 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ proc near
.text$mn:00007840                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)+Ap
.text$mn:00007840
.text$mn:00007840 var_4           = dword ptr -4
.text$mn:00007840 arg_0           = dword ptr  8
.text$mn:00007840
.text$mn:00007840                 push    ebp
.text$mn:00007841                 mov     ebp, esp
.text$mn:00007843                 push    ecx
.text$mn:00007844                 mov     [ebp+var_4], ecx
.text$mn:00007847                 mov     eax, [ebp+var_4]
.text$mn:0000784A                 push    eax
.text$mn:0000784B                 mov     ecx, [ebp+arg_0]
.text$mn:0000784E                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00007853                 mov     eax, [ebp+arg_0]
.text$mn:00007856                 mov     esp, ebp
.text$mn:00007858                 pop     ebp
.text$mn:00007859                 retn    4
.text$mn:00007859 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ endp
.text$mn:00007859
.text$mn:00007859 _text$mn        ends
.text$mn:00007859
.text$mn:0000785C ; ===========================================================================
.text$mn:0000785C
.text$mn:0000785C ; Segment type: Pure code
.text$mn:0000785C ; Segment permissions: Read/Execute
.text$mn:0000785C _text$mn        segment para public 'CODE' use32
.text$mn:0000785C                 assume cs:_text$mn
.text$mn:0000785C                 ;org 785Ch
.text$mn:0000785C ; COMDAT (pick any)
.text$mn:0000785C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000785C
.text$mn:0000785C ; =============== S U B R O U T I N E =======================================
.text$mn:0000785C
.text$mn:0000785C ; Attributes: bp-based frame
.text$mn:0000785C
.text$mn:0000785C ; public: static class std::allocator<wchar_t> __cdecl std::allocator_traits<class std::allocator<wchar_t>>::select_on_container_copy_construction(class std::allocator<wchar_t> const &)
.text$mn:0000785C                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
.text$mn:0000785C ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z proc near
.text$mn:0000785C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+11p
.text$mn:0000785C
.text$mn:0000785C arg_0           = dword ptr  8
.text$mn:0000785C arg_4           = dword ptr  0Ch
.text$mn:0000785C
.text$mn:0000785C                 push    ebp
.text$mn:0000785D                 mov     ebp, esp
.text$mn:0000785F                 mov     eax, [ebp+arg_0]
.text$mn:00007862                 push    eax
.text$mn:00007863                 mov     ecx, [ebp+arg_4]
.text$mn:00007866                 call    ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ ; std::allocator<wchar_t>::select_on_container_copy_construction(void)
.text$mn:0000786B                 mov     eax, [ebp+arg_0]
.text$mn:0000786E                 pop     ebp
.text$mn:0000786F                 retn
.text$mn:0000786F ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z endp
.text$mn:0000786F
.text$mn:0000786F _text$mn        ends
.text$mn:0000786F
.text$mn:00007870 ; ===========================================================================
.text$mn:00007870
.text$mn:00007870 ; Segment type: Pure code
.text$mn:00007870 ; Segment permissions: Read/Execute
.text$mn:00007870 _text$mn        segment para public 'CODE' use32
.text$mn:00007870                 assume cs:_text$mn
.text$mn:00007870                 ;org 7870h
.text$mn:00007870 ; COMDAT (pick any)
.text$mn:00007870                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007870
.text$mn:00007870 ; =============== S U B R O U T I N E =======================================
.text$mn:00007870
.text$mn:00007870 ; Attributes: bp-based frame
.text$mn:00007870
.text$mn:00007870 ; void __thiscall ToolBar::setDefaultImageList(ToolBar *__hidden this)
.text$mn:00007870                 public ?setDefaultImageList@ToolBar@@AAEXXZ
.text$mn:00007870 ?setDefaultImageList@ToolBar@@AAEXXZ proc near
.text$mn:00007870                                         ; CODE XREF: ToolBar::reset(bool)+12Ap
.text$mn:00007870
.text$mn:00007870 var_4           = dword ptr -4
.text$mn:00007870
.text$mn:00007870                 push    ebp
.text$mn:00007871                 mov     ebp, esp
.text$mn:00007873                 push    ecx
.text$mn:00007874                 mov     [ebp+var_4], ecx
.text$mn:00007877                 mov     ecx, [ebp+var_4]
.text$mn:0000787A                 add     ecx, 14h        ; this
.text$mn:0000787D                 call    ?getDefaultLst@ToolBarIcons@@QBEPAU_IMAGELIST@@XZ ; ToolBarIcons::getDefaultLst(void)
.text$mn:00007882                 push    eax             ; lParam
.text$mn:00007883                 push    0               ; wParam
.text$mn:00007885                 push    430h            ; Msg
.text$mn:0000788A                 mov     eax, [ebp+var_4]
.text$mn:0000788D                 mov     ecx, [eax+0Ch]
.text$mn:00007890                 push    ecx             ; hWnd
.text$mn:00007891                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00007897                 mov     esp, ebp
.text$mn:00007899                 pop     ebp
.text$mn:0000789A                 retn
.text$mn:0000789A ?setDefaultImageList@ToolBar@@AAEXXZ endp
.text$mn:0000789A
.text$mn:0000789A ; ---------------------------------------------------------------------------
.text$mn:0000789B                 align 4
.text$mn:0000789B _text$mn        ends
.text$mn:0000789B
.text$mn:0000789C ; ===========================================================================
.text$mn:0000789C
.text$mn:0000789C ; Segment type: Pure code
.text$mn:0000789C ; Segment permissions: Read/Execute
.text$mn:0000789C _text$mn        segment para public 'CODE' use32
.text$mn:0000789C                 assume cs:_text$mn
.text$mn:0000789C                 ;org 789Ch
.text$mn:0000789C ; COMDAT (pick any)
.text$mn:0000789C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000789C
.text$mn:0000789C ; =============== S U B R O U T I N E =======================================
.text$mn:0000789C
.text$mn:0000789C ; Attributes: bp-based frame
.text$mn:0000789C
.text$mn:0000789C ; void __thiscall ToolBar::setDisableImageList(ToolBar *__hidden this)
.text$mn:0000789C                 public ?setDisableImageList@ToolBar@@AAEXXZ
.text$mn:0000789C ?setDisableImageList@ToolBar@@AAEXXZ proc near
.text$mn:0000789C                                         ; CODE XREF: ToolBar::reset(bool)+13Ap
.text$mn:0000789C
.text$mn:0000789C var_4           = dword ptr -4
.text$mn:0000789C
.text$mn:0000789C                 push    ebp
.text$mn:0000789D                 mov     ebp, esp
.text$mn:0000789F                 push    ecx
.text$mn:000078A0                 mov     [ebp+var_4], ecx
.text$mn:000078A3                 mov     ecx, [ebp+var_4]
.text$mn:000078A6                 add     ecx, 14h        ; this
.text$mn:000078A9                 call    ?getDisableLst@ToolBarIcons@@QBEPAU_IMAGELIST@@XZ ; ToolBarIcons::getDisableLst(void)
.text$mn:000078AE                 push    eax             ; lParam
.text$mn:000078AF                 push    0               ; wParam
.text$mn:000078B1                 push    436h            ; Msg
.text$mn:000078B6                 mov     eax, [ebp+var_4]
.text$mn:000078B9                 mov     ecx, [eax+0Ch]
.text$mn:000078BC                 push    ecx             ; hWnd
.text$mn:000078BD                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000078C3                 mov     esp, ebp
.text$mn:000078C5                 pop     ebp
.text$mn:000078C6                 retn
.text$mn:000078C6 ?setDisableImageList@ToolBar@@AAEXXZ endp
.text$mn:000078C6
.text$mn:000078C6 ; ---------------------------------------------------------------------------
.text$mn:000078C7                 align 4
.text$mn:000078C7 _text$mn        ends
.text$mn:000078C7
.text$mn:000078C8 ; ===========================================================================
.text$mn:000078C8
.text$mn:000078C8 ; Segment type: Pure code
.text$mn:000078C8 ; Segment permissions: Read/Execute
.text$mn:000078C8 _text$mn        segment para public 'CODE' use32
.text$mn:000078C8                 assume cs:_text$mn
.text$mn:000078C8                 ;org 78C8h
.text$mn:000078C8 ; COMDAT (pick any)
.text$mn:000078C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000078C8
.text$mn:000078C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000078C8
.text$mn:000078C8 ; Attributes: bp-based frame
.text$mn:000078C8
.text$mn:000078C8 ; void __thiscall ToolBar::setHotImageList(ToolBar *__hidden this)
.text$mn:000078C8                 public ?setHotImageList@ToolBar@@AAEXXZ
.text$mn:000078C8 ?setHotImageList@ToolBar@@AAEXXZ proc near
.text$mn:000078C8                                         ; CODE XREF: ToolBar::reset(bool)+132p
.text$mn:000078C8
.text$mn:000078C8 var_4           = dword ptr -4
.text$mn:000078C8
.text$mn:000078C8                 push    ebp
.text$mn:000078C9                 mov     ebp, esp
.text$mn:000078CB                 push    ecx
.text$mn:000078CC                 mov     [ebp+var_4], ecx
.text$mn:000078CF                 mov     ecx, [ebp+var_4]
.text$mn:000078D2                 add     ecx, 14h        ; this
.text$mn:000078D5                 call    ?getHotLst@ToolBarIcons@@QBEPAU_IMAGELIST@@XZ ; ToolBarIcons::getHotLst(void)
.text$mn:000078DA                 push    eax             ; lParam
.text$mn:000078DB                 push    0               ; wParam
.text$mn:000078DD                 push    434h            ; Msg
.text$mn:000078E2                 mov     eax, [ebp+var_4]
.text$mn:000078E5                 mov     ecx, [eax+0Ch]
.text$mn:000078E8                 push    ecx             ; hWnd
.text$mn:000078E9                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000078EF                 mov     esp, ebp
.text$mn:000078F1                 pop     ebp
.text$mn:000078F2                 retn
.text$mn:000078F2 ?setHotImageList@ToolBar@@AAEXXZ endp
.text$mn:000078F2
.text$mn:000078F2 ; ---------------------------------------------------------------------------
.text$mn:000078F3                 align 4
.text$mn:000078F3 _text$mn        ends
.text$mn:000078F3
.text$mn:000078F4 ; ===========================================================================
.text$mn:000078F4
.text$mn:000078F4 ; Segment type: Pure code
.text$mn:000078F4 ; Segment permissions: Read/Execute
.text$mn:000078F4 _text$mn        segment para public 'CODE' use32
.text$mn:000078F4                 assume cs:_text$mn
.text$mn:000078F4                 ;org 78F4h
.text$mn:000078F4 ; COMDAT (pick any)
.text$mn:000078F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000078F4
.text$mn:000078F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000078F4
.text$mn:000078F4 ; Attributes: bp-based frame
.text$mn:000078F4
.text$mn:000078F4 ; private: void __thiscall ToolBar::setState(enum  toolBarStatusType)
.text$mn:000078F4                 public ?setState@ToolBar@@AAEXW4toolBarStatusType@@@Z
.text$mn:000078F4 ?setState@ToolBar@@AAEXW4toolBarStatusType@@@Z proc near
.text$mn:000078F4                                         ; CODE XREF: ToolBar::reduce(void)+61p
.text$mn:000078F4                                         ; ToolBar::enlarge(void)+61p ...
.text$mn:000078F4
.text$mn:000078F4 var_4           = dword ptr -4
.text$mn:000078F4 arg_0           = dword ptr  8
.text$mn:000078F4
.text$mn:000078F4                 push    ebp
.text$mn:000078F5                 mov     ebp, esp
.text$mn:000078F7                 push    ecx
.text$mn:000078F8                 mov     [ebp+var_4], ecx
.text$mn:000078FB                 mov     eax, [ebp+var_4]
.text$mn:000078FE                 mov     ecx, [ebp+arg_0]
.text$mn:00007901                 mov     [eax+0ECh], ecx
.text$mn:00007907                 mov     esp, ebp
.text$mn:00007909                 pop     ebp
.text$mn:0000790A                 retn    4
.text$mn:0000790A ?setState@ToolBar@@AAEXW4toolBarStatusType@@@Z endp
.text$mn:0000790A
.text$mn:0000790A ; ---------------------------------------------------------------------------
.text$mn:0000790D                 align 10h
.text$mn:0000790D _text$mn        ends
.text$mn:0000790D
.text$mn:00007910 ; ===========================================================================
.text$mn:00007910
.text$mn:00007910 ; Segment type: Pure code
.text$mn:00007910 ; Segment permissions: Read/Execute
.text$mn:00007910 _text$mn        segment para public 'CODE' use32
.text$mn:00007910                 assume cs:_text$mn
.text$mn:00007910                 ;org 7910h
.text$mn:00007910 ; COMDAT (pick any)
.text$mn:00007910                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007910
.text$mn:00007910 ; =============== S U B R O U T I N E =======================================
.text$mn:00007910
.text$mn:00007910 ; Attributes: bp-based frame
.text$mn:00007910
.text$mn:00007910 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00007910                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00007910 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00007910                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00007910                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00007910
.text$mn:00007910 var_4           = dword ptr -4
.text$mn:00007910
.text$mn:00007910                 push    ebp
.text$mn:00007911                 mov     ebp, esp
.text$mn:00007913                 push    ecx
.text$mn:00007914                 mov     [ebp+var_4], ecx
.text$mn:00007917                 mov     eax, [ebp+var_4]
.text$mn:0000791A                 mov     eax, [eax+14h]
.text$mn:0000791D                 mov     esp, ebp
.text$mn:0000791F                 pop     ebp
.text$mn:00007920                 retn
.text$mn:00007920 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00007920
.text$mn:00007920 ; ---------------------------------------------------------------------------
.text$mn:00007921                 align 4
.text$mn:00007921 _text$mn        ends
.text$mn:00007921
.text$mn:00007924 ; ===========================================================================
.text$mn:00007924
.text$mn:00007924 ; Segment type: Pure code
.text$mn:00007924 ; Segment permissions: Read/Execute
.text$mn:00007924 _text$mn        segment para public 'CODE' use32
.text$mn:00007924                 assume cs:_text$mn
.text$mn:00007924                 ;org 7924h
.text$mn:00007924 ; COMDAT (pick any)
.text$mn:00007924                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007924
.text$mn:00007924 ; =============== S U B R O U T I N E =======================================
.text$mn:00007924
.text$mn:00007924 ; Attributes: bp-based frame
.text$mn:00007924
.text$mn:00007924 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:00007924                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00007924 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00007924                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:00007924                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p ...
.text$mn:00007924
.text$mn:00007924 var_4           = dword ptr -4
.text$mn:00007924
.text$mn:00007924                 push    ebp
.text$mn:00007925                 mov     ebp, esp
.text$mn:00007927                 push    ecx
.text$mn:00007928                 mov     [ebp+var_4], ecx
.text$mn:0000792B                 mov     eax, [ebp+var_4]
.text$mn:0000792E                 mov     eax, [eax+14h]
.text$mn:00007931                 mov     esp, ebp
.text$mn:00007933                 pop     ebp
.text$mn:00007934                 retn
.text$mn:00007934 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00007934
.text$mn:00007934 ; ---------------------------------------------------------------------------
.text$mn:00007935                 align 4
.text$mn:00007935 _text$mn        ends
.text$mn:00007935
.text$mn:00007938 ; ===========================================================================
.text$mn:00007938
.text$mn:00007938 ; Segment type: Pure code
.text$mn:00007938 ; Segment permissions: Read/Execute
.text$mn:00007938 _text$mn        segment para public 'CODE' use32
.text$mn:00007938                 assume cs:_text$mn
.text$mn:00007938                 ;org 7938h
.text$mn:00007938 ; COMDAT (pick any)
.text$mn:00007938                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007938
.text$mn:00007938 ; =============== S U B R O U T I N E =======================================
.text$mn:00007938
.text$mn:00007938 ; Attributes: bp-based frame
.text$mn:00007938
.text$mn:00007938 ; public: unsigned int __thiscall std::vector<int, class std::allocator<int>>::size(void)const
.text$mn:00007938                 public ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
.text$mn:00007938 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ proc near
.text$mn:00007938                                         ; CODE XREF: ReBar::getNewID(void)+1Dp
.text$mn:00007938                                         ; ReBar::releaseID(int)+2Ep ...
.text$mn:00007938
.text$mn:00007938 var_4           = dword ptr -4
.text$mn:00007938
.text$mn:00007938                 push    ebp
.text$mn:00007939                 mov     ebp, esp
.text$mn:0000793B                 push    ecx
.text$mn:0000793C                 mov     [ebp+var_4], ecx
.text$mn:0000793F                 mov     eax, [ebp+var_4]
.text$mn:00007942                 mov     ecx, [ebp+var_4]
.text$mn:00007945                 mov     eax, [eax+8]
.text$mn:00007948                 sub     eax, [ecx+4]
.text$mn:0000794B                 sar     eax, 2
.text$mn:0000794E                 mov     esp, ebp
.text$mn:00007950                 pop     ebp
.text$mn:00007951                 retn
.text$mn:00007951 ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ endp
.text$mn:00007951
.text$mn:00007951 ; ---------------------------------------------------------------------------
.text$mn:00007952                 align 4
.text$mn:00007952 _text$mn        ends
.text$mn:00007952
.text$mn:00007954 ; ===========================================================================
.text$mn:00007954
.text$mn:00007954 ; Segment type: Pure code
.text$mn:00007954 ; Segment permissions: Read/Execute
.text$mn:00007954 _text$mn        segment para public 'CODE' use32
.text$mn:00007954                 assume cs:_text$mn
.text$mn:00007954                 ;org 7954h
.text$mn:00007954 ; COMDAT (pick any)
.text$mn:00007954                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007954
.text$mn:00007954 ; =============== S U B R O U T I N E =======================================
.text$mn:00007954
.text$mn:00007954 ; Attributes: bp-based frame
.text$mn:00007954
.text$mn:00007954 ; public: unsigned int __thiscall std::vector<struct ToolBarButtonUnit, class std::allocator<struct ToolBarButtonUnit>>::size(void)const
.text$mn:00007954                 public ?size@?$vector@UToolBarButtonUnit@@V?$allocator@UToolBarButtonUnit@@@std@@@std@@QBEIXZ
.text$mn:00007954 ?size@?$vector@UToolBarButtonUnit@@V?$allocator@UToolBarButtonUnit@@@std@@@std@@QBEIXZ proc near
.text$mn:00007954                                         ; CODE XREF: std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)+Ap
.text$mn:00007954
.text$mn:00007954 var_4           = dword ptr -4
.text$mn:00007954
.text$mn:00007954                 push    ebp
.text$mn:00007955                 mov     ebp, esp
.text$mn:00007957                 push    ecx
.text$mn:00007958                 mov     [ebp+var_4], ecx
.text$mn:0000795B                 mov     eax, [ebp+var_4]
.text$mn:0000795E                 mov     ecx, [ebp+var_4]
.text$mn:00007961                 mov     eax, [eax+8]
.text$mn:00007964                 sub     eax, [ecx+4]
.text$mn:00007967                 cdq
.text$mn:00007968                 mov     ecx, 14h
.text$mn:0000796D                 idiv    ecx
.text$mn:0000796F                 mov     esp, ebp
.text$mn:00007971                 pop     ebp
.text$mn:00007972                 retn
.text$mn:00007972 ?size@?$vector@UToolBarButtonUnit@@V?$allocator@UToolBarButtonUnit@@@std@@@std@@QBEIXZ endp
.text$mn:00007972
.text$mn:00007972 ; ---------------------------------------------------------------------------
.text$mn:00007973                 align 4
.text$mn:00007973 _text$mn        ends
.text$mn:00007973
.text$mn:00007974 ; ===========================================================================
.text$mn:00007974
.text$mn:00007974 ; Segment type: Pure code
.text$mn:00007974 ; Segment permissions: Read/Execute
.text$mn:00007974 _text$mn        segment para public 'CODE' use32
.text$mn:00007974                 assume cs:_text$mn
.text$mn:00007974                 ;org 7974h
.text$mn:00007974 ; COMDAT (pick any)
.text$mn:00007974                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007974
.text$mn:00007974 ; =============== S U B R O U T I N E =======================================
.text$mn:00007974
.text$mn:00007974 ; Attributes: bp-based frame
.text$mn:00007974
.text$mn:00007974 ; public: unsigned int __thiscall std::vector<struct iconLocator, class std::allocator<struct iconLocator>>::size(void)const
.text$mn:00007974                 public ?size@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ
.text$mn:00007974 ?size@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ proc near
.text$mn:00007974                                         ; CODE XREF: std::vector<iconLocator,std::allocator<iconLocator>>::_Reallocate(uint)+A9p
.text$mn:00007974                                         ; std::vector<iconLocator,std::allocator<iconLocator>>::_Reserve(uint)+22p ...
.text$mn:00007974
.text$mn:00007974 var_4           = dword ptr -4
.text$mn:00007974
.text$mn:00007974                 push    ebp
.text$mn:00007975                 mov     ebp, esp
.text$mn:00007977                 push    ecx
.text$mn:00007978                 mov     [ebp+var_4], ecx
.text$mn:0000797B                 mov     eax, [ebp+var_4]
.text$mn:0000797E                 mov     ecx, [ebp+var_4]
.text$mn:00007981                 mov     eax, [eax+8]
.text$mn:00007984                 sub     eax, [ecx+4]
.text$mn:00007987                 cdq
.text$mn:00007988                 mov     ecx, 24h ; '$'
.text$mn:0000798D                 idiv    ecx
.text$mn:0000798F                 mov     esp, ebp
.text$mn:00007991                 pop     ebp
.text$mn:00007992                 retn
.text$mn:00007992 ?size@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@QBEIXZ endp
.text$mn:00007992
.text$mn:00007992 ; ---------------------------------------------------------------------------
.text$mn:00007993                 align 4
.text$mn:00007993 _text$mn        ends
.text$mn:00007993
.text$mn:00007994 ; ===========================================================================
.text$mn:00007994
.text$mn:00007994 ; Segment type: Pure code
.text$mn:00007994 ; Segment permissions: Read/Execute
.text$mn:00007994 _text$mn        segment para public 'CODE' use32
.text$mn:00007994                 assume cs:_text$mn
.text$mn:00007994                 ;org 7994h
.text$mn:00007994 ; COMDAT (pick any)
.text$mn:00007994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007994
.text$mn:00007994 ; =============== S U B R O U T I N E =======================================
.text$mn:00007994
.text$mn:00007994 ; Attributes: bp-based frame
.text$mn:00007994
.text$mn:00007994 ; public: unsigned int __thiscall std::vector<struct tDynamicList, class std::allocator<struct tDynamicList>>::size(void)const
.text$mn:00007994                 public ?size@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ
.text$mn:00007994 ?size@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ proc near
.text$mn:00007994                                         ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+ADp
.text$mn:00007994                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::operator[](uint)+Ap ...
.text$mn:00007994
.text$mn:00007994 var_4           = dword ptr -4
.text$mn:00007994
.text$mn:00007994                 push    ebp
.text$mn:00007995                 mov     ebp, esp
.text$mn:00007997                 push    ecx
.text$mn:00007998                 mov     [ebp+var_4], ecx
.text$mn:0000799B                 mov     eax, [ebp+var_4]
.text$mn:0000799E                 mov     ecx, [ebp+var_4]
.text$mn:000079A1                 mov     eax, [eax+8]
.text$mn:000079A4                 sub     eax, [ecx+4]
.text$mn:000079A7                 cdq
.text$mn:000079A8                 mov     ecx, 0Ch
.text$mn:000079AD                 idiv    ecx
.text$mn:000079AF                 mov     esp, ebp
.text$mn:000079B1                 pop     ebp
.text$mn:000079B2                 retn
.text$mn:000079B2 ?size@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@QBEIXZ endp
.text$mn:000079B2
.text$mn:000079B2 ; ---------------------------------------------------------------------------
.text$mn:000079B3                 align 4
.text$mn:000079B3 _text$mn        ends
.text$mn:000079B3
.text$mn:000079B4 ; ===========================================================================
.text$mn:000079B4
.text$mn:000079B4 ; Segment type: Pure code
.text$mn:000079B4 ; Segment permissions: Read/Execute
.text$mn:000079B4 _text$mn        segment para public 'CODE' use32
.text$mn:000079B4                 assume cs:_text$mn
.text$mn:000079B4                 ;org 79B4h
.text$mn:000079B4 ; COMDAT (pick any)
.text$mn:000079B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000079B4
.text$mn:000079B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000079B4
.text$mn:000079B4 ; Attributes: bp-based frame
.text$mn:000079B4
.text$mn:000079B4 ; public: unsigned int __thiscall std::vector<class IconList, class std::allocator<class IconList>>::size(void)const
.text$mn:000079B4                 public ?size@?$vector@VIconList@@V?$allocator@VIconList@@@std@@@std@@QBEIXZ
.text$mn:000079B4 ?size@?$vector@VIconList@@V?$allocator@VIconList@@@std@@@std@@QBEIXZ proc near
.text$mn:000079B4                                         ; CODE XREF: std::vector<IconList,std::allocator<IconList>>::operator[](uint)+Ap
.text$mn:000079B4
.text$mn:000079B4 var_4           = dword ptr -4
.text$mn:000079B4
.text$mn:000079B4                 push    ebp
.text$mn:000079B5                 mov     ebp, esp
.text$mn:000079B7                 push    ecx
.text$mn:000079B8                 mov     [ebp+var_4], ecx
.text$mn:000079BB                 mov     eax, [ebp+var_4]
.text$mn:000079BE                 mov     ecx, [ebp+var_4]
.text$mn:000079C1                 mov     eax, [eax+8]
.text$mn:000079C4                 sub     eax, [ecx+4]
.text$mn:000079C7                 cdq
.text$mn:000079C8                 mov     ecx, 14h
.text$mn:000079CD                 idiv    ecx
.text$mn:000079CF                 mov     esp, ebp
.text$mn:000079D1                 pop     ebp
.text$mn:000079D2                 retn
.text$mn:000079D2 ?size@?$vector@VIconList@@V?$allocator@VIconList@@@std@@@std@@QBEIXZ endp
.text$mn:000079D2
.text$mn:000079D2 ; ---------------------------------------------------------------------------
.text$mn:000079D3                 align 4
.text$mn:000079D3 _text$mn        ends
.text$mn:000079D3
.text$mn:000079D4 ; ===========================================================================
.text$mn:000079D4
.text$mn:000079D4 ; Segment type: Pure code
.text$mn:000079D4 ; Segment permissions: Read/Execute
.text$mn:000079D4 _text$mn        segment para public 'CODE' use32
.text$mn:000079D4                 assume cs:_text$mn
.text$mn:000079D4                 ;org 79D4h
.text$mn:000079D4 ; COMDAT (pick any)
.text$mn:000079D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000079D4
.text$mn:000079D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000079D4
.text$mn:000079D4 ; Attributes: bp-based frame
.text$mn:000079D4
.text$mn:000079D4 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:000079D4                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:000079D4 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000079D4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_6AACp
.text$mn:000079D4                 push    ebp
.text$mn:000079D5                 mov     ebp, esp
.text$mn:000079D7                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:000079DC                 pop     ebp
.text$mn:000079DD                 retn
.text$mn:000079DD ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000079DD
.text$mn:000079DD ; ---------------------------------------------------------------------------
.text$mn:000079DE                 align 10h
.text$mn:000079DE _text$mn        ends
.text$mn:000079DE
.text$mn:000079E0 ; ===========================================================================
.text$mn:000079E0
.text$mn:000079E0 ; Segment type: Pure code
.text$mn:000079E0 ; Segment permissions: Read/Execute
.text$mn:000079E0 _text$mn        segment para public 'CODE' use32
.text$mn:000079E0                 assume cs:_text$mn
.text$mn:000079E0                 ;org 79E0h
.text$mn:000079E0 ; COMDAT (pick any)
.text$mn:000079E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000079E0
.text$mn:000079E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000079E0
.text$mn:000079E0 ; Attributes: bp-based frame
.text$mn:000079E0
.text$mn:000079E0 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:000079E0                 public ?value@error_code@std@@QBEHXZ
.text$mn:000079E0 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:000079E0
.text$mn:000079E0 var_4           = dword ptr -4
.text$mn:000079E0
.text$mn:000079E0                 push    ebp
.text$mn:000079E1                 mov     ebp, esp
.text$mn:000079E3                 push    ecx
.text$mn:000079E4                 mov     [ebp+var_4], ecx
.text$mn:000079E7                 mov     eax, [ebp+var_4]
.text$mn:000079EA                 mov     eax, [eax]
.text$mn:000079EC                 mov     esp, ebp
.text$mn:000079EE                 pop     ebp
.text$mn:000079EF                 retn
.text$mn:000079EF ?value@error_code@std@@QBEHXZ endp
.text$mn:000079EF
.text$mn:000079EF _text$mn        ends
.text$mn:000079EF
.text$mn:000079F0 ; ===========================================================================
.text$mn:000079F0
.text$mn:000079F0 ; Segment type: Pure code
.text$mn:000079F0 ; Segment permissions: Read/Execute
.text$mn:000079F0 _text$mn        segment para public 'CODE' use32
.text$mn:000079F0                 assume cs:_text$mn
.text$mn:000079F0                 ;org 79F0h
.text$mn:000079F0 ; COMDAT (pick any)
.text$mn:000079F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000079F0
.text$mn:000079F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000079F0
.text$mn:000079F0 ; Attributes: bp-based frame
.text$mn:000079F0
.text$mn:000079F0 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:000079F0                 public ?value@error_condition@std@@QBEHXZ
.text$mn:000079F0 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:000079F0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:000079F0                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:000079F0
.text$mn:000079F0 var_4           = dword ptr -4
.text$mn:000079F0
.text$mn:000079F0                 push    ebp
.text$mn:000079F1                 mov     ebp, esp
.text$mn:000079F3                 push    ecx
.text$mn:000079F4                 mov     [ebp+var_4], ecx
.text$mn:000079F7                 mov     eax, [ebp+var_4]
.text$mn:000079FA                 mov     eax, [eax]
.text$mn:000079FC                 mov     esp, ebp
.text$mn:000079FE                 pop     ebp
.text$mn:000079FF                 retn
.text$mn:000079FF ?value@error_condition@std@@QBEHXZ endp
.text$mn:000079FF
.text$mn:000079FF _text$mn        ends
.text$mn:000079FF
.text$mn:00007A00 ; ===========================================================================
.text$mn:00007A00
.text$mn:00007A00 ; Segment type: Pure code
.text$mn:00007A00 ; Segment permissions: Read/Execute
.text$mn:00007A00 _text$mn        segment para public 'CODE' use32
.text$mn:00007A00                 assume cs:_text$mn
.text$mn:00007A00                 ;org 7A00h
.text$mn:00007A00 ; COMDAT (pick any)
.text$mn:00007A00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A00
.text$mn:00007A00 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A00
.text$mn:00007A00 ; Attributes: bp-based frame
.text$mn:00007A00
.text$mn:00007A00                 public _hypot
.text$mn:00007A00 _hypot          proc near
.text$mn:00007A00
.text$mn:00007A00 var_10          = qword ptr -10h
.text$mn:00007A00 var_8           = qword ptr -8
.text$mn:00007A00 arg_0           = qword ptr  8
.text$mn:00007A00 arg_8           = qword ptr  10h
.text$mn:00007A00
.text$mn:00007A00                 push    ebp
.text$mn:00007A01                 mov     ebp, esp
.text$mn:00007A03                 sub     esp, 8
.text$mn:00007A06                 movsd   xmm0, [ebp+arg_8]
.text$mn:00007A0B                 movsd   [esp+8+var_8], xmm0
.text$mn:00007A10                 sub     esp, 8
.text$mn:00007A13                 movsd   xmm0, [ebp+arg_0]
.text$mn:00007A18                 movsd   [esp+10h+var_10], xmm0
.text$mn:00007A1D                 call    __hypot
.text$mn:00007A22                 add     esp, 10h
.text$mn:00007A25                 pop     ebp
.text$mn:00007A26                 retn
.text$mn:00007A26 _hypot          endp
.text$mn:00007A26
.text$mn:00007A26 ; ---------------------------------------------------------------------------
.text$mn:00007A27                 align 4
.text$mn:00007A27 _text$mn        ends
.text$mn:00007A27
.text$mn:00007A28 ; ===========================================================================
.text$mn:00007A28
.text$mn:00007A28 ; Segment type: Pure code
.text$mn:00007A28 ; Segment permissions: Read/Execute
.text$mn:00007A28 _text$mn        segment para public 'CODE' use32
.text$mn:00007A28                 assume cs:_text$mn
.text$mn:00007A28                 ;org 7A28h
.text$mn:00007A28 ; COMDAT (pick any)
.text$mn:00007A28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A28
.text$mn:00007A28 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A28
.text$mn:00007A28 ; Attributes: bp-based frame
.text$mn:00007A28
.text$mn:00007A28 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:00007A28                 public _wmemcpy
.text$mn:00007A28 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00007A28
.text$mn:00007A28 Dst             = dword ptr  8
.text$mn:00007A28 Src             = dword ptr  0Ch
.text$mn:00007A28 arg_8           = dword ptr  10h
.text$mn:00007A28
.text$mn:00007A28                 push    ebp
.text$mn:00007A29                 mov     ebp, esp
.text$mn:00007A2B                 mov     eax, [ebp+arg_8]
.text$mn:00007A2E                 shl     eax, 1
.text$mn:00007A30                 push    eax             ; Size
.text$mn:00007A31                 mov     ecx, [ebp+Src]
.text$mn:00007A34                 push    ecx             ; Src
.text$mn:00007A35                 mov     edx, [ebp+Dst]
.text$mn:00007A38                 push    edx             ; Dst
.text$mn:00007A39                 call    _memcpy
.text$mn:00007A3E                 add     esp, 0Ch
.text$mn:00007A41                 pop     ebp
.text$mn:00007A42                 retn
.text$mn:00007A42 _wmemcpy        endp
.text$mn:00007A42
.text$mn:00007A42 ; ---------------------------------------------------------------------------
.text$mn:00007A43                 align 4
.text$mn:00007A43 _text$mn        ends
.text$mn:00007A43
.text$mn:00007A44 ; ===========================================================================
.text$mn:00007A44
.text$mn:00007A44 ; Segment type: Pure code
.text$mn:00007A44 ; Segment permissions: Read/Execute
.text$mn:00007A44 _text$mn        segment para public 'CODE' use32
.text$mn:00007A44                 assume cs:_text$mn
.text$mn:00007A44                 ;org 7A44h
.text$mn:00007A44 ; COMDAT (pick any)
.text$mn:00007A44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A44
.text$mn:00007A44 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A44
.text$mn:00007A44 ; Attributes: bp-based frame
.text$mn:00007A44
.text$mn:00007A44 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:00007A44                 public _wmemmove
.text$mn:00007A44 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00007A44
.text$mn:00007A44 Dst             = dword ptr  8
.text$mn:00007A44 Src             = dword ptr  0Ch
.text$mn:00007A44 arg_8           = dword ptr  10h
.text$mn:00007A44
.text$mn:00007A44                 push    ebp
.text$mn:00007A45                 mov     ebp, esp
.text$mn:00007A47                 mov     eax, [ebp+arg_8]
.text$mn:00007A4A                 shl     eax, 1
.text$mn:00007A4C                 push    eax             ; Size
.text$mn:00007A4D                 mov     ecx, [ebp+Src]
.text$mn:00007A50                 push    ecx             ; Src
.text$mn:00007A51                 mov     edx, [ebp+Dst]
.text$mn:00007A54                 push    edx             ; Dst
.text$mn:00007A55                 call    _memmove
.text$mn:00007A5A                 add     esp, 0Ch
.text$mn:00007A5D                 pop     ebp
.text$mn:00007A5E                 retn
.text$mn:00007A5E _wmemmove       endp
.text$mn:00007A5E
.text$mn:00007A5E ; ---------------------------------------------------------------------------
.text$mn:00007A5F                 align 10h
.text$mn:00007A5F _text$mn        ends
.text$mn:00007A5F
.xdata$x:00007A60 ; ===========================================================================
.xdata$x:00007A60
.xdata$x:00007A60 ; Segment type: Pure data
.xdata$x:00007A60 ; Segment permissions: Read
.xdata$x:00007A60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007A60                 assume cs:_xdata$x
.xdata$x:00007A60                 ;org 7A60h
.xdata$x:00007A60 ; COMDAT (pick associative to section at 551C)
.xdata$x:00007A60 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00007A60                                         ; DATA XREF: .xdata$x:00007A70o
.xdata$x:00007A61                 db 0FFh
.xdata$x:00007A62                 db 0FFh
.xdata$x:00007A63                 db 0FFh
.xdata$x:00007A64                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00007A68 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00007A68                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00007A69                 db    5
.xdata$x:00007A6A                 db  93h ; ô
.xdata$x:00007A6B                 db  19h
.xdata$x:00007A6C                 db    1
.xdata$x:00007A6D                 db    0
.xdata$x:00007A6E                 db    0
.xdata$x:00007A6F                 db    0
.xdata$x:00007A70                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00007A74                 db    0
.xdata$x:00007A75                 db    0
.xdata$x:00007A76                 db    0
.xdata$x:00007A77                 db    0
.xdata$x:00007A78                 db    0
.xdata$x:00007A79                 db    0
.xdata$x:00007A7A                 db    0
.xdata$x:00007A7B                 db    0
.xdata$x:00007A7C                 db    0
.xdata$x:00007A7D                 db    0
.xdata$x:00007A7E                 db    0
.xdata$x:00007A7F                 db    0
.xdata$x:00007A80                 db    0
.xdata$x:00007A81                 db    0
.xdata$x:00007A82                 db    0
.xdata$x:00007A83                 db    0
.xdata$x:00007A84                 db    0
.xdata$x:00007A85                 db    0
.xdata$x:00007A86                 db    0
.xdata$x:00007A87                 db    0
.xdata$x:00007A88                 db    0
.xdata$x:00007A89                 db    0
.xdata$x:00007A8A                 db    0
.xdata$x:00007A8B                 db    0
.xdata$x:00007A8B _xdata$x        ends
.xdata$x:00007A8B
.xdata$x:00007A8C ; ===========================================================================
.xdata$x:00007A8C
.xdata$x:00007A8C ; Segment type: Pure data
.xdata$x:00007A8C ; Segment permissions: Read
.xdata$x:00007A8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007A8C                 assume cs:_xdata$x
.xdata$x:00007A8C                 ;org 7A8Ch
.xdata$x:00007A8C ; COMDAT (pick associative to section at 4198)
.xdata$x:00007A8C __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:00007A8C                                         ; DATA XREF: .xdata$x:00007A9Co
.xdata$x:00007A8D                 db 0FFh
.xdata$x:00007A8E                 db 0FFh
.xdata$x:00007A8F                 db 0FFh
.xdata$x:00007A90                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:00007A94 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:00007A94                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:00007A95                 db    5
.xdata$x:00007A96                 db  93h ; ô
.xdata$x:00007A97                 db  19h
.xdata$x:00007A98                 db    1
.xdata$x:00007A99                 db    0
.xdata$x:00007A9A                 db    0
.xdata$x:00007A9B                 db    0
.xdata$x:00007A9C                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:00007AA0                 db    0
.xdata$x:00007AA1                 db    0
.xdata$x:00007AA2                 db    0
.xdata$x:00007AA3                 db    0
.xdata$x:00007AA4                 db    0
.xdata$x:00007AA5                 db    0
.xdata$x:00007AA6                 db    0
.xdata$x:00007AA7                 db    0
.xdata$x:00007AA8                 db    0
.xdata$x:00007AA9                 db    0
.xdata$x:00007AAA                 db    0
.xdata$x:00007AAB                 db    0
.xdata$x:00007AAC                 db    0
.xdata$x:00007AAD                 db    0
.xdata$x:00007AAE                 db    0
.xdata$x:00007AAF                 db    0
.xdata$x:00007AB0                 db    0
.xdata$x:00007AB1                 db    0
.xdata$x:00007AB2                 db    0
.xdata$x:00007AB3                 db    0
.xdata$x:00007AB4                 db    0
.xdata$x:00007AB5                 db    0
.xdata$x:00007AB6                 db    0
.xdata$x:00007AB7                 db    0
.xdata$x:00007AB7 _xdata$x        ends
.xdata$x:00007AB7
.xdata$x:00007AB8 ; ===========================================================================
.xdata$x:00007AB8
.xdata$x:00007AB8 ; Segment type: Pure data
.xdata$x:00007AB8 ; Segment permissions: Read
.xdata$x:00007AB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007AB8                 assume cs:_xdata$x
.xdata$x:00007AB8                 ;org 7AB8h
.xdata$x:00007AB8 ; COMDAT (pick associative to section at 3F98)
.xdata$x:00007AB8 __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:00007AB8                                         ; DATA XREF: .xdata$x:00007AC8o
.xdata$x:00007AB9                 db 0FFh
.xdata$x:00007ABA                 db 0FFh
.xdata$x:00007ABB                 db 0FFh
.xdata$x:00007ABC                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:00007AC0 __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:00007AC0                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:00007AC1                 db    5
.xdata$x:00007AC2                 db  93h ; ô
.xdata$x:00007AC3                 db  19h
.xdata$x:00007AC4                 db    1
.xdata$x:00007AC5                 db    0
.xdata$x:00007AC6                 db    0
.xdata$x:00007AC7                 db    0
.xdata$x:00007AC8                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:00007ACC                 db    0
.xdata$x:00007ACD                 db    0
.xdata$x:00007ACE                 db    0
.xdata$x:00007ACF                 db    0
.xdata$x:00007AD0                 db    0
.xdata$x:00007AD1                 db    0
.xdata$x:00007AD2                 db    0
.xdata$x:00007AD3                 db    0
.xdata$x:00007AD4                 db    0
.xdata$x:00007AD5                 db    0
.xdata$x:00007AD6                 db    0
.xdata$x:00007AD7                 db    0
.xdata$x:00007AD8                 db    0
.xdata$x:00007AD9                 db    0
.xdata$x:00007ADA                 db    0
.xdata$x:00007ADB                 db    0
.xdata$x:00007ADC                 db    0
.xdata$x:00007ADD                 db    0
.xdata$x:00007ADE                 db    0
.xdata$x:00007ADF                 db    0
.xdata$x:00007AE0                 db    0
.xdata$x:00007AE1                 db    0
.xdata$x:00007AE2                 db    0
.xdata$x:00007AE3                 db    0
.xdata$x:00007AE3 _xdata$x        ends
.xdata$x:00007AE3
.xdata$x:00007AE4 ; ===========================================================================
.xdata$x:00007AE4
.xdata$x:00007AE4 ; Segment type: Pure data
.xdata$x:00007AE4 ; Segment permissions: Read
.xdata$x:00007AE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007AE4                 assume cs:_xdata$x
.xdata$x:00007AE4                 ;org 7AE4h
.xdata$x:00007AE4 ; COMDAT (pick associative to section at 488C)
.xdata$x:00007AE4 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:00007AE4                                         ; DATA XREF: .xdata$x:00007AFCo
.xdata$x:00007AE5                 db 0FFh
.xdata$x:00007AE6                 db 0FFh
.xdata$x:00007AE7                 db 0FFh
.xdata$x:00007AE8                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:00007AEC                 db 0FFh
.xdata$x:00007AED                 db 0FFh
.xdata$x:00007AEE                 db 0FFh
.xdata$x:00007AEF                 db 0FFh
.xdata$x:00007AF0                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:00007AF4 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:00007AF4                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:00007AF5                 db    5
.xdata$x:00007AF6                 db  93h ; ô
.xdata$x:00007AF7                 db  19h
.xdata$x:00007AF8                 db    2
.xdata$x:00007AF9                 db    0
.xdata$x:00007AFA                 db    0
.xdata$x:00007AFB                 db    0
.xdata$x:00007AFC                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:00007B00                 db    0
.xdata$x:00007B01                 db    0
.xdata$x:00007B02                 db    0
.xdata$x:00007B03                 db    0
.xdata$x:00007B04                 db    0
.xdata$x:00007B05                 db    0
.xdata$x:00007B06                 db    0
.xdata$x:00007B07                 db    0
.xdata$x:00007B08                 db    0
.xdata$x:00007B09                 db    0
.xdata$x:00007B0A                 db    0
.xdata$x:00007B0B                 db    0
.xdata$x:00007B0C                 db    0
.xdata$x:00007B0D                 db    0
.xdata$x:00007B0E                 db    0
.xdata$x:00007B0F                 db    0
.xdata$x:00007B10                 db    0
.xdata$x:00007B11                 db    0
.xdata$x:00007B12                 db    0
.xdata$x:00007B13                 db    0
.xdata$x:00007B14                 db    0
.xdata$x:00007B15                 db    0
.xdata$x:00007B16                 db    0
.xdata$x:00007B17                 db    0
.xdata$x:00007B17 _xdata$x        ends
.xdata$x:00007B17
.xdata$x:00007B18 ; ===========================================================================
.xdata$x:00007B18
.xdata$x:00007B18 ; Segment type: Pure data
.xdata$x:00007B18 ; Segment permissions: Read
.xdata$x:00007B18 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007B18                 assume cs:_xdata$x
.xdata$x:00007B18                 ;org 7B18h
.xdata$x:00007B18 ; COMDAT (pick associative to section at 2F6C)
.xdata$x:00007B18 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00007B18                                         ; DATA XREF: .xdata$x:00007B28o
.xdata$x:00007B19                 db 0FFh
.xdata$x:00007B1A                 db 0FFh
.xdata$x:00007B1B                 db 0FFh
.xdata$x:00007B1C                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00007B20 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00007B20                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00007B21                 db    5
.xdata$x:00007B22                 db  93h ; ô
.xdata$x:00007B23                 db  19h
.xdata$x:00007B24                 db    1
.xdata$x:00007B25                 db    0
.xdata$x:00007B26                 db    0
.xdata$x:00007B27                 db    0
.xdata$x:00007B28                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00007B2C                 db    0
.xdata$x:00007B2D                 db    0
.xdata$x:00007B2E                 db    0
.xdata$x:00007B2F                 db    0
.xdata$x:00007B30                 db    0
.xdata$x:00007B31                 db    0
.xdata$x:00007B32                 db    0
.xdata$x:00007B33                 db    0
.xdata$x:00007B34                 db    0
.xdata$x:00007B35                 db    0
.xdata$x:00007B36                 db    0
.xdata$x:00007B37                 db    0
.xdata$x:00007B38                 db    0
.xdata$x:00007B39                 db    0
.xdata$x:00007B3A                 db    0
.xdata$x:00007B3B                 db    0
.xdata$x:00007B3C                 db    0
.xdata$x:00007B3D                 db    0
.xdata$x:00007B3E                 db    0
.xdata$x:00007B3F                 db    0
.xdata$x:00007B40                 db    0
.xdata$x:00007B41                 db    0
.xdata$x:00007B42                 db    0
.xdata$x:00007B43                 db    0
.xdata$x:00007B43 _xdata$x        ends
.xdata$x:00007B43
.xdata$x:00007B44 ; ===========================================================================
.xdata$x:00007B44
.xdata$x:00007B44 ; Segment type: Pure data
.xdata$x:00007B44 ; Segment permissions: Read
.xdata$x:00007B44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007B44                 assume cs:_xdata$x
.xdata$x:00007B44                 ;org 7B44h
.xdata$x:00007B44 ; COMDAT (pick associative to section at 3BEC)
.xdata$x:00007B44 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00007B44                                         ; DATA XREF: .xdata$x:00007B54o
.xdata$x:00007B45                 db 0FFh
.xdata$x:00007B46                 db 0FFh
.xdata$x:00007B47                 db 0FFh
.xdata$x:00007B48                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00007B4C __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00007B4C                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00007B4D                 db    5
.xdata$x:00007B4E                 db  93h ; ô
.xdata$x:00007B4F                 db  19h
.xdata$x:00007B50                 db    1
.xdata$x:00007B51                 db    0
.xdata$x:00007B52                 db    0
.xdata$x:00007B53                 db    0
.xdata$x:00007B54                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00007B58                 db    0
.xdata$x:00007B59                 db    0
.xdata$x:00007B5A                 db    0
.xdata$x:00007B5B                 db    0
.xdata$x:00007B5C                 db    0
.xdata$x:00007B5D                 db    0
.xdata$x:00007B5E                 db    0
.xdata$x:00007B5F                 db    0
.xdata$x:00007B60                 db    0
.xdata$x:00007B61                 db    0
.xdata$x:00007B62                 db    0
.xdata$x:00007B63                 db    0
.xdata$x:00007B64                 db    0
.xdata$x:00007B65                 db    0
.xdata$x:00007B66                 db    0
.xdata$x:00007B67                 db    0
.xdata$x:00007B68                 db    0
.xdata$x:00007B69                 db    0
.xdata$x:00007B6A                 db    0
.xdata$x:00007B6B                 db    0
.xdata$x:00007B6C                 db    0
.xdata$x:00007B6D                 db    0
.xdata$x:00007B6E                 db    0
.xdata$x:00007B6F                 db    0
.xdata$x:00007B6F _xdata$x        ends
.xdata$x:00007B6F
.xdata$x:00007B70 ; ===========================================================================
.xdata$x:00007B70
.xdata$x:00007B70 ; Segment type: Pure data
.xdata$x:00007B70 ; Segment permissions: Read
.xdata$x:00007B70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007B70                 assume cs:_xdata$x
.xdata$x:00007B70                 ;org 7B70h
.xdata$x:00007B70 ; COMDAT (pick associative to section at 2E74)
.xdata$x:00007B70 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00007B70                                         ; DATA XREF: .xdata$x:00007B80o
.xdata$x:00007B71                 db 0FFh
.xdata$x:00007B72                 db 0FFh
.xdata$x:00007B73                 db 0FFh
.xdata$x:00007B74                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00007B78 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00007B78                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00007B79                 db    5
.xdata$x:00007B7A                 db  93h ; ô
.xdata$x:00007B7B                 db  19h
.xdata$x:00007B7C                 db    1
.xdata$x:00007B7D                 db    0
.xdata$x:00007B7E                 db    0
.xdata$x:00007B7F                 db    0
.xdata$x:00007B80                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00007B84                 db    0
.xdata$x:00007B85                 db    0
.xdata$x:00007B86                 db    0
.xdata$x:00007B87                 db    0
.xdata$x:00007B88                 db    0
.xdata$x:00007B89                 db    0
.xdata$x:00007B8A                 db    0
.xdata$x:00007B8B                 db    0
.xdata$x:00007B8C                 db    0
.xdata$x:00007B8D                 db    0
.xdata$x:00007B8E                 db    0
.xdata$x:00007B8F                 db    0
.xdata$x:00007B90                 db    0
.xdata$x:00007B91                 db    0
.xdata$x:00007B92                 db    0
.xdata$x:00007B93                 db    0
.xdata$x:00007B94                 db    0
.xdata$x:00007B95                 db    0
.xdata$x:00007B96                 db    0
.xdata$x:00007B97                 db    0
.xdata$x:00007B98                 db    0
.xdata$x:00007B99                 db    0
.xdata$x:00007B9A                 db    0
.xdata$x:00007B9B                 db    0
.xdata$x:00007B9B _xdata$x        ends
.xdata$x:00007B9B
.xdata$x:00007B9C ; ===========================================================================
.xdata$x:00007B9C
.xdata$x:00007B9C ; Segment type: Pure data
.xdata$x:00007B9C ; Segment permissions: Read
.xdata$x:00007B9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007B9C                 assume cs:_xdata$x
.xdata$x:00007B9C                 ;org 7B9Ch
.xdata$x:00007B9C ; COMDAT (pick associative to section at 3AFC)
.xdata$x:00007B9C __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00007B9C                                         ; DATA XREF: .xdata$x:00007BACo
.xdata$x:00007B9D                 db 0FFh
.xdata$x:00007B9E                 db 0FFh
.xdata$x:00007B9F                 db 0FFh
.xdata$x:00007BA0                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00007BA4 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00007BA4                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00007BA5                 db    5
.xdata$x:00007BA6                 db  93h ; ô
.xdata$x:00007BA7                 db  19h
.xdata$x:00007BA8                 db    1
.xdata$x:00007BA9                 db    0
.xdata$x:00007BAA                 db    0
.xdata$x:00007BAB                 db    0
.xdata$x:00007BAC                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00007BB0                 db    0
.xdata$x:00007BB1                 db    0
.xdata$x:00007BB2                 db    0
.xdata$x:00007BB3                 db    0
.xdata$x:00007BB4                 db    0
.xdata$x:00007BB5                 db    0
.xdata$x:00007BB6                 db    0
.xdata$x:00007BB7                 db    0
.xdata$x:00007BB8                 db    0
.xdata$x:00007BB9                 db    0
.xdata$x:00007BBA                 db    0
.xdata$x:00007BBB                 db    0
.xdata$x:00007BBC                 db    0
.xdata$x:00007BBD                 db    0
.xdata$x:00007BBE                 db    0
.xdata$x:00007BBF                 db    0
.xdata$x:00007BC0                 db    0
.xdata$x:00007BC1                 db    0
.xdata$x:00007BC2                 db    0
.xdata$x:00007BC3                 db    0
.xdata$x:00007BC4                 db    0
.xdata$x:00007BC5                 db    0
.xdata$x:00007BC6                 db    0
.xdata$x:00007BC7                 db    0
.xdata$x:00007BC7 _xdata$x        ends
.xdata$x:00007BC7
.xdata$x:00007BC8 ; ===========================================================================
.xdata$x:00007BC8
.xdata$x:00007BC8 ; Segment type: Pure data
.xdata$x:00007BC8 ; Segment permissions: Read
.xdata$x:00007BC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007BC8                 assume cs:_xdata$x
.xdata$x:00007BC8                 ;org 7BC8h
.xdata$x:00007BC8 ; COMDAT (pick associative to section at 3384)
.xdata$x:00007BC8 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00007BC8                                         ; DATA XREF: .xdata$x:00007BD8o
.xdata$x:00007BC9                 db 0FFh
.xdata$x:00007BCA                 db 0FFh
.xdata$x:00007BCB                 db 0FFh
.xdata$x:00007BCC                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00007BD0 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00007BD0                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00007BD1                 db    5
.xdata$x:00007BD2                 db  93h ; ô
.xdata$x:00007BD3                 db  19h
.xdata$x:00007BD4                 db    1
.xdata$x:00007BD5                 db    0
.xdata$x:00007BD6                 db    0
.xdata$x:00007BD7                 db    0
.xdata$x:00007BD8                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00007BDC                 db    0
.xdata$x:00007BDD                 db    0
.xdata$x:00007BDE                 db    0
.xdata$x:00007BDF                 db    0
.xdata$x:00007BE0                 db    0
.xdata$x:00007BE1                 db    0
.xdata$x:00007BE2                 db    0
.xdata$x:00007BE3                 db    0
.xdata$x:00007BE4                 db    0
.xdata$x:00007BE5                 db    0
.xdata$x:00007BE6                 db    0
.xdata$x:00007BE7                 db    0
.xdata$x:00007BE8                 db    0
.xdata$x:00007BE9                 db    0
.xdata$x:00007BEA                 db    0
.xdata$x:00007BEB                 db    0
.xdata$x:00007BEC                 db    0
.xdata$x:00007BED                 db    0
.xdata$x:00007BEE                 db    0
.xdata$x:00007BEF                 db    0
.xdata$x:00007BF0                 db    0
.xdata$x:00007BF1                 db    0
.xdata$x:00007BF2                 db    0
.xdata$x:00007BF3                 db    0
.xdata$x:00007BF3 _xdata$x        ends
.xdata$x:00007BF3
.xdata$x:00007BF4 ; ===========================================================================
.xdata$x:00007BF4
.xdata$x:00007BF4 ; Segment type: Pure data
.xdata$x:00007BF4 ; Segment permissions: Read
.xdata$x:00007BF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007BF4                 assume cs:_xdata$x
.xdata$x:00007BF4                 ;org 7BF4h
.xdata$x:00007BF4 ; COMDAT (pick associative to section at 3DAC)
.xdata$x:00007BF4 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00007BF4                                         ; DATA XREF: .xdata$x:00007C04o
.xdata$x:00007BF5                 db 0FFh
.xdata$x:00007BF6                 db 0FFh
.xdata$x:00007BF7                 db 0FFh
.xdata$x:00007BF8                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00007BFC __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00007BFC                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00007BFD                 db    5
.xdata$x:00007BFE                 db  93h ; ô
.xdata$x:00007BFF                 db  19h
.xdata$x:00007C00                 db    1
.xdata$x:00007C01                 db    0
.xdata$x:00007C02                 db    0
.xdata$x:00007C03                 db    0
.xdata$x:00007C04                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00007C08                 align 20h
.xdata$x:00007C08 _xdata$x        ends
.xdata$x:00007C08
.xdata$x:00007C20 ; ===========================================================================
.xdata$x:00007C20
.xdata$x:00007C20 ; Segment type: Pure data
.xdata$x:00007C20 ; Segment permissions: Read
.xdata$x:00007C20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007C20                 assume cs:_xdata$x
.xdata$x:00007C20                 ;org 7C20h
.xdata$x:00007C20 ; COMDAT (pick associative to section at 4A1C)
.xdata$x:00007C20 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00007C20                                         ; DATA XREF: .xdata$x:00007CA8o
.xdata$x:00007C21                 db    0
.xdata$x:00007C22                 db    0
.xdata$x:00007C23                 db    0
.xdata$x:00007C24                 db    0
.xdata$x:00007C25                 db    0
.xdata$x:00007C26                 db    0
.xdata$x:00007C27                 db    0
.xdata$x:00007C28                 db    0
.xdata$x:00007C29                 db    0
.xdata$x:00007C2A                 db    0
.xdata$x:00007C2B                 db    0
.xdata$x:00007C2C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00007C30 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00007C30                                         ; DATA XREF: .xdata$x:00007C94o
.xdata$x:00007C31                 db    0
.xdata$x:00007C32                 db    0
.xdata$x:00007C33                 db    0
.xdata$x:00007C34                 db    0
.xdata$x:00007C35                 db    0
.xdata$x:00007C36                 db    0
.xdata$x:00007C37                 db    0
.xdata$x:00007C38                 db    0
.xdata$x:00007C39                 db    0
.xdata$x:00007C3A                 db    0
.xdata$x:00007C3B                 db    0
.xdata$x:00007C3C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00007C40 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00007C40                                         ; DATA XREF: .xdata$x:00007C68o
.xdata$x:00007C41                 db 0FFh
.xdata$x:00007C42                 db 0FFh
.xdata$x:00007C43                 db 0FFh
.xdata$x:00007C44                 db    0
.xdata$x:00007C45                 db    0
.xdata$x:00007C46                 db    0
.xdata$x:00007C47                 db    0
.xdata$x:00007C48                 db 0FFh
.xdata$x:00007C49                 db 0FFh
.xdata$x:00007C4A                 db 0FFh
.xdata$x:00007C4B                 db 0FFh
.xdata$x:00007C4C                 db    0
.xdata$x:00007C4D                 db    0
.xdata$x:00007C4E                 db    0
.xdata$x:00007C4F                 db    0
.xdata$x:00007C50                 db    1
.xdata$x:00007C51                 db    0
.xdata$x:00007C52                 db    0
.xdata$x:00007C53                 db    0
.xdata$x:00007C54                 db    0
.xdata$x:00007C55                 db    0
.xdata$x:00007C56                 db    0
.xdata$x:00007C57                 db    0
.xdata$x:00007C58                 db    1
.xdata$x:00007C59                 db    0
.xdata$x:00007C5A                 db    0
.xdata$x:00007C5B                 db    0
.xdata$x:00007C5C                 db    0
.xdata$x:00007C5D                 db    0
.xdata$x:00007C5E                 db    0
.xdata$x:00007C5F                 db    0
.xdata$x:00007C60 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00007C60                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00007C61                 db    5
.xdata$x:00007C62                 db  93h ; ô
.xdata$x:00007C63                 db  19h
.xdata$x:00007C64                 db    4
.xdata$x:00007C65                 db    0
.xdata$x:00007C66                 db    0
.xdata$x:00007C67                 db    0
.xdata$x:00007C68                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00007C6C                 db    2
.xdata$x:00007C6D                 db    0
.xdata$x:00007C6E                 db    0
.xdata$x:00007C6F                 db    0
.xdata$x:00007C70                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00007C74                 db    0
.xdata$x:00007C75                 db    0
.xdata$x:00007C76                 db    0
.xdata$x:00007C77                 db    0
.xdata$x:00007C78                 db    0
.xdata$x:00007C79                 db    0
.xdata$x:00007C7A                 db    0
.xdata$x:00007C7B                 db    0
.xdata$x:00007C7C                 db    0
.xdata$x:00007C7D                 db    0
.xdata$x:00007C7E                 db    0
.xdata$x:00007C7F                 db    0
.xdata$x:00007C80                 db    0
.xdata$x:00007C81                 db    0
.xdata$x:00007C82                 db    0
.xdata$x:00007C83                 db    0
.xdata$x:00007C84 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00007C84                                         ; DATA XREF: .xdata$x:00007C70o
.xdata$x:00007C85                 db    0
.xdata$x:00007C86                 db    0
.xdata$x:00007C87                 db    0
.xdata$x:00007C88                 db    2
.xdata$x:00007C89                 db    0
.xdata$x:00007C8A                 db    0
.xdata$x:00007C8B                 db    0
.xdata$x:00007C8C                 db    3
.xdata$x:00007C8D                 db    0
.xdata$x:00007C8E                 db    0
.xdata$x:00007C8F                 db    0
.xdata$x:00007C90                 db    1
.xdata$x:00007C91                 db    0
.xdata$x:00007C92                 db    0
.xdata$x:00007C93                 db    0
.xdata$x:00007C94                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00007C98                 align 10h
.xdata$x:00007CA0                 db    3
.xdata$x:00007CA1                 db    0
.xdata$x:00007CA2                 db    0
.xdata$x:00007CA3                 db    0
.xdata$x:00007CA4                 db    1
.xdata$x:00007CA5                 db    0
.xdata$x:00007CA6                 db    0
.xdata$x:00007CA7                 db    0
.xdata$x:00007CA8                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00007CA8 _xdata$x        ends
.xdata$x:00007CA8
.xdata$x:00007CAC ; ===========================================================================
.xdata$x:00007CAC
.xdata$x:00007CAC ; Segment type: Pure data
.xdata$x:00007CAC ; Segment permissions: Read
.xdata$x:00007CAC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007CAC                 assume cs:_xdata$x
.xdata$x:00007CAC                 ;org 7CACh
.xdata$x:00007CAC ; COMDAT (pick associative to section at 3A08)
.xdata$x:00007CAC __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:00007CAC                                         ; DATA XREF: .xdata$x:00007CBCo
.xdata$x:00007CAD                 db 0FFh
.xdata$x:00007CAE                 db 0FFh
.xdata$x:00007CAF                 db 0FFh
.xdata$x:00007CB0                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:00007CB4 __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00007CB4                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:00007CB5                 db    5
.xdata$x:00007CB6                 db  93h ; ô
.xdata$x:00007CB7                 db  19h
.xdata$x:00007CB8                 db    1
.xdata$x:00007CB9                 db    0
.xdata$x:00007CBA                 db    0
.xdata$x:00007CBB                 db    0
.xdata$x:00007CBC                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:00007CC0                 db    0
.xdata$x:00007CC1                 db    0
.xdata$x:00007CC2                 db    0
.xdata$x:00007CC3                 db    0
.xdata$x:00007CC4                 db    0
.xdata$x:00007CC5                 db    0
.xdata$x:00007CC6                 db    0
.xdata$x:00007CC7                 db    0
.xdata$x:00007CC8                 db    0
.xdata$x:00007CC9                 db    0
.xdata$x:00007CCA                 db    0
.xdata$x:00007CCB                 db    0
.xdata$x:00007CCC                 db    0
.xdata$x:00007CCD                 db    0
.xdata$x:00007CCE                 db    0
.xdata$x:00007CCF                 db    0
.xdata$x:00007CD0                 db    0
.xdata$x:00007CD1                 db    0
.xdata$x:00007CD2                 db    0
.xdata$x:00007CD3                 db    0
.xdata$x:00007CD4                 db    0
.xdata$x:00007CD5                 db    0
.xdata$x:00007CD6                 db    0
.xdata$x:00007CD7                 db    0
.xdata$x:00007CD7 _xdata$x        ends
.xdata$x:00007CD7
.xdata$x:00007CD8 ; ===========================================================================
.xdata$x:00007CD8
.xdata$x:00007CD8 ; Segment type: Pure data
.xdata$x:00007CD8 ; Segment permissions: Read
.xdata$x:00007CD8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007CD8                 assume cs:_xdata$x
.xdata$x:00007CD8                 ;org 7CD8h
.xdata$x:00007CD8 ; COMDAT (pick associative to section at 4118)
.xdata$x:00007CD8 __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:00007CD8                                         ; DATA XREF: .xdata$x:00007CE8o
.xdata$x:00007CD9                 db 0FFh
.xdata$x:00007CDA                 db 0FFh
.xdata$x:00007CDB                 db 0FFh
.xdata$x:00007CDC                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:00007CE0 __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:00007CE0                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:00007CE1                 db    5
.xdata$x:00007CE2                 db  93h ; ô
.xdata$x:00007CE3                 db  19h
.xdata$x:00007CE4                 db    1
.xdata$x:00007CE5                 db    0
.xdata$x:00007CE6                 db    0
.xdata$x:00007CE7                 db    0
.xdata$x:00007CE8                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:00007CEC                 db    0
.xdata$x:00007CED                 db    0
.xdata$x:00007CEE                 db    0
.xdata$x:00007CEF                 db    0
.xdata$x:00007CF0                 db    0
.xdata$x:00007CF1                 db    0
.xdata$x:00007CF2                 db    0
.xdata$x:00007CF3                 db    0
.xdata$x:00007CF4                 db    0
.xdata$x:00007CF5                 db    0
.xdata$x:00007CF6                 db    0
.xdata$x:00007CF7                 db    0
.xdata$x:00007CF8                 db    0
.xdata$x:00007CF9                 db    0
.xdata$x:00007CFA                 db    0
.xdata$x:00007CFB                 db    0
.xdata$x:00007CFC                 db    0
.xdata$x:00007CFD                 db    0
.xdata$x:00007CFE                 db    0
.xdata$x:00007CFF                 db    0
.xdata$x:00007D00                 db    0
.xdata$x:00007D01                 db    0
.xdata$x:00007D02                 db    0
.xdata$x:00007D03                 db    0
.xdata$x:00007D03 _xdata$x        ends
.xdata$x:00007D03
.xdata$x:00007D04 ; ===========================================================================
.xdata$x:00007D04
.xdata$x:00007D04 ; Segment type: Pure data
.xdata$x:00007D04 ; Segment permissions: Read
.xdata$x:00007D04 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007D04                 assume cs:_xdata$x
.xdata$x:00007D04                 ;org 7D04h
.xdata$x:00007D04 ; COMDAT (pick associative to section at 3984)
.xdata$x:00007D04 __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00007D04                                         ; DATA XREF: .xdata$x:00007D14o
.xdata$x:00007D05                 db 0FFh
.xdata$x:00007D06                 db 0FFh
.xdata$x:00007D07                 db 0FFh
.xdata$x:00007D08                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:00007D0C __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00007D0C                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:00007D0D                 db    5
.xdata$x:00007D0E                 db  93h ; ô
.xdata$x:00007D0F                 db  19h
.xdata$x:00007D10                 db    1
.xdata$x:00007D11                 db    0
.xdata$x:00007D12                 db    0
.xdata$x:00007D13                 db    0
.xdata$x:00007D14                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:00007D18                 db    0
.xdata$x:00007D19                 db    0
.xdata$x:00007D1A                 db    0
.xdata$x:00007D1B                 db    0
.xdata$x:00007D1C                 db    0
.xdata$x:00007D1D                 db    0
.xdata$x:00007D1E                 db    0
.xdata$x:00007D1F                 db    0
.xdata$x:00007D20                 db    0
.xdata$x:00007D21                 db    0
.xdata$x:00007D22                 db    0
.xdata$x:00007D23                 db    0
.xdata$x:00007D24                 db    0
.xdata$x:00007D25                 db    0
.xdata$x:00007D26                 db    0
.xdata$x:00007D27                 db    0
.xdata$x:00007D28                 db    0
.xdata$x:00007D29                 db    0
.xdata$x:00007D2A                 db    0
.xdata$x:00007D2B                 db    0
.xdata$x:00007D2C                 db    0
.xdata$x:00007D2D                 db    0
.xdata$x:00007D2E                 db    0
.xdata$x:00007D2F                 db    0
.xdata$x:00007D2F _xdata$x        ends
.xdata$x:00007D2F
.xdata$x:00007D30 ; ===========================================================================
.xdata$x:00007D30
.xdata$x:00007D30 ; Segment type: Pure data
.xdata$x:00007D30 ; Segment permissions: Read
.xdata$x:00007D30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007D30                 assume cs:_xdata$x
.xdata$x:00007D30                 ;org 7D30h
.xdata$x:00007D30 ; COMDAT (pick associative to section at 362C)
.xdata$x:00007D30 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00007D30                                         ; DATA XREF: .xdata$x:00007D40o
.xdata$x:00007D31                 db 0FFh
.xdata$x:00007D32                 db 0FFh
.xdata$x:00007D33                 db 0FFh
.xdata$x:00007D34                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00007D38 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00007D38                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00007D39                 db    5
.xdata$x:00007D3A                 db  93h ; ô
.xdata$x:00007D3B                 db  19h
.xdata$x:00007D3C                 db    1
.xdata$x:00007D3D                 db    0
.xdata$x:00007D3E                 db    0
.xdata$x:00007D3F                 db    0
.xdata$x:00007D40                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00007D44                 db    0
.xdata$x:00007D45                 db    0
.xdata$x:00007D46                 db    0
.xdata$x:00007D47                 db    0
.xdata$x:00007D48                 db    0
.xdata$x:00007D49                 db    0
.xdata$x:00007D4A                 db    0
.xdata$x:00007D4B                 db    0
.xdata$x:00007D4C                 db    0
.xdata$x:00007D4D                 db    0
.xdata$x:00007D4E                 db    0
.xdata$x:00007D4F                 db    0
.xdata$x:00007D50                 db    0
.xdata$x:00007D51                 db    0
.xdata$x:00007D52                 db    0
.xdata$x:00007D53                 db    0
.xdata$x:00007D54                 db    0
.xdata$x:00007D55                 db    0
.xdata$x:00007D56                 db    0
.xdata$x:00007D57                 db    0
.xdata$x:00007D58                 db    0
.xdata$x:00007D59                 db    0
.xdata$x:00007D5A                 db    0
.xdata$x:00007D5B                 db    0
.xdata$x:00007D5B _xdata$x        ends
.xdata$x:00007D5B
.xdata$x:00007D5C ; ===========================================================================
.xdata$x:00007D5C
.xdata$x:00007D5C ; Segment type: Pure data
.xdata$x:00007D5C ; Segment permissions: Read
.xdata$x:00007D5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007D5C                 assume cs:_xdata$x
.xdata$x:00007D5C                 ;org 7D5Ch
.xdata$x:00007D5C ; COMDAT (pick associative to section at 71B0)
.xdata$x:00007D5C __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00007D5C                                         ; DATA XREF: .xdata$x:00007D6Co
.xdata$x:00007D5D                 db 0FFh
.xdata$x:00007D5E                 db 0FFh
.xdata$x:00007D5F                 db 0FFh
.xdata$x:00007D60                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00007D64 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00007D64                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00007D65                 db    5
.xdata$x:00007D66                 db  93h ; ô
.xdata$x:00007D67                 db  19h
.xdata$x:00007D68                 db    1
.xdata$x:00007D69                 db    0
.xdata$x:00007D6A                 db    0
.xdata$x:00007D6B                 db    0
.xdata$x:00007D6C                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00007D70                 db    0
.xdata$x:00007D71                 db    0
.xdata$x:00007D72                 db    0
.xdata$x:00007D73                 db    0
.xdata$x:00007D74                 db    0
.xdata$x:00007D75                 db    0
.xdata$x:00007D76                 db    0
.xdata$x:00007D77                 db    0
.xdata$x:00007D78                 db    0
.xdata$x:00007D79                 db    0
.xdata$x:00007D7A                 db    0
.xdata$x:00007D7B                 db    0
.xdata$x:00007D7C                 db    0
.xdata$x:00007D7D                 db    0
.xdata$x:00007D7E                 db    0
.xdata$x:00007D7F                 db    0
.xdata$x:00007D80                 db    0
.xdata$x:00007D81                 db    0
.xdata$x:00007D82                 db    0
.xdata$x:00007D83                 db    0
.xdata$x:00007D84                 db    0
.xdata$x:00007D85                 db    0
.xdata$x:00007D86                 db    0
.xdata$x:00007D87                 db    0
.xdata$x:00007D87 _xdata$x        ends
.xdata$x:00007D87
.xdata$x:00007D88 ; ===========================================================================
.xdata$x:00007D88
.xdata$x:00007D88 ; Segment type: Pure data
.xdata$x:00007D88 ; Segment permissions: Read
.xdata$x:00007D88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007D88                 assume cs:_xdata$x
.xdata$x:00007D88                 ;org 7D88h
.xdata$x:00007D88 ; COMDAT (pick associative to section at 3EB8)
.xdata$x:00007D88 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00007D88                                         ; DATA XREF: .xdata$x:00007D98o
.xdata$x:00007D89                 db 0FFh
.xdata$x:00007D8A                 db 0FFh
.xdata$x:00007D8B                 db 0FFh
.xdata$x:00007D8C                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00007D90 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00007D90                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00007D91                 db    5
.xdata$x:00007D92                 db  93h ; ô
.xdata$x:00007D93                 db  19h
.xdata$x:00007D94                 db    1
.xdata$x:00007D95                 db    0
.xdata$x:00007D96                 db    0
.xdata$x:00007D97                 db    0
.xdata$x:00007D98                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00007D9C                 db    0
.xdata$x:00007D9D                 db    0
.xdata$x:00007D9E                 db    0
.xdata$x:00007D9F                 db    0
.xdata$x:00007DA0                 db    0
.xdata$x:00007DA1                 db    0
.xdata$x:00007DA2                 db    0
.xdata$x:00007DA3                 db    0
.xdata$x:00007DA4                 db    0
.xdata$x:00007DA5                 db    0
.xdata$x:00007DA6                 db    0
.xdata$x:00007DA7                 db    0
.xdata$x:00007DA8                 db    0
.xdata$x:00007DA9                 db    0
.xdata$x:00007DAA                 db    0
.xdata$x:00007DAB                 db    0
.xdata$x:00007DAC                 db    0
.xdata$x:00007DAD                 db    0
.xdata$x:00007DAE                 db    0
.xdata$x:00007DAF                 db    0
.xdata$x:00007DB0                 db    0
.xdata$x:00007DB1                 db    0
.xdata$x:00007DB2                 db    0
.xdata$x:00007DB3                 db    0
.xdata$x:00007DB3 _xdata$x        ends
.xdata$x:00007DB3
.xdata$x:00007DB4 ; ===========================================================================
.xdata$x:00007DB4
.xdata$x:00007DB4 ; Segment type: Pure data
.xdata$x:00007DB4 ; Segment permissions: Read
.xdata$x:00007DB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007DB4                 assume cs:_xdata$x
.xdata$x:00007DB4                 ;org 7DB4h
.xdata$x:00007DB4 ; COMDAT (pick associative to section at 36A8)
.xdata$x:00007DB4 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00007DB4                                         ; DATA XREF: .xdata$x:00007DC4o
.xdata$x:00007DB5                 db 0FFh
.xdata$x:00007DB6                 db 0FFh
.xdata$x:00007DB7                 db 0FFh
.xdata$x:00007DB8                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00007DBC __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00007DBC                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00007DBD                 db    5
.xdata$x:00007DBE                 db  93h ; ô
.xdata$x:00007DBF                 db  19h
.xdata$x:00007DC0                 db    1
.xdata$x:00007DC1                 db    0
.xdata$x:00007DC2                 db    0
.xdata$x:00007DC3                 db    0
.xdata$x:00007DC4                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00007DC8                 align 20h
.xdata$x:00007DC8 _xdata$x        ends
.xdata$x:00007DC8
.xdata$x:00007DE0 ; ===========================================================================
.xdata$x:00007DE0
.xdata$x:00007DE0 ; Segment type: Pure data
.xdata$x:00007DE0 ; Segment permissions: Read
.xdata$x:00007DE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007DE0                 assume cs:_xdata$x
.xdata$x:00007DE0                 ;org 7DE0h
.xdata$x:00007DE0 ; COMDAT (pick associative to section at 7268)
.xdata$x:00007DE0 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00007DE0                                         ; DATA XREF: .xdata$x:00007DF0o
.xdata$x:00007DE1                 db 0FFh
.xdata$x:00007DE2                 db 0FFh
.xdata$x:00007DE3                 db 0FFh
.xdata$x:00007DE4                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00007DE8 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00007DE8                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00007DE9                 db    5
.xdata$x:00007DEA                 db  93h ; ô
.xdata$x:00007DEB                 db  19h
.xdata$x:00007DEC                 db    1
.xdata$x:00007DED                 db    0
.xdata$x:00007DEE                 db    0
.xdata$x:00007DEF                 db    0
.xdata$x:00007DF0                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00007DF4                 db    0
.xdata$x:00007DF5                 db    0
.xdata$x:00007DF6                 db    0
.xdata$x:00007DF7                 db    0
.xdata$x:00007DF8                 db    0
.xdata$x:00007DF9                 db    0
.xdata$x:00007DFA                 db    0
.xdata$x:00007DFB                 db    0
.xdata$x:00007DFC                 db    0
.xdata$x:00007DFD                 db    0
.xdata$x:00007DFE                 db    0
.xdata$x:00007DFF                 db    0
.xdata$x:00007E00                 db    0
.xdata$x:00007E01                 db    0
.xdata$x:00007E02                 db    0
.xdata$x:00007E03                 db    0
.xdata$x:00007E04                 db    0
.xdata$x:00007E05                 db    0
.xdata$x:00007E06                 db    0
.xdata$x:00007E07                 db    0
.xdata$x:00007E08                 db    0
.xdata$x:00007E09                 db    0
.xdata$x:00007E0A                 db    0
.xdata$x:00007E0B                 db    0
.xdata$x:00007E0B _xdata$x        ends
.xdata$x:00007E0B
.xdata$x:00007E0C ; ===========================================================================
.xdata$x:00007E0C
.xdata$x:00007E0C ; Segment type: Pure data
.xdata$x:00007E0C ; Segment permissions: Read
.xdata$x:00007E0C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007E0C                 assume cs:_xdata$x
.xdata$x:00007E0C                 ;org 7E0Ch
.xdata$x:00007E0C ; COMDAT (pick associative to section at 3F28)
.xdata$x:00007E0C __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00007E0C                                         ; DATA XREF: .xdata$x:00007E1Co
.xdata$x:00007E0D                 db 0FFh
.xdata$x:00007E0E                 db 0FFh
.xdata$x:00007E0F                 db 0FFh
.xdata$x:00007E10                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00007E14 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00007E14                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00007E15                 db    5
.xdata$x:00007E16                 db  93h ; ô
.xdata$x:00007E17                 db  19h
.xdata$x:00007E18                 db    1
.xdata$x:00007E19                 db    0
.xdata$x:00007E1A                 db    0
.xdata$x:00007E1B                 db    0
.xdata$x:00007E1C                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00007E20                 db    0
.xdata$x:00007E21                 db    0
.xdata$x:00007E22                 db    0
.xdata$x:00007E23                 db    0
.xdata$x:00007E24                 db    0
.xdata$x:00007E25                 db    0
.xdata$x:00007E26                 db    0
.xdata$x:00007E27                 db    0
.xdata$x:00007E28                 db    0
.xdata$x:00007E29                 db    0
.xdata$x:00007E2A                 db    0
.xdata$x:00007E2B                 db    0
.xdata$x:00007E2C                 db    0
.xdata$x:00007E2D                 db    0
.xdata$x:00007E2E                 db    0
.xdata$x:00007E2F                 db    0
.xdata$x:00007E30                 db    0
.xdata$x:00007E31                 db    0
.xdata$x:00007E32                 db    0
.xdata$x:00007E33                 db    0
.xdata$x:00007E34                 db    0
.xdata$x:00007E35                 db    0
.xdata$x:00007E36                 db    0
.xdata$x:00007E37                 db    0
.xdata$x:00007E37 _xdata$x        ends
.xdata$x:00007E37
.xdata$x:00007E38 ; ===========================================================================
.xdata$x:00007E38
.xdata$x:00007E38 ; Segment type: Pure data
.xdata$x:00007E38 ; Segment permissions: Read
.xdata$x:00007E38 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007E38                 assume cs:_xdata$x
.xdata$x:00007E38                 ;org 7E38h
.xdata$x:00007E38 ; COMDAT (pick associative to section at 3778)
.xdata$x:00007E38 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00007E38                                         ; DATA XREF: .xdata$x:00007E48o
.xdata$x:00007E39                 db 0FFh
.xdata$x:00007E3A                 db 0FFh
.xdata$x:00007E3B                 db 0FFh
.xdata$x:00007E3C                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00007E40 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00007E40                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00007E41                 db    5
.xdata$x:00007E42                 db  93h ; ô
.xdata$x:00007E43                 db  19h
.xdata$x:00007E44                 db    1
.xdata$x:00007E45                 db    0
.xdata$x:00007E46                 db    0
.xdata$x:00007E47                 db    0
.xdata$x:00007E48                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00007E4C                 db    0
.xdata$x:00007E4D                 db    0
.xdata$x:00007E4E                 db    0
.xdata$x:00007E4F                 db    0
.xdata$x:00007E50                 db    0
.xdata$x:00007E51                 db    0
.xdata$x:00007E52                 db    0
.xdata$x:00007E53                 db    0
.xdata$x:00007E54                 db    0
.xdata$x:00007E55                 db    0
.xdata$x:00007E56                 db    0
.xdata$x:00007E57                 db    0
.xdata$x:00007E58                 db    0
.xdata$x:00007E59                 db    0
.xdata$x:00007E5A                 db    0
.xdata$x:00007E5B                 db    0
.xdata$x:00007E5C                 db    0
.xdata$x:00007E5D                 db    0
.xdata$x:00007E5E                 db    0
.xdata$x:00007E5F                 db    0
.xdata$x:00007E60                 db    0
.xdata$x:00007E61                 db    0
.xdata$x:00007E62                 db    0
.xdata$x:00007E63                 db    0
.xdata$x:00007E63 _xdata$x        ends
.xdata$x:00007E63
.xdata$x:00007E64 ; ===========================================================================
.xdata$x:00007E64
.xdata$x:00007E64 ; Segment type: Pure data
.xdata$x:00007E64 ; Segment permissions: Read
.xdata$x:00007E64 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007E64                 assume cs:_xdata$x
.xdata$x:00007E64                 ;org 7E64h
.xdata$x:00007E64 ; COMDAT (pick associative to section at 732C)
.xdata$x:00007E64 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00007E64                                         ; DATA XREF: .xdata$x:00007E74o
.xdata$x:00007E65                 db 0FFh
.xdata$x:00007E66                 db 0FFh
.xdata$x:00007E67                 db 0FFh
.xdata$x:00007E68                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00007E6C __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00007E6C                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00007E6D                 db    5
.xdata$x:00007E6E                 db  93h ; ô
.xdata$x:00007E6F                 db  19h
.xdata$x:00007E70                 db    1
.xdata$x:00007E71                 db    0
.xdata$x:00007E72                 db    0
.xdata$x:00007E73                 db    0
.xdata$x:00007E74                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00007E78                 db    0
.xdata$x:00007E79                 db    0
.xdata$x:00007E7A                 db    0
.xdata$x:00007E7B                 db    0
.xdata$x:00007E7C                 db    0
.xdata$x:00007E7D                 db    0
.xdata$x:00007E7E                 db    0
.xdata$x:00007E7F                 db    0
.xdata$x:00007E80                 db    0
.xdata$x:00007E81                 db    0
.xdata$x:00007E82                 db    0
.xdata$x:00007E83                 db    0
.xdata$x:00007E84                 db    0
.xdata$x:00007E85                 db    0
.xdata$x:00007E86                 db    0
.xdata$x:00007E87                 db    0
.xdata$x:00007E88                 db    0
.xdata$x:00007E89                 db    0
.xdata$x:00007E8A                 db    0
.xdata$x:00007E8B                 db    0
.xdata$x:00007E8C                 db    0
.xdata$x:00007E8D                 db    0
.xdata$x:00007E8E                 db    0
.xdata$x:00007E8F                 db    0
.xdata$x:00007E8F _xdata$x        ends
.xdata$x:00007E8F
.xdata$x:00007E90 ; ===========================================================================
.xdata$x:00007E90
.xdata$x:00007E90 ; Segment type: Pure data
.xdata$x:00007E90 ; Segment permissions: Read
.xdata$x:00007E90 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007E90                 assume cs:_xdata$x
.xdata$x:00007E90                 ;org 7E90h
.xdata$x:00007E90 ; COMDAT (pick associative to section at 401C)
.xdata$x:00007E90 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00007E90                                         ; DATA XREF: .xdata$x:00007EA0o
.xdata$x:00007E91                 db 0FFh
.xdata$x:00007E92                 db 0FFh
.xdata$x:00007E93                 db 0FFh
.xdata$x:00007E94                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00007E98 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00007E98                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00007E99                 db    5
.xdata$x:00007E9A                 db  93h ; ô
.xdata$x:00007E9B                 db  19h
.xdata$x:00007E9C                 db    1
.xdata$x:00007E9D                 db    0
.xdata$x:00007E9E                 db    0
.xdata$x:00007E9F                 db    0
.xdata$x:00007EA0                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00007EA4                 db    0
.xdata$x:00007EA5                 db    0
.xdata$x:00007EA6                 db    0
.xdata$x:00007EA7                 db    0
.xdata$x:00007EA8                 db    0
.xdata$x:00007EA9                 db    0
.xdata$x:00007EAA                 db    0
.xdata$x:00007EAB                 db    0
.xdata$x:00007EAC                 db    0
.xdata$x:00007EAD                 db    0
.xdata$x:00007EAE                 db    0
.xdata$x:00007EAF                 db    0
.xdata$x:00007EB0                 db    0
.xdata$x:00007EB1                 db    0
.xdata$x:00007EB2                 db    0
.xdata$x:00007EB3                 db    0
.xdata$x:00007EB4                 db    0
.xdata$x:00007EB5                 db    0
.xdata$x:00007EB6                 db    0
.xdata$x:00007EB7                 db    0
.xdata$x:00007EB8                 db    0
.xdata$x:00007EB9                 db    0
.xdata$x:00007EBA                 db    0
.xdata$x:00007EBB                 db    0
.xdata$x:00007EBB _xdata$x        ends
.xdata$x:00007EBB
.xdata$x:00007EBC ; ===========================================================================
.xdata$x:00007EBC
.xdata$x:00007EBC ; Segment type: Pure data
.xdata$x:00007EBC ; Segment permissions: Read
.xdata$x:00007EBC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007EBC                 assume cs:_xdata$x
.xdata$x:00007EBC                 ;org 7EBCh
.xdata$x:00007EBC ; COMDAT (pick associative to section at 2FF4)
.xdata$x:00007EBC __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00007EBC                                         ; DATA XREF: .xdata$x:00007ECCo
.xdata$x:00007EBD                 db 0FFh
.xdata$x:00007EBE                 db 0FFh
.xdata$x:00007EBF                 db 0FFh
.xdata$x:00007EC0                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00007EC4 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00007EC4                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00007EC5                 db    5
.xdata$x:00007EC6                 db  93h ; ô
.xdata$x:00007EC7                 db  19h
.xdata$x:00007EC8                 db    1
.xdata$x:00007EC9                 db    0
.xdata$x:00007ECA                 db    0
.xdata$x:00007ECB                 db    0
.xdata$x:00007ECC                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00007ED0                 db    0
.xdata$x:00007ED1                 db    0
.xdata$x:00007ED2                 db    0
.xdata$x:00007ED3                 db    0
.xdata$x:00007ED4                 db    0
.xdata$x:00007ED5                 db    0
.xdata$x:00007ED6                 db    0
.xdata$x:00007ED7                 db    0
.xdata$x:00007ED8                 db    0
.xdata$x:00007ED9                 db    0
.xdata$x:00007EDA                 db    0
.xdata$x:00007EDB                 db    0
.xdata$x:00007EDC                 db    0
.xdata$x:00007EDD                 db    0
.xdata$x:00007EDE                 db    0
.xdata$x:00007EDF                 db    0
.xdata$x:00007EE0                 db    0
.xdata$x:00007EE1                 db    0
.xdata$x:00007EE2                 db    0
.xdata$x:00007EE3                 db    0
.xdata$x:00007EE4                 db    0
.xdata$x:00007EE5                 db    0
.xdata$x:00007EE6                 db    0
.xdata$x:00007EE7                 db    0
.xdata$x:00007EE7 _xdata$x        ends
.xdata$x:00007EE7
.xdata$x:00007EE8 ; ===========================================================================
.xdata$x:00007EE8
.xdata$x:00007EE8 ; Segment type: Pure data
.xdata$x:00007EE8 ; Segment permissions: Read
.xdata$x:00007EE8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007EE8                 assume cs:_xdata$x
.xdata$x:00007EE8                 ;org 7EE8h
.xdata$x:00007EE8 ; COMDAT (pick associative to section at 3C5C)
.xdata$x:00007EE8 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00007EE8                                         ; DATA XREF: .xdata$x:00007EF8o
.xdata$x:00007EE9                 db 0FFh
.xdata$x:00007EEA                 db 0FFh
.xdata$x:00007EEB                 db 0FFh
.xdata$x:00007EEC                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00007EF0 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00007EF0                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00007EF1                 db    5
.xdata$x:00007EF2                 db  93h ; ô
.xdata$x:00007EF3                 db  19h
.xdata$x:00007EF4                 db    1
.xdata$x:00007EF5                 db    0
.xdata$x:00007EF6                 db    0
.xdata$x:00007EF7                 db    0
.xdata$x:00007EF8                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00007EFC                 db    0
.xdata$x:00007EFD                 db    0
.xdata$x:00007EFE                 db    0
.xdata$x:00007EFF                 db    0
.xdata$x:00007F00                 db    0
.xdata$x:00007F01                 db    0
.xdata$x:00007F02                 db    0
.xdata$x:00007F03                 db    0
.xdata$x:00007F04                 db    0
.xdata$x:00007F05                 db    0
.xdata$x:00007F06                 db    0
.xdata$x:00007F07                 db    0
.xdata$x:00007F08                 db    0
.xdata$x:00007F09                 db    0
.xdata$x:00007F0A                 db    0
.xdata$x:00007F0B                 db    0
.xdata$x:00007F0C                 db    0
.xdata$x:00007F0D                 db    0
.xdata$x:00007F0E                 db    0
.xdata$x:00007F0F                 db    0
.xdata$x:00007F10                 db    0
.xdata$x:00007F11                 db    0
.xdata$x:00007F12                 db    0
.xdata$x:00007F13                 db    0
.xdata$x:00007F13 _xdata$x        ends
.xdata$x:00007F13
.xdata$x:00007F14 ; ===========================================================================
.xdata$x:00007F14
.xdata$x:00007F14 ; Segment type: Pure data
.xdata$x:00007F14 ; Segment permissions: Read
.xdata$x:00007F14 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007F14                 assume cs:_xdata$x
.xdata$x:00007F14                 ;org 7F14h
.xdata$x:00007F14 ; COMDAT (pick associative to section at 2EF0)
.xdata$x:00007F14 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:00007F14                                         ; DATA XREF: .xdata$x:00007F24o
.xdata$x:00007F15                 db 0FFh
.xdata$x:00007F16                 db 0FFh
.xdata$x:00007F17                 db 0FFh
.xdata$x:00007F18                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:00007F1C __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:00007F1C                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:00007F1D                 db    5
.xdata$x:00007F1E                 db  93h ; ô
.xdata$x:00007F1F                 db  19h
.xdata$x:00007F20                 db    1
.xdata$x:00007F21                 db    0
.xdata$x:00007F22                 db    0
.xdata$x:00007F23                 db    0
.xdata$x:00007F24                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:00007F28                 align 20h
.xdata$x:00007F28 _xdata$x        ends
.xdata$x:00007F28
.xdata$x:00007F40 ; ===========================================================================
.xdata$x:00007F40
.xdata$x:00007F40 ; Segment type: Pure data
.xdata$x:00007F40 ; Segment permissions: Read
.xdata$x:00007F40 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007F40                 assume cs:_xdata$x
.xdata$x:00007F40                 ;org 7F40h
.xdata$x:00007F40 ; COMDAT (pick associative to section at 3B74)
.xdata$x:00007F40 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00007F40                                         ; DATA XREF: .xdata$x:00007F50o
.xdata$x:00007F41                 db 0FFh
.xdata$x:00007F42                 db 0FFh
.xdata$x:00007F43                 db 0FFh
.xdata$x:00007F44                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00007F48 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00007F48                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00007F49                 db    5
.xdata$x:00007F4A                 db  93h ; ô
.xdata$x:00007F4B                 db  19h
.xdata$x:00007F4C                 db    1
.xdata$x:00007F4D                 db    0
.xdata$x:00007F4E                 db    0
.xdata$x:00007F4F                 db    0
.xdata$x:00007F50                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:00007F54                 db    0
.xdata$x:00007F55                 db    0
.xdata$x:00007F56                 db    0
.xdata$x:00007F57                 db    0
.xdata$x:00007F58                 db    0
.xdata$x:00007F59                 db    0
.xdata$x:00007F5A                 db    0
.xdata$x:00007F5B                 db    0
.xdata$x:00007F5C                 db    0
.xdata$x:00007F5D                 db    0
.xdata$x:00007F5E                 db    0
.xdata$x:00007F5F                 db    0
.xdata$x:00007F60                 db    0
.xdata$x:00007F61                 db    0
.xdata$x:00007F62                 db    0
.xdata$x:00007F63                 db    0
.xdata$x:00007F64                 db    0
.xdata$x:00007F65                 db    0
.xdata$x:00007F66                 db    0
.xdata$x:00007F67                 db    0
.xdata$x:00007F68                 db    0
.xdata$x:00007F69                 db    0
.xdata$x:00007F6A                 db    0
.xdata$x:00007F6B                 db    0
.xdata$x:00007F6B _xdata$x        ends
.xdata$x:00007F6B
.xdata$x:00007F6C ; ===========================================================================
.xdata$x:00007F6C
.xdata$x:00007F6C ; Segment type: Pure data
.xdata$x:00007F6C ; Segment permissions: Read
.xdata$x:00007F6C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007F6C                 assume cs:_xdata$x
.xdata$x:00007F6C                 ;org 7F6Ch
.xdata$x:00007F6C ; COMDAT (pick associative to section at 341C)
.xdata$x:00007F6C __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00007F6C                                         ; DATA XREF: .xdata$x:00007F7Co
.xdata$x:00007F6D                 db 0FFh
.xdata$x:00007F6E                 db 0FFh
.xdata$x:00007F6F                 db 0FFh
.xdata$x:00007F70                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0
.xdata$x:00007F74 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00007F74                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z+11o
.xdata$x:00007F75                 db    5
.xdata$x:00007F76                 db  93h ; ô
.xdata$x:00007F77                 db  19h
.xdata$x:00007F78                 db    1
.xdata$x:00007F79                 db    0
.xdata$x:00007F7A                 db    0
.xdata$x:00007F7B                 db    0
.xdata$x:00007F7C                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.xdata$x:00007F80                 db    0
.xdata$x:00007F81                 db    0
.xdata$x:00007F82                 db    0
.xdata$x:00007F83                 db    0
.xdata$x:00007F84                 db    0
.xdata$x:00007F85                 db    0
.xdata$x:00007F86                 db    0
.xdata$x:00007F87                 db    0
.xdata$x:00007F88                 db    0
.xdata$x:00007F89                 db    0
.xdata$x:00007F8A                 db    0
.xdata$x:00007F8B                 db    0
.xdata$x:00007F8C                 db    0
.xdata$x:00007F8D                 db    0
.xdata$x:00007F8E                 db    0
.xdata$x:00007F8F                 db    0
.xdata$x:00007F90                 db    0
.xdata$x:00007F91                 db    0
.xdata$x:00007F92                 db    0
.xdata$x:00007F93                 db    0
.xdata$x:00007F94                 db    0
.xdata$x:00007F95                 db    0
.xdata$x:00007F96                 db    0
.xdata$x:00007F97                 db    0
.xdata$x:00007F97 _xdata$x        ends
.xdata$x:00007F97
.xdata$x:00007F98 ; ===========================================================================
.xdata$x:00007F98
.xdata$x:00007F98 ; Segment type: Pure data
.xdata$x:00007F98 ; Segment permissions: Read
.xdata$x:00007F98 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007F98                 assume cs:_xdata$x
.xdata$x:00007F98                 ;org 7F98h
.xdata$x:00007F98 ; COMDAT (pick associative to section at 3564)
.xdata$x:00007F98 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:00007F98                                         ; DATA XREF: .xdata$x:00007FA8o
.xdata$x:00007F99                 db 0FFh
.xdata$x:00007F9A                 db 0FFh
.xdata$x:00007F9B                 db 0FFh
.xdata$x:00007F9C                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:00007FA0 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00007FA0                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:00007FA1                 db    5
.xdata$x:00007FA2                 db  93h ; ô
.xdata$x:00007FA3                 db  19h
.xdata$x:00007FA4                 db    1
.xdata$x:00007FA5                 db    0
.xdata$x:00007FA6                 db    0
.xdata$x:00007FA7                 db    0
.xdata$x:00007FA8                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00007FAC                 db    0
.xdata$x:00007FAD                 db    0
.xdata$x:00007FAE                 db    0
.xdata$x:00007FAF                 db    0
.xdata$x:00007FB0                 db    0
.xdata$x:00007FB1                 db    0
.xdata$x:00007FB2                 db    0
.xdata$x:00007FB3                 db    0
.xdata$x:00007FB4                 db    0
.xdata$x:00007FB5                 db    0
.xdata$x:00007FB6                 db    0
.xdata$x:00007FB7                 db    0
.xdata$x:00007FB8                 db    0
.xdata$x:00007FB9                 db    0
.xdata$x:00007FBA                 db    0
.xdata$x:00007FBB                 db    0
.xdata$x:00007FBC                 db    0
.xdata$x:00007FBD                 db    0
.xdata$x:00007FBE                 db    0
.xdata$x:00007FBF                 db    0
.xdata$x:00007FC0                 db    0
.xdata$x:00007FC1                 db    0
.xdata$x:00007FC2                 db    0
.xdata$x:00007FC3                 db    0
.xdata$x:00007FC3 _xdata$x        ends
.xdata$x:00007FC3
.xdata$x:00007FC4 ; ===========================================================================
.xdata$x:00007FC4
.xdata$x:00007FC4 ; Segment type: Pure data
.xdata$x:00007FC4 ; Segment permissions: Read
.xdata$x:00007FC4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007FC4                 assume cs:_xdata$x
.xdata$x:00007FC4                 ;org 7FC4h
.xdata$x:00007FC4 ; COMDAT (pick associative to section at 34CC)
.xdata$x:00007FC4 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:00007FC4                                         ; DATA XREF: .xdata$x:00007FD4o
.xdata$x:00007FC5                 db 0FFh
.xdata$x:00007FC6                 db 0FFh
.xdata$x:00007FC7                 db 0FFh
.xdata$x:00007FC8                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:00007FCC __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:00007FCC                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:00007FCD                 db    5
.xdata$x:00007FCE                 db  93h ; ô
.xdata$x:00007FCF                 db  19h
.xdata$x:00007FD0                 db    1
.xdata$x:00007FD1                 db    0
.xdata$x:00007FD2                 db    0
.xdata$x:00007FD3                 db    0
.xdata$x:00007FD4                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:00007FD8                 db    0
.xdata$x:00007FD9                 db    0
.xdata$x:00007FDA                 db    0
.xdata$x:00007FDB                 db    0
.xdata$x:00007FDC                 db    0
.xdata$x:00007FDD                 db    0
.xdata$x:00007FDE                 db    0
.xdata$x:00007FDF                 db    0
.xdata$x:00007FE0                 db    0
.xdata$x:00007FE1                 db    0
.xdata$x:00007FE2                 db    0
.xdata$x:00007FE3                 db    0
.xdata$x:00007FE4                 db    0
.xdata$x:00007FE5                 db    0
.xdata$x:00007FE6                 db    0
.xdata$x:00007FE7                 db    0
.xdata$x:00007FE8                 db    0
.xdata$x:00007FE9                 db    0
.xdata$x:00007FEA                 db    0
.xdata$x:00007FEB                 db    0
.xdata$x:00007FEC                 db    0
.xdata$x:00007FED                 db    0
.xdata$x:00007FEE                 db    0
.xdata$x:00007FEF                 db    0
.xdata$x:00007FEF _xdata$x        ends
.xdata$x:00007FEF
.xdata$x:00007FF0 ; ===========================================================================
.xdata$x:00007FF0
.xdata$x:00007FF0 ; Segment type: Pure data
.xdata$x:00007FF0 ; Segment permissions: Read
.xdata$x:00007FF0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007FF0                 assume cs:_xdata$x
.xdata$x:00007FF0                 ;org 7FF0h
.xdata$x:00007FF0 ; COMDAT (pick associative to section at 3E28)
.xdata$x:00007FF0 __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:00007FF0                                         ; DATA XREF: .xdata$x:00008000o
.xdata$x:00007FF1                 db 0FFh
.xdata$x:00007FF2                 db 0FFh
.xdata$x:00007FF3                 db 0FFh
.xdata$x:00007FF4                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:00007FF8 __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00007FF8                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:00007FF9                 db    5
.xdata$x:00007FFA                 db  93h ; ô
.xdata$x:00007FFB                 db  19h
.xdata$x:00007FFC                 db    1
.xdata$x:00007FFD                 db    0
.xdata$x:00007FFE                 db    0
.xdata$x:00007FFF                 db    0
.xdata$x:00008000                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00008004                 db    0
.xdata$x:00008005                 db    0
.xdata$x:00008006                 db    0
.xdata$x:00008007                 db    0
.xdata$x:00008008                 db    0
.xdata$x:00008009                 db    0
.xdata$x:0000800A                 db    0
.xdata$x:0000800B                 db    0
.xdata$x:0000800C                 db    0
.xdata$x:0000800D                 db    0
.xdata$x:0000800E                 db    0
.xdata$x:0000800F                 db    0
.xdata$x:00008010                 db    0
.xdata$x:00008011                 db    0
.xdata$x:00008012                 db    0
.xdata$x:00008013                 db    0
.xdata$x:00008014                 db    0
.xdata$x:00008015                 db    0
.xdata$x:00008016                 db    0
.xdata$x:00008017                 db    0
.xdata$x:00008018                 db    0
.xdata$x:00008019                 db    0
.xdata$x:0000801A                 db    0
.xdata$x:0000801B                 db    0
.xdata$x:0000801B _xdata$x        ends
.xdata$x:0000801B
.xdata$x:0000801C ; ===========================================================================
.xdata$x:0000801C
.xdata$x:0000801C ; Segment type: Pure data
.xdata$x:0000801C ; Segment permissions: Read
.xdata$x:0000801C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000801C                 assume cs:_xdata$x
.xdata$x:0000801C                 ;org 801Ch
.xdata$x:0000801C ; COMDAT (pick associative to section at 4BDC)
.xdata$x:0000801C __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000801C                                         ; DATA XREF: .xdata$x:000080A4o
.xdata$x:0000801D                 db    0
.xdata$x:0000801E                 db    0
.xdata$x:0000801F                 db    0
.xdata$x:00008020                 db    0
.xdata$x:00008021                 db    0
.xdata$x:00008022                 db    0
.xdata$x:00008023                 db    0
.xdata$x:00008024                 db    0
.xdata$x:00008025                 db    0
.xdata$x:00008026                 db    0
.xdata$x:00008027                 db    0
.xdata$x:00008028                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:0000802C __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:0000802C                                         ; DATA XREF: .xdata$x:00008090o
.xdata$x:0000802D                 db    0
.xdata$x:0000802E                 db    0
.xdata$x:0000802F                 db    0
.xdata$x:00008030                 db    0
.xdata$x:00008031                 db    0
.xdata$x:00008032                 db    0
.xdata$x:00008033                 db    0
.xdata$x:00008034                 db    0
.xdata$x:00008035                 db    0
.xdata$x:00008036                 db    0
.xdata$x:00008037                 db    0
.xdata$x:00008038                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:0000803C __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:0000803C                                         ; DATA XREF: .xdata$x:00008064o
.xdata$x:0000803D                 db 0FFh
.xdata$x:0000803E                 db 0FFh
.xdata$x:0000803F                 db 0FFh
.xdata$x:00008040                 db    0
.xdata$x:00008041                 db    0
.xdata$x:00008042                 db    0
.xdata$x:00008043                 db    0
.xdata$x:00008044                 db 0FFh
.xdata$x:00008045                 db 0FFh
.xdata$x:00008046                 db 0FFh
.xdata$x:00008047                 db 0FFh
.xdata$x:00008048                 db    0
.xdata$x:00008049                 db    0
.xdata$x:0000804A                 db    0
.xdata$x:0000804B                 db    0
.xdata$x:0000804C                 db    1
.xdata$x:0000804D                 db    0
.xdata$x:0000804E                 db    0
.xdata$x:0000804F                 db    0
.xdata$x:00008050                 db    0
.xdata$x:00008051                 db    0
.xdata$x:00008052                 db    0
.xdata$x:00008053                 db    0
.xdata$x:00008054                 db    1
.xdata$x:00008055                 db    0
.xdata$x:00008056                 db    0
.xdata$x:00008057                 db    0
.xdata$x:00008058                 db    0
.xdata$x:00008059                 db    0
.xdata$x:0000805A                 db    0
.xdata$x:0000805B                 db    0
.xdata$x:0000805C __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:0000805C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:0000805D                 db    5
.xdata$x:0000805E                 db  93h ; ô
.xdata$x:0000805F                 db  19h
.xdata$x:00008060                 db    4
.xdata$x:00008061                 db    0
.xdata$x:00008062                 db    0
.xdata$x:00008063                 db    0
.xdata$x:00008064                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00008068                 db    2
.xdata$x:00008069                 db    0
.xdata$x:0000806A                 db    0
.xdata$x:0000806B                 db    0
.xdata$x:0000806C                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00008070                 align 20h
.xdata$x:00008080 __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:00008080                                         ; DATA XREF: .xdata$x:0000806Co
.xdata$x:00008081                 db    0
.xdata$x:00008082                 db    0
.xdata$x:00008083                 db    0
.xdata$x:00008084                 db    2
.xdata$x:00008085                 db    0
.xdata$x:00008086                 db    0
.xdata$x:00008087                 db    0
.xdata$x:00008088                 db    3
.xdata$x:00008089                 db    0
.xdata$x:0000808A                 db    0
.xdata$x:0000808B                 db    0
.xdata$x:0000808C                 db    1
.xdata$x:0000808D                 db    0
.xdata$x:0000808E                 db    0
.xdata$x:0000808F                 db    0
.xdata$x:00008090                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:00008094                 db    0
.xdata$x:00008095                 db    0
.xdata$x:00008096                 db    0
.xdata$x:00008097                 db    0
.xdata$x:00008098                 db    0
.xdata$x:00008099                 db    0
.xdata$x:0000809A                 db    0
.xdata$x:0000809B                 db    0
.xdata$x:0000809C                 db    3
.xdata$x:0000809D                 db    0
.xdata$x:0000809E                 db    0
.xdata$x:0000809F                 db    0
.xdata$x:000080A0                 db    1
.xdata$x:000080A1                 db    0
.xdata$x:000080A2                 db    0
.xdata$x:000080A3                 db    0
.xdata$x:000080A4                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:000080A4 _xdata$x        ends
.xdata$x:000080A4
.xdata$x:000080A8 ; ===========================================================================
.xdata$x:000080A8
.xdata$x:000080A8 ; Segment type: Pure data
.xdata$x:000080A8 ; Segment permissions: Read
.xdata$x:000080A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000080A8                 assume cs:_xdata$x
.xdata$x:000080A8                 ;org 80A8h
.xdata$x:000080A8 ; COMDAT (pick associative to section at 38C8)
.xdata$x:000080A8 __unwindtable$??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z db 0FFh
.xdata$x:000080A8                                         ; DATA XREF: .xdata$x:000080C0o
.xdata$x:000080A9                 db 0FFh
.xdata$x:000080AA                 db 0FFh
.xdata$x:000080AB                 db 0FFh
.xdata$x:000080AC                 dd offset __unwindfunclet$??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$0
.xdata$x:000080B0                 db    0
.xdata$x:000080B1                 db    0
.xdata$x:000080B2                 db    0
.xdata$x:000080B3                 db    0
.xdata$x:000080B4                 dd offset __unwindfunclet$??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z$1
.xdata$x:000080B8 __ehfuncinfo$??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z db  22h ; "
.xdata$x:000080B8                                         ; DATA XREF: __ehhandler$??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z+11o
.xdata$x:000080B9                 db    5
.xdata$x:000080BA                 db  93h ; ô
.xdata$x:000080BB                 db  19h
.xdata$x:000080BC                 db    2
.xdata$x:000080BD                 db    0
.xdata$x:000080BE                 db    0
.xdata$x:000080BF                 db    0
.xdata$x:000080C0                 dd offset __unwindtable$??0iconLocator@@QAE@HHV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
.xdata$x:000080C4                 db    0
.xdata$x:000080C5                 db    0
.xdata$x:000080C6                 db    0
.xdata$x:000080C7                 db    0
.xdata$x:000080C8                 db    0
.xdata$x:000080C9                 db    0
.xdata$x:000080CA                 db    0
.xdata$x:000080CB                 db    0
.xdata$x:000080CC                 db    0
.xdata$x:000080CD                 db    0
.xdata$x:000080CE                 db    0
.xdata$x:000080CF                 db    0
.xdata$x:000080D0                 db    0
.xdata$x:000080D1                 db    0
.xdata$x:000080D2                 db    0
.xdata$x:000080D3                 db    0
.xdata$x:000080D4                 db    0
.xdata$x:000080D5                 db    0
.xdata$x:000080D6                 db    0
.xdata$x:000080D7                 db    0
.xdata$x:000080D8                 db    0
.xdata$x:000080D9                 db    0
.xdata$x:000080DA                 db    0
.xdata$x:000080DB                 db    0
.xdata$x:000080DB _xdata$x        ends
.xdata$x:000080DB
.xdata$x:000080DC ; ===========================================================================
.xdata$x:000080DC
.xdata$x:000080DC ; Segment type: Pure data
.xdata$x:000080DC ; Segment permissions: Read
.xdata$x:000080DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000080DC                 assume cs:_xdata$x
.xdata$x:000080DC                 ;org 80DCh
.xdata$x:000080DC ; COMDAT (pick associative to section at 40A0)
.xdata$x:000080DC __unwindtable$??1iconLocator@@QAE@XZ db 0FFh
.xdata$x:000080DC                                         ; DATA XREF: .xdata$x:000080ECo
.xdata$x:000080DD                 db 0FFh
.xdata$x:000080DE                 db 0FFh
.xdata$x:000080DF                 db 0FFh
.xdata$x:000080E0                 dd offset __unwindfunclet$??1iconLocator@@QAE@XZ$0
.xdata$x:000080E4 __ehfuncinfo$??1iconLocator@@QAE@XZ db  22h ; "
.xdata$x:000080E4                                         ; DATA XREF: __ehhandler$??1iconLocator@@QAE@XZ+11o
.xdata$x:000080E5                 db    5
.xdata$x:000080E6                 db  93h ; ô
.xdata$x:000080E7                 db  19h
.xdata$x:000080E8                 db    1
.xdata$x:000080E9                 db    0
.xdata$x:000080EA                 db    0
.xdata$x:000080EB                 db    0
.xdata$x:000080EC                 dd offset __unwindtable$??1iconLocator@@QAE@XZ
.xdata$x:000080F0                 db    0
.xdata$x:000080F1                 db    0
.xdata$x:000080F2                 db    0
.xdata$x:000080F3                 db    0
.xdata$x:000080F4                 db    0
.xdata$x:000080F5                 db    0
.xdata$x:000080F6                 db    0
.xdata$x:000080F7                 db    0
.xdata$x:000080F8                 db    0
.xdata$x:000080F9                 db    0
.xdata$x:000080FA                 db    0
.xdata$x:000080FB                 db    0
.xdata$x:000080FC                 db    0
.xdata$x:000080FD                 db    0
.xdata$x:000080FE                 db    0
.xdata$x:000080FF                 db    0
.xdata$x:00008100                 db    0
.xdata$x:00008101                 db    0
.xdata$x:00008102                 db    0
.xdata$x:00008103                 db    0
.xdata$x:00008104                 db    0
.xdata$x:00008105                 db    0
.xdata$x:00008106                 db    0
.xdata$x:00008107                 db    0
.xdata$x:00008107 _xdata$x        ends
.xdata$x:00008107
.xdata$x:00008108 ; ===========================================================================
.xdata$x:00008108
.xdata$x:00008108 ; Segment type: Pure data
.xdata$x:00008108 ; Segment permissions: Read
.xdata$x:00008108 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008108                 assume cs:_xdata$x
.xdata$x:00008108                 ;org 8108h
.xdata$x:00008108 ; COMDAT (pick associative to section at 3830)
.xdata$x:00008108 __unwindtable$??0iconLocator@@QAE@ABU0@@Z db 0FFh
.xdata$x:00008108                                         ; DATA XREF: .xdata$x:00008118o
.xdata$x:00008109                 db 0FFh
.xdata$x:0000810A                 db 0FFh
.xdata$x:0000810B                 db 0FFh
.xdata$x:0000810C                 dd offset __unwindfunclet$??0iconLocator@@QAE@ABU0@@Z$0
.xdata$x:00008110 __ehfuncinfo$??0iconLocator@@QAE@ABU0@@Z db  22h ; "
.xdata$x:00008110                                         ; DATA XREF: __ehhandler$??0iconLocator@@QAE@ABU0@@Z+11o
.xdata$x:00008111                 db    5
.xdata$x:00008112                 db  93h ; ô
.xdata$x:00008113                 db  19h
.xdata$x:00008114                 db    1
.xdata$x:00008115                 db    0
.xdata$x:00008116                 db    0
.xdata$x:00008117                 db    0
.xdata$x:00008118                 dd offset __unwindtable$??0iconLocator@@QAE@ABU0@@Z
.xdata$x:0000811C                 db    0
.xdata$x:0000811D                 db    0
.xdata$x:0000811E                 db    0
.xdata$x:0000811F                 db    0
.xdata$x:00008120                 db    0
.xdata$x:00008121                 db    0
.xdata$x:00008122                 db    0
.xdata$x:00008123                 db    0
.xdata$x:00008124                 db    0
.xdata$x:00008125                 db    0
.xdata$x:00008126                 db    0
.xdata$x:00008127                 db    0
.xdata$x:00008128                 db    0
.xdata$x:00008129                 db    0
.xdata$x:0000812A                 db    0
.xdata$x:0000812B                 db    0
.xdata$x:0000812C                 db    0
.xdata$x:0000812D                 db    0
.xdata$x:0000812E                 db    0
.xdata$x:0000812F                 db    0
.xdata$x:00008130                 db    0
.xdata$x:00008131                 db    0
.xdata$x:00008132                 db    0
.xdata$x:00008133                 db    0
.xdata$x:00008133 _xdata$x        ends
.xdata$x:00008133
.xdata$x:00008134 ; ===========================================================================
.xdata$x:00008134
.xdata$x:00008134 ; Segment type: Pure data
.xdata$x:00008134 ; Segment permissions: Read
.xdata$x:00008134 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008134                 assume cs:_xdata$x
.xdata$x:00008134                 ;org 8134h
.xdata$x:00008134 __unwindtable$?doPopop@ToolBar@@QAEXUtagPOINT@@@Z db 0FFh
.xdata$x:00008134                                         ; DATA XREF: .xdata$x:00008180o
.xdata$x:00008135                 db 0FFh
.xdata$x:00008136                 db 0FFh
.xdata$x:00008137                 db 0FFh
.xdata$x:00008138                 dd offset __unwindfunclet$?doPopop@ToolBar@@QAEXUtagPOINT@@@Z$0
.xdata$x:0000813C __unwindtable$?releaseID@ReBar@@AAEXH@Z db 0FFh
.xdata$x:0000813C                                         ; DATA XREF: .xdata$x:0000815Co
.xdata$x:0000813D                 db 0FFh
.xdata$x:0000813E                 db 0FFh
.xdata$x:0000813F                 db 0FFh
.xdata$x:00008140                 dd offset __unwindfunclet$?releaseID@ReBar@@AAEXH@Z$0
.xdata$x:00008144                 align 8
.xdata$x:00008148                 dd offset __unwindfunclet$?releaseID@ReBar@@AAEXH@Z$1
.xdata$x:0000814C                 db    1
.xdata$x:0000814D                 db    0
.xdata$x:0000814E                 db    0
.xdata$x:0000814F                 db    0
.xdata$x:00008150                 dd offset __unwindfunclet$?releaseID@ReBar@@AAEXH@Z$2
.xdata$x:00008154 __ehfuncinfo$?releaseID@ReBar@@AAEXH@Z db  22h ; "
.xdata$x:00008154                                         ; DATA XREF: __ehhandler$?releaseID@ReBar@@AAEXH@Z+11o
.xdata$x:00008155                 db    5
.xdata$x:00008156                 db  93h ; ô
.xdata$x:00008157                 db  19h
.xdata$x:00008158                 db    3
.xdata$x:00008159                 db    0
.xdata$x:0000815A                 db    0
.xdata$x:0000815B                 db    0
.xdata$x:0000815C                 dd offset __unwindtable$?releaseID@ReBar@@AAEXH@Z
.xdata$x:00008160                 db    0
.xdata$x:00008161                 db    0
.xdata$x:00008162                 db    0
.xdata$x:00008163                 db    0
.xdata$x:00008164                 db    0
.xdata$x:00008165                 db    0
.xdata$x:00008166                 db    0
.xdata$x:00008167                 db    0
.xdata$x:00008168                 db    0
.xdata$x:00008169                 db    0
.xdata$x:0000816A                 db    0
.xdata$x:0000816B                 db    0
.xdata$x:0000816C                 db    0
.xdata$x:0000816D                 db    0
.xdata$x:0000816E                 db    0
.xdata$x:0000816F                 db    0
.xdata$x:00008170                 db    0
.xdata$x:00008171                 db    0
.xdata$x:00008172                 db    0
.xdata$x:00008173                 db    0
.xdata$x:00008174                 db    0
.xdata$x:00008175                 db    0
.xdata$x:00008176                 db    0
.xdata$x:00008177                 db    0
.xdata$x:00008178 __ehfuncinfo$?doPopop@ToolBar@@QAEXUtagPOINT@@@Z db  22h ; "
.xdata$x:00008178                                         ; DATA XREF: __ehhandler$?doPopop@ToolBar@@QAEXUtagPOINT@@@Z+1Bo
.xdata$x:00008179                 db    5
.xdata$x:0000817A                 db  93h ; ô
.xdata$x:0000817B                 db  19h
.xdata$x:0000817C                 db    1
.xdata$x:0000817D                 db    0
.xdata$x:0000817E                 db    0
.xdata$x:0000817F                 db    0
.xdata$x:00008180                 dd offset __unwindtable$?doPopop@ToolBar@@QAEXUtagPOINT@@@Z
.xdata$x:00008184                 db    0
.xdata$x:00008185                 db    0
.xdata$x:00008186                 db    0
.xdata$x:00008187                 db    0
.xdata$x:00008188                 db    0
.xdata$x:00008189                 db    0
.xdata$x:0000818A                 db    0
.xdata$x:0000818B                 db    0
.xdata$x:0000818C                 db    0
.xdata$x:0000818D                 db    0
.xdata$x:0000818E                 db    0
.xdata$x:0000818F                 db    0
.xdata$x:00008190                 db    0
.xdata$x:00008191                 db    0
.xdata$x:00008192                 db    0
.xdata$x:00008193                 db    0
.xdata$x:00008194                 db    0
.xdata$x:00008195                 db    0
.xdata$x:00008196                 db    0
.xdata$x:00008197                 db    0
.xdata$x:00008198                 db    0
.xdata$x:00008199                 db    0
.xdata$x:0000819A                 db    0
.xdata$x:0000819B                 db    0
.xdata$x:0000819C __ehfuncinfo$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z db  22h ; "
.xdata$x:0000819C                                         ; DATA XREF: __ehhandler$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z+1Eo
.xdata$x:0000819D                 db    5
.xdata$x:0000819E                 db  93h ; ô
.xdata$x:0000819F                 db  19h
.xdata$x:000081A0                 db    9
.xdata$x:000081A1                 db    0
.xdata$x:000081A2                 db    0
.xdata$x:000081A3                 db    0
.xdata$x:000081A4                 dd offset __unwindtable$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z
.xdata$x:000081A8                 align 20h
.xdata$x:000081C0 __unwindtable$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z db 0FFh
.xdata$x:000081C0                                         ; DATA XREF: .xdata$x:000081A4o
.xdata$x:000081C1                 db 0FFh
.xdata$x:000081C2                 db 0FFh
.xdata$x:000081C3                 db 0FFh
.xdata$x:000081C4                 dd offset __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$0
.xdata$x:000081C8                 db    0
.xdata$x:000081C9                 db    0
.xdata$x:000081CA                 db    0
.xdata$x:000081CB                 db    0
.xdata$x:000081CC                 dd offset __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$1
.xdata$x:000081D0                 db    0
.xdata$x:000081D1                 db    0
.xdata$x:000081D2                 db    0
.xdata$x:000081D3                 db    0
.xdata$x:000081D4                 dd offset __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$2
.xdata$x:000081D8                 db 0FFh
.xdata$x:000081D9                 db 0FFh
.xdata$x:000081DA                 db 0FFh
.xdata$x:000081DB                 db 0FFh
.xdata$x:000081DC                 dd offset __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$3
.xdata$x:000081E0                 db    3
.xdata$x:000081E1                 db    0
.xdata$x:000081E2                 db    0
.xdata$x:000081E3                 db    0
.xdata$x:000081E4                 dd offset __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$4
.xdata$x:000081E8                 db    3
.xdata$x:000081E9                 db    0
.xdata$x:000081EA                 db    0
.xdata$x:000081EB                 db    0
.xdata$x:000081EC                 dd offset __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$5
.xdata$x:000081F0                 db 0FFh
.xdata$x:000081F1                 db 0FFh
.xdata$x:000081F2                 db 0FFh
.xdata$x:000081F3                 db 0FFh
.xdata$x:000081F4                 dd offset __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$6
.xdata$x:000081F8                 db    6
.xdata$x:000081F9                 db    0
.xdata$x:000081FA                 db    0
.xdata$x:000081FB                 db    0
.xdata$x:000081FC                 dd offset __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$7
.xdata$x:00008200                 db    6
.xdata$x:00008201                 db    0
.xdata$x:00008202                 db    0
.xdata$x:00008203                 db    0
.xdata$x:00008204                 dd offset __unwindfunclet$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z$8
.xdata$x:00008204 _xdata$x        ends
.xdata$x:00008204
.xdata$x:00008208 ; ===========================================================================
.xdata$x:00008208
.xdata$x:00008208 ; Segment type: Pure data
.xdata$x:00008208 ; Segment permissions: Read
.xdata$x:00008208 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008208                 assume cs:_xdata$x
.xdata$x:00008208                 ;org 8208h
.xdata$x:00008208 ; COMDAT (pick associative to section at 5B9C)
.xdata$x:00008208 __catchsym$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:00008208                                         ; DATA XREF: .xdata$x:00008238o
.xdata$x:00008209                 db    0
.xdata$x:0000820A                 db    0
.xdata$x:0000820B                 db    0
.xdata$x:0000820C                 db    0
.xdata$x:0000820D                 db    0
.xdata$x:0000820E                 db    0
.xdata$x:0000820F                 db    0
.xdata$x:00008210                 db    0
.xdata$x:00008211                 db    0
.xdata$x:00008212                 db    0
.xdata$x:00008213                 db    0
.xdata$x:00008214                 dd offset __catch$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z$0
.xdata$x:00008218 __unwindtable$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:00008218                                         ; DATA XREF: .xdata$x:00008244o
.xdata$x:00008219                 db 0FFh
.xdata$x:0000821A                 db 0FFh
.xdata$x:0000821B                 db 0FFh
.xdata$x:0000821C                 db    0
.xdata$x:0000821D                 db    0
.xdata$x:0000821E                 db    0
.xdata$x:0000821F                 db    0
.xdata$x:00008220                 db 0FFh
.xdata$x:00008221                 db 0FFh
.xdata$x:00008222                 db 0FFh
.xdata$x:00008223                 db 0FFh
.xdata$x:00008224                 db    0
.xdata$x:00008225                 db    0
.xdata$x:00008226                 db    0
.xdata$x:00008227                 db    0
.xdata$x:00008228 __tryblocktable$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z db    0
.xdata$x:00008228                                         ; DATA XREF: .xdata$x:0000824Co
.xdata$x:00008229                 db    0
.xdata$x:0000822A                 db    0
.xdata$x:0000822B                 db    0
.xdata$x:0000822C                 db    0
.xdata$x:0000822D                 db    0
.xdata$x:0000822E                 db    0
.xdata$x:0000822F                 db    0
.xdata$x:00008230                 db    1
.xdata$x:00008231                 db    0
.xdata$x:00008232                 db    0
.xdata$x:00008233                 db    0
.xdata$x:00008234                 db    1
.xdata$x:00008235                 db    0
.xdata$x:00008236                 db    0
.xdata$x:00008237                 db    0
.xdata$x:00008238                 dd offset __catchsym$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z$2
.xdata$x:0000823C __ehfuncinfo$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000823C                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z+11o
.xdata$x:0000823D                 db    5
.xdata$x:0000823E                 db  93h ; ô
.xdata$x:0000823F                 db  19h
.xdata$x:00008240                 db    2
.xdata$x:00008241                 db    0
.xdata$x:00008242                 db    0
.xdata$x:00008243                 db    0
.xdata$x:00008244                 dd offset __unwindtable$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z
.xdata$x:00008248                 db    1
.xdata$x:00008249                 db    0
.xdata$x:0000824A                 db    0
.xdata$x:0000824B                 db    0
.xdata$x:0000824C                 dd offset __tryblocktable$?_Reallocate@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IAEXI@Z
.xdata$x:00008250                 align 20h
.xdata$x:00008250 _xdata$x        ends
.xdata$x:00008250
.xdata$x:00008260 ; ===========================================================================
.xdata$x:00008260
.xdata$x:00008260 ; Segment type: Pure data
.xdata$x:00008260 ; Segment permissions: Read
.xdata$x:00008260 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008260                 assume cs:_xdata$x
.xdata$x:00008260                 ;org 8260h
.xdata$x:00008260 ; COMDAT (pick associative to section at 5808)
.xdata$x:00008260 __unwindtable$?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z db 0FFh
.xdata$x:00008260                                         ; DATA XREF: .xdata$x:00008270o
.xdata$x:00008261                 db 0FFh
.xdata$x:00008262                 db 0FFh
.xdata$x:00008263                 db 0FFh
.xdata$x:00008264                 dd offset __unwindfunclet$?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z$0
.xdata$x:00008268 __ehfuncinfo$?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z db  22h ; "
.xdata$x:00008268                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z+11o
.xdata$x:00008269                 db    5
.xdata$x:0000826A                 db  93h ; ô
.xdata$x:0000826B                 db  19h
.xdata$x:0000826C                 db    1
.xdata$x:0000826D                 db    0
.xdata$x:0000826E                 db    0
.xdata$x:0000826F                 db    0
.xdata$x:00008270                 dd offset __unwindtable$?_Orphan_range@?$vector@UtDynamicList@@V?$allocator@UtDynamicList@@@std@@@std@@IBEXPAUtDynamicList@@0@Z
.xdata$x:00008274                 db    0
.xdata$x:00008275                 db    0
.xdata$x:00008276                 db    0
.xdata$x:00008277                 db    0
.xdata$x:00008278                 db    0
.xdata$x:00008279                 db    0
.xdata$x:0000827A                 db    0
.xdata$x:0000827B                 db    0
.xdata$x:0000827C                 db    0
.xdata$x:0000827D                 db    0
.xdata$x:0000827E                 db    0
.xdata$x:0000827F                 db    0
.xdata$x:00008280                 db    0
.xdata$x:00008281                 db    0
.xdata$x:00008282                 db    0
.xdata$x:00008283                 db    0
.xdata$x:00008284                 db    0
.xdata$x:00008285                 db    0
.xdata$x:00008286                 db    0
.xdata$x:00008287                 db    0
.xdata$x:00008288                 db    0
.xdata$x:00008289                 db    0
.xdata$x:0000828A                 db    0
.xdata$x:0000828B                 db    0
.xdata$x:0000828B _xdata$x        ends
.xdata$x:0000828B
.xdata$x:0000828C ; ===========================================================================
.xdata$x:0000828C
.xdata$x:0000828C ; Segment type: Pure data
.xdata$x:0000828C ; Segment permissions: Read
.xdata$x:0000828C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000828C                 assume cs:_xdata$x
.xdata$x:0000828C                 ;org 828Ch
.xdata$x:0000828C ; COMDAT (pick associative to section at 5A40)
.xdata$x:0000828C __catchsym$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:0000828C                                         ; DATA XREF: .xdata$x:000082BCo
.xdata$x:0000828D                 db    0
.xdata$x:0000828E                 db    0
.xdata$x:0000828F                 db    0
.xdata$x:00008290                 db    0
.xdata$x:00008291                 db    0
.xdata$x:00008292                 db    0
.xdata$x:00008293                 db    0
.xdata$x:00008294                 db    0
.xdata$x:00008295                 db    0
.xdata$x:00008296                 db    0
.xdata$x:00008297                 db    0
.xdata$x:00008298                 dd offset __catch$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z$0
.xdata$x:0000829C __unwindtable$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:0000829C                                         ; DATA XREF: .xdata$x:000082C8o
.xdata$x:0000829D                 db 0FFh
.xdata$x:0000829E                 db 0FFh
.xdata$x:0000829F                 db 0FFh
.xdata$x:000082A0                 db    0
.xdata$x:000082A1                 db    0
.xdata$x:000082A2                 db    0
.xdata$x:000082A3                 db    0
.xdata$x:000082A4                 db 0FFh
.xdata$x:000082A5                 db 0FFh
.xdata$x:000082A6                 db 0FFh
.xdata$x:000082A7                 db 0FFh
.xdata$x:000082A8                 db    0
.xdata$x:000082A9                 db    0
.xdata$x:000082AA                 db    0
.xdata$x:000082AB                 db    0
.xdata$x:000082AC __tryblocktable$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z db    0
.xdata$x:000082AC                                         ; DATA XREF: .xdata$x:000082D0o
.xdata$x:000082AD                 db    0
.xdata$x:000082AE                 db    0
.xdata$x:000082AF                 db    0
.xdata$x:000082B0                 db    0
.xdata$x:000082B1                 db    0
.xdata$x:000082B2                 db    0
.xdata$x:000082B3                 db    0
.xdata$x:000082B4                 db    1
.xdata$x:000082B5                 db    0
.xdata$x:000082B6                 db    0
.xdata$x:000082B7                 db    0
.xdata$x:000082B8                 db    1
.xdata$x:000082B9                 db    0
.xdata$x:000082BA                 db    0
.xdata$x:000082BB                 db    0
.xdata$x:000082BC                 dd offset __catchsym$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z$2
.xdata$x:000082C0 __ehfuncinfo$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:000082C0                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z+11o
.xdata$x:000082C1                 db    5
.xdata$x:000082C2                 db  93h ; ô
.xdata$x:000082C3                 db  19h
.xdata$x:000082C4                 db    2
.xdata$x:000082C5                 db    0
.xdata$x:000082C6                 db    0
.xdata$x:000082C7                 db    0
.xdata$x:000082C8                 dd offset __unwindtable$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z
.xdata$x:000082CC                 db    1
.xdata$x:000082CD                 db    0
.xdata$x:000082CE                 db    0
.xdata$x:000082CF                 db    0
.xdata$x:000082D0                 dd offset __tryblocktable$?_Reallocate@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IAEXI@Z
.xdata$x:000082D4                 db    0
.xdata$x:000082D5                 db    0
.xdata$x:000082D6                 db    0
.xdata$x:000082D7                 db    0
.xdata$x:000082D8                 db    0
.xdata$x:000082D9                 db    0
.xdata$x:000082DA                 db    0
.xdata$x:000082DB                 db    0
.xdata$x:000082DC                 db    0
.xdata$x:000082DD                 db    0
.xdata$x:000082DE                 db    0
.xdata$x:000082DF                 db    0
.xdata$x:000082E0                 db    0
.xdata$x:000082E1                 db    0
.xdata$x:000082E2                 db    0
.xdata$x:000082E3                 db    0
.xdata$x:000082E3 _xdata$x        ends
.xdata$x:000082E3
.xdata$x:000082E4 ; ===========================================================================
.xdata$x:000082E4
.xdata$x:000082E4 ; Segment type: Pure data
.xdata$x:000082E4 ; Segment permissions: Read
.xdata$x:000082E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000082E4                 assume cs:_xdata$x
.xdata$x:000082E4                 ;org 82E4h
.xdata$x:000082E4 ; COMDAT (pick associative to section at 572C)
.xdata$x:000082E4 __unwindtable$?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z db 0FFh
.xdata$x:000082E4                                         ; DATA XREF: .xdata$x:000082F4o
.xdata$x:000082E5                 db 0FFh
.xdata$x:000082E6                 db 0FFh
.xdata$x:000082E7                 db 0FFh
.xdata$x:000082E8                 dd offset __unwindfunclet$?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z$0
.xdata$x:000082EC __ehfuncinfo$?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z db  22h ; "
.xdata$x:000082EC                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z+11o
.xdata$x:000082ED                 db    5
.xdata$x:000082EE                 db  93h ; ô
.xdata$x:000082EF                 db  19h
.xdata$x:000082F0                 db    1
.xdata$x:000082F1                 db    0
.xdata$x:000082F2                 db    0
.xdata$x:000082F3                 db    0
.xdata$x:000082F4                 dd offset __unwindtable$?_Orphan_range@?$vector@UiconLocator@@V?$allocator@UiconLocator@@@std@@@std@@IBEXPAUiconLocator@@0@Z
.xdata$x:000082F8                 db    0
.xdata$x:000082F9                 db    0
.xdata$x:000082FA                 db    0
.xdata$x:000082FB                 db    0
.xdata$x:000082FC                 db    0
.xdata$x:000082FD                 db    0
.xdata$x:000082FE                 db    0
.xdata$x:000082FF                 db    0
.xdata$x:00008300                 db    0
.xdata$x:00008301                 db    0
.xdata$x:00008302                 db    0
.xdata$x:00008303                 db    0
.xdata$x:00008304                 db    0
.xdata$x:00008305                 db    0
.xdata$x:00008306                 db    0
.xdata$x:00008307                 db    0
.xdata$x:00008308                 db    0
.xdata$x:00008309                 db    0
.xdata$x:0000830A                 db    0
.xdata$x:0000830B                 db    0
.xdata$x:0000830C                 db    0
.xdata$x:0000830D                 db    0
.xdata$x:0000830E                 db    0
.xdata$x:0000830F                 db    0
.xdata$x:0000830F _xdata$x        ends
.xdata$x:0000830F
.xdata$x:00008310 ; ===========================================================================
.xdata$x:00008310
.xdata$x:00008310 ; Segment type: Pure data
.xdata$x:00008310 ; Segment permissions: Read
.xdata$x:00008310 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008310                 assume cs:_xdata$x
.xdata$x:00008310                 ;org 8310h
.xdata$x:00008310 ; COMDAT (pick associative to section at 6714)
.xdata$x:00008310 __unwindtable$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ db 0FFh
.xdata$x:00008310                                         ; DATA XREF: .xdata$x:00008320o
.xdata$x:00008311                 db 0FFh
.xdata$x:00008312                 db 0FFh
.xdata$x:00008313                 db 0FFh
.xdata$x:00008314                 dd offset __unwindfunclet$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ$0
.xdata$x:00008318 __ehfuncinfo$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00008318                                         ; DATA XREF: __ehhandler$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ+11o
.xdata$x:00008319                 db    5
.xdata$x:0000831A                 db  93h ; ô
.xdata$x:0000831B                 db  19h
.xdata$x:0000831C                 db    1
.xdata$x:0000831D                 db    0
.xdata$x:0000831E                 db    0
.xdata$x:0000831F                 db    0
.xdata$x:00008320                 dd offset __unwindtable$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
.xdata$x:00008324                 db    0
.xdata$x:00008325                 db    0
.xdata$x:00008326                 db    0
.xdata$x:00008327                 db    0
.xdata$x:00008328                 db    0
.xdata$x:00008329                 db    0
.xdata$x:0000832A                 db    0
.xdata$x:0000832B                 db    0
.xdata$x:0000832C                 db    0
.xdata$x:0000832D                 db    0
.xdata$x:0000832E                 db    0
.xdata$x:0000832F                 db    0
.xdata$x:00008330                 db    0
.xdata$x:00008331                 db    0
.xdata$x:00008332                 db    0
.xdata$x:00008333                 db    0
.xdata$x:00008334                 db    0
.xdata$x:00008335                 db    0
.xdata$x:00008336                 db    0
.xdata$x:00008337                 db    0
.xdata$x:00008338                 db    0
.xdata$x:00008339                 db    0
.xdata$x:0000833A                 db    0
.xdata$x:0000833B                 db    0
.xdata$x:0000833B _xdata$x        ends
.xdata$x:0000833B
.xdata$x:0000833C ; ===========================================================================
.xdata$x:0000833C
.xdata$x:0000833C ; Segment type: Pure data
.xdata$x:0000833C ; Segment permissions: Read
.xdata$x:0000833C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000833C                 assume cs:_xdata$x
.xdata$x:0000833C                 ;org 833Ch
.xdata$x:0000833C ; COMDAT (pick associative to section at 5390)
.xdata$x:0000833C __unwindtable$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z db 0FFh
.xdata$x:0000833C                                         ; DATA XREF: .xdata$x:00008354o
.xdata$x:0000833D                 db 0FFh
.xdata$x:0000833E                 db 0FFh
.xdata$x:0000833F                 db 0FFh
.xdata$x:00008340                 dd offset __unwindfunclet$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$1
.xdata$x:00008344                 db    0
.xdata$x:00008345                 db    0
.xdata$x:00008346                 db    0
.xdata$x:00008347                 db    0
.xdata$x:00008348                 dd offset __unwindfunclet$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$0
.xdata$x:0000834C __ehfuncinfo$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z db  22h ; "
.xdata$x:0000834C                                         ; DATA XREF: __ehhandler$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z+11o
.xdata$x:0000834D                 db    5
.xdata$x:0000834E                 db  93h ; ô
.xdata$x:0000834F                 db  19h
.xdata$x:00008350                 db    2
.xdata$x:00008351                 db    0
.xdata$x:00008352                 db    0
.xdata$x:00008353                 db    0
.xdata$x:00008354                 dd offset __unwindtable$?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z
.xdata$x:00008358                 db    0
.xdata$x:00008359                 db    0
.xdata$x:0000835A                 db    0
.xdata$x:0000835B                 db    0
.xdata$x:0000835C                 db    0
.xdata$x:0000835D                 db    0
.xdata$x:0000835E                 db    0
.xdata$x:0000835F                 db    0
.xdata$x:00008360                 db    0
.xdata$x:00008361                 db    0
.xdata$x:00008362                 db    0
.xdata$x:00008363                 db    0
.xdata$x:00008364                 db    0
.xdata$x:00008365                 db    0
.xdata$x:00008366                 db    0
.xdata$x:00008367                 db    0
.xdata$x:00008368                 db    0
.xdata$x:00008369                 db    0
.xdata$x:0000836A                 db    0
.xdata$x:0000836B                 db    0
.xdata$x:0000836C                 db    0
.xdata$x:0000836D                 db    0
.xdata$x:0000836E                 db    0
.xdata$x:0000836F                 db    0
.xdata$x:0000836F _xdata$x        ends
.xdata$x:0000836F
.xdata$x:00008370 ; ===========================================================================
.xdata$x:00008370
.xdata$x:00008370 ; Segment type: Pure data
.xdata$x:00008370 ; Segment permissions: Read
.xdata$x:00008370 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008370                 assume cs:_xdata$x
.xdata$x:00008370                 ;org 8370h
.xdata$x:00008370 ; COMDAT (pick associative to section at 6CD8)
.xdata$x:00008370 __unwindtable$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z db 0FFh
.xdata$x:00008370                                         ; DATA XREF: .xdata$x:00008390o
.xdata$x:00008371                 db 0FFh
.xdata$x:00008372                 db 0FFh
.xdata$x:00008373                 db 0FFh
.xdata$x:00008374                 dd offset __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$2
.xdata$x:00008378                 db    0
.xdata$x:00008379                 db    0
.xdata$x:0000837A                 db    0
.xdata$x:0000837B                 db    0
.xdata$x:0000837C                 dd offset __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$0
.xdata$x:00008380                 db    1
.xdata$x:00008381                 db    0
.xdata$x:00008382                 db    0
.xdata$x:00008383                 db    0
.xdata$x:00008384                 dd offset __unwindfunclet$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z$1
.xdata$x:00008388 __ehfuncinfo$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z db  22h ; "
.xdata$x:00008388                                         ; DATA XREF: __ehhandler$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z+11o
.xdata$x:00008389                 db    5
.xdata$x:0000838A                 db  93h ; ô
.xdata$x:0000838B                 db  19h
.xdata$x:0000838C                 db    3
.xdata$x:0000838D                 db    0
.xdata$x:0000838E                 db    0
.xdata$x:0000838F                 db    0
.xdata$x:00008390                 dd offset __unwindtable$?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@@Z
.xdata$x:00008394                 db    0
.xdata$x:00008395                 db    0
.xdata$x:00008396                 db    0
.xdata$x:00008397                 db    0
.xdata$x:00008398                 db    0
.xdata$x:00008399                 db    0
.xdata$x:0000839A                 db    0
.xdata$x:0000839B                 db    0
.xdata$x:0000839C                 db    0
.xdata$x:0000839D                 db    0
.xdata$x:0000839E                 db    0
.xdata$x:0000839F                 db    0
.xdata$x:000083A0                 db    0
.xdata$x:000083A1                 db    0
.xdata$x:000083A2                 db    0
.xdata$x:000083A3                 db    0
.xdata$x:000083A4                 db    0
.xdata$x:000083A5                 db    0
.xdata$x:000083A6                 db    0
.xdata$x:000083A7                 db    0
.xdata$x:000083A8                 db    0
.xdata$x:000083A9                 db    0
.xdata$x:000083AA                 db    0
.xdata$x:000083AB                 db    0
.xdata$x:000083AB _xdata$x        ends
.xdata$x:000083AB
.xdata$x:000083AC ; ===========================================================================
.xdata$x:000083AC
.xdata$x:000083AC ; Segment type: Pure data
.xdata$x:000083AC ; Segment permissions: Read
.xdata$x:000083AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000083AC                 assume cs:_xdata$x
.xdata$x:000083AC                 ;org 83ACh
.xdata$x:000083AC ; COMDAT (pick associative to section at 58E4)
.xdata$x:000083AC __catchsym$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:000083AC                                         ; DATA XREF: .xdata$x:000083DCo
.xdata$x:000083AD                 db    0
.xdata$x:000083AE                 db    0
.xdata$x:000083AF                 db    0
.xdata$x:000083B0                 db    0
.xdata$x:000083B1                 db    0
.xdata$x:000083B2                 db    0
.xdata$x:000083B3                 db    0
.xdata$x:000083B4                 db    0
.xdata$x:000083B5                 db    0
.xdata$x:000083B6                 db    0
.xdata$x:000083B7                 db    0
.xdata$x:000083B8                 dd offset __catch$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$0
.xdata$x:000083BC __unwindtable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:000083BC                                         ; DATA XREF: .xdata$x:000083E8o
.xdata$x:000083BD                 db 0FFh
.xdata$x:000083BE                 db 0FFh
.xdata$x:000083BF                 db 0FFh
.xdata$x:000083C0                 db    0
.xdata$x:000083C1                 db    0
.xdata$x:000083C2                 db    0
.xdata$x:000083C3                 db    0
.xdata$x:000083C4                 db 0FFh
.xdata$x:000083C5                 db 0FFh
.xdata$x:000083C6                 db 0FFh
.xdata$x:000083C7                 db 0FFh
.xdata$x:000083C8                 db    0
.xdata$x:000083C9                 db    0
.xdata$x:000083CA                 db    0
.xdata$x:000083CB                 db    0
.xdata$x:000083CC __tryblocktable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z db    0
.xdata$x:000083CC                                         ; DATA XREF: .xdata$x:000083F0o
.xdata$x:000083CD                 db    0
.xdata$x:000083CE                 db    0
.xdata$x:000083CF                 db    0
.xdata$x:000083D0                 db    0
.xdata$x:000083D1                 db    0
.xdata$x:000083D2                 db    0
.xdata$x:000083D3                 db    0
.xdata$x:000083D4                 db    1
.xdata$x:000083D5                 db    0
.xdata$x:000083D6                 db    0
.xdata$x:000083D7                 db    0
.xdata$x:000083D8                 db    1
.xdata$x:000083D9                 db    0
.xdata$x:000083DA                 db    0
.xdata$x:000083DB                 db    0
.xdata$x:000083DC                 dd offset __catchsym$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z$2
.xdata$x:000083E0 __ehfuncinfo$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:000083E0                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z+11o
.xdata$x:000083E1                 db    5
.xdata$x:000083E2                 db  93h ; ô
.xdata$x:000083E3                 db  19h
.xdata$x:000083E4                 db    2
.xdata$x:000083E5                 db    0
.xdata$x:000083E6                 db    0
.xdata$x:000083E7                 db    0
.xdata$x:000083E8                 dd offset __unwindtable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.xdata$x:000083EC                 db    1
.xdata$x:000083ED                 db    0
.xdata$x:000083EE                 db    0
.xdata$x:000083EF                 db    0
.xdata$x:000083F0                 dd offset __tryblocktable$?_Reallocate@?$vector@HV?$allocator@H@std@@@std@@IAEXI@Z
.xdata$x:000083F4                 db    0
.xdata$x:000083F5                 db    0
.xdata$x:000083F6                 db    0
.xdata$x:000083F7                 db    0
.xdata$x:000083F8                 db    0
.xdata$x:000083F9                 db    0
.xdata$x:000083FA                 db    0
.xdata$x:000083FB                 db    0
.xdata$x:000083FC                 db    0
.xdata$x:000083FD                 db    0
.xdata$x:000083FE                 db    0
.xdata$x:000083FF                 db    0
.xdata$x:00008400                 db    0
.xdata$x:00008401                 db    0
.xdata$x:00008402                 db    0
.xdata$x:00008403                 db    0
.xdata$x:00008403 _xdata$x        ends
.xdata$x:00008403
.xdata$x:00008404 ; ===========================================================================
.xdata$x:00008404
.xdata$x:00008404 ; Segment type: Pure data
.xdata$x:00008404 ; Segment permissions: Read
.xdata$x:00008404 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008404                 assume cs:_xdata$x
.xdata$x:00008404                 ;org 8404h
.xdata$x:00008404 ; COMDAT (pick associative to section at 5650)
.xdata$x:00008404 __unwindtable$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z db 0FFh
.xdata$x:00008404                                         ; DATA XREF: .xdata$x:00008414o
.xdata$x:00008405                 db 0FFh
.xdata$x:00008406                 db 0FFh
.xdata$x:00008407                 db 0FFh
.xdata$x:00008408                 dd offset __unwindfunclet$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z$0
.xdata$x:0000840C __ehfuncinfo$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z db  22h ; "
.xdata$x:0000840C                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z+11o
.xdata$x:0000840D                 db    5
.xdata$x:0000840E                 db  93h ; ô
.xdata$x:0000840F                 db  19h
.xdata$x:00008410                 db    1
.xdata$x:00008411                 db    0
.xdata$x:00008412                 db    0
.xdata$x:00008413                 db    0
.xdata$x:00008414                 dd offset __unwindtable$?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@IBEXPAH0@Z
.xdata$x:00008418                 db    0
.xdata$x:00008419                 db    0
.xdata$x:0000841A                 db    0
.xdata$x:0000841B                 db    0
.xdata$x:0000841C                 db    0
.xdata$x:0000841D                 db    0
.xdata$x:0000841E                 db    0
.xdata$x:0000841F                 db    0
.xdata$x:00008420                 db    0
.xdata$x:00008421                 db    0
.xdata$x:00008422                 db    0
.xdata$x:00008423                 db    0
.xdata$x:00008424                 db    0
.xdata$x:00008425                 db    0
.xdata$x:00008426                 db    0
.xdata$x:00008427                 db    0
.xdata$x:00008428                 db    0
.xdata$x:00008429                 db    0
.xdata$x:0000842A                 db    0
.xdata$x:0000842B                 db    0
.xdata$x:0000842C                 db    0
.xdata$x:0000842D                 db    0
.xdata$x:0000842E                 db    0
.xdata$x:0000842F                 db    0
.xdata$x:0000842F _xdata$x        ends
.xdata$x:0000842F
.xdata$x:00008430 ; ===========================================================================
.xdata$x:00008430
.xdata$x:00008430 ; Segment type: Pure data
.xdata$x:00008430 ; Segment permissions: Read
.xdata$x:00008430 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008430                 assume cs:_xdata$x
.xdata$x:00008430                 ;org 8430h
.xdata$x:00008430 ; COMDAT (pick associative to section at 2E00)
.xdata$x:00008430 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00008430                                         ; DATA XREF: .xdata$x:00008440o
.xdata$x:00008431                 db 0FFh
.xdata$x:00008432                 db 0FFh
.xdata$x:00008433                 db 0FFh
.xdata$x:00008434                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00008438 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00008438                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00008439                 db    5
.xdata$x:0000843A                 db  93h ; ô
.xdata$x:0000843B                 db  19h
.xdata$x:0000843C                 db    1
.xdata$x:0000843D                 db    0
.xdata$x:0000843E                 db    0
.xdata$x:0000843F                 db    0
.xdata$x:00008440                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00008444                 db    0
.xdata$x:00008445                 db    0
.xdata$x:00008446                 db    0
.xdata$x:00008447                 db    0
.xdata$x:00008448                 db    0
.xdata$x:00008449                 db    0
.xdata$x:0000844A                 db    0
.xdata$x:0000844B                 db    0
.xdata$x:0000844C                 db    0
.xdata$x:0000844D                 db    0
.xdata$x:0000844E                 db    0
.xdata$x:0000844F                 db    0
.xdata$x:00008450                 db    0
.xdata$x:00008451                 db    0
.xdata$x:00008452                 db    0
.xdata$x:00008453                 db    0
.xdata$x:00008454                 db    0
.xdata$x:00008455                 db    0
.xdata$x:00008456                 db    0
.xdata$x:00008457                 db    0
.xdata$x:00008458                 db    0
.xdata$x:00008459                 db    0
.xdata$x:0000845A                 db    0
.xdata$x:0000845B                 db    0
.xdata$x:0000845B _xdata$x        ends
.xdata$x:0000845B
.xdata$x:0000845C ; ===========================================================================
.xdata$x:0000845C
.xdata$x:0000845C ; Segment type: Pure data
.xdata$x:0000845C ; Segment permissions: Read
.xdata$x:0000845C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000845C                 assume cs:_xdata$x
.xdata$x:0000845C                 ;org 845Ch
.xdata$x:0000845C ; COMDAT (pick associative to section at 3A8C)
.xdata$x:0000845C __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000845C                                         ; DATA XREF: .xdata$x:0000846Co
.xdata$x:0000845D                 db 0FFh
.xdata$x:0000845E                 db 0FFh
.xdata$x:0000845F                 db 0FFh
.xdata$x:00008460                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00008464 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00008464                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00008465                 db    5
.xdata$x:00008466                 db  93h ; ô
.xdata$x:00008467                 db  19h
.xdata$x:00008468                 db    1
.xdata$x:00008469                 db    0
.xdata$x:0000846A                 db    0
.xdata$x:0000846B                 db    0
.xdata$x:0000846C                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00008470                 db    0
.xdata$x:00008471                 db    0
.xdata$x:00008472                 db    0
.xdata$x:00008473                 db    0
.xdata$x:00008474                 db    0
.xdata$x:00008475                 db    0
.xdata$x:00008476                 db    0
.xdata$x:00008477                 db    0
.xdata$x:00008478                 db    0
.xdata$x:00008479                 db    0
.xdata$x:0000847A                 db    0
.xdata$x:0000847B                 db    0
.xdata$x:0000847C                 db    0
.xdata$x:0000847D                 db    0
.xdata$x:0000847E                 db    0
.xdata$x:0000847F                 db    0
.xdata$x:00008480                 db    0
.xdata$x:00008481                 db    0
.xdata$x:00008482                 db    0
.xdata$x:00008483                 db    0
.xdata$x:00008484                 db    0
.xdata$x:00008485                 db    0
.xdata$x:00008486                 db    0
.xdata$x:00008487                 db    0
.xdata$x:00008487 _xdata$x        ends
.xdata$x:00008487
.xdata$x:00008488 ; ===========================================================================
.xdata$x:00008488
.xdata$x:00008488 ; Segment type: Pure data
.xdata$x:00008488 ; Segment permissions: Read
.xdata$x:00008488 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008488                 assume cs:_xdata$x
.xdata$x:00008488                 ;org 8488h
.xdata$x:00008488 ; COMDAT (pick associative to section at 2D88)
.xdata$x:00008488 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:00008488                                         ; DATA XREF: .xdata$x:00008498o
.xdata$x:00008489                 db 0FFh
.xdata$x:0000848A                 db 0FFh
.xdata$x:0000848B                 db 0FFh
.xdata$x:0000848C                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:00008490 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:00008490                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:00008491                 db    5
.xdata$x:00008492                 db  93h ; ô
.xdata$x:00008493                 db  19h
.xdata$x:00008494                 db    1
.xdata$x:00008495                 db    0
.xdata$x:00008496                 db    0
.xdata$x:00008497                 db    0
.xdata$x:00008498                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:0000849C                 db    0
.xdata$x:0000849D                 db    0
.xdata$x:0000849E                 db    0
.xdata$x:0000849F                 db    0
.xdata$x:000084A0                 db    0
.xdata$x:000084A1                 db    0
.xdata$x:000084A2                 db    0
.xdata$x:000084A3                 db    0
.xdata$x:000084A4                 db    0
.xdata$x:000084A5                 db    0
.xdata$x:000084A6                 db    0
.xdata$x:000084A7                 db    0
.xdata$x:000084A8                 db    0
.xdata$x:000084A9                 db    0
.xdata$x:000084AA                 db    0
.xdata$x:000084AB                 db    0
.xdata$x:000084AC                 db    0
.xdata$x:000084AD                 db    0
.xdata$x:000084AE                 db    0
.xdata$x:000084AF                 db    0
.xdata$x:000084B0                 db    0
.xdata$x:000084B1                 db    0
.xdata$x:000084B2                 db    0
.xdata$x:000084B3                 db    0
.xdata$x:000084B3 _xdata$x        ends
.xdata$x:000084B3
.xdata$x:000084B4 ; ===========================================================================
.xdata$x:000084B4
.xdata$x:000084B4 ; Segment type: Pure data
.xdata$x:000084B4 ; Segment permissions: Read
.xdata$x:000084B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000084B4                 assume cs:_xdata$x
.xdata$x:000084B4                 ;org 84B4h
.xdata$x:000084B4 ; COMDAT (pick associative to section at 3100)
.xdata$x:000084B4 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z db 0FFh
.xdata$x:000084B4                                         ; DATA XREF: .xdata$x:000084C4o
.xdata$x:000084B5                 db 0FFh
.xdata$x:000084B6                 db 0FFh
.xdata$x:000084B7                 db 0FFh
.xdata$x:000084B8                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0
.xdata$x:000084BC __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:000084BC                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z+11o
.xdata$x:000084BD                 db    5
.xdata$x:000084BE                 db  93h ; ô
.xdata$x:000084BF                 db  19h
.xdata$x:000084C0                 db    1
.xdata$x:000084C1                 db    0
.xdata$x:000084C2                 db    0
.xdata$x:000084C3                 db    0
.xdata$x:000084C4                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.xdata$x:000084C8                 align 20h
.xdata$x:000084C8 _xdata$x        ends
.xdata$x:000084C8
.xdata$x:000084E0 ; ===========================================================================
.xdata$x:000084E0
.xdata$x:000084E0 ; Segment type: Pure data
.xdata$x:000084E0 ; Segment permissions: Read
.xdata$x:000084E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000084E0                 assume cs:_xdata$x
.xdata$x:000084E0                 ;org 84E0h
.xdata$x:000084E0 ; COMDAT (pick associative to section at 3CCC)
.xdata$x:000084E0 __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000084E0                                         ; DATA XREF: .xdata$x:000084F0o
.xdata$x:000084E1                 db 0FFh
.xdata$x:000084E2                 db 0FFh
.xdata$x:000084E3                 db 0FFh
.xdata$x:000084E4                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000084E8 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000084E8                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000084E9                 db    5
.xdata$x:000084EA                 db  93h ; ô
.xdata$x:000084EB                 db  19h
.xdata$x:000084EC                 db    1
.xdata$x:000084ED                 db    0
.xdata$x:000084EE                 db    0
.xdata$x:000084EF                 db    0
.xdata$x:000084F0                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.xdata$x:000084F4                 db    0
.xdata$x:000084F5                 db    0
.xdata$x:000084F6                 db    0
.xdata$x:000084F7                 db    0
.xdata$x:000084F8                 db    0
.xdata$x:000084F9                 db    0
.xdata$x:000084FA                 db    0
.xdata$x:000084FB                 db    0
.xdata$x:000084FC                 db    0
.xdata$x:000084FD                 db    0
.xdata$x:000084FE                 db    0
.xdata$x:000084FF                 db    0
.xdata$x:00008500                 db    0
.xdata$x:00008501                 db    0
.xdata$x:00008502                 db    0
.xdata$x:00008503                 db    0
.xdata$x:00008504                 db    0
.xdata$x:00008505                 db    0
.xdata$x:00008506                 db    0
.xdata$x:00008507                 db    0
.xdata$x:00008508                 db    0
.xdata$x:00008509                 db    0
.xdata$x:0000850A                 db    0
.xdata$x:0000850B                 db    0
.xdata$x:0000850B _xdata$x        ends
.xdata$x:0000850B
.xdata$x:0000850C ; ===========================================================================
.xdata$x:0000850C
.xdata$x:0000850C ; Segment type: Pure data
.xdata$x:0000850C ; Segment permissions: Read
.xdata$x:0000850C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000850C                 assume cs:_xdata$x
.xdata$x:0000850C                 ;org 850Ch
.xdata$x:0000850C ; COMDAT (pick associative to section at 307C)
.xdata$x:0000850C __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000850C                                         ; DATA XREF: .xdata$x:0000851Co
.xdata$x:0000850D                 db 0FFh
.xdata$x:0000850E                 db 0FFh
.xdata$x:0000850F                 db 0FFh
.xdata$x:00008510                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00008514 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00008514                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00008515                 db    5
.xdata$x:00008516                 db  93h ; ô
.xdata$x:00008517                 db  19h
.xdata$x:00008518                 db    1
.xdata$x:00008519                 db    0
.xdata$x:0000851A                 db    0
.xdata$x:0000851B                 db    0
.xdata$x:0000851C                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00008520                 db    0
.xdata$x:00008521                 db    0
.xdata$x:00008522                 db    0
.xdata$x:00008523                 db    0
.xdata$x:00008524                 db    0
.xdata$x:00008525                 db    0
.xdata$x:00008526                 db    0
.xdata$x:00008527                 db    0
.xdata$x:00008528                 db    0
.xdata$x:00008529                 db    0
.xdata$x:0000852A                 db    0
.xdata$x:0000852B                 db    0
.xdata$x:0000852C                 db    0
.xdata$x:0000852D                 db    0
.xdata$x:0000852E                 db    0
.xdata$x:0000852F                 db    0
.xdata$x:00008530                 db    0
.xdata$x:00008531                 db    0
.xdata$x:00008532                 db    0
.xdata$x:00008533                 db    0
.xdata$x:00008534                 db    0
.xdata$x:00008535                 db    0
.xdata$x:00008536                 db    0
.xdata$x:00008537                 db    0
.xdata$x:00008537 _xdata$x        ends
.xdata$x:00008537
.xdata$x:00008538 ; ===========================================================================
.xdata$x:00008538
.xdata$x:00008538 ; Segment type: Pure data
.xdata$x:00008538 ; Segment permissions: Read
.xdata$x:00008538 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008538                 assume cs:_xdata$x
.xdata$x:00008538                 ;org 8538h
.xdata$x:00008538 ; COMDAT (pick associative to section at 3204)
.xdata$x:00008538 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z db 0FFh
.xdata$x:00008538                                         ; DATA XREF: .xdata$x:00008548o
.xdata$x:00008539                 db 0FFh
.xdata$x:0000853A                 db 0FFh
.xdata$x:0000853B                 db 0FFh
.xdata$x:0000853C                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0
.xdata$x:00008540 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00008540                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z+11o
.xdata$x:00008541                 db    5
.xdata$x:00008542                 db  93h ; ô
.xdata$x:00008543                 db  19h
.xdata$x:00008544                 db    1
.xdata$x:00008545                 db    0
.xdata$x:00008546                 db    0
.xdata$x:00008547                 db    0
.xdata$x:00008548                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
.xdata$x:0000854C                 db    0
.xdata$x:0000854D                 db    0
.xdata$x:0000854E                 db    0
.xdata$x:0000854F                 db    0
.xdata$x:00008550                 db    0
.xdata$x:00008551                 db    0
.xdata$x:00008552                 db    0
.xdata$x:00008553                 db    0
.xdata$x:00008554                 db    0
.xdata$x:00008555                 db    0
.xdata$x:00008556                 db    0
.xdata$x:00008557                 db    0
.xdata$x:00008558                 db    0
.xdata$x:00008559                 db    0
.xdata$x:0000855A                 db    0
.xdata$x:0000855B                 db    0
.xdata$x:0000855C                 db    0
.xdata$x:0000855D                 db    0
.xdata$x:0000855E                 db    0
.xdata$x:0000855F                 db    0
.xdata$x:00008560                 db    0
.xdata$x:00008561                 db    0
.xdata$x:00008562                 db    0
.xdata$x:00008563                 db    0
.xdata$x:00008563 _xdata$x        ends
.xdata$x:00008563
.xdata$x:00008564 ; ===========================================================================
.xdata$x:00008564
.xdata$x:00008564 ; Segment type: Pure data
.xdata$x:00008564 ; Segment permissions: Read
.xdata$x:00008564 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008564                 assume cs:_xdata$x
.xdata$x:00008564                 ;org 8564h
.xdata$x:00008564 ; COMDAT (pick associative to section at 4474)
.xdata$x:00008564 __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:00008564                                         ; DATA XREF: .xdata$x:0000857Co
.xdata$x:00008565                 db 0FFh
.xdata$x:00008566                 db 0FFh
.xdata$x:00008567                 db 0FFh
.xdata$x:00008568                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:0000856C                 align 10h
.xdata$x:00008570                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:00008574 __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:00008574                                         ; DATA XREF: __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:00008575                 db    5
.xdata$x:00008576                 db  93h ; ô
.xdata$x:00008577                 db  19h
.xdata$x:00008578                 db    2
.xdata$x:00008579                 db    0
.xdata$x:0000857A                 db    0
.xdata$x:0000857B                 db    0
.xdata$x:0000857C                 dd offset __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:00008580                 db    0
.xdata$x:00008581                 db    0
.xdata$x:00008582                 db    0
.xdata$x:00008583                 db    0
.xdata$x:00008584                 db    0
.xdata$x:00008585                 db    0
.xdata$x:00008586                 db    0
.xdata$x:00008587                 db    0
.xdata$x:00008588                 db    0
.xdata$x:00008589                 db    0
.xdata$x:0000858A                 db    0
.xdata$x:0000858B                 db    0
.xdata$x:0000858C                 db    0
.xdata$x:0000858D                 db    0
.xdata$x:0000858E                 db    0
.xdata$x:0000858F                 db    0
.xdata$x:00008590                 db    0
.xdata$x:00008591                 db    0
.xdata$x:00008592                 db    0
.xdata$x:00008593                 db    0
.xdata$x:00008594                 db    0
.xdata$x:00008595                 db    0
.xdata$x:00008596                 db    0
.xdata$x:00008597                 db    0
.xdata$x:00008597 _xdata$x        ends
.xdata$x:00008597
.xdata$x:00008598 ; ===========================================================================
.xdata$x:00008598
.xdata$x:00008598 ; Segment type: Pure data
.xdata$x:00008598 ; Segment permissions: Read
.xdata$x:00008598 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008598                 assume cs:_xdata$x
.xdata$x:00008598                 ;org 8598h
.xdata$x:00008598 ; COMDAT (pick associative to section at 3D3C)
.xdata$x:00008598 __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00008598                                         ; DATA XREF: .xdata$x:000085A8o
.xdata$x:00008599                 db 0FFh
.xdata$x:0000859A                 db 0FFh
.xdata$x:0000859B                 db 0FFh
.xdata$x:0000859C                 dd offset __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000085A0 __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000085A0                                         ; DATA XREF: __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000085A1                 db    5
.xdata$x:000085A2                 db  93h ; ô
.xdata$x:000085A3                 db  19h
.xdata$x:000085A4                 db    1
.xdata$x:000085A5                 db    0
.xdata$x:000085A6                 db    0
.xdata$x:000085A7                 db    0
.xdata$x:000085A8                 dd offset __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
.xdata$x:000085AC                 db    0
.xdata$x:000085AD                 db    0
.xdata$x:000085AE                 db    0
.xdata$x:000085AF                 db    0
.xdata$x:000085B0                 db    0
.xdata$x:000085B1                 db    0
.xdata$x:000085B2                 db    0
.xdata$x:000085B3                 db    0
.xdata$x:000085B4                 db    0
.xdata$x:000085B5                 db    0
.xdata$x:000085B6                 db    0
.xdata$x:000085B7                 db    0
.xdata$x:000085B8                 db    0
.xdata$x:000085B9                 db    0
.xdata$x:000085BA                 db    0
.xdata$x:000085BB                 db    0
.xdata$x:000085BC                 db    0
.xdata$x:000085BD                 db    0
.xdata$x:000085BE                 db    0
.xdata$x:000085BF                 db    0
.xdata$x:000085C0                 db    0
.xdata$x:000085C1                 db    0
.xdata$x:000085C2                 db    0
.xdata$x:000085C3                 db    0
.xdata$x:000085C3 _xdata$x        ends
.xdata$x:000085C3
.xdata$x:000085C4 ; ===========================================================================
.xdata$x:000085C4
.xdata$x:000085C4 ; Segment type: Pure data
.xdata$x:000085C4 ; Segment permissions: Read
.xdata$x:000085C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000085C4                 assume cs:_xdata$x
.xdata$x:000085C4                 ;org 85C4h
.xdata$x:000085C4 ; COMDAT (pick associative to section at 318C)
.xdata$x:000085C4 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:000085C4                                         ; DATA XREF: .xdata$x:000085D4o
.xdata$x:000085C5                 db 0FFh
.xdata$x:000085C6                 db 0FFh
.xdata$x:000085C7                 db 0FFh
.xdata$x:000085C8                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:000085CC __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:000085CC                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:000085CD                 db    5
.xdata$x:000085CE                 db  93h ; ô
.xdata$x:000085CF                 db  19h
.xdata$x:000085D0                 db    1
.xdata$x:000085D1                 db    0
.xdata$x:000085D2                 db    0
.xdata$x:000085D3                 db    0
.xdata$x:000085D4                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:000085D8                 db    0
.xdata$x:000085D9                 db    0
.xdata$x:000085DA                 db    0
.xdata$x:000085DB                 db    0
.xdata$x:000085DC                 db    0
.xdata$x:000085DD                 db    0
.xdata$x:000085DE                 db    0
.xdata$x:000085DF                 db    0
.xdata$x:000085E0                 db    0
.xdata$x:000085E1                 db    0
.xdata$x:000085E2                 db    0
.xdata$x:000085E3                 db    0
.xdata$x:000085E4                 db    0
.xdata$x:000085E5                 db    0
.xdata$x:000085E6                 db    0
.xdata$x:000085E7                 db    0
.xdata$x:000085E8                 db    0
.xdata$x:000085E9                 db    0
.xdata$x:000085EA                 db    0
.xdata$x:000085EB                 db    0
.xdata$x:000085EC                 db    0
.xdata$x:000085ED                 db    0
.xdata$x:000085EE                 db    0
.xdata$x:000085EF                 db    0
.xdata$x:000085EF _xdata$x        ends
.xdata$x:000085EF
.xdata$x:000085F0 ; ===========================================================================
.xdata$x:000085F0
.xdata$x:000085F0 ; Segment type: Pure data
.xdata$x:000085F0 ; Segment permissions: Read
.xdata$x:000085F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000085F0                 assume cs:_xdata$x
.xdata$x:000085F0                 ;org 85F0h
.xdata$x:000085F0 ; COMDAT (pick associative to section at 27FC)
.xdata$x:000085F0 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:000085F0                                         ; DATA XREF: .xdata$x:00008600o
.xdata$x:000085F1                 db 0FFh
.xdata$x:000085F2                 db 0FFh
.xdata$x:000085F3                 db 0FFh
.xdata$x:000085F4                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:000085F8 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:000085F8                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:000085F9                 db    5
.xdata$x:000085FA                 db  93h ; ô
.xdata$x:000085FB                 db  19h
.xdata$x:000085FC                 db    1
.xdata$x:000085FD                 db    0
.xdata$x:000085FE                 db    0
.xdata$x:000085FF                 db    0
.xdata$x:00008600                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00008604                 db    0
.xdata$x:00008605                 db    0
.xdata$x:00008606                 db    0
.xdata$x:00008607                 db    0
.xdata$x:00008608                 db    0
.xdata$x:00008609                 db    0
.xdata$x:0000860A                 db    0
.xdata$x:0000860B                 db    0
.xdata$x:0000860C                 db    0
.xdata$x:0000860D                 db    0
.xdata$x:0000860E                 db    0
.xdata$x:0000860F                 db    0
.xdata$x:00008610                 db    0
.xdata$x:00008611                 db    0
.xdata$x:00008612                 db    0
.xdata$x:00008613                 db    0
.xdata$x:00008614                 db    0
.xdata$x:00008615                 db    0
.xdata$x:00008616                 db    0
.xdata$x:00008617                 db    0
.xdata$x:00008618                 db    0
.xdata$x:00008619                 db    0
.xdata$x:0000861A                 db    0
.xdata$x:0000861B                 db    0
.xdata$x:0000861B _xdata$x        ends
.xdata$x:0000861B
.xdata$x:0000861C ; ===========================================================================
.xdata$x:0000861C
.xdata$x:0000861C ; Segment type: Pure data
.xdata$x:0000861C ; Segment permissions: Read
.xdata$x:0000861C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000861C                 assume cs:_xdata$x
.xdata$x:0000861C                 ;org 861Ch
.xdata$x:0000861C ; COMDAT (pick associative to section at 29E0)
.xdata$x:0000861C __unwindtable$??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z db 0FFh
.xdata$x:0000861C                                         ; DATA XREF: .xdata$x:0000862Co
.xdata$x:0000861D                 db 0FFh
.xdata$x:0000861E                 db 0FFh
.xdata$x:0000861F                 db 0FFh
.xdata$x:00008620                 dd offset __unwindfunclet$??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z$0
.xdata$x:00008624 __ehfuncinfo$??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z db  22h ; "
.xdata$x:00008624                                         ; DATA XREF: __ehhandler$??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z+11o
.xdata$x:00008625                 db    5
.xdata$x:00008626                 db  93h ; ô
.xdata$x:00008627                 db  19h
.xdata$x:00008628                 db    1
.xdata$x:00008629                 db    0
.xdata$x:0000862A                 db    0
.xdata$x:0000862B                 db    0
.xdata$x:0000862C                 dd offset __unwindtable$??$construct@UtDynamicList@@AAU1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@AAU2@@Z
.xdata$x:00008630                 db    0
.xdata$x:00008631                 db    0
.xdata$x:00008632                 db    0
.xdata$x:00008633                 db    0
.xdata$x:00008634                 db    0
.xdata$x:00008635                 db    0
.xdata$x:00008636                 db    0
.xdata$x:00008637                 db    0
.xdata$x:00008638                 db    0
.xdata$x:00008639                 db    0
.xdata$x:0000863A                 db    0
.xdata$x:0000863B                 db    0
.xdata$x:0000863C                 db    0
.xdata$x:0000863D                 db    0
.xdata$x:0000863E                 db    0
.xdata$x:0000863F                 db    0
.xdata$x:00008640                 db    0
.xdata$x:00008641                 db    0
.xdata$x:00008642                 db    0
.xdata$x:00008643                 db    0
.xdata$x:00008644                 db    0
.xdata$x:00008645                 db    0
.xdata$x:00008646                 db    0
.xdata$x:00008647                 db    0
.xdata$x:00008647 _xdata$x        ends
.xdata$x:00008647
.xdata$x:00008648 ; ===========================================================================
.xdata$x:00008648
.xdata$x:00008648 ; Segment type: Pure data
.xdata$x:00008648 ; Segment permissions: Read
.xdata$x:00008648 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008648                 assume cs:_xdata$x
.xdata$x:00008648                 ;org 8648h
.xdata$x:00008648 ; COMDAT (pick associative to section at 28E0)
.xdata$x:00008648 __unwindtable$??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z db 0FFh
.xdata$x:00008648                                         ; DATA XREF: .xdata$x:00008658o
.xdata$x:00008649                 db 0FFh
.xdata$x:0000864A                 db 0FFh
.xdata$x:0000864B                 db 0FFh
.xdata$x:0000864C                 dd offset __unwindfunclet$??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z$0
.xdata$x:00008650 __ehfuncinfo$??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z db  22h ; "
.xdata$x:00008650                                         ; DATA XREF: __ehhandler$??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z+11o
.xdata$x:00008651                 db    5
.xdata$x:00008652                 db  93h ; ô
.xdata$x:00008653                 db  19h
.xdata$x:00008654                 db    1
.xdata$x:00008655                 db    0
.xdata$x:00008656                 db    0
.xdata$x:00008657                 db    0
.xdata$x:00008658                 dd offset __unwindtable$??$construct@UiconLocator@@U1@@?$allocator@UiconLocator@@@std@@QAEXPAUiconLocator@@$$QAU2@@Z
.xdata$x:0000865C                 db    0
.xdata$x:0000865D                 db    0
.xdata$x:0000865E                 db    0
.xdata$x:0000865F                 db    0
.xdata$x:00008660                 db    0
.xdata$x:00008661                 db    0
.xdata$x:00008662                 db    0
.xdata$x:00008663                 db    0
.xdata$x:00008664                 db    0
.xdata$x:00008665                 db    0
.xdata$x:00008666                 db    0
.xdata$x:00008667                 db    0
.xdata$x:00008668                 db    0
.xdata$x:00008669                 db    0
.xdata$x:0000866A                 db    0
.xdata$x:0000866B                 db    0
.xdata$x:0000866C                 db    0
.xdata$x:0000866D                 db    0
.xdata$x:0000866E                 db    0
.xdata$x:0000866F                 db    0
.xdata$x:00008670                 db    0
.xdata$x:00008671                 db    0
.xdata$x:00008672                 db    0
.xdata$x:00008673                 db    0
.xdata$x:00008673 _xdata$x        ends
.xdata$x:00008673
.xdata$x:00008674 ; ===========================================================================
.xdata$x:00008674
.xdata$x:00008674 ; Segment type: Pure data
.xdata$x:00008674 ; Segment permissions: Read
.xdata$x:00008674 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008674                 assume cs:_xdata$x
.xdata$x:00008674                 ;org 8674h
.xdata$x:00008674 ; COMDAT (pick associative to section at 24DC)
.xdata$x:00008674 __unwindtable$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z db 0FFh
.xdata$x:00008674                                         ; DATA XREF: .xdata$x:00008684o
.xdata$x:00008675                 db 0FFh
.xdata$x:00008676                 db 0FFh
.xdata$x:00008677                 db 0FFh
.xdata$x:00008678                 dd offset __unwindfunclet$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z$0
.xdata$x:0000867C __ehfuncinfo$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z db  22h ; "
.xdata$x:0000867C                                         ; DATA XREF: __ehhandler$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z+11o
.xdata$x:0000867D                 db    5
.xdata$x:0000867E                 db  93h ; ô
.xdata$x:0000867F                 db  19h
.xdata$x:00008680                 db    1
.xdata$x:00008681                 db    0
.xdata$x:00008682                 db    0
.xdata$x:00008683                 db    0
.xdata$x:00008684                 dd offset __unwindtable$??$construct@HAAH@?$allocator@H@std@@QAEXPAHAAH@Z
.xdata$x:00008688                 align 20h
.xdata$x:00008688 _xdata$x        ends
.xdata$x:00008688
.xdata$x:000086A0 ; ===========================================================================
.xdata$x:000086A0
.xdata$x:000086A0 ; Segment type: Pure data
.xdata$x:000086A0 ; Segment permissions: Read
.xdata$x:000086A0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000086A0                 assume cs:_xdata$x
.xdata$x:000086A0                 ;org 86A0h
.xdata$x:000086A0 ; COMDAT (pick associative to section at 2628)
.xdata$x:000086A0 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:000086A0                                         ; DATA XREF: .xdata$x:000086B0o
.xdata$x:000086A1                 db 0FFh
.xdata$x:000086A2                 db 0FFh
.xdata$x:000086A3                 db 0FFh
.xdata$x:000086A4                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:000086A8 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:000086A8                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:000086A9                 db    5
.xdata$x:000086AA                 db  93h ; ô
.xdata$x:000086AB                 db  19h
.xdata$x:000086AC                 db    1
.xdata$x:000086AD                 db    0
.xdata$x:000086AE                 db    0
.xdata$x:000086AF                 db    0
.xdata$x:000086B0                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:000086B4                 db    0
.xdata$x:000086B5                 db    0
.xdata$x:000086B6                 db    0
.xdata$x:000086B7                 db    0
.xdata$x:000086B8                 db    0
.xdata$x:000086B9                 db    0
.xdata$x:000086BA                 db    0
.xdata$x:000086BB                 db    0
.xdata$x:000086BC                 db    0
.xdata$x:000086BD                 db    0
.xdata$x:000086BE                 db    0
.xdata$x:000086BF                 db    0
.xdata$x:000086C0                 db    0
.xdata$x:000086C1                 db    0
.xdata$x:000086C2                 db    0
.xdata$x:000086C3                 db    0
.xdata$x:000086C4                 db    0
.xdata$x:000086C5                 db    0
.xdata$x:000086C6                 db    0
.xdata$x:000086C7                 db    0
.xdata$x:000086C8                 db    0
.xdata$x:000086C9                 db    0
.xdata$x:000086CA                 db    0
.xdata$x:000086CB                 db    0
.xdata$x:000086CB _xdata$x        ends
.xdata$x:000086CB
.xdata$x:000086CC ; ===========================================================================
.xdata$x:000086CC
.xdata$x:000086CC ; Segment type: Pure data
.xdata$x:000086CC ; Segment permissions: Read
.xdata$x:000086CC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000086CC                 assume cs:_xdata$x
.xdata$x:000086CC                 ;org 86CCh
.xdata$x:000086CC ; COMDAT (pick associative to section at 2728)
.xdata$x:000086CC __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:000086CC                                         ; DATA XREF: .xdata$x:000086DCo
.xdata$x:000086CD                 db 0FFh
.xdata$x:000086CE                 db 0FFh
.xdata$x:000086CF                 db 0FFh
.xdata$x:000086D0                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:000086D4 __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:000086D4                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:000086D5                 db    5
.xdata$x:000086D6                 db  93h ; ô
.xdata$x:000086D7                 db  19h
.xdata$x:000086D8                 db    1
.xdata$x:000086D9                 db    0
.xdata$x:000086DA                 db    0
.xdata$x:000086DB                 db    0
.xdata$x:000086DC                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:000086E0                 db    0
.xdata$x:000086E1                 db    0
.xdata$x:000086E2                 db    0
.xdata$x:000086E3                 db    0
.xdata$x:000086E4                 db    0
.xdata$x:000086E5                 db    0
.xdata$x:000086E6                 db    0
.xdata$x:000086E7                 db    0
.xdata$x:000086E8                 db    0
.xdata$x:000086E9                 db    0
.xdata$x:000086EA                 db    0
.xdata$x:000086EB                 db    0
.xdata$x:000086EC                 db    0
.xdata$x:000086ED                 db    0
.xdata$x:000086EE                 db    0
.xdata$x:000086EF                 db    0
.xdata$x:000086F0                 db    0
.xdata$x:000086F1                 db    0
.xdata$x:000086F2                 db    0
.xdata$x:000086F3                 db    0
.xdata$x:000086F4                 db    0
.xdata$x:000086F5                 db    0
.xdata$x:000086F6                 db    0
.xdata$x:000086F7                 db    0
.xdata$x:000086F7 _xdata$x        ends
.xdata$x:000086F7
.xdata$x:000086F8 ; ===========================================================================
.xdata$x:000086F8
.xdata$x:000086F8 ; Segment type: Pure data
.xdata$x:000086F8 ; Segment permissions: Read
.xdata$x:000086F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000086F8                 assume cs:_xdata$x
.xdata$x:000086F8                 ;org 86F8h
.xdata$x:000086F8 ; COMDAT (pick associative to section at 2290)
.xdata$x:000086F8 __catchsym$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:000086F8                                         ; DATA XREF: .xdata$x:00008728o
.xdata$x:000086F9                 db    0
.xdata$x:000086FA                 db    0
.xdata$x:000086FB                 db    0
.xdata$x:000086FC                 db    0
.xdata$x:000086FD                 db    0
.xdata$x:000086FE                 db    0
.xdata$x:000086FF                 db    0
.xdata$x:00008700                 db    0
.xdata$x:00008701                 db    0
.xdata$x:00008702                 db    0
.xdata$x:00008703                 db    0
.xdata$x:00008704                 dd offset __catch$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:00008708 __unwindtable$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:00008708                                         ; DATA XREF: .xdata$x:00008734o
.xdata$x:00008709                 db 0FFh
.xdata$x:0000870A                 db 0FFh
.xdata$x:0000870B                 db 0FFh
.xdata$x:0000870C                 db    0
.xdata$x:0000870D                 db    0
.xdata$x:0000870E                 db    0
.xdata$x:0000870F                 db    0
.xdata$x:00008710                 db 0FFh
.xdata$x:00008711                 db 0FFh
.xdata$x:00008712                 db 0FFh
.xdata$x:00008713                 db 0FFh
.xdata$x:00008714                 db    0
.xdata$x:00008715                 db    0
.xdata$x:00008716                 db    0
.xdata$x:00008717                 db    0
.xdata$x:00008718 __tryblocktable$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:00008718                                         ; DATA XREF: .xdata$x:0000873Co
.xdata$x:00008719                 db    0
.xdata$x:0000871A                 db    0
.xdata$x:0000871B                 db    0
.xdata$x:0000871C                 db    0
.xdata$x:0000871D                 db    0
.xdata$x:0000871E                 db    0
.xdata$x:0000871F                 db    0
.xdata$x:00008720                 db    1
.xdata$x:00008721                 db    0
.xdata$x:00008722                 db    0
.xdata$x:00008723                 db    0
.xdata$x:00008724                 db    1
.xdata$x:00008725                 db    0
.xdata$x:00008726                 db    0
.xdata$x:00008727                 db    0
.xdata$x:00008728                 dd offset __catchsym$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000872C __ehfuncinfo$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000872C                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000872D                 db    5
.xdata$x:0000872E                 db  93h ; ô
.xdata$x:0000872F                 db  19h
.xdata$x:00008730                 db    2
.xdata$x:00008731                 db    0
.xdata$x:00008732                 db    0
.xdata$x:00008733                 db    0
.xdata$x:00008734                 dd offset __unwindtable$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00008738                 db    1
.xdata$x:00008739                 db    0
.xdata$x:0000873A                 db    0
.xdata$x:0000873B                 db    0
.xdata$x:0000873C                 dd offset __tryblocktable$??$_Uninit_move@PAUtDynamicList@@PAU1@V?$allocator@UtDynamicList@@@std@@U1@@std@@YAPAUtDynamicList@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UtDynamicList@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00008740                 db    0
.xdata$x:00008741                 db    0
.xdata$x:00008742                 db    0
.xdata$x:00008743                 db    0
.xdata$x:00008744                 db    0
.xdata$x:00008745                 db    0
.xdata$x:00008746                 db    0
.xdata$x:00008747                 db    0
.xdata$x:00008748                 db    0
.xdata$x:00008749                 db    0
.xdata$x:0000874A                 db    0
.xdata$x:0000874B                 db    0
.xdata$x:0000874C                 db    0
.xdata$x:0000874D                 db    0
.xdata$x:0000874E                 db    0
.xdata$x:0000874F                 db    0
.xdata$x:0000874F _xdata$x        ends
.xdata$x:0000874F
.xdata$x:00008750 ; ===========================================================================
.xdata$x:00008750
.xdata$x:00008750 ; Segment type: Pure data
.xdata$x:00008750 ; Segment permissions: Read
.xdata$x:00008750 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008750                 assume cs:_xdata$x
.xdata$x:00008750                 ;org 8750h
.xdata$x:00008750 ; COMDAT (pick associative to section at 2140)
.xdata$x:00008750 __catchsym$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:00008750                                         ; DATA XREF: .xdata$x:00008780o
.xdata$x:00008751                 db    0
.xdata$x:00008752                 db    0
.xdata$x:00008753                 db    0
.xdata$x:00008754                 db    0
.xdata$x:00008755                 db    0
.xdata$x:00008756                 db    0
.xdata$x:00008757                 db    0
.xdata$x:00008758                 db    0
.xdata$x:00008759                 db    0
.xdata$x:0000875A                 db    0
.xdata$x:0000875B                 db    0
.xdata$x:0000875C                 dd offset __catch$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:00008760 __unwindtable$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:00008760                                         ; DATA XREF: .xdata$x:0000878Co
.xdata$x:00008761                 db 0FFh
.xdata$x:00008762                 db 0FFh
.xdata$x:00008763                 db 0FFh
.xdata$x:00008764                 db    0
.xdata$x:00008765                 db    0
.xdata$x:00008766                 db    0
.xdata$x:00008767                 db    0
.xdata$x:00008768                 db 0FFh
.xdata$x:00008769                 db 0FFh
.xdata$x:0000876A                 db 0FFh
.xdata$x:0000876B                 db 0FFh
.xdata$x:0000876C                 db    0
.xdata$x:0000876D                 db    0
.xdata$x:0000876E                 db    0
.xdata$x:0000876F                 db    0
.xdata$x:00008770 __tryblocktable$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:00008770                                         ; DATA XREF: .xdata$x:00008794o
.xdata$x:00008771                 db    0
.xdata$x:00008772                 db    0
.xdata$x:00008773                 db    0
.xdata$x:00008774                 db    0
.xdata$x:00008775                 db    0
.xdata$x:00008776                 db    0
.xdata$x:00008777                 db    0
.xdata$x:00008778                 db    1
.xdata$x:00008779                 db    0
.xdata$x:0000877A                 db    0
.xdata$x:0000877B                 db    0
.xdata$x:0000877C                 db    1
.xdata$x:0000877D                 db    0
.xdata$x:0000877E                 db    0
.xdata$x:0000877F                 db    0
.xdata$x:00008780                 dd offset __catchsym$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:00008784 __ehfuncinfo$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:00008784                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:00008785                 db    5
.xdata$x:00008786                 db  93h ; ô
.xdata$x:00008787                 db  19h
.xdata$x:00008788                 db    2
.xdata$x:00008789                 db    0
.xdata$x:0000878A                 db    0
.xdata$x:0000878B                 db    0
.xdata$x:0000878C                 dd offset __unwindtable$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00008790                 db    1
.xdata$x:00008791                 db    0
.xdata$x:00008792                 db    0
.xdata$x:00008793                 db    0
.xdata$x:00008794                 dd offset __tryblocktable$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00008798                 db    0
.xdata$x:00008799                 db    0
.xdata$x:0000879A                 db    0
.xdata$x:0000879B                 db    0
.xdata$x:0000879C                 db    0
.xdata$x:0000879D                 db    0
.xdata$x:0000879E                 db    0
.xdata$x:0000879F                 db    0
.xdata$x:000087A0                 db    0
.xdata$x:000087A1                 db    0
.xdata$x:000087A2                 db    0
.xdata$x:000087A3                 db    0
.xdata$x:000087A4                 db    0
.xdata$x:000087A5                 db    0
.xdata$x:000087A6                 db    0
.xdata$x:000087A7                 db    0
.xdata$x:000087A7 _xdata$x        ends
.xdata$x:000087A7
.xdata$x:000087A8 ; ===========================================================================
.xdata$x:000087A8
.xdata$x:000087A8 ; Segment type: Pure data
.xdata$x:000087A8 ; Segment permissions: Read
.xdata$x:000087A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000087A8                 assume cs:_xdata$x
.xdata$x:000087A8                 ;org 87A8h
.xdata$x:000087A8 ; COMDAT (pick associative to section at 2B38)
.xdata$x:000087A8 __unwindtable$??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z db 0FFh
.xdata$x:000087A8                                         ; DATA XREF: .xdata$x:000087B8o
.xdata$x:000087A9                 db 0FFh
.xdata$x:000087AA                 db 0FFh
.xdata$x:000087AB                 db 0FFh
.xdata$x:000087AC                 dd offset __unwindfunclet$??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z$0
.xdata$x:000087B0 __ehfuncinfo$??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z db  22h ; "
.xdata$x:000087B0                                         ; DATA XREF: __ehhandler$??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z+11o
.xdata$x:000087B1                 db    5
.xdata$x:000087B2                 db  93h ; ô
.xdata$x:000087B3                 db  19h
.xdata$x:000087B4                 db    1
.xdata$x:000087B5                 db    0
.xdata$x:000087B6                 db    0
.xdata$x:000087B7                 db    0
.xdata$x:000087B8                 dd offset __unwindtable$??$construct@UtDynamicList@@U1@@?$allocator@UtDynamicList@@@std@@QAEXPAUtDynamicList@@$$QAU2@@Z
.xdata$x:000087BC                 db    0
.xdata$x:000087BD                 db    0
.xdata$x:000087BE                 db    0
.xdata$x:000087BF                 db    0
.xdata$x:000087C0                 db    0
.xdata$x:000087C1                 db    0
.xdata$x:000087C2                 db    0
.xdata$x:000087C3                 db    0
.xdata$x:000087C4                 db    0
.xdata$x:000087C5                 db    0
.xdata$x:000087C6                 db    0
.xdata$x:000087C7                 db    0
.xdata$x:000087C8                 db    0
.xdata$x:000087C9                 db    0
.xdata$x:000087CA                 db    0
.xdata$x:000087CB                 db    0
.xdata$x:000087CC                 db    0
.xdata$x:000087CD                 db    0
.xdata$x:000087CE                 db    0
.xdata$x:000087CF                 db    0
.xdata$x:000087D0                 db    0
.xdata$x:000087D1                 db    0
.xdata$x:000087D2                 db    0
.xdata$x:000087D3                 db    0
.xdata$x:000087D3 _xdata$x        ends
.xdata$x:000087D3
.bss:000087D4 ; ===========================================================================
.bss:000087D4
.bss:000087D4 ; Segment type: Uninitialized
.bss:000087D4 ; Segment permissions: Read/Write
.bss:000087D4 _bss            segment byte public 'BSS' use32
.bss:000087D4                 assume cs:_bss
.bss:000087D4                 ;org 87D4h
.bss:000087D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000087D4 _allocator_arg  db    ? ;
.bss:000087D5 _piecewise_construct db    ? ;
.bss:000087D6                 align 4
.bss:000087D6 _bss            ends
.bss:000087D6
.rdata:000087D8 ; ===========================================================================
.rdata:000087D8
.rdata:000087D8 ; Segment type: Pure data
.rdata:000087D8 ; Segment permissions: Read
.rdata:000087D8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000087D8 _rdata          segment para public 'DATA' use32
.rdata:000087D8                 assume cs:_rdata
.rdata:000087D8                 ;org 87D8h
.rdata:000087D8 ; COMDAT (pick any)
.rdata:000087D8                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000087D8 ; wchar_t `string'
.rdata:000087D8 ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000087D8                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+48o
.rdata:000087D8                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:000087D8                 unicode 0, <clude\xutility>,0
.rdata:000087D8 _rdata          ends
.rdata:000087D8
.rdata:00008868 ; ===========================================================================
.rdata:00008868
.rdata:00008868 ; Segment type: Pure data
.rdata:00008868 ; Segment permissions: Read
.rdata:00008868 _rdata          segment dword public 'DATA' use32
.rdata:00008868                 assume cs:_rdata
.rdata:00008868                 ;org 8868h
.rdata:00008868 ; COMDAT (pick any)
.rdata:00008868                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:00008868 ; wchar_t `string'
.rdata:00008868 ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:00008868                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:00008868                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:0000889A                 align 4
.rdata:0000889A _rdata          ends
.rdata:0000889A
.rdata:0000889C ; ===========================================================================
.rdata:0000889C
.rdata:0000889C ; Segment type: Pure data
.rdata:0000889C ; Segment permissions: Read
.rdata:0000889C _rdata          segment dword public 'DATA' use32
.rdata:0000889C                 assume cs:_rdata
.rdata:0000889C                 ;org 889Ch
.rdata:0000889C ; COMDAT (pick largest)
.rdata:0000889C                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:000088A0                 public ??_7runtime_error@std@@6B@
.rdata:000088A0 ; const std::runtime_error::`vftable'
.rdata:000088A0 ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:000088A0                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:000088A0                                         ; std::runtime_error::runtime_error(char const *)+3Co
.rdata:000088A0                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:000088A4                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:000088A4 _rdata          ends
.rdata:000088A4
.xdata$x:000088A8 ; ===========================================================================
.xdata$x:000088A8
.xdata$x:000088A8 ; Segment type: Pure data
.xdata$x:000088A8 ; Segment permissions: Read
.xdata$x:000088A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000088A8                 assume cs:_xdata$x
.xdata$x:000088A8                 ;org 88A8h
.xdata$x:000088A8 ; COMDAT (pick any)
.xdata$x:000088A8                 public __TI2?AVruntime_error@std@@
.xdata$x:000088A8 __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: ToolBar::reset(bool)+10Do
.xdata$x:000088A9                 db    0
.xdata$x:000088AA                 db    0
.xdata$x:000088AB                 db    0
.xdata$x:000088AC                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:000088B0                 db    0
.xdata$x:000088B1                 db    0
.xdata$x:000088B2                 db    0
.xdata$x:000088B3                 db    0
.xdata$x:000088B4                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:000088B4 _xdata$x        ends
.xdata$x:000088B4
.xdata$x:000088B8 ; ===========================================================================
.xdata$x:000088B8
.xdata$x:000088B8 ; Segment type: Pure data
.xdata$x:000088B8 ; Segment permissions: Read
.xdata$x:000088B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000088B8                 assume cs:_xdata$x
.xdata$x:000088B8                 ;org 88B8h
.xdata$x:000088B8 ; COMDAT (pick any)
.xdata$x:000088B8                 public __CTA2?AVruntime_error@std@@
.xdata$x:000088B8 __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:000088B4o
.xdata$x:000088B9                 db    0
.xdata$x:000088BA                 db    0
.xdata$x:000088BB                 db    0
.xdata$x:000088BC                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:000088C0                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:000088C0 _xdata$x        ends
.xdata$x:000088C0
.data$r:000088C4 ; ===========================================================================
.data$r:000088C4
.data$r:000088C4 ; Segment type: Pure data
.data$r:000088C4 ; Segment permissions: Read/Write
.data$r:000088C4 _data$r         segment dword public 'DATA' use32
.data$r:000088C4                 assume cs:_data$r
.data$r:000088C4                 ;org 88C4h
.data$r:000088C4 ; COMDAT (pick any)
.data$r:000088C4                 public ??_R0?AVruntime_error@std@@@8
.data$r:000088C4 ; class std::runtime_error `RTTI Type Descriptor'
.data$r:000088C4 ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000088C4                                         ; DATA XREF: .xdata$x:000088E8o
.data$r:000088C4                                         ; .rdata$r:00009104o ...
.data$r:000088C4                                         ; const type_info::`vftable'
.data$r:000088C8                 db    0
.data$r:000088C9                 db    0
.data$r:000088CA                 db    0
.data$r:000088CB                 db    0
.data$r:000088CC                 db  2Eh ; .
.data$r:000088CD                 db  3Fh ; ?
.data$r:000088CE                 db  41h ; A
.data$r:000088CF                 db  56h ; V
.data$r:000088D0                 db  72h ; r
.data$r:000088D1                 db  75h ; u
.data$r:000088D2                 db  6Eh ; n
.data$r:000088D3                 db  74h ; t
.data$r:000088D4                 db  69h ; i
.data$r:000088D5                 db  6Dh ; m
.data$r:000088D6                 db  65h ; e
.data$r:000088D7                 db  5Fh ; _
.data$r:000088D8                 db  65h ; e
.data$r:000088D9                 db  72h ; r
.data$r:000088DA                 db  72h ; r
.data$r:000088DB                 db  6Fh ; o
.data$r:000088DC                 db  72h ; r
.data$r:000088DD                 db  40h ; @
.data$r:000088DE                 db  73h ; s
.data$r:000088DF                 db  74h ; t
.data$r:000088E0                 db  64h ; d
.data$r:000088E1                 db  40h ; @
.data$r:000088E2                 db  40h ; @
.data$r:000088E3                 db    0
.data$r:000088E3 _data$r         ends
.data$r:000088E3
.xdata$x:000088E4 ; ===========================================================================
.xdata$x:000088E4
.xdata$x:000088E4 ; Segment type: Pure data
.xdata$x:000088E4 ; Segment permissions: Read
.xdata$x:000088E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000088E4                 assume cs:_xdata$x
.xdata$x:000088E4                 ;org 88E4h
.xdata$x:000088E4 ; COMDAT (pick any)
.xdata$x:000088E4                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:000088E4 __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:000088E4                                         ; DATA XREF: .xdata$x:000088BCo
.xdata$x:000088E5                 db    0
.xdata$x:000088E6                 db    0
.xdata$x:000088E7                 db    0
.xdata$x:000088E8                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:000088EC                 align 10h
.xdata$x:000088F0                 db 0FFh
.xdata$x:000088F1                 db 0FFh
.xdata$x:000088F2                 db 0FFh
.xdata$x:000088F3                 db 0FFh
.xdata$x:000088F4                 db    0
.xdata$x:000088F5                 db    0
.xdata$x:000088F6                 db    0
.xdata$x:000088F7                 db    0
.xdata$x:000088F8                 db  0Ch
.xdata$x:000088F9                 db    0
.xdata$x:000088FA                 db    0
.xdata$x:000088FB                 db    0
.xdata$x:000088FC                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:000088FC _xdata$x        ends
.xdata$x:000088FC
.data$r:00008900 ; ===========================================================================
.data$r:00008900
.data$r:00008900 ; Segment type: Pure data
.data$r:00008900 ; Segment permissions: Read/Write
.data$r:00008900 _data$r         segment dword public 'DATA' use32
.data$r:00008900                 assume cs:_data$r
.data$r:00008900                 ;org 8900h
.data$r:00008900 ; COMDAT (pick any)
.data$r:00008900                 public ??_R0?AVexception@std@@@8
.data$r:00008900 ; class std::exception `RTTI Type Descriptor'
.data$r:00008900 ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00008900                                         ; DATA XREF: .xdata$x:00008920o
.data$r:00008900                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00008900                                         ; const type_info::`vftable'
.data$r:00008904                 align 8
.data$r:00008908 a_?avexception@ db '.?AVexception@std@@',0
.data$r:00008908 _data$r         ends
.data$r:00008908
.xdata$x:0000891C ; ===========================================================================
.xdata$x:0000891C
.xdata$x:0000891C ; Segment type: Pure data
.xdata$x:0000891C ; Segment permissions: Read
.xdata$x:0000891C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000891C                 assume cs:_xdata$x
.xdata$x:0000891C                 ;org 891Ch
.xdata$x:0000891C ; COMDAT (pick any)
.xdata$x:0000891C                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:0000891C __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:0000891C                                         ; DATA XREF: .xdata$x:000088C0o
.xdata$x:0000891D                 db    0
.xdata$x:0000891E                 db    0
.xdata$x:0000891F                 db    0
.xdata$x:00008920                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:00008924                 align 8
.xdata$x:00008928                 db 0FFh
.xdata$x:00008929                 db 0FFh
.xdata$x:0000892A                 db 0FFh
.xdata$x:0000892B                 db 0FFh
.xdata$x:0000892C                 db    0
.xdata$x:0000892D                 db    0
.xdata$x:0000892E                 db    0
.xdata$x:0000892F                 db    0
.xdata$x:00008930                 db  0Ch
.xdata$x:00008931                 db    0
.xdata$x:00008932                 db    0
.xdata$x:00008933                 db    0
.xdata$x:00008934                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:00008934 _xdata$x        ends
.xdata$x:00008934
.rdata:00008938 ; ===========================================================================
.rdata:00008938
.rdata:00008938 ; Segment type: Pure data
.rdata:00008938 ; Segment permissions: Read
.rdata:00008938 _rdata          segment dword public 'DATA' use32
.rdata:00008938                 assume cs:_rdata
.rdata:00008938                 ;org 8938h
.rdata:00008938 ; COMDAT (pick largest)
.rdata:00008938                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:0000893C                 public ??_7error_category@std@@6B@
.rdata:0000893C ; const std::error_category::`vftable'
.rdata:0000893C ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:0000893C                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:0000893C                                         ; std::error_category::~error_category(void)+Ao
.rdata:0000893C                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00008940                 dd offset __purecall
.rdata:00008944                 dd offset __purecall
.rdata:00008948                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000894C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00008950                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00008950 _rdata          ends
.rdata:00008950
.rdata:00008954 ; ===========================================================================
.rdata:00008954
.rdata:00008954 ; Segment type: Pure data
.rdata:00008954 ; Segment permissions: Read
.rdata:00008954 _rdata          segment dword public 'DATA' use32
.rdata:00008954                 assume cs:_rdata
.rdata:00008954                 ;org 8954h
.rdata:00008954 ; COMDAT (pick largest)
.rdata:00008954                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00008958                 public ??_7_Generic_error_category@std@@6B@
.rdata:00008958 ; const std::_Generic_error_category::`vftable'
.rdata:00008958 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00008958                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00008958                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:0000895C                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00008960                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00008964                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00008968                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000896C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000896C _rdata          ends
.rdata:0000896C
.rdata:00008970 ; ===========================================================================
.rdata:00008970
.rdata:00008970 ; Segment type: Pure data
.rdata:00008970 ; Segment permissions: Read
.rdata:00008970 _rdata          segment dword public 'DATA' use32
.rdata:00008970                 assume cs:_rdata
.rdata:00008970                 ;org 8970h
.rdata:00008970 ; COMDAT (pick any)
.rdata:00008970                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00008970 ; `string'
.rdata:00008970 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00008970                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00008970 _rdata          ends
.rdata:00008970
.rdata:00008978 ; ===========================================================================
.rdata:00008978
.rdata:00008978 ; Segment type: Pure data
.rdata:00008978 ; Segment permissions: Read
.rdata:00008978 _rdata          segment dword public 'DATA' use32
.rdata:00008978                 assume cs:_rdata
.rdata:00008978                 ;org 8978h
.rdata:00008978 ; COMDAT (pick any)
.rdata:00008978                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00008978 ; `string'
.rdata:00008978 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00008978                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_71FCo
.rdata:00008978                                         ; std::_System_error_category::message(int):loc_7378o
.rdata:00008986                 align 4
.rdata:00008986 _rdata          ends
.rdata:00008986
.rdata:00008988 ; ===========================================================================
.rdata:00008988
.rdata:00008988 ; Segment type: Pure data
.rdata:00008988 ; Segment permissions: Read
.rdata:00008988 _rdata          segment dword public 'DATA' use32
.rdata:00008988                 assume cs:_rdata
.rdata:00008988                 ;org 8988h
.rdata:00008988 ; COMDAT (pick largest)
.rdata:00008988                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:0000898C                 public ??_7_Iostream_error_category@std@@6B@
.rdata:0000898C ; const std::_Iostream_error_category::`vftable'
.rdata:0000898C ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:0000898C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:0000898C                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00008990                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00008994                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00008998                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000899C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000089A0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000089A0 _rdata          ends
.rdata:000089A0
.rdata:000089A4 ; ===========================================================================
.rdata:000089A4
.rdata:000089A4 ; Segment type: Pure data
.rdata:000089A4 ; Segment permissions: Read
.rdata:000089A4 _rdata          segment dword public 'DATA' use32
.rdata:000089A4                 assume cs:_rdata
.rdata:000089A4                 ;org 89A4h
.rdata:000089A4 ; COMDAT (pick any)
.rdata:000089A4                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:000089A4 ; `string'
.rdata:000089A4 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:000089A4                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:000089AD                 align 10h
.rdata:000089AD _rdata          ends
.rdata:000089AD
.rdata:000089B0 ; ===========================================================================
.rdata:000089B0
.rdata:000089B0 ; Segment type: Pure data
.rdata:000089B0 ; Segment permissions: Read
.rdata:000089B0 _rdata          segment dword public 'DATA' use32
.rdata:000089B0                 assume cs:_rdata
.rdata:000089B0                 ;org 89B0h
.rdata:000089B0 ; COMDAT (pick any)
.rdata:000089B0                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:000089B0 ; char `string'[]
.rdata:000089B0 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:000089B0                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:000089C6                 align 4
.rdata:000089C6 _rdata          ends
.rdata:000089C6
.rdata:000089C8 ; ===========================================================================
.rdata:000089C8
.rdata:000089C8 ; Segment type: Pure data
.rdata:000089C8 ; Segment permissions: Read
.rdata:000089C8 _rdata          segment dword public 'DATA' use32
.rdata:000089C8                 assume cs:_rdata
.rdata:000089C8                 ;org 89C8h
.rdata:000089C8 ; COMDAT (pick largest)
.rdata:000089C8                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:000089CC                 public ??_7_System_error_category@std@@6B@
.rdata:000089CC ; const std::_System_error_category::`vftable'
.rdata:000089CC ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:000089CC                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:000089CC                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:000089D0                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:000089D4                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:000089D8                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:000089DC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000089E0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000089E0 _rdata          ends
.rdata:000089E0
.rdata:000089E4 ; ===========================================================================
.rdata:000089E4
.rdata:000089E4 ; Segment type: Pure data
.rdata:000089E4 ; Segment permissions: Read
.rdata:000089E4 _rdata          segment dword public 'DATA' use32
.rdata:000089E4                 assume cs:_rdata
.rdata:000089E4                 ;org 89E4h
.rdata:000089E4 ; COMDAT (pick any)
.rdata:000089E4                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:000089E4 ; `string'
.rdata:000089E4 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:000089E4                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:000089EB                 align 4
.rdata:000089EB _rdata          ends
.rdata:000089EB
.bss:000089EC ; ===========================================================================
.bss:000089EC
.bss:000089EC ; Segment type: Uninitialized
.bss:000089EC ; Segment permissions: Read/Write
.bss:000089EC _bss            segment dword public 'BSS' use32
.bss:000089EC                 assume cs:_bss
.bss:000089EC                 ;org 89ECh
.bss:000089EC ; COMDAT (pick any)
.bss:000089EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000089EC                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:000089EC ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:000089EC ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:000089EC                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:000089EC                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:000089ED                 db    ? ;
.bss:000089EE                 db    ? ;
.bss:000089EF                 db    ? ;
.bss:000089EF _bss            ends
.bss:000089EF
.bss:000089F0 ; ===========================================================================
.bss:000089F0
.bss:000089F0 ; Segment type: Uninitialized
.bss:000089F0 ; Segment permissions: Read/Write
.bss:000089F0 _bss            segment dword public 'BSS' use32
.bss:000089F0                 assume cs:_bss
.bss:000089F0                 ;org 89F0h
.bss:000089F0 ; COMDAT (pick any)
.bss:000089F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000089F0                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:000089F0 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:000089F0 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:000089F0                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000089F0                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000089F1                 db    ? ;
.bss:000089F2                 db    ? ;
.bss:000089F3                 db    ? ;
.bss:000089F3 _bss            ends
.bss:000089F3
.bss:000089F4 ; ===========================================================================
.bss:000089F4
.bss:000089F4 ; Segment type: Uninitialized
.bss:000089F4 ; Segment permissions: Read/Write
.bss:000089F4 _bss            segment dword public 'BSS' use32
.bss:000089F4                 assume cs:_bss
.bss:000089F4                 ;org 89F4h
.bss:000089F4 ; COMDAT (pick any)
.bss:000089F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000089F4                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:000089F4 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:000089F4 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:000089F4                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:000089F4                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:000089F5                 db    ? ;
.bss:000089F6                 db    ? ;
.bss:000089F7                 db    ? ;
.bss:000089F7 _bss            ends
.bss:000089F7
.rdata:000089F8 ; ===========================================================================
.rdata:000089F8
.rdata:000089F8 ; Segment type: Pure data
.rdata:000089F8 ; Segment permissions: Read
.rdata:000089F8 _rdata          segment dword public 'DATA' use32
.rdata:000089F8                 assume cs:_rdata
.rdata:000089F8                 ;org 89F8h
.rdata:000089F8 ; COMDAT (pick any)
.rdata:000089F8                 public ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
.rdata:000089F8 ; public: static unsigned int const std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::npos
.rdata:000089F8 ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB dd 0FFFFFFFFh
.rdata:000089F8                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Br
.rdata:000089F8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+3Dr ...
.rdata:000089F8 _rdata          ends
.rdata:000089F8
.bss:000089FC ; ===========================================================================
.bss:000089FC
.bss:000089FC ; Segment type: Uninitialized
.bss:000089FC ; Segment permissions: Read/Write
.bss:000089FC _bss            segment dword public 'BSS' use32
.bss:000089FC                 assume cs:_bss
.bss:000089FC                 ;org 89FCh
.bss:000089FC ; COMDAT (pick any)
.bss:000089FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000089FC                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:000089FC ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:000089FC ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:000089FC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:000089FD                 db    ? ;
.bss:000089FE                 db    ? ;
.bss:000089FF                 db    ? ;
.bss:000089FF _bss            ends
.bss:000089FF
.bss:00008A00 ; ===========================================================================
.bss:00008A00
.bss:00008A00 ; Segment type: Uninitialized
.bss:00008A00 ; Segment permissions: Read/Write
.bss:00008A00 _bss            segment dword public 'BSS' use32
.bss:00008A00                 assume cs:_bss
.bss:00008A00                 ;org 8A00h
.bss:00008A00 ; COMDAT (pick any)
.bss:00008A00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00008A00                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00008A00 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00008A00 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00008A00                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00008A01                 db    ? ;
.bss:00008A02                 db    ? ;
.bss:00008A03                 db    ? ;
.bss:00008A03 _bss            ends
.bss:00008A03
.rdata:00008A04 ; ===========================================================================
.rdata:00008A04
.rdata:00008A04 ; Segment type: Pure data
.rdata:00008A04 ; Segment permissions: Read
.rdata:00008A04 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00008A04 _rdata          segment para public 'DATA' use32
.rdata:00008A04                 assume cs:_rdata
.rdata:00008A04                 ;org 8A04h
.rdata:00008A04 ; COMDAT (pick any)
.rdata:00008A04                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00008A04 ; wchar_t `string'
.rdata:00008A04 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00008A04                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+Co
.rdata:00008A04                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+14o ...
.rdata:00008A04                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00008A04                 unicode 0, <clude\xstring>,0
.rdata:00008A92                 align 4
.rdata:00008A92 _rdata          ends
.rdata:00008A92
.bss:00008A94 ; ===========================================================================
.bss:00008A94
.bss:00008A94 ; Segment type: Uninitialized
.bss:00008A94 ; Segment permissions: Read/Write
.bss:00008A94 _bss            segment dword public 'BSS' use32
.bss:00008A94                 assume cs:_bss
.bss:00008A94                 ;org 8A94h
.bss:00008A94 ; COMDAT (pick any)
.bss:00008A94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00008A94                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00008A94 ; std::locale::id std::numpunct<char>::id
.bss:00008A94 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00008A94                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00008A95                 db    ? ;
.bss:00008A96                 db    ? ;
.bss:00008A97                 db    ? ;
.bss:00008A97 _bss            ends
.bss:00008A97
.bss:00008A98 ; ===========================================================================
.bss:00008A98
.bss:00008A98 ; Segment type: Uninitialized
.bss:00008A98 ; Segment permissions: Read/Write
.bss:00008A98 _bss            segment dword public 'BSS' use32
.bss:00008A98                 assume cs:_bss
.bss:00008A98                 ;org 8A98h
.bss:00008A98 ; COMDAT (pick any)
.bss:00008A98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00008A98                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00008A98 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00008A98 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00008A98                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00008A99                 db    ? ;
.bss:00008A9A                 db    ? ;
.bss:00008A9B                 db    ? ;
.bss:00008A9B _bss            ends
.bss:00008A9B
.rdata:00008A9C ; ===========================================================================
.rdata:00008A9C
.rdata:00008A9C ; Segment type: Pure data
.rdata:00008A9C ; Segment permissions: Read
.rdata:00008A9C ; Segment alignment 'qword' can not be represented in assembly
.rdata:00008A9C _rdata          segment para public 'DATA' use32
.rdata:00008A9C                 assume cs:_rdata
.rdata:00008A9C                 ;org 8A9Ch
.rdata:00008A9C ; COMDAT (pick any)
.rdata:00008A9C                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00008A9C ; wchar_t `string'
.rdata:00008A9C ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00008A9C                                         ; DATA XREF: std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)+19o
.rdata:00008A9C                                         ; std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)+49o ...
.rdata:00008A9C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00008A9C                 unicode 0, <clude\vector>,0
.rdata:00008A9C _rdata          ends
.rdata:00008A9C
.rdata:00008B28 ; ===========================================================================
.rdata:00008B28
.rdata:00008B28 ; Segment type: Pure data
.rdata:00008B28 ; Segment permissions: Read
.rdata:00008B28 _rdata          segment dword public 'DATA' use32
.rdata:00008B28                 assume cs:_rdata
.rdata:00008B28                 ;org 8B28h
.rdata:00008B28 ; COMDAT (pick any)
.rdata:00008B28                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:00008B28 ; wchar_t `string'
.rdata:00008B28 ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:00008B28                                         ; DATA XREF: std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)+1Eo
.rdata:00008B28                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::operator[](uint)+1Eo ...
.rdata:00008B28                 unicode 0, <vector subscript out of range>,0
.rdata:00008B28 _rdata          ends
.rdata:00008B28
.rdata:00008B64 ; ===========================================================================
.rdata:00008B64
.rdata:00008B64 ; Segment type: Pure data
.rdata:00008B64 ; Segment permissions: Read
.rdata:00008B64 _rdata          segment dword public 'DATA' use32
.rdata:00008B64                 assume cs:_rdata
.rdata:00008B64                 ;org 8B64h
.rdata:00008B64 ; COMDAT (pick any)
.rdata:00008B64                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:00008B64 ; `string'
.rdata:00008B64 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:00008B64                                         ; DATA XREF: std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)+2Bo
.rdata:00008B64                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::operator[](uint)+2Bo ...
.rdata:00008B64 _rdata          ends
.rdata:00008B64
.rdata:00008B88 ; ===========================================================================
.rdata:00008B88
.rdata:00008B88 ; Segment type: Pure data
.rdata:00008B88 ; Segment permissions: Read
.rdata:00008B88 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00008B88 _rdata          segment para public 'DATA' use32
.rdata:00008B88                 assume cs:_rdata
.rdata:00008B88                 ;org 8B88h
.rdata:00008B88 ; COMDAT (pick any)
.rdata:00008B88                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:00008B88 ; `string'
.rdata:00008B88 ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:00008B88                                         ; DATA XREF: std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint):loc_4308o
.rdata:00008B88                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::operator[](uint):loc_4394o ...
.rdata:00008B88                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:00008BDE                 align 10h
.rdata:00008BDE _rdata          ends
.rdata:00008BDE
.rdata:00008BE0 ; ===========================================================================
.rdata:00008BE0
.rdata:00008BE0 ; Segment type: Pure data
.rdata:00008BE0 ; Segment permissions: Read
.rdata:00008BE0 _rdata          segment dword public 'DATA' use32
.rdata:00008BE0                 assume cs:_rdata
.rdata:00008BE0                 ;org 8BE0h
.rdata:00008BE0 ; COMDAT (pick any)
.rdata:00008BE0                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:00008BE0 ; `string'
.rdata:00008BE0 ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:00008BE0                                         ; DATA XREF: std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)+3Do
.rdata:00008BE0                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::operator[](uint)+3Do ...
.rdata:00008BE0                 unicode 0, <%s>,0
.rdata:00008BE6                 align 4
.rdata:00008BE6 _rdata          ends
.rdata:00008BE6
.rdata:00008BE8 ; ===========================================================================
.rdata:00008BE8
.rdata:00008BE8 ; Segment type: Pure data
.rdata:00008BE8 ; Segment permissions: Read
.rdata:00008BE8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00008BE8 _rdata          segment para public 'DATA' use32
.rdata:00008BE8                 assume cs:_rdata
.rdata:00008BE8                 ;org 8BE8h
.rdata:00008BE8 ; COMDAT (pick any)
.rdata:00008BE8                 public ??_C@_1JO@BHIHLBBA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAI?$AAc?$AAo?$AAn?$AAL?$AAi?$AAs?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@
.rdata:00008BE8 ; `string'
.rdata:00008BE8 ??_C@_1JO@BHIHLBBA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAI?$AAc?$AAo?$AAn?$AAL?$AAi?$AAs?$AAt?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs@:
.rdata:00008BE8                                         ; DATA XREF: std::vector<IconList,std::allocator<IconList>>::operator[](uint)+6Ao
.rdata:00008BE8                 unicode 0, <std::vector>
.rdata:00008BE8                 dw 3Ch
.rdata:00008BE8                 unicode 0, <class IconList,class std::allocator>
.rdata:00008BE8                 dw 3Ch
.rdata:00008BE8                 unicode 0, <class IconList>
.rdata:00008BE8                 dw 3Eh
.rdata:00008BE8                 unicode 0, < >
.rdata:00008BE8                 dw 3Eh
.rdata:00008BE8                 unicode 0, <::operator []>,0
.rdata:00008C86                 align 4
.rdata:00008C86 _rdata          ends
.rdata:00008C86
.rdata:00008C88 ; ===========================================================================
.rdata:00008C88
.rdata:00008C88 ; Segment type: Pure data
.rdata:00008C88 ; Segment permissions: Read
.rdata:00008C88 _rdata          segment dword public 'DATA' use32
.rdata:00008C88                 assume cs:_rdata
.rdata:00008C88                 ;org 8C88h
.rdata:00008C88 ; COMDAT (pick any)
.rdata:00008C88                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:00008C88 ; `string'
.rdata:00008C88 ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:00008C88                                         ; DATA XREF: std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)+6Fo
.rdata:00008C88                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::operator[](uint)+6Fo ...
.rdata:00008C88                 unicode 0, <"out of range">,0
.rdata:00008CA6                 align 4
.rdata:00008CA6 _rdata          ends
.rdata:00008CA6
.rdata:00008CA8 ; ===========================================================================
.rdata:00008CA8
.rdata:00008CA8 ; Segment type: Pure data
.rdata:00008CA8 ; Segment permissions: Read
.rdata:00008CA8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00008CA8 _rdata          segment para public 'DATA' use32
.rdata:00008CA8                 assume cs:_rdata
.rdata:00008CA8                 ;org 8CA8h
.rdata:00008CA8 ; COMDAT (pick any)
.rdata:00008CA8                 public ??_C@_1MG@CCKBFFHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAT?$AAo?$AAo?$AAl?$AAB?$AAa?$AAr?$AAB?$AAu?$AAt?$AAt?$AAo?$AAn@
.rdata:00008CA8 ; `string'
.rdata:00008CA8 ??_C@_1MG@CCKBFFHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAT?$AAo?$AAo?$AAl?$AAB?$AAa?$AAr?$AAB?$AAu?$AAt?$AAt?$AAo?$AAn@:
.rdata:00008CA8                                         ; DATA XREF: std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)+6Ao
.rdata:00008CA8                 unicode 0, <std::vector>
.rdata:00008CA8                 dw 3Ch
.rdata:00008CA8                 unicode 0, <struct ToolBarButtonUnit,class std::allocator>
.rdata:00008CA8                 dw 3Ch
.rdata:00008CA8                 unicode 0, <struct ToolBarButtonUnit>
.rdata:00008CA8                 dw 3Eh
.rdata:00008CA8                 unicode 0, < >
.rdata:00008CA8                 dw 3Eh
.rdata:00008CA8                 unicode 0, <::operator []>,0
.rdata:00008D6E                 align 10h
.rdata:00008D6E _rdata          ends
.rdata:00008D6E
.rdata:00008D70 ; ===========================================================================
.rdata:00008D70
.rdata:00008D70 ; Segment type: Pure data
.rdata:00008D70 ; Segment permissions: Read
.rdata:00008D70 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00008D70 _rdata          segment para public 'DATA' use32
.rdata:00008D70                 assume cs:_rdata
.rdata:00008D70                 ;org 8D70h
.rdata:00008D70 ; COMDAT (pick any)
.rdata:00008D70                 public ??_C@_1LC@PNCOBLPJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAt?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AAL?$AAi?$AAs?$AAt?$AA?0@
.rdata:00008D70 ; `string'
.rdata:00008D70 ??_C@_1LC@PNCOBLPJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAs?$AAt?$AAr?$AAu?$AAc?$AAt?$AA?5?$AAt?$AAD?$AAy?$AAn?$AAa?$AAm?$AAi?$AAc?$AAL?$AAi?$AAs?$AAt?$AA?0@:
.rdata:00008D70                                         ; DATA XREF: std::vector<tDynamicList,std::allocator<tDynamicList>>::operator[](uint)+6Ao
.rdata:00008D70                 unicode 0, <std::vector>
.rdata:00008D70                 dw 3Ch
.rdata:00008D70                 unicode 0, <struct tDynamicList,class std::allocator>
.rdata:00008D70                 dw 3Ch
.rdata:00008D70                 unicode 0, <struct tDynamicList>
.rdata:00008D70                 dw 3Eh
.rdata:00008D70                 unicode 0, < >
.rdata:00008D70                 dw 3Eh
.rdata:00008D70                 unicode 0, <::operator []>,0
.rdata:00008E22                 align 4
.rdata:00008E22 _rdata          ends
.rdata:00008E22
.rdata:00008E24 ; ===========================================================================
.rdata:00008E24
.rdata:00008E24 ; Segment type: Pure data
.rdata:00008E24 ; Segment permissions: Read
.rdata:00008E24 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00008E24 _rdata          segment para public 'DATA' use32
.rdata:00008E24                 assume cs:_rdata
.rdata:00008E24                 ;org 8E24h
.rdata:00008E24 ; COMDAT (pick any)
.rdata:00008E24                 public ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
.rdata:00008E24 ; wchar_t `string'
.rdata:00008E24 ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@:
.rdata:00008E24                                         ; DATA XREF: std::vector<int,std::allocator<int>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>)+63o
.rdata:00008E24                 unicode 0, <vector erase iterator outside range>,0
.rdata:00008E24 _rdata          ends
.rdata:00008E24
.rdata:00008E6C ; ===========================================================================
.rdata:00008E6C
.rdata:00008E6C ; Segment type: Pure data
.rdata:00008E6C ; Segment permissions: Read
.rdata:00008E6C _rdata          segment dword public 'DATA' use32
.rdata:00008E6C                 assume cs:_rdata
.rdata:00008E6C                 ;org 8E6Ch
.rdata:00008E6C ; COMDAT (pick any)
.rdata:00008E6C                 public ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
.rdata:00008E6C ; char `string'[]
.rdata:00008E6C ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ db 'invalid vector<T> subscript',0
.rdata:00008E6C                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Xran(void)+7o
.rdata:00008E6C                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::_Xran(void)+7o
.rdata:00008E6C _rdata          ends
.rdata:00008E6C
.rdata:00008E88 ; ===========================================================================
.rdata:00008E88
.rdata:00008E88 ; Segment type: Pure data
.rdata:00008E88 ; Segment permissions: Read
.rdata:00008E88 _rdata          segment dword public 'DATA' use32
.rdata:00008E88                 assume cs:_rdata
.rdata:00008E88                 ;org 8E88h
.rdata:00008E88 ; COMDAT (pick any)
.rdata:00008E88                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00008E88 ; char `string'[]
.rdata:00008E88 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00008E88                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00008E88                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:00008E88 _rdata          ends
.rdata:00008E88
.rdata:00008E98 ; ===========================================================================
.rdata:00008E98
.rdata:00008E98 ; Segment type: Pure data
.rdata:00008E98 ; Segment permissions: Read
.rdata:00008E98 _rdata          segment dword public 'DATA' use32
.rdata:00008E98                 assume cs:_rdata
.rdata:00008E98                 ;org 8E98h
.rdata:00008E98 ; COMDAT (pick any)
.rdata:00008E98                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00008E98 ; char `string'[]
.rdata:00008E98 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00008E98                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00008E98                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:00008E98 _rdata          ends
.rdata:00008E98
.rdata:00008EB0 ; ===========================================================================
.rdata:00008EB0
.rdata:00008EB0 ; Segment type: Pure data
.rdata:00008EB0 ; Segment permissions: Read
.rdata:00008EB0 _rdata          segment dword public 'DATA' use32
.rdata:00008EB0                 assume cs:_rdata
.rdata:00008EB0                 ;org 8EB0h
.rdata:00008EB0 ; COMDAT (pick any)
.rdata:00008EB0                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:00008EB0 ; char `string'[]
.rdata:00008EB0 ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:00008EB0                                         ; DATA XREF: std::vector<int,std::allocator<int>>::_Xlen(void)+7o
.rdata:00008EB0                                         ; std::vector<iconLocator,std::allocator<iconLocator>>::_Xlen(void)+7o ...
.rdata:00008EC3                 align 4
.rdata:00008EC3 _rdata          ends
.rdata:00008EC3
.rdata:00008EC4 ; ===========================================================================
.rdata:00008EC4
.rdata:00008EC4 ; Segment type: Pure data
.rdata:00008EC4 ; Segment permissions: Read
.rdata:00008EC4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00008EC4 _rdata          segment para public 'DATA' use32
.rdata:00008EC4                 assume cs:_rdata
.rdata:00008EC4                 ;org 8EC4h
.rdata:00008EC4 ; COMDAT (pick any)
.rdata:00008EC4                 public ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
.rdata:00008EC4 ; wchar_t `string'
.rdata:00008EC4 ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@:
.rdata:00008EC4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+=(int)+50o
.rdata:00008EC4                 unicode 0, <vector iterator + offset out of range>,0
.rdata:00008EC4 _rdata          ends
.rdata:00008EC4
.rdata:00008F10 ; ===========================================================================
.rdata:00008F10
.rdata:00008F10 ; Segment type: Pure data
.rdata:00008F10 ; Segment permissions: Read
.rdata:00008F10 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00008F10 _rdata          segment para public 'DATA' use32
.rdata:00008F10                 assume cs:_rdata
.rdata:00008F10                 ;org 8F10h
.rdata:00008F10 ; COMDAT (pick any)
.rdata:00008F10                 public ??_C@_1MG@JKKENLGC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:00008F10 ; `string'
.rdata:00008F10 ??_C@_1MG@JKKENLGC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:00008F10                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int>>>::operator+=(int)+9Co
.rdata:00008F10                 unicode 0, <std::_Vector_const_iterator>
.rdata:00008F10                 dw 3Ch
.rdata:00008F10                 unicode 0, <class std::_Vector_val>
.rdata:00008F10                 dw 3Ch
.rdata:00008F10                 unicode 0, <struct std::_Simple_types>
.rdata:00008F10                 dw 3Ch
.rdata:00008F10                 unicode 0, <int>
.rdata:00008F10                 dw 3Eh
.rdata:00008F10                 unicode 0, < >
.rdata:00008F10                 dw 3Eh
.rdata:00008F10                 unicode 0, < >
.rdata:00008F10                 dw 3Eh
.rdata:00008F10                 unicode 0, <::operator +=>,0
.rdata:00008FD6                 align 4
.rdata:00008FD6 _rdata          ends
.rdata:00008FD6
.rdata:00008FD8 ; ===========================================================================
.rdata:00008FD8
.rdata:00008FD8 ; Segment type: Pure data
.rdata:00008FD8 ; Segment permissions: Read
.rdata:00008FD8 _rdata          segment dword public 'DATA' use32
.rdata:00008FD8                 assume cs:_rdata
.rdata:00008FD8                 ;org 8FD8h
.rdata:00008FD8 ; COMDAT (pick any)
.rdata:00008FD8                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00008FD8 ; wchar_t `string'
.rdata:00008FD8 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00008FD8                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00008FD8                                         ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)+11o ...
.rdata:00008FD8                 unicode 0, <invalid null pointer>,0
.rdata:00009002                 align 4
.rdata:00009002 _rdata          ends
.rdata:00009002
.rdata:00009004 ; ===========================================================================
.rdata:00009004
.rdata:00009004 ; Segment type: Pure data
.rdata:00009004 ; Segment permissions: Read
.rdata:00009004 _rdata          segment dword public 'DATA' use32
.rdata:00009004                 assume cs:_rdata
.rdata:00009004                 ;org 9004h
.rdata:00009004 ; COMDAT (pick any)
.rdata:00009004                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:00009004 ; wchar_t `string'
.rdata:00009004 ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:00009004                                         ; DATA XREF: std::_Debug_range2<int *>(int *,int *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:00009004                                         ; std::_Debug_range2<iconLocator *>(iconLocator *,iconLocator *,wchar_t const *,uint,std::random_access_iterator_tag)+43o ...
.rdata:00009004                 unicode 0, <invalid iterator range>,0
.rdata:00009032                 align 4
.rdata:00009032 _rdata          ends
.rdata:00009032
.rdata:00009034 ; ===========================================================================
.rdata:00009034
.rdata:00009034 ; Segment type: Pure data
.rdata:00009034 ; Segment permissions: Read
.rdata:00009034 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00009034 _rdata          segment para public 'DATA' use32
.rdata:00009034                 assume cs:_rdata
.rdata:00009034                 ;org 9034h
.rdata:00009034 ; COMDAT (pick any)
.rdata:00009034                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00009034 ; wchar_t `string'
.rdata:00009034 ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00009034                                         ; DATA XREF: std::_Uninit_move<int,int,int>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)+9o
.rdata:00009034                                         ; std::_Uninit_move<int,int,int>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)+23o ...
.rdata:00009034                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00009034                 unicode 0, <clude\xmemory>,0
.rdata:000090C2                 align 4
.rdata:000090C2 _rdata          ends
.rdata:000090C2
.rdata$r:000090C4 ; ===========================================================================
.rdata$r:000090C4
.rdata$r:000090C4 ; Segment type: Pure data
.rdata$r:000090C4 ; Segment permissions: Read
.rdata$r:000090C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000090C4                 assume cs:_rdata$r
.rdata$r:000090C4                 ;org 90C4h
.rdata$r:000090C4 ; COMDAT (pick any)
.rdata$r:000090C4                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:000090C4 ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000090C4 ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:000090C4                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:000090C4                                         ; .rdata$r:00009120o
.rdata$r:000090C4                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:000090C8                 align 10h
.rdata$r:000090D0                 db 0FFh
.rdata$r:000090D1                 db 0FFh
.rdata$r:000090D2                 db 0FFh
.rdata$r:000090D3                 db 0FFh
.rdata$r:000090D4                 db    0
.rdata$r:000090D5                 db    0
.rdata$r:000090D6                 db    0
.rdata$r:000090D7                 db    0
.rdata$r:000090D8                 db  40h ; @
.rdata$r:000090D9                 db    0
.rdata$r:000090DA                 db    0
.rdata$r:000090DB                 db    0
.rdata$r:000090DC                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:000090DC _rdata$r        ends
.rdata$r:000090DC
.rdata$r:000090E0 ; ===========================================================================
.rdata$r:000090E0
.rdata$r:000090E0 ; Segment type: Pure data
.rdata$r:000090E0 ; Segment permissions: Read
.rdata$r:000090E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000090E0                 assume cs:_rdata$r
.rdata$r:000090E0                 ;org 90E0h
.rdata$r:000090E0 ; COMDAT (pick any)
.rdata$r:000090E0                 public ??_R3exception@std@@8
.rdata$r:000090E0 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:000090E0 ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:000090DCo
.rdata$r:000090E1                 db    0
.rdata$r:000090E2                 db    0
.rdata$r:000090E3                 db    0
.rdata$r:000090E4                 db    0
.rdata$r:000090E5                 db    0
.rdata$r:000090E6                 db    0
.rdata$r:000090E7                 db    0
.rdata$r:000090E8                 db    1
.rdata$r:000090E9                 db    0
.rdata$r:000090EA                 db    0
.rdata$r:000090EB                 db    0
.rdata$r:000090EC                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:000090EC _rdata$r        ends
.rdata$r:000090EC
.rdata$r:000090F0 ; ===========================================================================
.rdata$r:000090F0
.rdata$r:000090F0 ; Segment type: Pure data
.rdata$r:000090F0 ; Segment permissions: Read
.rdata$r:000090F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000090F0                 assume cs:_rdata$r
.rdata$r:000090F0                 ;org 90F0h
.rdata$r:000090F0 ; COMDAT (pick any)
.rdata$r:000090F0                 public ??_R2exception@std@@8
.rdata$r:000090F0 ; std::exception::`RTTI Base Class Array'
.rdata$r:000090F0 ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:000090F0                                         ; DATA XREF: .rdata$r:000090ECo
.rdata$r:000090F0                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000090F4                 db    0
.rdata$r:000090F5                 align 4
.rdata$r:000090F5 _rdata$r        ends
.rdata$r:000090F5
.rdata$r:000090F8 ; ===========================================================================
.rdata$r:000090F8
.rdata$r:000090F8 ; Segment type: Pure data
.rdata$r:000090F8 ; Segment permissions: Read
.rdata$r:000090F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000090F8                 assume cs:_rdata$r
.rdata$r:000090F8                 ;org 90F8h
.rdata$r:000090F8 ; COMDAT (pick any)
.rdata$r:000090F8                 public ??_R4runtime_error@std@@6B@
.rdata$r:000090F8 ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:000090F8 ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:0000889Co
.rdata$r:000090F9                 db    0
.rdata$r:000090FA                 db    0
.rdata$r:000090FB                 db    0
.rdata$r:000090FC                 db    0
.rdata$r:000090FD                 db    0
.rdata$r:000090FE                 db    0
.rdata$r:000090FF                 db    0
.rdata$r:00009100                 db    0
.rdata$r:00009101                 db    0
.rdata$r:00009102                 db    0
.rdata$r:00009103                 db    0
.rdata$r:00009104                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00009108                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009108 _rdata$r        ends
.rdata$r:00009108
.rdata$r:0000910C ; ===========================================================================
.rdata$r:0000910C
.rdata$r:0000910C ; Segment type: Pure data
.rdata$r:0000910C ; Segment permissions: Read
.rdata$r:0000910C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000910C                 assume cs:_rdata$r
.rdata$r:0000910C                 ;org 910Ch
.rdata$r:0000910C ; COMDAT (pick any)
.rdata$r:0000910C                 public ??_R3runtime_error@std@@8
.rdata$r:0000910C ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000910C ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:00009108o
.rdata$r:0000910C                                         ; .rdata$r:00009140o
.rdata$r:0000910D                 db    0
.rdata$r:0000910E                 db    0
.rdata$r:0000910F                 db    0
.rdata$r:00009110                 db    0
.rdata$r:00009111                 db    0
.rdata$r:00009112                 db    0
.rdata$r:00009113                 db    0
.rdata$r:00009114                 db    2
.rdata$r:00009115                 db    0
.rdata$r:00009116                 db    0
.rdata$r:00009117                 db    0
.rdata$r:00009118                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00009118 _rdata$r        ends
.rdata$r:00009118
.rdata$r:0000911C ; ===========================================================================
.rdata$r:0000911C
.rdata$r:0000911C ; Segment type: Pure data
.rdata$r:0000911C ; Segment permissions: Read
.rdata$r:0000911C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000911C                 assume cs:_rdata$r
.rdata$r:0000911C                 ;org 911Ch
.rdata$r:0000911C ; COMDAT (pick any)
.rdata$r:0000911C                 public ??_R2runtime_error@std@@8
.rdata$r:0000911C ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:0000911C ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:0000911C                                         ; DATA XREF: .rdata$r:00009118o
.rdata$r:0000911C                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009120                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009124                 db    0
.rdata$r:00009125                 align 4
.rdata$r:00009125 _rdata$r        ends
.rdata$r:00009125
.rdata$r:00009128 ; ===========================================================================
.rdata$r:00009128
.rdata$r:00009128 ; Segment type: Pure data
.rdata$r:00009128 ; Segment permissions: Read
.rdata$r:00009128 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009128                 assume cs:_rdata$r
.rdata$r:00009128                 ;org 9128h
.rdata$r:00009128 ; COMDAT (pick any)
.rdata$r:00009128                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00009128 ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009128 ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:00009128                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:00009128                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:0000912C                 db    1
.rdata$r:0000912D                 db    0
.rdata$r:0000912E                 db    0
.rdata$r:0000912F                 db    0
.rdata$r:00009130                 db    0
.rdata$r:00009131                 db    0
.rdata$r:00009132                 db    0
.rdata$r:00009133                 db    0
.rdata$r:00009134                 db 0FFh
.rdata$r:00009135                 db 0FFh
.rdata$r:00009136                 db 0FFh
.rdata$r:00009137                 db 0FFh
.rdata$r:00009138                 db    0
.rdata$r:00009139                 db    0
.rdata$r:0000913A                 db    0
.rdata$r:0000913B                 db    0
.rdata$r:0000913C                 db  40h ; @
.rdata$r:0000913D                 db    0
.rdata$r:0000913E                 db    0
.rdata$r:0000913F                 db    0
.rdata$r:00009140                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009140 _rdata$r        ends
.rdata$r:00009140
.rdata$r:00009144 ; ===========================================================================
.rdata$r:00009144
.rdata$r:00009144 ; Segment type: Pure data
.rdata$r:00009144 ; Segment permissions: Read
.rdata$r:00009144 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009144                 assume cs:_rdata$r
.rdata$r:00009144                 ;org 9144h
.rdata$r:00009144 ; COMDAT (pick any)
.rdata$r:00009144                 public ??_R4error_category@std@@6B@
.rdata$r:00009144 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00009144 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00008938o
.rdata$r:00009145                 db    0
.rdata$r:00009146                 db    0
.rdata$r:00009147                 db    0
.rdata$r:00009148                 db    0
.rdata$r:00009149                 db    0
.rdata$r:0000914A                 db    0
.rdata$r:0000914B                 db    0
.rdata$r:0000914C                 db    0
.rdata$r:0000914D                 db    0
.rdata$r:0000914E                 db    0
.rdata$r:0000914F                 db    0
.rdata$r:00009150                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00009154                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009154 _rdata$r        ends
.rdata$r:00009154
.data$r:00009158 ; ===========================================================================
.data$r:00009158
.data$r:00009158 ; Segment type: Pure data
.data$r:00009158 ; Segment permissions: Read/Write
.data$r:00009158 _data$r         segment dword public 'DATA' use32
.data$r:00009158                 assume cs:_data$r
.data$r:00009158                 ;org 9158h
.data$r:00009158 ; COMDAT (pick any)
.data$r:00009158                 public ??_R0?AVerror_category@std@@@8
.data$r:00009158 ; class std::error_category `RTTI Type Descriptor'
.data$r:00009158 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00009158                                         ; DATA XREF: .rdata$r:00009150o
.data$r:00009158                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00009158                                         ; const type_info::`vftable'
.data$r:0000915C                 align 10h
.data$r:00009160 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:00009179                 align 4
.data$r:00009179 _data$r         ends
.data$r:00009179
.rdata$r:0000917C ; ===========================================================================
.rdata$r:0000917C
.rdata$r:0000917C ; Segment type: Pure data
.rdata$r:0000917C ; Segment permissions: Read
.rdata$r:0000917C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000917C                 assume cs:_rdata$r
.rdata$r:0000917C                 ;org 917Ch
.rdata$r:0000917C ; COMDAT (pick any)
.rdata$r:0000917C                 public ??_R3error_category@std@@8
.rdata$r:0000917C ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000917C ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00009154o
.rdata$r:0000917C                                         ; .rdata$r:000091ACo
.rdata$r:0000917D                 db    0
.rdata$r:0000917E                 db    0
.rdata$r:0000917F                 db    0
.rdata$r:00009180                 db    0
.rdata$r:00009181                 db    0
.rdata$r:00009182                 db    0
.rdata$r:00009183                 db    0
.rdata$r:00009184                 db    1
.rdata$r:00009185                 db    0
.rdata$r:00009186                 db    0
.rdata$r:00009187                 db    0
.rdata$r:00009188                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00009188 _rdata$r        ends
.rdata$r:00009188
.rdata$r:0000918C ; ===========================================================================
.rdata$r:0000918C
.rdata$r:0000918C ; Segment type: Pure data
.rdata$r:0000918C ; Segment permissions: Read
.rdata$r:0000918C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000918C                 assume cs:_rdata$r
.rdata$r:0000918C                 ;org 918Ch
.rdata$r:0000918C ; COMDAT (pick any)
.rdata$r:0000918C                 public ??_R2error_category@std@@8
.rdata$r:0000918C ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000918C ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000918C                                         ; DATA XREF: .rdata$r:00009188o
.rdata$r:0000918C                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009190                 db    0
.rdata$r:00009191                 align 4
.rdata$r:00009191 _rdata$r        ends
.rdata$r:00009191
.rdata$r:00009194 ; ===========================================================================
.rdata$r:00009194
.rdata$r:00009194 ; Segment type: Pure data
.rdata$r:00009194 ; Segment permissions: Read
.rdata$r:00009194 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009194                 assume cs:_rdata$r
.rdata$r:00009194                 ;org 9194h
.rdata$r:00009194 ; COMDAT (pick any)
.rdata$r:00009194                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00009194 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009194 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00009194                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00009194                                         ; .rdata$r:00009204o ...
.rdata$r:00009194                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00009198                 align 10h
.rdata$r:000091A0                 db 0FFh
.rdata$r:000091A1                 db 0FFh
.rdata$r:000091A2                 db 0FFh
.rdata$r:000091A3                 db 0FFh
.rdata$r:000091A4                 db    0
.rdata$r:000091A5                 db    0
.rdata$r:000091A6                 db    0
.rdata$r:000091A7                 db    0
.rdata$r:000091A8                 db  40h ; @
.rdata$r:000091A9                 db    0
.rdata$r:000091AA                 db    0
.rdata$r:000091AB                 db    0
.rdata$r:000091AC                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000091AC _rdata$r        ends
.rdata$r:000091AC
.rdata$r:000091B0 ; ===========================================================================
.rdata$r:000091B0
.rdata$r:000091B0 ; Segment type: Pure data
.rdata$r:000091B0 ; Segment permissions: Read
.rdata$r:000091B0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000091B0                 assume cs:_rdata$r
.rdata$r:000091B0                 ;org 91B0h
.rdata$r:000091B0 ; COMDAT (pick any)
.rdata$r:000091B0                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:000091B0 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:000091B0 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:000091B0                                         ; DATA XREF: .rdata:00008954o
.rdata$r:000091B1                 db    0
.rdata$r:000091B2                 db    0
.rdata$r:000091B3                 db    0
.rdata$r:000091B4                 db    0
.rdata$r:000091B5                 db    0
.rdata$r:000091B6                 db    0
.rdata$r:000091B7                 db    0
.rdata$r:000091B8                 db    0
.rdata$r:000091B9                 db    0
.rdata$r:000091BA                 db    0
.rdata$r:000091BB                 db    0
.rdata$r:000091BC                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000091C0                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000091C0 _rdata$r        ends
.rdata$r:000091C0
.data$r:000091C4 ; ===========================================================================
.data$r:000091C4
.data$r:000091C4 ; Segment type: Pure data
.data$r:000091C4 ; Segment permissions: Read/Write
.data$r:000091C4 _data$r         segment dword public 'DATA' use32
.data$r:000091C4                 assume cs:_data$r
.data$r:000091C4                 ;org 91C4h
.data$r:000091C4 ; COMDAT (pick any)
.data$r:000091C4                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:000091C4 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:000091C4 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000091C4                                         ; DATA XREF: .rdata$r:000091BCo
.data$r:000091C4                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000091C4                                         ; const type_info::`vftable'
.data$r:000091C8                 db    0
.data$r:000091C9                 db    0
.data$r:000091CA                 db    0
.data$r:000091CB                 db    0
.data$r:000091CC                 db  2Eh ; .
.data$r:000091CD                 db  3Fh ; ?
.data$r:000091CE                 db  41h ; A
.data$r:000091CF                 db  56h ; V
.data$r:000091D0                 db  5Fh ; _
.data$r:000091D1                 db  47h ; G
.data$r:000091D2                 db  65h ; e
.data$r:000091D3                 db  6Eh ; n
.data$r:000091D4                 db  65h ; e
.data$r:000091D5                 db  72h ; r
.data$r:000091D6                 db  69h ; i
.data$r:000091D7                 db  63h ; c
.data$r:000091D8                 db  5Fh ; _
.data$r:000091D9                 db  65h ; e
.data$r:000091DA                 db  72h ; r
.data$r:000091DB                 db  72h ; r
.data$r:000091DC                 db  6Fh ; o
.data$r:000091DD                 db  72h ; r
.data$r:000091DE                 db  5Fh ; _
.data$r:000091DF                 db  63h ; c
.data$r:000091E0                 db  61h ; a
.data$r:000091E1                 db  74h ; t
.data$r:000091E2                 db  65h ; e
.data$r:000091E3                 db  67h ; g
.data$r:000091E4                 db  6Fh ; o
.data$r:000091E5                 db  72h ; r
.data$r:000091E6                 db  79h ; y
.data$r:000091E7                 db  40h ; @
.data$r:000091E8                 db  73h ; s
.data$r:000091E9                 db  74h ; t
.data$r:000091EA                 db  64h ; d
.data$r:000091EB                 db  40h ; @
.data$r:000091EC                 db  40h ; @
.data$r:000091ED                 db    0
.data$r:000091EE                 align 10h
.data$r:000091EE _data$r         ends
.data$r:000091EE
.rdata$r:000091F0 ; ===========================================================================
.rdata$r:000091F0
.rdata$r:000091F0 ; Segment type: Pure data
.rdata$r:000091F0 ; Segment permissions: Read
.rdata$r:000091F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000091F0                 assume cs:_rdata$r
.rdata$r:000091F0                 ;org 91F0h
.rdata$r:000091F0 ; COMDAT (pick any)
.rdata$r:000091F0                 public ??_R3_Generic_error_category@std@@8
.rdata$r:000091F0 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000091F0 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:000091F0                                         ; DATA XREF: .rdata$r:000091C0o
.rdata$r:000091F0                                         ; .rdata$r:00009224o
.rdata$r:000091F1                 db    0
.rdata$r:000091F2                 db    0
.rdata$r:000091F3                 db    0
.rdata$r:000091F4                 db    0
.rdata$r:000091F5                 db    0
.rdata$r:000091F6                 db    0
.rdata$r:000091F7                 db    0
.rdata$r:000091F8                 db    2
.rdata$r:000091F9                 db    0
.rdata$r:000091FA                 db    0
.rdata$r:000091FB                 db    0
.rdata$r:000091FC                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000091FC _rdata$r        ends
.rdata$r:000091FC
.rdata$r:00009200 ; ===========================================================================
.rdata$r:00009200
.rdata$r:00009200 ; Segment type: Pure data
.rdata$r:00009200 ; Segment permissions: Read
.rdata$r:00009200 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009200                 assume cs:_rdata$r
.rdata$r:00009200                 ;org 9200h
.rdata$r:00009200 ; COMDAT (pick any)
.rdata$r:00009200                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00009200 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00009200 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00009200                                         ; DATA XREF: .rdata$r:000091FCo
.rdata$r:00009200                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009204                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009208                 db    0
.rdata$r:00009209                 align 4
.rdata$r:00009209 _rdata$r        ends
.rdata$r:00009209
.rdata$r:0000920C ; ===========================================================================
.rdata$r:0000920C
.rdata$r:0000920C ; Segment type: Pure data
.rdata$r:0000920C ; Segment permissions: Read
.rdata$r:0000920C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000920C                 assume cs:_rdata$r
.rdata$r:0000920C                 ;org 920Ch
.rdata$r:0000920C ; COMDAT (pick any)
.rdata$r:0000920C                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000920C ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000920C ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0000920C                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0000920C                                         ; .rdata$r:0000927Co ...
.rdata$r:0000920C                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00009210                 db    1
.rdata$r:00009211                 db    0
.rdata$r:00009212                 db    0
.rdata$r:00009213                 db    0
.rdata$r:00009214                 db    0
.rdata$r:00009215                 db    0
.rdata$r:00009216                 db    0
.rdata$r:00009217                 db    0
.rdata$r:00009218                 db 0FFh
.rdata$r:00009219                 db 0FFh
.rdata$r:0000921A                 db 0FFh
.rdata$r:0000921B                 db 0FFh
.rdata$r:0000921C                 db    0
.rdata$r:0000921D                 db    0
.rdata$r:0000921E                 db    0
.rdata$r:0000921F                 db    0
.rdata$r:00009220                 db  40h ; @
.rdata$r:00009221                 db    0
.rdata$r:00009222                 db    0
.rdata$r:00009223                 db    0
.rdata$r:00009224                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009224 _rdata$r        ends
.rdata$r:00009224
.rdata$r:00009228 ; ===========================================================================
.rdata$r:00009228
.rdata$r:00009228 ; Segment type: Pure data
.rdata$r:00009228 ; Segment permissions: Read
.rdata$r:00009228 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009228                 assume cs:_rdata$r
.rdata$r:00009228                 ;org 9228h
.rdata$r:00009228 ; COMDAT (pick any)
.rdata$r:00009228                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00009228 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00009228 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00009228                                         ; DATA XREF: .rdata:00008988o
.rdata$r:00009229                 db    0
.rdata$r:0000922A                 db    0
.rdata$r:0000922B                 db    0
.rdata$r:0000922C                 db    0
.rdata$r:0000922D                 db    0
.rdata$r:0000922E                 db    0
.rdata$r:0000922F                 db    0
.rdata$r:00009230                 db    0
.rdata$r:00009231                 db    0
.rdata$r:00009232                 db    0
.rdata$r:00009233                 db    0
.rdata$r:00009234                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00009238                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009238 _rdata$r        ends
.rdata$r:00009238
.data$r:0000923C ; ===========================================================================
.data$r:0000923C
.data$r:0000923C ; Segment type: Pure data
.data$r:0000923C ; Segment permissions: Read/Write
.data$r:0000923C _data$r         segment dword public 'DATA' use32
.data$r:0000923C                 assume cs:_data$r
.data$r:0000923C                 ;org 923Ch
.data$r:0000923C ; COMDAT (pick any)
.data$r:0000923C                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000923C ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000923C ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000923C                                         ; DATA XREF: .rdata$r:00009234o
.data$r:0000923C                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000923C                                         ; const type_info::`vftable'
.data$r:00009240                 db    0
.data$r:00009241                 db    0
.data$r:00009242                 db    0
.data$r:00009243                 db    0
.data$r:00009244                 db  2Eh ; .
.data$r:00009245                 db  3Fh ; ?
.data$r:00009246                 db  41h ; A
.data$r:00009247                 db  56h ; V
.data$r:00009248                 db  5Fh ; _
.data$r:00009249                 db  49h ; I
.data$r:0000924A                 db  6Fh ; o
.data$r:0000924B                 db  73h ; s
.data$r:0000924C                 db  74h ; t
.data$r:0000924D                 db  72h ; r
.data$r:0000924E                 db  65h ; e
.data$r:0000924F                 db  61h ; a
.data$r:00009250                 db  6Dh ; m
.data$r:00009251                 db  5Fh ; _
.data$r:00009252                 db  65h ; e
.data$r:00009253                 db  72h ; r
.data$r:00009254                 db  72h ; r
.data$r:00009255                 db  6Fh ; o
.data$r:00009256                 db  72h ; r
.data$r:00009257                 db  5Fh ; _
.data$r:00009258                 db  63h ; c
.data$r:00009259                 db  61h ; a
.data$r:0000925A                 db  74h ; t
.data$r:0000925B                 db  65h ; e
.data$r:0000925C                 db  67h ; g
.data$r:0000925D                 db  6Fh ; o
.data$r:0000925E                 db  72h ; r
.data$r:0000925F                 db  79h ; y
.data$r:00009260                 db  40h ; @
.data$r:00009261                 db  73h ; s
.data$r:00009262                 db  74h ; t
.data$r:00009263                 db  64h ; d
.data$r:00009264                 db  40h ; @
.data$r:00009265                 db  40h ; @
.data$r:00009266                 db    0
.data$r:00009267                 align 4
.data$r:00009267 _data$r         ends
.data$r:00009267
.rdata$r:00009268 ; ===========================================================================
.rdata$r:00009268
.rdata$r:00009268 ; Segment type: Pure data
.rdata$r:00009268 ; Segment permissions: Read
.rdata$r:00009268 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009268                 assume cs:_rdata$r
.rdata$r:00009268                 ;org 9268h
.rdata$r:00009268 ; COMDAT (pick any)
.rdata$r:00009268                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00009268 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009268 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00009268                                         ; DATA XREF: .rdata$r:00009238o
.rdata$r:00009268                                         ; .rdata$r:000092A0o
.rdata$r:00009269                 db    0
.rdata$r:0000926A                 db    0
.rdata$r:0000926B                 db    0
.rdata$r:0000926C                 db    0
.rdata$r:0000926D                 db    0
.rdata$r:0000926E                 db    0
.rdata$r:0000926F                 db    0
.rdata$r:00009270                 db    3
.rdata$r:00009271                 db    0
.rdata$r:00009272                 db    0
.rdata$r:00009273                 db    0
.rdata$r:00009274                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00009274 _rdata$r        ends
.rdata$r:00009274
.rdata$r:00009278 ; ===========================================================================
.rdata$r:00009278
.rdata$r:00009278 ; Segment type: Pure data
.rdata$r:00009278 ; Segment permissions: Read
.rdata$r:00009278 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009278                 assume cs:_rdata$r
.rdata$r:00009278                 ;org 9278h
.rdata$r:00009278 ; COMDAT (pick any)
.rdata$r:00009278                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00009278 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00009278 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00009278                                         ; DATA XREF: .rdata$r:00009274o
.rdata$r:00009278                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000927C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009280                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009284                 db    0
.rdata$r:00009285                 align 4
.rdata$r:00009285 _rdata$r        ends
.rdata$r:00009285
.rdata$r:00009288 ; ===========================================================================
.rdata$r:00009288
.rdata$r:00009288 ; Segment type: Pure data
.rdata$r:00009288 ; Segment permissions: Read
.rdata$r:00009288 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009288                 assume cs:_rdata$r
.rdata$r:00009288                 ;org 9288h
.rdata$r:00009288 ; COMDAT (pick any)
.rdata$r:00009288                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00009288 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009288 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00009288                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00009288                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000928C                 db    2
.rdata$r:0000928D                 db    0
.rdata$r:0000928E                 db    0
.rdata$r:0000928F                 db    0
.rdata$r:00009290                 db    0
.rdata$r:00009291                 db    0
.rdata$r:00009292                 db    0
.rdata$r:00009293                 db    0
.rdata$r:00009294                 db 0FFh
.rdata$r:00009295                 db 0FFh
.rdata$r:00009296                 db 0FFh
.rdata$r:00009297                 db 0FFh
.rdata$r:00009298                 db    0
.rdata$r:00009299                 db    0
.rdata$r:0000929A                 db    0
.rdata$r:0000929B                 db    0
.rdata$r:0000929C                 db  40h ; @
.rdata$r:0000929D                 db    0
.rdata$r:0000929E                 db    0
.rdata$r:0000929F                 db    0
.rdata$r:000092A0                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000092A0 _rdata$r        ends
.rdata$r:000092A0
.rdata$r:000092A4 ; ===========================================================================
.rdata$r:000092A4
.rdata$r:000092A4 ; Segment type: Pure data
.rdata$r:000092A4 ; Segment permissions: Read
.rdata$r:000092A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000092A4                 assume cs:_rdata$r
.rdata$r:000092A4                 ;org 92A4h
.rdata$r:000092A4 ; COMDAT (pick any)
.rdata$r:000092A4                 public ??_R4_System_error_category@std@@6B@
.rdata$r:000092A4 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:000092A4 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:000089C8o
.rdata$r:000092A5                 db    0
.rdata$r:000092A6                 db    0
.rdata$r:000092A7                 db    0
.rdata$r:000092A8                 db    0
.rdata$r:000092A9                 db    0
.rdata$r:000092AA                 db    0
.rdata$r:000092AB                 db    0
.rdata$r:000092AC                 db    0
.rdata$r:000092AD                 db    0
.rdata$r:000092AE                 db    0
.rdata$r:000092AF                 db    0
.rdata$r:000092B0                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000092B4                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000092B4 _rdata$r        ends
.rdata$r:000092B4
.data$r:000092B8 ; ===========================================================================
.data$r:000092B8
.data$r:000092B8 ; Segment type: Pure data
.data$r:000092B8 ; Segment permissions: Read/Write
.data$r:000092B8 _data$r         segment dword public 'DATA' use32
.data$r:000092B8                 assume cs:_data$r
.data$r:000092B8                 ;org 92B8h
.data$r:000092B8 ; COMDAT (pick any)
.data$r:000092B8                 public ??_R0?AV_System_error_category@std@@@8
.data$r:000092B8 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:000092B8 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000092B8                                         ; DATA XREF: .rdata$r:000092B0o
.data$r:000092B8                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000092B8                                         ; const type_info::`vftable'
.data$r:000092BC                 align 10h
.data$r:000092C0 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:000092E1                 align 4
.data$r:000092E1 _data$r         ends
.data$r:000092E1
.rdata$r:000092E4 ; ===========================================================================
.rdata$r:000092E4
.rdata$r:000092E4 ; Segment type: Pure data
.rdata$r:000092E4 ; Segment permissions: Read
.rdata$r:000092E4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000092E4                 assume cs:_rdata$r
.rdata$r:000092E4                 ;org 92E4h
.rdata$r:000092E4 ; COMDAT (pick any)
.rdata$r:000092E4                 public ??_R3_System_error_category@std@@8
.rdata$r:000092E4 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000092E4 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:000092B4o
.rdata$r:000092E4                                         ; .rdata$r:0000931Co
.rdata$r:000092E5                 db    0
.rdata$r:000092E6                 db    0
.rdata$r:000092E7                 db    0
.rdata$r:000092E8                 db    0
.rdata$r:000092E9                 db    0
.rdata$r:000092EA                 db    0
.rdata$r:000092EB                 db    0
.rdata$r:000092EC                 db    3
.rdata$r:000092ED                 db    0
.rdata$r:000092EE                 db    0
.rdata$r:000092EF                 db    0
.rdata$r:000092F0                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000092F0 _rdata$r        ends
.rdata$r:000092F0
.rdata$r:000092F4 ; ===========================================================================
.rdata$r:000092F4
.rdata$r:000092F4 ; Segment type: Pure data
.rdata$r:000092F4 ; Segment permissions: Read
.rdata$r:000092F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000092F4                 assume cs:_rdata$r
.rdata$r:000092F4                 ;org 92F4h
.rdata$r:000092F4 ; COMDAT (pick any)
.rdata$r:000092F4                 public ??_R2_System_error_category@std@@8
.rdata$r:000092F4 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000092F4 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000092F4                                         ; DATA XREF: .rdata$r:000092F0o
.rdata$r:000092F4                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000092F8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000092FC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009300                 db    0
.rdata$r:00009301                 align 4
.rdata$r:00009301 _rdata$r        ends
.rdata$r:00009301
.rdata$r:00009304 ; ===========================================================================
.rdata$r:00009304
.rdata$r:00009304 ; Segment type: Pure data
.rdata$r:00009304 ; Segment permissions: Read
.rdata$r:00009304 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009304                 assume cs:_rdata$r
.rdata$r:00009304                 ;org 9304h
.rdata$r:00009304 ; COMDAT (pick any)
.rdata$r:00009304                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00009304 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009304 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00009304                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00009304                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00009308                 db    2
.rdata$r:00009309                 db    0
.rdata$r:0000930A                 db    0
.rdata$r:0000930B                 db    0
.rdata$r:0000930C                 db    0
.rdata$r:0000930D                 db    0
.rdata$r:0000930E                 db    0
.rdata$r:0000930F                 db    0
.rdata$r:00009310                 db 0FFh
.rdata$r:00009311                 db 0FFh
.rdata$r:00009312                 db 0FFh
.rdata$r:00009313                 db 0FFh
.rdata$r:00009314                 db    0
.rdata$r:00009315                 db    0
.rdata$r:00009316                 db    0
.rdata$r:00009317                 db    0
.rdata$r:00009318                 db  40h ; @
.rdata$r:00009319                 db    0
.rdata$r:0000931A                 db    0
.rdata$r:0000931B                 db    0
.rdata$r:0000931C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000931C _rdata$r        ends
.rdata$r:0000931C
.CRT$XCU:00009320 ; ===========================================================================
.CRT$XCU:00009320
.CRT$XCU:00009320 ; Segment type: Pure data
.CRT$XCU:00009320 ; Segment permissions: Read
.CRT$XCU:00009320 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009320                 assume cs:_CRT$XCU
.CRT$XCU:00009320                 ;org 9320h
.CRT$XCU:00009320 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00009324 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00009324 _CRT$XCU        ends
.CRT$XCU:00009324
.CRT$XCU:00009328 ; ===========================================================================
.CRT$XCU:00009328
.CRT$XCU:00009328 ; Segment type: Pure data
.CRT$XCU:00009328 ; Segment permissions: Read
.CRT$XCU:00009328 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009328                 assume cs:_CRT$XCU
.CRT$XCU:00009328                 ;org 9328h
.CRT$XCU:00009328 ; COMDAT (pick associative to section at 89EC)
.CRT$XCU:00009328 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00009328 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00009328 _CRT$XCU        ends
.CRT$XCU:00009328
.CRT$XCU:0000932C ; ===========================================================================
.CRT$XCU:0000932C
.CRT$XCU:0000932C ; Segment type: Pure data
.CRT$XCU:0000932C ; Segment permissions: Read
.CRT$XCU:0000932C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000932C                 assume cs:_CRT$XCU
.CRT$XCU:0000932C                 ;org 932Ch
.CRT$XCU:0000932C ; COMDAT (pick associative to section at 89F0)
.CRT$XCU:0000932C ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000932C ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000932C _CRT$XCU        ends
.CRT$XCU:0000932C
.CRT$XCU:00009330 ; ===========================================================================
.CRT$XCU:00009330
.CRT$XCU:00009330 ; Segment type: Pure data
.CRT$XCU:00009330 ; Segment permissions: Read
.CRT$XCU:00009330 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009330                 assume cs:_CRT$XCU
.CRT$XCU:00009330                 ;org 9330h
.CRT$XCU:00009330 ; COMDAT (pick associative to section at 89F4)
.CRT$XCU:00009330 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00009330 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00009330 _CRT$XCU        ends
.CRT$XCU:00009330
.CRT$XCU:00009334 ; ===========================================================================
.CRT$XCU:00009334
.CRT$XCU:00009334 ; Segment type: Pure data
.CRT$XCU:00009334 ; Segment permissions: Read
.CRT$XCU:00009334 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009334                 assume cs:_CRT$XCU
.CRT$XCU:00009334                 ;org 9334h
.CRT$XCU:00009334 ; COMDAT (pick associative to section at 89FC)
.CRT$XCU:00009334 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00009334 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00009334 _CRT$XCU        ends
.CRT$XCU:00009334
.CRT$XCU:00009338 ; ===========================================================================
.CRT$XCU:00009338
.CRT$XCU:00009338 ; Segment type: Pure data
.CRT$XCU:00009338 ; Segment permissions: Read
.CRT$XCU:00009338 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009338                 assume cs:_CRT$XCU
.CRT$XCU:00009338                 ;org 9338h
.CRT$XCU:00009338 ; COMDAT (pick associative to section at 8A00)
.CRT$XCU:00009338 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00009338 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00009338 _CRT$XCU        ends
.CRT$XCU:00009338
.CRT$XCU:0000933C ; ===========================================================================
.CRT$XCU:0000933C
.CRT$XCU:0000933C ; Segment type: Pure data
.CRT$XCU:0000933C ; Segment permissions: Read
.CRT$XCU:0000933C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000933C                 assume cs:_CRT$XCU
.CRT$XCU:0000933C                 ;org 933Ch
.CRT$XCU:0000933C ; COMDAT (pick associative to section at 8A94)
.CRT$XCU:0000933C ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000933C ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000933C _CRT$XCU        ends
.CRT$XCU:0000933C
.CRT$XCU:00009340 ; ===========================================================================
.CRT$XCU:00009340
.CRT$XCU:00009340 ; Segment type: Pure data
.CRT$XCU:00009340 ; Segment permissions: Read
.CRT$XCU:00009340 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009340                 assume cs:_CRT$XCU
.CRT$XCU:00009340                 ;org 9340h
.CRT$XCU:00009340 ; COMDAT (pick associative to section at 8A98)
.CRT$XCU:00009340 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00009340 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00009340 _CRT$XCU        ends
.CRT$XCU:00009340
UNDEF:00009350 ; ===========================================================================
UNDEF:00009350
UNDEF:00009350 ; Segment type: Externs
UNDEF:00009350 ; UNDEF
UNDEF:00009350                 extrn __purecall:near   ; DATA XREF: .rdata:00008940o
UNDEF:00009350                                         ; .rdata:00008944o
UNDEF:00009354 ; void *__cdecl operator new(unsigned int)
UNDEF:00009354                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00009354                                         ; std::_Allocate<int>(uint,int *)+23p ...
UNDEF:00009358 ; void __cdecl operator delete(void *)
UNDEF:00009358                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00009358                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000935C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000935C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000935C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00009360                 extrn __invalid_parameter:near
UNDEF:00009360                                         ; CODE XREF: std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)+74p
UNDEF:00009360                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::operator[](uint)+74p ...
UNDEF:00009364 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00009364                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00009364                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:00009364                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:00009368 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00009368                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00009368                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:00009368                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:0000936C                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00009370 ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:00009370                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:00009374 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00009374                 extrn _memmove:near     ; CODE XREF: std::_Move<int *,int *>(int *,int *,int *,std::_Scalar_ptr_iterator_tag)+1Fp
UNDEF:00009374                                         ; std::_Uninit_move<int,int,int>(int *,int *,int *,std::_Wrap_alloc<std::allocator<int>> &,int *,std::_Scalar_ptr_iterator_tag)+4Fp ...
UNDEF:00009378 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00009378                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00009378                                         ; _wmemcpy+11p
UNDEF:0000937C ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:0000937C                 extrn _memset:near      ; CODE XREF: ToolBar::addToRebar(ReBar *)+33p
UNDEF:0000937C                                         ; ReBar::init(HINSTANCE__ *,HWND__ *)+58p ...
UNDEF:00009380 ; size_t __cdecl strlen(const char *Str)
UNDEF:00009380                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00009384 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:00009384                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:00009384                                         ; CODE XREF: std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:00009388 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:00009388                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:00009388                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:00009388                                         ; DATA XREF: .xdata$x:00008934o
UNDEF:0000938C ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:0000938C                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:0000938C                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:0000938C                                         ; __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0+3j ...
UNDEF:00009390 ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:00009390                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:00009390                                         ; DATA XREF: .rdata:000088A4o
UNDEF:00009394 ; void __cdecl operator delete[](void *)
UNDEF:00009394                 extrn ??_V@YAXPAX@Z:near
UNDEF:00009394                                         ; CODE XREF: ToolBar::destroy(void)+47p
UNDEF:00009398 ; void *__cdecl operator new[](unsigned int)
UNDEF:00009398                 extrn ??_U@YAPAXI@Z:near
UNDEF:00009398                                         ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+10Ep
UNDEF:0000939C                 extrn __CrtDbgReportW:near
UNDEF:0000939C                                         ; CODE XREF: std::vector<ToolBarButtonUnit,std::allocator<ToolBarButtonUnit>>::operator[](uint)+50p
UNDEF:0000939C                                         ; std::vector<tDynamicList,std::allocator<tDynamicList>>::operator[](uint)+50p ...
UNDEF:000093A0 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:000093A0                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:000093A0                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:000093A0                                         ; std::_Debug_pointer<int>(int *,wchar_t const *,uint)+16p ...
UNDEF:000093A4 ; void __cdecl std::_Xbad_alloc()
UNDEF:000093A4                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:000093A4                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_1A1Ap
UNDEF:000093A4                                         ; std::_Allocate<int>(uint,int *):loc_1A5Cp ...
UNDEF:000093A8 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:000093A8                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:000093A8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:000093A8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp ...
UNDEF:000093AC ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:000093AC                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:000093AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:000093AC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp ...
UNDEF:000093B0 ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:000093B0                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:000093B0                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:000093B4 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:000093B4                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000093B4                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:000093B8 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:000093B8                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:000093B8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:000093B8                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:000093BC ; const char *__cdecl std::_Winerror_map(int)
UNDEF:000093BC                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:000093BC                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:000093C0 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000093C0                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000093C0                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:000093C4 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000093C4                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000093C4                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:000093C8 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000093C8                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000093C8                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:000093CC ; HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName)
UNDEF:000093CC                 extrn __imp__GetModuleHandleW@4:near
UNDEF:000093CC                                         ; CODE XREF: ReBar::setGrayBackground(int)+51p
UNDEF:000093CC                                         ; DATA XREF: ReBar::setGrayBackground(int)+51r
UNDEF:000093D0 ; int __stdcall MulDiv(int nNumber, int nNumerator, int nDenominator)
UNDEF:000093D0                 extrn __imp__MulDiv@12:near
UNDEF:000093D0                                         ; CODE XREF: DPIManager::scaleX(int)+13p
UNDEF:000093D0                                         ; DATA XREF: DPIManager::scaleX(int)+13r
UNDEF:000093D4 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000093D4                 extrn __imp__SendMessageW@16:near
UNDEF:000093D4                                         ; CODE XREF: ToolBar::getWidth(void)+4Ep
UNDEF:000093D4                                         ; ToolBar::getHeight(void)+19p ...
UNDEF:000093D8 ; HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
UNDEF:000093D8                 extrn __imp__CreateWindowExW@48:near
UNDEF:000093D8                                         ; CODE XREF: ToolBar::reset(bool)+BFp
UNDEF:000093D8                                         ; ReBar::init(HINSTANCE__ *,HWND__ *)+44p
UNDEF:000093D8                                         ; DATA XREF: ...
UNDEF:000093DC ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:000093DC                 extrn __imp__DestroyWindow@4:near
UNDEF:000093DC                                         ; CODE XREF: ToolBar::destroy(void)+56p
UNDEF:000093DC                                         ; ToolBar::reset(bool)+78p
UNDEF:000093DC                                         ; DATA XREF: ...
UNDEF:000093E0 ; HMENU __stdcall CreatePopupMenu()
UNDEF:000093E0                 extrn __imp__CreatePopupMenu@0:near
UNDEF:000093E0                                         ; CODE XREF: ToolBar::doPopop(tagPOINT)+A8p
UNDEF:000093E0                                         ; DATA XREF: ToolBar::doPopop(tagPOINT)+A8r
UNDEF:000093E4 ; BOOL __stdcall AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
UNDEF:000093E4                 extrn __imp__AppendMenuW@16:near
UNDEF:000093E4                                         ; CODE XREF: ToolBar::doPopop(tagPOINT)+133p
UNDEF:000093E4                                         ; ToolBar::doPopop(tagPOINT)+14Ep ...
UNDEF:000093E8 ; BOOL __stdcall TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
UNDEF:000093E8                 extrn __imp__TrackPopupMenu@28:near
UNDEF:000093E8                                         ; CODE XREF: ToolBar::doPopop(tagPOINT)+193p
UNDEF:000093E8                                         ; DATA XREF: ToolBar::doPopop(tagPOINT)+193r
UNDEF:000093EC ; BOOL __stdcall UpdateWindow(HWND hWnd)
UNDEF:000093EC                 extrn __imp__UpdateWindow@4:near
UNDEF:000093EC                                         ; CODE XREF: Window::redraw(bool)+27p
UNDEF:000093EC                                         ; DATA XREF: Window::redraw(bool)+27r
UNDEF:000093F0 ; BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
UNDEF:000093F0                 extrn __imp__InvalidateRect@12:near
UNDEF:000093F0                                         ; CODE XREF: Window::redraw(bool)+12p
UNDEF:000093F0                                         ; DATA XREF: Window::redraw(bool)+12r
UNDEF:000093F4 ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:000093F4                 extrn __imp__GetClientRect@8:near
UNDEF:000093F4                                         ; CODE XREF: Window::getWidth(void)+1Ep
UNDEF:000093F4                                         ; DATA XREF: Window::getWidth(void)+1Er
UNDEF:000093F8 ; HBITMAP __stdcall LoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName)
UNDEF:000093F8                 extrn __imp__LoadBitmapW@8:near
UNDEF:000093F8                                         ; CODE XREF: ReBar::setGrayBackground(int)+58p
UNDEF:000093F8                                         ; DATA XREF: ReBar::setGrayBackground(int)+58r
UNDEF:000093FC ; HANDLE __stdcall LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad)
UNDEF:000093FC                 extrn __imp__LoadImageW@24:near
UNDEF:000093FC                                         ; CODE XREF: ToolBar::reset(bool)+1EEp
UNDEF:000093FC                                         ; DATA XREF: ToolBar::reset(bool)+1EEr
UNDEF:00009400 ; BOOL __stdcall InitCommonControlsEx(const INITCOMMONCONTROLSEX *picce)
UNDEF:00009400                 extrn __imp__InitCommonControlsEx@4:near
UNDEF:00009400                                         ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+92p
UNDEF:00009400                                         ; DATA XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+92r
UNDEF:00009404 ; void __thiscall ToolBarIcons::init(ToolBarIcons *__hidden this, struct ToolBarButtonUnit *, int)
UNDEF:00009404                 extrn ?init@ToolBarIcons@@QAEXPAUToolBarButtonUnit@@H@Z:near
UNDEF:00009404                                         ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+65p
UNDEF:00009408 ; void __thiscall ToolBarIcons::create(ToolBarIcons *__hidden this, HINSTANCE, int)
UNDEF:00009408                 extrn ?create@ToolBarIcons@@QAEXPAUHINSTANCE__@@H@Z:near
UNDEF:00009408                                         ; CODE XREF: ToolBar::init(HINSTANCE__ *,HWND__ *,toolBarStatusType,ToolBarButtonUnit *,int)+7Bp
UNDEF:0000940C ; void __thiscall ToolBarIcons::destroy(ToolBarIcons *__hidden this)
UNDEF:0000940C                 extrn ?destroy@ToolBarIcons@@QAEXXZ:near
UNDEF:0000940C                                         ; CODE XREF: ToolBar::destroy(void)+6Cp
UNDEF:00009410 ; void __thiscall ToolBarIcons::reInit(ToolBarIcons *__hidden this, int)
UNDEF:00009410                 extrn ?reInit@ToolBarIcons@@QAEXH@Z:near
UNDEF:00009410                                         ; CODE XREF: ToolBarIcons::resizeIcon(int)+Ep
UNDEF:00009414 ; void __cdecl getNameStrFromCmd(unsigned long, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &)
UNDEF:00009414                 extrn ?getNameStrFromCmd@@YAXKAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z:near
UNDEF:00009414                                         ; CODE XREF: ToolBar::doPopop(tagPOINT)+EBp
UNDEF:00009418 ; struct TiXmlNode *__thiscall TiXmlNode::FirstChild(TiXmlNode *__hidden this, const wchar_t *)
UNDEF:00009418                 extrn ?FirstChild@TiXmlNode@@QBEPAV1@PB_W@Z:near
UNDEF:00009418                                         ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+39p
UNDEF:00009418                                         ; ToolBar::initTheme(TiXmlDocument *)+6Ep ...
UNDEF:0000941C ; struct TiXmlNode *__thiscall TiXmlNode::NextSibling(TiXmlNode *__hidden this, const wchar_t *)
UNDEF:0000941C                 extrn ?NextSibling@TiXmlNode@@QBEPAV1@PB_W@Z:near
UNDEF:0000941C                                         ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+113p
UNDEF:00009420 ; struct TiXmlElement *__thiscall TiXmlNode::FirstChildElement(TiXmlNode *__hidden this, const wchar_t *)
UNDEF:00009420                 extrn ?FirstChildElement@TiXmlNode@@QBEPAVTiXmlElement@@PB_W@Z:near
UNDEF:00009420                                         ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+FBp
UNDEF:00009420                                         ; ToolBar::initTheme(TiXmlDocument *)+167p ...
UNDEF:00009424 ; const wchar_t *__thiscall TiXmlElement::Attribute(TiXmlElement *__hidden this, const wchar_t *)
UNDEF:00009424                 extrn ?Attribute@TiXmlElement@@QBEPB_WPB_W@Z:near
UNDEF:00009424                                         ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+DFp
UNDEF:00009428 ; const wchar_t *__thiscall TiXmlElement::Attribute(TiXmlElement *__hidden this, const wchar_t *, int *)
UNDEF:00009428                 extrn ?Attribute@TiXmlElement@@QBEPB_WPB_WPAH@Z:near
UNDEF:00009428                                         ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+144p
UNDEF:0000942C ; __fastcall __security_check_cookie(x)
UNDEF:0000942C                 extrn @__security_check_cookie@4:near
UNDEF:0000942C                                         ; CODE XREF: ToolBar::initTheme(TiXmlDocument *)+4BFp
UNDEF:0000942C                                         ; ToolBar::getWidth(void)+6Ap ...
UNDEF:00009430 ; __stdcall _CxxThrowException(x, x)
UNDEF:00009430                 extrn __CxxThrowException@8:near
UNDEF:00009430                                         ; CODE XREF: ToolBar::reset(bool)+116p
UNDEF:00009430                                         ; __catch$??$_Uninit_move@PAUiconLocator@@PAU1@V?$allocator@UiconLocator@@@std@@U1@@std@@YAPAUiconLocator@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UiconLocator@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+25p ...
UNDEF:00009434                 extrn ___CxxFrameHandler3:near
UNDEF:00009434                                         ; CODE XREF: __ehhandler$?initTheme@ToolBar@@QAEXPAVTiXmlDocument@@@Z+23j
UNDEF:00009434                                         ; __ehhandler$?doPopop@ToolBar@@QAEXUtagPOINT@@@Z+20j ...
UNDEF:00009438 ; const type_info::`vftable'
UNDEF:00009438                 extrn ??_7type_info@@6B@:near
UNDEF:00009438                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:00009438                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:0000943C ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:0000943C                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:0000943C                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:00009440                 extrn ___security_cookie:near
UNDEF:00009440                                         ; DATA XREF: ToolBar::initTheme(TiXmlDocument *)+17r
UNDEF:00009440                                         ; ToolBar::getWidth(void)+6r ...
UNDEF:00009444                 extrn __fltused:near
UNDEF:00009444
UNDEF:00009444
UNDEF:00009444                 end