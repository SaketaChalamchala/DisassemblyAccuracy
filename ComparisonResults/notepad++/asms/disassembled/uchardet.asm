.text$mn:00000000 ;
.text$mn:00000000 ; +-------------------------------------------------------------------------+
.text$mn:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.text$mn:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.text$mn:00000000 ; |                      License info: 48-3677-7074-51                      |
.text$mn:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.text$mn:00000000 ; +-------------------------------------------------------------------------+
.text$mn:00000000 ;
.text$mn:00000000 ; Input MD5   : E29C43EC8E4ECCD95177516D39D3854B
.text$mn:00000000 ; Input CRC32 : A5008A49
.text$mn:00000000
.text$mn:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\uchardet.obj
.text$mn:00000000 ; Format      : COFF (X386MAGIC)
.text$mn:00000000 ; includelib "libcpmtd"
.text$mn:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.text$mn:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.text$mn:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.text$mn:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.text$mn:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.text$mn:00000000 ; includelib "LIBCMTD"
.text$mn:00000000 ; includelib "OLDNAMES"
.text$mn:00000000
.text$mn:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.text$mn:00000000
.text$mn:00000000                 .686p
.text$mn:00000000                 .mmx
.text$mn:00000000                 .model flat
.text$mn:00000000
.text$mn:00000000 ; ===========================================================================
.text$mn:00000000
.text$mn:00000000 ; Segment type: Pure code
.text$mn:00000000 ; Segment permissions: Read/Execute
.text$mn:00000000 _text$mn        segment para public 'CODE' use32
.text$mn:00000000                 assume cs:_text$mn
.text$mn:00000000                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000000
.text$mn:00000000 ; =============== S U B R O U T I N E =======================================
.text$mn:00000000
.text$mn:00000000 ; Attributes: bp-based frame
.text$mn:00000000
.text$mn:00000000                 public _uchardet_new
.text$mn:00000000 _uchardet_new   proc near
.text$mn:00000000
.text$mn:00000000 var_18          = dword ptr -18h
.text$mn:00000000 var_14          = dword ptr -14h
.text$mn:00000000 var_10          = dword ptr -10h
.text$mn:00000000 var_C           = dword ptr -0Ch
.text$mn:00000000 var_4           = dword ptr -4
.text$mn:00000000
.text$mn:00000000                 push    ebp
.text$mn:00000001                 mov     ebp, esp
.text$mn:00000003                 push    0FFFFFFFFh
.text$mn:00000005                 push    offset __ehhandler$_uchardet_new
.text$mn:0000000A                 mov     eax, large fs:0
.text$mn:00000010                 push    eax
.text$mn:00000011                 sub     esp, 0Ch
.text$mn:00000014                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000019                 xor     eax, ebp
.text$mn:0000001B                 push    eax
.text$mn:0000001C                 lea     eax, [ebp+var_C]
.text$mn:0000001F                 mov     large fs:0, eax
.text$mn:00000025                 push    48h ; 'H'       ; unsigned int
.text$mn:00000027                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000002C                 add     esp, 4
.text$mn:0000002F                 mov     [ebp+var_10], eax
.text$mn:00000032                 mov     [ebp+var_4], 0
.text$mn:00000039                 cmp     [ebp+var_10], 0
.text$mn:0000003D                 jz      short loc_4C
.text$mn:0000003F                 mov     ecx, [ebp+var_10]
.text$mn:00000042                 call    ??0HandleUniversalDetector@@QAE@XZ ; HandleUniversalDetector::HandleUniversalDetector(void)
.text$mn:00000047                 mov     [ebp+var_14], eax
.text$mn:0000004A                 jmp     short loc_53
.text$mn:0000004C ; ---------------------------------------------------------------------------
.text$mn:0000004C
.text$mn:0000004C loc_4C:                                 ; CODE XREF: _uchardet_new+3Dj
.text$mn:0000004C                 mov     [ebp+var_14], 0
.text$mn:00000053
.text$mn:00000053 loc_53:                                 ; CODE XREF: _uchardet_new+4Aj
.text$mn:00000053                 mov     eax, [ebp+var_14]
.text$mn:00000056                 mov     [ebp+var_18], eax
.text$mn:00000059                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000060                 mov     eax, [ebp+var_18]
.text$mn:00000063                 mov     ecx, [ebp+var_C]
.text$mn:00000066                 mov     large fs:0, ecx
.text$mn:0000006D                 pop     ecx
.text$mn:0000006E                 mov     esp, ebp
.text$mn:00000070                 pop     ebp
.text$mn:00000071                 retn
.text$mn:00000071 _uchardet_new   endp
.text$mn:00000071
.text$mn:00000071 ; ---------------------------------------------------------------------------
.text$mn:00000072                 align 10h
.text$mn:00000080
.text$mn:00000080 ; =============== S U B R O U T I N E =======================================
.text$mn:00000080
.text$mn:00000080 ; Attributes: bp-based frame
.text$mn:00000080
.text$mn:00000080                 public _uchardet_delete
.text$mn:00000080 _uchardet_delete proc near
.text$mn:00000080
.text$mn:00000080 var_C           = dword ptr -0Ch
.text$mn:00000080 var_8           = dword ptr -8
.text$mn:00000080 var_4           = dword ptr -4
.text$mn:00000080 arg_0           = dword ptr  8
.text$mn:00000080
.text$mn:00000080                 push    ebp
.text$mn:00000081                 mov     ebp, esp
.text$mn:00000083                 sub     esp, 0Ch
.text$mn:00000086                 mov     eax, [ebp+arg_0]
.text$mn:00000089                 mov     [ebp+var_8], eax
.text$mn:0000008C                 mov     ecx, [ebp+var_8]
.text$mn:0000008F                 mov     [ebp+var_4], ecx
.text$mn:00000092                 cmp     [ebp+var_4], 0
.text$mn:00000096                 jz      short loc_AB
.text$mn:00000098                 push    1
.text$mn:0000009A                 mov     edx, [ebp+var_4]
.text$mn:0000009D                 mov     eax, [edx]
.text$mn:0000009F                 mov     ecx, [ebp+var_4]
.text$mn:000000A2                 mov     edx, [eax]
.text$mn:000000A4                 call    edx
.text$mn:000000A6                 mov     [ebp+var_C], eax
.text$mn:000000A9                 jmp     short loc_B2
.text$mn:000000AB ; ---------------------------------------------------------------------------
.text$mn:000000AB
.text$mn:000000AB loc_AB:                                 ; CODE XREF: _uchardet_delete+16j
.text$mn:000000AB                 mov     [ebp+var_C], 0
.text$mn:000000B2
.text$mn:000000B2 loc_B2:                                 ; CODE XREF: _uchardet_delete+29j
.text$mn:000000B2                 mov     esp, ebp
.text$mn:000000B4                 pop     ebp
.text$mn:000000B5                 retn
.text$mn:000000B5 _uchardet_delete endp
.text$mn:000000B5
.text$mn:000000B5 ; ---------------------------------------------------------------------------
.text$mn:000000B6                 align 10h
.text$mn:000000C0
.text$mn:000000C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000000C0
.text$mn:000000C0 ; Attributes: bp-based frame
.text$mn:000000C0
.text$mn:000000C0                 public _uchardet_handle_data
.text$mn:000000C0 _uchardet_handle_data proc near
.text$mn:000000C0
.text$mn:000000C0 var_8           = dword ptr -8
.text$mn:000000C0 var_4           = dword ptr -4
.text$mn:000000C0 arg_0           = dword ptr  8
.text$mn:000000C0 arg_4           = dword ptr  0Ch
.text$mn:000000C0 arg_8           = dword ptr  10h
.text$mn:000000C0
.text$mn:000000C0                 push    ebp
.text$mn:000000C1                 mov     ebp, esp
.text$mn:000000C3                 sub     esp, 8
.text$mn:000000C6                 mov     eax, [ebp+arg_8]
.text$mn:000000C9                 push    eax
.text$mn:000000CA                 mov     ecx, [ebp+arg_4]
.text$mn:000000CD                 push    ecx
.text$mn:000000CE                 mov     edx, [ebp+arg_0]
.text$mn:000000D1                 mov     eax, [edx]
.text$mn:000000D3                 mov     ecx, [ebp+arg_0]
.text$mn:000000D6                 mov     edx, [eax+4]
.text$mn:000000D9                 call    edx
.text$mn:000000DB                 mov     [ebp+var_8], eax
.text$mn:000000DE                 cmp     [ebp+var_8], 0
.text$mn:000000E2                 jz      short loc_ED
.text$mn:000000E4                 mov     [ebp+var_4], 1
.text$mn:000000EB                 jmp     short loc_F4
.text$mn:000000ED ; ---------------------------------------------------------------------------
.text$mn:000000ED
.text$mn:000000ED loc_ED:                                 ; CODE XREF: _uchardet_handle_data+22j
.text$mn:000000ED                 mov     [ebp+var_4], 0
.text$mn:000000F4
.text$mn:000000F4 loc_F4:                                 ; CODE XREF: _uchardet_handle_data+2Bj
.text$mn:000000F4                 mov     eax, [ebp+var_4]
.text$mn:000000F7                 mov     esp, ebp
.text$mn:000000F9                 pop     ebp
.text$mn:000000FA                 retn
.text$mn:000000FA _uchardet_handle_data endp
.text$mn:000000FA
.text$mn:000000FA ; ---------------------------------------------------------------------------
.text$mn:000000FB                 align 10h
.text$mn:00000100
.text$mn:00000100 ; =============== S U B R O U T I N E =======================================
.text$mn:00000100
.text$mn:00000100 ; Attributes: bp-based frame
.text$mn:00000100
.text$mn:00000100                 public _uchardet_data_end
.text$mn:00000100 _uchardet_data_end proc near
.text$mn:00000100
.text$mn:00000100 arg_0           = dword ptr  8
.text$mn:00000100
.text$mn:00000100                 push    ebp
.text$mn:00000101                 mov     ebp, esp
.text$mn:00000103                 mov     eax, [ebp+arg_0]
.text$mn:00000106                 mov     edx, [eax]
.text$mn:00000108                 mov     ecx, [ebp+arg_0]
.text$mn:0000010B                 mov     eax, [edx+8]
.text$mn:0000010E                 call    eax
.text$mn:00000110                 pop     ebp
.text$mn:00000111                 retn
.text$mn:00000111 _uchardet_data_end endp
.text$mn:00000111
.text$mn:00000111 ; ---------------------------------------------------------------------------
.text$mn:00000112                 align 10h
.text$mn:00000120
.text$mn:00000120 ; =============== S U B R O U T I N E =======================================
.text$mn:00000120
.text$mn:00000120 ; Attributes: bp-based frame
.text$mn:00000120
.text$mn:00000120                 public _uchardet_reset
.text$mn:00000120 _uchardet_reset proc near
.text$mn:00000120
.text$mn:00000120 arg_0           = dword ptr  8
.text$mn:00000120
.text$mn:00000120                 push    ebp
.text$mn:00000121                 mov     ebp, esp
.text$mn:00000123                 mov     eax, [ebp+arg_0]
.text$mn:00000126                 mov     edx, [eax]
.text$mn:00000128                 mov     ecx, [ebp+arg_0]
.text$mn:0000012B                 mov     eax, [edx+10h]
.text$mn:0000012E                 call    eax
.text$mn:00000130                 pop     ebp
.text$mn:00000131                 retn
.text$mn:00000131 _uchardet_reset endp
.text$mn:00000131
.text$mn:00000131 ; ---------------------------------------------------------------------------
.text$mn:00000132                 align 10h
.text$mn:00000140
.text$mn:00000140 ; =============== S U B R O U T I N E =======================================
.text$mn:00000140
.text$mn:00000140 ; Attributes: bp-based frame
.text$mn:00000140
.text$mn:00000140 ; int __cdecl uchardet_get_charset(HandleUniversalDetector *)
.text$mn:00000140                 public _uchardet_get_charset
.text$mn:00000140 _uchardet_get_charset proc near
.text$mn:00000140
.text$mn:00000140 arg_0           = dword ptr  8
.text$mn:00000140
.text$mn:00000140                 push    ebp
.text$mn:00000141                 mov     ebp, esp
.text$mn:00000143                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000146                 call    ?GetCharset@HandleUniversalDetector@@QBEPBDXZ ; HandleUniversalDetector::GetCharset(void)
.text$mn:0000014B                 pop     ebp
.text$mn:0000014C                 retn
.text$mn:0000014C _uchardet_get_charset endp
.text$mn:0000014C
.text$mn:0000014C ; ---------------------------------------------------------------------------
.text$mn:0000014D                 align 10h
.text$mn:0000014D _text$mn        ends
.text$mn:0000014D
.text$x:00000150 ; ===========================================================================
.text$x:00000150
.text$x:00000150 ; Segment type: Pure code
.text$x:00000150 ; Segment permissions: Read/Execute
.text$x:00000150 _text$x         segment para public 'CODE' use32
.text$x:00000150                 assume cs:_text$x
.text$x:00000150                 ;org 150h
.text$x:00000150                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000150
.text$x:00000150 ; =============== S U B R O U T I N E =======================================
.text$x:00000150
.text$x:00000150
.text$x:00000150 __unwindfunclet$_uchardet_new$0 proc near ; DATA XREF: .xdata$x:00001D0Co
.text$x:00000150                 mov     eax, [ebp-10h]
.text$x:00000153                 push    eax             ; void *
.text$x:00000154                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$x:00000159                 pop     ecx
.text$x:0000015A                 retn
.text$x:0000015A __unwindfunclet$_uchardet_new$0 endp
.text$x:0000015A
.text$x:0000015B
.text$x:0000015B ; =============== S U B R O U T I N E =======================================
.text$x:0000015B
.text$x:0000015B
.text$x:0000015B __ehhandler$_uchardet_new proc near     ; DATA XREF: _uchardet_new+5o
.text$x:0000015B
.text$x:0000015B arg_4           = dword ptr  8
.text$x:0000015B
.text$x:0000015B                 mov     edx, [esp+arg_4]
.text$x:0000015F                 lea     eax, [edx+0Ch]
.text$x:00000162                 mov     ecx, [edx-10h]
.text$x:00000165                 xor     ecx, eax
.text$x:00000167                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000016C                 mov     eax, offset __ehfuncinfo$_uchardet_new
.text$x:00000171                 jmp     ___CxxFrameHandler3
.text$x:00000171 __ehhandler$_uchardet_new endp
.text$x:00000171
.text$x:00000171 ; ---------------------------------------------------------------------------
.text$x:00000176                 align 4
.text$x:00000176 _text$x         ends
.text$x:00000176
.text$mn:00000178 ; ===========================================================================
.text$mn:00000178
.text$mn:00000178 ; Segment type: Pure code
.text$mn:00000178 ; Segment permissions: Read/Execute
.text$mn:00000178 _text$mn        segment para public 'CODE' use32
.text$mn:00000178                 assume cs:_text$mn
.text$mn:00000178                 ;org 178h
.text$mn:00000178 ; COMDAT (pick any)
.text$mn:00000178                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000178
.text$mn:00000178 ; =============== S U B R O U T I N E =======================================
.text$mn:00000178
.text$mn:00000178 ; Attributes: bp-based frame
.text$mn:00000178
.text$mn:00000178 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00000178                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00000178 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00000178                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00000178
.text$mn:00000178 var_4           = dword ptr -4
.text$mn:00000178 arg_0           = dword ptr  8
.text$mn:00000178
.text$mn:00000178                 push    ebp
.text$mn:00000179                 mov     ebp, esp
.text$mn:0000017B                 push    ecx
.text$mn:0000017C                 mov     [ebp+var_4], 0
.text$mn:00000183                 cmp     [ebp+arg_0], 0
.text$mn:00000187                 jnz     short loc_18B
.text$mn:00000189                 jmp     short loc_1AB
.text$mn:0000018B ; ---------------------------------------------------------------------------
.text$mn:0000018B
.text$mn:0000018B loc_18B:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:0000018B                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:0000018F                 ja      short loc_1A6
.text$mn:00000191                 mov     eax, [ebp+arg_0]
.text$mn:00000194                 push    eax             ; unsigned int
.text$mn:00000195                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000019A                 add     esp, 4
.text$mn:0000019D                 mov     [ebp+var_4], eax
.text$mn:000001A0                 cmp     [ebp+var_4], 0
.text$mn:000001A4                 jnz     short loc_1AB
.text$mn:000001A6
.text$mn:000001A6 loc_1A6:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000001A6                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000001AB
.text$mn:000001AB loc_1AB:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000001AB                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000001AB                 mov     eax, [ebp+var_4]
.text$mn:000001AE                 mov     esp, ebp
.text$mn:000001B0                 pop     ebp
.text$mn:000001B1                 retn
.text$mn:000001B1 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:000001B1
.text$mn:000001B1 ; ---------------------------------------------------------------------------
.text$mn:000001B2                 align 4
.text$mn:000001B2 _text$mn        ends
.text$mn:000001B2
.text$mn:000001B4 ; ===========================================================================
.text$mn:000001B4
.text$mn:000001B4 ; Segment type: Pure code
.text$mn:000001B4 ; Segment permissions: Read/Execute
.text$mn:000001B4 _text$mn        segment para public 'CODE' use32
.text$mn:000001B4                 assume cs:_text$mn
.text$mn:000001B4                 ;org 1B4h
.text$mn:000001B4 ; COMDAT (pick any)
.text$mn:000001B4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000001B4
.text$mn:000001B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000001B4
.text$mn:000001B4 ; Attributes: bp-based frame
.text$mn:000001B4
.text$mn:000001B4 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:000001B4                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:000001B4 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:000001B4                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:000001B4
.text$mn:000001B4 var_4           = dword ptr -4
.text$mn:000001B4 arg_0           = dword ptr  8
.text$mn:000001B4
.text$mn:000001B4                 push    ebp
.text$mn:000001B5                 mov     ebp, esp
.text$mn:000001B7                 push    ecx
.text$mn:000001B8                 mov     [ebp+var_4], 0
.text$mn:000001BF                 cmp     [ebp+arg_0], 0
.text$mn:000001C3                 jnz     short loc_1C7
.text$mn:000001C5                 jmp     short loc_1ED
.text$mn:000001C7 ; ---------------------------------------------------------------------------
.text$mn:000001C7
.text$mn:000001C7 loc_1C7:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:000001C7                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:000001CE                 ja      short loc_1E8
.text$mn:000001D0                 mov     eax, [ebp+arg_0]
.text$mn:000001D3                 shl     eax, 3
.text$mn:000001D6                 push    eax             ; unsigned int
.text$mn:000001D7                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000001DC                 add     esp, 4
.text$mn:000001DF                 mov     [ebp+var_4], eax
.text$mn:000001E2                 cmp     [ebp+var_4], 0
.text$mn:000001E6                 jnz     short loc_1ED
.text$mn:000001E8
.text$mn:000001E8 loc_1E8:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000001E8                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000001ED
.text$mn:000001ED loc_1ED:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000001ED                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000001ED                 mov     eax, [ebp+var_4]
.text$mn:000001F0                 mov     esp, ebp
.text$mn:000001F2                 pop     ebp
.text$mn:000001F3                 retn
.text$mn:000001F3 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000001F3
.text$mn:000001F3 _text$mn        ends
.text$mn:000001F3
.text$mn:000001F4 ; ===========================================================================
.text$mn:000001F4
.text$mn:000001F4 ; Segment type: Pure code
.text$mn:000001F4 ; Segment permissions: Read/Execute
.text$mn:000001F4 _text$mn        segment para public 'CODE' use32
.text$mn:000001F4                 assume cs:_text$mn
.text$mn:000001F4                 ;org 1F4h
.text$mn:000001F4 ; COMDAT (pick any)
.text$mn:000001F4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000001F4
.text$mn:000001F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000001F4
.text$mn:000001F4 ; Attributes: bp-based frame
.text$mn:000001F4
.text$mn:000001F4 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000001F4                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000001F4 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000001F4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000001F4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000001F4
.text$mn:000001F4 arg_0           = dword ptr  8
.text$mn:000001F4 arg_4           = dword ptr  0Ch
.text$mn:000001F4 arg_8           = dword ptr  10h
.text$mn:000001F4
.text$mn:000001F4                 push    ebp
.text$mn:000001F5                 mov     ebp, esp
.text$mn:000001F7                 cmp     [ebp+arg_0], 0
.text$mn:000001FB                 jnz     short loc_212
.text$mn:000001FD                 mov     eax, [ebp+arg_8]
.text$mn:00000200                 push    eax             ; unsigned int
.text$mn:00000201                 mov     ecx, [ebp+arg_4]
.text$mn:00000204                 push    ecx             ; wchar_t *
.text$mn:00000205                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000020A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000020F                 add     esp, 0Ch
.text$mn:00000212
.text$mn:00000212 loc_212:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00000212                 pop     ebp
.text$mn:00000213                 retn
.text$mn:00000213 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00000213
.text$mn:00000213 _text$mn        ends
.text$mn:00000213
.text$mn:00000214 ; ===========================================================================
.text$mn:00000214
.text$mn:00000214 ; Segment type: Pure code
.text$mn:00000214 ; Segment permissions: Read/Execute
.text$mn:00000214 _text$mn        segment para public 'CODE' use32
.text$mn:00000214                 assume cs:_text$mn
.text$mn:00000214                 ;org 214h
.text$mn:00000214 ; COMDAT (pick any)
.text$mn:00000214                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000214
.text$mn:00000214 ; =============== S U B R O U T I N E =======================================
.text$mn:00000214
.text$mn:00000214 ; Attributes: bp-based frame
.text$mn:00000214
.text$mn:00000214 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00000214                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00000214 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00000214                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00000214                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00000214
.text$mn:00000214 arg_0           = dword ptr  8
.text$mn:00000214
.text$mn:00000214                 push    ebp
.text$mn:00000215                 mov     ebp, esp
.text$mn:00000217                 mov     eax, [ebp+arg_0]
.text$mn:0000021A                 pop     ebp
.text$mn:0000021B                 retn
.text$mn:0000021B ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:0000021B
.text$mn:0000021B _text$mn        ends
.text$mn:0000021B
.text$mn:0000021C ; ===========================================================================
.text$mn:0000021C
.text$mn:0000021C ; Segment type: Pure code
.text$mn:0000021C ; Segment permissions: Read/Execute
.text$mn:0000021C _text$mn        segment para public 'CODE' use32
.text$mn:0000021C                 assume cs:_text$mn
.text$mn:0000021C                 ;org 21Ch
.text$mn:0000021C ; COMDAT (pick any)
.text$mn:0000021C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000021C
.text$mn:0000021C ; =============== S U B R O U T I N E =======================================
.text$mn:0000021C
.text$mn:0000021C ; Attributes: bp-based frame
.text$mn:0000021C
.text$mn:0000021C ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:0000021C                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:0000021C ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:0000021C                                         ; CODE XREF: $LN19+4Bp
.text$mn:0000021C
.text$mn:0000021C var_4           = dword ptr -4
.text$mn:0000021C arg_0           = dword ptr  8
.text$mn:0000021C arg_4           = dword ptr  0Ch
.text$mn:0000021C
.text$mn:0000021C                 push    ebp
.text$mn:0000021D                 mov     ebp, esp
.text$mn:0000021F                 push    ecx
.text$mn:00000220                 mov     [ebp+var_4], ecx
.text$mn:00000223                 mov     eax, [ebp+arg_4]
.text$mn:00000226                 push    eax
.text$mn:00000227                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000022C                 add     esp, 4
.text$mn:0000022F                 push    eax             ; int
.text$mn:00000230                 mov     ecx, [ebp+arg_0]
.text$mn:00000233                 push    ecx             ; void *
.text$mn:00000234                 mov     edx, [ebp+var_4]
.text$mn:00000237                 push    edx             ; int
.text$mn:00000238                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:0000023D                 add     esp, 0Ch
.text$mn:00000240                 mov     esp, ebp
.text$mn:00000242                 pop     ebp
.text$mn:00000243                 retn    8
.text$mn:00000243 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000243
.text$mn:00000243 ; ---------------------------------------------------------------------------
.text$mn:00000246                 align 4
.text$mn:00000246 _text$mn        ends
.text$mn:00000246
.text$mn:00000248 ; ===========================================================================
.text$mn:00000248
.text$mn:00000248 ; Segment type: Pure code
.text$mn:00000248 ; Segment permissions: Read/Execute
.text$mn:00000248 _text$mn        segment para public 'CODE' use32
.text$mn:00000248                 assume cs:_text$mn
.text$mn:00000248                 ;org 248h
.text$mn:00000248 ; COMDAT (pick any)
.text$mn:00000248                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000248
.text$mn:00000248 ; =============== S U B R O U T I N E =======================================
.text$mn:00000248
.text$mn:00000248 ; Attributes: bp-based frame
.text$mn:00000248
.text$mn:00000248 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00000248                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000248 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000248                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00000248
.text$mn:00000248 var_1C          = dword ptr -1Ch
.text$mn:00000248 var_18          = dword ptr -18h
.text$mn:00000248 var_14          = dword ptr -14h
.text$mn:00000248 var_10          = dword ptr -10h
.text$mn:00000248 var_C           = dword ptr -0Ch
.text$mn:00000248 var_4           = dword ptr -4
.text$mn:00000248 arg_0           = dword ptr  8
.text$mn:00000248 arg_4           = dword ptr  0Ch
.text$mn:00000248
.text$mn:00000248                 push    ebp
.text$mn:00000249                 mov     ebp, esp
.text$mn:0000024B                 push    0FFFFFFFFh
.text$mn:0000024D                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000252                 mov     eax, large fs:0
.text$mn:00000258                 push    eax
.text$mn:00000259                 sub     esp, 10h
.text$mn:0000025C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000261                 xor     eax, ebp
.text$mn:00000263                 push    eax
.text$mn:00000264                 lea     eax, [ebp+var_C]
.text$mn:00000267                 mov     large fs:0, eax
.text$mn:0000026D                 mov     [ebp+var_18], ecx
.text$mn:00000270                 mov     eax, [ebp+arg_0]
.text$mn:00000273                 push    eax             ; void *
.text$mn:00000274                 push    4               ; unsigned int
.text$mn:00000276                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000027B                 add     esp, 8
.text$mn:0000027E                 mov     [ebp+var_10], eax
.text$mn:00000281                 mov     [ebp+var_4], 0
.text$mn:00000288                 cmp     [ebp+var_10], 0
.text$mn:0000028C                 jz      short loc_2A9
.text$mn:0000028E                 mov     ecx, [ebp+arg_4]
.text$mn:00000291                 push    ecx
.text$mn:00000292                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000297                 add     esp, 4
.text$mn:0000029A                 mov     edx, [ebp+var_10]
.text$mn:0000029D                 mov     eax, [eax]
.text$mn:0000029F                 mov     [edx], eax
.text$mn:000002A1                 mov     ecx, [ebp+var_10]
.text$mn:000002A4                 mov     [ebp+var_14], ecx
.text$mn:000002A7                 jmp     short loc_2B0
.text$mn:000002A9 ; ---------------------------------------------------------------------------
.text$mn:000002A9
.text$mn:000002A9 loc_2A9:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000002A9                 mov     [ebp+var_14], 0
.text$mn:000002B0
.text$mn:000002B0 loc_2B0:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000002B0                 mov     edx, [ebp+var_14]
.text$mn:000002B3                 mov     [ebp+var_1C], edx
.text$mn:000002B6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000002BD                 mov     ecx, [ebp+var_C]
.text$mn:000002C0                 mov     large fs:0, ecx
.text$mn:000002C7                 pop     ecx
.text$mn:000002C8                 mov     esp, ebp
.text$mn:000002CA                 pop     ebp
.text$mn:000002CB                 retn    8
.text$mn:000002CB ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000002CB
.text$mn:000002CB ; ---------------------------------------------------------------------------
.text$mn:000002CE                 align 10h
.text$mn:000002CE _text$mn        ends
.text$mn:000002CE
.text$x:000002D0 ; ===========================================================================
.text$x:000002D0
.text$x:000002D0 ; Segment type: Pure code
.text$x:000002D0 ; Segment permissions: Read/Execute
.text$x:000002D0 _text$x         segment para public 'CODE' use32
.text$x:000002D0                 assume cs:_text$x
.text$x:000002D0                 ;org 2D0h
.text$x:000002D0 ; COMDAT (pick associative to section at 248)
.text$x:000002D0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000002D0
.text$x:000002D0 ; =============== S U B R O U T I N E =======================================
.text$x:000002D0
.text$x:000002D0
.text$x:000002D0 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000002D0                                         ; DATA XREF: .xdata$x:00002144o
.text$x:000002D0                 mov     eax, [ebp+8]
.text$x:000002D3                 push    eax
.text$x:000002D4                 mov     eax, [ebp-10h]
.text$x:000002D7                 push    eax             ; void *
.text$x:000002D8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000002DD                 add     esp, 8
.text$x:000002E0                 retn
.text$x:000002E0 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000002E0
.text$x:000002E1
.text$x:000002E1 ; =============== S U B R O U T I N E =======================================
.text$x:000002E1
.text$x:000002E1
.text$x:000002E1 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000002E1                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000002E1
.text$x:000002E1 arg_4           = dword ptr  8
.text$x:000002E1
.text$x:000002E1                 mov     edx, [esp+arg_4]
.text$x:000002E5                 lea     eax, [edx+0Ch]
.text$x:000002E8                 mov     ecx, [edx-14h]
.text$x:000002EB                 xor     ecx, eax
.text$x:000002ED                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000002F2                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000002F7                 jmp     ___CxxFrameHandler3
.text$x:000002F7 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000002F7
.text$x:000002F7 _text$x         ends
.text$x:000002F7
.text$mn:000002FC ; ===========================================================================
.text$mn:000002FC
.text$mn:000002FC ; Segment type: Pure code
.text$mn:000002FC ; Segment permissions: Read/Execute
.text$mn:000002FC _text$mn        segment para public 'CODE' use32
.text$mn:000002FC                 assume cs:_text$mn
.text$mn:000002FC                 ;org 2FCh
.text$mn:000002FC ; COMDAT (pick any)
.text$mn:000002FC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000002FC
.text$mn:000002FC ; =============== S U B R O U T I N E =======================================
.text$mn:000002FC
.text$mn:000002FC ; Attributes: bp-based frame
.text$mn:000002FC
.text$mn:000002FC ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000002FC                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000002FC ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000002FC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000002FC
.text$mn:000002FC arg_0           = dword ptr  8
.text$mn:000002FC arg_4           = dword ptr  0Ch
.text$mn:000002FC arg_8           = dword ptr  10h
.text$mn:000002FC
.text$mn:000002FC                 push    ebp
.text$mn:000002FD                 mov     ebp, esp
.text$mn:000002FF                 mov     eax, [ebp+arg_8]
.text$mn:00000302                 push    eax
.text$mn:00000303                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000308                 add     esp, 4
.text$mn:0000030B                 push    eax             ; int
.text$mn:0000030C                 mov     ecx, [ebp+arg_4]
.text$mn:0000030F                 push    ecx             ; void *
.text$mn:00000310                 mov     ecx, [ebp+arg_0]
.text$mn:00000313                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00000318                 pop     ebp
.text$mn:00000319                 retn
.text$mn:00000319 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00000319
.text$mn:00000319 ; ---------------------------------------------------------------------------
.text$mn:0000031A                 align 4
.text$mn:0000031A _text$mn        ends
.text$mn:0000031A
.text$mn:0000031C ; ===========================================================================
.text$mn:0000031C
.text$mn:0000031C ; Segment type: Pure code
.text$mn:0000031C ; Segment permissions: Read/Execute
.text$mn:0000031C _text$mn        segment para public 'CODE' use32
.text$mn:0000031C                 assume cs:_text$mn
.text$mn:0000031C                 ;org 31Ch
.text$mn:0000031C ; COMDAT (pick any)
.text$mn:0000031C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000031C
.text$mn:0000031C ; =============== S U B R O U T I N E =======================================
.text$mn:0000031C
.text$mn:0000031C ; Attributes: bp-based frame
.text$mn:0000031C
.text$mn:0000031C ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:0000031C                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000031C ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:0000031C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:0000031C
.text$mn:0000031C var_1C          = dword ptr -1Ch
.text$mn:0000031C var_18          = dword ptr -18h
.text$mn:0000031C var_14          = dword ptr -14h
.text$mn:0000031C var_10          = dword ptr -10h
.text$mn:0000031C var_C           = dword ptr -0Ch
.text$mn:0000031C var_4           = dword ptr -4
.text$mn:0000031C arg_0           = dword ptr  8
.text$mn:0000031C arg_4           = dword ptr  0Ch
.text$mn:0000031C
.text$mn:0000031C                 push    ebp
.text$mn:0000031D                 mov     ebp, esp
.text$mn:0000031F                 push    0FFFFFFFFh
.text$mn:00000321                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000326                 mov     eax, large fs:0
.text$mn:0000032C                 push    eax
.text$mn:0000032D                 sub     esp, 10h
.text$mn:00000330                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000335                 xor     eax, ebp
.text$mn:00000337                 push    eax
.text$mn:00000338                 lea     eax, [ebp+var_C]
.text$mn:0000033B                 mov     large fs:0, eax
.text$mn:00000341                 mov     [ebp+var_18], ecx
.text$mn:00000344                 mov     eax, [ebp+arg_0]
.text$mn:00000347                 push    eax             ; void *
.text$mn:00000348                 push    8               ; unsigned int
.text$mn:0000034A                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000034F                 add     esp, 8
.text$mn:00000352                 mov     [ebp+var_10], eax
.text$mn:00000355                 mov     [ebp+var_4], 0
.text$mn:0000035C                 cmp     [ebp+var_10], 0
.text$mn:00000360                 jz      short loc_383
.text$mn:00000362                 mov     ecx, [ebp+arg_4]
.text$mn:00000365                 push    ecx
.text$mn:00000366                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000036B                 add     esp, 4
.text$mn:0000036E                 mov     edx, [eax]
.text$mn:00000370                 mov     eax, [eax+4]
.text$mn:00000373                 mov     ecx, [ebp+var_10]
.text$mn:00000376                 mov     [ecx], edx
.text$mn:00000378                 mov     [ecx+4], eax
.text$mn:0000037B                 mov     edx, [ebp+var_10]
.text$mn:0000037E                 mov     [ebp+var_14], edx
.text$mn:00000381                 jmp     short loc_38A
.text$mn:00000383 ; ---------------------------------------------------------------------------
.text$mn:00000383
.text$mn:00000383 loc_383:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00000383                 mov     [ebp+var_14], 0
.text$mn:0000038A
.text$mn:0000038A loc_38A:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:0000038A                 mov     eax, [ebp+var_14]
.text$mn:0000038D                 mov     [ebp+var_1C], eax
.text$mn:00000390                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000397                 mov     ecx, [ebp+var_C]
.text$mn:0000039A                 mov     large fs:0, ecx
.text$mn:000003A1                 pop     ecx
.text$mn:000003A2                 mov     esp, ebp
.text$mn:000003A4                 pop     ebp
.text$mn:000003A5                 retn    8
.text$mn:000003A5 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000003A5
.text$mn:000003A5 _text$mn        ends
.text$mn:000003A5
.text$x:000003A8 ; ===========================================================================
.text$x:000003A8
.text$x:000003A8 ; Segment type: Pure code
.text$x:000003A8 ; Segment permissions: Read/Execute
.text$x:000003A8 _text$x         segment para public 'CODE' use32
.text$x:000003A8                 assume cs:_text$x
.text$x:000003A8                 ;org 3A8h
.text$x:000003A8 ; COMDAT (pick associative to section at 31C)
.text$x:000003A8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000003A8
.text$x:000003A8 ; =============== S U B R O U T I N E =======================================
.text$x:000003A8
.text$x:000003A8
.text$x:000003A8 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000003A8                                         ; DATA XREF: .xdata$x:00002118o
.text$x:000003A8                 mov     eax, [ebp+8]
.text$x:000003AB                 push    eax
.text$x:000003AC                 mov     eax, [ebp-10h]
.text$x:000003AF                 push    eax             ; void *
.text$x:000003B0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000003B5                 add     esp, 8
.text$x:000003B8                 retn
.text$x:000003B8 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:000003B8
.text$x:000003B9
.text$x:000003B9 ; =============== S U B R O U T I N E =======================================
.text$x:000003B9
.text$x:000003B9
.text$x:000003B9 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:000003B9                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:000003B9
.text$x:000003B9 arg_4           = dword ptr  8
.text$x:000003B9
.text$x:000003B9                 mov     edx, [esp+arg_4]
.text$x:000003BD                 lea     eax, [edx+0Ch]
.text$x:000003C0                 mov     ecx, [edx-14h]
.text$x:000003C3                 xor     ecx, eax
.text$x:000003C5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000003CA                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000003CF                 jmp     ___CxxFrameHandler3
.text$x:000003CF __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000003CF
.text$x:000003CF _text$x         ends
.text$x:000003CF
.text$mn:000003D4 ; ===========================================================================
.text$mn:000003D4
.text$mn:000003D4 ; Segment type: Pure code
.text$mn:000003D4 ; Segment permissions: Read/Execute
.text$mn:000003D4 _text$mn        segment para public 'CODE' use32
.text$mn:000003D4                 assume cs:_text$mn
.text$mn:000003D4                 ;org 3D4h
.text$mn:000003D4 ; COMDAT (pick any)
.text$mn:000003D4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000003D4
.text$mn:000003D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000003D4
.text$mn:000003D4 ; Attributes: bp-based frame
.text$mn:000003D4
.text$mn:000003D4 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000003D4                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:000003D4 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:000003D4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:000003D4
.text$mn:000003D4 var_4           = dword ptr -4
.text$mn:000003D4 arg_0           = dword ptr  8
.text$mn:000003D4
.text$mn:000003D4                 push    ebp
.text$mn:000003D5                 mov     ebp, esp
.text$mn:000003D7                 push    ecx
.text$mn:000003D8                 mov     [ebp+var_4], ecx
.text$mn:000003DB                 mov     eax, [ebp+arg_0]
.text$mn:000003DE                 push    eax
.text$mn:000003DF                 mov     ecx, [ebp+var_4]
.text$mn:000003E2                 push    ecx
.text$mn:000003E3                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:000003E8                 add     esp, 8
.text$mn:000003EB                 mov     esp, ebp
.text$mn:000003ED                 pop     ebp
.text$mn:000003EE                 retn    4
.text$mn:000003EE ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:000003EE
.text$mn:000003EE ; ---------------------------------------------------------------------------
.text$mn:000003F1                 align 4
.text$mn:000003F1 _text$mn        ends
.text$mn:000003F1
.text$mn:000003F4 ; ===========================================================================
.text$mn:000003F4
.text$mn:000003F4 ; Segment type: Pure code
.text$mn:000003F4 ; Segment permissions: Read/Execute
.text$mn:000003F4 _text$mn        segment para public 'CODE' use32
.text$mn:000003F4                 assume cs:_text$mn
.text$mn:000003F4                 ;org 3F4h
.text$mn:000003F4 ; COMDAT (pick any)
.text$mn:000003F4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000003F4
.text$mn:000003F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000003F4
.text$mn:000003F4 ; Attributes: bp-based frame
.text$mn:000003F4
.text$mn:000003F4 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:000003F4                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:000003F4 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:000003F4                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:000003F4
.text$mn:000003F4 var_4           = dword ptr -4
.text$mn:000003F4
.text$mn:000003F4                 push    ebp
.text$mn:000003F5                 mov     ebp, esp
.text$mn:000003F7                 push    ecx
.text$mn:000003F8                 mov     [ebp+var_4], ecx
.text$mn:000003FB                 mov     esp, ebp
.text$mn:000003FD                 pop     ebp
.text$mn:000003FE                 retn    4
.text$mn:000003FE ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:000003FE
.text$mn:000003FE ; ---------------------------------------------------------------------------
.text$mn:00000401                 align 4
.text$mn:00000401 _text$mn        ends
.text$mn:00000401
.text$mn:00000404 ; ===========================================================================
.text$mn:00000404
.text$mn:00000404 ; Segment type: Pure code
.text$mn:00000404 ; Segment permissions: Read/Execute
.text$mn:00000404 _text$mn        segment para public 'CODE' use32
.text$mn:00000404                 assume cs:_text$mn
.text$mn:00000404                 ;org 404h
.text$mn:00000404 ; COMDAT (pick any)
.text$mn:00000404                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000404
.text$mn:00000404 ; =============== S U B R O U T I N E =======================================
.text$mn:00000404
.text$mn:00000404 ; Attributes: bp-based frame
.text$mn:00000404
.text$mn:00000404 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00000404                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00000404 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00000404                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00000404
.text$mn:00000404 arg_0           = dword ptr  8
.text$mn:00000404 arg_4           = dword ptr  0Ch
.text$mn:00000404
.text$mn:00000404                 push    ebp
.text$mn:00000405                 mov     ebp, esp
.text$mn:00000407                 mov     eax, [ebp+arg_4]
.text$mn:0000040A                 push    eax
.text$mn:0000040B                 mov     ecx, [ebp+arg_0]
.text$mn:0000040E                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000413                 pop     ebp
.text$mn:00000414                 retn
.text$mn:00000414 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00000414
.text$mn:00000414 ; ---------------------------------------------------------------------------
.text$mn:00000415                 align 4
.text$mn:00000415 _text$mn        ends
.text$mn:00000415
.text$mn:00000418 ; ===========================================================================
.text$mn:00000418
.text$mn:00000418 ; Segment type: Pure code
.text$mn:00000418 ; Segment permissions: Read/Execute
.text$mn:00000418 _text$mn        segment para public 'CODE' use32
.text$mn:00000418                 assume cs:_text$mn
.text$mn:00000418                 ;org 418h
.text$mn:00000418 ; COMDAT (pick any)
.text$mn:00000418                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000418
.text$mn:00000418 ; =============== S U B R O U T I N E =======================================
.text$mn:00000418
.text$mn:00000418 ; Attributes: bp-based frame
.text$mn:00000418
.text$mn:00000418 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00000418                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00000418 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00000418                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00000418
.text$mn:00000418 var_4           = dword ptr -4
.text$mn:00000418
.text$mn:00000418                 push    ebp
.text$mn:00000419                 mov     ebp, esp
.text$mn:0000041B                 push    ecx
.text$mn:0000041C                 mov     [ebp+var_4], ecx
.text$mn:0000041F                 mov     esp, ebp
.text$mn:00000421                 pop     ebp
.text$mn:00000422                 retn    4
.text$mn:00000422 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00000422
.text$mn:00000422 ; ---------------------------------------------------------------------------
.text$mn:00000425                 align 4
.text$mn:00000425 _text$mn        ends
.text$mn:00000425
.text$mn:00000428 ; ===========================================================================
.text$mn:00000428
.text$mn:00000428 ; Segment type: Pure code
.text$mn:00000428 ; Segment permissions: Read/Execute
.text$mn:00000428 _text$mn        segment para public 'CODE' use32
.text$mn:00000428                 assume cs:_text$mn
.text$mn:00000428                 ;org 428h
.text$mn:00000428 ; COMDAT (pick any)
.text$mn:00000428                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000428
.text$mn:00000428 ; =============== S U B R O U T I N E =======================================
.text$mn:00000428
.text$mn:00000428 ; Attributes: bp-based frame
.text$mn:00000428
.text$mn:00000428 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00000428                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00000428 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00000428                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00000428                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00000428
.text$mn:00000428 arg_0           = dword ptr  8
.text$mn:00000428
.text$mn:00000428                 push    ebp
.text$mn:00000429                 mov     ebp, esp
.text$mn:0000042B                 mov     eax, [ebp+arg_0]
.text$mn:0000042E                 pop     ebp
.text$mn:0000042F                 retn
.text$mn:0000042F ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:0000042F
.text$mn:0000042F _text$mn        ends
.text$mn:0000042F
.text$mn:00000430 ; ===========================================================================
.text$mn:00000430
.text$mn:00000430 ; Segment type: Pure code
.text$mn:00000430 ; Segment permissions: Read/Execute
.text$mn:00000430 _text$mn        segment para public 'CODE' use32
.text$mn:00000430                 assume cs:_text$mn
.text$mn:00000430                 ;org 430h
.text$mn:00000430 ; COMDAT (pick any)
.text$mn:00000430                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000430
.text$mn:00000430 ; =============== S U B R O U T I N E =======================================
.text$mn:00000430
.text$mn:00000430 ; Attributes: bp-based frame
.text$mn:00000430
.text$mn:00000430 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00000430                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00000430 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00000430                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00000430
.text$mn:00000430 arg_0           = dword ptr  8
.text$mn:00000430
.text$mn:00000430                 push    ebp
.text$mn:00000431                 mov     ebp, esp
.text$mn:00000433                 mov     eax, [ebp+arg_0]
.text$mn:00000436                 pop     ebp
.text$mn:00000437                 retn
.text$mn:00000437 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00000437
.text$mn:00000437 _text$mn        ends
.text$mn:00000437
.text$mn:00000438 ; ===========================================================================
.text$mn:00000438
.text$mn:00000438 ; Segment type: Pure code
.text$mn:00000438 ; Segment permissions: Read/Execute
.text$mn:00000438 _text$mn        segment para public 'CODE' use32
.text$mn:00000438                 assume cs:_text$mn
.text$mn:00000438                 ;org 438h
.text$mn:00000438 ; COMDAT (pick any)
.text$mn:00000438                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000438
.text$mn:00000438 ; =============== S U B R O U T I N E =======================================
.text$mn:00000438
.text$mn:00000438 ; Attributes: bp-based frame
.text$mn:00000438
.text$mn:00000438 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00000438                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000438 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00000438                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00000438                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p
.text$mn:00000438
.text$mn:00000438 var_10          = dword ptr -10h
.text$mn:00000438 var_C           = dword ptr -0Ch
.text$mn:00000438 var_4           = dword ptr -4
.text$mn:00000438
.text$mn:00000438                 push    ebp
.text$mn:00000439                 mov     ebp, esp
.text$mn:0000043B                 push    0FFFFFFFFh
.text$mn:0000043D                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000442                 mov     eax, large fs:0
.text$mn:00000448                 push    eax
.text$mn:00000449                 push    ecx
.text$mn:0000044A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000044F                 xor     eax, ebp
.text$mn:00000451                 push    eax
.text$mn:00000452                 lea     eax, [ebp+var_C]
.text$mn:00000455                 mov     large fs:0, eax
.text$mn:0000045B                 mov     [ebp+var_10], ecx
.text$mn:0000045E                 mov     ecx, [ebp+var_10]
.text$mn:00000461                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00000466                 mov     [ebp+var_4], 0
.text$mn:0000046D                 mov     ecx, [ebp+var_10]
.text$mn:00000470                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000475                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000047C                 mov     eax, [ebp+var_10]
.text$mn:0000047F                 mov     ecx, [ebp+var_C]
.text$mn:00000482                 mov     large fs:0, ecx
.text$mn:00000489                 pop     ecx
.text$mn:0000048A                 mov     esp, ebp
.text$mn:0000048C                 pop     ebp
.text$mn:0000048D                 retn    4
.text$mn:0000048D ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:0000048D
.text$mn:0000048D _text$mn        ends
.text$mn:0000048D
.text$x:00000490 ; ===========================================================================
.text$x:00000490
.text$x:00000490 ; Segment type: Pure code
.text$x:00000490 ; Segment permissions: Read/Execute
.text$x:00000490 _text$x         segment para public 'CODE' use32
.text$x:00000490                 assume cs:_text$x
.text$x:00000490                 ;org 490h
.text$x:00000490 ; COMDAT (pick associative to section at 438)
.text$x:00000490                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000490
.text$x:00000490 ; =============== S U B R O U T I N E =======================================
.text$x:00000490
.text$x:00000490
.text$x:00000490 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000490                                         ; DATA XREF: .xdata$x:00001DBCo
.text$x:00000490                 mov     ecx, [ebp-10h]
.text$x:00000493                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000493 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00000493
.text$x:00000498
.text$x:00000498 ; =============== S U B R O U T I N E =======================================
.text$x:00000498
.text$x:00000498
.text$x:00000498 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00000498                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00000498
.text$x:00000498 arg_4           = dword ptr  8
.text$x:00000498
.text$x:00000498                 mov     edx, [esp+arg_4]
.text$x:0000049C                 lea     eax, [edx+0Ch]
.text$x:0000049F                 mov     ecx, [edx-8]
.text$x:000004A2                 xor     ecx, eax
.text$x:000004A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000004A9                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:000004AE                 jmp     ___CxxFrameHandler3
.text$x:000004AE __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:000004AE
.text$x:000004AE ; ---------------------------------------------------------------------------
.text$x:000004B3                 align 4
.text$x:000004B3 _text$x         ends
.text$x:000004B3
.text$mn:000004B4 ; ===========================================================================
.text$mn:000004B4
.text$mn:000004B4 ; Segment type: Pure code
.text$mn:000004B4 ; Segment permissions: Read/Execute
.text$mn:000004B4 _text$mn        segment para public 'CODE' use32
.text$mn:000004B4                 assume cs:_text$mn
.text$mn:000004B4                 ;org 4B4h
.text$mn:000004B4 ; COMDAT (pick any)
.text$mn:000004B4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000004B4
.text$mn:000004B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000004B4
.text$mn:000004B4 ; Attributes: bp-based frame
.text$mn:000004B4
.text$mn:000004B4 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000004B4                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000004B4 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000004B4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:000004B4
.text$mn:000004B4 var_10          = dword ptr -10h
.text$mn:000004B4 var_C           = dword ptr -0Ch
.text$mn:000004B4 var_4           = dword ptr -4
.text$mn:000004B4
.text$mn:000004B4                 push    ebp
.text$mn:000004B5                 mov     ebp, esp
.text$mn:000004B7                 push    0FFFFFFFFh
.text$mn:000004B9                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000004BE                 mov     eax, large fs:0
.text$mn:000004C4                 push    eax
.text$mn:000004C5                 push    ecx
.text$mn:000004C6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000004CB                 xor     eax, ebp
.text$mn:000004CD                 push    eax
.text$mn:000004CE                 lea     eax, [ebp+var_C]
.text$mn:000004D1                 mov     large fs:0, eax
.text$mn:000004D7                 mov     [ebp+var_10], ecx
.text$mn:000004DA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000004DD                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000004E2                 mov     [ebp+var_4], 0
.text$mn:000004E9                 mov     eax, [ebp+var_10]
.text$mn:000004EC                 mov     dword ptr [eax+14h], 0
.text$mn:000004F3                 mov     ecx, [ebp+var_10]
.text$mn:000004F6                 mov     dword ptr [ecx+18h], 0
.text$mn:000004FD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000504                 mov     eax, [ebp+var_10]
.text$mn:00000507                 mov     ecx, [ebp+var_C]
.text$mn:0000050A                 mov     large fs:0, ecx
.text$mn:00000511                 pop     ecx
.text$mn:00000512                 mov     esp, ebp
.text$mn:00000514                 pop     ebp
.text$mn:00000515                 retn
.text$mn:00000515 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000515
.text$mn:00000515 ; ---------------------------------------------------------------------------
.text$mn:00000516                 align 4
.text$mn:00000516 _text$mn        ends
.text$mn:00000516
.text$x:00000518 ; ===========================================================================
.text$x:00000518
.text$x:00000518 ; Segment type: Pure code
.text$x:00000518 ; Segment permissions: Read/Execute
.text$x:00000518 _text$x         segment para public 'CODE' use32
.text$x:00000518                 assume cs:_text$x
.text$x:00000518                 ;org 518h
.text$x:00000518 ; COMDAT (pick associative to section at 4B4)
.text$x:00000518                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000518
.text$x:00000518 ; =============== S U B R O U T I N E =======================================
.text$x:00000518
.text$x:00000518
.text$x:00000518 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000518                                         ; DATA XREF: .xdata$x:00001D64o
.text$x:00000518                 mov     ecx, [ebp-10h]  ; this
.text$x:0000051B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000051B __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000051B
.text$x:00000520
.text$x:00000520 ; =============== S U B R O U T I N E =======================================
.text$x:00000520
.text$x:00000520
.text$x:00000520 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000520                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000520
.text$x:00000520 arg_4           = dword ptr  8
.text$x:00000520
.text$x:00000520                 mov     edx, [esp+arg_4]
.text$x:00000524                 lea     eax, [edx+0Ch]
.text$x:00000527                 mov     ecx, [edx-8]
.text$x:0000052A                 xor     ecx, eax
.text$x:0000052C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000531                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000536                 jmp     ___CxxFrameHandler3
.text$x:00000536 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000536
.text$x:00000536 ; ---------------------------------------------------------------------------
.text$x:0000053B                 align 4
.text$x:0000053B _text$x         ends
.text$x:0000053B
.text$mn:0000053C ; ===========================================================================
.text$mn:0000053C
.text$mn:0000053C ; Segment type: Pure code
.text$mn:0000053C ; Segment permissions: Read/Execute
.text$mn:0000053C _text$mn        segment para public 'CODE' use32
.text$mn:0000053C                 assume cs:_text$mn
.text$mn:0000053C                 ;org 53Ch
.text$mn:0000053C ; COMDAT (pick any)
.text$mn:0000053C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000053C
.text$mn:0000053C ; =============== S U B R O U T I N E =======================================
.text$mn:0000053C
.text$mn:0000053C ; Attributes: bp-based frame
.text$mn:0000053C
.text$mn:0000053C ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:0000053C                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:0000053C ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:0000053C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:0000053C
.text$mn:0000053C var_4           = dword ptr -4
.text$mn:0000053C
.text$mn:0000053C                 push    ebp
.text$mn:0000053D                 mov     ebp, esp
.text$mn:0000053F                 push    ecx
.text$mn:00000540                 mov     [ebp+var_4], ecx
.text$mn:00000543                 mov     ecx, [ebp+var_4]
.text$mn:00000546                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000054B                 mov     eax, [ebp+var_4]
.text$mn:0000054E                 mov     esp, ebp
.text$mn:00000550                 pop     ebp
.text$mn:00000551                 retn
.text$mn:00000551 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00000551
.text$mn:00000551 ; ---------------------------------------------------------------------------
.text$mn:00000552                 align 4
.text$mn:00000552 _text$mn        ends
.text$mn:00000552
.text$mn:00000554 ; ===========================================================================
.text$mn:00000554
.text$mn:00000554 ; Segment type: Pure code
.text$mn:00000554 ; Segment permissions: Read/Execute
.text$mn:00000554 _text$mn        segment para public 'CODE' use32
.text$mn:00000554                 assume cs:_text$mn
.text$mn:00000554                 ;org 554h
.text$mn:00000554 ; COMDAT (pick any)
.text$mn:00000554                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000554
.text$mn:00000554 ; =============== S U B R O U T I N E =======================================
.text$mn:00000554
.text$mn:00000554 ; Attributes: bp-based frame
.text$mn:00000554
.text$mn:00000554 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00000554                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00000554 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00000554                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp ...
.text$mn:00000554
.text$mn:00000554 var_4           = dword ptr -4
.text$mn:00000554
.text$mn:00000554                 push    ebp
.text$mn:00000555                 mov     ebp, esp
.text$mn:00000557                 push    ecx
.text$mn:00000558                 mov     [ebp+var_4], ecx
.text$mn:0000055B                 mov     eax, [ebp+var_4]
.text$mn:0000055E                 mov     esp, ebp
.text$mn:00000560                 pop     ebp
.text$mn:00000561                 retn
.text$mn:00000561 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00000561
.text$mn:00000561 ; ---------------------------------------------------------------------------
.text$mn:00000562                 align 4
.text$mn:00000562 _text$mn        ends
.text$mn:00000562
.text$mn:00000564 ; ===========================================================================
.text$mn:00000564
.text$mn:00000564 ; Segment type: Pure code
.text$mn:00000564 ; Segment permissions: Read/Execute
.text$mn:00000564 _text$mn        segment para public 'CODE' use32
.text$mn:00000564                 assume cs:_text$mn
.text$mn:00000564                 ;org 564h
.text$mn:00000564 ; COMDAT (pick any)
.text$mn:00000564                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000564
.text$mn:00000564 ; =============== S U B R O U T I N E =======================================
.text$mn:00000564
.text$mn:00000564 ; Attributes: bp-based frame
.text$mn:00000564
.text$mn:00000564 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00000564                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00000564 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00000564                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00000564                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:00000564
.text$mn:00000564 var_4           = dword ptr -4
.text$mn:00000564
.text$mn:00000564                 push    ebp
.text$mn:00000565                 mov     ebp, esp
.text$mn:00000567                 push    ecx
.text$mn:00000568                 mov     [ebp+var_4], ecx
.text$mn:0000056B                 mov     eax, [ebp+var_4]
.text$mn:0000056E                 mov     esp, ebp
.text$mn:00000570                 pop     ebp
.text$mn:00000571                 retn
.text$mn:00000571 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00000571
.text$mn:00000571 ; ---------------------------------------------------------------------------
.text$mn:00000572                 align 4
.text$mn:00000572 _text$mn        ends
.text$mn:00000572
.text$mn:00000574 ; ===========================================================================
.text$mn:00000574
.text$mn:00000574 ; Segment type: Pure code
.text$mn:00000574 ; Segment permissions: Read/Execute
.text$mn:00000574 _text$mn        segment para public 'CODE' use32
.text$mn:00000574                 assume cs:_text$mn
.text$mn:00000574                 ;org 574h
.text$mn:00000574 ; COMDAT (pick any)
.text$mn:00000574                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000574
.text$mn:00000574 ; =============== S U B R O U T I N E =======================================
.text$mn:00000574
.text$mn:00000574 ; Attributes: bp-based frame
.text$mn:00000574
.text$mn:00000574 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00000574                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00000574 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00000574                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00000574                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00000574
.text$mn:00000574 var_14          = dword ptr -14h
.text$mn:00000574 var_D           = byte ptr -0Dh
.text$mn:00000574 var_C           = dword ptr -0Ch
.text$mn:00000574 var_4           = dword ptr -4
.text$mn:00000574 Str             = dword ptr  8
.text$mn:00000574
.text$mn:00000574                 push    ebp
.text$mn:00000575                 mov     ebp, esp
.text$mn:00000577                 push    0FFFFFFFFh
.text$mn:00000579                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000057E                 mov     eax, large fs:0
.text$mn:00000584                 push    eax
.text$mn:00000585                 sub     esp, 8
.text$mn:00000588                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000058D                 xor     eax, ebp
.text$mn:0000058F                 push    eax
.text$mn:00000590                 lea     eax, [ebp+var_C]
.text$mn:00000593                 mov     large fs:0, eax
.text$mn:00000599                 mov     [ebp+var_14], ecx
.text$mn:0000059C                 lea     ecx, [ebp+var_D]
.text$mn:0000059F                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000005A4                 push    eax
.text$mn:000005A5                 mov     ecx, [ebp+var_14]
.text$mn:000005A8                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000005AD                 mov     [ebp+var_4], 0
.text$mn:000005B4                 push    0               ; Size
.text$mn:000005B6                 push    0               ; char
.text$mn:000005B8                 mov     ecx, [ebp+var_14]
.text$mn:000005BB                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000005C0                 mov     eax, [ebp+Str]
.text$mn:000005C3                 push    eax             ; Str
.text$mn:000005C4                 mov     ecx, [ebp+var_14]
.text$mn:000005C7                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000005CC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000005D3                 mov     eax, [ebp+var_14]
.text$mn:000005D6                 mov     ecx, [ebp+var_C]
.text$mn:000005D9                 mov     large fs:0, ecx
.text$mn:000005E0                 pop     ecx
.text$mn:000005E1                 mov     esp, ebp
.text$mn:000005E3                 pop     ebp
.text$mn:000005E4                 retn    4
.text$mn:000005E4 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:000005E4
.text$mn:000005E4 ; ---------------------------------------------------------------------------
.text$mn:000005E7                 align 4
.text$mn:000005E7 _text$mn        ends
.text$mn:000005E7
.text$x:000005E8 ; ===========================================================================
.text$x:000005E8
.text$x:000005E8 ; Segment type: Pure code
.text$x:000005E8 ; Segment permissions: Read/Execute
.text$x:000005E8 _text$x         segment para public 'CODE' use32
.text$x:000005E8                 assume cs:_text$x
.text$x:000005E8                 ;org 5E8h
.text$x:000005E8 ; COMDAT (pick associative to section at 574)
.text$x:000005E8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000005E8
.text$x:000005E8 ; =============== S U B R O U T I N E =======================================
.text$x:000005E8
.text$x:000005E8
.text$x:000005E8 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:000005E8                                         ; DATA XREF: .xdata$x:00001E40o
.text$x:000005E8                 mov     ecx, [ebp-14h]
.text$x:000005EB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000005EB __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:000005EB
.text$x:000005F0
.text$x:000005F0 ; =============== S U B R O U T I N E =======================================
.text$x:000005F0
.text$x:000005F0
.text$x:000005F0 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:000005F0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:000005F0
.text$x:000005F0 arg_4           = dword ptr  8
.text$x:000005F0
.text$x:000005F0                 mov     edx, [esp+arg_4]
.text$x:000005F4                 lea     eax, [edx+0Ch]
.text$x:000005F7                 mov     ecx, [edx-0Ch]
.text$x:000005FA                 xor     ecx, eax
.text$x:000005FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000601                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00000606                 jmp     ___CxxFrameHandler3
.text$x:00000606 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00000606
.text$x:00000606 ; ---------------------------------------------------------------------------
.text$x:0000060B                 align 4
.text$x:0000060B _text$x         ends
.text$x:0000060B
.text$mn:0000060C ; ===========================================================================
.text$mn:0000060C
.text$mn:0000060C ; Segment type: Pure code
.text$mn:0000060C ; Segment permissions: Read/Execute
.text$mn:0000060C _text$mn        segment para public 'CODE' use32
.text$mn:0000060C                 assume cs:_text$mn
.text$mn:0000060C                 ;org 60Ch
.text$mn:0000060C ; COMDAT (pick any)
.text$mn:0000060C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000060C
.text$mn:0000060C ; =============== S U B R O U T I N E =======================================
.text$mn:0000060C
.text$mn:0000060C ; Attributes: bp-based frame
.text$mn:0000060C
.text$mn:0000060C ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:0000060C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000060C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:0000060C                                         ; CODE XREF: HandleUniversalDetector::HandleUniversalDetector(void)+46p
.text$mn:0000060C
.text$mn:0000060C var_14          = dword ptr -14h
.text$mn:0000060C var_D           = byte ptr -0Dh
.text$mn:0000060C var_C           = dword ptr -0Ch
.text$mn:0000060C var_4           = dword ptr -4
.text$mn:0000060C
.text$mn:0000060C                 push    ebp
.text$mn:0000060D                 mov     ebp, esp
.text$mn:0000060F                 push    0FFFFFFFFh
.text$mn:00000611                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000616                 mov     eax, large fs:0
.text$mn:0000061C                 push    eax
.text$mn:0000061D                 sub     esp, 8
.text$mn:00000620                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000625                 xor     eax, ebp
.text$mn:00000627                 push    eax
.text$mn:00000628                 lea     eax, [ebp+var_C]
.text$mn:0000062B                 mov     large fs:0, eax
.text$mn:00000631                 mov     [ebp+var_14], ecx
.text$mn:00000634                 lea     ecx, [ebp+var_D]
.text$mn:00000637                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000063C                 push    eax
.text$mn:0000063D                 mov     ecx, [ebp+var_14]
.text$mn:00000640                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00000645                 mov     [ebp+var_4], 0
.text$mn:0000064C                 push    0               ; Size
.text$mn:0000064E                 push    0               ; char
.text$mn:00000650                 mov     ecx, [ebp+var_14]
.text$mn:00000653                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000658                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000065F                 mov     eax, [ebp+var_14]
.text$mn:00000662                 mov     ecx, [ebp+var_C]
.text$mn:00000665                 mov     large fs:0, ecx
.text$mn:0000066C                 pop     ecx
.text$mn:0000066D                 mov     esp, ebp
.text$mn:0000066F                 pop     ebp
.text$mn:00000670                 retn
.text$mn:00000670 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00000670
.text$mn:00000670 ; ---------------------------------------------------------------------------
.text$mn:00000671                 align 4
.text$mn:00000671 _text$mn        ends
.text$mn:00000671
.text$x:00000674 ; ===========================================================================
.text$x:00000674
.text$x:00000674 ; Segment type: Pure code
.text$x:00000674 ; Segment permissions: Read/Execute
.text$x:00000674 _text$x         segment para public 'CODE' use32
.text$x:00000674                 assume cs:_text$x
.text$x:00000674                 ;org 674h
.text$x:00000674 ; COMDAT (pick associative to section at 60C)
.text$x:00000674                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000674
.text$x:00000674 ; =============== S U B R O U T I N E =======================================
.text$x:00000674
.text$x:00000674
.text$x:00000674 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00000674                                         ; DATA XREF: .xdata$x:00001E14o
.text$x:00000674                 mov     ecx, [ebp-14h]
.text$x:00000677                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000677 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00000677
.text$x:0000067C
.text$x:0000067C ; =============== S U B R O U T I N E =======================================
.text$x:0000067C
.text$x:0000067C
.text$x:0000067C __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:0000067C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:0000067C
.text$x:0000067C arg_4           = dword ptr  8
.text$x:0000067C
.text$x:0000067C                 mov     edx, [esp+arg_4]
.text$x:00000680                 lea     eax, [edx+0Ch]
.text$x:00000683                 mov     ecx, [edx-0Ch]
.text$x:00000686                 xor     ecx, eax
.text$x:00000688                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000068D                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00000692                 jmp     ___CxxFrameHandler3
.text$x:00000692 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00000692
.text$x:00000692 ; ---------------------------------------------------------------------------
.text$x:00000697                 align 4
.text$x:00000697 _text$x         ends
.text$x:00000697
.text$mn:00000698 ; ===========================================================================
.text$mn:00000698
.text$mn:00000698 ; Segment type: Pure code
.text$mn:00000698 ; Segment permissions: Read/Execute
.text$mn:00000698 _text$mn        segment para public 'CODE' use32
.text$mn:00000698                 assume cs:_text$mn
.text$mn:00000698                 ;org 698h
.text$mn:00000698 ; COMDAT (pick any)
.text$mn:00000698                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000698
.text$mn:00000698 ; =============== S U B R O U T I N E =======================================
.text$mn:00000698
.text$mn:00000698 ; Attributes: bp-based frame
.text$mn:00000698
.text$mn:00000698 ; public: __thiscall HandleUniversalDetector::HandleUniversalDetector(void)
.text$mn:00000698                 public ??0HandleUniversalDetector@@QAE@XZ
.text$mn:00000698 ??0HandleUniversalDetector@@QAE@XZ proc near
.text$mn:00000698                                         ; CODE XREF: _uchardet_new+42p
.text$mn:00000698
.text$mn:00000698 var_10          = dword ptr -10h
.text$mn:00000698 var_C           = dword ptr -0Ch
.text$mn:00000698 var_4           = dword ptr -4
.text$mn:00000698
.text$mn:00000698                 push    ebp
.text$mn:00000699                 mov     ebp, esp
.text$mn:0000069B                 push    0FFFFFFFFh
.text$mn:0000069D                 push    offset __ehhandler$??0HandleUniversalDetector@@QAE@XZ
.text$mn:000006A2                 mov     eax, large fs:0
.text$mn:000006A8                 push    eax
.text$mn:000006A9                 push    ecx
.text$mn:000006AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000006AF                 xor     eax, ebp
.text$mn:000006B1                 push    eax
.text$mn:000006B2                 lea     eax, [ebp+var_C]
.text$mn:000006B5                 mov     large fs:0, eax
.text$mn:000006BB                 mov     [ebp+var_10], ecx
.text$mn:000006BE                 push    1Fh             ; unsigned int
.text$mn:000006C0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000006C3                 call    ??0nsUniversalDetector@@QAE@I@Z ; nsUniversalDetector::nsUniversalDetector(uint)
.text$mn:000006C8                 mov     [ebp+var_4], 0
.text$mn:000006CF                 mov     eax, [ebp+var_10]
.text$mn:000006D2                 mov     dword ptr [eax], offset ??_7HandleUniversalDetector@@6B@ ; const HandleUniversalDetector::`vftable'
.text$mn:000006D8                 mov     ecx, [ebp+var_10]
.text$mn:000006DB                 add     ecx, 2Ch ; ','
.text$mn:000006DE                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:000006E3                 mov     byte ptr [ebp+var_4], 1
.text$mn:000006E7                 push    offset ??_C@_00CNPNBAHC@?$AA@ ; Str
.text$mn:000006EC                 mov     ecx, [ebp+var_10]
.text$mn:000006EF                 add     ecx, 2Ch ; ','
.text$mn:000006F2                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:000006F7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000006FE                 mov     eax, [ebp+var_10]
.text$mn:00000701                 mov     ecx, [ebp+var_C]
.text$mn:00000704                 mov     large fs:0, ecx
.text$mn:0000070B                 pop     ecx
.text$mn:0000070C                 mov     esp, ebp
.text$mn:0000070E                 pop     ebp
.text$mn:0000070F                 retn
.text$mn:0000070F ??0HandleUniversalDetector@@QAE@XZ endp
.text$mn:0000070F
.text$mn:0000070F _text$mn        ends
.text$mn:0000070F
.text$x:00000710 ; ===========================================================================
.text$x:00000710
.text$x:00000710 ; Segment type: Pure code
.text$x:00000710 ; Segment permissions: Read/Execute
.text$x:00000710 _text$x         segment para public 'CODE' use32
.text$x:00000710                 assume cs:_text$x
.text$x:00000710                 ;org 710h
.text$x:00000710 ; COMDAT (pick associative to section at 698)
.text$x:00000710                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000710
.text$x:00000710 ; =============== S U B R O U T I N E =======================================
.text$x:00000710
.text$x:00000710
.text$x:00000710 __unwindfunclet$??0HandleUniversalDetector@@QAE@XZ$0 proc near
.text$x:00000710                                         ; DATA XREF: .xdata$x:000020B0o
.text$x:00000710                 mov     ecx, [ebp-10h]  ; this
.text$x:00000713                 jmp     ??1nsUniversalDetector@@UAE@XZ ; nsUniversalDetector::~nsUniversalDetector(void)
.text$x:00000713 __unwindfunclet$??0HandleUniversalDetector@@QAE@XZ$0 endp
.text$x:00000713
.text$x:00000718
.text$x:00000718 ; =============== S U B R O U T I N E =======================================
.text$x:00000718
.text$x:00000718
.text$x:00000718 __unwindfunclet$??0HandleUniversalDetector@@QAE@XZ$1 proc near
.text$x:00000718                                         ; DATA XREF: .xdata$x:000020B8o
.text$x:00000718                 mov     ecx, [ebp-10h]
.text$x:0000071B                 add     ecx, 2Ch ; ','
.text$x:0000071E                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:0000071E __unwindfunclet$??0HandleUniversalDetector@@QAE@XZ$1 endp
.text$x:0000071E
.text$x:00000723
.text$x:00000723 ; =============== S U B R O U T I N E =======================================
.text$x:00000723
.text$x:00000723
.text$x:00000723 __ehhandler$??0HandleUniversalDetector@@QAE@XZ proc near
.text$x:00000723                                         ; DATA XREF: HandleUniversalDetector::HandleUniversalDetector(void)+5o
.text$x:00000723
.text$x:00000723 arg_4           = dword ptr  8
.text$x:00000723
.text$x:00000723                 mov     edx, [esp+arg_4]
.text$x:00000727                 lea     eax, [edx+0Ch]
.text$x:0000072A                 mov     ecx, [edx-8]
.text$x:0000072D                 xor     ecx, eax
.text$x:0000072F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000734                 mov     eax, offset __ehfuncinfo$??0HandleUniversalDetector@@QAE@XZ
.text$x:00000739                 jmp     ___CxxFrameHandler3
.text$x:00000739 __ehhandler$??0HandleUniversalDetector@@QAE@XZ endp
.text$x:00000739
.text$x:00000739 ; ---------------------------------------------------------------------------
.text$x:0000073E                 align 10h
.text$x:0000073E _text$x         ends
.text$x:0000073E
.text$mn:00000740 ; ===========================================================================
.text$mn:00000740
.text$mn:00000740 ; Segment type: Pure code
.text$mn:00000740 ; Segment permissions: Read/Execute
.text$mn:00000740 _text$mn        segment para public 'CODE' use32
.text$mn:00000740                 assume cs:_text$mn
.text$mn:00000740                 ;org 740h
.text$mn:00000740 ; COMDAT (pick any)
.text$mn:00000740                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000740
.text$mn:00000740 ; =============== S U B R O U T I N E =======================================
.text$mn:00000740
.text$mn:00000740 ; Attributes: bp-based frame
.text$mn:00000740
.text$mn:00000740 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000740                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00000740 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00000740                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00000740
.text$mn:00000740 var_4           = dword ptr -4
.text$mn:00000740
.text$mn:00000740                 push    ebp
.text$mn:00000741                 mov     ebp, esp
.text$mn:00000743                 push    ecx
.text$mn:00000744                 mov     [ebp+var_4], ecx
.text$mn:00000747                 mov     eax, [ebp+var_4]
.text$mn:0000074A                 mov     dword ptr [eax], 0
.text$mn:00000750                 mov     eax, [ebp+var_4]
.text$mn:00000753                 mov     esp, ebp
.text$mn:00000755                 pop     ebp
.text$mn:00000756                 retn
.text$mn:00000756 ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00000756
.text$mn:00000756 ; ---------------------------------------------------------------------------
.text$mn:00000757                 align 4
.text$mn:00000757 _text$mn        ends
.text$mn:00000757
.text$mn:00000758 ; ===========================================================================
.text$mn:00000758
.text$mn:00000758 ; Segment type: Pure code
.text$mn:00000758 ; Segment permissions: Read/Execute
.text$mn:00000758 _text$mn        segment para public 'CODE' use32
.text$mn:00000758                 assume cs:_text$mn
.text$mn:00000758                 ;org 758h
.text$mn:00000758 ; COMDAT (pick any)
.text$mn:00000758                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000758
.text$mn:00000758 ; =============== S U B R O U T I N E =======================================
.text$mn:00000758
.text$mn:00000758 ; Attributes: bp-based frame
.text$mn:00000758
.text$mn:00000758 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00000758                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00000758 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00000758                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00000758
.text$mn:00000758 var_4           = dword ptr -4
.text$mn:00000758
.text$mn:00000758                 push    ebp
.text$mn:00000759                 mov     ebp, esp
.text$mn:0000075B                 push    ecx
.text$mn:0000075C                 mov     [ebp+var_4], ecx
.text$mn:0000075F                 mov     eax, [ebp+var_4]
.text$mn:00000762                 mov     dword ptr [eax], 0
.text$mn:00000768                 mov     ecx, [ebp+var_4]
.text$mn:0000076B                 mov     dword ptr [ecx+4], 0
.text$mn:00000772                 mov     eax, [ebp+var_4]
.text$mn:00000775                 mov     esp, ebp
.text$mn:00000777                 pop     ebp
.text$mn:00000778                 retn
.text$mn:00000778 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00000778
.text$mn:00000778 ; ---------------------------------------------------------------------------
.text$mn:00000779                 align 4
.text$mn:00000779 _text$mn        ends
.text$mn:00000779
.text$mn:0000077C ; ===========================================================================
.text$mn:0000077C
.text$mn:0000077C ; Segment type: Pure code
.text$mn:0000077C ; Segment permissions: Read/Execute
.text$mn:0000077C _text$mn        segment para public 'CODE' use32
.text$mn:0000077C                 assume cs:_text$mn
.text$mn:0000077C                 ;org 77Ch
.text$mn:0000077C ; COMDAT (pick any)
.text$mn:0000077C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000077C
.text$mn:0000077C ; =============== S U B R O U T I N E =======================================
.text$mn:0000077C
.text$mn:0000077C ; Attributes: bp-based frame
.text$mn:0000077C
.text$mn:0000077C ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:0000077C                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000077C ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:0000077C                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:0000077C                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:0000077C
.text$mn:0000077C var_10          = dword ptr -10h
.text$mn:0000077C var_C           = dword ptr -0Ch
.text$mn:0000077C var_4           = dword ptr -4
.text$mn:0000077C
.text$mn:0000077C                 push    ebp
.text$mn:0000077D                 mov     ebp, esp
.text$mn:0000077F                 push    0FFFFFFFFh
.text$mn:00000781                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00000786                 mov     eax, large fs:0
.text$mn:0000078C                 push    eax
.text$mn:0000078D                 push    ecx
.text$mn:0000078E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000793                 xor     eax, ebp
.text$mn:00000795                 push    eax
.text$mn:00000796                 lea     eax, [ebp+var_C]
.text$mn:00000799                 mov     large fs:0, eax
.text$mn:0000079F                 mov     [ebp+var_10], ecx
.text$mn:000007A2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000007A5                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000007AA                 mov     [ebp+var_4], 0
.text$mn:000007B1                 mov     eax, [ebp+var_10]
.text$mn:000007B4                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000007BA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000007C1                 mov     eax, [ebp+var_10]
.text$mn:000007C4                 mov     ecx, [ebp+var_C]
.text$mn:000007C7                 mov     large fs:0, ecx
.text$mn:000007CE                 pop     ecx
.text$mn:000007CF                 mov     esp, ebp
.text$mn:000007D1                 pop     ebp
.text$mn:000007D2                 retn
.text$mn:000007D2 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000007D2
.text$mn:000007D2 ; ---------------------------------------------------------------------------
.text$mn:000007D3                 align 4
.text$mn:000007D3 _text$mn        ends
.text$mn:000007D3
.text$x:000007D4 ; ===========================================================================
.text$x:000007D4
.text$x:000007D4 ; Segment type: Pure code
.text$x:000007D4 ; Segment permissions: Read/Execute
.text$x:000007D4 _text$x         segment para public 'CODE' use32
.text$x:000007D4                 assume cs:_text$x
.text$x:000007D4                 ;org 7D4h
.text$x:000007D4 ; COMDAT (pick associative to section at 77C)
.text$x:000007D4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000007D4
.text$x:000007D4 ; =============== S U B R O U T I N E =======================================
.text$x:000007D4
.text$x:000007D4
.text$x:000007D4 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000007D4                                         ; DATA XREF: .xdata$x:00001F24o
.text$x:000007D4                 mov     ecx, [ebp-10h]  ; this
.text$x:000007D7                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000007D7 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000007D7
.text$x:000007DC
.text$x:000007DC ; =============== S U B R O U T I N E =======================================
.text$x:000007DC
.text$x:000007DC
.text$x:000007DC __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000007DC                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000007DC
.text$x:000007DC arg_4           = dword ptr  8
.text$x:000007DC
.text$x:000007DC                 mov     edx, [esp+arg_4]
.text$x:000007E0                 lea     eax, [edx+0Ch]
.text$x:000007E3                 mov     ecx, [edx-8]
.text$x:000007E6                 xor     ecx, eax
.text$x:000007E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000007ED                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000007F2                 jmp     ___CxxFrameHandler3
.text$x:000007F2 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000007F2
.text$x:000007F2 ; ---------------------------------------------------------------------------
.text$x:000007F7                 align 4
.text$x:000007F7 _text$x         ends
.text$x:000007F7
.text$mn:000007F8 ; ===========================================================================
.text$mn:000007F8
.text$mn:000007F8 ; Segment type: Pure code
.text$mn:000007F8 ; Segment permissions: Read/Execute
.text$mn:000007F8 _text$mn        segment para public 'CODE' use32
.text$mn:000007F8                 assume cs:_text$mn
.text$mn:000007F8                 ;org 7F8h
.text$mn:000007F8 ; COMDAT (pick any)
.text$mn:000007F8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000007F8
.text$mn:000007F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000007F8
.text$mn:000007F8 ; Attributes: bp-based frame
.text$mn:000007F8
.text$mn:000007F8 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000007F8                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000007F8 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:000007F8                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000007F8
.text$mn:000007F8 var_10          = dword ptr -10h
.text$mn:000007F8 var_C           = dword ptr -0Ch
.text$mn:000007F8 var_4           = dword ptr -4
.text$mn:000007F8
.text$mn:000007F8                 push    ebp
.text$mn:000007F9                 mov     ebp, esp
.text$mn:000007FB                 push    0FFFFFFFFh
.text$mn:000007FD                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00000802                 mov     eax, large fs:0
.text$mn:00000808                 push    eax
.text$mn:00000809                 push    ecx
.text$mn:0000080A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000080F                 xor     eax, ebp
.text$mn:00000811                 push    eax
.text$mn:00000812                 lea     eax, [ebp+var_C]
.text$mn:00000815                 mov     large fs:0, eax
.text$mn:0000081B                 mov     [ebp+var_10], ecx
.text$mn:0000081E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000821                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00000826                 mov     [ebp+var_4], 0
.text$mn:0000082D                 mov     eax, [ebp+var_10]
.text$mn:00000830                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00000836                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000083D                 mov     eax, [ebp+var_10]
.text$mn:00000840                 mov     ecx, [ebp+var_C]
.text$mn:00000843                 mov     large fs:0, ecx
.text$mn:0000084A                 pop     ecx
.text$mn:0000084B                 mov     esp, ebp
.text$mn:0000084D                 pop     ebp
.text$mn:0000084E                 retn
.text$mn:0000084E ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:0000084E
.text$mn:0000084E ; ---------------------------------------------------------------------------
.text$mn:0000084F                 align 10h
.text$mn:0000084F _text$mn        ends
.text$mn:0000084F
.text$x:00000850 ; ===========================================================================
.text$x:00000850
.text$x:00000850 ; Segment type: Pure code
.text$x:00000850 ; Segment permissions: Read/Execute
.text$x:00000850 _text$x         segment para public 'CODE' use32
.text$x:00000850                 assume cs:_text$x
.text$x:00000850                 ;org 850h
.text$x:00000850 ; COMDAT (pick associative to section at 7F8)
.text$x:00000850                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000850
.text$x:00000850 ; =============== S U B R O U T I N E =======================================
.text$x:00000850
.text$x:00000850
.text$x:00000850 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00000850                                         ; DATA XREF: .xdata$x:00001FA8o
.text$x:00000850                 mov     ecx, [ebp-10h]  ; this
.text$x:00000853                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000853 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00000853
.text$x:00000858
.text$x:00000858 ; =============== S U B R O U T I N E =======================================
.text$x:00000858
.text$x:00000858
.text$x:00000858 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00000858                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00000858
.text$x:00000858 arg_4           = dword ptr  8
.text$x:00000858
.text$x:00000858                 mov     edx, [esp+arg_4]
.text$x:0000085C                 lea     eax, [edx+0Ch]
.text$x:0000085F                 mov     ecx, [edx-8]
.text$x:00000862                 xor     ecx, eax
.text$x:00000864                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000869                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:0000086E                 jmp     ___CxxFrameHandler3
.text$x:0000086E __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:0000086E
.text$x:0000086E ; ---------------------------------------------------------------------------
.text$x:00000873                 align 4
.text$x:00000873 _text$x         ends
.text$x:00000873
.text$mn:00000874 ; ===========================================================================
.text$mn:00000874
.text$mn:00000874 ; Segment type: Pure code
.text$mn:00000874 ; Segment permissions: Read/Execute
.text$mn:00000874 _text$mn        segment para public 'CODE' use32
.text$mn:00000874                 assume cs:_text$mn
.text$mn:00000874                 ;org 874h
.text$mn:00000874 ; COMDAT (pick any)
.text$mn:00000874                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000874
.text$mn:00000874 ; =============== S U B R O U T I N E =======================================
.text$mn:00000874
.text$mn:00000874 ; Attributes: bp-based frame
.text$mn:00000874
.text$mn:00000874 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000874                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00000874 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00000874                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000874
.text$mn:00000874 var_10          = dword ptr -10h
.text$mn:00000874 var_C           = dword ptr -0Ch
.text$mn:00000874 var_4           = dword ptr -4
.text$mn:00000874
.text$mn:00000874                 push    ebp
.text$mn:00000875                 mov     ebp, esp
.text$mn:00000877                 push    0FFFFFFFFh
.text$mn:00000879                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:0000087E                 mov     eax, large fs:0
.text$mn:00000884                 push    eax
.text$mn:00000885                 push    ecx
.text$mn:00000886                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000088B                 xor     eax, ebp
.text$mn:0000088D                 push    eax
.text$mn:0000088E                 lea     eax, [ebp+var_C]
.text$mn:00000891                 mov     large fs:0, eax
.text$mn:00000897                 mov     [ebp+var_10], ecx
.text$mn:0000089A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000089D                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000008A2                 mov     [ebp+var_4], 0
.text$mn:000008A9                 mov     eax, [ebp+var_10]
.text$mn:000008AC                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:000008B2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000008B9                 mov     eax, [ebp+var_10]
.text$mn:000008BC                 mov     ecx, [ebp+var_C]
.text$mn:000008BF                 mov     large fs:0, ecx
.text$mn:000008C6                 pop     ecx
.text$mn:000008C7                 mov     esp, ebp
.text$mn:000008C9                 pop     ebp
.text$mn:000008CA                 retn
.text$mn:000008CA ??0_System_error_category@std@@QAE@XZ endp
.text$mn:000008CA
.text$mn:000008CA ; ---------------------------------------------------------------------------
.text$mn:000008CB                 align 4
.text$mn:000008CB _text$mn        ends
.text$mn:000008CB
.text$x:000008CC ; ===========================================================================
.text$x:000008CC
.text$x:000008CC ; Segment type: Pure code
.text$x:000008CC ; Segment permissions: Read/Execute
.text$x:000008CC _text$x         segment para public 'CODE' use32
.text$x:000008CC                 assume cs:_text$x
.text$x:000008CC                 ;org 8CCh
.text$x:000008CC ; COMDAT (pick associative to section at 874)
.text$x:000008CC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:000008CC
.text$x:000008CC ; =============== S U B R O U T I N E =======================================
.text$x:000008CC
.text$x:000008CC
.text$x:000008CC __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:000008CC                                         ; DATA XREF: .xdata$x:0000202Co
.text$x:000008CC                 mov     ecx, [ebp-10h]  ; this
.text$x:000008CF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000008CF __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:000008CF
.text$x:000008D4
.text$x:000008D4 ; =============== S U B R O U T I N E =======================================
.text$x:000008D4
.text$x:000008D4
.text$x:000008D4 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000008D4                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000008D4
.text$x:000008D4 arg_4           = dword ptr  8
.text$x:000008D4
.text$x:000008D4                 mov     edx, [esp+arg_4]
.text$x:000008D8                 lea     eax, [edx+0Ch]
.text$x:000008DB                 mov     ecx, [edx-8]
.text$x:000008DE                 xor     ecx, eax
.text$x:000008E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000008E5                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000008EA                 jmp     ___CxxFrameHandler3
.text$x:000008EA __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000008EA
.text$x:000008EA ; ---------------------------------------------------------------------------
.text$x:000008EF                 align 10h
.text$x:000008EF _text$x         ends
.text$x:000008EF
.text$mn:000008F0 ; ===========================================================================
.text$mn:000008F0
.text$mn:000008F0 ; Segment type: Pure code
.text$mn:000008F0 ; Segment permissions: Read/Execute
.text$mn:000008F0 _text$mn        segment para public 'CODE' use32
.text$mn:000008F0                 assume cs:_text$mn
.text$mn:000008F0                 ;org 8F0h
.text$mn:000008F0 ; COMDAT (pick any)
.text$mn:000008F0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000008F0
.text$mn:000008F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000008F0
.text$mn:000008F0 ; Attributes: bp-based frame
.text$mn:000008F0
.text$mn:000008F0 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000008F0                 public ??0error_category@std@@QAE@XZ
.text$mn:000008F0 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000008F0
.text$mn:000008F0 var_4           = dword ptr -4
.text$mn:000008F0
.text$mn:000008F0                 push    ebp
.text$mn:000008F1                 mov     ebp, esp
.text$mn:000008F3                 push    ecx
.text$mn:000008F4                 mov     [ebp+var_4], ecx
.text$mn:000008F7                 mov     eax, [ebp+var_4]
.text$mn:000008FA                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000900                 mov     eax, [ebp+var_4]
.text$mn:00000903                 mov     esp, ebp
.text$mn:00000905                 pop     ebp
.text$mn:00000906                 retn
.text$mn:00000906 ??0error_category@std@@QAE@XZ endp
.text$mn:00000906
.text$mn:00000906 ; ---------------------------------------------------------------------------
.text$mn:00000907                 align 4
.text$mn:00000907 _text$mn        ends
.text$mn:00000907
.text$mn:00000908 ; ===========================================================================
.text$mn:00000908
.text$mn:00000908 ; Segment type: Pure code
.text$mn:00000908 ; Segment permissions: Read/Execute
.text$mn:00000908 _text$mn        segment para public 'CODE' use32
.text$mn:00000908                 assume cs:_text$mn
.text$mn:00000908                 ;org 908h
.text$mn:00000908 ; COMDAT (pick any)
.text$mn:00000908                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000908
.text$mn:00000908 ; =============== S U B R O U T I N E =======================================
.text$mn:00000908
.text$mn:00000908 ; Attributes: bp-based frame
.text$mn:00000908
.text$mn:00000908 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00000908                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00000908 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00000908                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00000908                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00000908
.text$mn:00000908 var_4           = dword ptr -4
.text$mn:00000908 arg_0           = dword ptr  8
.text$mn:00000908 arg_4           = dword ptr  0Ch
.text$mn:00000908
.text$mn:00000908                 push    ebp
.text$mn:00000909                 mov     ebp, esp
.text$mn:0000090B                 push    ecx
.text$mn:0000090C                 mov     [ebp+var_4], ecx
.text$mn:0000090F                 mov     eax, [ebp+var_4]
.text$mn:00000912                 mov     ecx, [ebp+arg_0]
.text$mn:00000915                 mov     [eax], ecx
.text$mn:00000917                 mov     edx, [ebp+var_4]
.text$mn:0000091A                 mov     eax, [ebp+arg_4]
.text$mn:0000091D                 mov     [edx+4], eax
.text$mn:00000920                 mov     eax, [ebp+var_4]
.text$mn:00000923                 mov     esp, ebp
.text$mn:00000925                 pop     ebp
.text$mn:00000926                 retn    8
.text$mn:00000926 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00000926
.text$mn:00000926 ; ---------------------------------------------------------------------------
.text$mn:00000929                 align 4
.text$mn:00000929 _text$mn        ends
.text$mn:00000929
.text$mn:0000092C ; ===========================================================================
.text$mn:0000092C
.text$mn:0000092C ; Segment type: Pure code
.text$mn:0000092C ; Segment permissions: Read/Execute
.text$mn:0000092C _text$mn        segment para public 'CODE' use32
.text$mn:0000092C                 assume cs:_text$mn
.text$mn:0000092C                 ;org 92Ch
.text$mn:0000092C ; COMDAT (pick any)
.text$mn:0000092C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000092C
.text$mn:0000092C ; =============== S U B R O U T I N E =======================================
.text$mn:0000092C
.text$mn:0000092C ; Attributes: bp-based frame
.text$mn:0000092C
.text$mn:0000092C ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:0000092C                 public ??0id@locale@std@@QAE@I@Z
.text$mn:0000092C ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:0000092C                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:0000092C
.text$mn:0000092C var_4           = dword ptr -4
.text$mn:0000092C arg_0           = dword ptr  8
.text$mn:0000092C
.text$mn:0000092C                 push    ebp
.text$mn:0000092D                 mov     ebp, esp
.text$mn:0000092F                 push    ecx
.text$mn:00000930                 mov     [ebp+var_4], ecx
.text$mn:00000933                 mov     eax, [ebp+var_4]
.text$mn:00000936                 mov     ecx, [ebp+arg_0]
.text$mn:00000939                 mov     [eax], ecx
.text$mn:0000093B                 mov     eax, [ebp+var_4]
.text$mn:0000093E                 mov     esp, ebp
.text$mn:00000940                 pop     ebp
.text$mn:00000941                 retn    4
.text$mn:00000941 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00000941
.text$mn:00000941 _text$mn        ends
.text$mn:00000941
.text$mn:00000944 ; ===========================================================================
.text$mn:00000944
.text$mn:00000944 ; Segment type: Pure code
.text$mn:00000944 ; Segment permissions: Read/Execute
.text$mn:00000944 _text$mn        segment para public 'CODE' use32
.text$mn:00000944                 assume cs:_text$mn
.text$mn:00000944                 ;org 944h
.text$mn:00000944 ; COMDAT (pick any)
.text$mn:00000944                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000944
.text$mn:00000944 ; =============== S U B R O U T I N E =======================================
.text$mn:00000944
.text$mn:00000944 ; Attributes: bp-based frame
.text$mn:00000944
.text$mn:00000944 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00000944                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00000944 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00000944                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00000944                                         ; __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0+3j ...
.text$mn:00000944
.text$mn:00000944 var_10          = dword ptr -10h
.text$mn:00000944 var_C           = dword ptr -0Ch
.text$mn:00000944 var_4           = dword ptr -4
.text$mn:00000944
.text$mn:00000944                 push    ebp
.text$mn:00000945                 mov     ebp, esp
.text$mn:00000947                 push    0FFFFFFFFh
.text$mn:00000949                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000094E                 mov     eax, large fs:0
.text$mn:00000954                 push    eax
.text$mn:00000955                 push    ecx
.text$mn:00000956                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000095B                 xor     eax, ebp
.text$mn:0000095D                 push    eax
.text$mn:0000095E                 lea     eax, [ebp+var_C]
.text$mn:00000961                 mov     large fs:0, eax
.text$mn:00000967                 mov     [ebp+var_10], ecx
.text$mn:0000096A                 mov     [ebp+var_4], 0
.text$mn:00000971                 mov     ecx, [ebp+var_10]
.text$mn:00000974                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00000979                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000980                 mov     ecx, [ebp+var_10]
.text$mn:00000983                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00000988                 mov     ecx, [ebp+var_C]
.text$mn:0000098B                 mov     large fs:0, ecx
.text$mn:00000992                 pop     ecx
.text$mn:00000993                 mov     esp, ebp
.text$mn:00000995                 pop     ebp
.text$mn:00000996                 retn
.text$mn:00000996 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00000996
.text$mn:00000996 ; ---------------------------------------------------------------------------
.text$mn:00000997                 align 4
.text$mn:00000997 _text$mn        ends
.text$mn:00000997
.text$x:00000998 ; ===========================================================================
.text$x:00000998
.text$x:00000998 ; Segment type: Pure code
.text$x:00000998 ; Segment permissions: Read/Execute
.text$x:00000998 _text$x         segment para public 'CODE' use32
.text$x:00000998                 assume cs:_text$x
.text$x:00000998                 ;org 998h
.text$x:00000998 ; COMDAT (pick associative to section at 944)
.text$x:00000998                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000998
.text$x:00000998 ; =============== S U B R O U T I N E =======================================
.text$x:00000998
.text$x:00000998
.text$x:00000998 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00000998                                         ; DATA XREF: .xdata$x:00001DE8o
.text$x:00000998                 mov     ecx, [ebp-10h]
.text$x:0000099B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000099B __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000099B
.text$x:000009A0
.text$x:000009A0 ; =============== S U B R O U T I N E =======================================
.text$x:000009A0
.text$x:000009A0
.text$x:000009A0 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:000009A0                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:000009A0
.text$x:000009A0 arg_4           = dword ptr  8
.text$x:000009A0
.text$x:000009A0                 mov     edx, [esp+arg_4]
.text$x:000009A4                 lea     eax, [edx+0Ch]
.text$x:000009A7                 mov     ecx, [edx-8]
.text$x:000009AA                 xor     ecx, eax
.text$x:000009AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000009B1                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:000009B6                 jmp     ___CxxFrameHandler3
.text$x:000009B6 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:000009B6
.text$x:000009B6 ; ---------------------------------------------------------------------------
.text$x:000009BB                 align 4
.text$x:000009BB _text$x         ends
.text$x:000009BB
.text$mn:000009BC ; ===========================================================================
.text$mn:000009BC
.text$mn:000009BC ; Segment type: Pure code
.text$mn:000009BC ; Segment permissions: Read/Execute
.text$mn:000009BC _text$mn        segment para public 'CODE' use32
.text$mn:000009BC                 assume cs:_text$mn
.text$mn:000009BC                 ;org 9BCh
.text$mn:000009BC ; COMDAT (pick any)
.text$mn:000009BC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000009BC
.text$mn:000009BC ; =============== S U B R O U T I N E =======================================
.text$mn:000009BC
.text$mn:000009BC ; Attributes: bp-based frame
.text$mn:000009BC
.text$mn:000009BC ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:000009BC                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000009BC ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:000009BC                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:000009BC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:000009BC
.text$mn:000009BC var_10          = dword ptr -10h
.text$mn:000009BC var_C           = dword ptr -0Ch
.text$mn:000009BC var_4           = dword ptr -4
.text$mn:000009BC
.text$mn:000009BC                 push    ebp
.text$mn:000009BD                 mov     ebp, esp
.text$mn:000009BF                 push    0FFFFFFFFh
.text$mn:000009C1                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:000009C6                 mov     eax, large fs:0
.text$mn:000009CC                 push    eax
.text$mn:000009CD                 push    ecx
.text$mn:000009CE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000009D3                 xor     eax, ebp
.text$mn:000009D5                 push    eax
.text$mn:000009D6                 lea     eax, [ebp+var_C]
.text$mn:000009D9                 mov     large fs:0, eax
.text$mn:000009DF                 mov     [ebp+var_10], ecx
.text$mn:000009E2                 mov     [ebp+var_4], 0
.text$mn:000009E9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000009F0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000009F3                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000009F8                 mov     ecx, [ebp+var_C]
.text$mn:000009FB                 mov     large fs:0, ecx
.text$mn:00000A02                 pop     ecx
.text$mn:00000A03                 mov     esp, ebp
.text$mn:00000A05                 pop     ebp
.text$mn:00000A06                 retn
.text$mn:00000A06 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000A06
.text$mn:00000A06 ; ---------------------------------------------------------------------------
.text$mn:00000A07                 align 4
.text$mn:00000A07 _text$mn        ends
.text$mn:00000A07
.text$x:00000A08 ; ===========================================================================
.text$x:00000A08
.text$x:00000A08 ; Segment type: Pure code
.text$x:00000A08 ; Segment permissions: Read/Execute
.text$x:00000A08 _text$x         segment para public 'CODE' use32
.text$x:00000A08                 assume cs:_text$x
.text$x:00000A08                 ;org 0A08h
.text$x:00000A08 ; COMDAT (pick associative to section at 9BC)
.text$x:00000A08                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000A08
.text$x:00000A08 ; =============== S U B R O U T I N E =======================================
.text$x:00000A08
.text$x:00000A08
.text$x:00000A08 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000A08                                         ; DATA XREF: .xdata$x:00001D90o
.text$x:00000A08                 mov     ecx, [ebp-10h]  ; this
.text$x:00000A0B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000A0B __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000A0B
.text$x:00000A10
.text$x:00000A10 ; =============== S U B R O U T I N E =======================================
.text$x:00000A10
.text$x:00000A10
.text$x:00000A10 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000A10                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000A10
.text$x:00000A10 arg_4           = dword ptr  8
.text$x:00000A10
.text$x:00000A10                 mov     edx, [esp+arg_4]
.text$x:00000A14                 lea     eax, [edx+0Ch]
.text$x:00000A17                 mov     ecx, [edx-8]
.text$x:00000A1A                 xor     ecx, eax
.text$x:00000A1C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A21                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000A26                 jmp     ___CxxFrameHandler3
.text$x:00000A26 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000A26
.text$x:00000A26 ; ---------------------------------------------------------------------------
.text$x:00000A2B                 align 4
.text$x:00000A2B _text$x         ends
.text$x:00000A2B
.text$mn:00000A2C ; ===========================================================================
.text$mn:00000A2C
.text$mn:00000A2C ; Segment type: Pure code
.text$mn:00000A2C ; Segment permissions: Read/Execute
.text$mn:00000A2C _text$mn        segment para public 'CODE' use32
.text$mn:00000A2C                 assume cs:_text$mn
.text$mn:00000A2C                 ;org 0A2Ch
.text$mn:00000A2C ; COMDAT (pick any)
.text$mn:00000A2C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000A2C
.text$mn:00000A2C ; =============== S U B R O U T I N E =======================================
.text$mn:00000A2C
.text$mn:00000A2C ; Attributes: bp-based frame
.text$mn:00000A2C
.text$mn:00000A2C ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00000A2C                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000A2C ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00000A2C                                         ; CODE XREF: __unwindfunclet$??0HandleUniversalDetector@@QAE@XZ$1+6j
.text$mn:00000A2C                                         ; HandleUniversalDetector::~HandleUniversalDetector(void)+40p ...
.text$mn:00000A2C
.text$mn:00000A2C var_10          = dword ptr -10h
.text$mn:00000A2C var_C           = dword ptr -0Ch
.text$mn:00000A2C var_4           = dword ptr -4
.text$mn:00000A2C
.text$mn:00000A2C                 push    ebp
.text$mn:00000A2D                 mov     ebp, esp
.text$mn:00000A2F                 push    0FFFFFFFFh
.text$mn:00000A31                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00000A36                 mov     eax, large fs:0
.text$mn:00000A3C                 push    eax
.text$mn:00000A3D                 push    ecx
.text$mn:00000A3E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A43                 xor     eax, ebp
.text$mn:00000A45                 push    eax
.text$mn:00000A46                 lea     eax, [ebp+var_C]
.text$mn:00000A49                 mov     large fs:0, eax
.text$mn:00000A4F                 mov     [ebp+var_10], ecx
.text$mn:00000A52                 mov     [ebp+var_4], 0
.text$mn:00000A59                 push    0               ; Size
.text$mn:00000A5B                 push    1               ; char
.text$mn:00000A5D                 mov     ecx, [ebp+var_10]
.text$mn:00000A60                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00000A65                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000A6C                 mov     ecx, [ebp+var_10]
.text$mn:00000A6F                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00000A74                 mov     ecx, [ebp+var_C]
.text$mn:00000A77                 mov     large fs:0, ecx
.text$mn:00000A7E                 pop     ecx
.text$mn:00000A7F                 mov     esp, ebp
.text$mn:00000A81                 pop     ebp
.text$mn:00000A82                 retn
.text$mn:00000A82 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00000A82
.text$mn:00000A82 ; ---------------------------------------------------------------------------
.text$mn:00000A83                 align 4
.text$mn:00000A83 _text$mn        ends
.text$mn:00000A83
.text$x:00000A84 ; ===========================================================================
.text$x:00000A84
.text$x:00000A84 ; Segment type: Pure code
.text$x:00000A84 ; Segment permissions: Read/Execute
.text$x:00000A84 _text$x         segment para public 'CODE' use32
.text$x:00000A84                 assume cs:_text$x
.text$x:00000A84                 ;org 0A84h
.text$x:00000A84 ; COMDAT (pick associative to section at A2C)
.text$x:00000A84                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000A84
.text$x:00000A84 ; =============== S U B R O U T I N E =======================================
.text$x:00000A84
.text$x:00000A84
.text$x:00000A84 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00000A84                                         ; DATA XREF: .xdata$x:00001E6Co
.text$x:00000A84                 mov     ecx, [ebp-10h]
.text$x:00000A87                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00000A87 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00000A87
.text$x:00000A8C
.text$x:00000A8C ; =============== S U B R O U T I N E =======================================
.text$x:00000A8C
.text$x:00000A8C
.text$x:00000A8C __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00000A8C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00000A8C
.text$x:00000A8C arg_4           = dword ptr  8
.text$x:00000A8C
.text$x:00000A8C                 mov     edx, [esp+arg_4]
.text$x:00000A90                 lea     eax, [edx+0Ch]
.text$x:00000A93                 mov     ecx, [edx-8]
.text$x:00000A96                 xor     ecx, eax
.text$x:00000A98                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000A9D                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00000AA2                 jmp     ___CxxFrameHandler3
.text$x:00000AA2 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00000AA2
.text$x:00000AA2 ; ---------------------------------------------------------------------------
.text$x:00000AA7                 align 4
.text$x:00000AA7 _text$x         ends
.text$x:00000AA7
.text$mn:00000AA8 ; ===========================================================================
.text$mn:00000AA8
.text$mn:00000AA8 ; Segment type: Pure code
.text$mn:00000AA8 ; Segment permissions: Read/Execute
.text$mn:00000AA8 _text$mn        segment para public 'CODE' use32
.text$mn:00000AA8                 assume cs:_text$mn
.text$mn:00000AA8                 ;org 0AA8h
.text$mn:00000AA8 ; COMDAT (pick any)
.text$mn:00000AA8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000AA8
.text$mn:00000AA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000AA8
.text$mn:00000AA8 ; Attributes: bp-based frame
.text$mn:00000AA8
.text$mn:00000AA8 ; _DWORD __thiscall HandleUniversalDetector::~HandleUniversalDetector(HandleUniversalDetector *__hidden this)
.text$mn:00000AA8                 public ??1HandleUniversalDetector@@UAE@XZ
.text$mn:00000AA8 ??1HandleUniversalDetector@@UAE@XZ proc near
.text$mn:00000AA8                                         ; CODE XREF: HandleUniversalDetector::`scalar deleting destructor'(uint)+Ap
.text$mn:00000AA8
.text$mn:00000AA8 var_10          = dword ptr -10h
.text$mn:00000AA8 var_C           = dword ptr -0Ch
.text$mn:00000AA8 var_4           = dword ptr -4
.text$mn:00000AA8
.text$mn:00000AA8                 push    ebp
.text$mn:00000AA9                 mov     ebp, esp
.text$mn:00000AAB                 push    0FFFFFFFFh
.text$mn:00000AAD                 push    offset __ehhandler$??1HandleUniversalDetector@@UAE@XZ
.text$mn:00000AB2                 mov     eax, large fs:0
.text$mn:00000AB8                 push    eax
.text$mn:00000AB9                 push    ecx
.text$mn:00000ABA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000ABF                 xor     eax, ebp
.text$mn:00000AC1                 push    eax
.text$mn:00000AC2                 lea     eax, [ebp+var_C]
.text$mn:00000AC5                 mov     large fs:0, eax
.text$mn:00000ACB                 mov     [ebp+var_10], ecx
.text$mn:00000ACE                 mov     eax, [ebp+var_10]
.text$mn:00000AD1                 mov     dword ptr [eax], offset ??_7HandleUniversalDetector@@6B@ ; const HandleUniversalDetector::`vftable'
.text$mn:00000AD7                 mov     [ebp+var_4], 1
.text$mn:00000ADE                 mov     byte ptr [ebp+var_4], 0
.text$mn:00000AE2                 mov     ecx, [ebp+var_10]
.text$mn:00000AE5                 add     ecx, 2Ch ; ','
.text$mn:00000AE8                 call    ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$mn:00000AED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000AF4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000AF7                 call    ??1nsUniversalDetector@@UAE@XZ ; nsUniversalDetector::~nsUniversalDetector(void)
.text$mn:00000AFC                 mov     ecx, [ebp+var_C]
.text$mn:00000AFF                 mov     large fs:0, ecx
.text$mn:00000B06                 pop     ecx
.text$mn:00000B07                 mov     esp, ebp
.text$mn:00000B09                 pop     ebp
.text$mn:00000B0A                 retn
.text$mn:00000B0A ??1HandleUniversalDetector@@UAE@XZ endp
.text$mn:00000B0A
.text$mn:00000B0A ; ---------------------------------------------------------------------------
.text$mn:00000B0B                 align 4
.text$mn:00000B0B _text$mn        ends
.text$mn:00000B0B
.text$x:00000B0C ; ===========================================================================
.text$x:00000B0C
.text$x:00000B0C ; Segment type: Pure code
.text$x:00000B0C ; Segment permissions: Read/Execute
.text$x:00000B0C _text$x         segment para public 'CODE' use32
.text$x:00000B0C                 assume cs:_text$x
.text$x:00000B0C                 ;org 0B0Ch
.text$x:00000B0C ; COMDAT (pick associative to section at AA8)
.text$x:00000B0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000B0C
.text$x:00000B0C ; =============== S U B R O U T I N E =======================================
.text$x:00000B0C
.text$x:00000B0C
.text$x:00000B0C __unwindfunclet$??1HandleUniversalDetector@@UAE@XZ$0 proc near
.text$x:00000B0C                                         ; DATA XREF: .xdata$x:000020E4o
.text$x:00000B0C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000B0F                 jmp     ??1nsUniversalDetector@@UAE@XZ ; nsUniversalDetector::~nsUniversalDetector(void)
.text$x:00000B0F __unwindfunclet$??1HandleUniversalDetector@@UAE@XZ$0 endp
.text$x:00000B0F
.text$x:00000B14
.text$x:00000B14 ; =============== S U B R O U T I N E =======================================
.text$x:00000B14
.text$x:00000B14
.text$x:00000B14 __unwindfunclet$??1HandleUniversalDetector@@UAE@XZ$1 proc near
.text$x:00000B14                                         ; DATA XREF: .xdata$x:000020ECo
.text$x:00000B14                 mov     ecx, [ebp-10h]
.text$x:00000B17                 add     ecx, 2Ch ; ','
.text$x:00000B1A                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00000B1A __unwindfunclet$??1HandleUniversalDetector@@UAE@XZ$1 endp
.text$x:00000B1A
.text$x:00000B1F
.text$x:00000B1F ; =============== S U B R O U T I N E =======================================
.text$x:00000B1F
.text$x:00000B1F
.text$x:00000B1F __ehhandler$??1HandleUniversalDetector@@UAE@XZ proc near
.text$x:00000B1F                                         ; DATA XREF: HandleUniversalDetector::~HandleUniversalDetector(void)+5o
.text$x:00000B1F
.text$x:00000B1F arg_4           = dword ptr  8
.text$x:00000B1F
.text$x:00000B1F                 mov     edx, [esp+arg_4]
.text$x:00000B23                 lea     eax, [edx+0Ch]
.text$x:00000B26                 mov     ecx, [edx-8]
.text$x:00000B29                 xor     ecx, eax
.text$x:00000B2B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B30                 mov     eax, offset __ehfuncinfo$??1HandleUniversalDetector@@UAE@XZ
.text$x:00000B35                 jmp     ___CxxFrameHandler3
.text$x:00000B35 __ehhandler$??1HandleUniversalDetector@@UAE@XZ endp
.text$x:00000B35
.text$x:00000B35 ; ---------------------------------------------------------------------------
.text$x:00000B3A                 align 4
.text$x:00000B3A _text$x         ends
.text$x:00000B3A
.text$mn:00000B3C ; ===========================================================================
.text$mn:00000B3C
.text$mn:00000B3C ; Segment type: Pure code
.text$mn:00000B3C ; Segment permissions: Read/Execute
.text$mn:00000B3C _text$mn        segment para public 'CODE' use32
.text$mn:00000B3C                 assume cs:_text$mn
.text$mn:00000B3C                 ;org 0B3Ch
.text$mn:00000B3C ; COMDAT (pick any)
.text$mn:00000B3C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000B3C
.text$mn:00000B3C ; =============== S U B R O U T I N E =======================================
.text$mn:00000B3C
.text$mn:00000B3C ; Attributes: bp-based frame
.text$mn:00000B3C
.text$mn:00000B3C ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00000B3C                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00000B3C ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00000B3C                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00000B3C                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00000B3C
.text$mn:00000B3C var_4           = dword ptr -4
.text$mn:00000B3C
.text$mn:00000B3C                 push    ebp
.text$mn:00000B3D                 mov     ebp, esp
.text$mn:00000B3F                 push    ecx
.text$mn:00000B40                 mov     [ebp+var_4], ecx
.text$mn:00000B43                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000B46                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00000B4B                 mov     esp, ebp
.text$mn:00000B4D                 pop     ebp
.text$mn:00000B4E                 retn
.text$mn:00000B4E ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00000B4E
.text$mn:00000B4E ; ---------------------------------------------------------------------------
.text$mn:00000B4F                 align 10h
.text$mn:00000B4F _text$mn        ends
.text$mn:00000B4F
.text$mn:00000B50 ; ===========================================================================
.text$mn:00000B50
.text$mn:00000B50 ; Segment type: Pure code
.text$mn:00000B50 ; Segment permissions: Read/Execute
.text$mn:00000B50 _text$mn        segment para public 'CODE' use32
.text$mn:00000B50                 assume cs:_text$mn
.text$mn:00000B50                 ;org 0B50h
.text$mn:00000B50 ; COMDAT (pick any)
.text$mn:00000B50                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000B50
.text$mn:00000B50 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B50
.text$mn:00000B50 ; Attributes: bp-based frame
.text$mn:00000B50
.text$mn:00000B50 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00000B50                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000B50 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00000B50                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00000B50                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00000B50
.text$mn:00000B50 var_10          = dword ptr -10h
.text$mn:00000B50 var_C           = dword ptr -0Ch
.text$mn:00000B50 var_4           = dword ptr -4
.text$mn:00000B50
.text$mn:00000B50                 push    ebp
.text$mn:00000B51                 mov     ebp, esp
.text$mn:00000B53                 push    0FFFFFFFFh
.text$mn:00000B55                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00000B5A                 mov     eax, large fs:0
.text$mn:00000B60                 push    eax
.text$mn:00000B61                 push    ecx
.text$mn:00000B62                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000B67                 xor     eax, ebp
.text$mn:00000B69                 push    eax
.text$mn:00000B6A                 lea     eax, [ebp+var_C]
.text$mn:00000B6D                 mov     large fs:0, eax
.text$mn:00000B73                 mov     [ebp+var_10], ecx
.text$mn:00000B76                 mov     [ebp+var_4], 0
.text$mn:00000B7D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000B84                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000B87                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000B8C                 mov     ecx, [ebp+var_C]
.text$mn:00000B8F                 mov     large fs:0, ecx
.text$mn:00000B96                 pop     ecx
.text$mn:00000B97                 mov     esp, ebp
.text$mn:00000B99                 pop     ebp
.text$mn:00000B9A                 retn
.text$mn:00000B9A ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00000B9A
.text$mn:00000B9A ; ---------------------------------------------------------------------------
.text$mn:00000B9B                 align 4
.text$mn:00000B9B _text$mn        ends
.text$mn:00000B9B
.text$x:00000B9C ; ===========================================================================
.text$x:00000B9C
.text$x:00000B9C ; Segment type: Pure code
.text$x:00000B9C ; Segment permissions: Read/Execute
.text$x:00000B9C _text$x         segment para public 'CODE' use32
.text$x:00000B9C                 assume cs:_text$x
.text$x:00000B9C                 ;org 0B9Ch
.text$x:00000B9C ; COMDAT (pick associative to section at B50)
.text$x:00000B9C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000B9C
.text$x:00000B9C ; =============== S U B R O U T I N E =======================================
.text$x:00000B9C
.text$x:00000B9C
.text$x:00000B9C __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00000B9C                                         ; DATA XREF: .xdata$x:00001F7Co
.text$x:00000B9C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000B9F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00000B9F __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00000B9F
.text$x:00000BA4
.text$x:00000BA4 ; =============== S U B R O U T I N E =======================================
.text$x:00000BA4
.text$x:00000BA4
.text$x:00000BA4 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00000BA4                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00000BA4
.text$x:00000BA4 arg_4           = dword ptr  8
.text$x:00000BA4
.text$x:00000BA4                 mov     edx, [esp+arg_4]
.text$x:00000BA8                 lea     eax, [edx+0Ch]
.text$x:00000BAB                 mov     ecx, [edx-8]
.text$x:00000BAE                 xor     ecx, eax
.text$x:00000BB0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000BB5                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00000BBA                 jmp     ___CxxFrameHandler3
.text$x:00000BBA __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00000BBA
.text$x:00000BBA ; ---------------------------------------------------------------------------
.text$x:00000BBF                 align 10h
.text$x:00000BBF _text$x         ends
.text$x:00000BBF
.text$mn:00000BC0 ; ===========================================================================
.text$mn:00000BC0
.text$mn:00000BC0 ; Segment type: Pure code
.text$mn:00000BC0 ; Segment permissions: Read/Execute
.text$mn:00000BC0 _text$mn        segment para public 'CODE' use32
.text$mn:00000BC0                 assume cs:_text$mn
.text$mn:00000BC0                 ;org 0BC0h
.text$mn:00000BC0 ; COMDAT (pick any)
.text$mn:00000BC0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000BC0
.text$mn:00000BC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000BC0
.text$mn:00000BC0 ; Attributes: bp-based frame
.text$mn:00000BC0
.text$mn:00000BC0 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00000BC0                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000BC0 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00000BC0                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000BC0                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00000BC0
.text$mn:00000BC0 var_10          = dword ptr -10h
.text$mn:00000BC0 var_C           = dword ptr -0Ch
.text$mn:00000BC0 var_4           = dword ptr -4
.text$mn:00000BC0
.text$mn:00000BC0                 push    ebp
.text$mn:00000BC1                 mov     ebp, esp
.text$mn:00000BC3                 push    0FFFFFFFFh
.text$mn:00000BC5                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00000BCA                 mov     eax, large fs:0
.text$mn:00000BD0                 push    eax
.text$mn:00000BD1                 push    ecx
.text$mn:00000BD2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000BD7                 xor     eax, ebp
.text$mn:00000BD9                 push    eax
.text$mn:00000BDA                 lea     eax, [ebp+var_C]
.text$mn:00000BDD                 mov     large fs:0, eax
.text$mn:00000BE3                 mov     [ebp+var_10], ecx
.text$mn:00000BE6                 mov     [ebp+var_4], 0
.text$mn:00000BED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000BF4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000BF7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000BFC                 mov     ecx, [ebp+var_C]
.text$mn:00000BFF                 mov     large fs:0, ecx
.text$mn:00000C06                 pop     ecx
.text$mn:00000C07                 mov     esp, ebp
.text$mn:00000C09                 pop     ebp
.text$mn:00000C0A                 retn
.text$mn:00000C0A ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00000C0A
.text$mn:00000C0A ; ---------------------------------------------------------------------------
.text$mn:00000C0B                 align 4
.text$mn:00000C0B _text$mn        ends
.text$mn:00000C0B
.text$x:00000C0C ; ===========================================================================
.text$x:00000C0C
.text$x:00000C0C ; Segment type: Pure code
.text$x:00000C0C ; Segment permissions: Read/Execute
.text$x:00000C0C _text$x         segment para public 'CODE' use32
.text$x:00000C0C                 assume cs:_text$x
.text$x:00000C0C                 ;org 0C0Ch
.text$x:00000C0C ; COMDAT (pick associative to section at BC0)
.text$x:00000C0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000C0C
.text$x:00000C0C ; =============== S U B R O U T I N E =======================================
.text$x:00000C0C
.text$x:00000C0C
.text$x:00000C0C __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00000C0C                                         ; DATA XREF: .xdata$x:00002000o
.text$x:00000C0C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000C0F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000C0F __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00000C0F
.text$x:00000C14
.text$x:00000C14 ; =============== S U B R O U T I N E =======================================
.text$x:00000C14
.text$x:00000C14
.text$x:00000C14 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00000C14                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00000C14
.text$x:00000C14 arg_4           = dword ptr  8
.text$x:00000C14
.text$x:00000C14                 mov     edx, [esp+arg_4]
.text$x:00000C18                 lea     eax, [edx+0Ch]
.text$x:00000C1B                 mov     ecx, [edx-8]
.text$x:00000C1E                 xor     ecx, eax
.text$x:00000C20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C25                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00000C2A                 jmp     ___CxxFrameHandler3
.text$x:00000C2A __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00000C2A
.text$x:00000C2A ; ---------------------------------------------------------------------------
.text$x:00000C2F                 align 10h
.text$x:00000C2F _text$x         ends
.text$x:00000C2F
.text$mn:00000C30 ; ===========================================================================
.text$mn:00000C30
.text$mn:00000C30 ; Segment type: Pure code
.text$mn:00000C30 ; Segment permissions: Read/Execute
.text$mn:00000C30 _text$mn        segment para public 'CODE' use32
.text$mn:00000C30                 assume cs:_text$mn
.text$mn:00000C30                 ;org 0C30h
.text$mn:00000C30 ; COMDAT (pick any)
.text$mn:00000C30                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000C30
.text$mn:00000C30 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C30
.text$mn:00000C30 ; Attributes: bp-based frame
.text$mn:00000C30
.text$mn:00000C30 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00000C30                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00000C30 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00000C30                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00000C30                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00000C30
.text$mn:00000C30 var_10          = dword ptr -10h
.text$mn:00000C30 var_C           = dword ptr -0Ch
.text$mn:00000C30 var_4           = dword ptr -4
.text$mn:00000C30
.text$mn:00000C30                 push    ebp
.text$mn:00000C31                 mov     ebp, esp
.text$mn:00000C33                 push    0FFFFFFFFh
.text$mn:00000C35                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00000C3A                 mov     eax, large fs:0
.text$mn:00000C40                 push    eax
.text$mn:00000C41                 push    ecx
.text$mn:00000C42                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C47                 xor     eax, ebp
.text$mn:00000C49                 push    eax
.text$mn:00000C4A                 lea     eax, [ebp+var_C]
.text$mn:00000C4D                 mov     large fs:0, eax
.text$mn:00000C53                 mov     [ebp+var_10], ecx
.text$mn:00000C56                 mov     [ebp+var_4], 0
.text$mn:00000C5D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000C64                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000C67                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000C6C                 mov     ecx, [ebp+var_C]
.text$mn:00000C6F                 mov     large fs:0, ecx
.text$mn:00000C76                 pop     ecx
.text$mn:00000C77                 mov     esp, ebp
.text$mn:00000C79                 pop     ebp
.text$mn:00000C7A                 retn
.text$mn:00000C7A ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00000C7A
.text$mn:00000C7A ; ---------------------------------------------------------------------------
.text$mn:00000C7B                 align 4
.text$mn:00000C7B _text$mn        ends
.text$mn:00000C7B
.text$x:00000C7C ; ===========================================================================
.text$x:00000C7C
.text$x:00000C7C ; Segment type: Pure code
.text$x:00000C7C ; Segment permissions: Read/Execute
.text$x:00000C7C _text$x         segment para public 'CODE' use32
.text$x:00000C7C                 assume cs:_text$x
.text$x:00000C7C                 ;org 0C7Ch
.text$x:00000C7C ; COMDAT (pick associative to section at C30)
.text$x:00000C7C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00000C7C
.text$x:00000C7C ; =============== S U B R O U T I N E =======================================
.text$x:00000C7C
.text$x:00000C7C
.text$x:00000C7C __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00000C7C                                         ; DATA XREF: .xdata$x:00002084o
.text$x:00000C7C                 mov     ecx, [ebp-10h]  ; this
.text$x:00000C7F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00000C7F __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00000C7F
.text$x:00000C84
.text$x:00000C84 ; =============== S U B R O U T I N E =======================================
.text$x:00000C84
.text$x:00000C84
.text$x:00000C84 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00000C84                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00000C84
.text$x:00000C84 arg_4           = dword ptr  8
.text$x:00000C84
.text$x:00000C84                 mov     edx, [esp+arg_4]
.text$x:00000C88                 lea     eax, [edx+0Ch]
.text$x:00000C8B                 mov     ecx, [edx-8]
.text$x:00000C8E                 xor     ecx, eax
.text$x:00000C90                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C95                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00000C9A                 jmp     ___CxxFrameHandler3
.text$x:00000C9A __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00000C9A
.text$x:00000C9A ; ---------------------------------------------------------------------------
.text$x:00000C9F                 align 10h
.text$x:00000C9F _text$x         ends
.text$x:00000C9F
.text$mn:00000CA0 ; ===========================================================================
.text$mn:00000CA0
.text$mn:00000CA0 ; Segment type: Pure code
.text$mn:00000CA0 ; Segment permissions: Read/Execute
.text$mn:00000CA0 _text$mn        segment para public 'CODE' use32
.text$mn:00000CA0                 assume cs:_text$mn
.text$mn:00000CA0                 ;org 0CA0h
.text$mn:00000CA0 ; COMDAT (pick any)
.text$mn:00000CA0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000CA0
.text$mn:00000CA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CA0
.text$mn:00000CA0 ; Attributes: bp-based frame
.text$mn:00000CA0
.text$mn:00000CA0 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00000CA0                 public ??1error_category@std@@UAE@XZ
.text$mn:00000CA0 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00000CA0                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00000CA0
.text$mn:00000CA0 var_4           = dword ptr -4
.text$mn:00000CA0
.text$mn:00000CA0                 push    ebp
.text$mn:00000CA1                 mov     ebp, esp
.text$mn:00000CA3                 push    ecx
.text$mn:00000CA4                 mov     [ebp+var_4], ecx
.text$mn:00000CA7                 mov     eax, [ebp+var_4]
.text$mn:00000CAA                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00000CB0                 mov     esp, ebp
.text$mn:00000CB2                 pop     ebp
.text$mn:00000CB3                 retn
.text$mn:00000CB3 ??1error_category@std@@UAE@XZ endp
.text$mn:00000CB3
.text$mn:00000CB3 _text$mn        ends
.text$mn:00000CB3
.text$mn:00000CB4 ; ===========================================================================
.text$mn:00000CB4
.text$mn:00000CB4 ; Segment type: Pure code
.text$mn:00000CB4 ; Segment permissions: Read/Execute
.text$mn:00000CB4 _text$mn        segment para public 'CODE' use32
.text$mn:00000CB4                 assume cs:_text$mn
.text$mn:00000CB4                 ;org 0CB4h
.text$mn:00000CB4 ; COMDAT (pick any)
.text$mn:00000CB4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000CB4
.text$mn:00000CB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CB4
.text$mn:00000CB4 ; Attributes: bp-based frame
.text$mn:00000CB4
.text$mn:00000CB4 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00000CB4                 public ??2@YAPAXIPAX@Z
.text$mn:00000CB4 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00000CB4                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00000CB4
.text$mn:00000CB4 arg_4           = dword ptr  0Ch
.text$mn:00000CB4
.text$mn:00000CB4                 push    ebp
.text$mn:00000CB5                 mov     ebp, esp
.text$mn:00000CB7                 mov     eax, [ebp+arg_4]
.text$mn:00000CBA                 pop     ebp
.text$mn:00000CBB                 retn
.text$mn:00000CBB ??2@YAPAXIPAX@Z endp
.text$mn:00000CBB
.text$mn:00000CBB _text$mn        ends
.text$mn:00000CBB
.text$mn:00000CBC ; ===========================================================================
.text$mn:00000CBC
.text$mn:00000CBC ; Segment type: Pure code
.text$mn:00000CBC ; Segment permissions: Read/Execute
.text$mn:00000CBC _text$mn        segment para public 'CODE' use32
.text$mn:00000CBC                 assume cs:_text$mn
.text$mn:00000CBC                 ;org 0CBCh
.text$mn:00000CBC ; COMDAT (pick any)
.text$mn:00000CBC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000CBC
.text$mn:00000CBC ; =============== S U B R O U T I N E =======================================
.text$mn:00000CBC
.text$mn:00000CBC ; Attributes: bp-based frame
.text$mn:00000CBC
.text$mn:00000CBC ; void __cdecl operator delete(void *)
.text$mn:00000CBC                 public ??3@YAXPAX0@Z
.text$mn:00000CBC ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00000CBC                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00000CBC                 push    ebp
.text$mn:00000CBD                 mov     ebp, esp
.text$mn:00000CBF                 pop     ebp
.text$mn:00000CC0                 retn
.text$mn:00000CC0 ??3@YAXPAX0@Z   endp
.text$mn:00000CC0
.text$mn:00000CC0 ; ---------------------------------------------------------------------------
.text$mn:00000CC1                 align 4
.text$mn:00000CC1 _text$mn        ends
.text$mn:00000CC1
.text$mn:00000CC4 ; ===========================================================================
.text$mn:00000CC4
.text$mn:00000CC4 ; Segment type: Pure code
.text$mn:00000CC4 ; Segment permissions: Read/Execute
.text$mn:00000CC4 _text$mn        segment para public 'CODE' use32
.text$mn:00000CC4                 assume cs:_text$mn
.text$mn:00000CC4                 ;org 0CC4h
.text$mn:00000CC4 ; COMDAT (pick any)
.text$mn:00000CC4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000CC4
.text$mn:00000CC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CC4
.text$mn:00000CC4 ; Attributes: bp-based frame
.text$mn:00000CC4
.text$mn:00000CC4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char *Str)
.text$mn:00000CC4                 public ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
.text$mn:00000CC4 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z proc near
.text$mn:00000CC4                                         ; CODE XREF: HandleUniversalDetector::HandleUniversalDetector(void)+5Ap
.text$mn:00000CC4                                         ; HandleUniversalDetector::Report(char const *)+11p ...
.text$mn:00000CC4
.text$mn:00000CC4 var_4           = dword ptr -4
.text$mn:00000CC4 Str             = dword ptr  8
.text$mn:00000CC4
.text$mn:00000CC4                 push    ebp
.text$mn:00000CC5                 mov     ebp, esp
.text$mn:00000CC7                 push    ecx
.text$mn:00000CC8                 mov     [ebp+var_4], ecx
.text$mn:00000CCB                 mov     eax, [ebp+Str]
.text$mn:00000CCE                 push    eax             ; Str
.text$mn:00000CCF                 mov     ecx, [ebp+var_4]
.text$mn:00000CD2                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00000CD7                 mov     esp, ebp
.text$mn:00000CD9                 pop     ebp
.text$mn:00000CDA                 retn    4
.text$mn:00000CDA ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z endp
.text$mn:00000CDA
.text$mn:00000CDA ; ---------------------------------------------------------------------------
.text$mn:00000CDD                 align 10h
.text$mn:00000CDD _text$mn        ends
.text$mn:00000CDD
.text$mn:00000CE0 ; ===========================================================================
.text$mn:00000CE0
.text$mn:00000CE0 ; Segment type: Pure code
.text$mn:00000CE0 ; Segment permissions: Read/Execute
.text$mn:00000CE0 _text$mn        segment para public 'CODE' use32
.text$mn:00000CE0                 assume cs:_text$mn
.text$mn:00000CE0                 ;org 0CE0h
.text$mn:00000CE0 ; COMDAT (pick any)
.text$mn:00000CE0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000CE0
.text$mn:00000CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000CE0
.text$mn:00000CE0 ; Attributes: bp-based frame
.text$mn:00000CE0
.text$mn:00000CE0 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00000CE0                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00000CE0 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00000CE0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00000CE0                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00000CE0
.text$mn:00000CE0 var_8           = dword ptr -8
.text$mn:00000CE0 var_4           = dword ptr -4
.text$mn:00000CE0 arg_0           = dword ptr  8
.text$mn:00000CE0
.text$mn:00000CE0                 push    ebp
.text$mn:00000CE1                 mov     ebp, esp
.text$mn:00000CE3                 sub     esp, 8
.text$mn:00000CE6                 mov     [ebp+var_8], ecx
.text$mn:00000CE9                 mov     eax, [ebp+var_8]
.text$mn:00000CEC                 cmp     eax, [ebp+arg_0]
.text$mn:00000CEF                 jnz     short loc_CFA
.text$mn:00000CF1                 mov     [ebp+var_4], 1
.text$mn:00000CF8                 jmp     short loc_D01
.text$mn:00000CFA ; ---------------------------------------------------------------------------
.text$mn:00000CFA
.text$mn:00000CFA loc_CFA:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00000CFA                 mov     [ebp+var_4], 0
.text$mn:00000D01
.text$mn:00000D01 loc_D01:                                ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00000D01                 mov     al, byte ptr [ebp+var_4]
.text$mn:00000D04                 mov     esp, ebp
.text$mn:00000D06                 pop     ebp
.text$mn:00000D07                 retn    4
.text$mn:00000D07 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00000D07
.text$mn:00000D07 ; ---------------------------------------------------------------------------
.text$mn:00000D0A                 align 4
.text$mn:00000D0A _text$mn        ends
.text$mn:00000D0A
.text$mn:00000D0C ; ===========================================================================
.text$mn:00000D0C
.text$mn:00000D0C ; Segment type: Pure code
.text$mn:00000D0C ; Segment permissions: Read/Execute
.text$mn:00000D0C _text$mn        segment para public 'CODE' use32
.text$mn:00000D0C                 assume cs:_text$mn
.text$mn:00000D0C                 ;org 0D0Ch
.text$mn:00000D0C ; COMDAT (pick any)
.text$mn:00000D0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D0C
.text$mn:00000D0C ; =============== S U B R O U T I N E =======================================
.text$mn:00000D0C
.text$mn:00000D0C ; Attributes: bp-based frame
.text$mn:00000D0C
.text$mn:00000D0C ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00000D0C                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00000D0C ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00000D0C                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00000D0C
.text$mn:00000D0C var_8           = dword ptr -8
.text$mn:00000D0C var_4           = dword ptr -4
.text$mn:00000D0C arg_0           = dword ptr  8
.text$mn:00000D0C
.text$mn:00000D0C                 push    ebp
.text$mn:00000D0D                 mov     ebp, esp
.text$mn:00000D0F                 sub     esp, 8
.text$mn:00000D12                 push    esi
.text$mn:00000D13                 mov     [ebp+var_4], ecx
.text$mn:00000D16                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000D19                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000D1E                 push    eax
.text$mn:00000D1F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000D22                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00000D27                 mov     ecx, eax
.text$mn:00000D29                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00000D2E                 movzx   eax, al
.text$mn:00000D31                 test    eax, eax
.text$mn:00000D33                 jz      short loc_D54
.text$mn:00000D35                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000D38                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000D3D                 mov     esi, eax
.text$mn:00000D3F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000D42                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00000D47                 cmp     esi, eax
.text$mn:00000D49                 jnz     short loc_D54
.text$mn:00000D4B                 mov     [ebp+var_8], 1
.text$mn:00000D52                 jmp     short loc_D5B
.text$mn:00000D54 ; ---------------------------------------------------------------------------
.text$mn:00000D54
.text$mn:00000D54 loc_D54:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00000D54                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00000D54                 mov     [ebp+var_8], 0
.text$mn:00000D5B
.text$mn:00000D5B loc_D5B:                                ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00000D5B                 mov     al, byte ptr [ebp+var_8]
.text$mn:00000D5E                 pop     esi
.text$mn:00000D5F                 mov     esp, ebp
.text$mn:00000D61                 pop     ebp
.text$mn:00000D62                 retn    4
.text$mn:00000D62 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00000D62
.text$mn:00000D62 ; ---------------------------------------------------------------------------
.text$mn:00000D65                 align 4
.text$mn:00000D65 _text$mn        ends
.text$mn:00000D65
.text$mn:00000D68 ; ===========================================================================
.text$mn:00000D68
.text$mn:00000D68 ; Segment type: Pure code
.text$mn:00000D68 ; Segment permissions: Read/Execute
.text$mn:00000D68 _text$mn        segment para public 'CODE' use32
.text$mn:00000D68                 assume cs:_text$mn
.text$mn:00000D68                 ;org 0D68h
.text$mn:00000D68 ; COMDAT (pick any)
.text$mn:00000D68                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D68
.text$mn:00000D68 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D68
.text$mn:00000D68 ; Attributes: bp-based frame
.text$mn:00000D68
.text$mn:00000D68 ; public: virtual void * __thiscall HandleUniversalDetector::`scalar deleting destructor'(unsigned int)
.text$mn:00000D68                 public ??_GHandleUniversalDetector@@UAEPAXI@Z
.text$mn:00000D68 ??_GHandleUniversalDetector@@UAEPAXI@Z proc near
.text$mn:00000D68
.text$mn:00000D68 var_4           = dword ptr -4
.text$mn:00000D68 arg_0           = dword ptr  8
.text$mn:00000D68
.text$mn:00000D68                 push    ebp
.text$mn:00000D69                 mov     ebp, esp
.text$mn:00000D6B                 push    ecx
.text$mn:00000D6C                 mov     [ebp+var_4], ecx
.text$mn:00000D6F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000D72                 call    ??1HandleUniversalDetector@@UAE@XZ ; HandleUniversalDetector::~HandleUniversalDetector(void)
.text$mn:00000D77                 mov     eax, [ebp+arg_0]
.text$mn:00000D7A                 and     eax, 1
.text$mn:00000D7D                 jz      short loc_D8B
.text$mn:00000D7F                 mov     ecx, [ebp+var_4]
.text$mn:00000D82                 push    ecx             ; void *
.text$mn:00000D83                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000D88                 add     esp, 4
.text$mn:00000D8B
.text$mn:00000D8B loc_D8B:                                ; CODE XREF: HandleUniversalDetector::`scalar deleting destructor'(uint)+15j
.text$mn:00000D8B                 mov     eax, [ebp+var_4]
.text$mn:00000D8E                 mov     esp, ebp
.text$mn:00000D90                 pop     ebp
.text$mn:00000D91                 retn    4
.text$mn:00000D91 ??_GHandleUniversalDetector@@UAEPAXI@Z endp
.text$mn:00000D91
.text$mn:00000D91 _text$mn        ends
.text$mn:00000D91
.text$mn:00000D94 ; ===========================================================================
.text$mn:00000D94
.text$mn:00000D94 ; Segment type: Pure code
.text$mn:00000D94 ; Segment permissions: Read/Execute
.text$mn:00000D94 _text$mn        segment para public 'CODE' use32
.text$mn:00000D94                 assume cs:_text$mn
.text$mn:00000D94                 ;org 0D94h
.text$mn:00000D94 ; COMDAT (pick any)
.text$mn:00000D94                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000D94
.text$mn:00000D94 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D94
.text$mn:00000D94 ; Attributes: bp-based frame
.text$mn:00000D94
.text$mn:00000D94 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000D94                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00000D94 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000D94
.text$mn:00000D94 var_4           = dword ptr -4
.text$mn:00000D94 arg_0           = dword ptr  8
.text$mn:00000D94
.text$mn:00000D94                 push    ebp
.text$mn:00000D95                 mov     ebp, esp
.text$mn:00000D97                 push    ecx
.text$mn:00000D98                 mov     [ebp+var_4], ecx
.text$mn:00000D9B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000D9E                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00000DA3                 mov     eax, [ebp+arg_0]
.text$mn:00000DA6                 and     eax, 1
.text$mn:00000DA9                 jz      short loc_DB7
.text$mn:00000DAB                 mov     ecx, [ebp+var_4]
.text$mn:00000DAE                 push    ecx             ; void *
.text$mn:00000DAF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000DB4                 add     esp, 4
.text$mn:00000DB7
.text$mn:00000DB7 loc_DB7:                                ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000DB7                 mov     eax, [ebp+var_4]
.text$mn:00000DBA                 mov     esp, ebp
.text$mn:00000DBC                 pop     ebp
.text$mn:00000DBD                 retn    4
.text$mn:00000DBD ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00000DBD
.text$mn:00000DBD _text$mn        ends
.text$mn:00000DBD
.text$mn:00000DC0 ; ===========================================================================
.text$mn:00000DC0
.text$mn:00000DC0 ; Segment type: Pure code
.text$mn:00000DC0 ; Segment permissions: Read/Execute
.text$mn:00000DC0 _text$mn        segment para public 'CODE' use32
.text$mn:00000DC0                 assume cs:_text$mn
.text$mn:00000DC0                 ;org 0DC0h
.text$mn:00000DC0 ; COMDAT (pick any)
.text$mn:00000DC0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000DC0
.text$mn:00000DC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DC0
.text$mn:00000DC0 ; Attributes: bp-based frame
.text$mn:00000DC0
.text$mn:00000DC0 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000DC0                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00000DC0 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000DC0
.text$mn:00000DC0 var_4           = dword ptr -4
.text$mn:00000DC0 arg_0           = dword ptr  8
.text$mn:00000DC0
.text$mn:00000DC0                 push    ebp
.text$mn:00000DC1                 mov     ebp, esp
.text$mn:00000DC3                 push    ecx
.text$mn:00000DC4                 mov     [ebp+var_4], ecx
.text$mn:00000DC7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000DCA                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00000DCF                 mov     eax, [ebp+arg_0]
.text$mn:00000DD2                 and     eax, 1
.text$mn:00000DD5                 jz      short loc_DE3
.text$mn:00000DD7                 mov     ecx, [ebp+var_4]
.text$mn:00000DDA                 push    ecx             ; void *
.text$mn:00000DDB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000DE0                 add     esp, 4
.text$mn:00000DE3
.text$mn:00000DE3 loc_DE3:                                ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000DE3                 mov     eax, [ebp+var_4]
.text$mn:00000DE6                 mov     esp, ebp
.text$mn:00000DE8                 pop     ebp
.text$mn:00000DE9                 retn    4
.text$mn:00000DE9 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00000DE9
.text$mn:00000DE9 _text$mn        ends
.text$mn:00000DE9
.text$mn:00000DEC ; ===========================================================================
.text$mn:00000DEC
.text$mn:00000DEC ; Segment type: Pure code
.text$mn:00000DEC ; Segment permissions: Read/Execute
.text$mn:00000DEC _text$mn        segment para public 'CODE' use32
.text$mn:00000DEC                 assume cs:_text$mn
.text$mn:00000DEC                 ;org 0DECh
.text$mn:00000DEC ; COMDAT (pick any)
.text$mn:00000DEC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000DEC
.text$mn:00000DEC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DEC
.text$mn:00000DEC ; Attributes: bp-based frame
.text$mn:00000DEC
.text$mn:00000DEC ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000DEC                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00000DEC ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00000DEC
.text$mn:00000DEC var_4           = dword ptr -4
.text$mn:00000DEC arg_0           = dword ptr  8
.text$mn:00000DEC
.text$mn:00000DEC                 push    ebp
.text$mn:00000DED                 mov     ebp, esp
.text$mn:00000DEF                 push    ecx
.text$mn:00000DF0                 mov     [ebp+var_4], ecx
.text$mn:00000DF3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000DF6                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00000DFB                 mov     eax, [ebp+arg_0]
.text$mn:00000DFE                 and     eax, 1
.text$mn:00000E01                 jz      short loc_E0F
.text$mn:00000E03                 mov     ecx, [ebp+var_4]
.text$mn:00000E06                 push    ecx             ; void *
.text$mn:00000E07                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000E0C                 add     esp, 4
.text$mn:00000E0F
.text$mn:00000E0F loc_E0F:                                ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000E0F                 mov     eax, [ebp+var_4]
.text$mn:00000E12                 mov     esp, ebp
.text$mn:00000E14                 pop     ebp
.text$mn:00000E15                 retn    4
.text$mn:00000E15 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00000E15
.text$mn:00000E15 _text$mn        ends
.text$mn:00000E15
.text$mn:00000E18 ; ===========================================================================
.text$mn:00000E18
.text$mn:00000E18 ; Segment type: Pure code
.text$mn:00000E18 ; Segment permissions: Read/Execute
.text$mn:00000E18 _text$mn        segment para public 'CODE' use32
.text$mn:00000E18                 assume cs:_text$mn
.text$mn:00000E18                 ;org 0E18h
.text$mn:00000E18 ; COMDAT (pick any)
.text$mn:00000E18                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000E18
.text$mn:00000E18 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E18
.text$mn:00000E18 ; Attributes: bp-based frame
.text$mn:00000E18
.text$mn:00000E18 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00000E18                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00000E18 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00000E18
.text$mn:00000E18 var_4           = dword ptr -4
.text$mn:00000E18 arg_0           = dword ptr  8
.text$mn:00000E18
.text$mn:00000E18                 push    ebp
.text$mn:00000E19                 mov     ebp, esp
.text$mn:00000E1B                 push    ecx
.text$mn:00000E1C                 mov     [ebp+var_4], ecx
.text$mn:00000E1F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E22                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00000E27                 mov     eax, [ebp+arg_0]
.text$mn:00000E2A                 and     eax, 1
.text$mn:00000E2D                 jz      short loc_E3B
.text$mn:00000E2F                 mov     ecx, [ebp+var_4]
.text$mn:00000E32                 push    ecx             ; void *
.text$mn:00000E33                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00000E38                 add     esp, 4
.text$mn:00000E3B
.text$mn:00000E3B loc_E3B:                                ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00000E3B                 mov     eax, [ebp+var_4]
.text$mn:00000E3E                 mov     esp, ebp
.text$mn:00000E40                 pop     ebp
.text$mn:00000E41                 retn    4
.text$mn:00000E41 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00000E41
.text$mn:00000E41 _text$mn        ends
.text$mn:00000E41
.text$di:00000E44 ; ===========================================================================
.text$di:00000E44
.text$di:00000E44 ; Segment type: Pure code
.text$di:00000E44 ; Segment permissions: Read/Execute
.text$di:00000E44 _text$di        segment para public 'CODE' use32
.text$di:00000E44                 assume cs:_text$di
.text$di:00000E44                 ;org 0E44h
.text$di:00000E44 ; COMDAT (pick any)
.text$di:00000E44                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000E44
.text$di:00000E44 ; =============== S U B R O U T I N E =======================================
.text$di:00000E44
.text$di:00000E44 ; Attributes: bp-based frame
.text$di:00000E44
.text$di:00000E44 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00000E44 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00000E44                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00000E44                 push    ebp
.text$di:00000E45                 mov     ebp, esp
.text$di:00000E47                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00000E4C                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00000E51                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000E56                 call    _atexit
.text$di:00000E5B                 add     esp, 4
.text$di:00000E5E                 pop     ebp
.text$di:00000E5F                 retn
.text$di:00000E5F ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00000E5F
.text$di:00000E5F _text$di        ends
.text$di:00000E5F
.text$di:00000E60 ; ===========================================================================
.text$di:00000E60
.text$di:00000E60 ; Segment type: Pure code
.text$di:00000E60 ; Segment permissions: Read/Execute
.text$di:00000E60 _text$di        segment para public 'CODE' use32
.text$di:00000E60                 assume cs:_text$di
.text$di:00000E60                 ;org 0E60h
.text$di:00000E60 ; COMDAT (pick any)
.text$di:00000E60                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000E60
.text$di:00000E60 ; =============== S U B R O U T I N E =======================================
.text$di:00000E60
.text$di:00000E60 ; Attributes: bp-based frame
.text$di:00000E60
.text$di:00000E60 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00000E60 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00000E60                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00000E60                 push    ebp
.text$di:00000E61                 mov     ebp, esp
.text$di:00000E63                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00000E68                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00000E6D                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000E72                 call    _atexit
.text$di:00000E77                 add     esp, 4
.text$di:00000E7A                 pop     ebp
.text$di:00000E7B                 retn
.text$di:00000E7B ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00000E7B
.text$di:00000E7B _text$di        ends
.text$di:00000E7B
.text$di:00000E7C ; ===========================================================================
.text$di:00000E7C
.text$di:00000E7C ; Segment type: Pure code
.text$di:00000E7C ; Segment permissions: Read/Execute
.text$di:00000E7C _text$di        segment para public 'CODE' use32
.text$di:00000E7C                 assume cs:_text$di
.text$di:00000E7C                 ;org 0E7Ch
.text$di:00000E7C ; COMDAT (pick any)
.text$di:00000E7C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000E7C
.text$di:00000E7C ; =============== S U B R O U T I N E =======================================
.text$di:00000E7C
.text$di:00000E7C ; Attributes: bp-based frame
.text$di:00000E7C
.text$di:00000E7C ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00000E7C ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00000E7C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00000E7C                 push    ebp
.text$di:00000E7D                 mov     ebp, esp
.text$di:00000E7F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00000E84                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00000E89                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00000E8E                 call    _atexit
.text$di:00000E93                 add     esp, 4
.text$di:00000E96                 pop     ebp
.text$di:00000E97                 retn
.text$di:00000E97 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00000E97
.text$di:00000E97 _text$di        ends
.text$di:00000E97
.text$di:00000E98 ; ===========================================================================
.text$di:00000E98
.text$di:00000E98 ; Segment type: Pure code
.text$di:00000E98 ; Segment permissions: Read/Execute
.text$di:00000E98 _text$di        segment para public 'CODE' use32
.text$di:00000E98                 assume cs:_text$di
.text$di:00000E98                 ;org 0E98h
.text$di:00000E98 ; COMDAT (pick any)
.text$di:00000E98                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000E98
.text$di:00000E98 ; =============== S U B R O U T I N E =======================================
.text$di:00000E98
.text$di:00000E98 ; Attributes: bp-based frame
.text$di:00000E98
.text$di:00000E98 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00000E98 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000E98                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00000E98                 push    ebp
.text$di:00000E99                 mov     ebp, esp
.text$di:00000E9B                 push    0               ; unsigned int
.text$di:00000E9D                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00000EA2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000EA7                 pop     ebp
.text$di:00000EA8                 retn
.text$di:00000EA8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000EA8
.text$di:00000EA8 ; ---------------------------------------------------------------------------
.text$di:00000EA9                 align 4
.text$di:00000EA9 _text$di        ends
.text$di:00000EA9
.text$di:00000EAC ; ===========================================================================
.text$di:00000EAC
.text$di:00000EAC ; Segment type: Pure code
.text$di:00000EAC ; Segment permissions: Read/Execute
.text$di:00000EAC _text$di        segment para public 'CODE' use32
.text$di:00000EAC                 assume cs:_text$di
.text$di:00000EAC                 ;org 0EACh
.text$di:00000EAC ; COMDAT (pick any)
.text$di:00000EAC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000EAC
.text$di:00000EAC ; =============== S U B R O U T I N E =======================================
.text$di:00000EAC
.text$di:00000EAC ; Attributes: bp-based frame
.text$di:00000EAC
.text$di:00000EAC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00000EAC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000EAC                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00000EAC                 push    ebp
.text$di:00000EAD                 mov     ebp, esp
.text$di:00000EAF                 push    0               ; unsigned int
.text$di:00000EB1                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00000EB6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000EBB                 pop     ebp
.text$di:00000EBC                 retn
.text$di:00000EBC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000EBC
.text$di:00000EBC ; ---------------------------------------------------------------------------
.text$di:00000EBD                 align 10h
.text$di:00000EBD _text$di        ends
.text$di:00000EBD
.text$di:00000EC0 ; ===========================================================================
.text$di:00000EC0
.text$di:00000EC0 ; Segment type: Pure code
.text$di:00000EC0 ; Segment permissions: Read/Execute
.text$di:00000EC0 _text$di        segment para public 'CODE' use32
.text$di:00000EC0                 assume cs:_text$di
.text$di:00000EC0                 ;org 0EC0h
.text$di:00000EC0 ; COMDAT (pick any)
.text$di:00000EC0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000EC0
.text$di:00000EC0 ; =============== S U B R O U T I N E =======================================
.text$di:00000EC0
.text$di:00000EC0 ; Attributes: bp-based frame
.text$di:00000EC0
.text$di:00000EC0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00000EC0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000EC0                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00000EC0                 push    ebp
.text$di:00000EC1                 mov     ebp, esp
.text$di:00000EC3                 push    0               ; unsigned int
.text$di:00000EC5                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00000ECA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000ECF                 pop     ebp
.text$di:00000ED0                 retn
.text$di:00000ED0 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000ED0
.text$di:00000ED0 ; ---------------------------------------------------------------------------
.text$di:00000ED1                 align 4
.text$di:00000ED1 _text$di        ends
.text$di:00000ED1
.text$di:00000ED4 ; ===========================================================================
.text$di:00000ED4
.text$di:00000ED4 ; Segment type: Pure code
.text$di:00000ED4 ; Segment permissions: Read/Execute
.text$di:00000ED4 _text$di        segment para public 'CODE' use32
.text$di:00000ED4                 assume cs:_text$di
.text$di:00000ED4                 ;org 0ED4h
.text$di:00000ED4 ; COMDAT (pick any)
.text$di:00000ED4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000ED4
.text$di:00000ED4 ; =============== S U B R O U T I N E =======================================
.text$di:00000ED4
.text$di:00000ED4 ; Attributes: bp-based frame
.text$di:00000ED4
.text$di:00000ED4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00000ED4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00000ED4                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00000ED4                 push    ebp
.text$di:00000ED5                 mov     ebp, esp
.text$di:00000ED7                 push    0               ; unsigned int
.text$di:00000ED9                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00000EDE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00000EE3                 pop     ebp
.text$di:00000EE4                 retn
.text$di:00000EE4 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00000EE4
.text$di:00000EE4 ; ---------------------------------------------------------------------------
.text$di:00000EE5                 align 4
.text$di:00000EE5 _text$di        ends
.text$di:00000EE5
.text$di:00000EE8 ; ===========================================================================
.text$di:00000EE8
.text$di:00000EE8 ; Segment type: Pure code
.text$di:00000EE8 ; Segment permissions: Read/Execute
.text$di:00000EE8 _text$di        segment para public 'CODE' use32
.text$di:00000EE8                 assume cs:_text$di
.text$di:00000EE8                 ;org 0EE8h
.text$di:00000EE8 ; COMDAT (pick any)
.text$di:00000EE8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000EE8
.text$di:00000EE8 ; =============== S U B R O U T I N E =======================================
.text$di:00000EE8
.text$di:00000EE8 ; Attributes: bp-based frame
.text$di:00000EE8
.text$di:00000EE8 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00000EE8 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00000EE8
.text$di:00000EE8 var_1           = byte ptr -1
.text$di:00000EE8
.text$di:00000EE8                 push    ebp
.text$di:00000EE9                 mov     ebp, esp
.text$di:00000EEB                 push    ecx
.text$di:00000EEC                 xor     eax, eax
.text$di:00000EEE                 mov     [ebp+var_1], al
.text$di:00000EF1                 mov     esp, ebp
.text$di:00000EF3                 pop     ebp
.text$di:00000EF4                 retn
.text$di:00000EF4 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00000EF4
.text$di:00000EF4 ; ---------------------------------------------------------------------------
.text$di:00000EF5                 align 4
.text$di:00000EF5 _text$di        ends
.text$di:00000EF5
.text$di:00000EF8 ; ===========================================================================
.text$di:00000EF8
.text$di:00000EF8 ; Segment type: Pure code
.text$di:00000EF8 ; Segment permissions: Read/Execute
.text$di:00000EF8 _text$di        segment para public 'CODE' use32
.text$di:00000EF8                 assume cs:_text$di
.text$di:00000EF8                 ;org 0EF8h
.text$di:00000EF8 ; COMDAT (pick any)
.text$di:00000EF8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$di:00000EF8
.text$di:00000EF8 ; =============== S U B R O U T I N E =======================================
.text$di:00000EF8
.text$di:00000EF8 ; Attributes: bp-based frame
.text$di:00000EF8
.text$di:00000EF8 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00000EF8 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00000EF8                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00000EF8
.text$di:00000EF8 var_1           = byte ptr -1
.text$di:00000EF8
.text$di:00000EF8                 push    ebp
.text$di:00000EF9                 mov     ebp, esp
.text$di:00000EFB                 push    ecx
.text$di:00000EFC                 xor     eax, eax
.text$di:00000EFE                 mov     [ebp+var_1], al
.text$di:00000F01                 mov     esp, ebp
.text$di:00000F03                 pop     ebp
.text$di:00000F04                 retn
.text$di:00000F04 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00000F04
.text$di:00000F04 ; ---------------------------------------------------------------------------
.text$di:00000F05                 align 4
.text$di:00000F05 _text$di        ends
.text$di:00000F05
.text$yd:00000F08 ; ===========================================================================
.text$yd:00000F08
.text$yd:00000F08 ; Segment type: Pure code
.text$yd:00000F08 ; Segment permissions: Read/Execute
.text$yd:00000F08 _text$yd        segment para public 'CODE' use32
.text$yd:00000F08                 assume cs:_text$yd
.text$yd:00000F08                 ;org 0F08h
.text$yd:00000F08 ; COMDAT (pick any)
.text$yd:00000F08                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:00000F08
.text$yd:00000F08 ; =============== S U B R O U T I N E =======================================
.text$yd:00000F08
.text$yd:00000F08 ; Attributes: bp-based frame
.text$yd:00000F08
.text$yd:00000F08 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00000F08 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00000F08                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00000F08                 push    ebp
.text$yd:00000F09                 mov     ebp, esp
.text$yd:00000F0B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00000F10                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00000F15                 pop     ebp
.text$yd:00000F16                 retn
.text$yd:00000F16 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00000F16
.text$yd:00000F16 ; ---------------------------------------------------------------------------
.text$yd:00000F17                 align 4
.text$yd:00000F17 _text$yd        ends
.text$yd:00000F17
.text$yd:00000F18 ; ===========================================================================
.text$yd:00000F18
.text$yd:00000F18 ; Segment type: Pure code
.text$yd:00000F18 ; Segment permissions: Read/Execute
.text$yd:00000F18 _text$yd        segment para public 'CODE' use32
.text$yd:00000F18                 assume cs:_text$yd
.text$yd:00000F18                 ;org 0F18h
.text$yd:00000F18 ; COMDAT (pick any)
.text$yd:00000F18                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:00000F18
.text$yd:00000F18 ; =============== S U B R O U T I N E =======================================
.text$yd:00000F18
.text$yd:00000F18 ; Attributes: bp-based frame
.text$yd:00000F18
.text$yd:00000F18 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00000F18 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00000F18                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00000F18                 push    ebp
.text$yd:00000F19                 mov     ebp, esp
.text$yd:00000F1B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00000F20                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00000F25                 pop     ebp
.text$yd:00000F26                 retn
.text$yd:00000F26 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00000F26
.text$yd:00000F26 ; ---------------------------------------------------------------------------
.text$yd:00000F27                 align 4
.text$yd:00000F27 _text$yd        ends
.text$yd:00000F27
.text$yd:00000F28 ; ===========================================================================
.text$yd:00000F28
.text$yd:00000F28 ; Segment type: Pure code
.text$yd:00000F28 ; Segment permissions: Read/Execute
.text$yd:00000F28 _text$yd        segment para public 'CODE' use32
.text$yd:00000F28                 assume cs:_text$yd
.text$yd:00000F28                 ;org 0F28h
.text$yd:00000F28 ; COMDAT (pick any)
.text$yd:00000F28                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$yd:00000F28
.text$yd:00000F28 ; =============== S U B R O U T I N E =======================================
.text$yd:00000F28
.text$yd:00000F28 ; Attributes: bp-based frame
.text$yd:00000F28
.text$yd:00000F28 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00000F28 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00000F28                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00000F28                 push    ebp
.text$yd:00000F29                 mov     ebp, esp
.text$yd:00000F2B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00000F30                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00000F35                 pop     ebp
.text$yd:00000F36                 retn
.text$yd:00000F36 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00000F36
.text$yd:00000F36 ; ---------------------------------------------------------------------------
.text$yd:00000F37                 align 4
.text$yd:00000F37 _text$yd        ends
.text$yd:00000F37
.text$mn:00000F38 ; ===========================================================================
.text$mn:00000F38
.text$mn:00000F38 ; Segment type: Pure code
.text$mn:00000F38 ; Segment permissions: Read/Execute
.text$mn:00000F38 _text$mn        segment para public 'CODE' use32
.text$mn:00000F38                 assume cs:_text$mn
.text$mn:00000F38                 ;org 0F38h
.text$mn:00000F38 ; COMDAT (pick any)
.text$mn:00000F38                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F38
.text$mn:00000F38 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F38
.text$mn:00000F38 ; Attributes: bp-based frame
.text$mn:00000F38
.text$mn:00000F38 ; const char *__thiscall HandleUniversalDetector::GetCharset(HandleUniversalDetector *__hidden this)
.text$mn:00000F38                 public ?GetCharset@HandleUniversalDetector@@QBEPBDXZ
.text$mn:00000F38 ?GetCharset@HandleUniversalDetector@@QBEPBDXZ proc near
.text$mn:00000F38                                         ; CODE XREF: _uchardet_get_charset+6p
.text$mn:00000F38
.text$mn:00000F38 var_4           = dword ptr -4
.text$mn:00000F38
.text$mn:00000F38                 push    ebp
.text$mn:00000F39                 mov     ebp, esp
.text$mn:00000F3B                 push    ecx
.text$mn:00000F3C                 mov     [ebp+var_4], ecx
.text$mn:00000F3F                 mov     ecx, [ebp+var_4]
.text$mn:00000F42                 add     ecx, 2Ch ; ','
.text$mn:00000F45                 call    ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)
.text$mn:00000F4A                 mov     esp, ebp
.text$mn:00000F4C                 pop     ebp
.text$mn:00000F4D                 retn
.text$mn:00000F4D ?GetCharset@HandleUniversalDetector@@QBEPBDXZ endp
.text$mn:00000F4D
.text$mn:00000F4D ; ---------------------------------------------------------------------------
.text$mn:00000F4E                 align 10h
.text$mn:00000F4E _text$mn        ends
.text$mn:00000F4E
.text$mn:00000F50 ; ===========================================================================
.text$mn:00000F50
.text$mn:00000F50 ; Segment type: Pure code
.text$mn:00000F50 ; Segment permissions: Read/Execute
.text$mn:00000F50 _text$mn        segment para public 'CODE' use32
.text$mn:00000F50                 assume cs:_text$mn
.text$mn:00000F50                 ;org 0F50h
.text$mn:00000F50 ; COMDAT (pick any)
.text$mn:00000F50                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F50
.text$mn:00000F50 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F50
.text$mn:00000F50 ; Attributes: bp-based frame
.text$mn:00000F50
.text$mn:00000F50 ; void __thiscall HandleUniversalDetector::Report(HandleUniversalDetector *this, const char *)
.text$mn:00000F50                 public ?Report@HandleUniversalDetector@@UAEXPBD@Z
.text$mn:00000F50 ?Report@HandleUniversalDetector@@UAEXPBD@Z proc near
.text$mn:00000F50                                         ; DATA XREF: .rdata:0000224Co
.text$mn:00000F50
.text$mn:00000F50 var_4           = dword ptr -4
.text$mn:00000F50 Str             = dword ptr  8
.text$mn:00000F50
.text$mn:00000F50                 push    ebp
.text$mn:00000F51                 mov     ebp, esp
.text$mn:00000F53                 push    ecx
.text$mn:00000F54                 mov     [ebp+var_4], ecx
.text$mn:00000F57                 mov     eax, [ebp+Str]
.text$mn:00000F5A                 push    eax             ; Str
.text$mn:00000F5B                 mov     ecx, [ebp+var_4]
.text$mn:00000F5E                 add     ecx, 2Ch ; ','
.text$mn:00000F61                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:00000F66                 mov     esp, ebp
.text$mn:00000F68                 pop     ebp
.text$mn:00000F69                 retn    4
.text$mn:00000F69 ?Report@HandleUniversalDetector@@UAEXPBD@Z endp
.text$mn:00000F69
.text$mn:00000F69 _text$mn        ends
.text$mn:00000F69
.text$mn:00000F6C ; ===========================================================================
.text$mn:00000F6C
.text$mn:00000F6C ; Segment type: Pure code
.text$mn:00000F6C ; Segment permissions: Read/Execute
.text$mn:00000F6C _text$mn        segment para public 'CODE' use32
.text$mn:00000F6C                 assume cs:_text$mn
.text$mn:00000F6C                 ;org 0F6Ch
.text$mn:00000F6C ; COMDAT (pick any)
.text$mn:00000F6C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F6C
.text$mn:00000F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F6C
.text$mn:00000F6C ; Attributes: bp-based frame
.text$mn:00000F6C
.text$mn:00000F6C ; void __thiscall HandleUniversalDetector::Reset(HandleUniversalDetector *__hidden this)
.text$mn:00000F6C                 public ?Reset@HandleUniversalDetector@@UAEXXZ
.text$mn:00000F6C ?Reset@HandleUniversalDetector@@UAEXXZ proc near
.text$mn:00000F6C                                         ; DATA XREF: .rdata:00002250o
.text$mn:00000F6C
.text$mn:00000F6C var_4           = dword ptr -4
.text$mn:00000F6C
.text$mn:00000F6C                 push    ebp
.text$mn:00000F6D                 mov     ebp, esp
.text$mn:00000F6F                 push    ecx
.text$mn:00000F70                 mov     [ebp+var_4], ecx
.text$mn:00000F73                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000F76                 call    ?Reset@nsUniversalDetector@@MAEXXZ ; nsUniversalDetector::Reset(void)
.text$mn:00000F7B                 push    offset ??_C@_00CNPNBAHC@?$AA@ ; Str
.text$mn:00000F80                 mov     ecx, [ebp+var_4]
.text$mn:00000F83                 add     ecx, 2Ch ; ','
.text$mn:00000F86                 call    ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)
.text$mn:00000F8B                 mov     esp, ebp
.text$mn:00000F8D                 pop     ebp
.text$mn:00000F8E                 retn
.text$mn:00000F8E ?Reset@HandleUniversalDetector@@UAEXXZ endp
.text$mn:00000F8E
.text$mn:00000F8E ; ---------------------------------------------------------------------------
.text$mn:00000F8F                 align 10h
.text$mn:00000F8F _text$mn        ends
.text$mn:00000F8F
.text$mn:00000F90 ; ===========================================================================
.text$mn:00000F90
.text$mn:00000F90 ; Segment type: Pure code
.text$mn:00000F90 ; Segment permissions: Read/Execute
.text$mn:00000F90 _text$mn        segment para public 'CODE' use32
.text$mn:00000F90                 assume cs:_text$mn
.text$mn:00000F90                 ;org 0F90h
.text$mn:00000F90 ; COMDAT (pick any)
.text$mn:00000F90                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000F90
.text$mn:00000F90 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F90
.text$mn:00000F90 ; Attributes: bp-based frame
.text$mn:00000F90
.text$mn:00000F90 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000F90                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00000F90 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00000F90                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00000F90
.text$mn:00000F90 var_10          = byte ptr -10h
.text$mn:00000F90 var_8           = dword ptr -8
.text$mn:00000F90 var_1           = byte ptr -1
.text$mn:00000F90
.text$mn:00000F90                 push    ebp
.text$mn:00000F91                 mov     ebp, esp
.text$mn:00000F93                 sub     esp, 10h
.text$mn:00000F96                 mov     [ebp+var_8], ecx
.text$mn:00000F99                 lea     ecx, [ebp+var_1]
.text$mn:00000F9C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00000FA1                 push    1
.text$mn:00000FA3                 lea     ecx, [ebp+var_1]
.text$mn:00000FA6                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00000FAB                 mov     ecx, [ebp+var_8]
.text$mn:00000FAE                 mov     [ecx], eax
.text$mn:00000FB0                 lea     ecx, [ebp+var_10] ; this
.text$mn:00000FB3                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00000FB8                 push    eax             ; int
.text$mn:00000FB9                 mov     edx, [ebp+var_8]
.text$mn:00000FBC                 mov     eax, [edx]
.text$mn:00000FBE                 push    eax             ; void *
.text$mn:00000FBF                 lea     ecx, [ebp+var_1]
.text$mn:00000FC2                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00000FC7                 mov     ecx, [ebp+var_8]
.text$mn:00000FCA                 mov     edx, [ecx]
.text$mn:00000FCC                 mov     eax, [ebp+var_8]
.text$mn:00000FCF                 mov     [edx], eax
.text$mn:00000FD1                 mov     esp, ebp
.text$mn:00000FD3                 pop     ebp
.text$mn:00000FD4                 retn
.text$mn:00000FD4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00000FD4
.text$mn:00000FD4 ; ---------------------------------------------------------------------------
.text$mn:00000FD5                 align 4
.text$mn:00000FD5 _text$mn        ends
.text$mn:00000FD5
.text$mn:00000FD8 ; ===========================================================================
.text$mn:00000FD8
.text$mn:00000FD8 ; Segment type: Pure code
.text$mn:00000FD8 ; Segment permissions: Read/Execute
.text$mn:00000FD8 _text$mn        segment para public 'CODE' use32
.text$mn:00000FD8                 assume cs:_text$mn
.text$mn:00000FD8                 ;org 0FD8h
.text$mn:00000FD8 ; COMDAT (pick any)
.text$mn:00000FD8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00000FD8
.text$mn:00000FD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FD8
.text$mn:00000FD8 ; Attributes: bp-based frame
.text$mn:00000FD8
.text$mn:00000FD8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00000FD8                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000FD8 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00000FD8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00000FD8
.text$mn:00000FD8 var_20          = dword ptr -20h
.text$mn:00000FD8 var_1C          = dword ptr -1Ch
.text$mn:00000FD8 var_18          = dword ptr -18h
.text$mn:00000FD8 var_11          = byte ptr -11h
.text$mn:00000FD8 var_10          = dword ptr -10h
.text$mn:00000FD8 var_C           = byte ptr -0Ch
.text$mn:00000FD8 var_4           = dword ptr -4
.text$mn:00000FD8 arg_0           = dword ptr  8
.text$mn:00000FD8
.text$mn:00000FD8 ; FUNCTION CHUNK AT .text$mn:000010FA SIZE 00000009 BYTES
.text$mn:00000FD8
.text$mn:00000FD8                 push    ebp
.text$mn:00000FD9                 mov     ebp, esp
.text$mn:00000FDB                 push    0FFFFFFFFh
.text$mn:00000FDD                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00000FE2                 mov     eax, large fs:0
.text$mn:00000FE8                 push    eax
.text$mn:00000FE9                 push    ecx
.text$mn:00000FEA                 sub     esp, 10h
.text$mn:00000FED                 push    ebx
.text$mn:00000FEE                 push    esi
.text$mn:00000FEF                 push    edi
.text$mn:00000FF0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000FF5                 xor     eax, ebp
.text$mn:00000FF7                 push    eax
.text$mn:00000FF8                 lea     eax, [ebp+var_C]
.text$mn:00000FFB                 mov     large fs:0, eax
.text$mn:00001001                 mov     [ebp+var_10], esp
.text$mn:00001004                 mov     [ebp+var_18], ecx
.text$mn:00001007                 mov     eax, [ebp+arg_0]
.text$mn:0000100A                 or      eax, 0Fh
.text$mn:0000100D                 mov     [ebp+var_1C], eax
.text$mn:00001010                 mov     ecx, [ebp+var_18]
.text$mn:00001013                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001018                 cmp     eax, [ebp+var_1C]
.text$mn:0000101B                 jnb     short loc_1025
.text$mn:0000101D                 mov     ecx, [ebp+arg_0]
.text$mn:00001020                 mov     [ebp+var_1C], ecx
.text$mn:00001023                 jmp     short loc_1077
.text$mn:00001025 ; ---------------------------------------------------------------------------
.text$mn:00001025
.text$mn:00001025 loc_1025:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00001025                 mov     edx, [ebp+var_18]
.text$mn:00001028                 mov     ecx, [edx+18h]
.text$mn:0000102B                 shr     ecx, 1
.text$mn:0000102D                 mov     eax, [ebp+var_1C]
.text$mn:00001030                 xor     edx, edx
.text$mn:00001032                 mov     esi, 3
.text$mn:00001037                 div     esi
.text$mn:00001039                 cmp     ecx, eax
.text$mn:0000103B                 ja      short loc_103F
.text$mn:0000103D                 jmp     short loc_1077
.text$mn:0000103F ; ---------------------------------------------------------------------------
.text$mn:0000103F
.text$mn:0000103F loc_103F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:0000103F                 mov     ecx, [ebp+var_18]
.text$mn:00001042                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001047                 mov     edx, [ebp+var_18]
.text$mn:0000104A                 mov     ecx, [edx+18h]
.text$mn:0000104D                 shr     ecx, 1
.text$mn:0000104F                 sub     eax, ecx
.text$mn:00001051                 mov     edx, [ebp+var_18]
.text$mn:00001054                 cmp     [edx+18h], eax
.text$mn:00001057                 ja      short loc_106C
.text$mn:00001059                 mov     eax, [ebp+var_18]
.text$mn:0000105C                 mov     ecx, [eax+18h]
.text$mn:0000105F                 shr     ecx, 1
.text$mn:00001061                 mov     edx, [ebp+var_18]
.text$mn:00001064                 add     ecx, [edx+18h]
.text$mn:00001067                 mov     [ebp+var_1C], ecx
.text$mn:0000106A                 jmp     short loc_1077
.text$mn:0000106C ; ---------------------------------------------------------------------------
.text$mn:0000106C
.text$mn:0000106C loc_106C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:0000106C                 mov     ecx, [ebp+var_18]
.text$mn:0000106F                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001074                 mov     [ebp+var_1C], eax
.text$mn:00001077
.text$mn:00001077 loc_1077:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00001077                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00001077                 mov     [ebp+var_4], 0
.text$mn:0000107E                 mov     eax, [ebp+var_1C]
.text$mn:00001081                 add     eax, 1
.text$mn:00001084                 push    eax
.text$mn:00001085                 lea     ecx, [ebp+var_11]
.text$mn:00001088                 push    ecx
.text$mn:00001089                 mov     ecx, [ebp+var_18]
.text$mn:0000108C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001091                 mov     ecx, eax
.text$mn:00001093                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001098                 mov     [ebp+var_20], eax
.text$mn:0000109B                 jmp     short loc_10FA
.text$mn:0000109B ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:0000109B
.text$mn:0000109D
.text$mn:0000109D ; =============== S U B R O U T I N E =======================================
.text$mn:0000109D
.text$mn:0000109D
.text$mn:0000109D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:0000109D                                         ; DATA XREF: .xdata$x:00001EA0o
.text$mn:0000109D
.text$mn:0000109D ; FUNCTION CHUNK AT .text$mn:000010E4 SIZE 00000009 BYTES
.text$mn:0000109D ; FUNCTION CHUNK AT .text$mn:000010F4 SIZE 00000006 BYTES
.text$mn:0000109D
.text$mn:0000109D                 mov     [ebp-10h], esp
.text$mn:000010A0                 mov     edx, [ebp+8]
.text$mn:000010A3                 mov     [ebp-1Ch], edx
.text$mn:000010A6                 mov     byte ptr [ebp-4], 2
.text$mn:000010AA                 mov     eax, [ebp-1Ch]
.text$mn:000010AD                 add     eax, 1
.text$mn:000010B0                 push    eax
.text$mn:000010B1                 lea     ecx, [ebp-12h]
.text$mn:000010B4                 push    ecx
.text$mn:000010B5                 mov     ecx, [ebp-18h]
.text$mn:000010B8                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000010BD                 mov     ecx, eax
.text$mn:000010BF                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000010C4                 mov     [ebp-20h], eax
.text$mn:000010C7                 jmp     short loc_10E4
.text$mn:000010C7 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:000010C7
.text$mn:000010C9
.text$mn:000010C9 ; =============== S U B R O U T I N E =======================================
.text$mn:000010C9
.text$mn:000010C9 ; Attributes: noreturn
.text$mn:000010C9
.text$mn:000010C9 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:000010C9                                         ; DATA XREF: .xdata$x:00001EB0o
.text$mn:000010C9                 push    0               ; Size
.text$mn:000010CB                 push    1               ; char
.text$mn:000010CD                 mov     ecx, [ebp-18h]
.text$mn:000010D0                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000010D5                 push    0
.text$mn:000010D7                 push    0
.text$mn:000010D9                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000010D9 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:000010D9
.text$mn:000010DE ; ---------------------------------------------------------------------------
.text$mn:000010DE                 mov     eax, offset $LN17
.text$mn:000010E3                 retn
.text$mn:000010E4 ; ---------------------------------------------------------------------------
.text$mn:000010E4 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000010E4
.text$mn:000010E4 loc_10E4:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:000010E4                 mov     dword ptr [ebp-4], 1
.text$mn:000010EB                 jmp     short loc_10F4
.text$mn:000010EB ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000010ED
.text$mn:000010ED ; =============== S U B R O U T I N E =======================================
.text$mn:000010ED
.text$mn:000010ED
.text$mn:000010ED $LN17           proc near               ; DATA XREF: .text$mn:000010DEo
.text$mn:000010ED                 mov     dword ptr [ebp-4], 1
.text$mn:000010ED $LN17           endp ; sp-analysis failed
.text$mn:000010ED
.text$mn:000010F4 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000010F4
.text$mn:000010F4 loc_10F4:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:000010F4                 mov     eax, offset $LN19
.text$mn:000010F9                 retn
.text$mn:000010F9 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000010FA ; ---------------------------------------------------------------------------
.text$mn:000010FA ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000010FA
.text$mn:000010FA loc_10FA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:000010FA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001101                 jmp     short loc_110A
.text$mn:00001101 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001103
.text$mn:00001103 ; =============== S U B R O U T I N E =======================================
.text$mn:00001103
.text$mn:00001103
.text$mn:00001103 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_10F4o
.text$mn:00001103                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000110A
.text$mn:0000110A loc_110A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:0000110A                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000110E                 jbe     short loc_1129
.text$mn:00001110                 mov     edx, [ebp+0Ch]
.text$mn:00001113                 push    edx             ; Size
.text$mn:00001114                 mov     ecx, [ebp-18h]
.text$mn:00001117                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000111C                 push    eax             ; Src
.text$mn:0000111D                 mov     eax, [ebp-20h]
.text$mn:00001120                 push    eax             ; Dst
.text$mn:00001121                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001126                 add     esp, 0Ch
.text$mn:00001129
.text$mn:00001129 loc_1129:                               ; CODE XREF: $LN19+Bj
.text$mn:00001129                 push    0               ; Size
.text$mn:0000112B                 push    1               ; char
.text$mn:0000112D                 mov     ecx, [ebp-18h]
.text$mn:00001130                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001135                 lea     ecx, [ebp-20h]
.text$mn:00001138                 push    ecx             ; int
.text$mn:00001139                 mov     edx, [ebp-18h]
.text$mn:0000113C                 add     edx, 4
.text$mn:0000113F                 push    edx             ; void *
.text$mn:00001140                 lea     eax, [ebp-13h]
.text$mn:00001143                 push    eax
.text$mn:00001144                 mov     ecx, [ebp-18h]
.text$mn:00001147                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000114C                 mov     ecx, eax
.text$mn:0000114E                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001153                 mov     ecx, [ebp-18h]
.text$mn:00001156                 mov     edx, [ebp-1Ch]
.text$mn:00001159                 mov     [ecx+18h], edx
.text$mn:0000115C                 mov     eax, [ebp+0Ch]
.text$mn:0000115F                 push    eax
.text$mn:00001160                 mov     ecx, [ebp-18h]
.text$mn:00001163                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001168                 mov     ecx, [ebp-0Ch]
.text$mn:0000116B                 mov     large fs:0, ecx
.text$mn:00001172                 pop     ecx
.text$mn:00001173                 pop     edi
.text$mn:00001174                 pop     esi
.text$mn:00001175                 pop     ebx
.text$mn:00001176                 mov     esp, ebp
.text$mn:00001178                 pop     ebp
.text$mn:00001179                 retn    8
.text$mn:00001179 $LN19           endp ; sp-analysis failed
.text$mn:00001179
.text$mn:00001179 _text$mn        ends
.text$mn:00001179
.text$x:0000117C ; ===========================================================================
.text$x:0000117C
.text$x:0000117C ; Segment type: Pure code
.text$x:0000117C ; Segment permissions: Read/Execute
.text$x:0000117C _text$x         segment para public 'CODE' use32
.text$x:0000117C                 assume cs:_text$x
.text$x:0000117C                 ;org 117Ch
.text$x:0000117C ; COMDAT (pick associative to section at FD8)
.text$x:0000117C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:0000117C
.text$x:0000117C ; =============== S U B R O U T I N E =======================================
.text$x:0000117C
.text$x:0000117C
.text$x:0000117C __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:0000117C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:0000117C
.text$x:0000117C arg_4           = dword ptr  8
.text$x:0000117C
.text$x:0000117C                 mov     edx, [esp+arg_4]
.text$x:00001180                 lea     eax, [edx+0Ch]
.text$x:00001183                 mov     ecx, [edx-24h]
.text$x:00001186                 xor     ecx, eax
.text$x:00001188                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000118D                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00001192                 jmp     ___CxxFrameHandler3
.text$x:00001192 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00001192
.text$x:00001192 ; ---------------------------------------------------------------------------
.text$x:00001197                 align 4
.text$x:00001197 _text$x         ends
.text$x:00001197
.text$mn:00001198 ; ===========================================================================
.text$mn:00001198
.text$mn:00001198 ; Segment type: Pure code
.text$mn:00001198 ; Segment permissions: Read/Execute
.text$mn:00001198 _text$mn        segment para public 'CODE' use32
.text$mn:00001198                 assume cs:_text$mn
.text$mn:00001198                 ;org 1198h
.text$mn:00001198 ; COMDAT (pick any)
.text$mn:00001198                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001198
.text$mn:00001198 ; =============== S U B R O U T I N E =======================================
.text$mn:00001198
.text$mn:00001198 ; Attributes: bp-based frame
.text$mn:00001198
.text$mn:00001198 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00001198                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00001198 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00001198                                         ; CODE XREF: $LN19+60p
.text$mn:00001198                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00001198
.text$mn:00001198 var_8           = dword ptr -8
.text$mn:00001198 var_1           = byte ptr -1
.text$mn:00001198 arg_0           = dword ptr  8
.text$mn:00001198
.text$mn:00001198                 push    ebp
.text$mn:00001199                 mov     ebp, esp
.text$mn:0000119B                 sub     esp, 8
.text$mn:0000119E                 mov     [ebp+var_8], ecx
.text$mn:000011A1                 mov     [ebp+var_1], 0
.text$mn:000011A5                 mov     eax, [ebp+var_8]
.text$mn:000011A8                 mov     ecx, [ebp+arg_0]
.text$mn:000011AB                 mov     [eax+14h], ecx
.text$mn:000011AE                 lea     edx, [ebp+var_1]
.text$mn:000011B1                 push    edx
.text$mn:000011B2                 mov     ecx, [ebp+var_8]
.text$mn:000011B5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000011BA                 add     eax, [ebp+arg_0]
.text$mn:000011BD                 push    eax
.text$mn:000011BE                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:000011C3                 add     esp, 8
.text$mn:000011C6                 mov     esp, ebp
.text$mn:000011C8                 pop     ebp
.text$mn:000011C9                 retn    4
.text$mn:000011C9 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:000011C9
.text$mn:000011C9 _text$mn        ends
.text$mn:000011C9
.text$mn:000011CC ; ===========================================================================
.text$mn:000011CC
.text$mn:000011CC ; Segment type: Pure code
.text$mn:000011CC ; Segment permissions: Read/Execute
.text$mn:000011CC _text$mn        segment para public 'CODE' use32
.text$mn:000011CC                 assume cs:_text$mn
.text$mn:000011CC                 ;org 11CCh
.text$mn:000011CC ; COMDAT (pick any)
.text$mn:000011CC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000011CC
.text$mn:000011CC ; =============== S U B R O U T I N E =======================================
.text$mn:000011CC
.text$mn:000011CC ; Attributes: bp-based frame
.text$mn:000011CC
.text$mn:000011CC ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:000011CC                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000011CC ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000011CC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:000011CC
.text$mn:000011CC var_8           = dword ptr -8
.text$mn:000011CC var_1           = byte ptr -1
.text$mn:000011CC
.text$mn:000011CC                 push    ebp
.text$mn:000011CD                 mov     ebp, esp
.text$mn:000011CF                 sub     esp, 8
.text$mn:000011D2                 mov     [ebp+var_8], ecx
.text$mn:000011D5                 lea     ecx, [ebp+var_1]
.text$mn:000011D8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000011DD                 mov     ecx, [ebp+var_8] ; this
.text$mn:000011E0                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000011E5                 mov     eax, [ebp+var_8]
.text$mn:000011E8                 mov     ecx, [eax]
.text$mn:000011EA                 push    ecx
.text$mn:000011EB                 lea     ecx, [ebp+var_1]
.text$mn:000011EE                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000011F3                 push    1               ; int
.text$mn:000011F5                 mov     edx, [ebp+var_8]
.text$mn:000011F8                 mov     eax, [edx]
.text$mn:000011FA                 push    eax             ; void *
.text$mn:000011FB                 lea     ecx, [ebp+var_1]
.text$mn:000011FE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00001203                 mov     ecx, [ebp+var_8]
.text$mn:00001206                 mov     dword ptr [ecx], 0
.text$mn:0000120C                 mov     esp, ebp
.text$mn:0000120E                 pop     ebp
.text$mn:0000120F                 retn
.text$mn:0000120F ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000120F
.text$mn:0000120F _text$mn        ends
.text$mn:0000120F
.text$mn:00001210 ; ===========================================================================
.text$mn:00001210
.text$mn:00001210 ; Segment type: Pure code
.text$mn:00001210 ; Segment permissions: Read/Execute
.text$mn:00001210 _text$mn        segment para public 'CODE' use32
.text$mn:00001210                 assume cs:_text$mn
.text$mn:00001210                 ;org 1210h
.text$mn:00001210 ; COMDAT (pick any)
.text$mn:00001210                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001210
.text$mn:00001210 ; =============== S U B R O U T I N E =======================================
.text$mn:00001210
.text$mn:00001210 ; Attributes: bp-based frame
.text$mn:00001210
.text$mn:00001210 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00001210                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00001210 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00001210                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00001210                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00001210
.text$mn:00001210 var_4           = dword ptr -4
.text$mn:00001210 arg_0           = dword ptr  8
.text$mn:00001210
.text$mn:00001210                 push    ebp
.text$mn:00001211                 mov     ebp, esp
.text$mn:00001213                 push    ecx
.text$mn:00001214                 mov     [ebp+var_4], ecx
.text$mn:00001217                 mov     ecx, [ebp+arg_0]
.text$mn:0000121A                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:0000121F                 mov     eax, [ebp+arg_0]
.text$mn:00001222                 mov     esp, ebp
.text$mn:00001224                 pop     ebp
.text$mn:00001225                 retn    4
.text$mn:00001225 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00001225
.text$mn:00001225 _text$mn        ends
.text$mn:00001225
.text$mn:00001228 ; ===========================================================================
.text$mn:00001228
.text$mn:00001228 ; Segment type: Pure code
.text$mn:00001228 ; Segment permissions: Read/Execute
.text$mn:00001228 _text$mn        segment para public 'CODE' use32
.text$mn:00001228                 assume cs:_text$mn
.text$mn:00001228                 ;org 1228h
.text$mn:00001228 ; COMDAT (pick any)
.text$mn:00001228                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001228
.text$mn:00001228 ; =============== S U B R O U T I N E =======================================
.text$mn:00001228
.text$mn:00001228 ; Attributes: bp-based frame
.text$mn:00001228
.text$mn:00001228 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00001228                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00001228 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00001228                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00001228                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00001228
.text$mn:00001228 var_C           = dword ptr -0Ch
.text$mn:00001228 Size            = dword ptr -8
.text$mn:00001228 var_4           = dword ptr -4
.text$mn:00001228 arg_0           = dword ptr  8
.text$mn:00001228 arg_4           = byte ptr  0Ch
.text$mn:00001228
.text$mn:00001228                 push    ebp
.text$mn:00001229                 mov     ebp, esp
.text$mn:0000122B                 sub     esp, 0Ch
.text$mn:0000122E                 mov     [ebp+var_4], ecx
.text$mn:00001231                 mov     ecx, [ebp+var_4]
.text$mn:00001234                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001239                 cmp     eax, [ebp+arg_0]
.text$mn:0000123C                 jnb     short loc_1246
.text$mn:0000123E                 mov     ecx, [ebp+var_4]
.text$mn:00001241                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00001246
.text$mn:00001246 loc_1246:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00001246                 mov     eax, [ebp+var_4]
.text$mn:00001249                 mov     ecx, [eax+18h]
.text$mn:0000124C                 cmp     ecx, [ebp+arg_0]
.text$mn:0000124F                 jnb     short loc_1266
.text$mn:00001251                 mov     edx, [ebp+var_4]
.text$mn:00001254                 mov     eax, [edx+14h]
.text$mn:00001257                 push    eax
.text$mn:00001258                 mov     ecx, [ebp+arg_0]
.text$mn:0000125B                 push    ecx
.text$mn:0000125C                 mov     ecx, [ebp+var_4]
.text$mn:0000125F                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00001264                 jmp     short loc_12B0
.text$mn:00001266 ; ---------------------------------------------------------------------------
.text$mn:00001266
.text$mn:00001266 loc_1266:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00001266                 movzx   edx, [ebp+arg_4]
.text$mn:0000126A                 test    edx, edx
.text$mn:0000126C                 jz      short loc_12A0
.text$mn:0000126E                 cmp     [ebp+arg_0], 10h
.text$mn:00001272                 jnb     short loc_12A0
.text$mn:00001274                 mov     eax, [ebp+var_4]
.text$mn:00001277                 mov     ecx, [ebp+arg_0]
.text$mn:0000127A                 cmp     ecx, [eax+14h]
.text$mn:0000127D                 jnb     short loc_1287
.text$mn:0000127F                 mov     edx, [ebp+arg_0]
.text$mn:00001282                 mov     [ebp+Size], edx
.text$mn:00001285                 jmp     short loc_1290
.text$mn:00001287 ; ---------------------------------------------------------------------------
.text$mn:00001287
.text$mn:00001287 loc_1287:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00001287                 mov     eax, [ebp+var_4]
.text$mn:0000128A                 mov     ecx, [eax+14h]
.text$mn:0000128D                 mov     [ebp+Size], ecx
.text$mn:00001290
.text$mn:00001290 loc_1290:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00001290                 mov     edx, [ebp+Size]
.text$mn:00001293                 push    edx             ; Size
.text$mn:00001294                 push    1               ; char
.text$mn:00001296                 mov     ecx, [ebp+var_4]
.text$mn:00001299                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000129E                 jmp     short loc_12B0
.text$mn:000012A0 ; ---------------------------------------------------------------------------
.text$mn:000012A0
.text$mn:000012A0 loc_12A0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:000012A0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:000012A0                 cmp     [ebp+arg_0], 0
.text$mn:000012A4                 jnz     short loc_12B0
.text$mn:000012A6                 push    0
.text$mn:000012A8                 mov     ecx, [ebp+var_4]
.text$mn:000012AB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000012B0
.text$mn:000012B0 loc_12B0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:000012B0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:000012B0                 cmp     [ebp+arg_0], 0
.text$mn:000012B4                 jbe     short loc_12BF
.text$mn:000012B6                 mov     [ebp+var_C], 1
.text$mn:000012BD                 jmp     short loc_12C6
.text$mn:000012BF ; ---------------------------------------------------------------------------
.text$mn:000012BF
.text$mn:000012BF loc_12BF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:000012BF                 mov     [ebp+var_C], 0
.text$mn:000012C6
.text$mn:000012C6 loc_12C6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:000012C6                 mov     al, byte ptr [ebp+var_C]
.text$mn:000012C9                 mov     esp, ebp
.text$mn:000012CB                 pop     ebp
.text$mn:000012CC                 retn    8
.text$mn:000012CC ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:000012CC
.text$mn:000012CC ; ---------------------------------------------------------------------------
.text$mn:000012CF                 align 10h
.text$mn:000012CF _text$mn        ends
.text$mn:000012CF
.text$mn:000012D0 ; ===========================================================================
.text$mn:000012D0
.text$mn:000012D0 ; Segment type: Pure code
.text$mn:000012D0 ; Segment permissions: Read/Execute
.text$mn:000012D0 _text$mn        segment para public 'CODE' use32
.text$mn:000012D0                 assume cs:_text$mn
.text$mn:000012D0                 ;org 12D0h
.text$mn:000012D0 ; COMDAT (pick any)
.text$mn:000012D0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000012D0
.text$mn:000012D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000012D0
.text$mn:000012D0 ; Attributes: bp-based frame
.text$mn:000012D0
.text$mn:000012D0 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000012D0                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000012D0 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000012D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000012D0
.text$mn:000012D0 var_4           = dword ptr -4
.text$mn:000012D0 arg_0           = dword ptr  8
.text$mn:000012D0
.text$mn:000012D0                 push    ebp
.text$mn:000012D1                 mov     ebp, esp
.text$mn:000012D3                 push    ecx
.text$mn:000012D4                 mov     [ebp+var_4], ecx
.text$mn:000012D7                 cmp     [ebp+arg_0], 0
.text$mn:000012DB                 jz      short loc_12FD
.text$mn:000012DD                 mov     ecx, [ebp+var_4]
.text$mn:000012E0                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000012E5                 cmp     [ebp+arg_0], eax
.text$mn:000012E8                 jb      short loc_12FD
.text$mn:000012EA                 mov     ecx, [ebp+var_4]
.text$mn:000012ED                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000012F2                 mov     ecx, [ebp+var_4]
.text$mn:000012F5                 add     eax, [ecx+14h]
.text$mn:000012F8                 cmp     eax, [ebp+arg_0]
.text$mn:000012FB                 ja      short loc_1303
.text$mn:000012FD
.text$mn:000012FD loc_12FD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:000012FD                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:000012FD                 xor     al, al
.text$mn:000012FF                 jmp     short loc_1305
.text$mn:00001301 ; ---------------------------------------------------------------------------
.text$mn:00001301                 jmp     short loc_1305
.text$mn:00001303 ; ---------------------------------------------------------------------------
.text$mn:00001303
.text$mn:00001303 loc_1303:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00001303                 mov     al, 1
.text$mn:00001305
.text$mn:00001305 loc_1305:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00001305                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00001305                 mov     esp, ebp
.text$mn:00001307                 pop     ebp
.text$mn:00001308                 retn    4
.text$mn:00001308 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00001308
.text$mn:00001308 ; ---------------------------------------------------------------------------
.text$mn:0000130B                 align 4
.text$mn:0000130B _text$mn        ends
.text$mn:0000130B
.text$mn:0000130C ; ===========================================================================
.text$mn:0000130C
.text$mn:0000130C ; Segment type: Pure code
.text$mn:0000130C ; Segment permissions: Read/Execute
.text$mn:0000130C _text$mn        segment para public 'CODE' use32
.text$mn:0000130C                 assume cs:_text$mn
.text$mn:0000130C                 ;org 130Ch
.text$mn:0000130C ; COMDAT (pick any)
.text$mn:0000130C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000130C
.text$mn:0000130C ; =============== S U B R O U T I N E =======================================
.text$mn:0000130C
.text$mn:0000130C ; Attributes: bp-based frame
.text$mn:0000130C
.text$mn:0000130C ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000130C                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:0000130C ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:0000130C                                         ; CODE XREF: $LN19+14p
.text$mn:0000130C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:0000130C
.text$mn:0000130C var_8           = dword ptr -8
.text$mn:0000130C var_4           = dword ptr -4
.text$mn:0000130C
.text$mn:0000130C                 push    ebp
.text$mn:0000130D                 mov     ebp, esp
.text$mn:0000130F                 sub     esp, 8
.text$mn:00001312                 mov     [ebp+var_4], ecx
.text$mn:00001315                 mov     eax, [ebp+var_4]
.text$mn:00001318                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000131C                 jb      short loc_1332
.text$mn:0000131E                 mov     ecx, [ebp+var_4]
.text$mn:00001321                 mov     edx, [ecx+4]
.text$mn:00001324                 push    edx
.text$mn:00001325                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000132A                 add     esp, 4
.text$mn:0000132D                 mov     [ebp+var_8], eax
.text$mn:00001330                 jmp     short loc_133B
.text$mn:00001332 ; ---------------------------------------------------------------------------
.text$mn:00001332
.text$mn:00001332 loc_1332:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00001332                 mov     eax, [ebp+var_4]
.text$mn:00001335                 add     eax, 4
.text$mn:00001338                 mov     [ebp+var_8], eax
.text$mn:0000133B
.text$mn:0000133B loc_133B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000133B                 mov     eax, [ebp+var_8]
.text$mn:0000133E                 mov     esp, ebp
.text$mn:00001340                 pop     ebp
.text$mn:00001341                 retn
.text$mn:00001341 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00001341
.text$mn:00001341 ; ---------------------------------------------------------------------------
.text$mn:00001342                 align 4
.text$mn:00001342 _text$mn        ends
.text$mn:00001342
.text$mn:00001344 ; ===========================================================================
.text$mn:00001344
.text$mn:00001344 ; Segment type: Pure code
.text$mn:00001344 ; Segment permissions: Read/Execute
.text$mn:00001344 _text$mn        segment para public 'CODE' use32
.text$mn:00001344                 assume cs:_text$mn
.text$mn:00001344                 ;org 1344h
.text$mn:00001344 ; COMDAT (pick any)
.text$mn:00001344                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001344
.text$mn:00001344 ; =============== S U B R O U T I N E =======================================
.text$mn:00001344
.text$mn:00001344 ; Attributes: bp-based frame
.text$mn:00001344
.text$mn:00001344 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00001344                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00001344 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00001344                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00001344                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(void)+Ap
.text$mn:00001344
.text$mn:00001344 var_8           = dword ptr -8
.text$mn:00001344 var_4           = dword ptr -4
.text$mn:00001344
.text$mn:00001344                 push    ebp
.text$mn:00001345                 mov     ebp, esp
.text$mn:00001347                 sub     esp, 8
.text$mn:0000134A                 mov     [ebp+var_4], ecx
.text$mn:0000134D                 mov     eax, [ebp+var_4]
.text$mn:00001350                 cmp     dword ptr [eax+18h], 10h
.text$mn:00001354                 jb      short loc_136A
.text$mn:00001356                 mov     ecx, [ebp+var_4]
.text$mn:00001359                 mov     edx, [ecx+4]
.text$mn:0000135C                 push    edx
.text$mn:0000135D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00001362                 add     esp, 4
.text$mn:00001365                 mov     [ebp+var_8], eax
.text$mn:00001368                 jmp     short loc_1373
.text$mn:0000136A ; ---------------------------------------------------------------------------
.text$mn:0000136A
.text$mn:0000136A loc_136A:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000136A                 mov     eax, [ebp+var_4]
.text$mn:0000136D                 add     eax, 4
.text$mn:00001370                 mov     [ebp+var_8], eax
.text$mn:00001373
.text$mn:00001373 loc_1373:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00001373                 mov     eax, [ebp+var_8]
.text$mn:00001376                 mov     esp, ebp
.text$mn:00001378                 pop     ebp
.text$mn:00001379                 retn
.text$mn:00001379 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00001379
.text$mn:00001379 ; ---------------------------------------------------------------------------
.text$mn:0000137A                 align 4
.text$mn:0000137A _text$mn        ends
.text$mn:0000137A
.text$mn:0000137C ; ===========================================================================
.text$mn:0000137C
.text$mn:0000137C ; Segment type: Pure code
.text$mn:0000137C ; Segment permissions: Read/Execute
.text$mn:0000137C _text$mn        segment para public 'CODE' use32
.text$mn:0000137C                 assume cs:_text$mn
.text$mn:0000137C                 ;org 137Ch
.text$mn:0000137C ; COMDAT (pick any)
.text$mn:0000137C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000137C
.text$mn:0000137C ; =============== S U B R O U T I N E =======================================
.text$mn:0000137C
.text$mn:0000137C ; Attributes: bp-based frame
.text$mn:0000137C
.text$mn:0000137C ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:0000137C                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000137C ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:0000137C                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:0000137C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:0000137C
.text$mn:0000137C var_18          = byte ptr -18h
.text$mn:0000137C var_14          = dword ptr -14h
.text$mn:0000137C var_10          = dword ptr -10h
.text$mn:0000137C var_C           = dword ptr -0Ch
.text$mn:0000137C var_4           = dword ptr -4
.text$mn:0000137C
.text$mn:0000137C                 push    ebp
.text$mn:0000137D                 mov     ebp, esp
.text$mn:0000137F                 push    0FFFFFFFFh
.text$mn:00001381                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00001386                 mov     eax, large fs:0
.text$mn:0000138C                 push    eax
.text$mn:0000138D                 sub     esp, 0Ch
.text$mn:00001390                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001395                 xor     eax, ebp
.text$mn:00001397                 push    eax
.text$mn:00001398                 lea     eax, [ebp+var_C]
.text$mn:0000139B                 mov     large fs:0, eax
.text$mn:000013A1                 mov     [ebp+var_14], ecx
.text$mn:000013A4                 mov     eax, [ebp+var_14]
.text$mn:000013A7                 cmp     dword ptr [eax], 0
.text$mn:000013AA                 jz      short loc_1407
.text$mn:000013AC                 push    3               ; int
.text$mn:000013AE                 lea     ecx, [ebp+var_18] ; this
.text$mn:000013B1                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000013B6                 mov     [ebp+var_4], 0
.text$mn:000013BD                 mov     ecx, [ebp+var_14]
.text$mn:000013C0                 mov     edx, [ecx]
.text$mn:000013C2                 add     edx, 4
.text$mn:000013C5                 mov     [ebp+var_10], edx
.text$mn:000013C8                 jmp     short loc_13D7
.text$mn:000013CA ; ---------------------------------------------------------------------------
.text$mn:000013CA
.text$mn:000013CA loc_13CA:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:000013CA                 mov     eax, [ebp+var_10]
.text$mn:000013CD                 mov     ecx, [eax]
.text$mn:000013CF                 mov     edx, [ebp+var_10]
.text$mn:000013D2                 mov     eax, [ecx+4]
.text$mn:000013D5                 mov     [edx], eax
.text$mn:000013D7
.text$mn:000013D7 loc_13D7:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:000013D7                 mov     ecx, [ebp+var_10]
.text$mn:000013DA                 cmp     dword ptr [ecx], 0
.text$mn:000013DD                 jz      short loc_13EC
.text$mn:000013DF                 mov     edx, [ebp+var_10]
.text$mn:000013E2                 mov     eax, [edx]
.text$mn:000013E4                 mov     dword ptr [eax], 0
.text$mn:000013EA                 jmp     short loc_13CA
.text$mn:000013EC ; ---------------------------------------------------------------------------
.text$mn:000013EC
.text$mn:000013EC loc_13EC:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:000013EC                 mov     ecx, [ebp+var_14]
.text$mn:000013EF                 mov     edx, [ecx]
.text$mn:000013F1                 mov     dword ptr [edx+4], 0
.text$mn:000013F8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000013FF                 lea     ecx, [ebp+var_18] ; this
.text$mn:00001402                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00001407
.text$mn:00001407 loc_1407:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00001407                 mov     ecx, [ebp+var_C]
.text$mn:0000140A                 mov     large fs:0, ecx
.text$mn:00001411                 pop     ecx
.text$mn:00001412                 mov     esp, ebp
.text$mn:00001414                 pop     ebp
.text$mn:00001415                 retn
.text$mn:00001415 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00001415
.text$mn:00001415 ; ---------------------------------------------------------------------------
.text$mn:00001416                 align 4
.text$mn:00001416 _text$mn        ends
.text$mn:00001416
.text$x:00001418 ; ===========================================================================
.text$x:00001418
.text$x:00001418 ; Segment type: Pure code
.text$x:00001418 ; Segment permissions: Read/Execute
.text$x:00001418 _text$x         segment para public 'CODE' use32
.text$x:00001418                 assume cs:_text$x
.text$x:00001418                 ;org 1418h
.text$x:00001418 ; COMDAT (pick associative to section at 137C)
.text$x:00001418                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001418
.text$x:00001418 ; =============== S U B R O U T I N E =======================================
.text$x:00001418
.text$x:00001418
.text$x:00001418 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00001418                                         ; DATA XREF: .xdata$x:00001D38o
.text$x:00001418                 lea     ecx, [ebp-18h]  ; this
.text$x:0000141B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000141B __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:0000141B
.text$x:00001420
.text$x:00001420 ; =============== S U B R O U T I N E =======================================
.text$x:00001420
.text$x:00001420
.text$x:00001420 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00001420                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00001420
.text$x:00001420 arg_4           = dword ptr  8
.text$x:00001420
.text$x:00001420                 mov     edx, [esp+arg_4]
.text$x:00001424                 lea     eax, [edx+0Ch]
.text$x:00001427                 mov     ecx, [edx-10h]
.text$x:0000142A                 xor     ecx, eax
.text$x:0000142C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001431                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00001436                 jmp     ___CxxFrameHandler3
.text$x:00001436 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00001436
.text$x:00001436 ; ---------------------------------------------------------------------------
.text$x:0000143B                 align 4
.text$x:0000143B _text$x         ends
.text$x:0000143B
.text$mn:0000143C ; ===========================================================================
.text$mn:0000143C
.text$mn:0000143C ; Segment type: Pure code
.text$mn:0000143C ; Segment permissions: Read/Execute
.text$mn:0000143C _text$mn        segment para public 'CODE' use32
.text$mn:0000143C                 assume cs:_text$mn
.text$mn:0000143C                 ;org 143Ch
.text$mn:0000143C ; COMDAT (pick any)
.text$mn:0000143C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000143C
.text$mn:0000143C ; =============== S U B R O U T I N E =======================================
.text$mn:0000143C
.text$mn:0000143C ; Attributes: bp-based frame
.text$mn:0000143C
.text$mn:0000143C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:0000143C                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:0000143C ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:0000143C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:0000143C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+47p ...
.text$mn:0000143C
.text$mn:0000143C var_C           = dword ptr -0Ch
.text$mn:0000143C var_8           = dword ptr -8
.text$mn:0000143C var_2           = byte ptr -2
.text$mn:0000143C var_1           = byte ptr -1
.text$mn:0000143C arg_0           = byte ptr  8
.text$mn:0000143C Size            = dword ptr  0Ch
.text$mn:0000143C
.text$mn:0000143C                 push    ebp
.text$mn:0000143D                 mov     ebp, esp
.text$mn:0000143F                 sub     esp, 0Ch
.text$mn:00001442                 mov     [ebp+var_8], ecx
.text$mn:00001445                 movzx   eax, [ebp+arg_0]
.text$mn:00001449                 test    eax, eax
.text$mn:0000144B                 jnz     short loc_144F
.text$mn:0000144D                 jmp     short loc_14C2
.text$mn:0000144F ; ---------------------------------------------------------------------------
.text$mn:0000144F
.text$mn:0000144F loc_144F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:0000144F                 mov     ecx, [ebp+var_8]
.text$mn:00001452                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00001456                 jb      short loc_14C2
.text$mn:00001458                 mov     edx, [ebp+var_8]
.text$mn:0000145B                 mov     eax, [edx+4]
.text$mn:0000145E                 mov     [ebp+var_C], eax
.text$mn:00001461                 mov     ecx, [ebp+var_8]
.text$mn:00001464                 add     ecx, 4
.text$mn:00001467                 push    ecx
.text$mn:00001468                 lea     edx, [ebp+var_1]
.text$mn:0000146B                 push    edx
.text$mn:0000146C                 mov     ecx, [ebp+var_8]
.text$mn:0000146F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001474                 mov     ecx, eax
.text$mn:00001476                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000147B                 cmp     [ebp+Size], 0
.text$mn:0000147F                 jbe     short loc_14A1
.text$mn:00001481                 mov     eax, [ebp+Size]
.text$mn:00001484                 push    eax             ; Size
.text$mn:00001485                 mov     ecx, [ebp+var_C]
.text$mn:00001488                 push    ecx
.text$mn:00001489                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000148E                 add     esp, 4
.text$mn:00001491                 push    eax             ; Src
.text$mn:00001492                 mov     edx, [ebp+var_8]
.text$mn:00001495                 add     edx, 4
.text$mn:00001498                 push    edx             ; Dst
.text$mn:00001499                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000149E                 add     esp, 0Ch
.text$mn:000014A1
.text$mn:000014A1 loc_14A1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:000014A1                 mov     eax, [ebp+var_8]
.text$mn:000014A4                 mov     ecx, [eax+18h]
.text$mn:000014A7                 add     ecx, 1
.text$mn:000014AA                 push    ecx             ; int
.text$mn:000014AB                 mov     edx, [ebp+var_C]
.text$mn:000014AE                 push    edx             ; void *
.text$mn:000014AF                 lea     eax, [ebp+var_2]
.text$mn:000014B2                 push    eax
.text$mn:000014B3                 mov     ecx, [ebp+var_8]
.text$mn:000014B6                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000014BB                 mov     ecx, eax
.text$mn:000014BD                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:000014C2
.text$mn:000014C2 loc_14C2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:000014C2                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:000014C2                 mov     ecx, [ebp+var_8]
.text$mn:000014C5                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:000014CC                 mov     edx, [ebp+Size]
.text$mn:000014CF                 push    edx
.text$mn:000014D0                 mov     ecx, [ebp+var_8]
.text$mn:000014D3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000014D8                 mov     esp, ebp
.text$mn:000014DA                 pop     ebp
.text$mn:000014DB                 retn    8
.text$mn:000014DB ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:000014DB
.text$mn:000014DB ; ---------------------------------------------------------------------------
.text$mn:000014DE                 align 10h
.text$mn:000014DE _text$mn        ends
.text$mn:000014DE
.text$mn:000014E0 ; ===========================================================================
.text$mn:000014E0
.text$mn:000014E0 ; Segment type: Pure code
.text$mn:000014E0 ; Segment permissions: Read/Execute
.text$mn:000014E0 _text$mn        segment para public 'CODE' use32
.text$mn:000014E0                 assume cs:_text$mn
.text$mn:000014E0                 ;org 14E0h
.text$mn:000014E0 ; COMDAT (pick any)
.text$mn:000014E0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000014E0
.text$mn:000014E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000014E0
.text$mn:000014E0 ; Attributes: bp-based frame
.text$mn:000014E0
.text$mn:000014E0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:000014E0                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000014E0 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000014E0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:000014E0
.text$mn:000014E0 var_4           = dword ptr -4
.text$mn:000014E0
.text$mn:000014E0                 push    ebp
.text$mn:000014E1                 mov     ebp, esp
.text$mn:000014E3                 push    ecx
.text$mn:000014E4                 mov     [ebp+var_4], ecx
.text$mn:000014E7                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000014EC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000014F1                 mov     esp, ebp
.text$mn:000014F3                 pop     ebp
.text$mn:000014F4                 retn
.text$mn:000014F4 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000014F4
.text$mn:000014F4 ; ---------------------------------------------------------------------------
.text$mn:000014F5                 align 4
.text$mn:000014F5 _text$mn        ends
.text$mn:000014F5
.text$mn:000014F8 ; ===========================================================================
.text$mn:000014F8
.text$mn:000014F8 ; Segment type: Pure code
.text$mn:000014F8 ; Segment permissions: Read/Execute
.text$mn:000014F8 _text$mn        segment para public 'CODE' use32
.text$mn:000014F8                 assume cs:_text$mn
.text$mn:000014F8                 ;org 14F8h
.text$mn:000014F8 ; COMDAT (pick any)
.text$mn:000014F8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000014F8
.text$mn:000014F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014F8
.text$mn:000014F8 ; Attributes: bp-based frame
.text$mn:000014F8
.text$mn:000014F8 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000014F8                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000014F8 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000014F8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000014F8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:000014F8
.text$mn:000014F8 var_4           = dword ptr -4
.text$mn:000014F8
.text$mn:000014F8                 push    ebp
.text$mn:000014F9                 mov     ebp, esp
.text$mn:000014FB                 push    ecx
.text$mn:000014FC                 mov     [ebp+var_4], ecx
.text$mn:000014FF                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00001504                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00001509                 mov     esp, ebp
.text$mn:0000150B                 pop     ebp
.text$mn:0000150C                 retn
.text$mn:0000150C ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:0000150C
.text$mn:0000150C ; ---------------------------------------------------------------------------
.text$mn:0000150D                 align 10h
.text$mn:0000150D _text$mn        ends
.text$mn:0000150D
.text$mn:00001510 ; ===========================================================================
.text$mn:00001510
.text$mn:00001510 ; Segment type: Pure code
.text$mn:00001510 ; Segment permissions: Read/Execute
.text$mn:00001510 _text$mn        segment para public 'CODE' use32
.text$mn:00001510                 assume cs:_text$mn
.text$mn:00001510                 ;org 1510h
.text$mn:00001510 ; COMDAT (pick any)
.text$mn:00001510                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001510
.text$mn:00001510 ; =============== S U B R O U T I N E =======================================
.text$mn:00001510
.text$mn:00001510 ; Attributes: bp-based frame
.text$mn:00001510
.text$mn:00001510 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00001510                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00001510 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00001510                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00001510                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00001510
.text$mn:00001510 var_4           = dword ptr -4
.text$mn:00001510 arg_0           = dword ptr  8
.text$mn:00001510
.text$mn:00001510                 push    ebp
.text$mn:00001511                 mov     ebp, esp
.text$mn:00001513                 push    ecx
.text$mn:00001514                 mov     [ebp+var_4], ecx
.text$mn:00001517                 mov     eax, [ebp+arg_0]
.text$mn:0000151A                 push    eax
.text$mn:0000151B                 mov     ecx, [ebp+var_4]
.text$mn:0000151E                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00001523                 mov     esp, ebp
.text$mn:00001525                 pop     ebp
.text$mn:00001526                 retn    4
.text$mn:00001526 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00001526
.text$mn:00001526 ; ---------------------------------------------------------------------------
.text$mn:00001529                 align 4
.text$mn:00001529 _text$mn        ends
.text$mn:00001529
.text$mn:0000152C ; ===========================================================================
.text$mn:0000152C
.text$mn:0000152C ; Segment type: Pure code
.text$mn:0000152C ; Segment permissions: Read/Execute
.text$mn:0000152C _text$mn        segment para public 'CODE' use32
.text$mn:0000152C                 assume cs:_text$mn
.text$mn:0000152C                 ;org 152Ch
.text$mn:0000152C ; COMDAT (pick any)
.text$mn:0000152C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000152C
.text$mn:0000152C ; =============== S U B R O U T I N E =======================================
.text$mn:0000152C
.text$mn:0000152C ; Attributes: bp-based frame
.text$mn:0000152C
.text$mn:0000152C ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:0000152C                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:0000152C ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:0000152C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:0000152C
.text$mn:0000152C var_4           = dword ptr -4
.text$mn:0000152C arg_0           = dword ptr  8
.text$mn:0000152C
.text$mn:0000152C                 push    ebp
.text$mn:0000152D                 mov     ebp, esp
.text$mn:0000152F                 push    ecx
.text$mn:00001530                 mov     [ebp+var_4], ecx
.text$mn:00001533                 push    0
.text$mn:00001535                 mov     eax, [ebp+arg_0]
.text$mn:00001538                 push    eax
.text$mn:00001539                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:0000153E                 add     esp, 8
.text$mn:00001541                 mov     esp, ebp
.text$mn:00001543                 pop     ebp
.text$mn:00001544                 retn    4
.text$mn:00001544 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00001544
.text$mn:00001544 ; ---------------------------------------------------------------------------
.text$mn:00001547                 align 4
.text$mn:00001547 _text$mn        ends
.text$mn:00001547
.text$mn:00001548 ; ===========================================================================
.text$mn:00001548
.text$mn:00001548 ; Segment type: Pure code
.text$mn:00001548 ; Segment permissions: Read/Execute
.text$mn:00001548 _text$mn        segment para public 'CODE' use32
.text$mn:00001548                 assume cs:_text$mn
.text$mn:00001548                 ;org 1548h
.text$mn:00001548 ; COMDAT (pick any)
.text$mn:00001548                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001548
.text$mn:00001548 ; =============== S U B R O U T I N E =======================================
.text$mn:00001548
.text$mn:00001548 ; Attributes: bp-based frame
.text$mn:00001548
.text$mn:00001548 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00001548                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00001548 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00001548                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00001548
.text$mn:00001548 var_4           = dword ptr -4
.text$mn:00001548 arg_0           = dword ptr  8
.text$mn:00001548
.text$mn:00001548                 push    ebp
.text$mn:00001549                 mov     ebp, esp
.text$mn:0000154B                 push    ecx
.text$mn:0000154C                 mov     [ebp+var_4], ecx
.text$mn:0000154F                 push    0
.text$mn:00001551                 mov     eax, [ebp+arg_0]
.text$mn:00001554                 push    eax
.text$mn:00001555                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000155A                 add     esp, 8
.text$mn:0000155D                 mov     esp, ebp
.text$mn:0000155F                 pop     ebp
.text$mn:00001560                 retn    4
.text$mn:00001560 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00001560
.text$mn:00001560 ; ---------------------------------------------------------------------------
.text$mn:00001563                 align 4
.text$mn:00001563 _text$mn        ends
.text$mn:00001563
.text$mn:00001564 ; ===========================================================================
.text$mn:00001564
.text$mn:00001564 ; Segment type: Pure code
.text$mn:00001564 ; Segment permissions: Read/Execute
.text$mn:00001564 _text$mn        segment para public 'CODE' use32
.text$mn:00001564                 assume cs:_text$mn
.text$mn:00001564                 ;org 1564h
.text$mn:00001564 ; COMDAT (pick any)
.text$mn:00001564                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001564
.text$mn:00001564 ; =============== S U B R O U T I N E =======================================
.text$mn:00001564
.text$mn:00001564 ; Attributes: bp-based frame
.text$mn:00001564
.text$mn:00001564 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00001564                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00001564 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00001564                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00001564
.text$mn:00001564 Size            = dword ptr -8
.text$mn:00001564 var_4           = dword ptr -4
.text$mn:00001564 arg_0           = dword ptr  8
.text$mn:00001564 arg_4           = dword ptr  0Ch
.text$mn:00001564 arg_8           = dword ptr  10h
.text$mn:00001564
.text$mn:00001564                 push    ebp
.text$mn:00001565                 mov     ebp, esp
.text$mn:00001567                 sub     esp, 8
.text$mn:0000156A                 mov     [ebp+var_4], ecx
.text$mn:0000156D                 mov     ecx, [ebp+arg_0]
.text$mn:00001570                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00001575                 cmp     eax, [ebp+arg_4]
.text$mn:00001578                 jnb     short loc_1582
.text$mn:0000157A                 mov     ecx, [ebp+var_4]
.text$mn:0000157D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00001582
.text$mn:00001582 loc_1582:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00001582                 mov     ecx, [ebp+arg_0]
.text$mn:00001585                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000158A                 sub     eax, [ebp+arg_4]
.text$mn:0000158D                 mov     [ebp+Size], eax
.text$mn:00001590                 mov     eax, [ebp+arg_8]
.text$mn:00001593                 cmp     eax, [ebp+Size]
.text$mn:00001596                 jnb     short loc_159E
.text$mn:00001598                 mov     ecx, [ebp+arg_8]
.text$mn:0000159B                 mov     [ebp+Size], ecx
.text$mn:0000159E
.text$mn:0000159E loc_159E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000159E                 mov     edx, [ebp+var_4]
.text$mn:000015A1                 cmp     edx, [ebp+arg_0]
.text$mn:000015A4                 jnz     short loc_15C5
.text$mn:000015A6                 mov     eax, [ebp+arg_4]
.text$mn:000015A9                 add     eax, [ebp+Size]
.text$mn:000015AC                 push    eax
.text$mn:000015AD                 mov     ecx, [ebp+var_4]
.text$mn:000015B0                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:000015B5                 mov     ecx, [ebp+arg_4]
.text$mn:000015B8                 push    ecx
.text$mn:000015B9                 push    0
.text$mn:000015BB                 mov     ecx, [ebp+var_4]
.text$mn:000015BE                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000015C3                 jmp     short loc_1607
.text$mn:000015C5 ; ---------------------------------------------------------------------------
.text$mn:000015C5
.text$mn:000015C5 loc_15C5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000015C5                 push    0
.text$mn:000015C7                 mov     edx, [ebp+Size]
.text$mn:000015CA                 push    edx
.text$mn:000015CB                 mov     ecx, [ebp+var_4]
.text$mn:000015CE                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000015D3                 movzx   eax, al
.text$mn:000015D6                 test    eax, eax
.text$mn:000015D8                 jz      short loc_1607
.text$mn:000015DA                 mov     ecx, [ebp+Size]
.text$mn:000015DD                 push    ecx             ; Size
.text$mn:000015DE                 mov     ecx, [ebp+arg_0]
.text$mn:000015E1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000015E6                 add     eax, [ebp+arg_4]
.text$mn:000015E9                 push    eax             ; Src
.text$mn:000015EA                 mov     ecx, [ebp+var_4]
.text$mn:000015ED                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000015F2                 push    eax             ; Dst
.text$mn:000015F3                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000015F8                 add     esp, 0Ch
.text$mn:000015FB                 mov     edx, [ebp+Size]
.text$mn:000015FE                 push    edx
.text$mn:000015FF                 mov     ecx, [ebp+var_4]
.text$mn:00001602                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001607
.text$mn:00001607 loc_1607:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00001607                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00001607                 mov     eax, [ebp+var_4]
.text$mn:0000160A                 mov     esp, ebp
.text$mn:0000160C                 pop     ebp
.text$mn:0000160D                 retn    0Ch
.text$mn:0000160D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000160D
.text$mn:0000160D _text$mn        ends
.text$mn:0000160D
.text$mn:00001610 ; ===========================================================================
.text$mn:00001610
.text$mn:00001610 ; Segment type: Pure code
.text$mn:00001610 ; Segment permissions: Read/Execute
.text$mn:00001610 _text$mn        segment para public 'CODE' use32
.text$mn:00001610                 assume cs:_text$mn
.text$mn:00001610                 ;org 1610h
.text$mn:00001610 ; COMDAT (pick any)
.text$mn:00001610                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001610
.text$mn:00001610 ; =============== S U B R O U T I N E =======================================
.text$mn:00001610
.text$mn:00001610 ; Attributes: bp-based frame
.text$mn:00001610
.text$mn:00001610 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00001610                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00001610 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00001610                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00001610                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(char const *)+Ep
.text$mn:00001610
.text$mn:00001610 var_4           = dword ptr -4
.text$mn:00001610 Str             = dword ptr  8
.text$mn:00001610
.text$mn:00001610                 push    ebp
.text$mn:00001611                 mov     ebp, esp
.text$mn:00001613                 push    ecx
.text$mn:00001614                 mov     [ebp+var_4], ecx
.text$mn:00001617                 push    490h            ; unsigned int
.text$mn:0000161C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001621                 mov     eax, [ebp+Str]
.text$mn:00001624                 push    eax             ; int
.text$mn:00001625                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000162A                 add     esp, 0Ch
.text$mn:0000162D                 mov     ecx, [ebp+Str]
.text$mn:00001630                 push    ecx             ; Str
.text$mn:00001631                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00001636                 add     esp, 4
.text$mn:00001639                 push    eax             ; Size
.text$mn:0000163A                 mov     edx, [ebp+Str]
.text$mn:0000163D                 push    edx             ; Src
.text$mn:0000163E                 mov     ecx, [ebp+var_4]
.text$mn:00001641                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00001646                 mov     esp, ebp
.text$mn:00001648                 pop     ebp
.text$mn:00001649                 retn    4
.text$mn:00001649 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00001649
.text$mn:00001649 _text$mn        ends
.text$mn:00001649
.text$mn:0000164C ; ===========================================================================
.text$mn:0000164C
.text$mn:0000164C ; Segment type: Pure code
.text$mn:0000164C ; Segment permissions: Read/Execute
.text$mn:0000164C _text$mn        segment para public 'CODE' use32
.text$mn:0000164C                 assume cs:_text$mn
.text$mn:0000164C                 ;org 164Ch
.text$mn:0000164C ; COMDAT (pick any)
.text$mn:0000164C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000164C
.text$mn:0000164C ; =============== S U B R O U T I N E =======================================
.text$mn:0000164C
.text$mn:0000164C ; Attributes: bp-based frame
.text$mn:0000164C
.text$mn:0000164C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:0000164C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:0000164C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:0000164C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:0000164C
.text$mn:0000164C var_4           = dword ptr -4
.text$mn:0000164C Src             = dword ptr  8
.text$mn:0000164C Size            = dword ptr  0Ch
.text$mn:0000164C
.text$mn:0000164C                 push    ebp
.text$mn:0000164D                 mov     ebp, esp
.text$mn:0000164F                 push    ecx
.text$mn:00001650                 mov     [ebp+var_4], ecx
.text$mn:00001653                 cmp     [ebp+Size], 0
.text$mn:00001657                 jz      short loc_166F
.text$mn:00001659                 push    47Fh            ; unsigned int
.text$mn:0000165E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00001663                 mov     eax, [ebp+Src]
.text$mn:00001666                 push    eax             ; int
.text$mn:00001667                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000166C                 add     esp, 0Ch
.text$mn:0000166F
.text$mn:0000166F loc_166F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000166F                 mov     ecx, [ebp+Src]
.text$mn:00001672                 push    ecx
.text$mn:00001673                 mov     ecx, [ebp+var_4]
.text$mn:00001676                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000167B                 movzx   edx, al
.text$mn:0000167E                 test    edx, edx
.text$mn:00001680                 jz      short loc_16A2
.text$mn:00001682                 mov     eax, [ebp+Size]
.text$mn:00001685                 push    eax
.text$mn:00001686                 mov     ecx, [ebp+var_4]
.text$mn:00001689                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000168E                 mov     ecx, [ebp+Src]
.text$mn:00001691                 sub     ecx, eax
.text$mn:00001693                 push    ecx
.text$mn:00001694                 mov     edx, [ebp+var_4]
.text$mn:00001697                 push    edx
.text$mn:00001698                 mov     ecx, [ebp+var_4]
.text$mn:0000169B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:000016A0                 jmp     short loc_16DF
.text$mn:000016A2 ; ---------------------------------------------------------------------------
.text$mn:000016A2
.text$mn:000016A2 loc_16A2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:000016A2                 push    0
.text$mn:000016A4                 mov     eax, [ebp+Size]
.text$mn:000016A7                 push    eax
.text$mn:000016A8                 mov     ecx, [ebp+var_4]
.text$mn:000016AB                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000016B0                 movzx   ecx, al
.text$mn:000016B3                 test    ecx, ecx
.text$mn:000016B5                 jz      short loc_16DC
.text$mn:000016B7                 mov     edx, [ebp+Size]
.text$mn:000016BA                 push    edx             ; Size
.text$mn:000016BB                 mov     eax, [ebp+Src]
.text$mn:000016BE                 push    eax             ; Src
.text$mn:000016BF                 mov     ecx, [ebp+var_4]
.text$mn:000016C2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000016C7                 push    eax             ; Dst
.text$mn:000016C8                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000016CD                 add     esp, 0Ch
.text$mn:000016D0                 mov     ecx, [ebp+Size]
.text$mn:000016D3                 push    ecx
.text$mn:000016D4                 mov     ecx, [ebp+var_4]
.text$mn:000016D7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000016DC
.text$mn:000016DC loc_16DC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:000016DC                 mov     eax, [ebp+var_4]
.text$mn:000016DF
.text$mn:000016DF loc_16DF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:000016DF                 mov     esp, ebp
.text$mn:000016E1                 pop     ebp
.text$mn:000016E2                 retn    8
.text$mn:000016E2 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:000016E2
.text$mn:000016E2 ; ---------------------------------------------------------------------------
.text$mn:000016E5                 align 4
.text$mn:000016E5 _text$mn        ends
.text$mn:000016E5
.text$mn:000016E8 ; ===========================================================================
.text$mn:000016E8
.text$mn:000016E8 ; Segment type: Pure code
.text$mn:000016E8 ; Segment permissions: Read/Execute
.text$mn:000016E8 _text$mn        segment para public 'CODE' use32
.text$mn:000016E8                 assume cs:_text$mn
.text$mn:000016E8                 ;org 16E8h
.text$mn:000016E8 ; COMDAT (pick any)
.text$mn:000016E8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000016E8
.text$mn:000016E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016E8
.text$mn:000016E8 ; Attributes: bp-based frame
.text$mn:000016E8
.text$mn:000016E8 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:000016E8                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:000016E8 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:000016E8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:000016E8
.text$mn:000016E8 arg_0           = dword ptr  8
.text$mn:000016E8 arg_4           = dword ptr  0Ch
.text$mn:000016E8
.text$mn:000016E8                 push    ebp
.text$mn:000016E9                 mov     ebp, esp
.text$mn:000016EB                 mov     eax, [ebp+arg_0]
.text$mn:000016EE                 mov     ecx, [ebp+arg_4]
.text$mn:000016F1                 mov     dl, [ecx]
.text$mn:000016F3                 mov     [eax], dl
.text$mn:000016F5                 pop     ebp
.text$mn:000016F6                 retn
.text$mn:000016F6 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:000016F6
.text$mn:000016F6 ; ---------------------------------------------------------------------------
.text$mn:000016F7                 align 4
.text$mn:000016F7 _text$mn        ends
.text$mn:000016F7
.text$mn:000016F8 ; ===========================================================================
.text$mn:000016F8
.text$mn:000016F8 ; Segment type: Pure code
.text$mn:000016F8 ; Segment permissions: Read/Execute
.text$mn:000016F8 _text$mn        segment para public 'CODE' use32
.text$mn:000016F8                 assume cs:_text$mn
.text$mn:000016F8                 ;org 16F8h
.text$mn:000016F8 ; COMDAT (pick any)
.text$mn:000016F8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000016F8
.text$mn:000016F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000016F8
.text$mn:000016F8 ; Attributes: bp-based frame
.text$mn:000016F8
.text$mn:000016F8 ; public: char const * __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::c_str(void)const
.text$mn:000016F8                 public ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
.text$mn:000016F8 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ proc near
.text$mn:000016F8                                         ; CODE XREF: HandleUniversalDetector::GetCharset(void)+Dp
.text$mn:000016F8
.text$mn:000016F8 var_4           = dword ptr -4
.text$mn:000016F8
.text$mn:000016F8                 push    ebp
.text$mn:000016F9                 mov     ebp, esp
.text$mn:000016FB                 push    ecx
.text$mn:000016FC                 mov     [ebp+var_4], ecx
.text$mn:000016FF                 mov     ecx, [ebp+var_4]
.text$mn:00001702                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001707                 mov     esp, ebp
.text$mn:00001709                 pop     ebp
.text$mn:0000170A                 retn
.text$mn:0000170A ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ endp
.text$mn:0000170A
.text$mn:0000170A ; ---------------------------------------------------------------------------
.text$mn:0000170B                 align 4
.text$mn:0000170B _text$mn        ends
.text$mn:0000170B
.text$mn:0000170C ; ===========================================================================
.text$mn:0000170C
.text$mn:0000170C ; Segment type: Pure code
.text$mn:0000170C ; Segment permissions: Read/Execute
.text$mn:0000170C _text$mn        segment para public 'CODE' use32
.text$mn:0000170C                 assume cs:_text$mn
.text$mn:0000170C                 ;org 170Ch
.text$mn:0000170C ; COMDAT (pick any)
.text$mn:0000170C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:0000170C
.text$mn:0000170C ; =============== S U B R O U T I N E =======================================
.text$mn:0000170C
.text$mn:0000170C ; Attributes: bp-based frame
.text$mn:0000170C
.text$mn:0000170C ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:0000170C                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:0000170C ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000170C                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:0000170C
.text$mn:0000170C var_4           = dword ptr -4
.text$mn:0000170C
.text$mn:0000170C                 push    ebp
.text$mn:0000170D                 mov     ebp, esp
.text$mn:0000170F                 push    ecx
.text$mn:00001710                 mov     [ebp+var_4], ecx
.text$mn:00001713                 mov     eax, [ebp+var_4]
.text$mn:00001716                 mov     eax, [eax+4]
.text$mn:00001719                 mov     esp, ebp
.text$mn:0000171B                 pop     ebp
.text$mn:0000171C                 retn
.text$mn:0000171C ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000171C
.text$mn:0000171C ; ---------------------------------------------------------------------------
.text$mn:0000171D                 align 10h
.text$mn:0000171D _text$mn        ends
.text$mn:0000171D
.text$mn:00001720 ; ===========================================================================
.text$mn:00001720
.text$mn:00001720 ; Segment type: Pure code
.text$mn:00001720 ; Segment permissions: Read/Execute
.text$mn:00001720 _text$mn        segment para public 'CODE' use32
.text$mn:00001720                 assume cs:_text$mn
.text$mn:00001720                 ;org 1720h
.text$mn:00001720 ; COMDAT (pick any)
.text$mn:00001720                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001720
.text$mn:00001720 ; =============== S U B R O U T I N E =======================================
.text$mn:00001720
.text$mn:00001720 ; Attributes: bp-based frame
.text$mn:00001720
.text$mn:00001720 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00001720                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00001720 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00001720                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00001720                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00001720
.text$mn:00001720 var_4           = dword ptr -4
.text$mn:00001720
.text$mn:00001720                 push    ebp
.text$mn:00001721                 mov     ebp, esp
.text$mn:00001723                 push    ecx
.text$mn:00001724                 mov     [ebp+var_4], ecx
.text$mn:00001727                 mov     eax, [ebp+var_4]
.text$mn:0000172A                 mov     eax, [eax+4]
.text$mn:0000172D                 mov     esp, ebp
.text$mn:0000172F                 pop     ebp
.text$mn:00001730                 retn
.text$mn:00001730 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00001730
.text$mn:00001730 ; ---------------------------------------------------------------------------
.text$mn:00001731                 align 4
.text$mn:00001731 _text$mn        ends
.text$mn:00001731
.text$mn:00001734 ; ===========================================================================
.text$mn:00001734
.text$mn:00001734 ; Segment type: Pure code
.text$mn:00001734 ; Segment permissions: Read/Execute
.text$mn:00001734 _text$mn        segment para public 'CODE' use32
.text$mn:00001734                 assume cs:_text$mn
.text$mn:00001734                 ;org 1734h
.text$mn:00001734 ; COMDAT (pick any)
.text$mn:00001734                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001734
.text$mn:00001734 ; =============== S U B R O U T I N E =======================================
.text$mn:00001734
.text$mn:00001734 ; Attributes: bp-based frame
.text$mn:00001734
.text$mn:00001734 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00001734                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001734 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00001734                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00001734
.text$mn:00001734 var_4           = dword ptr -4
.text$mn:00001734 Dst             = dword ptr  8
.text$mn:00001734 Src             = dword ptr  0Ch
.text$mn:00001734 Size            = dword ptr  10h
.text$mn:00001734
.text$mn:00001734                 push    ebp
.text$mn:00001735                 mov     ebp, esp
.text$mn:00001737                 push    ecx
.text$mn:00001738                 cmp     [ebp+Size], 0
.text$mn:0000173C                 jnz     short loc_1746
.text$mn:0000173E                 mov     eax, [ebp+Dst]
.text$mn:00001741                 mov     [ebp+var_4], eax
.text$mn:00001744                 jmp     short loc_175D
.text$mn:00001746 ; ---------------------------------------------------------------------------
.text$mn:00001746
.text$mn:00001746 loc_1746:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00001746                 mov     ecx, [ebp+Size]
.text$mn:00001749                 push    ecx             ; Size
.text$mn:0000174A                 mov     edx, [ebp+Src]
.text$mn:0000174D                 push    edx             ; Src
.text$mn:0000174E                 mov     eax, [ebp+Dst]
.text$mn:00001751                 push    eax             ; Dst
.text$mn:00001752                 call    _memcpy
.text$mn:00001757                 add     esp, 0Ch
.text$mn:0000175A                 mov     [ebp+var_4], eax
.text$mn:0000175D
.text$mn:0000175D loc_175D:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:0000175D                 mov     eax, [ebp+var_4]
.text$mn:00001760                 mov     esp, ebp
.text$mn:00001762                 pop     ebp
.text$mn:00001763                 retn
.text$mn:00001763 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001763
.text$mn:00001763 _text$mn        ends
.text$mn:00001763
.text$mn:00001764 ; ===========================================================================
.text$mn:00001764
.text$mn:00001764 ; Segment type: Pure code
.text$mn:00001764 ; Segment permissions: Read/Execute
.text$mn:00001764 _text$mn        segment para public 'CODE' use32
.text$mn:00001764                 assume cs:_text$mn
.text$mn:00001764                 ;org 1764h
.text$mn:00001764 ; COMDAT (pick any)
.text$mn:00001764                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001764
.text$mn:00001764 ; =============== S U B R O U T I N E =======================================
.text$mn:00001764
.text$mn:00001764 ; Attributes: bp-based frame
.text$mn:00001764
.text$mn:00001764 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00001764                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00001764 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00001764                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00001764
.text$mn:00001764 var_4           = dword ptr -4
.text$mn:00001764 arg_0           = dword ptr  8
.text$mn:00001764 arg_4           = dword ptr  0Ch
.text$mn:00001764
.text$mn:00001764                 push    ebp
.text$mn:00001765                 mov     ebp, esp
.text$mn:00001767                 push    ecx
.text$mn:00001768                 mov     [ebp+var_4], ecx
.text$mn:0000176B                 mov     eax, [ebp+arg_4]
.text$mn:0000176E                 push    eax             ; int
.text$mn:0000176F                 mov     ecx, [ebp+arg_0]
.text$mn:00001772                 push    ecx             ; void *
.text$mn:00001773                 mov     ecx, [ebp+var_4]
.text$mn:00001776                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:0000177B                 mov     esp, ebp
.text$mn:0000177D                 pop     ebp
.text$mn:0000177E                 retn    8
.text$mn:0000177E ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000177E
.text$mn:0000177E ; ---------------------------------------------------------------------------
.text$mn:00001781                 align 4
.text$mn:00001781 _text$mn        ends
.text$mn:00001781
.text$mn:00001784 ; ===========================================================================
.text$mn:00001784
.text$mn:00001784 ; Segment type: Pure code
.text$mn:00001784 ; Segment permissions: Read/Execute
.text$mn:00001784 _text$mn        segment para public 'CODE' use32
.text$mn:00001784                 assume cs:_text$mn
.text$mn:00001784                 ;org 1784h
.text$mn:00001784 ; COMDAT (pick any)
.text$mn:00001784                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001784
.text$mn:00001784 ; =============== S U B R O U T I N E =======================================
.text$mn:00001784
.text$mn:00001784 ; Attributes: bp-based frame
.text$mn:00001784
.text$mn:00001784 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00001784                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00001784 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00001784                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00001784
.text$mn:00001784 var_4           = dword ptr -4
.text$mn:00001784 arg_0           = dword ptr  8
.text$mn:00001784
.text$mn:00001784                 push    ebp
.text$mn:00001785                 mov     ebp, esp
.text$mn:00001787                 push    ecx
.text$mn:00001788                 mov     [ebp+var_4], ecx
.text$mn:0000178B                 mov     eax, [ebp+arg_0]
.text$mn:0000178E                 push    eax             ; void *
.text$mn:0000178F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001794                 add     esp, 4
.text$mn:00001797                 mov     esp, ebp
.text$mn:00001799                 pop     ebp
.text$mn:0000179A                 retn    8
.text$mn:0000179A ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000179A
.text$mn:0000179A ; ---------------------------------------------------------------------------
.text$mn:0000179D                 align 10h
.text$mn:0000179D _text$mn        ends
.text$mn:0000179D
.text$mn:000017A0 ; ===========================================================================
.text$mn:000017A0
.text$mn:000017A0 ; Segment type: Pure code
.text$mn:000017A0 ; Segment permissions: Read/Execute
.text$mn:000017A0 _text$mn        segment para public 'CODE' use32
.text$mn:000017A0                 assume cs:_text$mn
.text$mn:000017A0                 ;org 17A0h
.text$mn:000017A0 ; COMDAT (pick any)
.text$mn:000017A0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000017A0
.text$mn:000017A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000017A0
.text$mn:000017A0 ; Attributes: bp-based frame
.text$mn:000017A0
.text$mn:000017A0 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:000017A0                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:000017A0 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:000017A0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:000017A0
.text$mn:000017A0 var_4           = dword ptr -4
.text$mn:000017A0 arg_0           = dword ptr  8
.text$mn:000017A0
.text$mn:000017A0                 push    ebp
.text$mn:000017A1                 mov     ebp, esp
.text$mn:000017A3                 push    ecx
.text$mn:000017A4                 mov     [ebp+var_4], ecx
.text$mn:000017A7                 mov     eax, [ebp+arg_0]
.text$mn:000017AA                 push    eax             ; void *
.text$mn:000017AB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000017B0                 add     esp, 4
.text$mn:000017B3                 mov     esp, ebp
.text$mn:000017B5                 pop     ebp
.text$mn:000017B6                 retn    8
.text$mn:000017B6 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:000017B6
.text$mn:000017B6 ; ---------------------------------------------------------------------------
.text$mn:000017B9                 align 4
.text$mn:000017B9 _text$mn        ends
.text$mn:000017B9
.text$mn:000017BC ; ===========================================================================
.text$mn:000017BC
.text$mn:000017BC ; Segment type: Pure code
.text$mn:000017BC ; Segment permissions: Read/Execute
.text$mn:000017BC _text$mn        segment para public 'CODE' use32
.text$mn:000017BC                 assume cs:_text$mn
.text$mn:000017BC                 ;org 17BCh
.text$mn:000017BC ; COMDAT (pick any)
.text$mn:000017BC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000017BC
.text$mn:000017BC ; =============== S U B R O U T I N E =======================================
.text$mn:000017BC
.text$mn:000017BC ; Attributes: bp-based frame
.text$mn:000017BC
.text$mn:000017BC ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:000017BC                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000017BC ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000017BC                                         ; DATA XREF: .rdata:00002214o
.text$mn:000017BC
.text$mn:000017BC var_4           = dword ptr -4
.text$mn:000017BC arg_0           = dword ptr  8
.text$mn:000017BC arg_4           = dword ptr  0Ch
.text$mn:000017BC
.text$mn:000017BC                 push    ebp
.text$mn:000017BD                 mov     ebp, esp
.text$mn:000017BF                 push    ecx
.text$mn:000017C0                 mov     [ebp+var_4], ecx
.text$mn:000017C3                 mov     eax, [ebp+arg_4]
.text$mn:000017C6                 push    eax             ; int
.text$mn:000017C7                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000017CC                 add     esp, 4
.text$mn:000017CF                 test    eax, eax
.text$mn:000017D1                 jz      short loc_17EC
.text$mn:000017D3                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:000017D8                 push    eax             ; struct std::error_category *
.text$mn:000017D9                 mov     ecx, [ebp+arg_4]
.text$mn:000017DC                 push    ecx             ; int
.text$mn:000017DD                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000017E0                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000017E5                 mov     eax, [ebp+arg_0]
.text$mn:000017E8                 jmp     short loc_1801
.text$mn:000017EA ; ---------------------------------------------------------------------------
.text$mn:000017EA                 jmp     short loc_1801
.text$mn:000017EC ; ---------------------------------------------------------------------------
.text$mn:000017EC
.text$mn:000017EC loc_17EC:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:000017EC                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000017F1                 push    eax             ; struct std::error_category *
.text$mn:000017F2                 mov     edx, [ebp+arg_4]
.text$mn:000017F5                 push    edx             ; int
.text$mn:000017F6                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000017F9                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000017FE                 mov     eax, [ebp+arg_0]
.text$mn:00001801
.text$mn:00001801 loc_1801:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00001801                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00001801                 mov     esp, ebp
.text$mn:00001803                 pop     ebp
.text$mn:00001804                 retn    8
.text$mn:00001804 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001804
.text$mn:00001804 ; ---------------------------------------------------------------------------
.text$mn:00001807                 align 4
.text$mn:00001807 _text$mn        ends
.text$mn:00001807
.text$mn:00001808 ; ===========================================================================
.text$mn:00001808
.text$mn:00001808 ; Segment type: Pure code
.text$mn:00001808 ; Segment permissions: Read/Execute
.text$mn:00001808 _text$mn        segment para public 'CODE' use32
.text$mn:00001808                 assume cs:_text$mn
.text$mn:00001808                 ;org 1808h
.text$mn:00001808 ; COMDAT (pick any)
.text$mn:00001808                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001808
.text$mn:00001808 ; =============== S U B R O U T I N E =======================================
.text$mn:00001808
.text$mn:00001808 ; Attributes: bp-based frame
.text$mn:00001808
.text$mn:00001808 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00001808                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00001808 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00001808                                         ; DATA XREF: .rdata:00002184o
.text$mn:00001808                                         ; .rdata:000021A0o ...
.text$mn:00001808
.text$mn:00001808 var_4           = dword ptr -4
.text$mn:00001808 arg_0           = dword ptr  8
.text$mn:00001808 arg_4           = dword ptr  0Ch
.text$mn:00001808
.text$mn:00001808                 push    ebp
.text$mn:00001809                 mov     ebp, esp
.text$mn:0000180B                 push    ecx
.text$mn:0000180C                 mov     [ebp+var_4], ecx
.text$mn:0000180F                 mov     eax, [ebp+var_4]
.text$mn:00001812                 push    eax             ; struct std::error_category *
.text$mn:00001813                 mov     ecx, [ebp+arg_4]
.text$mn:00001816                 push    ecx             ; int
.text$mn:00001817                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000181A                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000181F                 mov     eax, [ebp+arg_0]
.text$mn:00001822                 mov     esp, ebp
.text$mn:00001824                 pop     ebp
.text$mn:00001825                 retn    8
.text$mn:00001825 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00001825
.text$mn:00001825 _text$mn        ends
.text$mn:00001825
.text$mn:00001828 ; ===========================================================================
.text$mn:00001828
.text$mn:00001828 ; Segment type: Pure code
.text$mn:00001828 ; Segment permissions: Read/Execute
.text$mn:00001828 _text$mn        segment para public 'CODE' use32
.text$mn:00001828                 assume cs:_text$mn
.text$mn:00001828                 ;org 1828h
.text$mn:00001828 ; COMDAT (pick any)
.text$mn:00001828                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001828
.text$mn:00001828 ; =============== S U B R O U T I N E =======================================
.text$mn:00001828
.text$mn:00001828 ; Attributes: bp-based frame
.text$mn:00001828
.text$mn:00001828 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00001828                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00001828 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00001828                                         ; DATA XREF: .rdata:00002188o
.text$mn:00001828                                         ; .rdata:000021A4o ...
.text$mn:00001828
.text$mn:00001828 var_8           = dword ptr -8
.text$mn:00001828 var_4           = dword ptr -4
.text$mn:00001828 arg_0           = dword ptr  8
.text$mn:00001828 arg_4           = dword ptr  0Ch
.text$mn:00001828
.text$mn:00001828                 push    ebp
.text$mn:00001829                 mov     ebp, esp
.text$mn:0000182B                 sub     esp, 8
.text$mn:0000182E                 mov     [ebp+var_8], ecx
.text$mn:00001831                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001834                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00001839                 push    eax
.text$mn:0000183A                 mov     ecx, [ebp+var_8]
.text$mn:0000183D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001842                 movzx   eax, al
.text$mn:00001845                 test    eax, eax
.text$mn:00001847                 jz      short loc_185F
.text$mn:00001849                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000184C                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00001851                 cmp     eax, [ebp+arg_4]
.text$mn:00001854                 jnz     short loc_185F
.text$mn:00001856                 mov     [ebp+var_4], 1
.text$mn:0000185D                 jmp     short loc_1866
.text$mn:0000185F ; ---------------------------------------------------------------------------
.text$mn:0000185F
.text$mn:0000185F loc_185F:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000185F                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000185F                 mov     [ebp+var_4], 0
.text$mn:00001866
.text$mn:00001866 loc_1866:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00001866                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001869                 mov     esp, ebp
.text$mn:0000186B                 pop     ebp
.text$mn:0000186C                 retn    8
.text$mn:0000186C ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:0000186C
.text$mn:0000186C ; ---------------------------------------------------------------------------
.text$mn:0000186F                 align 10h
.text$mn:0000186F _text$mn        ends
.text$mn:0000186F
.text$mn:00001870 ; ===========================================================================
.text$mn:00001870
.text$mn:00001870 ; Segment type: Pure code
.text$mn:00001870 ; Segment permissions: Read/Execute
.text$mn:00001870 _text$mn        segment para public 'CODE' use32
.text$mn:00001870                 assume cs:_text$mn
.text$mn:00001870                 ;org 1870h
.text$mn:00001870 ; COMDAT (pick any)
.text$mn:00001870                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001870
.text$mn:00001870 ; =============== S U B R O U T I N E =======================================
.text$mn:00001870
.text$mn:00001870 ; Attributes: bp-based frame
.text$mn:00001870
.text$mn:00001870 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00001870                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00001870 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00001870                                         ; DATA XREF: .rdata:0000218Co
.text$mn:00001870                                         ; .rdata:000021A8o ...
.text$mn:00001870
.text$mn:00001870 var_C           = byte ptr -0Ch
.text$mn:00001870 var_4           = dword ptr -4
.text$mn:00001870 arg_0           = dword ptr  8
.text$mn:00001870 arg_4           = dword ptr  0Ch
.text$mn:00001870
.text$mn:00001870                 push    ebp
.text$mn:00001871                 mov     ebp, esp
.text$mn:00001873                 sub     esp, 0Ch
.text$mn:00001876                 mov     [ebp+var_4], ecx
.text$mn:00001879                 mov     eax, [ebp+arg_4]
.text$mn:0000187C                 push    eax             ; std::error_condition *
.text$mn:0000187D                 mov     ecx, [ebp+arg_0]
.text$mn:00001880                 push    ecx
.text$mn:00001881                 lea     edx, [ebp+var_C]
.text$mn:00001884                 push    edx
.text$mn:00001885                 mov     eax, [ebp+var_4]
.text$mn:00001888                 mov     edx, [eax]
.text$mn:0000188A                 mov     ecx, [ebp+var_4]
.text$mn:0000188D                 mov     eax, [edx+0Ch]
.text$mn:00001890                 call    eax
.text$mn:00001892                 mov     ecx, eax
.text$mn:00001894                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00001899                 mov     esp, ebp
.text$mn:0000189B                 pop     ebp
.text$mn:0000189C                 retn    8
.text$mn:0000189C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:0000189C
.text$mn:0000189C ; ---------------------------------------------------------------------------
.text$mn:0000189F                 align 10h
.text$mn:0000189F _text$mn        ends
.text$mn:0000189F
.text$mn:000018A0 ; ===========================================================================
.text$mn:000018A0
.text$mn:000018A0 ; Segment type: Pure code
.text$mn:000018A0 ; Segment permissions: Read/Execute
.text$mn:000018A0 _text$mn        segment para public 'CODE' use32
.text$mn:000018A0                 assume cs:_text$mn
.text$mn:000018A0                 ;org 18A0h
.text$mn:000018A0 ; COMDAT (pick any)
.text$mn:000018A0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000018A0
.text$mn:000018A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018A0
.text$mn:000018A0 ; Attributes: bp-based frame
.text$mn:000018A0
.text$mn:000018A0 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:000018A0                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:000018A0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000018A0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:000018A0
.text$mn:000018A0 var_4           = dword ptr -4
.text$mn:000018A0 arg_0           = dword ptr  8
.text$mn:000018A0
.text$mn:000018A0                 push    ebp
.text$mn:000018A1                 mov     ebp, esp
.text$mn:000018A3                 push    ecx
.text$mn:000018A4                 mov     [ebp+var_4], ecx
.text$mn:000018A7                 mov     eax, [ebp+var_4]
.text$mn:000018AA                 mov     ecx, [eax+14h]
.text$mn:000018AD                 cmp     ecx, [ebp+arg_0]
.text$mn:000018B0                 jnb     short loc_18BA
.text$mn:000018B2                 mov     ecx, [ebp+var_4]
.text$mn:000018B5                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000018BA
.text$mn:000018BA loc_18BA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:000018BA                 mov     edx, [ebp+arg_0]
.text$mn:000018BD                 push    edx
.text$mn:000018BE                 mov     ecx, [ebp+var_4]
.text$mn:000018C1                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000018C6                 mov     eax, [ebp+var_4]
.text$mn:000018C9                 mov     esp, ebp
.text$mn:000018CB                 pop     ebp
.text$mn:000018CC                 retn    4
.text$mn:000018CC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:000018CC
.text$mn:000018CC ; ---------------------------------------------------------------------------
.text$mn:000018CF                 align 10h
.text$mn:000018CF _text$mn        ends
.text$mn:000018CF
.text$mn:000018D0 ; ===========================================================================
.text$mn:000018D0
.text$mn:000018D0 ; Segment type: Pure code
.text$mn:000018D0 ; Segment permissions: Read/Execute
.text$mn:000018D0 _text$mn        segment para public 'CODE' use32
.text$mn:000018D0                 assume cs:_text$mn
.text$mn:000018D0                 ;org 18D0h
.text$mn:000018D0 ; COMDAT (pick any)
.text$mn:000018D0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000018D0
.text$mn:000018D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018D0
.text$mn:000018D0 ; Attributes: bp-based frame
.text$mn:000018D0
.text$mn:000018D0 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:000018D0                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:000018D0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:000018D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:000018D0
.text$mn:000018D0 var_C           = dword ptr -0Ch
.text$mn:000018D0 Dst             = dword ptr -8
.text$mn:000018D0 var_4           = dword ptr -4
.text$mn:000018D0 arg_0           = dword ptr  8
.text$mn:000018D0 arg_4           = dword ptr  0Ch
.text$mn:000018D0
.text$mn:000018D0                 push    ebp
.text$mn:000018D1                 mov     ebp, esp
.text$mn:000018D3                 sub     esp, 0Ch
.text$mn:000018D6                 mov     [ebp+var_4], ecx
.text$mn:000018D9                 mov     eax, [ebp+var_4]
.text$mn:000018DC                 mov     ecx, [eax+14h]
.text$mn:000018DF                 cmp     ecx, [ebp+arg_0]
.text$mn:000018E2                 jnb     short loc_18EC
.text$mn:000018E4                 mov     ecx, [ebp+var_4]
.text$mn:000018E7                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000018EC
.text$mn:000018EC loc_18EC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:000018EC                 mov     edx, [ebp+var_4]
.text$mn:000018EF                 mov     eax, [edx+14h]
.text$mn:000018F2                 sub     eax, [ebp+arg_0]
.text$mn:000018F5                 cmp     eax, [ebp+arg_4]
.text$mn:000018F8                 ja      short loc_1908
.text$mn:000018FA                 mov     ecx, [ebp+arg_0]
.text$mn:000018FD                 push    ecx
.text$mn:000018FE                 mov     ecx, [ebp+var_4]
.text$mn:00001901                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001906                 jmp     short loc_194E
.text$mn:00001908 ; ---------------------------------------------------------------------------
.text$mn:00001908
.text$mn:00001908 loc_1908:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00001908                 cmp     [ebp+arg_4], 0
.text$mn:0000190C                 jbe     short loc_194E
.text$mn:0000190E                 mov     ecx, [ebp+var_4]
.text$mn:00001911                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001916                 add     eax, [ebp+arg_0]
.text$mn:00001919                 mov     [ebp+Dst], eax
.text$mn:0000191C                 mov     edx, [ebp+var_4]
.text$mn:0000191F                 mov     eax, [edx+14h]
.text$mn:00001922                 sub     eax, [ebp+arg_4]
.text$mn:00001925                 mov     [ebp+var_C], eax
.text$mn:00001928                 mov     ecx, [ebp+var_C]
.text$mn:0000192B                 sub     ecx, [ebp+arg_0]
.text$mn:0000192E                 push    ecx             ; Size
.text$mn:0000192F                 mov     edx, [ebp+Dst]
.text$mn:00001932                 add     edx, [ebp+arg_4]
.text$mn:00001935                 push    edx             ; Src
.text$mn:00001936                 mov     eax, [ebp+Dst]
.text$mn:00001939                 push    eax             ; Dst
.text$mn:0000193A                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000193F                 add     esp, 0Ch
.text$mn:00001942                 mov     ecx, [ebp+var_C]
.text$mn:00001945                 push    ecx
.text$mn:00001946                 mov     ecx, [ebp+var_4]
.text$mn:00001949                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000194E
.text$mn:0000194E loc_194E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000194E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000194E                 mov     eax, [ebp+var_4]
.text$mn:00001951                 mov     esp, ebp
.text$mn:00001953                 pop     ebp
.text$mn:00001954                 retn    8
.text$mn:00001954 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00001954
.text$mn:00001954 ; ---------------------------------------------------------------------------
.text$mn:00001957                 align 4
.text$mn:00001957 _text$mn        ends
.text$mn:00001957
.text$mn:00001958 ; ===========================================================================
.text$mn:00001958
.text$mn:00001958 ; Segment type: Pure code
.text$mn:00001958 ; Segment permissions: Read/Execute
.text$mn:00001958 _text$mn        segment para public 'CODE' use32
.text$mn:00001958                 assume cs:_text$mn
.text$mn:00001958                 ;org 1958h
.text$mn:00001958 ; COMDAT (pick any)
.text$mn:00001958                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001958
.text$mn:00001958 ; =============== S U B R O U T I N E =======================================
.text$mn:00001958
.text$mn:00001958 ; Attributes: bp-based frame
.text$mn:00001958
.text$mn:00001958 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00001958                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00001958 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001958                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00001958                 push    ebp
.text$mn:00001959                 mov     ebp, esp
.text$mn:0000195B                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00001960                 pop     ebp
.text$mn:00001961                 retn
.text$mn:00001961 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001961
.text$mn:00001961 ; ---------------------------------------------------------------------------
.text$mn:00001962                 align 4
.text$mn:00001962 _text$mn        ends
.text$mn:00001962
.text$mn:00001964 ; ===========================================================================
.text$mn:00001964
.text$mn:00001964 ; Segment type: Pure code
.text$mn:00001964 ; Segment permissions: Read/Execute
.text$mn:00001964 _text$mn        segment para public 'CODE' use32
.text$mn:00001964                 assume cs:_text$mn
.text$mn:00001964                 ;org 1964h
.text$mn:00001964 ; COMDAT (pick any)
.text$mn:00001964                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001964
.text$mn:00001964 ; =============== S U B R O U T I N E =======================================
.text$mn:00001964
.text$mn:00001964 ; Attributes: bp-based frame
.text$mn:00001964
.text$mn:00001964 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00001964                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00001964 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00001964                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00001964
.text$mn:00001964 var_4           = dword ptr -4
.text$mn:00001964 Str             = dword ptr  8
.text$mn:00001964
.text$mn:00001964                 push    ebp
.text$mn:00001965                 mov     ebp, esp
.text$mn:00001967                 push    ecx
.text$mn:00001968                 mov     eax, [ebp+Str]
.text$mn:0000196B                 movsx   ecx, byte ptr [eax]
.text$mn:0000196E                 test    ecx, ecx
.text$mn:00001970                 jnz     short loc_197B
.text$mn:00001972                 mov     [ebp+var_4], 0
.text$mn:00001979                 jmp     short loc_198A
.text$mn:0000197B ; ---------------------------------------------------------------------------
.text$mn:0000197B
.text$mn:0000197B loc_197B:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000197B                 mov     edx, [ebp+Str]
.text$mn:0000197E                 push    edx             ; Str
.text$mn:0000197F                 call    _strlen
.text$mn:00001984                 add     esp, 4
.text$mn:00001987                 mov     [ebp+var_4], eax
.text$mn:0000198A
.text$mn:0000198A loc_198A:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000198A                 mov     eax, [ebp+var_4]
.text$mn:0000198D                 mov     esp, ebp
.text$mn:0000198F                 pop     ebp
.text$mn:00001990                 retn
.text$mn:00001990 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00001990
.text$mn:00001990 ; ---------------------------------------------------------------------------
.text$mn:00001991                 align 4
.text$mn:00001991 _text$mn        ends
.text$mn:00001991
.text$mn:00001994 ; ===========================================================================
.text$mn:00001994
.text$mn:00001994 ; Segment type: Pure code
.text$mn:00001994 ; Segment permissions: Read/Execute
.text$mn:00001994 _text$mn        segment para public 'CODE' use32
.text$mn:00001994                 assume cs:_text$mn
.text$mn:00001994                 ;org 1994h
.text$mn:00001994 ; COMDAT (pick any)
.text$mn:00001994                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001994
.text$mn:00001994 ; =============== S U B R O U T I N E =======================================
.text$mn:00001994
.text$mn:00001994 ; Attributes: bp-based frame
.text$mn:00001994
.text$mn:00001994 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00001994                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00001994 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00001994                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00001994
.text$mn:00001994 var_4           = dword ptr -4
.text$mn:00001994
.text$mn:00001994                 push    ebp
.text$mn:00001995                 mov     ebp, esp
.text$mn:00001997                 push    ecx
.text$mn:00001998                 mov     [ebp+var_4], ecx
.text$mn:0000199B                 mov     eax, [ebp+var_4]
.text$mn:0000199E                 push    eax
.text$mn:0000199F                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:000019A4                 add     esp, 4
.text$mn:000019A7                 mov     esp, ebp
.text$mn:000019A9                 pop     ebp
.text$mn:000019AA                 retn
.text$mn:000019AA ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:000019AA
.text$mn:000019AA ; ---------------------------------------------------------------------------
.text$mn:000019AB                 align 4
.text$mn:000019AB _text$mn        ends
.text$mn:000019AB
.text$mn:000019AC ; ===========================================================================
.text$mn:000019AC
.text$mn:000019AC ; Segment type: Pure code
.text$mn:000019AC ; Segment permissions: Read/Execute
.text$mn:000019AC _text$mn        segment para public 'CODE' use32
.text$mn:000019AC                 assume cs:_text$mn
.text$mn:000019AC                 ;org 19ACh
.text$mn:000019AC ; COMDAT (pick any)
.text$mn:000019AC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000019AC
.text$mn:000019AC ; =============== S U B R O U T I N E =======================================
.text$mn:000019AC
.text$mn:000019AC ; Attributes: bp-based frame
.text$mn:000019AC
.text$mn:000019AC ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:000019AC                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:000019AC ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:000019AC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:000019AC
.text$mn:000019AC var_4           = dword ptr -4
.text$mn:000019AC
.text$mn:000019AC                 push    ebp
.text$mn:000019AD                 mov     ebp, esp
.text$mn:000019AF                 push    ecx
.text$mn:000019B0                 mov     [ebp+var_4], ecx
.text$mn:000019B3                 or      eax, 0FFFFFFFFh
.text$mn:000019B6                 mov     esp, ebp
.text$mn:000019B8                 pop     ebp
.text$mn:000019B9                 retn
.text$mn:000019B9 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:000019B9
.text$mn:000019B9 ; ---------------------------------------------------------------------------
.text$mn:000019BA                 align 4
.text$mn:000019BA _text$mn        ends
.text$mn:000019BA
.text$mn:000019BC ; ===========================================================================
.text$mn:000019BC
.text$mn:000019BC ; Segment type: Pure code
.text$mn:000019BC ; Segment permissions: Read/Execute
.text$mn:000019BC _text$mn        segment para public 'CODE' use32
.text$mn:000019BC                 assume cs:_text$mn
.text$mn:000019BC                 ;org 19BCh
.text$mn:000019BC ; COMDAT (pick any)
.text$mn:000019BC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000019BC
.text$mn:000019BC ; =============== S U B R O U T I N E =======================================
.text$mn:000019BC
.text$mn:000019BC ; Attributes: bp-based frame
.text$mn:000019BC
.text$mn:000019BC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:000019BC                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:000019BC ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:000019BC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:000019BC
.text$mn:000019BC arg_0           = dword ptr  8
.text$mn:000019BC
.text$mn:000019BC                 push    ebp
.text$mn:000019BD                 mov     ebp, esp
.text$mn:000019BF                 mov     ecx, [ebp+arg_0]
.text$mn:000019C2                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000019C7                 pop     ebp
.text$mn:000019C8                 retn
.text$mn:000019C8 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000019C8
.text$mn:000019C8 ; ---------------------------------------------------------------------------
.text$mn:000019C9                 align 4
.text$mn:000019C9 _text$mn        ends
.text$mn:000019C9
.text$mn:000019CC ; ===========================================================================
.text$mn:000019CC
.text$mn:000019CC ; Segment type: Pure code
.text$mn:000019CC ; Segment permissions: Read/Execute
.text$mn:000019CC _text$mn        segment para public 'CODE' use32
.text$mn:000019CC                 assume cs:_text$mn
.text$mn:000019CC                 ;org 19CCh
.text$mn:000019CC ; COMDAT (pick any)
.text$mn:000019CC                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:000019CC
.text$mn:000019CC ; =============== S U B R O U T I N E =======================================
.text$mn:000019CC
.text$mn:000019CC ; Attributes: bp-based frame
.text$mn:000019CC
.text$mn:000019CC ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000019CC                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000019CC ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000019CC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000019CC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000019CC
.text$mn:000019CC var_10          = dword ptr -10h
.text$mn:000019CC var_C           = dword ptr -0Ch
.text$mn:000019CC var_8           = dword ptr -8
.text$mn:000019CC var_1           = byte ptr -1
.text$mn:000019CC
.text$mn:000019CC                 push    ebp
.text$mn:000019CD                 mov     ebp, esp
.text$mn:000019CF                 sub     esp, 10h
.text$mn:000019D2                 mov     [ebp+var_10], ecx
.text$mn:000019D5                 lea     eax, [ebp+var_1]
.text$mn:000019D8                 push    eax
.text$mn:000019D9                 mov     ecx, [ebp+var_10]
.text$mn:000019DC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000019E1                 mov     ecx, eax
.text$mn:000019E3                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:000019E8                 mov     [ebp+var_8], eax
.text$mn:000019EB                 cmp     [ebp+var_8], 1
.text$mn:000019EF                 ja      short loc_19FA
.text$mn:000019F1                 mov     [ebp+var_C], 1
.text$mn:000019F8                 jmp     short loc_1A03
.text$mn:000019FA ; ---------------------------------------------------------------------------
.text$mn:000019FA
.text$mn:000019FA loc_19FA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:000019FA                 mov     ecx, [ebp+var_8]
.text$mn:000019FD                 sub     ecx, 1
.text$mn:00001A00                 mov     [ebp+var_C], ecx
.text$mn:00001A03
.text$mn:00001A03 loc_1A03:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00001A03                 mov     eax, [ebp+var_C]
.text$mn:00001A06                 mov     esp, ebp
.text$mn:00001A08                 pop     ebp
.text$mn:00001A09                 retn
.text$mn:00001A09 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001A09
.text$mn:00001A09 ; ---------------------------------------------------------------------------
.text$mn:00001A0A                 align 4
.text$mn:00001A0A _text$mn        ends
.text$mn:00001A0A
.text$mn:00001A0C ; ===========================================================================
.text$mn:00001A0C
.text$mn:00001A0C ; Segment type: Pure code
.text$mn:00001A0C ; Segment permissions: Read/Execute
.text$mn:00001A0C _text$mn        segment para public 'CODE' use32
.text$mn:00001A0C                 assume cs:_text$mn
.text$mn:00001A0C                 ;org 1A0Ch
.text$mn:00001A0C ; COMDAT (pick any)
.text$mn:00001A0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001A0C
.text$mn:00001A0C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A0C
.text$mn:00001A0C ; Attributes: bp-based frame
.text$mn:00001A0C
.text$mn:00001A0C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00001A0C                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001A0C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001A0C                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00001A0C                                         ; DATA XREF: .rdata:0000219Co
.text$mn:00001A0C
.text$mn:00001A0C var_1C          = dword ptr -1Ch
.text$mn:00001A0C var_18          = dword ptr -18h
.text$mn:00001A0C Str             = dword ptr -14h
.text$mn:00001A0C var_10          = dword ptr -10h
.text$mn:00001A0C var_C           = dword ptr -0Ch
.text$mn:00001A0C var_4           = dword ptr -4
.text$mn:00001A0C arg_0           = dword ptr  8
.text$mn:00001A0C arg_4           = dword ptr  0Ch
.text$mn:00001A0C
.text$mn:00001A0C                 push    ebp
.text$mn:00001A0D                 mov     ebp, esp
.text$mn:00001A0F                 push    0FFFFFFFFh
.text$mn:00001A11                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001A16                 mov     eax, large fs:0
.text$mn:00001A1C                 push    eax
.text$mn:00001A1D                 sub     esp, 10h
.text$mn:00001A20                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A25                 xor     eax, ebp
.text$mn:00001A27                 push    eax
.text$mn:00001A28                 lea     eax, [ebp+var_C]
.text$mn:00001A2B                 mov     large fs:0, eax
.text$mn:00001A31                 mov     [ebp+var_1C], ecx
.text$mn:00001A34                 mov     [ebp+var_18], 0
.text$mn:00001A3B                 mov     eax, [ebp+arg_4]
.text$mn:00001A3E                 push    eax             ; int
.text$mn:00001A3F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00001A44                 add     esp, 4
.text$mn:00001A47                 mov     [ebp+var_10], eax
.text$mn:00001A4A                 cmp     [ebp+var_10], 0
.text$mn:00001A4E                 jz      short loc_1A58
.text$mn:00001A50                 mov     ecx, [ebp+var_10]
.text$mn:00001A53                 mov     [ebp+Str], ecx
.text$mn:00001A56                 jmp     short loc_1A5F
.text$mn:00001A58 ; ---------------------------------------------------------------------------
.text$mn:00001A58
.text$mn:00001A58 loc_1A58:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00001A58                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00001A5F
.text$mn:00001A5F loc_1A5F:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00001A5F                 mov     edx, [ebp+Str]
.text$mn:00001A62                 push    edx             ; Str
.text$mn:00001A63                 mov     ecx, [ebp+arg_0]
.text$mn:00001A66                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001A6B                 mov     [ebp+var_4], 0
.text$mn:00001A72                 mov     eax, [ebp+var_18]
.text$mn:00001A75                 or      eax, 1
.text$mn:00001A78                 mov     [ebp+var_18], eax
.text$mn:00001A7B                 mov     eax, [ebp+arg_0]
.text$mn:00001A7E                 mov     ecx, [ebp+var_C]
.text$mn:00001A81                 mov     large fs:0, ecx
.text$mn:00001A88                 pop     ecx
.text$mn:00001A89                 mov     esp, ebp
.text$mn:00001A8B                 pop     ebp
.text$mn:00001A8C                 retn    8
.text$mn:00001A8C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001A8C
.text$mn:00001A8C ; ---------------------------------------------------------------------------
.text$mn:00001A8F                 align 10h
.text$mn:00001A8F _text$mn        ends
.text$mn:00001A8F
.text$x:00001A90 ; ===========================================================================
.text$x:00001A90
.text$x:00001A90 ; Segment type: Pure code
.text$x:00001A90 ; Segment permissions: Read/Execute
.text$x:00001A90 _text$x         segment para public 'CODE' use32
.text$x:00001A90                 assume cs:_text$x
.text$x:00001A90                 ;org 1A90h
.text$x:00001A90 ; COMDAT (pick associative to section at 1A0C)
.text$x:00001A90                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001A90
.text$x:00001A90 ; =============== S U B R O U T I N E =======================================
.text$x:00001A90
.text$x:00001A90
.text$x:00001A90 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001A90                                         ; DATA XREF: .xdata$x:00001F50o
.text$x:00001A90                 mov     eax, [ebp-18h]
.text$x:00001A93                 and     eax, 1
.text$x:00001A96                 jz      $LN6
.text$x:00001A9C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001AA0                 mov     ecx, [ebp+8]
.text$x:00001AA3                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001AA8 ; ---------------------------------------------------------------------------
.text$x:00001AA8
.text$x:00001AA8 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001AA8                 retn
.text$x:00001AA8 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001AA8
.text$x:00001AA9
.text$x:00001AA9 ; =============== S U B R O U T I N E =======================================
.text$x:00001AA9
.text$x:00001AA9
.text$x:00001AA9 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001AA9                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00001AA9
.text$x:00001AA9 arg_4           = dword ptr  8
.text$x:00001AA9
.text$x:00001AA9                 mov     edx, [esp+arg_4]
.text$x:00001AAD                 lea     eax, [edx+0Ch]
.text$x:00001AB0                 mov     ecx, [edx-14h]
.text$x:00001AB3                 xor     ecx, eax
.text$x:00001AB5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001ABA                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001ABF                 jmp     ___CxxFrameHandler3
.text$x:00001ABF __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001ABF
.text$x:00001ABF _text$x         ends
.text$x:00001ABF
.text$mn:00001AC4 ; ===========================================================================
.text$mn:00001AC4
.text$mn:00001AC4 ; Segment type: Pure code
.text$mn:00001AC4 ; Segment permissions: Read/Execute
.text$mn:00001AC4 _text$mn        segment para public 'CODE' use32
.text$mn:00001AC4                 assume cs:_text$mn
.text$mn:00001AC4                 ;org 1AC4h
.text$mn:00001AC4 ; COMDAT (pick any)
.text$mn:00001AC4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001AC4
.text$mn:00001AC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AC4
.text$mn:00001AC4 ; Attributes: bp-based frame
.text$mn:00001AC4
.text$mn:00001AC4 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00001AC4                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001AC4 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001AC4                                         ; DATA XREF: .rdata:000021D0o
.text$mn:00001AC4
.text$mn:00001AC4 var_14          = dword ptr -14h
.text$mn:00001AC4 var_10          = dword ptr -10h
.text$mn:00001AC4 var_C           = dword ptr -0Ch
.text$mn:00001AC4 var_4           = dword ptr -4
.text$mn:00001AC4 arg_0           = dword ptr  8
.text$mn:00001AC4 arg_4           = dword ptr  0Ch
.text$mn:00001AC4
.text$mn:00001AC4                 push    ebp
.text$mn:00001AC5                 mov     ebp, esp
.text$mn:00001AC7                 push    0FFFFFFFFh
.text$mn:00001AC9                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001ACE                 mov     eax, large fs:0
.text$mn:00001AD4                 push    eax
.text$mn:00001AD5                 sub     esp, 8
.text$mn:00001AD8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001ADD                 xor     eax, ebp
.text$mn:00001ADF                 push    eax
.text$mn:00001AE0                 lea     eax, [ebp+var_C]
.text$mn:00001AE3                 mov     large fs:0, eax
.text$mn:00001AE9                 mov     [ebp+var_14], ecx
.text$mn:00001AEC                 mov     [ebp+var_10], 0
.text$mn:00001AF3                 cmp     [ebp+arg_4], 1
.text$mn:00001AF7                 jnz     short loc_1B1D
.text$mn:00001AF9                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00001AFE                 mov     ecx, [ebp+arg_0]
.text$mn:00001B01                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001B06                 mov     [ebp+var_4], 0
.text$mn:00001B0D                 mov     eax, [ebp+var_10]
.text$mn:00001B10                 or      eax, 1
.text$mn:00001B13                 mov     [ebp+var_10], eax
.text$mn:00001B16                 mov     eax, [ebp+arg_0]
.text$mn:00001B19                 jmp     short loc_1B40
.text$mn:00001B1B ; ---------------------------------------------------------------------------
.text$mn:00001B1B                 jmp     short loc_1B40
.text$mn:00001B1D ; ---------------------------------------------------------------------------
.text$mn:00001B1D
.text$mn:00001B1D loc_1B1D:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00001B1D                 mov     ecx, [ebp+arg_4]
.text$mn:00001B20                 push    ecx
.text$mn:00001B21                 mov     edx, [ebp+arg_0]
.text$mn:00001B24                 push    edx
.text$mn:00001B25                 mov     ecx, [ebp+var_14]
.text$mn:00001B28                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00001B2D                 mov     [ebp+var_4], 0
.text$mn:00001B34                 mov     eax, [ebp+var_10]
.text$mn:00001B37                 or      eax, 1
.text$mn:00001B3A                 mov     [ebp+var_10], eax
.text$mn:00001B3D                 mov     eax, [ebp+arg_0]
.text$mn:00001B40
.text$mn:00001B40 loc_1B40:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00001B40                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00001B40                 mov     ecx, [ebp+var_C]
.text$mn:00001B43                 mov     large fs:0, ecx
.text$mn:00001B4A                 pop     ecx
.text$mn:00001B4B                 mov     esp, ebp
.text$mn:00001B4D                 pop     ebp
.text$mn:00001B4E                 retn    8
.text$mn:00001B4E ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001B4E
.text$mn:00001B4E ; ---------------------------------------------------------------------------
.text$mn:00001B51                 align 4
.text$mn:00001B51 _text$mn        ends
.text$mn:00001B51
.text$x:00001B54 ; ===========================================================================
.text$x:00001B54
.text$x:00001B54 ; Segment type: Pure code
.text$x:00001B54 ; Segment permissions: Read/Execute
.text$x:00001B54 _text$x         segment para public 'CODE' use32
.text$x:00001B54                 assume cs:_text$x
.text$x:00001B54                 ;org 1B54h
.text$x:00001B54 ; COMDAT (pick associative to section at 1AC4)
.text$x:00001B54                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001B54
.text$x:00001B54 ; =============== S U B R O U T I N E =======================================
.text$x:00001B54
.text$x:00001B54
.text$x:00001B54 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001B54                                         ; DATA XREF: .xdata$x:00001FD4o
.text$x:00001B54                 mov     eax, [ebp-10h]
.text$x:00001B57                 and     eax, 1
.text$x:00001B5A                 jz      $LN6_0
.text$x:00001B60                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00001B64                 mov     ecx, [ebp+8]
.text$x:00001B67                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001B6C ; ---------------------------------------------------------------------------
.text$x:00001B6C
.text$x:00001B6C $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001B6C                 retn
.text$x:00001B6C __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001B6C
.text$x:00001B6D
.text$x:00001B6D ; =============== S U B R O U T I N E =======================================
.text$x:00001B6D
.text$x:00001B6D
.text$x:00001B6D __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001B6D                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00001B6D
.text$x:00001B6D arg_4           = dword ptr  8
.text$x:00001B6D
.text$x:00001B6D                 mov     edx, [esp+arg_4]
.text$x:00001B71                 lea     eax, [edx+0Ch]
.text$x:00001B74                 mov     ecx, [edx-0Ch]
.text$x:00001B77                 xor     ecx, eax
.text$x:00001B79                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B7E                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001B83                 jmp     ___CxxFrameHandler3
.text$x:00001B83 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001B83
.text$x:00001B83 _text$x         ends
.text$x:00001B83
.text$mn:00001B88 ; ===========================================================================
.text$mn:00001B88
.text$mn:00001B88 ; Segment type: Pure code
.text$mn:00001B88 ; Segment permissions: Read/Execute
.text$mn:00001B88 _text$mn        segment para public 'CODE' use32
.text$mn:00001B88                 assume cs:_text$mn
.text$mn:00001B88                 ;org 1B88h
.text$mn:00001B88 ; COMDAT (pick any)
.text$mn:00001B88                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001B88
.text$mn:00001B88 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B88
.text$mn:00001B88 ; Attributes: bp-based frame
.text$mn:00001B88
.text$mn:00001B88 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00001B88                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001B88 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00001B88                                         ; DATA XREF: .rdata:00002210o
.text$mn:00001B88
.text$mn:00001B88 var_1C          = dword ptr -1Ch
.text$mn:00001B88 var_18          = dword ptr -18h
.text$mn:00001B88 Str             = dword ptr -14h
.text$mn:00001B88 var_10          = dword ptr -10h
.text$mn:00001B88 var_C           = dword ptr -0Ch
.text$mn:00001B88 var_4           = dword ptr -4
.text$mn:00001B88 arg_0           = dword ptr  8
.text$mn:00001B88 arg_4           = dword ptr  0Ch
.text$mn:00001B88
.text$mn:00001B88                 push    ebp
.text$mn:00001B89                 mov     ebp, esp
.text$mn:00001B8B                 push    0FFFFFFFFh
.text$mn:00001B8D                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00001B92                 mov     eax, large fs:0
.text$mn:00001B98                 push    eax
.text$mn:00001B99                 sub     esp, 10h
.text$mn:00001B9C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001BA1                 xor     eax, ebp
.text$mn:00001BA3                 push    eax
.text$mn:00001BA4                 lea     eax, [ebp+var_C]
.text$mn:00001BA7                 mov     large fs:0, eax
.text$mn:00001BAD                 mov     [ebp+var_1C], ecx
.text$mn:00001BB0                 mov     [ebp+var_18], 0
.text$mn:00001BB7                 mov     eax, [ebp+arg_4]
.text$mn:00001BBA                 push    eax             ; int
.text$mn:00001BBB                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00001BC0                 add     esp, 4
.text$mn:00001BC3                 mov     [ebp+var_10], eax
.text$mn:00001BC6                 cmp     [ebp+var_10], 0
.text$mn:00001BCA                 jz      short loc_1BD4
.text$mn:00001BCC                 mov     ecx, [ebp+var_10]
.text$mn:00001BCF                 mov     [ebp+Str], ecx
.text$mn:00001BD2                 jmp     short loc_1BDB
.text$mn:00001BD4 ; ---------------------------------------------------------------------------
.text$mn:00001BD4
.text$mn:00001BD4 loc_1BD4:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00001BD4                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00001BDB
.text$mn:00001BDB loc_1BDB:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00001BDB                 mov     edx, [ebp+Str]
.text$mn:00001BDE                 push    edx             ; Str
.text$mn:00001BDF                 mov     ecx, [ebp+arg_0]
.text$mn:00001BE2                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00001BE7                 mov     [ebp+var_4], 0
.text$mn:00001BEE                 mov     eax, [ebp+var_18]
.text$mn:00001BF1                 or      eax, 1
.text$mn:00001BF4                 mov     [ebp+var_18], eax
.text$mn:00001BF7                 mov     eax, [ebp+arg_0]
.text$mn:00001BFA                 mov     ecx, [ebp+var_C]
.text$mn:00001BFD                 mov     large fs:0, ecx
.text$mn:00001C04                 pop     ecx
.text$mn:00001C05                 mov     esp, ebp
.text$mn:00001C07                 pop     ebp
.text$mn:00001C08                 retn    8
.text$mn:00001C08 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00001C08
.text$mn:00001C08 ; ---------------------------------------------------------------------------
.text$mn:00001C0B                 align 4
.text$mn:00001C0B _text$mn        ends
.text$mn:00001C0B
.text$x:00001C0C ; ===========================================================================
.text$x:00001C0C
.text$x:00001C0C ; Segment type: Pure code
.text$x:00001C0C ; Segment permissions: Read/Execute
.text$x:00001C0C _text$x         segment para public 'CODE' use32
.text$x:00001C0C                 assume cs:_text$x
.text$x:00001C0C                 ;org 1C0Ch
.text$x:00001C0C ; COMDAT (pick associative to section at 1B88)
.text$x:00001C0C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$x:00001C0C
.text$x:00001C0C ; =============== S U B R O U T I N E =======================================
.text$x:00001C0C
.text$x:00001C0C
.text$x:00001C0C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00001C0C                                         ; DATA XREF: .xdata$x:00002058o
.text$x:00001C0C                 mov     eax, [ebp-18h]
.text$x:00001C0F                 and     eax, 1
.text$x:00001C12                 jz      $LN6_1
.text$x:00001C18                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00001C1C                 mov     ecx, [ebp+8]
.text$x:00001C1F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00001C24 ; ---------------------------------------------------------------------------
.text$x:00001C24
.text$x:00001C24 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00001C24                 retn
.text$x:00001C24 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00001C24
.text$x:00001C25
.text$x:00001C25 ; =============== S U B R O U T I N E =======================================
.text$x:00001C25
.text$x:00001C25
.text$x:00001C25 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00001C25                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00001C25
.text$x:00001C25 arg_4           = dword ptr  8
.text$x:00001C25
.text$x:00001C25                 mov     edx, [esp+arg_4]
.text$x:00001C29                 lea     eax, [edx+0Ch]
.text$x:00001C2C                 mov     ecx, [edx-14h]
.text$x:00001C2F                 xor     ecx, eax
.text$x:00001C31                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C36                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00001C3B                 jmp     ___CxxFrameHandler3
.text$x:00001C3B __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00001C3B
.text$x:00001C3B _text$x         ends
.text$x:00001C3B
.text$mn:00001C40 ; ===========================================================================
.text$mn:00001C40
.text$mn:00001C40 ; Segment type: Pure code
.text$mn:00001C40 ; Segment permissions: Read/Execute
.text$mn:00001C40 _text$mn        segment para public 'CODE' use32
.text$mn:00001C40                 assume cs:_text$mn
.text$mn:00001C40                 ;org 1C40h
.text$mn:00001C40 ; COMDAT (pick any)
.text$mn:00001C40                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001C40
.text$mn:00001C40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C40
.text$mn:00001C40 ; Attributes: bp-based frame
.text$mn:00001C40
.text$mn:00001C40 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00001C40                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00001C40 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00001C40                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00001C40
.text$mn:00001C40 var_4           = dword ptr -4
.text$mn:00001C40 Dst             = dword ptr  8
.text$mn:00001C40 Src             = dword ptr  0Ch
.text$mn:00001C40 Size            = dword ptr  10h
.text$mn:00001C40
.text$mn:00001C40                 push    ebp
.text$mn:00001C41                 mov     ebp, esp
.text$mn:00001C43                 push    ecx
.text$mn:00001C44                 cmp     [ebp+Size], 0
.text$mn:00001C48                 jnz     short loc_1C52
.text$mn:00001C4A                 mov     eax, [ebp+Dst]
.text$mn:00001C4D                 mov     [ebp+var_4], eax
.text$mn:00001C50                 jmp     short loc_1C69
.text$mn:00001C52 ; ---------------------------------------------------------------------------
.text$mn:00001C52
.text$mn:00001C52 loc_1C52:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00001C52                 mov     ecx, [ebp+Size]
.text$mn:00001C55                 push    ecx             ; Size
.text$mn:00001C56                 mov     edx, [ebp+Src]
.text$mn:00001C59                 push    edx             ; Src
.text$mn:00001C5A                 mov     eax, [ebp+Dst]
.text$mn:00001C5D                 push    eax             ; Dst
.text$mn:00001C5E                 call    _memmove
.text$mn:00001C63                 add     esp, 0Ch
.text$mn:00001C66                 mov     [ebp+var_4], eax
.text$mn:00001C69
.text$mn:00001C69 loc_1C69:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00001C69                 mov     eax, [ebp+var_4]
.text$mn:00001C6C                 mov     esp, ebp
.text$mn:00001C6E                 pop     ebp
.text$mn:00001C6F                 retn
.text$mn:00001C6F ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00001C6F
.text$mn:00001C6F _text$mn        ends
.text$mn:00001C6F
.text$mn:00001C70 ; ===========================================================================
.text$mn:00001C70
.text$mn:00001C70 ; Segment type: Pure code
.text$mn:00001C70 ; Segment permissions: Read/Execute
.text$mn:00001C70 _text$mn        segment para public 'CODE' use32
.text$mn:00001C70                 assume cs:_text$mn
.text$mn:00001C70                 ;org 1C70h
.text$mn:00001C70 ; COMDAT (pick any)
.text$mn:00001C70                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001C70
.text$mn:00001C70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C70
.text$mn:00001C70 ; Attributes: bp-based frame
.text$mn:00001C70
.text$mn:00001C70 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00001C70                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00001C70 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00001C70                                         ; DATA XREF: .rdata:00002198o
.text$mn:00001C70
.text$mn:00001C70 var_4           = dword ptr -4
.text$mn:00001C70
.text$mn:00001C70                 push    ebp
.text$mn:00001C71                 mov     ebp, esp
.text$mn:00001C73                 push    ecx
.text$mn:00001C74                 mov     [ebp+var_4], ecx
.text$mn:00001C77                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00001C7C                 mov     esp, ebp
.text$mn:00001C7E                 pop     ebp
.text$mn:00001C7F                 retn
.text$mn:00001C7F ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00001C7F
.text$mn:00001C7F _text$mn        ends
.text$mn:00001C7F
.text$mn:00001C80 ; ===========================================================================
.text$mn:00001C80
.text$mn:00001C80 ; Segment type: Pure code
.text$mn:00001C80 ; Segment permissions: Read/Execute
.text$mn:00001C80 _text$mn        segment para public 'CODE' use32
.text$mn:00001C80                 assume cs:_text$mn
.text$mn:00001C80                 ;org 1C80h
.text$mn:00001C80 ; COMDAT (pick any)
.text$mn:00001C80                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001C80
.text$mn:00001C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C80
.text$mn:00001C80 ; Attributes: bp-based frame
.text$mn:00001C80
.text$mn:00001C80 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00001C80                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00001C80 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00001C80                                         ; DATA XREF: .rdata:000021CCo
.text$mn:00001C80
.text$mn:00001C80 var_4           = dword ptr -4
.text$mn:00001C80
.text$mn:00001C80                 push    ebp
.text$mn:00001C81                 mov     ebp, esp
.text$mn:00001C83                 push    ecx
.text$mn:00001C84                 mov     [ebp+var_4], ecx
.text$mn:00001C87                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00001C8C                 mov     esp, ebp
.text$mn:00001C8E                 pop     ebp
.text$mn:00001C8F                 retn
.text$mn:00001C8F ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00001C8F
.text$mn:00001C8F _text$mn        ends
.text$mn:00001C8F
.text$mn:00001C90 ; ===========================================================================
.text$mn:00001C90
.text$mn:00001C90 ; Segment type: Pure code
.text$mn:00001C90 ; Segment permissions: Read/Execute
.text$mn:00001C90 _text$mn        segment para public 'CODE' use32
.text$mn:00001C90                 assume cs:_text$mn
.text$mn:00001C90                 ;org 1C90h
.text$mn:00001C90 ; COMDAT (pick any)
.text$mn:00001C90                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001C90
.text$mn:00001C90 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C90
.text$mn:00001C90 ; Attributes: bp-based frame
.text$mn:00001C90
.text$mn:00001C90 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00001C90                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00001C90 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00001C90                                         ; DATA XREF: .rdata:0000220Co
.text$mn:00001C90
.text$mn:00001C90 var_4           = dword ptr -4
.text$mn:00001C90
.text$mn:00001C90                 push    ebp
.text$mn:00001C91                 mov     ebp, esp
.text$mn:00001C93                 push    ecx
.text$mn:00001C94                 mov     [ebp+var_4], ecx
.text$mn:00001C97                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00001C9C                 mov     esp, ebp
.text$mn:00001C9E                 pop     ebp
.text$mn:00001C9F                 retn
.text$mn:00001C9F ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00001C9F
.text$mn:00001C9F _text$mn        ends
.text$mn:00001C9F
.text$mn:00001CA0 ; ===========================================================================
.text$mn:00001CA0
.text$mn:00001CA0 ; Segment type: Pure code
.text$mn:00001CA0 ; Segment permissions: Read/Execute
.text$mn:00001CA0 _text$mn        segment para public 'CODE' use32
.text$mn:00001CA0                 assume cs:_text$mn
.text$mn:00001CA0                 ;org 1CA0h
.text$mn:00001CA0 ; COMDAT (pick any)
.text$mn:00001CA0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001CA0
.text$mn:00001CA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CA0
.text$mn:00001CA0 ; Attributes: bp-based frame
.text$mn:00001CA0
.text$mn:00001CA0 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00001CA0                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00001CA0 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00001CA0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00001CA0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00001CA0
.text$mn:00001CA0 var_4           = dword ptr -4
.text$mn:00001CA0
.text$mn:00001CA0                 push    ebp
.text$mn:00001CA1                 mov     ebp, esp
.text$mn:00001CA3                 push    ecx
.text$mn:00001CA4                 mov     [ebp+var_4], ecx
.text$mn:00001CA7                 mov     eax, [ebp+var_4]
.text$mn:00001CAA                 mov     eax, [eax+14h]
.text$mn:00001CAD                 mov     esp, ebp
.text$mn:00001CAF                 pop     ebp
.text$mn:00001CB0                 retn
.text$mn:00001CB0 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00001CB0
.text$mn:00001CB0 ; ---------------------------------------------------------------------------
.text$mn:00001CB1                 align 4
.text$mn:00001CB1 _text$mn        ends
.text$mn:00001CB1
.text$mn:00001CB4 ; ===========================================================================
.text$mn:00001CB4
.text$mn:00001CB4 ; Segment type: Pure code
.text$mn:00001CB4 ; Segment permissions: Read/Execute
.text$mn:00001CB4 _text$mn        segment para public 'CODE' use32
.text$mn:00001CB4                 assume cs:_text$mn
.text$mn:00001CB4                 ;org 1CB4h
.text$mn:00001CB4 ; COMDAT (pick any)
.text$mn:00001CB4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001CB4
.text$mn:00001CB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CB4
.text$mn:00001CB4 ; Attributes: bp-based frame
.text$mn:00001CB4
.text$mn:00001CB4 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00001CB4                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00001CB4 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00001CB4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_17ECp
.text$mn:00001CB4                 push    ebp
.text$mn:00001CB5                 mov     ebp, esp
.text$mn:00001CB7                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00001CBC                 pop     ebp
.text$mn:00001CBD                 retn
.text$mn:00001CBD ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00001CBD
.text$mn:00001CBD ; ---------------------------------------------------------------------------
.text$mn:00001CBE                 align 10h
.text$mn:00001CBE _text$mn        ends
.text$mn:00001CBE
.text$mn:00001CC0 ; ===========================================================================
.text$mn:00001CC0
.text$mn:00001CC0 ; Segment type: Pure code
.text$mn:00001CC0 ; Segment permissions: Read/Execute
.text$mn:00001CC0 _text$mn        segment para public 'CODE' use32
.text$mn:00001CC0                 assume cs:_text$mn
.text$mn:00001CC0                 ;org 1CC0h
.text$mn:00001CC0 ; COMDAT (pick any)
.text$mn:00001CC0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001CC0
.text$mn:00001CC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CC0
.text$mn:00001CC0 ; Attributes: bp-based frame
.text$mn:00001CC0
.text$mn:00001CC0 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00001CC0                 public ?value@error_code@std@@QBEHXZ
.text$mn:00001CC0 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00001CC0
.text$mn:00001CC0 var_4           = dword ptr -4
.text$mn:00001CC0
.text$mn:00001CC0                 push    ebp
.text$mn:00001CC1                 mov     ebp, esp
.text$mn:00001CC3                 push    ecx
.text$mn:00001CC4                 mov     [ebp+var_4], ecx
.text$mn:00001CC7                 mov     eax, [ebp+var_4]
.text$mn:00001CCA                 mov     eax, [eax]
.text$mn:00001CCC                 mov     esp, ebp
.text$mn:00001CCE                 pop     ebp
.text$mn:00001CCF                 retn
.text$mn:00001CCF ?value@error_code@std@@QBEHXZ endp
.text$mn:00001CCF
.text$mn:00001CCF _text$mn        ends
.text$mn:00001CCF
.text$mn:00001CD0 ; ===========================================================================
.text$mn:00001CD0
.text$mn:00001CD0 ; Segment type: Pure code
.text$mn:00001CD0 ; Segment permissions: Read/Execute
.text$mn:00001CD0 _text$mn        segment para public 'CODE' use32
.text$mn:00001CD0                 assume cs:_text$mn
.text$mn:00001CD0                 ;org 1CD0h
.text$mn:00001CD0 ; COMDAT (pick any)
.text$mn:00001CD0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001CD0
.text$mn:00001CD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CD0
.text$mn:00001CD0 ; Attributes: bp-based frame
.text$mn:00001CD0
.text$mn:00001CD0 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00001CD0                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00001CD0 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00001CD0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00001CD0                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00001CD0
.text$mn:00001CD0 var_4           = dword ptr -4
.text$mn:00001CD0
.text$mn:00001CD0                 push    ebp
.text$mn:00001CD1                 mov     ebp, esp
.text$mn:00001CD3                 push    ecx
.text$mn:00001CD4                 mov     [ebp+var_4], ecx
.text$mn:00001CD7                 mov     eax, [ebp+var_4]
.text$mn:00001CDA                 mov     eax, [eax]
.text$mn:00001CDC                 mov     esp, ebp
.text$mn:00001CDE                 pop     ebp
.text$mn:00001CDF                 retn
.text$mn:00001CDF ?value@error_condition@std@@QBEHXZ endp
.text$mn:00001CDF
.text$mn:00001CDF _text$mn        ends
.text$mn:00001CDF
.text$mn:00001CE0 ; ===========================================================================
.text$mn:00001CE0
.text$mn:00001CE0 ; Segment type: Pure code
.text$mn:00001CE0 ; Segment permissions: Read/Execute
.text$mn:00001CE0 _text$mn        segment para public 'CODE' use32
.text$mn:00001CE0                 assume cs:_text$mn
.text$mn:00001CE0                 ;org 1CE0h
.text$mn:00001CE0 ; COMDAT (pick any)
.text$mn:00001CE0                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.text$mn:00001CE0
.text$mn:00001CE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CE0
.text$mn:00001CE0 ; Attributes: bp-based frame
.text$mn:00001CE0
.text$mn:00001CE0                 public _hypot
.text$mn:00001CE0 _hypot          proc near
.text$mn:00001CE0
.text$mn:00001CE0 var_10          = qword ptr -10h
.text$mn:00001CE0 var_8           = qword ptr -8
.text$mn:00001CE0 arg_0           = qword ptr  8
.text$mn:00001CE0 arg_8           = qword ptr  10h
.text$mn:00001CE0
.text$mn:00001CE0                 push    ebp
.text$mn:00001CE1                 mov     ebp, esp
.text$mn:00001CE3                 sub     esp, 8
.text$mn:00001CE6                 movsd   xmm0, [ebp+arg_8]
.text$mn:00001CEB                 movsd   [esp+8+var_8], xmm0
.text$mn:00001CF0                 sub     esp, 8
.text$mn:00001CF3                 movsd   xmm0, [ebp+arg_0]
.text$mn:00001CF8                 movsd   [esp+10h+var_10], xmm0
.text$mn:00001CFD                 call    __hypot
.text$mn:00001D02                 add     esp, 10h
.text$mn:00001D05                 pop     ebp
.text$mn:00001D06                 retn
.text$mn:00001D06 _hypot          endp
.text$mn:00001D06
.text$mn:00001D06 ; ---------------------------------------------------------------------------
.text$mn:00001D07                 align 4
.text$mn:00001D07 _text$mn        ends
.text$mn:00001D07
.xdata$x:00001D08 ; ===========================================================================
.xdata$x:00001D08
.xdata$x:00001D08 ; Segment type: Pure data
.xdata$x:00001D08 ; Segment permissions: Read
.xdata$x:00001D08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D08                 assume cs:_xdata$x
.xdata$x:00001D08                 ;org 1D08h
.xdata$x:00001D08 __unwindtable$_uchardet_new db 0FFh     ; DATA XREF: .xdata$x:00001D18o
.xdata$x:00001D09                 db 0FFh
.xdata$x:00001D0A                 db 0FFh
.xdata$x:00001D0B                 db 0FFh
.xdata$x:00001D0C                 dd offset __unwindfunclet$_uchardet_new$0
.xdata$x:00001D10 __ehfuncinfo$_uchardet_new db  22h ; "  ; DATA XREF: __ehhandler$_uchardet_new+11o
.xdata$x:00001D11                 db    5
.xdata$x:00001D12                 db  93h ; 
.xdata$x:00001D13                 db  19h
.xdata$x:00001D14                 db    1
.xdata$x:00001D15                 db    0
.xdata$x:00001D16                 db    0
.xdata$x:00001D17                 db    0
.xdata$x:00001D18                 dd offset __unwindtable$_uchardet_new
.xdata$x:00001D1C                 db    0
.xdata$x:00001D1D                 db    0
.xdata$x:00001D1E                 db    0
.xdata$x:00001D1F                 db    0
.xdata$x:00001D20                 db    0
.xdata$x:00001D21                 db    0
.xdata$x:00001D22                 db    0
.xdata$x:00001D23                 db    0
.xdata$x:00001D24                 db    0
.xdata$x:00001D25                 db    0
.xdata$x:00001D26                 db    0
.xdata$x:00001D27                 db    0
.xdata$x:00001D28                 db    0
.xdata$x:00001D29                 db    0
.xdata$x:00001D2A                 db    0
.xdata$x:00001D2B                 db    0
.xdata$x:00001D2C                 db    0
.xdata$x:00001D2D                 db    0
.xdata$x:00001D2E                 db    0
.xdata$x:00001D2F                 db    0
.xdata$x:00001D30                 db    0
.xdata$x:00001D31                 db    0
.xdata$x:00001D32                 db    0
.xdata$x:00001D33                 db    0
.xdata$x:00001D33 _xdata$x        ends
.xdata$x:00001D33
.xdata$x:00001D34 ; ===========================================================================
.xdata$x:00001D34
.xdata$x:00001D34 ; Segment type: Pure data
.xdata$x:00001D34 ; Segment permissions: Read
.xdata$x:00001D34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D34                 assume cs:_xdata$x
.xdata$x:00001D34                 ;org 1D34h
.xdata$x:00001D34 ; COMDAT (pick associative to section at 137C)
.xdata$x:00001D34 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00001D34                                         ; DATA XREF: .xdata$x:00001D44o
.xdata$x:00001D35                 db 0FFh
.xdata$x:00001D36                 db 0FFh
.xdata$x:00001D37                 db 0FFh
.xdata$x:00001D38                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00001D3C __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00001D3C                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00001D3D                 db    5
.xdata$x:00001D3E                 db  93h ; 
.xdata$x:00001D3F                 db  19h
.xdata$x:00001D40                 db    1
.xdata$x:00001D41                 db    0
.xdata$x:00001D42                 db    0
.xdata$x:00001D43                 db    0
.xdata$x:00001D44                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00001D48                 align 20h
.xdata$x:00001D48 _xdata$x        ends
.xdata$x:00001D48
.xdata$x:00001D60 ; ===========================================================================
.xdata$x:00001D60
.xdata$x:00001D60 ; Segment type: Pure data
.xdata$x:00001D60 ; Segment permissions: Read
.xdata$x:00001D60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D60                 assume cs:_xdata$x
.xdata$x:00001D60                 ;org 1D60h
.xdata$x:00001D60 ; COMDAT (pick associative to section at 4B4)
.xdata$x:00001D60 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001D60                                         ; DATA XREF: .xdata$x:00001D70o
.xdata$x:00001D61                 db 0FFh
.xdata$x:00001D62                 db 0FFh
.xdata$x:00001D63                 db 0FFh
.xdata$x:00001D64                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00001D68 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001D68                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00001D69                 db    5
.xdata$x:00001D6A                 db  93h ; 
.xdata$x:00001D6B                 db  19h
.xdata$x:00001D6C                 db    1
.xdata$x:00001D6D                 db    0
.xdata$x:00001D6E                 db    0
.xdata$x:00001D6F                 db    0
.xdata$x:00001D70                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00001D74                 db    0
.xdata$x:00001D75                 db    0
.xdata$x:00001D76                 db    0
.xdata$x:00001D77                 db    0
.xdata$x:00001D78                 db    0
.xdata$x:00001D79                 db    0
.xdata$x:00001D7A                 db    0
.xdata$x:00001D7B                 db    0
.xdata$x:00001D7C                 db    0
.xdata$x:00001D7D                 db    0
.xdata$x:00001D7E                 db    0
.xdata$x:00001D7F                 db    0
.xdata$x:00001D80                 db    0
.xdata$x:00001D81                 db    0
.xdata$x:00001D82                 db    0
.xdata$x:00001D83                 db    0
.xdata$x:00001D84                 db    0
.xdata$x:00001D85                 db    0
.xdata$x:00001D86                 db    0
.xdata$x:00001D87                 db    0
.xdata$x:00001D88                 db    0
.xdata$x:00001D89                 db    0
.xdata$x:00001D8A                 db    0
.xdata$x:00001D8B                 db    0
.xdata$x:00001D8B _xdata$x        ends
.xdata$x:00001D8B
.xdata$x:00001D8C ; ===========================================================================
.xdata$x:00001D8C
.xdata$x:00001D8C ; Segment type: Pure data
.xdata$x:00001D8C ; Segment permissions: Read
.xdata$x:00001D8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001D8C                 assume cs:_xdata$x
.xdata$x:00001D8C                 ;org 1D8Ch
.xdata$x:00001D8C ; COMDAT (pick associative to section at 9BC)
.xdata$x:00001D8C __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001D8C                                         ; DATA XREF: .xdata$x:00001D9Co
.xdata$x:00001D8D                 db 0FFh
.xdata$x:00001D8E                 db 0FFh
.xdata$x:00001D8F                 db 0FFh
.xdata$x:00001D90                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00001D94 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001D94                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00001D95                 db    5
.xdata$x:00001D96                 db  93h ; 
.xdata$x:00001D97                 db  19h
.xdata$x:00001D98                 db    1
.xdata$x:00001D99                 db    0
.xdata$x:00001D9A                 db    0
.xdata$x:00001D9B                 db    0
.xdata$x:00001D9C                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00001DA0                 db    0
.xdata$x:00001DA1                 db    0
.xdata$x:00001DA2                 db    0
.xdata$x:00001DA3                 db    0
.xdata$x:00001DA4                 db    0
.xdata$x:00001DA5                 db    0
.xdata$x:00001DA6                 db    0
.xdata$x:00001DA7                 db    0
.xdata$x:00001DA8                 db    0
.xdata$x:00001DA9                 db    0
.xdata$x:00001DAA                 db    0
.xdata$x:00001DAB                 db    0
.xdata$x:00001DAC                 db    0
.xdata$x:00001DAD                 db    0
.xdata$x:00001DAE                 db    0
.xdata$x:00001DAF                 db    0
.xdata$x:00001DB0                 db    0
.xdata$x:00001DB1                 db    0
.xdata$x:00001DB2                 db    0
.xdata$x:00001DB3                 db    0
.xdata$x:00001DB4                 db    0
.xdata$x:00001DB5                 db    0
.xdata$x:00001DB6                 db    0
.xdata$x:00001DB7                 db    0
.xdata$x:00001DB7 _xdata$x        ends
.xdata$x:00001DB7
.xdata$x:00001DB8 ; ===========================================================================
.xdata$x:00001DB8
.xdata$x:00001DB8 ; Segment type: Pure data
.xdata$x:00001DB8 ; Segment permissions: Read
.xdata$x:00001DB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001DB8                 assume cs:_xdata$x
.xdata$x:00001DB8                 ;org 1DB8h
.xdata$x:00001DB8 ; COMDAT (pick associative to section at 438)
.xdata$x:00001DB8 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00001DB8                                         ; DATA XREF: .xdata$x:00001DC8o
.xdata$x:00001DB9                 db 0FFh
.xdata$x:00001DBA                 db 0FFh
.xdata$x:00001DBB                 db 0FFh
.xdata$x:00001DBC                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00001DC0 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00001DC0                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00001DC1                 db    5
.xdata$x:00001DC2                 db  93h ; 
.xdata$x:00001DC3                 db  19h
.xdata$x:00001DC4                 db    1
.xdata$x:00001DC5                 db    0
.xdata$x:00001DC6                 db    0
.xdata$x:00001DC7                 db    0
.xdata$x:00001DC8                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00001DCC                 db    0
.xdata$x:00001DCD                 db    0
.xdata$x:00001DCE                 db    0
.xdata$x:00001DCF                 db    0
.xdata$x:00001DD0                 db    0
.xdata$x:00001DD1                 db    0
.xdata$x:00001DD2                 db    0
.xdata$x:00001DD3                 db    0
.xdata$x:00001DD4                 db    0
.xdata$x:00001DD5                 db    0
.xdata$x:00001DD6                 db    0
.xdata$x:00001DD7                 db    0
.xdata$x:00001DD8                 db    0
.xdata$x:00001DD9                 db    0
.xdata$x:00001DDA                 db    0
.xdata$x:00001DDB                 db    0
.xdata$x:00001DDC                 db    0
.xdata$x:00001DDD                 db    0
.xdata$x:00001DDE                 db    0
.xdata$x:00001DDF                 db    0
.xdata$x:00001DE0                 db    0
.xdata$x:00001DE1                 db    0
.xdata$x:00001DE2                 db    0
.xdata$x:00001DE3                 db    0
.xdata$x:00001DE3 _xdata$x        ends
.xdata$x:00001DE3
.xdata$x:00001DE4 ; ===========================================================================
.xdata$x:00001DE4
.xdata$x:00001DE4 ; Segment type: Pure data
.xdata$x:00001DE4 ; Segment permissions: Read
.xdata$x:00001DE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001DE4                 assume cs:_xdata$x
.xdata$x:00001DE4                 ;org 1DE4h
.xdata$x:00001DE4 ; COMDAT (pick associative to section at 944)
.xdata$x:00001DE4 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00001DE4                                         ; DATA XREF: .xdata$x:00001DF4o
.xdata$x:00001DE5                 db 0FFh
.xdata$x:00001DE6                 db 0FFh
.xdata$x:00001DE7                 db 0FFh
.xdata$x:00001DE8                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00001DEC __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00001DEC                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00001DED                 db    5
.xdata$x:00001DEE                 db  93h ; 
.xdata$x:00001DEF                 db  19h
.xdata$x:00001DF0                 db    1
.xdata$x:00001DF1                 db    0
.xdata$x:00001DF2                 db    0
.xdata$x:00001DF3                 db    0
.xdata$x:00001DF4                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00001DF8                 db    0
.xdata$x:00001DF9                 db    0
.xdata$x:00001DFA                 db    0
.xdata$x:00001DFB                 db    0
.xdata$x:00001DFC                 db    0
.xdata$x:00001DFD                 db    0
.xdata$x:00001DFE                 db    0
.xdata$x:00001DFF                 db    0
.xdata$x:00001E00                 db    0
.xdata$x:00001E01                 db    0
.xdata$x:00001E02                 db    0
.xdata$x:00001E03                 db    0
.xdata$x:00001E04                 db    0
.xdata$x:00001E05                 db    0
.xdata$x:00001E06                 db    0
.xdata$x:00001E07                 db    0
.xdata$x:00001E08                 db    0
.xdata$x:00001E09                 db    0
.xdata$x:00001E0A                 db    0
.xdata$x:00001E0B                 db    0
.xdata$x:00001E0C                 db    0
.xdata$x:00001E0D                 db    0
.xdata$x:00001E0E                 db    0
.xdata$x:00001E0F                 db    0
.xdata$x:00001E0F _xdata$x        ends
.xdata$x:00001E0F
.xdata$x:00001E10 ; ===========================================================================
.xdata$x:00001E10
.xdata$x:00001E10 ; Segment type: Pure data
.xdata$x:00001E10 ; Segment permissions: Read
.xdata$x:00001E10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001E10                 assume cs:_xdata$x
.xdata$x:00001E10                 ;org 1E10h
.xdata$x:00001E10 ; COMDAT (pick associative to section at 60C)
.xdata$x:00001E10 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00001E10                                         ; DATA XREF: .xdata$x:00001E20o
.xdata$x:00001E11                 db 0FFh
.xdata$x:00001E12                 db 0FFh
.xdata$x:00001E13                 db 0FFh
.xdata$x:00001E14                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00001E18 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00001E18                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00001E19                 db    5
.xdata$x:00001E1A                 db  93h ; 
.xdata$x:00001E1B                 db  19h
.xdata$x:00001E1C                 db    1
.xdata$x:00001E1D                 db    0
.xdata$x:00001E1E                 db    0
.xdata$x:00001E1F                 db    0
.xdata$x:00001E20                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00001E24                 db    0
.xdata$x:00001E25                 db    0
.xdata$x:00001E26                 db    0
.xdata$x:00001E27                 db    0
.xdata$x:00001E28                 db    0
.xdata$x:00001E29                 db    0
.xdata$x:00001E2A                 db    0
.xdata$x:00001E2B                 db    0
.xdata$x:00001E2C                 db    0
.xdata$x:00001E2D                 db    0
.xdata$x:00001E2E                 db    0
.xdata$x:00001E2F                 db    0
.xdata$x:00001E30                 db    0
.xdata$x:00001E31                 db    0
.xdata$x:00001E32                 db    0
.xdata$x:00001E33                 db    0
.xdata$x:00001E34                 db    0
.xdata$x:00001E35                 db    0
.xdata$x:00001E36                 db    0
.xdata$x:00001E37                 db    0
.xdata$x:00001E38                 db    0
.xdata$x:00001E39                 db    0
.xdata$x:00001E3A                 db    0
.xdata$x:00001E3B                 db    0
.xdata$x:00001E3B _xdata$x        ends
.xdata$x:00001E3B
.xdata$x:00001E3C ; ===========================================================================
.xdata$x:00001E3C
.xdata$x:00001E3C ; Segment type: Pure data
.xdata$x:00001E3C ; Segment permissions: Read
.xdata$x:00001E3C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001E3C                 assume cs:_xdata$x
.xdata$x:00001E3C                 ;org 1E3Ch
.xdata$x:00001E3C ; COMDAT (pick associative to section at 574)
.xdata$x:00001E3C __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00001E3C                                         ; DATA XREF: .xdata$x:00001E4Co
.xdata$x:00001E3D                 db 0FFh
.xdata$x:00001E3E                 db 0FFh
.xdata$x:00001E3F                 db 0FFh
.xdata$x:00001E40                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00001E44 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00001E44                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00001E45                 db    5
.xdata$x:00001E46                 db  93h ; 
.xdata$x:00001E47                 db  19h
.xdata$x:00001E48                 db    1
.xdata$x:00001E49                 db    0
.xdata$x:00001E4A                 db    0
.xdata$x:00001E4B                 db    0
.xdata$x:00001E4C                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00001E50                 db    0
.xdata$x:00001E51                 db    0
.xdata$x:00001E52                 db    0
.xdata$x:00001E53                 db    0
.xdata$x:00001E54                 db    0
.xdata$x:00001E55                 db    0
.xdata$x:00001E56                 db    0
.xdata$x:00001E57                 db    0
.xdata$x:00001E58                 db    0
.xdata$x:00001E59                 db    0
.xdata$x:00001E5A                 db    0
.xdata$x:00001E5B                 db    0
.xdata$x:00001E5C                 db    0
.xdata$x:00001E5D                 db    0
.xdata$x:00001E5E                 db    0
.xdata$x:00001E5F                 db    0
.xdata$x:00001E60                 db    0
.xdata$x:00001E61                 db    0
.xdata$x:00001E62                 db    0
.xdata$x:00001E63                 db    0
.xdata$x:00001E64                 db    0
.xdata$x:00001E65                 db    0
.xdata$x:00001E66                 db    0
.xdata$x:00001E67                 db    0
.xdata$x:00001E67 _xdata$x        ends
.xdata$x:00001E67
.xdata$x:00001E68 ; ===========================================================================
.xdata$x:00001E68
.xdata$x:00001E68 ; Segment type: Pure data
.xdata$x:00001E68 ; Segment permissions: Read
.xdata$x:00001E68 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001E68                 assume cs:_xdata$x
.xdata$x:00001E68                 ;org 1E68h
.xdata$x:00001E68 ; COMDAT (pick associative to section at A2C)
.xdata$x:00001E68 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00001E68                                         ; DATA XREF: .xdata$x:00001E78o
.xdata$x:00001E69                 db 0FFh
.xdata$x:00001E6A                 db 0FFh
.xdata$x:00001E6B                 db 0FFh
.xdata$x:00001E6C                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00001E70 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00001E70                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00001E71                 db    5
.xdata$x:00001E72                 db  93h ; 
.xdata$x:00001E73                 db  19h
.xdata$x:00001E74                 db    1
.xdata$x:00001E75                 db    0
.xdata$x:00001E76                 db    0
.xdata$x:00001E77                 db    0
.xdata$x:00001E78                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00001E7C                 db    0
.xdata$x:00001E7D                 db    0
.xdata$x:00001E7E                 db    0
.xdata$x:00001E7F                 db    0
.xdata$x:00001E80                 db    0
.xdata$x:00001E81                 db    0
.xdata$x:00001E82                 db    0
.xdata$x:00001E83                 db    0
.xdata$x:00001E84                 db    0
.xdata$x:00001E85                 db    0
.xdata$x:00001E86                 db    0
.xdata$x:00001E87                 db    0
.xdata$x:00001E88                 db    0
.xdata$x:00001E89                 db    0
.xdata$x:00001E8A                 db    0
.xdata$x:00001E8B                 db    0
.xdata$x:00001E8C                 db    0
.xdata$x:00001E8D                 db    0
.xdata$x:00001E8E                 db    0
.xdata$x:00001E8F                 db    0
.xdata$x:00001E90                 db    0
.xdata$x:00001E91                 db    0
.xdata$x:00001E92                 db    0
.xdata$x:00001E93                 db    0
.xdata$x:00001E93 _xdata$x        ends
.xdata$x:00001E93
.xdata$x:00001E94 ; ===========================================================================
.xdata$x:00001E94
.xdata$x:00001E94 ; Segment type: Pure data
.xdata$x:00001E94 ; Segment permissions: Read
.xdata$x:00001E94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001E94                 assume cs:_xdata$x
.xdata$x:00001E94                 ;org 1E94h
.xdata$x:00001E94 ; COMDAT (pick associative to section at FD8)
.xdata$x:00001E94 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00001E94                                         ; DATA XREF: .xdata$x:00001F1Co
.xdata$x:00001E95                 db    0
.xdata$x:00001E96                 db    0
.xdata$x:00001E97                 db    0
.xdata$x:00001E98                 db    0
.xdata$x:00001E99                 db    0
.xdata$x:00001E9A                 db    0
.xdata$x:00001E9B                 db    0
.xdata$x:00001E9C                 db    0
.xdata$x:00001E9D                 db    0
.xdata$x:00001E9E                 db    0
.xdata$x:00001E9F                 db    0
.xdata$x:00001EA0                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00001EA4 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00001EA4                                         ; DATA XREF: .xdata$x:00001F08o
.xdata$x:00001EA5                 db    0
.xdata$x:00001EA6                 db    0
.xdata$x:00001EA7                 db    0
.xdata$x:00001EA8                 db    0
.xdata$x:00001EA9                 db    0
.xdata$x:00001EAA                 db    0
.xdata$x:00001EAB                 db    0
.xdata$x:00001EAC                 db    0
.xdata$x:00001EAD                 db    0
.xdata$x:00001EAE                 db    0
.xdata$x:00001EAF                 db    0
.xdata$x:00001EB0                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00001EB4 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00001EB4                                         ; DATA XREF: .xdata$x:00001EDCo
.xdata$x:00001EB5                 db 0FFh
.xdata$x:00001EB6                 db 0FFh
.xdata$x:00001EB7                 db 0FFh
.xdata$x:00001EB8                 db    0
.xdata$x:00001EB9                 db    0
.xdata$x:00001EBA                 db    0
.xdata$x:00001EBB                 db    0
.xdata$x:00001EBC                 db 0FFh
.xdata$x:00001EBD                 db 0FFh
.xdata$x:00001EBE                 db 0FFh
.xdata$x:00001EBF                 db 0FFh
.xdata$x:00001EC0                 db    0
.xdata$x:00001EC1                 db    0
.xdata$x:00001EC2                 db    0
.xdata$x:00001EC3                 db    0
.xdata$x:00001EC4                 db    1
.xdata$x:00001EC5                 db    0
.xdata$x:00001EC6                 db    0
.xdata$x:00001EC7                 db    0
.xdata$x:00001EC8                 db    0
.xdata$x:00001EC9                 db    0
.xdata$x:00001ECA                 db    0
.xdata$x:00001ECB                 db    0
.xdata$x:00001ECC                 db    1
.xdata$x:00001ECD                 db    0
.xdata$x:00001ECE                 db    0
.xdata$x:00001ECF                 db    0
.xdata$x:00001ED0                 db    0
.xdata$x:00001ED1                 db    0
.xdata$x:00001ED2                 db    0
.xdata$x:00001ED3                 db    0
.xdata$x:00001ED4 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00001ED4                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00001ED5                 db    5
.xdata$x:00001ED6                 db  93h ; 
.xdata$x:00001ED7                 db  19h
.xdata$x:00001ED8                 db    4
.xdata$x:00001ED9                 db    0
.xdata$x:00001EDA                 db    0
.xdata$x:00001EDB                 db    0
.xdata$x:00001EDC                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00001EE0                 db    2
.xdata$x:00001EE1                 db    0
.xdata$x:00001EE2                 db    0
.xdata$x:00001EE3                 db    0
.xdata$x:00001EE4                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00001EE8                 db    0
.xdata$x:00001EE9                 db    0
.xdata$x:00001EEA                 db    0
.xdata$x:00001EEB                 db    0
.xdata$x:00001EEC                 db    0
.xdata$x:00001EED                 db    0
.xdata$x:00001EEE                 db    0
.xdata$x:00001EEF                 db    0
.xdata$x:00001EF0                 db    0
.xdata$x:00001EF1                 db    0
.xdata$x:00001EF2                 db    0
.xdata$x:00001EF3                 db    0
.xdata$x:00001EF4                 db    0
.xdata$x:00001EF5                 db    0
.xdata$x:00001EF6                 db    0
.xdata$x:00001EF7                 db    0
.xdata$x:00001EF8 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00001EF8                                         ; DATA XREF: .xdata$x:00001EE4o
.xdata$x:00001EF9                 db    0
.xdata$x:00001EFA                 db    0
.xdata$x:00001EFB                 db    0
.xdata$x:00001EFC                 db    2
.xdata$x:00001EFD                 db    0
.xdata$x:00001EFE                 db    0
.xdata$x:00001EFF                 db    0
.xdata$x:00001F00                 db    3
.xdata$x:00001F01                 db    0
.xdata$x:00001F02                 db    0
.xdata$x:00001F03                 db    0
.xdata$x:00001F04                 db    1
.xdata$x:00001F05                 db    0
.xdata$x:00001F06                 db    0
.xdata$x:00001F07                 db    0
.xdata$x:00001F08                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00001F0C                 db    0
.xdata$x:00001F0D                 db    0
.xdata$x:00001F0E                 db    0
.xdata$x:00001F0F                 db    0
.xdata$x:00001F10                 db    0
.xdata$x:00001F11                 db    0
.xdata$x:00001F12                 db    0
.xdata$x:00001F13                 db    0
.xdata$x:00001F14                 db    3
.xdata$x:00001F15                 db    0
.xdata$x:00001F16                 db    0
.xdata$x:00001F17                 db    0
.xdata$x:00001F18                 db    1
.xdata$x:00001F19                 db    0
.xdata$x:00001F1A                 db    0
.xdata$x:00001F1B                 db    0
.xdata$x:00001F1C                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00001F1C _xdata$x        ends
.xdata$x:00001F1C
.xdata$x:00001F20 ; ===========================================================================
.xdata$x:00001F20
.xdata$x:00001F20 ; Segment type: Pure data
.xdata$x:00001F20 ; Segment permissions: Read
.xdata$x:00001F20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001F20                 assume cs:_xdata$x
.xdata$x:00001F20                 ;org 1F20h
.xdata$x:00001F20 ; COMDAT (pick associative to section at 77C)
.xdata$x:00001F20 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001F20                                         ; DATA XREF: .xdata$x:00001F30o
.xdata$x:00001F21                 db 0FFh
.xdata$x:00001F22                 db 0FFh
.xdata$x:00001F23                 db 0FFh
.xdata$x:00001F24                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00001F28 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001F28                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00001F29                 db    5
.xdata$x:00001F2A                 db  93h ; 
.xdata$x:00001F2B                 db  19h
.xdata$x:00001F2C                 db    1
.xdata$x:00001F2D                 db    0
.xdata$x:00001F2E                 db    0
.xdata$x:00001F2F                 db    0
.xdata$x:00001F30                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00001F34                 db    0
.xdata$x:00001F35                 db    0
.xdata$x:00001F36                 db    0
.xdata$x:00001F37                 db    0
.xdata$x:00001F38                 db    0
.xdata$x:00001F39                 db    0
.xdata$x:00001F3A                 db    0
.xdata$x:00001F3B                 db    0
.xdata$x:00001F3C                 db    0
.xdata$x:00001F3D                 db    0
.xdata$x:00001F3E                 db    0
.xdata$x:00001F3F                 db    0
.xdata$x:00001F40                 db    0
.xdata$x:00001F41                 db    0
.xdata$x:00001F42                 db    0
.xdata$x:00001F43                 db    0
.xdata$x:00001F44                 db    0
.xdata$x:00001F45                 db    0
.xdata$x:00001F46                 db    0
.xdata$x:00001F47                 db    0
.xdata$x:00001F48                 db    0
.xdata$x:00001F49                 db    0
.xdata$x:00001F4A                 db    0
.xdata$x:00001F4B                 db    0
.xdata$x:00001F4B _xdata$x        ends
.xdata$x:00001F4B
.xdata$x:00001F4C ; ===========================================================================
.xdata$x:00001F4C
.xdata$x:00001F4C ; Segment type: Pure data
.xdata$x:00001F4C ; Segment permissions: Read
.xdata$x:00001F4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001F4C                 assume cs:_xdata$x
.xdata$x:00001F4C                 ;org 1F4Ch
.xdata$x:00001F4C ; COMDAT (pick associative to section at 1A0C)
.xdata$x:00001F4C __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001F4C                                         ; DATA XREF: .xdata$x:00001F5Co
.xdata$x:00001F4D                 db 0FFh
.xdata$x:00001F4E                 db 0FFh
.xdata$x:00001F4F                 db 0FFh
.xdata$x:00001F50                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001F54 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001F54                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001F55                 db    5
.xdata$x:00001F56                 db  93h ; 
.xdata$x:00001F57                 db  19h
.xdata$x:00001F58                 db    1
.xdata$x:00001F59                 db    0
.xdata$x:00001F5A                 db    0
.xdata$x:00001F5B                 db    0
.xdata$x:00001F5C                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001F60                 db    0
.xdata$x:00001F61                 db    0
.xdata$x:00001F62                 db    0
.xdata$x:00001F63                 db    0
.xdata$x:00001F64                 db    0
.xdata$x:00001F65                 db    0
.xdata$x:00001F66                 db    0
.xdata$x:00001F67                 db    0
.xdata$x:00001F68                 db    0
.xdata$x:00001F69                 db    0
.xdata$x:00001F6A                 db    0
.xdata$x:00001F6B                 db    0
.xdata$x:00001F6C                 db    0
.xdata$x:00001F6D                 db    0
.xdata$x:00001F6E                 db    0
.xdata$x:00001F6F                 db    0
.xdata$x:00001F70                 db    0
.xdata$x:00001F71                 db    0
.xdata$x:00001F72                 db    0
.xdata$x:00001F73                 db    0
.xdata$x:00001F74                 db    0
.xdata$x:00001F75                 db    0
.xdata$x:00001F76                 db    0
.xdata$x:00001F77                 db    0
.xdata$x:00001F77 _xdata$x        ends
.xdata$x:00001F77
.xdata$x:00001F78 ; ===========================================================================
.xdata$x:00001F78
.xdata$x:00001F78 ; Segment type: Pure data
.xdata$x:00001F78 ; Segment permissions: Read
.xdata$x:00001F78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001F78                 assume cs:_xdata$x
.xdata$x:00001F78                 ;org 1F78h
.xdata$x:00001F78 ; COMDAT (pick associative to section at B50)
.xdata$x:00001F78 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001F78                                         ; DATA XREF: .xdata$x:00001F88o
.xdata$x:00001F79                 db 0FFh
.xdata$x:00001F7A                 db 0FFh
.xdata$x:00001F7B                 db 0FFh
.xdata$x:00001F7C                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00001F80 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00001F80                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00001F81                 db    5
.xdata$x:00001F82                 db  93h ; 
.xdata$x:00001F83                 db  19h
.xdata$x:00001F84                 db    1
.xdata$x:00001F85                 db    0
.xdata$x:00001F86                 db    0
.xdata$x:00001F87                 db    0
.xdata$x:00001F88                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00001F8C                 db    0
.xdata$x:00001F8D                 db    0
.xdata$x:00001F8E                 db    0
.xdata$x:00001F8F                 db    0
.xdata$x:00001F90                 db    0
.xdata$x:00001F91                 db    0
.xdata$x:00001F92                 db    0
.xdata$x:00001F93                 db    0
.xdata$x:00001F94                 db    0
.xdata$x:00001F95                 db    0
.xdata$x:00001F96                 db    0
.xdata$x:00001F97                 db    0
.xdata$x:00001F98                 db    0
.xdata$x:00001F99                 db    0
.xdata$x:00001F9A                 db    0
.xdata$x:00001F9B                 db    0
.xdata$x:00001F9C                 db    0
.xdata$x:00001F9D                 db    0
.xdata$x:00001F9E                 db    0
.xdata$x:00001F9F                 db    0
.xdata$x:00001FA0                 db    0
.xdata$x:00001FA1                 db    0
.xdata$x:00001FA2                 db    0
.xdata$x:00001FA3                 db    0
.xdata$x:00001FA3 _xdata$x        ends
.xdata$x:00001FA3
.xdata$x:00001FA4 ; ===========================================================================
.xdata$x:00001FA4
.xdata$x:00001FA4 ; Segment type: Pure data
.xdata$x:00001FA4 ; Segment permissions: Read
.xdata$x:00001FA4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001FA4                 assume cs:_xdata$x
.xdata$x:00001FA4                 ;org 1FA4h
.xdata$x:00001FA4 ; COMDAT (pick associative to section at 7F8)
.xdata$x:00001FA4 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00001FA4                                         ; DATA XREF: .xdata$x:00001FB4o
.xdata$x:00001FA5                 db 0FFh
.xdata$x:00001FA6                 db 0FFh
.xdata$x:00001FA7                 db 0FFh
.xdata$x:00001FA8                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00001FAC __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00001FAC                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00001FAD                 db    5
.xdata$x:00001FAE                 db  93h ; 
.xdata$x:00001FAF                 db  19h
.xdata$x:00001FB0                 db    1
.xdata$x:00001FB1                 db    0
.xdata$x:00001FB2                 db    0
.xdata$x:00001FB3                 db    0
.xdata$x:00001FB4                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00001FB8                 db    0
.xdata$x:00001FB9                 db    0
.xdata$x:00001FBA                 db    0
.xdata$x:00001FBB                 db    0
.xdata$x:00001FBC                 db    0
.xdata$x:00001FBD                 db    0
.xdata$x:00001FBE                 db    0
.xdata$x:00001FBF                 db    0
.xdata$x:00001FC0                 db    0
.xdata$x:00001FC1                 db    0
.xdata$x:00001FC2                 db    0
.xdata$x:00001FC3                 db    0
.xdata$x:00001FC4                 db    0
.xdata$x:00001FC5                 db    0
.xdata$x:00001FC6                 db    0
.xdata$x:00001FC7                 db    0
.xdata$x:00001FC8                 db    0
.xdata$x:00001FC9                 db    0
.xdata$x:00001FCA                 db    0
.xdata$x:00001FCB                 db    0
.xdata$x:00001FCC                 db    0
.xdata$x:00001FCD                 db    0
.xdata$x:00001FCE                 db    0
.xdata$x:00001FCF                 db    0
.xdata$x:00001FCF _xdata$x        ends
.xdata$x:00001FCF
.xdata$x:00001FD0 ; ===========================================================================
.xdata$x:00001FD0
.xdata$x:00001FD0 ; Segment type: Pure data
.xdata$x:00001FD0 ; Segment permissions: Read
.xdata$x:00001FD0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001FD0                 assume cs:_xdata$x
.xdata$x:00001FD0                 ;org 1FD0h
.xdata$x:00001FD0 ; COMDAT (pick associative to section at 1AC4)
.xdata$x:00001FD0 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00001FD0                                         ; DATA XREF: .xdata$x:00001FE0o
.xdata$x:00001FD1                 db 0FFh
.xdata$x:00001FD2                 db 0FFh
.xdata$x:00001FD3                 db 0FFh
.xdata$x:00001FD4                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00001FD8 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00001FD8                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00001FD9                 db    5
.xdata$x:00001FDA                 db  93h ; 
.xdata$x:00001FDB                 db  19h
.xdata$x:00001FDC                 db    1
.xdata$x:00001FDD                 db    0
.xdata$x:00001FDE                 db    0
.xdata$x:00001FDF                 db    0
.xdata$x:00001FE0                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00001FE4                 db    0
.xdata$x:00001FE5                 db    0
.xdata$x:00001FE6                 db    0
.xdata$x:00001FE7                 db    0
.xdata$x:00001FE8                 db    0
.xdata$x:00001FE9                 db    0
.xdata$x:00001FEA                 db    0
.xdata$x:00001FEB                 db    0
.xdata$x:00001FEC                 db    0
.xdata$x:00001FED                 db    0
.xdata$x:00001FEE                 db    0
.xdata$x:00001FEF                 db    0
.xdata$x:00001FF0                 db    0
.xdata$x:00001FF1                 db    0
.xdata$x:00001FF2                 db    0
.xdata$x:00001FF3                 db    0
.xdata$x:00001FF4                 db    0
.xdata$x:00001FF5                 db    0
.xdata$x:00001FF6                 db    0
.xdata$x:00001FF7                 db    0
.xdata$x:00001FF8                 db    0
.xdata$x:00001FF9                 db    0
.xdata$x:00001FFA                 db    0
.xdata$x:00001FFB                 db    0
.xdata$x:00001FFB _xdata$x        ends
.xdata$x:00001FFB
.xdata$x:00001FFC ; ===========================================================================
.xdata$x:00001FFC
.xdata$x:00001FFC ; Segment type: Pure data
.xdata$x:00001FFC ; Segment permissions: Read
.xdata$x:00001FFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00001FFC                 assume cs:_xdata$x
.xdata$x:00001FFC                 ;org 1FFCh
.xdata$x:00001FFC ; COMDAT (pick associative to section at BC0)
.xdata$x:00001FFC __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00001FFC                                         ; DATA XREF: .xdata$x:0000200Co
.xdata$x:00001FFD                 db 0FFh
.xdata$x:00001FFE                 db 0FFh
.xdata$x:00001FFF                 db 0FFh
.xdata$x:00002000                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00002004 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002004                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00002005                 db    5
.xdata$x:00002006                 db  93h ; 
.xdata$x:00002007                 db  19h
.xdata$x:00002008                 db    1
.xdata$x:00002009                 db    0
.xdata$x:0000200A                 db    0
.xdata$x:0000200B                 db    0
.xdata$x:0000200C                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00002010                 db    0
.xdata$x:00002011                 db    0
.xdata$x:00002012                 db    0
.xdata$x:00002013                 db    0
.xdata$x:00002014                 db    0
.xdata$x:00002015                 db    0
.xdata$x:00002016                 db    0
.xdata$x:00002017                 db    0
.xdata$x:00002018                 db    0
.xdata$x:00002019                 db    0
.xdata$x:0000201A                 db    0
.xdata$x:0000201B                 db    0
.xdata$x:0000201C                 db    0
.xdata$x:0000201D                 db    0
.xdata$x:0000201E                 db    0
.xdata$x:0000201F                 db    0
.xdata$x:00002020                 db    0
.xdata$x:00002021                 db    0
.xdata$x:00002022                 db    0
.xdata$x:00002023                 db    0
.xdata$x:00002024                 db    0
.xdata$x:00002025                 db    0
.xdata$x:00002026                 db    0
.xdata$x:00002027                 db    0
.xdata$x:00002027 _xdata$x        ends
.xdata$x:00002027
.xdata$x:00002028 ; ===========================================================================
.xdata$x:00002028
.xdata$x:00002028 ; Segment type: Pure data
.xdata$x:00002028 ; Segment permissions: Read
.xdata$x:00002028 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002028                 assume cs:_xdata$x
.xdata$x:00002028                 ;org 2028h
.xdata$x:00002028 ; COMDAT (pick associative to section at 874)
.xdata$x:00002028 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00002028                                         ; DATA XREF: .xdata$x:00002038o
.xdata$x:00002029                 db 0FFh
.xdata$x:0000202A                 db 0FFh
.xdata$x:0000202B                 db 0FFh
.xdata$x:0000202C                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00002030 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00002030                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00002031                 db    5
.xdata$x:00002032                 db  93h ; 
.xdata$x:00002033                 db  19h
.xdata$x:00002034                 db    1
.xdata$x:00002035                 db    0
.xdata$x:00002036                 db    0
.xdata$x:00002037                 db    0
.xdata$x:00002038                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:0000203C                 db    0
.xdata$x:0000203D                 db    0
.xdata$x:0000203E                 db    0
.xdata$x:0000203F                 db    0
.xdata$x:00002040                 db    0
.xdata$x:00002041                 db    0
.xdata$x:00002042                 db    0
.xdata$x:00002043                 db    0
.xdata$x:00002044                 db    0
.xdata$x:00002045                 db    0
.xdata$x:00002046                 db    0
.xdata$x:00002047                 db    0
.xdata$x:00002048                 db    0
.xdata$x:00002049                 db    0
.xdata$x:0000204A                 db    0
.xdata$x:0000204B                 db    0
.xdata$x:0000204C                 db    0
.xdata$x:0000204D                 db    0
.xdata$x:0000204E                 db    0
.xdata$x:0000204F                 db    0
.xdata$x:00002050                 db    0
.xdata$x:00002051                 db    0
.xdata$x:00002052                 db    0
.xdata$x:00002053                 db    0
.xdata$x:00002053 _xdata$x        ends
.xdata$x:00002053
.xdata$x:00002054 ; ===========================================================================
.xdata$x:00002054
.xdata$x:00002054 ; Segment type: Pure data
.xdata$x:00002054 ; Segment permissions: Read
.xdata$x:00002054 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002054                 assume cs:_xdata$x
.xdata$x:00002054                 ;org 2054h
.xdata$x:00002054 ; COMDAT (pick associative to section at 1B88)
.xdata$x:00002054 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00002054                                         ; DATA XREF: .xdata$x:00002064o
.xdata$x:00002055                 db 0FFh
.xdata$x:00002056                 db 0FFh
.xdata$x:00002057                 db 0FFh
.xdata$x:00002058                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000205C __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000205C                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000205D                 db    5
.xdata$x:0000205E                 db  93h ; 
.xdata$x:0000205F                 db  19h
.xdata$x:00002060                 db    1
.xdata$x:00002061                 db    0
.xdata$x:00002062                 db    0
.xdata$x:00002063                 db    0
.xdata$x:00002064                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00002068                 align 20h
.xdata$x:00002068 _xdata$x        ends
.xdata$x:00002068
.xdata$x:00002080 ; ===========================================================================
.xdata$x:00002080
.xdata$x:00002080 ; Segment type: Pure data
.xdata$x:00002080 ; Segment permissions: Read
.xdata$x:00002080 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002080                 assume cs:_xdata$x
.xdata$x:00002080                 ;org 2080h
.xdata$x:00002080 ; COMDAT (pick associative to section at C30)
.xdata$x:00002080 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00002080                                         ; DATA XREF: .xdata$x:00002090o
.xdata$x:00002081                 db 0FFh
.xdata$x:00002082                 db 0FFh
.xdata$x:00002083                 db 0FFh
.xdata$x:00002084                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00002088 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00002088                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00002089                 db    5
.xdata$x:0000208A                 db  93h ; 
.xdata$x:0000208B                 db  19h
.xdata$x:0000208C                 db    1
.xdata$x:0000208D                 db    0
.xdata$x:0000208E                 db    0
.xdata$x:0000208F                 db    0
.xdata$x:00002090                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00002094                 db    0
.xdata$x:00002095                 db    0
.xdata$x:00002096                 db    0
.xdata$x:00002097                 db    0
.xdata$x:00002098                 db    0
.xdata$x:00002099                 db    0
.xdata$x:0000209A                 db    0
.xdata$x:0000209B                 db    0
.xdata$x:0000209C                 db    0
.xdata$x:0000209D                 db    0
.xdata$x:0000209E                 db    0
.xdata$x:0000209F                 db    0
.xdata$x:000020A0                 db    0
.xdata$x:000020A1                 db    0
.xdata$x:000020A2                 db    0
.xdata$x:000020A3                 db    0
.xdata$x:000020A4                 db    0
.xdata$x:000020A5                 db    0
.xdata$x:000020A6                 db    0
.xdata$x:000020A7                 db    0
.xdata$x:000020A8                 db    0
.xdata$x:000020A9                 db    0
.xdata$x:000020AA                 db    0
.xdata$x:000020AB                 db    0
.xdata$x:000020AB _xdata$x        ends
.xdata$x:000020AB
.xdata$x:000020AC ; ===========================================================================
.xdata$x:000020AC
.xdata$x:000020AC ; Segment type: Pure data
.xdata$x:000020AC ; Segment permissions: Read
.xdata$x:000020AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000020AC                 assume cs:_xdata$x
.xdata$x:000020AC                 ;org 20ACh
.xdata$x:000020AC ; COMDAT (pick associative to section at 698)
.xdata$x:000020AC __unwindtable$??0HandleUniversalDetector@@QAE@XZ db 0FFh
.xdata$x:000020AC                                         ; DATA XREF: .xdata$x:000020C4o
.xdata$x:000020AD                 db 0FFh
.xdata$x:000020AE                 db 0FFh
.xdata$x:000020AF                 db 0FFh
.xdata$x:000020B0                 dd offset __unwindfunclet$??0HandleUniversalDetector@@QAE@XZ$0
.xdata$x:000020B4                 align 8
.xdata$x:000020B8                 dd offset __unwindfunclet$??0HandleUniversalDetector@@QAE@XZ$1
.xdata$x:000020BC __ehfuncinfo$??0HandleUniversalDetector@@QAE@XZ db  22h ; "
.xdata$x:000020BC                                         ; DATA XREF: __ehhandler$??0HandleUniversalDetector@@QAE@XZ+11o
.xdata$x:000020BD                 db    5
.xdata$x:000020BE                 db  93h ; 
.xdata$x:000020BF                 db  19h
.xdata$x:000020C0                 db    2
.xdata$x:000020C1                 db    0
.xdata$x:000020C2                 db    0
.xdata$x:000020C3                 db    0
.xdata$x:000020C4                 dd offset __unwindtable$??0HandleUniversalDetector@@QAE@XZ
.xdata$x:000020C8                 align 20h
.xdata$x:000020C8 _xdata$x        ends
.xdata$x:000020C8
.xdata$x:000020E0 ; ===========================================================================
.xdata$x:000020E0
.xdata$x:000020E0 ; Segment type: Pure data
.xdata$x:000020E0 ; Segment permissions: Read
.xdata$x:000020E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000020E0                 assume cs:_xdata$x
.xdata$x:000020E0                 ;org 20E0h
.xdata$x:000020E0 ; COMDAT (pick associative to section at AA8)
.xdata$x:000020E0 __unwindtable$??1HandleUniversalDetector@@UAE@XZ db 0FFh
.xdata$x:000020E0                                         ; DATA XREF: .xdata$x:000020F8o
.xdata$x:000020E1                 db 0FFh
.xdata$x:000020E2                 db 0FFh
.xdata$x:000020E3                 db 0FFh
.xdata$x:000020E4                 dd offset __unwindfunclet$??1HandleUniversalDetector@@UAE@XZ$0
.xdata$x:000020E8                 db    0
.xdata$x:000020E9                 db    0
.xdata$x:000020EA                 db    0
.xdata$x:000020EB                 db    0
.xdata$x:000020EC                 dd offset __unwindfunclet$??1HandleUniversalDetector@@UAE@XZ$1
.xdata$x:000020F0 __ehfuncinfo$??1HandleUniversalDetector@@UAE@XZ db  22h ; "
.xdata$x:000020F0                                         ; DATA XREF: __ehhandler$??1HandleUniversalDetector@@UAE@XZ+11o
.xdata$x:000020F1                 db    5
.xdata$x:000020F2                 db  93h ; 
.xdata$x:000020F3                 db  19h
.xdata$x:000020F4                 db    2
.xdata$x:000020F5                 db    0
.xdata$x:000020F6                 db    0
.xdata$x:000020F7                 db    0
.xdata$x:000020F8                 dd offset __unwindtable$??1HandleUniversalDetector@@UAE@XZ
.xdata$x:000020FC                 db    0
.xdata$x:000020FD                 db    0
.xdata$x:000020FE                 db    0
.xdata$x:000020FF                 db    0
.xdata$x:00002100                 db    0
.xdata$x:00002101                 db    0
.xdata$x:00002102                 db    0
.xdata$x:00002103                 db    0
.xdata$x:00002104                 db    0
.xdata$x:00002105                 db    0
.xdata$x:00002106                 db    0
.xdata$x:00002107                 db    0
.xdata$x:00002108                 db    0
.xdata$x:00002109                 db    0
.xdata$x:0000210A                 db    0
.xdata$x:0000210B                 db    0
.xdata$x:0000210C                 db    0
.xdata$x:0000210D                 db    0
.xdata$x:0000210E                 db    0
.xdata$x:0000210F                 db    0
.xdata$x:00002110                 db    0
.xdata$x:00002111                 db    0
.xdata$x:00002112                 db    0
.xdata$x:00002113                 db    0
.xdata$x:00002113 _xdata$x        ends
.xdata$x:00002113
.xdata$x:00002114 ; ===========================================================================
.xdata$x:00002114
.xdata$x:00002114 ; Segment type: Pure data
.xdata$x:00002114 ; Segment permissions: Read
.xdata$x:00002114 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002114                 assume cs:_xdata$x
.xdata$x:00002114                 ;org 2114h
.xdata$x:00002114 ; COMDAT (pick associative to section at 31C)
.xdata$x:00002114 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00002114                                         ; DATA XREF: .xdata$x:00002124o
.xdata$x:00002115                 db 0FFh
.xdata$x:00002116                 db 0FFh
.xdata$x:00002117                 db 0FFh
.xdata$x:00002118                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:0000211C __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:0000211C                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:0000211D                 db    5
.xdata$x:0000211E                 db  93h ; 
.xdata$x:0000211F                 db  19h
.xdata$x:00002120                 db    1
.xdata$x:00002121                 db    0
.xdata$x:00002122                 db    0
.xdata$x:00002123                 db    0
.xdata$x:00002124                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00002128                 align 20h
.xdata$x:00002128 _xdata$x        ends
.xdata$x:00002128
.xdata$x:00002140 ; ===========================================================================
.xdata$x:00002140
.xdata$x:00002140 ; Segment type: Pure data
.xdata$x:00002140 ; Segment permissions: Read
.xdata$x:00002140 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002140                 assume cs:_xdata$x
.xdata$x:00002140                 ;org 2140h
.xdata$x:00002140 ; COMDAT (pick associative to section at 248)
.xdata$x:00002140 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00002140                                         ; DATA XREF: .xdata$x:00002150o
.xdata$x:00002141                 db 0FFh
.xdata$x:00002142                 db 0FFh
.xdata$x:00002143                 db 0FFh
.xdata$x:00002144                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00002148 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00002148                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00002149                 db    5
.xdata$x:0000214A                 db  93h ; 
.xdata$x:0000214B                 db  19h
.xdata$x:0000214C                 db    1
.xdata$x:0000214D                 db    0
.xdata$x:0000214E                 db    0
.xdata$x:0000214F                 db    0
.xdata$x:00002150                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00002154                 db    0
.xdata$x:00002155                 db    0
.xdata$x:00002156                 db    0
.xdata$x:00002157                 db    0
.xdata$x:00002158                 db    0
.xdata$x:00002159                 db    0
.xdata$x:0000215A                 db    0
.xdata$x:0000215B                 db    0
.xdata$x:0000215C                 db    0
.xdata$x:0000215D                 db    0
.xdata$x:0000215E                 db    0
.xdata$x:0000215F                 db    0
.xdata$x:00002160                 db    0
.xdata$x:00002161                 db    0
.xdata$x:00002162                 db    0
.xdata$x:00002163                 db    0
.xdata$x:00002164                 db    0
.xdata$x:00002165                 db    0
.xdata$x:00002166                 db    0
.xdata$x:00002167                 db    0
.xdata$x:00002168                 db    0
.xdata$x:00002169                 db    0
.xdata$x:0000216A                 db    0
.xdata$x:0000216B                 db    0
.xdata$x:0000216B _xdata$x        ends
.xdata$x:0000216B
.bss:0000216C ; ===========================================================================
.bss:0000216C
.bss:0000216C ; Segment type: Uninitialized
.bss:0000216C ; Segment permissions: Read/Write
.bss:0000216C _bss            segment byte public 'BSS' use32
.bss:0000216C                 assume cs:_bss
.bss:0000216C                 ;org 216Ch
.bss:0000216C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:0000216C _allocator_arg  db    ? ;
.bss:0000216D _piecewise_construct db    ? ;
.bss:0000216E                 align 10h
.bss:0000216E _bss            ends
.bss:0000216E
.rdata:00002170 ; ===========================================================================
.rdata:00002170
.rdata:00002170 ; Segment type: Pure data
.rdata:00002170 ; Segment permissions: Read
.rdata:00002170 _rdata          segment byte public 'DATA' use32
.rdata:00002170                 assume cs:_rdata
.rdata:00002170                 ;org 2170h
.rdata:00002170 ; COMDAT (pick any)
.rdata:00002170                 public ??_C@_00CNPNBAHC@?$AA@
.rdata:00002170 ; char `string'
.rdata:00002170 ??_C@_00CNPNBAHC@?$AA@ db 0             ; DATA XREF: HandleUniversalDetector::HandleUniversalDetector(void)+4Fo
.rdata:00002170                                         ; HandleUniversalDetector::Reset(void)+Fo
.rdata:00002171                 align 4
.rdata:00002171 _rdata          ends
.rdata:00002171
.rdata:00002174 ; ===========================================================================
.rdata:00002174
.rdata:00002174 ; Segment type: Pure data
.rdata:00002174 ; Segment permissions: Read
.rdata:00002174 _rdata          segment dword public 'DATA' use32
.rdata:00002174                 assume cs:_rdata
.rdata:00002174                 ;org 2174h
.rdata:00002174 ; COMDAT (pick largest)
.rdata:00002174                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00002178                 public ??_7error_category@std@@6B@
.rdata:00002178 ; const std::error_category::`vftable'
.rdata:00002178 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00002178                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00002178                                         ; std::error_category::~error_category(void)+Ao
.rdata:00002178                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:0000217C                 dd offset __purecall
.rdata:00002180                 dd offset __purecall
.rdata:00002184                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00002188                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000218C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000218C _rdata          ends
.rdata:0000218C
.rdata:00002190 ; ===========================================================================
.rdata:00002190
.rdata:00002190 ; Segment type: Pure data
.rdata:00002190 ; Segment permissions: Read
.rdata:00002190 _rdata          segment dword public 'DATA' use32
.rdata:00002190                 assume cs:_rdata
.rdata:00002190                 ;org 2190h
.rdata:00002190 ; COMDAT (pick largest)
.rdata:00002190                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00002194                 public ??_7_Generic_error_category@std@@6B@
.rdata:00002194 ; const std::_Generic_error_category::`vftable'
.rdata:00002194 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00002194                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00002194                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00002198                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:0000219C                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:000021A0                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000021A4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000021A8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000021A8 _rdata          ends
.rdata:000021A8
.rdata:000021AC ; ===========================================================================
.rdata:000021AC
.rdata:000021AC ; Segment type: Pure data
.rdata:000021AC ; Segment permissions: Read
.rdata:000021AC _rdata          segment dword public 'DATA' use32
.rdata:000021AC                 assume cs:_rdata
.rdata:000021AC                 ;org 21ACh
.rdata:000021AC ; COMDAT (pick any)
.rdata:000021AC                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:000021AC ; `string'
.rdata:000021AC ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:000021AC                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:000021AC _rdata          ends
.rdata:000021AC
.rdata:000021B4 ; ===========================================================================
.rdata:000021B4
.rdata:000021B4 ; Segment type: Pure data
.rdata:000021B4 ; Segment permissions: Read
.rdata:000021B4 _rdata          segment dword public 'DATA' use32
.rdata:000021B4                 assume cs:_rdata
.rdata:000021B4                 ;org 21B4h
.rdata:000021B4 ; COMDAT (pick any)
.rdata:000021B4                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:000021B4 ; `string'
.rdata:000021B4 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:000021B4                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_1A58o
.rdata:000021B4                                         ; std::_System_error_category::message(int):loc_1BD4o
.rdata:000021C2                 align 4
.rdata:000021C2 _rdata          ends
.rdata:000021C2
.rdata:000021C4 ; ===========================================================================
.rdata:000021C4
.rdata:000021C4 ; Segment type: Pure data
.rdata:000021C4 ; Segment permissions: Read
.rdata:000021C4 _rdata          segment dword public 'DATA' use32
.rdata:000021C4                 assume cs:_rdata
.rdata:000021C4                 ;org 21C4h
.rdata:000021C4 ; COMDAT (pick largest)
.rdata:000021C4                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:000021C8                 public ??_7_Iostream_error_category@std@@6B@
.rdata:000021C8 ; const std::_Iostream_error_category::`vftable'
.rdata:000021C8 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:000021C8                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:000021C8                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:000021CC                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:000021D0                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:000021D4                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000021D8                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000021DC                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000021DC _rdata          ends
.rdata:000021DC
.rdata:000021E0 ; ===========================================================================
.rdata:000021E0
.rdata:000021E0 ; Segment type: Pure data
.rdata:000021E0 ; Segment permissions: Read
.rdata:000021E0 _rdata          segment dword public 'DATA' use32
.rdata:000021E0                 assume cs:_rdata
.rdata:000021E0                 ;org 21E0h
.rdata:000021E0 ; COMDAT (pick any)
.rdata:000021E0                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:000021E0 ; `string'
.rdata:000021E0 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:000021E0                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:000021E9                 align 4
.rdata:000021E9 _rdata          ends
.rdata:000021E9
.rdata:000021EC ; ===========================================================================
.rdata:000021EC
.rdata:000021EC ; Segment type: Pure data
.rdata:000021EC ; Segment permissions: Read
.rdata:000021EC _rdata          segment dword public 'DATA' use32
.rdata:000021EC                 assume cs:_rdata
.rdata:000021EC                 ;org 21ECh
.rdata:000021EC ; COMDAT (pick any)
.rdata:000021EC                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:000021EC ; char `string'[]
.rdata:000021EC ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:000021EC                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00002202                 align 4
.rdata:00002202 _rdata          ends
.rdata:00002202
.rdata:00002204 ; ===========================================================================
.rdata:00002204
.rdata:00002204 ; Segment type: Pure data
.rdata:00002204 ; Segment permissions: Read
.rdata:00002204 _rdata          segment dword public 'DATA' use32
.rdata:00002204                 assume cs:_rdata
.rdata:00002204                 ;org 2204h
.rdata:00002204 ; COMDAT (pick largest)
.rdata:00002204                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00002208                 public ??_7_System_error_category@std@@6B@
.rdata:00002208 ; const std::_System_error_category::`vftable'
.rdata:00002208 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00002208                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00002208                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:0000220C                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00002210                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00002214                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00002218                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000221C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000221C _rdata          ends
.rdata:0000221C
.rdata:00002220 ; ===========================================================================
.rdata:00002220
.rdata:00002220 ; Segment type: Pure data
.rdata:00002220 ; Segment permissions: Read
.rdata:00002220 _rdata          segment dword public 'DATA' use32
.rdata:00002220                 assume cs:_rdata
.rdata:00002220                 ;org 2220h
.rdata:00002220 ; COMDAT (pick any)
.rdata:00002220                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00002220 ; `string'
.rdata:00002220 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00002220                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00002227                 align 4
.rdata:00002227 _rdata          ends
.rdata:00002227
.bss:00002228 ; ===========================================================================
.bss:00002228
.bss:00002228 ; Segment type: Uninitialized
.bss:00002228 ; Segment permissions: Read/Write
.bss:00002228 _bss            segment dword public 'BSS' use32
.bss:00002228                 assume cs:_bss
.bss:00002228                 ;org 2228h
.bss:00002228 ; COMDAT (pick any)
.bss:00002228                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002228                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00002228 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00002228 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00002228                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00002228                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00002229                 db    ? ;
.bss:0000222A                 db    ? ;
.bss:0000222B                 db    ? ;
.bss:0000222B _bss            ends
.bss:0000222B
.bss:0000222C ; ===========================================================================
.bss:0000222C
.bss:0000222C ; Segment type: Uninitialized
.bss:0000222C ; Segment permissions: Read/Write
.bss:0000222C _bss            segment dword public 'BSS' use32
.bss:0000222C                 assume cs:_bss
.bss:0000222C                 ;org 222Ch
.bss:0000222C ; COMDAT (pick any)
.bss:0000222C                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:0000222C                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:0000222C ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:0000222C ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:0000222C                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000222C                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000222D                 db    ? ;
.bss:0000222E                 db    ? ;
.bss:0000222F                 db    ? ;
.bss:0000222F _bss            ends
.bss:0000222F
.bss:00002230 ; ===========================================================================
.bss:00002230
.bss:00002230 ; Segment type: Uninitialized
.bss:00002230 ; Segment permissions: Read/Write
.bss:00002230 _bss            segment dword public 'BSS' use32
.bss:00002230                 assume cs:_bss
.bss:00002230                 ;org 2230h
.bss:00002230 ; COMDAT (pick any)
.bss:00002230                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002230                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00002230 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00002230 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00002230                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00002230                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00002231                 db    ? ;
.bss:00002232                 db    ? ;
.bss:00002233                 db    ? ;
.bss:00002233 _bss            ends
.bss:00002233
.bss:00002234 ; ===========================================================================
.bss:00002234
.bss:00002234 ; Segment type: Uninitialized
.bss:00002234 ; Segment permissions: Read/Write
.bss:00002234 _bss            segment dword public 'BSS' use32
.bss:00002234                 assume cs:_bss
.bss:00002234                 ;org 2234h
.bss:00002234 ; COMDAT (pick any)
.bss:00002234                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002234                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002234 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00002234 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002234                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00002235                 db    ? ;
.bss:00002236                 db    ? ;
.bss:00002237                 db    ? ;
.bss:00002237 _bss            ends
.bss:00002237
.bss:00002238 ; ===========================================================================
.bss:00002238
.bss:00002238 ; Segment type: Uninitialized
.bss:00002238 ; Segment permissions: Read/Write
.bss:00002238 _bss            segment dword public 'BSS' use32
.bss:00002238                 assume cs:_bss
.bss:00002238                 ;org 2238h
.bss:00002238 ; COMDAT (pick any)
.bss:00002238                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:00002238                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00002238 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00002238 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00002238                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00002239                 db    ? ;
.bss:0000223A                 db    ? ;
.bss:0000223B                 db    ? ;
.bss:0000223B _bss            ends
.bss:0000223B
.rdata:0000223C ; ===========================================================================
.rdata:0000223C
.rdata:0000223C ; Segment type: Pure data
.rdata:0000223C ; Segment permissions: Read
.rdata:0000223C _rdata          segment dword public 'DATA' use32
.rdata:0000223C                 assume cs:_rdata
.rdata:0000223C                 ;org 223Ch
.rdata:0000223C ; COMDAT (pick largest)
.rdata:0000223C                 dd offset ??_R4HandleUniversalDetector@@6B@ ; const HandleUniversalDetector::`RTTI Complete Object Locator'
.rdata:00002240                 public ??_7HandleUniversalDetector@@6B@
.rdata:00002240 ; const HandleUniversalDetector::`vftable'
.rdata:00002240 ??_7HandleUniversalDetector@@6B@ dd offset ??_EHandleUniversalDetector@@UAEPAXI@Z
.rdata:00002240                                         ; DATA XREF: HandleUniversalDetector::HandleUniversalDetector(void)+3Ao
.rdata:00002240                                         ; HandleUniversalDetector::~HandleUniversalDetector(void)+29o
.rdata:00002240                                         ; HandleUniversalDetector::`vector deleting destructor'(uint)
.rdata:00002244                 dd offset ?HandleData@nsUniversalDetector@@UAE?AW4nsresult@@PBDI@Z ; nsUniversalDetector::HandleData(char const *,uint)
.rdata:00002248                 dd offset ?DataEnd@nsUniversalDetector@@UAEXXZ ; nsUniversalDetector::DataEnd(void)
.rdata:0000224C                 dd offset ?Report@HandleUniversalDetector@@UAEXPBD@Z ; HandleUniversalDetector::Report(char const *)
.rdata:00002250                 dd offset ?Reset@HandleUniversalDetector@@UAEXXZ ; HandleUniversalDetector::Reset(void)
.rdata:00002250 _rdata          ends
.rdata:00002250
.rdata:00002254 ; ===========================================================================
.rdata:00002254
.rdata:00002254 ; Segment type: Pure data
.rdata:00002254 ; Segment permissions: Read
.rdata:00002254 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00002254 _rdata          segment para public 'DATA' use32
.rdata:00002254                 assume cs:_rdata
.rdata:00002254                 ;org 2254h
.rdata:00002254 ; COMDAT (pick any)
.rdata:00002254                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00002254 ; wchar_t `string'
.rdata:00002254 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00002254                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00002254                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00002254                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00002254                 unicode 0, <clude\xstring>,0
.rdata:000022E2                 align 4
.rdata:000022E2 _rdata          ends
.rdata:000022E2
.bss:000022E4 ; ===========================================================================
.bss:000022E4
.bss:000022E4 ; Segment type: Uninitialized
.bss:000022E4 ; Segment permissions: Read/Write
.bss:000022E4 _bss            segment dword public 'BSS' use32
.bss:000022E4                 assume cs:_bss
.bss:000022E4                 ;org 22E4h
.bss:000022E4 ; COMDAT (pick any)
.bss:000022E4                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:000022E4                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:000022E4 ; std::locale::id std::numpunct<char>::id
.bss:000022E4 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:000022E4                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:000022E5                 db    ? ;
.bss:000022E6                 db    ? ;
.bss:000022E7                 db    ? ;
.bss:000022E7 _bss            ends
.bss:000022E7
.bss:000022E8 ; ===========================================================================
.bss:000022E8
.bss:000022E8 ; Segment type: Uninitialized
.bss:000022E8 ; Segment permissions: Read/Write
.bss:000022E8 _bss            segment dword public 'BSS' use32
.bss:000022E8                 assume cs:_bss
.bss:000022E8                 ;org 22E8h
.bss:000022E8 ; COMDAT (pick any)
.bss:000022E8                 assume es:nothing, ss:nothing, ds:_xdata$x, fs:nothing, gs:nothing
.bss:000022E8                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:000022E8 ; std::locale::id std::numpunct<wchar_t>::id
.bss:000022E8 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:000022E8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:000022E9                 db    ? ;
.bss:000022EA                 db    ? ;
.bss:000022EB                 db    ? ;
.bss:000022EB _bss            ends
.bss:000022EB
.rdata:000022EC ; ===========================================================================
.rdata:000022EC
.rdata:000022EC ; Segment type: Pure data
.rdata:000022EC ; Segment permissions: Read
.rdata:000022EC _rdata          segment dword public 'DATA' use32
.rdata:000022EC                 assume cs:_rdata
.rdata:000022EC                 ;org 22ECh
.rdata:000022EC ; COMDAT (pick any)
.rdata:000022EC                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:000022EC ; char `string'[]
.rdata:000022EC ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:000022EC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:000022EC _rdata          ends
.rdata:000022EC
.rdata:000022FC ; ===========================================================================
.rdata:000022FC
.rdata:000022FC ; Segment type: Pure data
.rdata:000022FC ; Segment permissions: Read
.rdata:000022FC _rdata          segment dword public 'DATA' use32
.rdata:000022FC                 assume cs:_rdata
.rdata:000022FC                 ;org 22FCh
.rdata:000022FC ; COMDAT (pick any)
.rdata:000022FC                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:000022FC ; char `string'[]
.rdata:000022FC ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:000022FC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:000022FC _rdata          ends
.rdata:000022FC
.rdata:00002314 ; ===========================================================================
.rdata:00002314
.rdata:00002314 ; Segment type: Pure data
.rdata:00002314 ; Segment permissions: Read
.rdata:00002314 _rdata          segment dword public 'DATA' use32
.rdata:00002314                 assume cs:_rdata
.rdata:00002314                 ;org 2314h
.rdata:00002314 ; COMDAT (pick any)
.rdata:00002314                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00002314 ; wchar_t `string'
.rdata:00002314 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00002314                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00002314                 unicode 0, <invalid null pointer>,0
.rdata:0000233E                 align 10h
.rdata:0000233E _rdata          ends
.rdata:0000233E
.rdata$r:00002340 ; ===========================================================================
.rdata$r:00002340
.rdata$r:00002340 ; Segment type: Pure data
.rdata$r:00002340 ; Segment permissions: Read
.rdata$r:00002340 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002340                 assume cs:_rdata$r
.rdata$r:00002340                 ;org 2340h
.rdata$r:00002340 ; COMDAT (pick any)
.rdata$r:00002340                 public ??_R4error_category@std@@6B@
.rdata$r:00002340 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00002340 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00002174o
.rdata$r:00002341                 db    0
.rdata$r:00002342                 db    0
.rdata$r:00002343                 db    0
.rdata$r:00002344                 db    0
.rdata$r:00002345                 db    0
.rdata$r:00002346                 db    0
.rdata$r:00002347                 db    0
.rdata$r:00002348                 db    0
.rdata$r:00002349                 db    0
.rdata$r:0000234A                 db    0
.rdata$r:0000234B                 db    0
.rdata$r:0000234C                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002350                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002350 _rdata$r        ends
.rdata$r:00002350
.data$r:00002354 ; ===========================================================================
.data$r:00002354
.data$r:00002354 ; Segment type: Pure data
.data$r:00002354 ; Segment permissions: Read/Write
.data$r:00002354 _data$r         segment dword public 'DATA' use32
.data$r:00002354                 assume cs:_data$r
.data$r:00002354                 ;org 2354h
.data$r:00002354 ; COMDAT (pick any)
.data$r:00002354                 public ??_R0?AVerror_category@std@@@8
.data$r:00002354 ; class std::error_category `RTTI Type Descriptor'
.data$r:00002354 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002354                                         ; DATA XREF: .rdata$r:0000234Co
.data$r:00002354                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002354                                         ; const type_info::`vftable'
.data$r:00002358                 db    0
.data$r:00002359                 db    0
.data$r:0000235A                 db    0
.data$r:0000235B                 db    0
.data$r:0000235C                 db  2Eh ; .
.data$r:0000235D                 db  3Fh ; ?
.data$r:0000235E                 db  41h ; A
.data$r:0000235F                 db  56h ; V
.data$r:00002360                 db  65h ; e
.data$r:00002361                 db  72h ; r
.data$r:00002362                 db  72h ; r
.data$r:00002363                 db  6Fh ; o
.data$r:00002364                 db  72h ; r
.data$r:00002365                 db  5Fh ; _
.data$r:00002366                 db  63h ; c
.data$r:00002367                 db  61h ; a
.data$r:00002368                 db  74h ; t
.data$r:00002369                 db  65h ; e
.data$r:0000236A                 db  67h ; g
.data$r:0000236B                 db  6Fh ; o
.data$r:0000236C                 db  72h ; r
.data$r:0000236D                 db  79h ; y
.data$r:0000236E                 db  40h ; @
.data$r:0000236F                 db  73h ; s
.data$r:00002370                 db  74h ; t
.data$r:00002371                 db  64h ; d
.data$r:00002372                 db  40h ; @
.data$r:00002373                 db  40h ; @
.data$r:00002374                 db    0
.data$r:00002375                 align 4
.data$r:00002375 _data$r         ends
.data$r:00002375
.rdata$r:00002378 ; ===========================================================================
.rdata$r:00002378
.rdata$r:00002378 ; Segment type: Pure data
.rdata$r:00002378 ; Segment permissions: Read
.rdata$r:00002378 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002378                 assume cs:_rdata$r
.rdata$r:00002378                 ;org 2378h
.rdata$r:00002378 ; COMDAT (pick any)
.rdata$r:00002378                 public ??_R3error_category@std@@8
.rdata$r:00002378 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002378 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00002350o
.rdata$r:00002378                                         ; .rdata$r:000023A8o
.rdata$r:00002379                 db    0
.rdata$r:0000237A                 db    0
.rdata$r:0000237B                 db    0
.rdata$r:0000237C                 db    0
.rdata$r:0000237D                 db    0
.rdata$r:0000237E                 db    0
.rdata$r:0000237F                 db    0
.rdata$r:00002380                 db    1
.rdata$r:00002381                 db    0
.rdata$r:00002382                 db    0
.rdata$r:00002383                 db    0
.rdata$r:00002384                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002384 _rdata$r        ends
.rdata$r:00002384
.rdata$r:00002388 ; ===========================================================================
.rdata$r:00002388
.rdata$r:00002388 ; Segment type: Pure data
.rdata$r:00002388 ; Segment permissions: Read
.rdata$r:00002388 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002388                 assume cs:_rdata$r
.rdata$r:00002388                 ;org 2388h
.rdata$r:00002388 ; COMDAT (pick any)
.rdata$r:00002388                 public ??_R2error_category@std@@8
.rdata$r:00002388 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00002388 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002388                                         ; DATA XREF: .rdata$r:00002384o
.rdata$r:00002388                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000238C                 db    0
.rdata$r:0000238D                 align 10h
.rdata$r:0000238D _rdata$r        ends
.rdata$r:0000238D
.rdata$r:00002390 ; ===========================================================================
.rdata$r:00002390
.rdata$r:00002390 ; Segment type: Pure data
.rdata$r:00002390 ; Segment permissions: Read
.rdata$r:00002390 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002390                 assume cs:_rdata$r
.rdata$r:00002390                 ;org 2390h
.rdata$r:00002390 ; COMDAT (pick any)
.rdata$r:00002390                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00002390 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002390 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00002390                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00002390                                         ; .rdata$r:00002400o ...
.rdata$r:00002390                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00002394                 db    0
.rdata$r:00002395                 db    0
.rdata$r:00002396                 db    0
.rdata$r:00002397                 db    0
.rdata$r:00002398                 db    0
.rdata$r:00002399                 db    0
.rdata$r:0000239A                 db    0
.rdata$r:0000239B                 db    0
.rdata$r:0000239C                 db 0FFh
.rdata$r:0000239D                 db 0FFh
.rdata$r:0000239E                 db 0FFh
.rdata$r:0000239F                 db 0FFh
.rdata$r:000023A0                 db    0
.rdata$r:000023A1                 db    0
.rdata$r:000023A2                 db    0
.rdata$r:000023A3                 db    0
.rdata$r:000023A4                 db  40h ; @
.rdata$r:000023A5                 db    0
.rdata$r:000023A6                 db    0
.rdata$r:000023A7                 db    0
.rdata$r:000023A8                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000023A8 _rdata$r        ends
.rdata$r:000023A8
.rdata$r:000023AC ; ===========================================================================
.rdata$r:000023AC
.rdata$r:000023AC ; Segment type: Pure data
.rdata$r:000023AC ; Segment permissions: Read
.rdata$r:000023AC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000023AC                 assume cs:_rdata$r
.rdata$r:000023AC                 ;org 23ACh
.rdata$r:000023AC ; COMDAT (pick any)
.rdata$r:000023AC                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:000023AC ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:000023AC ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:000023AC                                         ; DATA XREF: .rdata:00002190o
.rdata$r:000023AD                 db    0
.rdata$r:000023AE                 db    0
.rdata$r:000023AF                 db    0
.rdata$r:000023B0                 db    0
.rdata$r:000023B1                 db    0
.rdata$r:000023B2                 db    0
.rdata$r:000023B3                 db    0
.rdata$r:000023B4                 db    0
.rdata$r:000023B5                 db    0
.rdata$r:000023B6                 db    0
.rdata$r:000023B7                 db    0
.rdata$r:000023B8                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000023BC                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000023BC _rdata$r        ends
.rdata$r:000023BC
.data$r:000023C0 ; ===========================================================================
.data$r:000023C0
.data$r:000023C0 ; Segment type: Pure data
.data$r:000023C0 ; Segment permissions: Read/Write
.data$r:000023C0 _data$r         segment dword public 'DATA' use32
.data$r:000023C0                 assume cs:_data$r
.data$r:000023C0                 ;org 23C0h
.data$r:000023C0 ; COMDAT (pick any)
.data$r:000023C0                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:000023C0 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:000023C0 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000023C0                                         ; DATA XREF: .rdata$r:000023B8o
.data$r:000023C0                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000023C0                                         ; const type_info::`vftable'
.data$r:000023C4                 align 8
.data$r:000023C8 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:000023EA                 align 4
.data$r:000023EA _data$r         ends
.data$r:000023EA
.rdata$r:000023EC ; ===========================================================================
.rdata$r:000023EC
.rdata$r:000023EC ; Segment type: Pure data
.rdata$r:000023EC ; Segment permissions: Read
.rdata$r:000023EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000023EC                 assume cs:_rdata$r
.rdata$r:000023EC                 ;org 23ECh
.rdata$r:000023EC ; COMDAT (pick any)
.rdata$r:000023EC                 public ??_R3_Generic_error_category@std@@8
.rdata$r:000023EC ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000023EC ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:000023EC                                         ; DATA XREF: .rdata$r:000023BCo
.rdata$r:000023EC                                         ; .rdata$r:00002420o
.rdata$r:000023ED                 db    0
.rdata$r:000023EE                 db    0
.rdata$r:000023EF                 db    0
.rdata$r:000023F0                 db    0
.rdata$r:000023F1                 db    0
.rdata$r:000023F2                 db    0
.rdata$r:000023F3                 db    0
.rdata$r:000023F4                 db    2
.rdata$r:000023F5                 db    0
.rdata$r:000023F6                 db    0
.rdata$r:000023F7                 db    0
.rdata$r:000023F8                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000023F8 _rdata$r        ends
.rdata$r:000023F8
.rdata$r:000023FC ; ===========================================================================
.rdata$r:000023FC
.rdata$r:000023FC ; Segment type: Pure data
.rdata$r:000023FC ; Segment permissions: Read
.rdata$r:000023FC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000023FC                 assume cs:_rdata$r
.rdata$r:000023FC                 ;org 23FCh
.rdata$r:000023FC ; COMDAT (pick any)
.rdata$r:000023FC                 public ??_R2_Generic_error_category@std@@8
.rdata$r:000023FC ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:000023FC ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:000023FC                                         ; DATA XREF: .rdata$r:000023F8o
.rdata$r:000023FC                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002400                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002404                 db    0
.rdata$r:00002405                 align 4
.rdata$r:00002405 _rdata$r        ends
.rdata$r:00002405
.rdata$r:00002408 ; ===========================================================================
.rdata$r:00002408
.rdata$r:00002408 ; Segment type: Pure data
.rdata$r:00002408 ; Segment permissions: Read
.rdata$r:00002408 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002408                 assume cs:_rdata$r
.rdata$r:00002408                 ;org 2408h
.rdata$r:00002408 ; COMDAT (pick any)
.rdata$r:00002408                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00002408 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002408 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00002408                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00002408                                         ; .rdata$r:00002478o ...
.rdata$r:00002408                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000240C                 db    1
.rdata$r:0000240D                 db    0
.rdata$r:0000240E                 db    0
.rdata$r:0000240F                 db    0
.rdata$r:00002410                 db    0
.rdata$r:00002411                 db    0
.rdata$r:00002412                 db    0
.rdata$r:00002413                 db    0
.rdata$r:00002414                 db 0FFh
.rdata$r:00002415                 db 0FFh
.rdata$r:00002416                 db 0FFh
.rdata$r:00002417                 db 0FFh
.rdata$r:00002418                 db    0
.rdata$r:00002419                 db    0
.rdata$r:0000241A                 db    0
.rdata$r:0000241B                 db    0
.rdata$r:0000241C                 db  40h ; @
.rdata$r:0000241D                 db    0
.rdata$r:0000241E                 db    0
.rdata$r:0000241F                 db    0
.rdata$r:00002420                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002420 _rdata$r        ends
.rdata$r:00002420
.rdata$r:00002424 ; ===========================================================================
.rdata$r:00002424
.rdata$r:00002424 ; Segment type: Pure data
.rdata$r:00002424 ; Segment permissions: Read
.rdata$r:00002424 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002424                 assume cs:_rdata$r
.rdata$r:00002424                 ;org 2424h
.rdata$r:00002424 ; COMDAT (pick any)
.rdata$r:00002424                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00002424 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00002424 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00002424                                         ; DATA XREF: .rdata:000021C4o
.rdata$r:00002425                 db    0
.rdata$r:00002426                 db    0
.rdata$r:00002427                 db    0
.rdata$r:00002428                 db    0
.rdata$r:00002429                 db    0
.rdata$r:0000242A                 db    0
.rdata$r:0000242B                 db    0
.rdata$r:0000242C                 db    0
.rdata$r:0000242D                 db    0
.rdata$r:0000242E                 db    0
.rdata$r:0000242F                 db    0
.rdata$r:00002430                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002434                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002434 _rdata$r        ends
.rdata$r:00002434
.data$r:00002438 ; ===========================================================================
.data$r:00002438
.data$r:00002438 ; Segment type: Pure data
.data$r:00002438 ; Segment permissions: Read/Write
.data$r:00002438 _data$r         segment dword public 'DATA' use32
.data$r:00002438                 assume cs:_data$r
.data$r:00002438                 ;org 2438h
.data$r:00002438 ; COMDAT (pick any)
.data$r:00002438                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00002438 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00002438 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00002438                                         ; DATA XREF: .rdata$r:00002430o
.data$r:00002438                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002438                                         ; const type_info::`vftable'
.data$r:0000243C                 align 10h
.data$r:00002440 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:00002463                 align 4
.data$r:00002463 _data$r         ends
.data$r:00002463
.rdata$r:00002464 ; ===========================================================================
.rdata$r:00002464
.rdata$r:00002464 ; Segment type: Pure data
.rdata$r:00002464 ; Segment permissions: Read
.rdata$r:00002464 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002464                 assume cs:_rdata$r
.rdata$r:00002464                 ;org 2464h
.rdata$r:00002464 ; COMDAT (pick any)
.rdata$r:00002464                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00002464 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002464 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00002464                                         ; DATA XREF: .rdata$r:00002434o
.rdata$r:00002464                                         ; .rdata$r:0000249Co
.rdata$r:00002465                 db    0
.rdata$r:00002466                 db    0
.rdata$r:00002467                 db    0
.rdata$r:00002468                 db    0
.rdata$r:00002469                 db    0
.rdata$r:0000246A                 db    0
.rdata$r:0000246B                 db    0
.rdata$r:0000246C                 db    3
.rdata$r:0000246D                 db    0
.rdata$r:0000246E                 db    0
.rdata$r:0000246F                 db    0
.rdata$r:00002470                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002470 _rdata$r        ends
.rdata$r:00002470
.rdata$r:00002474 ; ===========================================================================
.rdata$r:00002474
.rdata$r:00002474 ; Segment type: Pure data
.rdata$r:00002474 ; Segment permissions: Read
.rdata$r:00002474 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002474                 assume cs:_rdata$r
.rdata$r:00002474                 ;org 2474h
.rdata$r:00002474 ; COMDAT (pick any)
.rdata$r:00002474                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00002474 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00002474 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002474                                         ; DATA XREF: .rdata$r:00002470o
.rdata$r:00002474                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002478                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000247C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002480                 db    0
.rdata$r:00002481                 align 4
.rdata$r:00002481 _rdata$r        ends
.rdata$r:00002481
.rdata$r:00002484 ; ===========================================================================
.rdata$r:00002484
.rdata$r:00002484 ; Segment type: Pure data
.rdata$r:00002484 ; Segment permissions: Read
.rdata$r:00002484 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002484                 assume cs:_rdata$r
.rdata$r:00002484                 ;org 2484h
.rdata$r:00002484 ; COMDAT (pick any)
.rdata$r:00002484                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00002484 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002484 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00002484                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00002484                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00002488                 db    2
.rdata$r:00002489                 db    0
.rdata$r:0000248A                 db    0
.rdata$r:0000248B                 db    0
.rdata$r:0000248C                 db    0
.rdata$r:0000248D                 db    0
.rdata$r:0000248E                 db    0
.rdata$r:0000248F                 db    0
.rdata$r:00002490                 db 0FFh
.rdata$r:00002491                 db 0FFh
.rdata$r:00002492                 db 0FFh
.rdata$r:00002493                 db 0FFh
.rdata$r:00002494                 db    0
.rdata$r:00002495                 db    0
.rdata$r:00002496                 db    0
.rdata$r:00002497                 db    0
.rdata$r:00002498                 db  40h ; @
.rdata$r:00002499                 db    0
.rdata$r:0000249A                 db    0
.rdata$r:0000249B                 db    0
.rdata$r:0000249C                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000249C _rdata$r        ends
.rdata$r:0000249C
.rdata$r:000024A0 ; ===========================================================================
.rdata$r:000024A0
.rdata$r:000024A0 ; Segment type: Pure data
.rdata$r:000024A0 ; Segment permissions: Read
.rdata$r:000024A0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000024A0                 assume cs:_rdata$r
.rdata$r:000024A0                 ;org 24A0h
.rdata$r:000024A0 ; COMDAT (pick any)
.rdata$r:000024A0                 public ??_R4_System_error_category@std@@6B@
.rdata$r:000024A0 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:000024A0 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00002204o
.rdata$r:000024A1                 db    0
.rdata$r:000024A2                 db    0
.rdata$r:000024A3                 db    0
.rdata$r:000024A4                 db    0
.rdata$r:000024A5                 db    0
.rdata$r:000024A6                 db    0
.rdata$r:000024A7                 db    0
.rdata$r:000024A8                 db    0
.rdata$r:000024A9                 db    0
.rdata$r:000024AA                 db    0
.rdata$r:000024AB                 db    0
.rdata$r:000024AC                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000024B0                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000024B0 _rdata$r        ends
.rdata$r:000024B0
.data$r:000024B4 ; ===========================================================================
.data$r:000024B4
.data$r:000024B4 ; Segment type: Pure data
.data$r:000024B4 ; Segment permissions: Read/Write
.data$r:000024B4 _data$r         segment dword public 'DATA' use32
.data$r:000024B4                 assume cs:_data$r
.data$r:000024B4                 ;org 24B4h
.data$r:000024B4 ; COMDAT (pick any)
.data$r:000024B4                 public ??_R0?AV_System_error_category@std@@@8
.data$r:000024B4 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:000024B4 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000024B4                                         ; DATA XREF: .rdata$r:000024ACo
.data$r:000024B4                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000024B4                                         ; const type_info::`vftable'
.data$r:000024B8                 db    0
.data$r:000024B9                 db    0
.data$r:000024BA                 db    0
.data$r:000024BB                 db    0
.data$r:000024BC                 db  2Eh ; .
.data$r:000024BD                 db  3Fh ; ?
.data$r:000024BE                 db  41h ; A
.data$r:000024BF                 db  56h ; V
.data$r:000024C0                 db  5Fh ; _
.data$r:000024C1                 db  53h ; S
.data$r:000024C2                 db  79h ; y
.data$r:000024C3                 db  73h ; s
.data$r:000024C4                 db  74h ; t
.data$r:000024C5                 db  65h ; e
.data$r:000024C6                 db  6Dh ; m
.data$r:000024C7                 db  5Fh ; _
.data$r:000024C8                 db  65h ; e
.data$r:000024C9                 db  72h ; r
.data$r:000024CA                 db  72h ; r
.data$r:000024CB                 db  6Fh ; o
.data$r:000024CC                 db  72h ; r
.data$r:000024CD                 db  5Fh ; _
.data$r:000024CE                 db  63h ; c
.data$r:000024CF                 db  61h ; a
.data$r:000024D0                 db  74h ; t
.data$r:000024D1                 db  65h ; e
.data$r:000024D2                 db  67h ; g
.data$r:000024D3                 db  6Fh ; o
.data$r:000024D4                 db  72h ; r
.data$r:000024D5                 db  79h ; y
.data$r:000024D6                 db  40h ; @
.data$r:000024D7                 db  73h ; s
.data$r:000024D8                 db  74h ; t
.data$r:000024D9                 db  64h ; d
.data$r:000024DA                 db  40h ; @
.data$r:000024DB                 db  40h ; @
.data$r:000024DC                 db    0
.data$r:000024DD                 align 10h
.data$r:000024DD _data$r         ends
.data$r:000024DD
.rdata$r:000024E0 ; ===========================================================================
.rdata$r:000024E0
.rdata$r:000024E0 ; Segment type: Pure data
.rdata$r:000024E0 ; Segment permissions: Read
.rdata$r:000024E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000024E0                 assume cs:_rdata$r
.rdata$r:000024E0                 ;org 24E0h
.rdata$r:000024E0 ; COMDAT (pick any)
.rdata$r:000024E0                 public ??_R3_System_error_category@std@@8
.rdata$r:000024E0 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000024E0 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:000024B0o
.rdata$r:000024E0                                         ; .rdata$r:00002518o
.rdata$r:000024E1                 db    0
.rdata$r:000024E2                 db    0
.rdata$r:000024E3                 db    0
.rdata$r:000024E4                 db    0
.rdata$r:000024E5                 db    0
.rdata$r:000024E6                 db    0
.rdata$r:000024E7                 db    0
.rdata$r:000024E8                 db    3
.rdata$r:000024E9                 db    0
.rdata$r:000024EA                 db    0
.rdata$r:000024EB                 db    0
.rdata$r:000024EC                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000024EC _rdata$r        ends
.rdata$r:000024EC
.rdata$r:000024F0 ; ===========================================================================
.rdata$r:000024F0
.rdata$r:000024F0 ; Segment type: Pure data
.rdata$r:000024F0 ; Segment permissions: Read
.rdata$r:000024F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000024F0                 assume cs:_rdata$r
.rdata$r:000024F0                 ;org 24F0h
.rdata$r:000024F0 ; COMDAT (pick any)
.rdata$r:000024F0                 public ??_R2_System_error_category@std@@8
.rdata$r:000024F0 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:000024F0 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:000024F0                                         ; DATA XREF: .rdata$r:000024ECo
.rdata$r:000024F0                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000024F4                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000024F8                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000024FC                 db    0
.rdata$r:000024FD                 align 10h
.rdata$r:000024FD _rdata$r        ends
.rdata$r:000024FD
.rdata$r:00002500 ; ===========================================================================
.rdata$r:00002500
.rdata$r:00002500 ; Segment type: Pure data
.rdata$r:00002500 ; Segment permissions: Read
.rdata$r:00002500 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002500                 assume cs:_rdata$r
.rdata$r:00002500                 ;org 2500h
.rdata$r:00002500 ; COMDAT (pick any)
.rdata$r:00002500                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00002500 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002500 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00002500                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00002500                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00002504                 db    2
.rdata$r:00002505                 db    0
.rdata$r:00002506                 db    0
.rdata$r:00002507                 db    0
.rdata$r:00002508                 db    0
.rdata$r:00002509                 db    0
.rdata$r:0000250A                 db    0
.rdata$r:0000250B                 db    0
.rdata$r:0000250C                 db 0FFh
.rdata$r:0000250D                 db 0FFh
.rdata$r:0000250E                 db 0FFh
.rdata$r:0000250F                 db 0FFh
.rdata$r:00002510                 db    0
.rdata$r:00002511                 db    0
.rdata$r:00002512                 db    0
.rdata$r:00002513                 db    0
.rdata$r:00002514                 db  40h ; @
.rdata$r:00002515                 db    0
.rdata$r:00002516                 db    0
.rdata$r:00002517                 db    0
.rdata$r:00002518                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002518 _rdata$r        ends
.rdata$r:00002518
.rdata$r:0000251C ; ===========================================================================
.rdata$r:0000251C
.rdata$r:0000251C ; Segment type: Pure data
.rdata$r:0000251C ; Segment permissions: Read
.rdata$r:0000251C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000251C                 assume cs:_rdata$r
.rdata$r:0000251C                 ;org 251Ch
.rdata$r:0000251C ; COMDAT (pick any)
.rdata$r:0000251C                 public ??_R4HandleUniversalDetector@@6B@
.rdata$r:0000251C ; const HandleUniversalDetector::`RTTI Complete Object Locator'
.rdata$r:0000251C ??_R4HandleUniversalDetector@@6B@ db    0 ; DATA XREF: .rdata:0000223Co
.rdata$r:0000251D                 db    0
.rdata$r:0000251E                 db    0
.rdata$r:0000251F                 db    0
.rdata$r:00002520                 db    0
.rdata$r:00002521                 db    0
.rdata$r:00002522                 db    0
.rdata$r:00002523                 db    0
.rdata$r:00002524                 db    0
.rdata$r:00002525                 db    0
.rdata$r:00002526                 db    0
.rdata$r:00002527                 db    0
.rdata$r:00002528                 dd offset ??_R0?AVHandleUniversalDetector@@@8 ; HandleUniversalDetector `RTTI Type Descriptor'
.rdata$r:0000252C                 dd offset ??_R3HandleUniversalDetector@@8 ; HandleUniversalDetector::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000252C _rdata$r        ends
.rdata$r:0000252C
.data$r:00002530 ; ===========================================================================
.data$r:00002530
.data$r:00002530 ; Segment type: Pure data
.data$r:00002530 ; Segment permissions: Read/Write
.data$r:00002530 _data$r         segment dword public 'DATA' use32
.data$r:00002530                 assume cs:_data$r
.data$r:00002530                 ;org 2530h
.data$r:00002530 ; COMDAT (pick any)
.data$r:00002530                 public ??_R0?AVHandleUniversalDetector@@@8
.data$r:00002530 ; class HandleUniversalDetector `RTTI Type Descriptor'
.data$r:00002530 ??_R0?AVHandleUniversalDetector@@@8 dd offset ??_7type_info@@6B@
.data$r:00002530                                         ; DATA XREF: .rdata$r:00002528o
.data$r:00002530                                         ; .rdata$r:HandleUniversalDetector::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00002530                                         ; const type_info::`vftable'
.data$r:00002534                 align 8
.data$r:00002538 a_?avhandleuniv db '.?AVHandleUniversalDetector@@',0
.data$r:00002556                 align 4
.data$r:00002556 _data$r         ends
.data$r:00002556
.rdata$r:00002558 ; ===========================================================================
.rdata$r:00002558
.rdata$r:00002558 ; Segment type: Pure data
.rdata$r:00002558 ; Segment permissions: Read
.rdata$r:00002558 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002558                 assume cs:_rdata$r
.rdata$r:00002558                 ;org 2558h
.rdata$r:00002558 ; COMDAT (pick any)
.rdata$r:00002558                 public ??_R3HandleUniversalDetector@@8
.rdata$r:00002558 ; HandleUniversalDetector::`RTTI Class Hierarchy Descriptor'
.rdata$r:00002558 ??_R3HandleUniversalDetector@@8 db    0 ; DATA XREF: .rdata$r:0000252Co
.rdata$r:00002558                                         ; .rdata$r:0000258Co
.rdata$r:00002559                 db    0
.rdata$r:0000255A                 db    0
.rdata$r:0000255B                 db    0
.rdata$r:0000255C                 db    0
.rdata$r:0000255D                 db    0
.rdata$r:0000255E                 db    0
.rdata$r:0000255F                 db    0
.rdata$r:00002560                 db    2
.rdata$r:00002561                 db    0
.rdata$r:00002562                 db    0
.rdata$r:00002563                 db    0
.rdata$r:00002564                 dd offset ??_R2HandleUniversalDetector@@8 ; HandleUniversalDetector::`RTTI Base Class Array'
.rdata$r:00002564 _rdata$r        ends
.rdata$r:00002564
.rdata$r:00002568 ; ===========================================================================
.rdata$r:00002568
.rdata$r:00002568 ; Segment type: Pure data
.rdata$r:00002568 ; Segment permissions: Read
.rdata$r:00002568 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002568                 assume cs:_rdata$r
.rdata$r:00002568                 ;org 2568h
.rdata$r:00002568 ; COMDAT (pick any)
.rdata$r:00002568                 public ??_R2HandleUniversalDetector@@8
.rdata$r:00002568 ; HandleUniversalDetector::`RTTI Base Class Array'
.rdata$r:00002568 ??_R2HandleUniversalDetector@@8 dd offset ??_R1A@?0A@EA@HandleUniversalDetector@@8
.rdata$r:00002568                                         ; DATA XREF: .rdata$r:00002564o
.rdata$r:00002568                                         ; HandleUniversalDetector::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000256C                 dd offset ??_R1A@?0A@EA@nsUniversalDetector@@8 ; nsUniversalDetector::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00002570                 db    0
.rdata$r:00002571                 align 4
.rdata$r:00002571 _rdata$r        ends
.rdata$r:00002571
.rdata$r:00002574 ; ===========================================================================
.rdata$r:00002574
.rdata$r:00002574 ; Segment type: Pure data
.rdata$r:00002574 ; Segment permissions: Read
.rdata$r:00002574 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002574                 assume cs:_rdata$r
.rdata$r:00002574                 ;org 2574h
.rdata$r:00002574 ; COMDAT (pick any)
.rdata$r:00002574                 public ??_R1A@?0A@EA@HandleUniversalDetector@@8
.rdata$r:00002574 ; HandleUniversalDetector::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002574 ??_R1A@?0A@EA@HandleUniversalDetector@@8 dd offset ??_R0?AVHandleUniversalDetector@@@8
.rdata$r:00002574                                         ; DATA XREF: .rdata$r:HandleUniversalDetector::`RTTI Base Class Array'o
.rdata$r:00002574                                         ; HandleUniversalDetector `RTTI Type Descriptor'
.rdata$r:00002578                 db    1
.rdata$r:00002579                 db    0
.rdata$r:0000257A                 db    0
.rdata$r:0000257B                 db    0
.rdata$r:0000257C                 db    0
.rdata$r:0000257D                 db    0
.rdata$r:0000257E                 db    0
.rdata$r:0000257F                 db    0
.rdata$r:00002580                 db 0FFh
.rdata$r:00002581                 db 0FFh
.rdata$r:00002582                 db 0FFh
.rdata$r:00002583                 db 0FFh
.rdata$r:00002584                 db    0
.rdata$r:00002585                 db    0
.rdata$r:00002586                 db    0
.rdata$r:00002587                 db    0
.rdata$r:00002588                 db  40h ; @
.rdata$r:00002589                 db    0
.rdata$r:0000258A                 db    0
.rdata$r:0000258B                 db    0
.rdata$r:0000258C                 dd offset ??_R3HandleUniversalDetector@@8 ; HandleUniversalDetector::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000258C _rdata$r        ends
.rdata$r:0000258C
.rdata$r:00002590 ; ===========================================================================
.rdata$r:00002590
.rdata$r:00002590 ; Segment type: Pure data
.rdata$r:00002590 ; Segment permissions: Read
.rdata$r:00002590 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00002590                 assume cs:_rdata$r
.rdata$r:00002590                 ;org 2590h
.rdata$r:00002590 ; COMDAT (pick any)
.rdata$r:00002590                 public ??_R1A@?0A@EA@nsUniversalDetector@@8
.rdata$r:00002590 ; nsUniversalDetector::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00002590 ??_R1A@?0A@EA@nsUniversalDetector@@8 dd offset ??_R0?AVnsUniversalDetector@@@8
.rdata$r:00002590                                         ; DATA XREF: .rdata$r:0000256Co
.rdata$r:00002590                                         ; .rdata$r:nsUniversalDetector::`RTTI Base Class Array'o
.rdata$r:00002590                                         ; nsUniversalDetector `RTTI Type Descriptor'
.rdata$r:00002594                 db    0
.rdata$r:00002595                 db    0
.rdata$r:00002596                 db    0
.rdata$r:00002597                 db    0
.rdata$r:00002598                 db    0
.rdata$r:00002599                 db    0
.rdata$r:0000259A                 db    0
.rdata$r:0000259B                 db    0
.rdata$r:0000259C                 db 0FFh
.rdata$r:0000259D                 db 0FFh
.rdata$r:0000259E                 db 0FFh
.rdata$r:0000259F                 db 0FFh
.rdata$r:000025A0                 db    0
.rdata$r:000025A1                 db    0
.rdata$r:000025A2                 db    0
.rdata$r:000025A3                 db    0
.rdata$r:000025A4                 db  40h ; @
.rdata$r:000025A5                 db    0
.rdata$r:000025A6                 db    0
.rdata$r:000025A7                 db    0
.rdata$r:000025A8                 dd offset ??_R3nsUniversalDetector@@8 ; nsUniversalDetector::`RTTI Class Hierarchy Descriptor'
.rdata$r:000025A8 _rdata$r        ends
.rdata$r:000025A8
.data$r:000025AC ; ===========================================================================
.data$r:000025AC
.data$r:000025AC ; Segment type: Pure data
.data$r:000025AC ; Segment permissions: Read/Write
.data$r:000025AC _data$r         segment dword public 'DATA' use32
.data$r:000025AC                 assume cs:_data$r
.data$r:000025AC                 ;org 25ACh
.data$r:000025AC ; COMDAT (pick any)
.data$r:000025AC                 public ??_R0?AVnsUniversalDetector@@@8
.data$r:000025AC ; class nsUniversalDetector `RTTI Type Descriptor'
.data$r:000025AC ??_R0?AVnsUniversalDetector@@@8 dd offset ??_7type_info@@6B@
.data$r:000025AC                                         ; DATA XREF: .rdata$r:nsUniversalDetector::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000025AC                                         ; const type_info::`vftable'
.data$r:000025B0                 db    0
.data$r:000025B1                 db    0
.data$r:000025B2                 db    0
.data$r:000025B3                 db    0
.data$r:000025B4                 db  2Eh ; .
.data$r:000025B5                 db  3Fh ; ?
.data$r:000025B6                 db  41h ; A
.data$r:000025B7                 db  56h ; V
.data$r:000025B8                 db  6Eh ; n
.data$r:000025B9                 db  73h ; s
.data$r:000025BA                 db  55h ; U
.data$r:000025BB                 db  6Eh ; n
.data$r:000025BC                 db  69h ; i
.data$r:000025BD                 db  76h ; v
.data$r:000025BE                 db  65h ; e
.data$r:000025BF                 db  72h ; r
.data$r:000025C0                 db  73h ; s
.data$r:000025C1                 db  61h ; a
.data$r:000025C2                 db  6Ch ; l
.data$r:000025C3                 db  44h ; D
.data$r:000025C4                 db  65h ; e
.data$r:000025C5                 db  74h ; t
.data$r:000025C6                 db  65h ; e
.data$r:000025C7                 db  63h ; c
.data$r:000025C8                 db  74h ; t
.data$r:000025C9                 db  6Fh ; o
.data$r:000025CA                 db  72h ; r
.data$r:000025CB                 db  40h ; @
.data$r:000025CC                 db  40h ; @
.data$r:000025CD                 db    0
.data$r:000025CE                 align 10h
.data$r:000025CE _data$r         ends
.data$r:000025CE
.rdata$r:000025D0 ; ===========================================================================
.rdata$r:000025D0
.rdata$r:000025D0 ; Segment type: Pure data
.rdata$r:000025D0 ; Segment permissions: Read
.rdata$r:000025D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000025D0                 assume cs:_rdata$r
.rdata$r:000025D0                 ;org 25D0h
.rdata$r:000025D0 ; COMDAT (pick any)
.rdata$r:000025D0                 public ??_R3nsUniversalDetector@@8
.rdata$r:000025D0 ; nsUniversalDetector::`RTTI Class Hierarchy Descriptor'
.rdata$r:000025D0 ??_R3nsUniversalDetector@@8 db    0     ; DATA XREF: .rdata$r:000025A8o
.rdata$r:000025D1                 db    0
.rdata$r:000025D2                 db    0
.rdata$r:000025D3                 db    0
.rdata$r:000025D4                 db    0
.rdata$r:000025D5                 db    0
.rdata$r:000025D6                 db    0
.rdata$r:000025D7                 db    0
.rdata$r:000025D8                 db    1
.rdata$r:000025D9                 db    0
.rdata$r:000025DA                 db    0
.rdata$r:000025DB                 db    0
.rdata$r:000025DC                 dd offset ??_R2nsUniversalDetector@@8 ; nsUniversalDetector::`RTTI Base Class Array'
.rdata$r:000025DC _rdata$r        ends
.rdata$r:000025DC
.rdata$r:000025E0 ; ===========================================================================
.rdata$r:000025E0
.rdata$r:000025E0 ; Segment type: Pure data
.rdata$r:000025E0 ; Segment permissions: Read
.rdata$r:000025E0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000025E0                 assume cs:_rdata$r
.rdata$r:000025E0                 ;org 25E0h
.rdata$r:000025E0 ; COMDAT (pick any)
.rdata$r:000025E0                 public ??_R2nsUniversalDetector@@8
.rdata$r:000025E0 ; nsUniversalDetector::`RTTI Base Class Array'
.rdata$r:000025E0 ??_R2nsUniversalDetector@@8 dd offset ??_R1A@?0A@EA@nsUniversalDetector@@8
.rdata$r:000025E0                                         ; DATA XREF: .rdata$r:000025DCo
.rdata$r:000025E0                                         ; nsUniversalDetector::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000025E4                 db    0
.rdata$r:000025E5                 align 4
.rdata$r:000025E5 _rdata$r        ends
.rdata$r:000025E5
.CRT$XCU:000025E8 ; ===========================================================================
.CRT$XCU:000025E8
.CRT$XCU:000025E8 ; Segment type: Pure data
.CRT$XCU:000025E8 ; Segment permissions: Read
.CRT$XCU:000025E8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000025E8                 assume cs:_CRT$XCU
.CRT$XCU:000025E8                 ;org 25E8h
.CRT$XCU:000025E8 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:000025EC _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:000025EC _CRT$XCU        ends
.CRT$XCU:000025EC
.CRT$XCU:000025F0 ; ===========================================================================
.CRT$XCU:000025F0
.CRT$XCU:000025F0 ; Segment type: Pure data
.CRT$XCU:000025F0 ; Segment permissions: Read
.CRT$XCU:000025F0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000025F0                 assume cs:_CRT$XCU
.CRT$XCU:000025F0                 ;org 25F0h
.CRT$XCU:000025F0 ; COMDAT (pick associative to section at 2228)
.CRT$XCU:000025F0 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:000025F0 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:000025F0 _CRT$XCU        ends
.CRT$XCU:000025F0
.CRT$XCU:000025F4 ; ===========================================================================
.CRT$XCU:000025F4
.CRT$XCU:000025F4 ; Segment type: Pure data
.CRT$XCU:000025F4 ; Segment permissions: Read
.CRT$XCU:000025F4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000025F4                 assume cs:_CRT$XCU
.CRT$XCU:000025F4                 ;org 25F4h
.CRT$XCU:000025F4 ; COMDAT (pick associative to section at 222C)
.CRT$XCU:000025F4 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:000025F4 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:000025F4 _CRT$XCU        ends
.CRT$XCU:000025F4
.CRT$XCU:000025F8 ; ===========================================================================
.CRT$XCU:000025F8
.CRT$XCU:000025F8 ; Segment type: Pure data
.CRT$XCU:000025F8 ; Segment permissions: Read
.CRT$XCU:000025F8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000025F8                 assume cs:_CRT$XCU
.CRT$XCU:000025F8                 ;org 25F8h
.CRT$XCU:000025F8 ; COMDAT (pick associative to section at 2230)
.CRT$XCU:000025F8 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:000025F8 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:000025F8 _CRT$XCU        ends
.CRT$XCU:000025F8
.CRT$XCU:000025FC ; ===========================================================================
.CRT$XCU:000025FC
.CRT$XCU:000025FC ; Segment type: Pure data
.CRT$XCU:000025FC ; Segment permissions: Read
.CRT$XCU:000025FC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000025FC                 assume cs:_CRT$XCU
.CRT$XCU:000025FC                 ;org 25FCh
.CRT$XCU:000025FC ; COMDAT (pick associative to section at 2234)
.CRT$XCU:000025FC ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:000025FC ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:000025FC _CRT$XCU        ends
.CRT$XCU:000025FC
.CRT$XCU:00002600 ; ===========================================================================
.CRT$XCU:00002600
.CRT$XCU:00002600 ; Segment type: Pure data
.CRT$XCU:00002600 ; Segment permissions: Read
.CRT$XCU:00002600 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002600                 assume cs:_CRT$XCU
.CRT$XCU:00002600                 ;org 2600h
.CRT$XCU:00002600 ; COMDAT (pick associative to section at 2238)
.CRT$XCU:00002600 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00002600 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00002600 _CRT$XCU        ends
.CRT$XCU:00002600
.CRT$XCU:00002604 ; ===========================================================================
.CRT$XCU:00002604
.CRT$XCU:00002604 ; Segment type: Pure data
.CRT$XCU:00002604 ; Segment permissions: Read
.CRT$XCU:00002604 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002604                 assume cs:_CRT$XCU
.CRT$XCU:00002604                 ;org 2604h
.CRT$XCU:00002604 ; COMDAT (pick associative to section at 22E4)
.CRT$XCU:00002604 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00002604 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00002604 _CRT$XCU        ends
.CRT$XCU:00002604
.CRT$XCU:00002608 ; ===========================================================================
.CRT$XCU:00002608
.CRT$XCU:00002608 ; Segment type: Pure data
.CRT$XCU:00002608 ; Segment permissions: Read
.CRT$XCU:00002608 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00002608                 assume cs:_CRT$XCU
.CRT$XCU:00002608                 ;org 2608h
.CRT$XCU:00002608 ; COMDAT (pick associative to section at 22E8)
.CRT$XCU:00002608 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00002608 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00002608 _CRT$XCU        ends
.CRT$XCU:00002608
UNDEF:00002610 ; ===========================================================================
UNDEF:00002610
UNDEF:00002610 ; Segment type: Externs
UNDEF:00002610 ; UNDEF
UNDEF:00002610                 extrn __purecall:near   ; DATA XREF: .rdata:0000217Co
UNDEF:00002610                                         ; .rdata:00002180o
UNDEF:00002614 ; void *__cdecl operator new(unsigned int)
UNDEF:00002614                 extrn ??2@YAPAXI@Z:near ; CODE XREF: _uchardet_new+27p
UNDEF:00002614                                         ; std::_Allocate<char>(uint,char *)+1Dp ...
UNDEF:00002618 ; void __cdecl operator delete(void *)
UNDEF:00002618                 extrn ??3@YAXPAX@Z:near ; CODE XREF: __unwindfunclet$_uchardet_new$0+4p
UNDEF:00002618                                         ; HandleUniversalDetector::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000261C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000261C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000261C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00002620 ; _DWORD __thiscall nsUniversalDetector::nsUniversalDetector(nsUniversalDetector *__hidden this, unsigned int)
UNDEF:00002620                 extrn ??0nsUniversalDetector@@QAE@I@Z:near
UNDEF:00002620                                         ; CODE XREF: HandleUniversalDetector::HandleUniversalDetector(void)+2Bp
UNDEF:00002624 ; _DWORD __thiscall nsUniversalDetector::~nsUniversalDetector(nsUniversalDetector *__hidden this)
UNDEF:00002624                 extrn ??1nsUniversalDetector@@UAE@XZ:near
UNDEF:00002624                                         ; CODE XREF: __unwindfunclet$??0HandleUniversalDetector@@QAE@XZ$0+3j
UNDEF:00002624                                         ; HandleUniversalDetector::~HandleUniversalDetector(void)+4Fp ...
UNDEF:00002628 ; public: virtual enum  nsresult __thiscall nsUniversalDetector::HandleData(char const *, unsigned int)
UNDEF:00002628                 extrn ?HandleData@nsUniversalDetector@@UAE?AW4nsresult@@PBDI@Z:near
UNDEF:00002628                                         ; DATA XREF: .rdata:00002244o
UNDEF:0000262C ; public: virtual void __thiscall nsUniversalDetector::DataEnd(void)
UNDEF:0000262C                 extrn ?DataEnd@nsUniversalDetector@@UAEXXZ:near
UNDEF:0000262C                                         ; DATA XREF: .rdata:00002248o
UNDEF:00002630 ; void __thiscall nsUniversalDetector::Reset(nsUniversalDetector *__hidden this)
UNDEF:00002630                 extrn ?Reset@nsUniversalDetector@@MAEXXZ:near
UNDEF:00002630                                         ; CODE XREF: HandleUniversalDetector::Reset(void)+Ap
UNDEF:00002634 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00002634                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00002634                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00002638 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00002638                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00002638                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00002638                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:0000263C                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00002640 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00002640                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00002644 ; size_t __cdecl strlen(const char *Str)
UNDEF:00002644                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00002648 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00002648                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:0000264C ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0000264C                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0000264C                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00002650 ; void __cdecl std::_Xbad_alloc()
UNDEF:00002650                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00002650                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_1A6p
UNDEF:00002650                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_1E8p
UNDEF:00002654 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00002654                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00002654                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00002658 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00002658                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00002658                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000265C ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000265C                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000265C                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00002660 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00002660                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00002660                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00002660                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00002664 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00002664                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00002664                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00002668 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002668                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002668                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000266C ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000266C                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000266C                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00002670 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00002670                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00002670                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00002674 ; public: virtual void * __thiscall HandleUniversalDetector::`vector deleting destructor'(unsigned int)
UNDEF:00002674                 extrn ??_EHandleUniversalDetector@@UAEPAXI@Z:near ; weak
UNDEF:00002674                                         ; DATA XREF: .rdata:const HandleUniversalDetector::`vftable'o
UNDEF:00002678 ; __fastcall __security_check_cookie(x)
UNDEF:00002678                 extrn @__security_check_cookie@4:near
UNDEF:00002678                                         ; CODE XREF: __ehhandler$_uchardet_new+Cp
UNDEF:00002678                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+Cp ...
UNDEF:0000267C ; __stdcall _CxxThrowException(x, x)
UNDEF:0000267C                 extrn __CxxThrowException@8:near
UNDEF:0000267C                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:00002680                 extrn ___CxxFrameHandler3:near
UNDEF:00002680                                         ; CODE XREF: __ehhandler$_uchardet_new+16j
UNDEF:00002680                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j ...
UNDEF:00002684 ; const type_info::`vftable'
UNDEF:00002684                 extrn ??_7type_info@@6B@:near
UNDEF:00002684                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:00002684                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00002688                 extrn ___security_cookie:near ; DATA XREF: _uchardet_new+14r
UNDEF:00002688                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r ...
UNDEF:0000268C                 extrn __fltused:near
UNDEF:0000268C
UNDEF:0000268C
UNDEF:0000268C                 end