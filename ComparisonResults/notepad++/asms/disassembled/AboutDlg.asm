.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : DAC29CC9105FC10C9EFD9258E25B6AFD
.rdata:00000000 ; Input CRC32 : FD2457FF
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\AboutDlg.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000000 _rdata          segment para public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; wchar_t _SG138313
.rdata:00000000 $SG138313:                              ; DATA XREF: AboutDlg::run_dlgProc(uint,uint,long)+80o
.rdata:00000000                 unicode 0, <Build time : >,0
.rdata:0000001C ; char _SG138315[]
.rdata:0000001C $SG138315       db 'Jul 23 2015',0      ; DATA XREF: AboutDlg::run_dlgProc(uint,uint,long)+A4o
.rdata:00000028 ; wchar_t _SG138316
.rdata:00000028 $SG138316:                              ; DATA XREF: AboutDlg::run_dlgProc(uint,uint,long)+BAo
.rdata:00000028                 unicode 0, < - >,0
.rdata:00000030 ; char _SG138317[]
.rdata:00000030 $SG138317       db '10:13:49',0         ; DATA XREF: AboutDlg::run_dlgProc(uint,uint,long)+CFo
.rdata:00000039                 align 10h
.rdata:00000040 $SG138321:                              ; DATA XREF: AboutDlg::run_dlgProc(uint,uint,long)+11Do
.rdata:00000040                 unicode 0, <This program is free software; you can redistribute it an>
.rdata:00000040                 unicode 0, <d/or modify it under the terms of the GNU General Public >
.rdata:00000040                 unicode 0, <License as published by the Free Software Foundation; eit>
.rdata:00000040                 unicode 0, <her version 2 of the License, or (at your option) any lat>
.rdata:00000040                 unicode 0, <er version.>
.rdata:00000040                 dw 0Dh, 0Ah, 0Dh, 0Ah
.rdata:00000040                 unicode 0, <This program is distributed in the hope that it will be u>
.rdata:00000040                 unicode 0, <seful, but WITHOUT ANY WARRANTY; without even the implied>
.rdata:00000040                 unicode 0, < warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR >
.rdata:00000040                 unicode 0, <PURPOSE.  See the GNU General Public License for more det>
.rdata:00000040                 unicode 0, <ails. >
.rdata:00000040                 dw 0Dh, 0Ah, 0Dh, 0Ah
.rdata:00000040                 unicode 0, <You should have received a copy of the GNU General Public>
.rdata:00000040                 unicode 0, < License along with this program; if not, write to the Fr>
.rdata:00000040                 unicode 0, <ee Software Foundation, Inc., 675 Mass Ave, Cambridge, MA>
.rdata:00000040                 unicode 0, < 02139, USA.>,0
.rdata:00000572                 align 8
.rdata:00000578 ; wchar_t _SG138322
.rdata:00000578 $SG138322:                              ; DATA XREF: AboutDlg::run_dlgProc(uint,uint,long)+154o
.rdata:00000578                 unicode 0, <https://notepad-plus-plus.org/contributors>,0
.rdata:000005CE                 align 10h
.rdata:000005D0 ; wchar_t _SG138323
.rdata:000005D0 $SG138323:                              ; DATA XREF: AboutDlg::run_dlgProc(uint,uint,long)+19Bo
.rdata:000005D0                 unicode 0, <https://notepad-plus-plus.org/>,0
.rdata:0000060E                 align 10h
.rdata:0000060E _rdata          ends
.rdata:0000060E
.text$mn:00000610 ; ===========================================================================
.text$mn:00000610
.text$mn:00000610 ; Segment type: Pure code
.text$mn:00000610 ; Segment permissions: Read/Execute
.text$mn:00000610 _text$mn        segment para public 'CODE' use32
.text$mn:00000610                 assume cs:_text$mn
.text$mn:00000610                 ;org 610h
.text$mn:00000610                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000610
.text$mn:00000610 ; =============== S U B R O U T I N E =======================================
.text$mn:00000610
.text$mn:00000610 ; Attributes: bp-based frame
.text$mn:00000610
.text$mn:00000610 ; void __thiscall AboutDlg::doDialog(AboutDlg *__hidden this)
.text$mn:00000610                 public ?doDialog@AboutDlg@@QAEXXZ
.text$mn:00000610 ?doDialog@AboutDlg@@QAEXXZ proc near
.text$mn:00000610
.text$mn:00000610 var_4           = dword ptr -4
.text$mn:00000610
.text$mn:00000610                 push    ebp
.text$mn:00000611                 mov     ebp, esp
.text$mn:00000613                 push    ecx
.text$mn:00000614                 mov     [ebp+var_4], ecx
.text$mn:00000617                 mov     eax, [ebp+var_4]
.text$mn:0000061A                 mov     edx, [eax]
.text$mn:0000061C                 mov     ecx, [ebp+var_4]
.text$mn:0000061F                 mov     eax, [edx+34h]
.text$mn:00000622                 call    eax
.text$mn:00000624                 movzx   ecx, al
.text$mn:00000627                 test    ecx, ecx
.text$mn:00000629                 jnz     short loc_641
.text$mn:0000062B                 push    1
.text$mn:0000062D                 push    0
.text$mn:0000062F                 push    6A4h
.text$mn:00000634                 mov     edx, [ebp+var_4]
.text$mn:00000637                 mov     eax, [edx]
.text$mn:00000639                 mov     ecx, [ebp+var_4]
.text$mn:0000063C                 mov     edx, [eax+30h]
.text$mn:0000063F                 call    edx
.text$mn:00000641
.text$mn:00000641 loc_641:                                ; CODE XREF: AboutDlg::doDialog(void)+19j
.text$mn:00000641                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000644                 call    ?goToCenter@StaticDialog@@QAEXXZ ; StaticDialog::goToCenter(void)
.text$mn:00000649                 mov     esp, ebp
.text$mn:0000064B                 pop     ebp
.text$mn:0000064C                 retn
.text$mn:0000064C ?doDialog@AboutDlg@@QAEXXZ endp
.text$mn:0000064C
.text$mn:0000064C ; ---------------------------------------------------------------------------
.text$mn:0000064D                 align 10h
.text$mn:00000650
.text$mn:00000650 ; =============== S U B R O U T I N E =======================================
.text$mn:00000650
.text$mn:00000650 ; Attributes: bp-based frame
.text$mn:00000650
.text$mn:00000650 ; int __stdcall AboutDlg::run_dlgProc(AboutDlg *this, unsigned int, unsigned int, __int32)
.text$mn:00000650                 public ?run_dlgProc@AboutDlg@@MAGHIIJ@Z
.text$mn:00000650 ?run_dlgProc@AboutDlg@@MAGHIIJ@Z proc near
.text$mn:00000650
.text$mn:00000650 var_54          = dword ptr -54h
.text$mn:00000650 var_50          = dword ptr -50h
.text$mn:00000650 var_4C          = dword ptr -4Ch
.text$mn:00000650 hIcon           = dword ptr -48h
.text$mn:00000650 var_44          = dword ptr -44h
.text$mn:00000650 var_40          = dword ptr -40h
.text$mn:00000650 var_3C          = dword ptr -3Ch
.text$mn:00000650 var_38          = dword ptr -38h
.text$mn:00000650 hWnd            = dword ptr -34h
.text$mn:00000650 var_30          = dword ptr -30h
.text$mn:00000650 var_2C          = byte ptr -2Ch
.text$mn:00000650 var_10          = dword ptr -10h
.text$mn:00000650 var_C           = dword ptr -0Ch
.text$mn:00000650 var_4           = dword ptr -4
.text$mn:00000650 this            = dword ptr  8
.text$mn:00000650 arg_4           = dword ptr  0Ch
.text$mn:00000650 arg_8           = dword ptr  10h
.text$mn:00000650 arg_C           = dword ptr  14h
.text$mn:00000650
.text$mn:00000650                 push    ebp
.text$mn:00000651                 mov     ebp, esp
.text$mn:00000653                 push    0FFFFFFFFh
.text$mn:00000655                 push    offset __ehhandler$?run_dlgProc@AboutDlg@@MAGHIIJ@Z
.text$mn:0000065A                 mov     eax, large fs:0
.text$mn:00000660                 push    eax
.text$mn:00000661                 sub     esp, 48h
.text$mn:00000664                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000669                 xor     eax, ebp
.text$mn:0000066B                 mov     [ebp+var_10], eax
.text$mn:0000066E                 push    eax
.text$mn:0000066F                 lea     eax, [ebp+var_C]
.text$mn:00000672                 mov     large fs:0, eax
.text$mn:00000678                 mov     eax, [ebp+arg_4]
.text$mn:0000067B                 mov     [ebp+var_30], eax
.text$mn:0000067E                 cmp     [ebp+var_30], 110h
.text$mn:00000685                 ja      short loc_6A9
.text$mn:00000687                 cmp     [ebp+var_30], 110h
.text$mn:0000068E                 jz      short loc_6BB
.text$mn:00000690                 cmp     [ebp+var_30], 2
.text$mn:00000694                 jz      loc_8E1
.text$mn:0000069A                 cmp     [ebp+var_30], 2Bh ; '+'
.text$mn:0000069E                 jz      loc_871
.text$mn:000006A4                 jmp     loc_8E8
.text$mn:000006A9 ; ---------------------------------------------------------------------------
.text$mn:000006A9
.text$mn:000006A9 loc_6A9:                                ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+35j
.text$mn:000006A9                 cmp     [ebp+var_30], 111h
.text$mn:000006B0                 jz      loc_8B7
.text$mn:000006B6                 jmp     loc_8E8
.text$mn:000006BB ; ---------------------------------------------------------------------------
.text$mn:000006BB
.text$mn:000006BB loc_6BB:                                ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+3Ej
.text$mn:000006BB                 push    6AAh            ; nIDDlgItem
.text$mn:000006C0                 mov     ecx, [ebp+this]
.text$mn:000006C3                 mov     edx, [ecx+0Ch]
.text$mn:000006C6                 push    edx             ; hDlg
.text$mn:000006C7                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:000006CD                 mov     [ebp+hWnd], eax
.text$mn:000006D0                 push    offset $SG138313 ; "Build time : "
.text$mn:000006D5                 lea     ecx, [ebp+var_2C]
.text$mn:000006D8                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000006DD                 mov     [ebp+var_4], 0
.text$mn:000006E4                 call    ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ ; WcharMbcsConvertor::getInstance(void)
.text$mn:000006E9                 mov     [ebp+var_40], eax
.text$mn:000006EC                 push    0               ; int *
.text$mn:000006EE                 push    0               ; int *
.text$mn:000006F0                 push    0FFFFFFFFh      ; int
.text$mn:000006F2                 push    0               ; unsigned int
.text$mn:000006F4                 push    offset $SG138315 ; "Jul 23 2015"
.text$mn:000006F9                 mov     ecx, [ebp+var_40] ; this
.text$mn:000006FC                 call    ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIHPAH1@Z ; WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)
.text$mn:00000701                 push    eax             ; Str
.text$mn:00000702                 lea     ecx, [ebp+var_2C]
.text$mn:00000705                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:0000070A                 push    offset $SG138316 ; " - "
.text$mn:0000070F                 lea     ecx, [ebp+var_2C]
.text$mn:00000712                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00000717                 push    0               ; int *
.text$mn:00000719                 push    0               ; int *
.text$mn:0000071B                 push    0FFFFFFFFh      ; int
.text$mn:0000071D                 push    0               ; unsigned int
.text$mn:0000071F                 push    offset $SG138317 ; "10:13:49"
.text$mn:00000724                 mov     ecx, [ebp+var_40] ; this
.text$mn:00000727                 call    ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIHPAH1@Z ; WcharMbcsConvertor::char2wchar(char const *,uint,int,int *,int *)
.text$mn:0000072C                 push    eax             ; Str
.text$mn:0000072D                 lea     ecx, [ebp+var_2C]
.text$mn:00000730                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00000735                 lea     ecx, [ebp+var_2C]
.text$mn:00000738                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000073D                 push    eax             ; lParam
.text$mn:0000073E                 push    0               ; wParam
.text$mn:00000740                 push    0Ch             ; Msg
.text$mn:00000742                 mov     eax, [ebp+hWnd]
.text$mn:00000745                 push    eax             ; hWnd
.text$mn:00000746                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000074C                 push    0               ; bEnable
.text$mn:0000074E                 mov     ecx, [ebp+hWnd]
.text$mn:00000751                 push    ecx             ; hWnd
.text$mn:00000752                 call    dword ptr ds:__imp__EnableWindow@8 ; EnableWindow(x,x)
.text$mn:00000758                 push    6A5h            ; nIDDlgItem
.text$mn:0000075D                 mov     edx, [ebp+this]
.text$mn:00000760                 mov     eax, [edx+0Ch]
.text$mn:00000763                 push    eax             ; hDlg
.text$mn:00000764                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:0000076A                 mov     [ebp+var_44], eax
.text$mn:0000076D                 push    offset $SG138321 ; "This program is free software; you can "...
.text$mn:00000772                 push    0               ; wParam
.text$mn:00000774                 push    0Ch             ; Msg
.text$mn:00000776                 mov     ecx, [ebp+var_44]
.text$mn:00000779                 push    ecx             ; hWnd
.text$mn:0000077A                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000780                 mov     edx, [ebp+this]
.text$mn:00000783                 mov     eax, [edx+0Ch]
.text$mn:00000786                 push    eax
.text$mn:00000787                 mov     ecx, [ebp+this]
.text$mn:0000078A                 mov     edx, [ecx+4]
.text$mn:0000078D                 push    edx
.text$mn:0000078E                 mov     ecx, [ebp+this]
.text$mn:00000791                 add     ecx, 20h ; ' '
.text$mn:00000794                 mov     eax, [ebp+this]
.text$mn:00000797                 mov     edx, [eax+20h]
.text$mn:0000079A                 mov     eax, [edx+4]
.text$mn:0000079D                 call    eax
.text$mn:0000079F                 push    0FF0000h        ; unsigned __int32
.text$mn:000007A4                 push    offset $SG138322 ; "https://notepad-plus-plus.org/contribut"...
.text$mn:000007A9                 push    6A9h            ; nIDDlgItem
.text$mn:000007AE                 mov     ecx, [ebp+this]
.text$mn:000007B1                 mov     edx, [ecx+0Ch]
.text$mn:000007B4                 push    edx             ; hDlg
.text$mn:000007B5                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:000007BB                 push    eax             ; HWND
.text$mn:000007BC                 mov     ecx, [ebp+this]
.text$mn:000007BF                 add     ecx, 20h ; ' '  ; this
.text$mn:000007C2                 call    ?create@URLCtrl@@QAEXPAUHWND__@@PA_WK@Z ; URLCtrl::create(HWND__ *,wchar_t *,ulong)
.text$mn:000007C7                 mov     eax, [ebp+this]
.text$mn:000007CA                 mov     ecx, [eax+0Ch]
.text$mn:000007CD                 push    ecx
.text$mn:000007CE                 mov     edx, [ebp+this]
.text$mn:000007D1                 mov     eax, [edx+4]
.text$mn:000007D4                 push    eax
.text$mn:000007D5                 mov     ecx, [ebp+this]
.text$mn:000007D8                 add     ecx, 6Ch ; 'l'
.text$mn:000007DB                 mov     edx, [ebp+this]
.text$mn:000007DE                 mov     eax, [edx+6Ch]
.text$mn:000007E1                 mov     edx, [eax+4]
.text$mn:000007E4                 call    edx
.text$mn:000007E6                 push    0FF0000h        ; unsigned __int32
.text$mn:000007EB                 push    offset $SG138323 ; "https://notepad-plus-plus.org/"
.text$mn:000007F0                 push    6A6h            ; nIDDlgItem
.text$mn:000007F5                 mov     eax, [ebp+this]
.text$mn:000007F8                 mov     ecx, [eax+0Ch]
.text$mn:000007FB                 push    ecx             ; hDlg
.text$mn:000007FC                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00000802                 push    eax             ; HWND
.text$mn:00000803                 mov     ecx, [ebp+this]
.text$mn:00000806                 add     ecx, 6Ch ; 'l'  ; this
.text$mn:00000809                 call    ?create@URLCtrl@@QAEXPAUHWND__@@PA_WK@Z ; URLCtrl::create(HWND__ *,wchar_t *,ulong)
.text$mn:0000080E                 mov     edx, [ebp+this]
.text$mn:00000811                 add     edx, 10h
.text$mn:00000814                 push    edx
.text$mn:00000815                 mov     eax, [ebp+this]
.text$mn:00000818                 mov     edx, [eax]
.text$mn:0000081A                 mov     ecx, [ebp+this]
.text$mn:0000081D                 mov     eax, [edx+1Ch]
.text$mn:00000820                 call    eax
.text$mn:00000822                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000827                 mov     [ebp+var_54], eax
.text$mn:0000082A                 mov     ecx, [ebp+var_54]
.text$mn:0000082D                 call    ?getEnableThemeDlgTexture@NppParameters@@QBEP6GJPAUHWND__@@IIJ@ZXZ ; NppParameters::getEnableThemeDlgTexture(void)
.text$mn:00000832                 mov     [ebp+var_3C], eax
.text$mn:00000835                 cmp     [ebp+var_3C], 0
.text$mn:00000839                 jz      short loc_856
.text$mn:0000083B                 push    6
.text$mn:0000083D                 mov     ecx, [ebp+this]
.text$mn:00000840                 mov     edx, [ecx+0Ch]
.text$mn:00000843                 push    edx
.text$mn:00000844                 call    [ebp+var_3C]
.text$mn:00000847                 push    0
.text$mn:00000849                 mov     eax, [ebp+this]
.text$mn:0000084C                 mov     edx, [eax]
.text$mn:0000084E                 mov     ecx, [ebp+this]
.text$mn:00000851                 mov     eax, [edx+18h]
.text$mn:00000854                 call    eax
.text$mn:00000856
.text$mn:00000856 loc_856:                                ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+1E9j
.text$mn:00000856                 mov     [ebp+var_50], 1
.text$mn:0000085D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000864                 lea     ecx, [ebp+var_2C]
.text$mn:00000867                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:0000086C                 mov     eax, [ebp+var_50]
.text$mn:0000086F                 jmp     short loc_8EA
.text$mn:00000871 ; ---------------------------------------------------------------------------
.text$mn:00000871
.text$mn:00000871 loc_871:                                ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+4Ej
.text$mn:00000871                 push    40h ; '@'       ; fuLoad
.text$mn:00000873                 push    40h ; '@'       ; cy
.text$mn:00000875                 push    40h ; '@'       ; cx
.text$mn:00000877                 push    1               ; type
.text$mn:00000879                 push    (offset $SG138321+25h) ; name
.text$mn:0000087B                 mov     ecx, [ebp+this]
.text$mn:0000087E                 mov     edx, [ecx+4]
.text$mn:00000881                 push    edx             ; hInst
.text$mn:00000882                 call    dword ptr ds:__imp__LoadImageW@24 ; LoadImageW(x,x,x,x,x,x)
.text$mn:00000888                 mov     [ebp+hIcon], eax
.text$mn:0000088B                 mov     eax, [ebp+arg_C]
.text$mn:0000088E                 mov     [ebp+var_4C], eax
.text$mn:00000891                 push    3               ; diFlags
.text$mn:00000893                 push    0               ; hbrFlickerFreeDraw
.text$mn:00000895                 push    0               ; istepIfAniCur
.text$mn:00000897                 push    40h ; '@'       ; cyWidth
.text$mn:00000899                 push    40h ; '@'       ; cxWidth
.text$mn:0000089B                 mov     ecx, [ebp+hIcon]
.text$mn:0000089E                 push    ecx             ; hIcon
.text$mn:0000089F                 push    0               ; yTop
.text$mn:000008A1                 push    0               ; xLeft
.text$mn:000008A3                 mov     edx, [ebp+var_4C]
.text$mn:000008A6                 mov     eax, [edx+18h]
.text$mn:000008A9                 push    eax             ; hdc
.text$mn:000008AA                 call    dword ptr ds:__imp__DrawIconEx@36 ; DrawIconEx(x,x,x,x,x,x,x,x,x)
.text$mn:000008B0                 mov     eax, 1
.text$mn:000008B5                 jmp     short loc_8EA
.text$mn:000008B7 ; ---------------------------------------------------------------------------
.text$mn:000008B7
.text$mn:000008B7 loc_8B7:                                ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+60j
.text$mn:000008B7                 mov     ecx, [ebp+arg_8]
.text$mn:000008BA                 mov     [ebp+var_38], ecx
.text$mn:000008BD                 cmp     [ebp+var_38], 0
.text$mn:000008C1                 jbe     short loc_8E1
.text$mn:000008C3                 cmp     [ebp+var_38], 2
.text$mn:000008C7                 jbe     short loc_8CB
.text$mn:000008C9                 jmp     short loc_8E1
.text$mn:000008CB ; ---------------------------------------------------------------------------
.text$mn:000008CB
.text$mn:000008CB loc_8CB:                                ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+277j
.text$mn:000008CB                 push    0
.text$mn:000008CD                 mov     edx, [ebp+this]
.text$mn:000008D0                 mov     eax, [edx]
.text$mn:000008D2                 mov     ecx, [ebp+this]
.text$mn:000008D5                 mov     edx, [eax+0Ch]
.text$mn:000008D8                 call    edx
.text$mn:000008DA                 mov     eax, 1
.text$mn:000008DF                 jmp     short loc_8EA
.text$mn:000008E1 ; ---------------------------------------------------------------------------
.text$mn:000008E1
.text$mn:000008E1 loc_8E1:                                ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+44j
.text$mn:000008E1                                         ; AboutDlg::run_dlgProc(uint,uint,long)+271j ...
.text$mn:000008E1                 mov     eax, 1
.text$mn:000008E6                 jmp     short loc_8EA
.text$mn:000008E8 ; ---------------------------------------------------------------------------
.text$mn:000008E8
.text$mn:000008E8 loc_8E8:                                ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+54j
.text$mn:000008E8                                         ; AboutDlg::run_dlgProc(uint,uint,long)+66j
.text$mn:000008E8                 xor     eax, eax
.text$mn:000008EA
.text$mn:000008EA loc_8EA:                                ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+21Fj
.text$mn:000008EA                                         ; AboutDlg::run_dlgProc(uint,uint,long)+265j ...
.text$mn:000008EA                 mov     ecx, [ebp+var_C]
.text$mn:000008ED                 mov     large fs:0, ecx
.text$mn:000008F4                 pop     ecx
.text$mn:000008F5                 mov     ecx, [ebp+var_10]
.text$mn:000008F8                 xor     ecx, ebp
.text$mn:000008FA                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000008FF                 mov     esp, ebp
.text$mn:00000901                 pop     ebp
.text$mn:00000902                 retn    10h
.text$mn:00000902 ?run_dlgProc@AboutDlg@@MAGHIIJ@Z endp
.text$mn:00000902
.text$mn:00000902 ; ---------------------------------------------------------------------------
.text$mn:00000905                 align 4
.text$mn:00000905 _text$mn        ends
.text$mn:00000905
.text$x:00000908 ; ===========================================================================
.text$x:00000908
.text$x:00000908 ; Segment type: Pure code
.text$x:00000908 ; Segment permissions: Read/Execute
.text$x:00000908 _text$x         segment para public 'CODE' use32
.text$x:00000908                 assume cs:_text$x
.text$x:00000908                 ;org 908h
.text$x:00000908                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000908
.text$x:00000908 ; =============== S U B R O U T I N E =======================================
.text$x:00000908
.text$x:00000908
.text$x:00000908 __unwindfunclet$?run_dlgProc@AboutDlg@@MAGHIIJ@Z$0 proc near
.text$x:00000908                                         ; DATA XREF: .xdata$x:00003724o
.text$x:00000908                 lea     ecx, [ebp-2Ch]
.text$x:0000090B                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:0000090B __unwindfunclet$?run_dlgProc@AboutDlg@@MAGHIIJ@Z$0 endp
.text$x:0000090B
.text$x:00000910
.text$x:00000910 ; =============== S U B R O U T I N E =======================================
.text$x:00000910
.text$x:00000910
.text$x:00000910 __ehhandler$?run_dlgProc@AboutDlg@@MAGHIIJ@Z proc near
.text$x:00000910                                         ; DATA XREF: AboutDlg::run_dlgProc(uint,uint,long)+5o
.text$x:00000910
.text$x:00000910 arg_4           = dword ptr  8
.text$x:00000910
.text$x:00000910                 mov     edx, [esp+arg_4]
.text$x:00000914                 lea     eax, [edx+0Ch]
.text$x:00000917                 mov     ecx, [edx-4Ch]
.text$x:0000091A                 xor     ecx, eax
.text$x:0000091C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000921                 mov     ecx, [edx-4]
.text$x:00000924                 xor     ecx, eax
.text$x:00000926                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000092B                 mov     eax, offset __ehfuncinfo$?run_dlgProc@AboutDlg@@MAGHIIJ@Z
.text$x:00000930                 jmp     ___CxxFrameHandler3
.text$x:00000930 __ehhandler$?run_dlgProc@AboutDlg@@MAGHIIJ@Z endp
.text$x:00000930
.text$x:00000930 ; ---------------------------------------------------------------------------
.text$x:00000935                 align 4
.text$x:00000935 _text$x         ends
.text$x:00000935
.text$mn:00000938 ; ===========================================================================
.text$mn:00000938
.text$mn:00000938 ; Segment type: Pure code
.text$mn:00000938 ; Segment permissions: Read/Execute
.text$mn:00000938 _text$mn        segment para public 'CODE' use32
.text$mn:00000938                 assume cs:_text$mn
.text$mn:00000938                 ;org 938h
.text$mn:00000938 ; COMDAT (pick any)
.text$mn:00000938                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000938
.text$mn:00000938 ; =============== S U B R O U T I N E =======================================
.text$mn:00000938
.text$mn:00000938 ; Attributes: bp-based frame
.text$mn:00000938
.text$mn:00000938 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00000938                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00000938 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00000938                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00000938
.text$mn:00000938 var_4           = dword ptr -4
.text$mn:00000938 arg_0           = dword ptr  8
.text$mn:00000938
.text$mn:00000938                 push    ebp
.text$mn:00000939                 mov     ebp, esp
.text$mn:0000093B                 push    ecx
.text$mn:0000093C                 mov     [ebp+var_4], 0
.text$mn:00000943                 cmp     [ebp+arg_0], 0
.text$mn:00000947                 jnz     short loc_94B
.text$mn:00000949                 jmp     short loc_96B
.text$mn:0000094B ; ---------------------------------------------------------------------------
.text$mn:0000094B
.text$mn:0000094B loc_94B:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:0000094B                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:0000094F                 ja      short loc_966
.text$mn:00000951                 mov     eax, [ebp+arg_0]
.text$mn:00000954                 push    eax             ; unsigned int
.text$mn:00000955                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000095A                 add     esp, 4
.text$mn:0000095D                 mov     [ebp+var_4], eax
.text$mn:00000960                 cmp     [ebp+var_4], 0
.text$mn:00000964                 jnz     short loc_96B
.text$mn:00000966
.text$mn:00000966 loc_966:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00000966                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000096B
.text$mn:0000096B loc_96B:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:0000096B                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:0000096B                 mov     eax, [ebp+var_4]
.text$mn:0000096E                 mov     esp, ebp
.text$mn:00000970                 pop     ebp
.text$mn:00000971                 retn
.text$mn:00000971 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00000971
.text$mn:00000971 ; ---------------------------------------------------------------------------
.text$mn:00000972                 align 4
.text$mn:00000972 _text$mn        ends
.text$mn:00000972
.text$mn:00000974 ; ===========================================================================
.text$mn:00000974
.text$mn:00000974 ; Segment type: Pure code
.text$mn:00000974 ; Segment permissions: Read/Execute
.text$mn:00000974 _text$mn        segment para public 'CODE' use32
.text$mn:00000974                 assume cs:_text$mn
.text$mn:00000974                 ;org 974h
.text$mn:00000974 ; COMDAT (pick any)
.text$mn:00000974                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000974
.text$mn:00000974 ; =============== S U B R O U T I N E =======================================
.text$mn:00000974
.text$mn:00000974 ; Attributes: bp-based frame
.text$mn:00000974
.text$mn:00000974 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00000974                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00000974 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00000974                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00000974
.text$mn:00000974 var_4           = dword ptr -4
.text$mn:00000974 arg_0           = dword ptr  8
.text$mn:00000974
.text$mn:00000974                 push    ebp
.text$mn:00000975                 mov     ebp, esp
.text$mn:00000977                 push    ecx
.text$mn:00000978                 mov     [ebp+var_4], 0
.text$mn:0000097F                 cmp     [ebp+arg_0], 0
.text$mn:00000983                 jnz     short loc_987
.text$mn:00000985                 jmp     short loc_9AD
.text$mn:00000987 ; ---------------------------------------------------------------------------
.text$mn:00000987
.text$mn:00000987 loc_987:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00000987                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:0000098E                 ja      short loc_9A8
.text$mn:00000990                 mov     eax, [ebp+arg_0]
.text$mn:00000993                 shl     eax, 3
.text$mn:00000996                 push    eax             ; unsigned int
.text$mn:00000997                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000099C                 add     esp, 4
.text$mn:0000099F                 mov     [ebp+var_4], eax
.text$mn:000009A2                 cmp     [ebp+var_4], 0
.text$mn:000009A6                 jnz     short loc_9AD
.text$mn:000009A8
.text$mn:000009A8 loc_9A8:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:000009A8                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000009AD
.text$mn:000009AD loc_9AD:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000009AD                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000009AD                 mov     eax, [ebp+var_4]
.text$mn:000009B0                 mov     esp, ebp
.text$mn:000009B2                 pop     ebp
.text$mn:000009B3                 retn
.text$mn:000009B3 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000009B3
.text$mn:000009B3 _text$mn        ends
.text$mn:000009B3
.text$mn:000009B4 ; ===========================================================================
.text$mn:000009B4
.text$mn:000009B4 ; Segment type: Pure code
.text$mn:000009B4 ; Segment permissions: Read/Execute
.text$mn:000009B4 _text$mn        segment para public 'CODE' use32
.text$mn:000009B4                 assume cs:_text$mn
.text$mn:000009B4                 ;org 9B4h
.text$mn:000009B4 ; COMDAT (pick any)
.text$mn:000009B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009B4
.text$mn:000009B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000009B4
.text$mn:000009B4 ; Attributes: bp-based frame
.text$mn:000009B4
.text$mn:000009B4 ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:000009B4                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:000009B4 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:000009B4                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:000009B4
.text$mn:000009B4 var_4           = dword ptr -4
.text$mn:000009B4 arg_0           = dword ptr  8
.text$mn:000009B4
.text$mn:000009B4                 push    ebp
.text$mn:000009B5                 mov     ebp, esp
.text$mn:000009B7                 push    ecx
.text$mn:000009B8                 mov     [ebp+var_4], 0
.text$mn:000009BF                 cmp     [ebp+arg_0], 0
.text$mn:000009C3                 jnz     short loc_9C7
.text$mn:000009C5                 jmp     short loc_9EC
.text$mn:000009C7 ; ---------------------------------------------------------------------------
.text$mn:000009C7
.text$mn:000009C7 loc_9C7:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:000009C7                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:000009CE                 ja      short loc_9E7
.text$mn:000009D0                 mov     eax, [ebp+arg_0]
.text$mn:000009D3                 shl     eax, 1
.text$mn:000009D5                 push    eax             ; unsigned int
.text$mn:000009D6                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000009DB                 add     esp, 4
.text$mn:000009DE                 mov     [ebp+var_4], eax
.text$mn:000009E1                 cmp     [ebp+var_4], 0
.text$mn:000009E5                 jnz     short loc_9EC
.text$mn:000009E7
.text$mn:000009E7 loc_9E7:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:000009E7                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000009EC
.text$mn:000009EC loc_9EC:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:000009EC                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:000009EC                 mov     eax, [ebp+var_4]
.text$mn:000009EF                 mov     esp, ebp
.text$mn:000009F1                 pop     ebp
.text$mn:000009F2                 retn
.text$mn:000009F2 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:000009F2
.text$mn:000009F2 ; ---------------------------------------------------------------------------
.text$mn:000009F3                 align 4
.text$mn:000009F3 _text$mn        ends
.text$mn:000009F3
.text$mn:000009F4 ; ===========================================================================
.text$mn:000009F4
.text$mn:000009F4 ; Segment type: Pure code
.text$mn:000009F4 ; Segment permissions: Read/Execute
.text$mn:000009F4 _text$mn        segment para public 'CODE' use32
.text$mn:000009F4                 assume cs:_text$mn
.text$mn:000009F4                 ;org 9F4h
.text$mn:000009F4 ; COMDAT (pick any)
.text$mn:000009F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000009F4
.text$mn:000009F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000009F4
.text$mn:000009F4 ; Attributes: bp-based frame
.text$mn:000009F4
.text$mn:000009F4 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000009F4                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000009F4 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000009F4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000009F4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000009F4
.text$mn:000009F4 arg_0           = dword ptr  8
.text$mn:000009F4 arg_4           = dword ptr  0Ch
.text$mn:000009F4 arg_8           = dword ptr  10h
.text$mn:000009F4
.text$mn:000009F4                 push    ebp
.text$mn:000009F5                 mov     ebp, esp
.text$mn:000009F7                 cmp     [ebp+arg_0], 0
.text$mn:000009FB                 jnz     short loc_A12
.text$mn:000009FD                 mov     eax, [ebp+arg_8]
.text$mn:00000A00                 push    eax             ; unsigned int
.text$mn:00000A01                 mov     ecx, [ebp+arg_4]
.text$mn:00000A04                 push    ecx             ; wchar_t *
.text$mn:00000A05                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000A0A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00000A0F                 add     esp, 0Ch
.text$mn:00000A12
.text$mn:00000A12 loc_A12:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00000A12                 pop     ebp
.text$mn:00000A13                 retn
.text$mn:00000A13 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00000A13
.text$mn:00000A13 _text$mn        ends
.text$mn:00000A13
.text$mn:00000A14 ; ===========================================================================
.text$mn:00000A14
.text$mn:00000A14 ; Segment type: Pure code
.text$mn:00000A14 ; Segment permissions: Read/Execute
.text$mn:00000A14 _text$mn        segment para public 'CODE' use32
.text$mn:00000A14                 assume cs:_text$mn
.text$mn:00000A14                 ;org 0A14h
.text$mn:00000A14 ; COMDAT (pick any)
.text$mn:00000A14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A14
.text$mn:00000A14 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A14
.text$mn:00000A14 ; Attributes: bp-based frame
.text$mn:00000A14
.text$mn:00000A14 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:00000A14                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:00000A14 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:00000A14                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+15p
.text$mn:00000A14                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+1Dp ...
.text$mn:00000A14
.text$mn:00000A14 arg_0           = dword ptr  8
.text$mn:00000A14 arg_4           = dword ptr  0Ch
.text$mn:00000A14 arg_8           = dword ptr  10h
.text$mn:00000A14
.text$mn:00000A14                 push    ebp
.text$mn:00000A15                 mov     ebp, esp
.text$mn:00000A17                 cmp     [ebp+arg_0], 0
.text$mn:00000A1B                 jnz     short loc_A32
.text$mn:00000A1D                 mov     eax, [ebp+arg_8]
.text$mn:00000A20                 push    eax             ; unsigned int
.text$mn:00000A21                 mov     ecx, [ebp+arg_4]
.text$mn:00000A24                 push    ecx             ; wchar_t *
.text$mn:00000A25                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000A2A                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00000A2F                 add     esp, 0Ch
.text$mn:00000A32
.text$mn:00000A32 loc_A32:                                ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:00000A32                 pop     ebp
.text$mn:00000A33                 retn
.text$mn:00000A33 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:00000A33
.text$mn:00000A33 _text$mn        ends
.text$mn:00000A33
.text$mn:00000A34 ; ===========================================================================
.text$mn:00000A34
.text$mn:00000A34 ; Segment type: Pure code
.text$mn:00000A34 ; Segment permissions: Read/Execute
.text$mn:00000A34 _text$mn        segment para public 'CODE' use32
.text$mn:00000A34                 assume cs:_text$mn
.text$mn:00000A34                 ;org 0A34h
.text$mn:00000A34 ; COMDAT (pick any)
.text$mn:00000A34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A34
.text$mn:00000A34 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A34
.text$mn:00000A34 ; Attributes: bp-based frame
.text$mn:00000A34
.text$mn:00000A34 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00000A34                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00000A34 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00000A34                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00000A34                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00000A34
.text$mn:00000A34 arg_0           = dword ptr  8
.text$mn:00000A34
.text$mn:00000A34                 push    ebp
.text$mn:00000A35                 mov     ebp, esp
.text$mn:00000A37                 mov     eax, [ebp+arg_0]
.text$mn:00000A3A                 pop     ebp
.text$mn:00000A3B                 retn
.text$mn:00000A3B ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00000A3B
.text$mn:00000A3B _text$mn        ends
.text$mn:00000A3B
.text$mn:00000A3C ; ===========================================================================
.text$mn:00000A3C
.text$mn:00000A3C ; Segment type: Pure code
.text$mn:00000A3C ; Segment permissions: Read/Execute
.text$mn:00000A3C _text$mn        segment para public 'CODE' use32
.text$mn:00000A3C                 assume cs:_text$mn
.text$mn:00000A3C                 ;org 0A3Ch
.text$mn:00000A3C ; COMDAT (pick any)
.text$mn:00000A3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A3C
.text$mn:00000A3C ; =============== S U B R O U T I N E =======================================
.text$mn:00000A3C
.text$mn:00000A3C ; Attributes: bp-based frame
.text$mn:00000A3C
.text$mn:00000A3C ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:00000A3C                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:00000A3C ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:00000A3C                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:00000A3C                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:00000A3C
.text$mn:00000A3C arg_0           = dword ptr  8
.text$mn:00000A3C
.text$mn:00000A3C                 push    ebp
.text$mn:00000A3D                 mov     ebp, esp
.text$mn:00000A3F                 mov     eax, [ebp+arg_0]
.text$mn:00000A42                 pop     ebp
.text$mn:00000A43                 retn
.text$mn:00000A43 ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:00000A43
.text$mn:00000A43 _text$mn        ends
.text$mn:00000A43
.text$mn:00000A44 ; ===========================================================================
.text$mn:00000A44
.text$mn:00000A44 ; Segment type: Pure code
.text$mn:00000A44 ; Segment permissions: Read/Execute
.text$mn:00000A44 _text$mn        segment para public 'CODE' use32
.text$mn:00000A44                 assume cs:_text$mn
.text$mn:00000A44                 ;org 0A44h
.text$mn:00000A44 ; COMDAT (pick any)
.text$mn:00000A44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A44
.text$mn:00000A44 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A44
.text$mn:00000A44 ; Attributes: bp-based frame
.text$mn:00000A44
.text$mn:00000A44 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00000A44                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00000A44 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000A44                                         ; CODE XREF: $LN19+4Bp
.text$mn:00000A44
.text$mn:00000A44 var_4           = dword ptr -4
.text$mn:00000A44 arg_0           = dword ptr  8
.text$mn:00000A44 arg_4           = dword ptr  0Ch
.text$mn:00000A44
.text$mn:00000A44                 push    ebp
.text$mn:00000A45                 mov     ebp, esp
.text$mn:00000A47                 push    ecx
.text$mn:00000A48                 mov     [ebp+var_4], ecx
.text$mn:00000A4B                 mov     eax, [ebp+arg_4]
.text$mn:00000A4E                 push    eax
.text$mn:00000A4F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000A54                 add     esp, 4
.text$mn:00000A57                 push    eax             ; int
.text$mn:00000A58                 mov     ecx, [ebp+arg_0]
.text$mn:00000A5B                 push    ecx             ; void *
.text$mn:00000A5C                 mov     edx, [ebp+var_4]
.text$mn:00000A5F                 push    edx             ; int
.text$mn:00000A60                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00000A65                 add     esp, 0Ch
.text$mn:00000A68                 mov     esp, ebp
.text$mn:00000A6A                 pop     ebp
.text$mn:00000A6B                 retn    8
.text$mn:00000A6B ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000A6B
.text$mn:00000A6B ; ---------------------------------------------------------------------------
.text$mn:00000A6E                 align 10h
.text$mn:00000A6E _text$mn        ends
.text$mn:00000A6E
.text$mn:00000A70 ; ===========================================================================
.text$mn:00000A70
.text$mn:00000A70 ; Segment type: Pure code
.text$mn:00000A70 ; Segment permissions: Read/Execute
.text$mn:00000A70 _text$mn        segment para public 'CODE' use32
.text$mn:00000A70                 assume cs:_text$mn
.text$mn:00000A70                 ;org 0A70h
.text$mn:00000A70 ; COMDAT (pick any)
.text$mn:00000A70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000A70
.text$mn:00000A70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000A70
.text$mn:00000A70 ; Attributes: bp-based frame
.text$mn:00000A70
.text$mn:00000A70 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00000A70                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000A70 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000A70                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00000A70
.text$mn:00000A70 var_1C          = dword ptr -1Ch
.text$mn:00000A70 var_18          = dword ptr -18h
.text$mn:00000A70 var_14          = dword ptr -14h
.text$mn:00000A70 var_10          = dword ptr -10h
.text$mn:00000A70 var_C           = dword ptr -0Ch
.text$mn:00000A70 var_4           = dword ptr -4
.text$mn:00000A70 arg_0           = dword ptr  8
.text$mn:00000A70 arg_4           = dword ptr  0Ch
.text$mn:00000A70
.text$mn:00000A70                 push    ebp
.text$mn:00000A71                 mov     ebp, esp
.text$mn:00000A73                 push    0FFFFFFFFh
.text$mn:00000A75                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000A7A                 mov     eax, large fs:0
.text$mn:00000A80                 push    eax
.text$mn:00000A81                 sub     esp, 10h
.text$mn:00000A84                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000A89                 xor     eax, ebp
.text$mn:00000A8B                 push    eax
.text$mn:00000A8C                 lea     eax, [ebp+var_C]
.text$mn:00000A8F                 mov     large fs:0, eax
.text$mn:00000A95                 mov     [ebp+var_18], ecx
.text$mn:00000A98                 mov     eax, [ebp+arg_0]
.text$mn:00000A9B                 push    eax             ; void *
.text$mn:00000A9C                 push    4               ; unsigned int
.text$mn:00000A9E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000AA3                 add     esp, 8
.text$mn:00000AA6                 mov     [ebp+var_10], eax
.text$mn:00000AA9                 mov     [ebp+var_4], 0
.text$mn:00000AB0                 cmp     [ebp+var_10], 0
.text$mn:00000AB4                 jz      short loc_AD1
.text$mn:00000AB6                 mov     ecx, [ebp+arg_4]
.text$mn:00000AB9                 push    ecx
.text$mn:00000ABA                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000ABF                 add     esp, 4
.text$mn:00000AC2                 mov     edx, [ebp+var_10]
.text$mn:00000AC5                 mov     eax, [eax]
.text$mn:00000AC7                 mov     [edx], eax
.text$mn:00000AC9                 mov     ecx, [ebp+var_10]
.text$mn:00000ACC                 mov     [ebp+var_14], ecx
.text$mn:00000ACF                 jmp     short loc_AD8
.text$mn:00000AD1 ; ---------------------------------------------------------------------------
.text$mn:00000AD1
.text$mn:00000AD1 loc_AD1:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00000AD1                 mov     [ebp+var_14], 0
.text$mn:00000AD8
.text$mn:00000AD8 loc_AD8:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00000AD8                 mov     edx, [ebp+var_14]
.text$mn:00000ADB                 mov     [ebp+var_1C], edx
.text$mn:00000ADE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000AE5                 mov     ecx, [ebp+var_C]
.text$mn:00000AE8                 mov     large fs:0, ecx
.text$mn:00000AEF                 pop     ecx
.text$mn:00000AF0                 mov     esp, ebp
.text$mn:00000AF2                 pop     ebp
.text$mn:00000AF3                 retn    8
.text$mn:00000AF3 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000AF3
.text$mn:00000AF3 ; ---------------------------------------------------------------------------
.text$mn:00000AF6                 align 4
.text$mn:00000AF6 _text$mn        ends
.text$mn:00000AF6
.text$x:00000AF8 ; ===========================================================================
.text$x:00000AF8
.text$x:00000AF8 ; Segment type: Pure code
.text$x:00000AF8 ; Segment permissions: Read/Execute
.text$x:00000AF8 _text$x         segment para public 'CODE' use32
.text$x:00000AF8                 assume cs:_text$x
.text$x:00000AF8                 ;org 0AF8h
.text$x:00000AF8 ; COMDAT (pick associative to section at A70)
.text$x:00000AF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000AF8
.text$x:00000AF8 ; =============== S U B R O U T I N E =======================================
.text$x:00000AF8
.text$x:00000AF8
.text$x:00000AF8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00000AF8                                         ; DATA XREF: .xdata$x:0000377Co
.text$x:00000AF8                 mov     eax, [ebp+8]
.text$x:00000AFB                 push    eax
.text$x:00000AFC                 mov     eax, [ebp-10h]
.text$x:00000AFF                 push    eax             ; void *
.text$x:00000B00                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000B05                 add     esp, 8
.text$x:00000B08                 retn
.text$x:00000B08 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00000B08
.text$x:00000B09
.text$x:00000B09 ; =============== S U B R O U T I N E =======================================
.text$x:00000B09
.text$x:00000B09
.text$x:00000B09 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00000B09                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00000B09
.text$x:00000B09 arg_4           = dword ptr  8
.text$x:00000B09
.text$x:00000B09                 mov     edx, [esp+arg_4]
.text$x:00000B0D                 lea     eax, [edx+0Ch]
.text$x:00000B10                 mov     ecx, [edx-14h]
.text$x:00000B13                 xor     ecx, eax
.text$x:00000B15                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000B1A                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00000B1F                 jmp     ___CxxFrameHandler3
.text$x:00000B1F __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00000B1F
.text$x:00000B1F _text$x         ends
.text$x:00000B1F
.text$mn:00000B24 ; ===========================================================================
.text$mn:00000B24
.text$mn:00000B24 ; Segment type: Pure code
.text$mn:00000B24 ; Segment permissions: Read/Execute
.text$mn:00000B24 _text$mn        segment para public 'CODE' use32
.text$mn:00000B24                 assume cs:_text$mn
.text$mn:00000B24                 ;org 0B24h
.text$mn:00000B24 ; COMDAT (pick any)
.text$mn:00000B24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B24
.text$mn:00000B24 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B24
.text$mn:00000B24 ; Attributes: bp-based frame
.text$mn:00000B24
.text$mn:00000B24 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00000B24                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00000B24 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00000B24                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00000B24
.text$mn:00000B24 arg_0           = dword ptr  8
.text$mn:00000B24 arg_4           = dword ptr  0Ch
.text$mn:00000B24 arg_8           = dword ptr  10h
.text$mn:00000B24
.text$mn:00000B24                 push    ebp
.text$mn:00000B25                 mov     ebp, esp
.text$mn:00000B27                 mov     eax, [ebp+arg_8]
.text$mn:00000B2A                 push    eax
.text$mn:00000B2B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000B30                 add     esp, 4
.text$mn:00000B33                 push    eax             ; int
.text$mn:00000B34                 mov     ecx, [ebp+arg_4]
.text$mn:00000B37                 push    ecx             ; void *
.text$mn:00000B38                 mov     ecx, [ebp+arg_0]
.text$mn:00000B3B                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00000B40                 pop     ebp
.text$mn:00000B41                 retn
.text$mn:00000B41 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00000B41
.text$mn:00000B41 ; ---------------------------------------------------------------------------
.text$mn:00000B42                 align 4
.text$mn:00000B42 _text$mn        ends
.text$mn:00000B42
.text$mn:00000B44 ; ===========================================================================
.text$mn:00000B44
.text$mn:00000B44 ; Segment type: Pure code
.text$mn:00000B44 ; Segment permissions: Read/Execute
.text$mn:00000B44 _text$mn        segment para public 'CODE' use32
.text$mn:00000B44                 assume cs:_text$mn
.text$mn:00000B44                 ;org 0B44h
.text$mn:00000B44 ; COMDAT (pick any)
.text$mn:00000B44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B44
.text$mn:00000B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B44
.text$mn:00000B44 ; Attributes: bp-based frame
.text$mn:00000B44
.text$mn:00000B44 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00000B44                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00000B44 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00000B44                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:00000B44
.text$mn:00000B44 var_4           = dword ptr -4
.text$mn:00000B44 arg_0           = dword ptr  8
.text$mn:00000B44 arg_4           = dword ptr  0Ch
.text$mn:00000B44
.text$mn:00000B44                 push    ebp
.text$mn:00000B45                 mov     ebp, esp
.text$mn:00000B47                 push    ecx
.text$mn:00000B48                 mov     [ebp+var_4], ecx
.text$mn:00000B4B                 mov     eax, [ebp+arg_4]
.text$mn:00000B4E                 push    eax
.text$mn:00000B4F                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000B54                 add     esp, 4
.text$mn:00000B57                 push    eax             ; int
.text$mn:00000B58                 mov     ecx, [ebp+arg_0]
.text$mn:00000B5B                 push    ecx             ; void *
.text$mn:00000B5C                 mov     edx, [ebp+var_4]
.text$mn:00000B5F                 push    edx             ; int
.text$mn:00000B60                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:00000B65                 add     esp, 0Ch
.text$mn:00000B68                 mov     esp, ebp
.text$mn:00000B6A                 pop     ebp
.text$mn:00000B6B                 retn    8
.text$mn:00000B6B ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00000B6B
.text$mn:00000B6B ; ---------------------------------------------------------------------------
.text$mn:00000B6E                 align 10h
.text$mn:00000B6E _text$mn        ends
.text$mn:00000B6E
.text$mn:00000B70 ; ===========================================================================
.text$mn:00000B70
.text$mn:00000B70 ; Segment type: Pure code
.text$mn:00000B70 ; Segment permissions: Read/Execute
.text$mn:00000B70 _text$mn        segment para public 'CODE' use32
.text$mn:00000B70                 assume cs:_text$mn
.text$mn:00000B70                 ;org 0B70h
.text$mn:00000B70 ; COMDAT (pick any)
.text$mn:00000B70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000B70
.text$mn:00000B70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000B70
.text$mn:00000B70 ; Attributes: bp-based frame
.text$mn:00000B70
.text$mn:00000B70 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00000B70                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00000B70 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00000B70                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:00000B70
.text$mn:00000B70 var_1C          = dword ptr -1Ch
.text$mn:00000B70 var_18          = dword ptr -18h
.text$mn:00000B70 var_14          = dword ptr -14h
.text$mn:00000B70 var_10          = dword ptr -10h
.text$mn:00000B70 var_C           = dword ptr -0Ch
.text$mn:00000B70 var_4           = dword ptr -4
.text$mn:00000B70 arg_0           = dword ptr  8
.text$mn:00000B70 arg_4           = dword ptr  0Ch
.text$mn:00000B70
.text$mn:00000B70                 push    ebp
.text$mn:00000B71                 mov     ebp, esp
.text$mn:00000B73                 push    0FFFFFFFFh
.text$mn:00000B75                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00000B7A                 mov     eax, large fs:0
.text$mn:00000B80                 push    eax
.text$mn:00000B81                 sub     esp, 10h
.text$mn:00000B84                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000B89                 xor     eax, ebp
.text$mn:00000B8B                 push    eax
.text$mn:00000B8C                 lea     eax, [ebp+var_C]
.text$mn:00000B8F                 mov     large fs:0, eax
.text$mn:00000B95                 mov     [ebp+var_18], ecx
.text$mn:00000B98                 mov     eax, [ebp+arg_0]
.text$mn:00000B9B                 push    eax             ; void *
.text$mn:00000B9C                 push    4               ; unsigned int
.text$mn:00000B9E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000BA3                 add     esp, 8
.text$mn:00000BA6                 mov     [ebp+var_10], eax
.text$mn:00000BA9                 mov     [ebp+var_4], 0
.text$mn:00000BB0                 cmp     [ebp+var_10], 0
.text$mn:00000BB4                 jz      short loc_BD1
.text$mn:00000BB6                 mov     ecx, [ebp+arg_4]
.text$mn:00000BB9                 push    ecx
.text$mn:00000BBA                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000BBF                 add     esp, 4
.text$mn:00000BC2                 mov     edx, [ebp+var_10]
.text$mn:00000BC5                 mov     eax, [eax]
.text$mn:00000BC7                 mov     [edx], eax
.text$mn:00000BC9                 mov     ecx, [ebp+var_10]
.text$mn:00000BCC                 mov     [ebp+var_14], ecx
.text$mn:00000BCF                 jmp     short loc_BD8
.text$mn:00000BD1 ; ---------------------------------------------------------------------------
.text$mn:00000BD1
.text$mn:00000BD1 loc_BD1:                                ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:00000BD1                 mov     [ebp+var_14], 0
.text$mn:00000BD8
.text$mn:00000BD8 loc_BD8:                                ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:00000BD8                 mov     edx, [ebp+var_14]
.text$mn:00000BDB                 mov     [ebp+var_1C], edx
.text$mn:00000BDE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000BE5                 mov     ecx, [ebp+var_C]
.text$mn:00000BE8                 mov     large fs:0, ecx
.text$mn:00000BEF                 pop     ecx
.text$mn:00000BF0                 mov     esp, ebp
.text$mn:00000BF2                 pop     ebp
.text$mn:00000BF3                 retn    8
.text$mn:00000BF3 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:00000BF3
.text$mn:00000BF3 ; ---------------------------------------------------------------------------
.text$mn:00000BF6                 align 4
.text$mn:00000BF6 _text$mn        ends
.text$mn:00000BF6
.text$x:00000BF8 ; ===========================================================================
.text$x:00000BF8
.text$x:00000BF8 ; Segment type: Pure code
.text$x:00000BF8 ; Segment permissions: Read/Execute
.text$x:00000BF8 _text$x         segment para public 'CODE' use32
.text$x:00000BF8                 assume cs:_text$x
.text$x:00000BF8                 ;org 0BF8h
.text$x:00000BF8 ; COMDAT (pick associative to section at B70)
.text$x:00000BF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000BF8
.text$x:00000BF8 ; =============== S U B R O U T I N E =======================================
.text$x:00000BF8
.text$x:00000BF8
.text$x:00000BF8 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:00000BF8                                         ; DATA XREF: .xdata$x:000037A8o
.text$x:00000BF8                 mov     eax, [ebp+8]
.text$x:00000BFB                 push    eax
.text$x:00000BFC                 mov     eax, [ebp-10h]
.text$x:00000BFF                 push    eax             ; void *
.text$x:00000C00                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000C05                 add     esp, 8
.text$x:00000C08                 retn
.text$x:00000C08 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:00000C08
.text$x:00000C09
.text$x:00000C09 ; =============== S U B R O U T I N E =======================================
.text$x:00000C09
.text$x:00000C09
.text$x:00000C09 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:00000C09                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:00000C09
.text$x:00000C09 arg_4           = dword ptr  8
.text$x:00000C09
.text$x:00000C09                 mov     edx, [esp+arg_4]
.text$x:00000C0D                 lea     eax, [edx+0Ch]
.text$x:00000C10                 mov     ecx, [edx-14h]
.text$x:00000C13                 xor     ecx, eax
.text$x:00000C15                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000C1A                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:00000C1F                 jmp     ___CxxFrameHandler3
.text$x:00000C1F __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:00000C1F
.text$x:00000C1F _text$x         ends
.text$x:00000C1F
.text$mn:00000C24 ; ===========================================================================
.text$mn:00000C24
.text$mn:00000C24 ; Segment type: Pure code
.text$mn:00000C24 ; Segment permissions: Read/Execute
.text$mn:00000C24 _text$mn        segment para public 'CODE' use32
.text$mn:00000C24                 assume cs:_text$mn
.text$mn:00000C24                 ;org 0C24h
.text$mn:00000C24 ; COMDAT (pick any)
.text$mn:00000C24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C24
.text$mn:00000C24 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C24
.text$mn:00000C24 ; Attributes: bp-based frame
.text$mn:00000C24
.text$mn:00000C24 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:00000C24                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:00000C24 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:00000C24                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:00000C24
.text$mn:00000C24 arg_0           = dword ptr  8
.text$mn:00000C24 arg_4           = dword ptr  0Ch
.text$mn:00000C24 arg_8           = dword ptr  10h
.text$mn:00000C24
.text$mn:00000C24                 push    ebp
.text$mn:00000C25                 mov     ebp, esp
.text$mn:00000C27                 mov     eax, [ebp+arg_8]
.text$mn:00000C2A                 push    eax
.text$mn:00000C2B                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000C30                 add     esp, 4
.text$mn:00000C33                 push    eax             ; int
.text$mn:00000C34                 mov     ecx, [ebp+arg_4]
.text$mn:00000C37                 push    ecx             ; void *
.text$mn:00000C38                 mov     ecx, [ebp+arg_0]
.text$mn:00000C3B                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00000C40                 pop     ebp
.text$mn:00000C41                 retn
.text$mn:00000C41 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:00000C41
.text$mn:00000C41 ; ---------------------------------------------------------------------------
.text$mn:00000C42                 align 4
.text$mn:00000C42 _text$mn        ends
.text$mn:00000C42
.text$mn:00000C44 ; ===========================================================================
.text$mn:00000C44
.text$mn:00000C44 ; Segment type: Pure code
.text$mn:00000C44 ; Segment permissions: Read/Execute
.text$mn:00000C44 _text$mn        segment para public 'CODE' use32
.text$mn:00000C44                 assume cs:_text$mn
.text$mn:00000C44                 ;org 0C44h
.text$mn:00000C44 ; COMDAT (pick any)
.text$mn:00000C44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000C44
.text$mn:00000C44 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C44
.text$mn:00000C44 ; Attributes: bp-based frame
.text$mn:00000C44
.text$mn:00000C44 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00000C44                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000C44 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00000C44                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00000C44                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+32p
.text$mn:00000C44
.text$mn:00000C44 var_1C          = dword ptr -1Ch
.text$mn:00000C44 var_18          = dword ptr -18h
.text$mn:00000C44 var_14          = dword ptr -14h
.text$mn:00000C44 var_10          = dword ptr -10h
.text$mn:00000C44 var_C           = dword ptr -0Ch
.text$mn:00000C44 var_4           = dword ptr -4
.text$mn:00000C44 arg_0           = dword ptr  8
.text$mn:00000C44 arg_4           = dword ptr  0Ch
.text$mn:00000C44
.text$mn:00000C44                 push    ebp
.text$mn:00000C45                 mov     ebp, esp
.text$mn:00000C47                 push    0FFFFFFFFh
.text$mn:00000C49                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00000C4E                 mov     eax, large fs:0
.text$mn:00000C54                 push    eax
.text$mn:00000C55                 sub     esp, 10h
.text$mn:00000C58                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C5D                 xor     eax, ebp
.text$mn:00000C5F                 push    eax
.text$mn:00000C60                 lea     eax, [ebp+var_C]
.text$mn:00000C63                 mov     large fs:0, eax
.text$mn:00000C69                 mov     [ebp+var_18], ecx
.text$mn:00000C6C                 mov     eax, [ebp+arg_0]
.text$mn:00000C6F                 push    eax             ; void *
.text$mn:00000C70                 push    8               ; unsigned int
.text$mn:00000C72                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000C77                 add     esp, 8
.text$mn:00000C7A                 mov     [ebp+var_10], eax
.text$mn:00000C7D                 mov     [ebp+var_4], 0
.text$mn:00000C84                 cmp     [ebp+var_10], 0
.text$mn:00000C88                 jz      short loc_CAB
.text$mn:00000C8A                 mov     ecx, [ebp+arg_4]
.text$mn:00000C8D                 push    ecx
.text$mn:00000C8E                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00000C93                 add     esp, 4
.text$mn:00000C96                 mov     edx, [eax]
.text$mn:00000C98                 mov     eax, [eax+4]
.text$mn:00000C9B                 mov     ecx, [ebp+var_10]
.text$mn:00000C9E                 mov     [ecx], edx
.text$mn:00000CA0                 mov     [ecx+4], eax
.text$mn:00000CA3                 mov     edx, [ebp+var_10]
.text$mn:00000CA6                 mov     [ebp+var_14], edx
.text$mn:00000CA9                 jmp     short loc_CB2
.text$mn:00000CAB ; ---------------------------------------------------------------------------
.text$mn:00000CAB
.text$mn:00000CAB loc_CAB:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00000CAB                 mov     [ebp+var_14], 0
.text$mn:00000CB2
.text$mn:00000CB2 loc_CB2:                                ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00000CB2                 mov     eax, [ebp+var_14]
.text$mn:00000CB5                 mov     [ebp+var_1C], eax
.text$mn:00000CB8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000CBF                 mov     ecx, [ebp+var_C]
.text$mn:00000CC2                 mov     large fs:0, ecx
.text$mn:00000CC9                 pop     ecx
.text$mn:00000CCA                 mov     esp, ebp
.text$mn:00000CCC                 pop     ebp
.text$mn:00000CCD                 retn    8
.text$mn:00000CCD ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00000CCD
.text$mn:00000CCD _text$mn        ends
.text$mn:00000CCD
.text$x:00000CD0 ; ===========================================================================
.text$x:00000CD0
.text$x:00000CD0 ; Segment type: Pure code
.text$x:00000CD0 ; Segment permissions: Read/Execute
.text$x:00000CD0 _text$x         segment para public 'CODE' use32
.text$x:00000CD0                 assume cs:_text$x
.text$x:00000CD0                 ;org 0CD0h
.text$x:00000CD0 ; COMDAT (pick associative to section at C44)
.text$x:00000CD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000CD0
.text$x:00000CD0 ; =============== S U B R O U T I N E =======================================
.text$x:00000CD0
.text$x:00000CD0
.text$x:00000CD0 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00000CD0                                         ; DATA XREF: .xdata$x:00003750o
.text$x:00000CD0                 mov     eax, [ebp+8]
.text$x:00000CD3                 push    eax
.text$x:00000CD4                 mov     eax, [ebp-10h]
.text$x:00000CD7                 push    eax             ; void *
.text$x:00000CD8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000CDD                 add     esp, 8
.text$x:00000CE0                 retn
.text$x:00000CE0 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00000CE0
.text$x:00000CE1
.text$x:00000CE1 ; =============== S U B R O U T I N E =======================================
.text$x:00000CE1
.text$x:00000CE1
.text$x:00000CE1 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00000CE1                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00000CE1
.text$x:00000CE1 arg_4           = dword ptr  8
.text$x:00000CE1
.text$x:00000CE1                 mov     edx, [esp+arg_4]
.text$x:00000CE5                 lea     eax, [edx+0Ch]
.text$x:00000CE8                 mov     ecx, [edx-14h]
.text$x:00000CEB                 xor     ecx, eax
.text$x:00000CED                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000CF2                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00000CF7                 jmp     ___CxxFrameHandler3
.text$x:00000CF7 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00000CF7
.text$x:00000CF7 _text$x         ends
.text$x:00000CF7
.text$mn:00000CFC ; ===========================================================================
.text$mn:00000CFC
.text$mn:00000CFC ; Segment type: Pure code
.text$mn:00000CFC ; Segment permissions: Read/Execute
.text$mn:00000CFC _text$mn        segment para public 'CODE' use32
.text$mn:00000CFC                 assume cs:_text$mn
.text$mn:00000CFC                 ;org 0CFCh
.text$mn:00000CFC ; COMDAT (pick any)
.text$mn:00000CFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000CFC
.text$mn:00000CFC ; =============== S U B R O U T I N E =======================================
.text$mn:00000CFC
.text$mn:00000CFC ; Attributes: bp-based frame
.text$mn:00000CFC
.text$mn:00000CFC ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00000CFC                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00000CFC ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00000CFC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00000CFC
.text$mn:00000CFC var_4           = dword ptr -4
.text$mn:00000CFC arg_0           = dword ptr  8
.text$mn:00000CFC
.text$mn:00000CFC                 push    ebp
.text$mn:00000CFD                 mov     ebp, esp
.text$mn:00000CFF                 push    ecx
.text$mn:00000D00                 mov     [ebp+var_4], ecx
.text$mn:00000D03                 mov     eax, [ebp+arg_0]
.text$mn:00000D06                 push    eax
.text$mn:00000D07                 mov     ecx, [ebp+var_4]
.text$mn:00000D0A                 push    ecx
.text$mn:00000D0B                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00000D10                 add     esp, 8
.text$mn:00000D13                 mov     esp, ebp
.text$mn:00000D15                 pop     ebp
.text$mn:00000D16                 retn    4
.text$mn:00000D16 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00000D16
.text$mn:00000D16 ; ---------------------------------------------------------------------------
.text$mn:00000D19                 align 4
.text$mn:00000D19 _text$mn        ends
.text$mn:00000D19
.text$mn:00000D1C ; ===========================================================================
.text$mn:00000D1C
.text$mn:00000D1C ; Segment type: Pure code
.text$mn:00000D1C ; Segment permissions: Read/Execute
.text$mn:00000D1C _text$mn        segment para public 'CODE' use32
.text$mn:00000D1C                 assume cs:_text$mn
.text$mn:00000D1C                 ;org 0D1Ch
.text$mn:00000D1C ; COMDAT (pick any)
.text$mn:00000D1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D1C
.text$mn:00000D1C ; =============== S U B R O U T I N E =======================================
.text$mn:00000D1C
.text$mn:00000D1C ; Attributes: bp-based frame
.text$mn:00000D1C
.text$mn:00000D1C ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000D1C                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00000D1C ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00000D1C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00000D1C
.text$mn:00000D1C var_4           = dword ptr -4
.text$mn:00000D1C
.text$mn:00000D1C                 push    ebp
.text$mn:00000D1D                 mov     ebp, esp
.text$mn:00000D1F                 push    ecx
.text$mn:00000D20                 mov     [ebp+var_4], ecx
.text$mn:00000D23                 mov     esp, ebp
.text$mn:00000D25                 pop     ebp
.text$mn:00000D26                 retn    4
.text$mn:00000D26 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00000D26
.text$mn:00000D26 ; ---------------------------------------------------------------------------
.text$mn:00000D29                 align 4
.text$mn:00000D29 _text$mn        ends
.text$mn:00000D29
.text$mn:00000D2C ; ===========================================================================
.text$mn:00000D2C
.text$mn:00000D2C ; Segment type: Pure code
.text$mn:00000D2C ; Segment permissions: Read/Execute
.text$mn:00000D2C _text$mn        segment para public 'CODE' use32
.text$mn:00000D2C                 assume cs:_text$mn
.text$mn:00000D2C                 ;org 0D2Ch
.text$mn:00000D2C ; COMDAT (pick any)
.text$mn:00000D2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D2C
.text$mn:00000D2C ; =============== S U B R O U T I N E =======================================
.text$mn:00000D2C
.text$mn:00000D2C ; Attributes: bp-based frame
.text$mn:00000D2C
.text$mn:00000D2C ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00000D2C                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00000D2C ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00000D2C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00000D2C
.text$mn:00000D2C arg_0           = dword ptr  8
.text$mn:00000D2C arg_4           = dword ptr  0Ch
.text$mn:00000D2C
.text$mn:00000D2C                 push    ebp
.text$mn:00000D2D                 mov     ebp, esp
.text$mn:00000D2F                 mov     eax, [ebp+arg_4]
.text$mn:00000D32                 push    eax
.text$mn:00000D33                 mov     ecx, [ebp+arg_0]
.text$mn:00000D36                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00000D3B                 pop     ebp
.text$mn:00000D3C                 retn
.text$mn:00000D3C ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00000D3C
.text$mn:00000D3C ; ---------------------------------------------------------------------------
.text$mn:00000D3D                 align 10h
.text$mn:00000D3D _text$mn        ends
.text$mn:00000D3D
.text$mn:00000D40 ; ===========================================================================
.text$mn:00000D40
.text$mn:00000D40 ; Segment type: Pure code
.text$mn:00000D40 ; Segment permissions: Read/Execute
.text$mn:00000D40 _text$mn        segment para public 'CODE' use32
.text$mn:00000D40                 assume cs:_text$mn
.text$mn:00000D40                 ;org 0D40h
.text$mn:00000D40 ; COMDAT (pick any)
.text$mn:00000D40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D40
.text$mn:00000D40 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D40
.text$mn:00000D40 ; Attributes: bp-based frame
.text$mn:00000D40
.text$mn:00000D40 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00000D40                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00000D40 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00000D40                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00000D40
.text$mn:00000D40 var_4           = dword ptr -4
.text$mn:00000D40 arg_0           = dword ptr  8
.text$mn:00000D40
.text$mn:00000D40                 push    ebp
.text$mn:00000D41                 mov     ebp, esp
.text$mn:00000D43                 push    ecx
.text$mn:00000D44                 mov     [ebp+var_4], ecx
.text$mn:00000D47                 mov     eax, [ebp+arg_0]
.text$mn:00000D4A                 push    eax
.text$mn:00000D4B                 mov     ecx, [ebp+var_4]
.text$mn:00000D4E                 push    ecx
.text$mn:00000D4F                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00000D54                 add     esp, 8
.text$mn:00000D57                 mov     esp, ebp
.text$mn:00000D59                 pop     ebp
.text$mn:00000D5A                 retn    4
.text$mn:00000D5A ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00000D5A
.text$mn:00000D5A ; ---------------------------------------------------------------------------
.text$mn:00000D5D                 align 10h
.text$mn:00000D5D _text$mn        ends
.text$mn:00000D5D
.text$mn:00000D60 ; ===========================================================================
.text$mn:00000D60
.text$mn:00000D60 ; Segment type: Pure code
.text$mn:00000D60 ; Segment permissions: Read/Execute
.text$mn:00000D60 _text$mn        segment para public 'CODE' use32
.text$mn:00000D60                 assume cs:_text$mn
.text$mn:00000D60                 ;org 0D60h
.text$mn:00000D60 ; COMDAT (pick any)
.text$mn:00000D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D60
.text$mn:00000D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D60
.text$mn:00000D60 ; Attributes: bp-based frame
.text$mn:00000D60
.text$mn:00000D60 ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00000D60                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00000D60 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00000D60                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00000D60
.text$mn:00000D60 var_4           = dword ptr -4
.text$mn:00000D60
.text$mn:00000D60                 push    ebp
.text$mn:00000D61                 mov     ebp, esp
.text$mn:00000D63                 push    ecx
.text$mn:00000D64                 mov     [ebp+var_4], ecx
.text$mn:00000D67                 mov     esp, ebp
.text$mn:00000D69                 pop     ebp
.text$mn:00000D6A                 retn    4
.text$mn:00000D6A ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00000D6A
.text$mn:00000D6A ; ---------------------------------------------------------------------------
.text$mn:00000D6D                 align 10h
.text$mn:00000D6D _text$mn        ends
.text$mn:00000D6D
.text$mn:00000D70 ; ===========================================================================
.text$mn:00000D70
.text$mn:00000D70 ; Segment type: Pure code
.text$mn:00000D70 ; Segment permissions: Read/Execute
.text$mn:00000D70 _text$mn        segment para public 'CODE' use32
.text$mn:00000D70                 assume cs:_text$mn
.text$mn:00000D70                 ;org 0D70h
.text$mn:00000D70 ; COMDAT (pick any)
.text$mn:00000D70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D70
.text$mn:00000D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D70
.text$mn:00000D70 ; Attributes: bp-based frame
.text$mn:00000D70
.text$mn:00000D70 ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00000D70                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00000D70 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00000D70                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00000D70
.text$mn:00000D70 arg_0           = dword ptr  8
.text$mn:00000D70 arg_4           = dword ptr  0Ch
.text$mn:00000D70
.text$mn:00000D70                 push    ebp
.text$mn:00000D71                 mov     ebp, esp
.text$mn:00000D73                 mov     eax, [ebp+arg_4]
.text$mn:00000D76                 push    eax
.text$mn:00000D77                 mov     ecx, [ebp+arg_0]
.text$mn:00000D7A                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00000D7F                 pop     ebp
.text$mn:00000D80                 retn
.text$mn:00000D80 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00000D80
.text$mn:00000D80 ; ---------------------------------------------------------------------------
.text$mn:00000D81                 align 4
.text$mn:00000D81 _text$mn        ends
.text$mn:00000D81
.text$mn:00000D84 ; ===========================================================================
.text$mn:00000D84
.text$mn:00000D84 ; Segment type: Pure code
.text$mn:00000D84 ; Segment permissions: Read/Execute
.text$mn:00000D84 _text$mn        segment para public 'CODE' use32
.text$mn:00000D84                 assume cs:_text$mn
.text$mn:00000D84                 ;org 0D84h
.text$mn:00000D84 ; COMDAT (pick any)
.text$mn:00000D84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D84
.text$mn:00000D84 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D84
.text$mn:00000D84 ; Attributes: bp-based frame
.text$mn:00000D84
.text$mn:00000D84 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00000D84                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00000D84 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00000D84                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00000D84                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+22p
.text$mn:00000D84
.text$mn:00000D84 var_4           = dword ptr -4
.text$mn:00000D84
.text$mn:00000D84                 push    ebp
.text$mn:00000D85                 mov     ebp, esp
.text$mn:00000D87                 push    ecx
.text$mn:00000D88                 mov     [ebp+var_4], ecx
.text$mn:00000D8B                 mov     esp, ebp
.text$mn:00000D8D                 pop     ebp
.text$mn:00000D8E                 retn    4
.text$mn:00000D8E ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00000D8E
.text$mn:00000D8E ; ---------------------------------------------------------------------------
.text$mn:00000D91                 align 4
.text$mn:00000D91 _text$mn        ends
.text$mn:00000D91
.text$mn:00000D94 ; ===========================================================================
.text$mn:00000D94
.text$mn:00000D94 ; Segment type: Pure code
.text$mn:00000D94 ; Segment permissions: Read/Execute
.text$mn:00000D94 _text$mn        segment para public 'CODE' use32
.text$mn:00000D94                 assume cs:_text$mn
.text$mn:00000D94                 ;org 0D94h
.text$mn:00000D94 ; COMDAT (pick any)
.text$mn:00000D94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D94
.text$mn:00000D94 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D94
.text$mn:00000D94 ; Attributes: bp-based frame
.text$mn:00000D94
.text$mn:00000D94 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00000D94                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00000D94 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00000D94                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00000D94                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00000D94
.text$mn:00000D94 arg_0           = dword ptr  8
.text$mn:00000D94
.text$mn:00000D94                 push    ebp
.text$mn:00000D95                 mov     ebp, esp
.text$mn:00000D97                 mov     eax, [ebp+arg_0]
.text$mn:00000D9A                 pop     ebp
.text$mn:00000D9B                 retn
.text$mn:00000D9B ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00000D9B
.text$mn:00000D9B _text$mn        ends
.text$mn:00000D9B
.text$mn:00000D9C ; ===========================================================================
.text$mn:00000D9C
.text$mn:00000D9C ; Segment type: Pure code
.text$mn:00000D9C ; Segment permissions: Read/Execute
.text$mn:00000D9C _text$mn        segment para public 'CODE' use32
.text$mn:00000D9C                 assume cs:_text$mn
.text$mn:00000D9C                 ;org 0D9Ch
.text$mn:00000D9C ; COMDAT (pick any)
.text$mn:00000D9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000D9C
.text$mn:00000D9C ; =============== S U B R O U T I N E =======================================
.text$mn:00000D9C
.text$mn:00000D9C ; Attributes: bp-based frame
.text$mn:00000D9C
.text$mn:00000D9C ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00000D9C                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:00000D9C ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:00000D9C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:00000D9C                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:00000D9C
.text$mn:00000D9C arg_0           = dword ptr  8
.text$mn:00000D9C
.text$mn:00000D9C                 push    ebp
.text$mn:00000D9D                 mov     ebp, esp
.text$mn:00000D9F                 mov     eax, [ebp+arg_0]
.text$mn:00000DA2                 pop     ebp
.text$mn:00000DA3                 retn
.text$mn:00000DA3 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:00000DA3
.text$mn:00000DA3 _text$mn        ends
.text$mn:00000DA3
.text$mn:00000DA4 ; ===========================================================================
.text$mn:00000DA4
.text$mn:00000DA4 ; Segment type: Pure code
.text$mn:00000DA4 ; Segment permissions: Read/Execute
.text$mn:00000DA4 _text$mn        segment para public 'CODE' use32
.text$mn:00000DA4                 assume cs:_text$mn
.text$mn:00000DA4                 ;org 0DA4h
.text$mn:00000DA4 ; COMDAT (pick any)
.text$mn:00000DA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DA4
.text$mn:00000DA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000DA4
.text$mn:00000DA4 ; Attributes: bp-based frame
.text$mn:00000DA4
.text$mn:00000DA4 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00000DA4                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00000DA4 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00000DA4                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00000DA4
.text$mn:00000DA4 arg_0           = dword ptr  8
.text$mn:00000DA4
.text$mn:00000DA4                 push    ebp
.text$mn:00000DA5                 mov     ebp, esp
.text$mn:00000DA7                 mov     eax, [ebp+arg_0]
.text$mn:00000DAA                 pop     ebp
.text$mn:00000DAB                 retn
.text$mn:00000DAB ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00000DAB
.text$mn:00000DAB _text$mn        ends
.text$mn:00000DAB
.text$mn:00000DAC ; ===========================================================================
.text$mn:00000DAC
.text$mn:00000DAC ; Segment type: Pure code
.text$mn:00000DAC ; Segment permissions: Read/Execute
.text$mn:00000DAC _text$mn        segment para public 'CODE' use32
.text$mn:00000DAC                 assume cs:_text$mn
.text$mn:00000DAC                 ;org 0DACh
.text$mn:00000DAC ; COMDAT (pick any)
.text$mn:00000DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DAC
.text$mn:00000DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DAC
.text$mn:00000DAC ; Attributes: bp-based frame
.text$mn:00000DAC
.text$mn:00000DAC ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00000DAC                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000DAC ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00000DAC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00000DAC
.text$mn:00000DAC var_10          = dword ptr -10h
.text$mn:00000DAC var_C           = dword ptr -0Ch
.text$mn:00000DAC var_4           = dword ptr -4
.text$mn:00000DAC
.text$mn:00000DAC                 push    ebp
.text$mn:00000DAD                 mov     ebp, esp
.text$mn:00000DAF                 push    0FFFFFFFFh
.text$mn:00000DB1                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00000DB6                 mov     eax, large fs:0
.text$mn:00000DBC                 push    eax
.text$mn:00000DBD                 push    ecx
.text$mn:00000DBE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000DC3                 xor     eax, ebp
.text$mn:00000DC5                 push    eax
.text$mn:00000DC6                 lea     eax, [ebp+var_C]
.text$mn:00000DC9                 mov     large fs:0, eax
.text$mn:00000DCF                 mov     [ebp+var_10], ecx
.text$mn:00000DD2                 mov     ecx, [ebp+var_10]
.text$mn:00000DD5                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00000DDA                 mov     [ebp+var_4], 0
.text$mn:00000DE1                 mov     ecx, [ebp+var_10]
.text$mn:00000DE4                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00000DE9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000DF0                 mov     eax, [ebp+var_10]
.text$mn:00000DF3                 mov     ecx, [ebp+var_C]
.text$mn:00000DF6                 mov     large fs:0, ecx
.text$mn:00000DFD                 pop     ecx
.text$mn:00000DFE                 mov     esp, ebp
.text$mn:00000E00                 pop     ebp
.text$mn:00000E01                 retn    4
.text$mn:00000E01 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00000E01
.text$mn:00000E01 _text$mn        ends
.text$mn:00000E01
.text$x:00000E04 ; ===========================================================================
.text$x:00000E04
.text$x:00000E04 ; Segment type: Pure code
.text$x:00000E04 ; Segment permissions: Read/Execute
.text$x:00000E04 _text$x         segment para public 'CODE' use32
.text$x:00000E04                 assume cs:_text$x
.text$x:00000E04                 ;org 0E04h
.text$x:00000E04 ; COMDAT (pick associative to section at DAC)
.text$x:00000E04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000E04
.text$x:00000E04 ; =============== S U B R O U T I N E =======================================
.text$x:00000E04
.text$x:00000E04
.text$x:00000E04 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00000E04                                         ; DATA XREF: .xdata$x:000032C8o
.text$x:00000E04                 mov     ecx, [ebp-10h]
.text$x:00000E07                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00000E07 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00000E07
.text$x:00000E0C
.text$x:00000E0C ; =============== S U B R O U T I N E =======================================
.text$x:00000E0C
.text$x:00000E0C
.text$x:00000E0C __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00000E0C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00000E0C
.text$x:00000E0C arg_4           = dword ptr  8
.text$x:00000E0C
.text$x:00000E0C                 mov     edx, [esp+arg_4]
.text$x:00000E10                 lea     eax, [edx+0Ch]
.text$x:00000E13                 mov     ecx, [edx-8]
.text$x:00000E16                 xor     ecx, eax
.text$x:00000E18                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E1D                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00000E22                 jmp     ___CxxFrameHandler3
.text$x:00000E22 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00000E22
.text$x:00000E22 ; ---------------------------------------------------------------------------
.text$x:00000E27                 align 4
.text$x:00000E27 _text$x         ends
.text$x:00000E27
.text$mn:00000E28 ; ===========================================================================
.text$mn:00000E28
.text$mn:00000E28 ; Segment type: Pure code
.text$mn:00000E28 ; Segment permissions: Read/Execute
.text$mn:00000E28 _text$mn        segment para public 'CODE' use32
.text$mn:00000E28                 assume cs:_text$mn
.text$mn:00000E28                 ;org 0E28h
.text$mn:00000E28 ; COMDAT (pick any)
.text$mn:00000E28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E28
.text$mn:00000E28 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E28
.text$mn:00000E28 ; Attributes: bp-based frame
.text$mn:00000E28
.text$mn:00000E28 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:00000E28                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00000E28 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00000E28                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+34p
.text$mn:00000E28
.text$mn:00000E28 var_10          = dword ptr -10h
.text$mn:00000E28 var_C           = dword ptr -0Ch
.text$mn:00000E28 var_4           = dword ptr -4
.text$mn:00000E28
.text$mn:00000E28                 push    ebp
.text$mn:00000E29                 mov     ebp, esp
.text$mn:00000E2B                 push    0FFFFFFFFh
.text$mn:00000E2D                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00000E32                 mov     eax, large fs:0
.text$mn:00000E38                 push    eax
.text$mn:00000E39                 push    ecx
.text$mn:00000E3A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000E3F                 xor     eax, ebp
.text$mn:00000E41                 push    eax
.text$mn:00000E42                 lea     eax, [ebp+var_C]
.text$mn:00000E45                 mov     large fs:0, eax
.text$mn:00000E4B                 mov     [ebp+var_10], ecx
.text$mn:00000E4E                 mov     ecx, [ebp+var_10]
.text$mn:00000E51                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00000E56                 mov     [ebp+var_4], 0
.text$mn:00000E5D                 mov     ecx, [ebp+var_10]
.text$mn:00000E60                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00000E65                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E6C                 mov     eax, [ebp+var_10]
.text$mn:00000E6F                 mov     ecx, [ebp+var_C]
.text$mn:00000E72                 mov     large fs:0, ecx
.text$mn:00000E79                 pop     ecx
.text$mn:00000E7A                 mov     esp, ebp
.text$mn:00000E7C                 pop     ebp
.text$mn:00000E7D                 retn    4
.text$mn:00000E7D ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00000E7D
.text$mn:00000E7D _text$mn        ends
.text$mn:00000E7D
.text$x:00000E80 ; ===========================================================================
.text$x:00000E80
.text$x:00000E80 ; Segment type: Pure code
.text$x:00000E80 ; Segment permissions: Read/Execute
.text$x:00000E80 _text$x         segment para public 'CODE' use32
.text$x:00000E80                 assume cs:_text$x
.text$x:00000E80                 ;org 0E80h
.text$x:00000E80 ; COMDAT (pick associative to section at E28)
.text$x:00000E80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000E80
.text$x:00000E80 ; =============== S U B R O U T I N E =======================================
.text$x:00000E80
.text$x:00000E80
.text$x:00000E80 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:00000E80                                         ; DATA XREF: .xdata$x:000035E8o
.text$x:00000E80                 mov     ecx, [ebp-10h]
.text$x:00000E83                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00000E83 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:00000E83
.text$x:00000E88
.text$x:00000E88 ; =============== S U B R O U T I N E =======================================
.text$x:00000E88
.text$x:00000E88
.text$x:00000E88 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:00000E88                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:00000E88
.text$x:00000E88 arg_4           = dword ptr  8
.text$x:00000E88
.text$x:00000E88                 mov     edx, [esp+arg_4]
.text$x:00000E8C                 lea     eax, [edx+0Ch]
.text$x:00000E8F                 mov     ecx, [edx-8]
.text$x:00000E92                 xor     ecx, eax
.text$x:00000E94                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E99                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:00000E9E                 jmp     ___CxxFrameHandler3
.text$x:00000E9E __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:00000E9E
.text$x:00000E9E ; ---------------------------------------------------------------------------
.text$x:00000EA3                 align 4
.text$x:00000EA3 _text$x         ends
.text$x:00000EA3
.text$mn:00000EA4 ; ===========================================================================
.text$mn:00000EA4
.text$mn:00000EA4 ; Segment type: Pure code
.text$mn:00000EA4 ; Segment permissions: Read/Execute
.text$mn:00000EA4 _text$mn        segment para public 'CODE' use32
.text$mn:00000EA4                 assume cs:_text$mn
.text$mn:00000EA4                 ;org 0EA4h
.text$mn:00000EA4 ; COMDAT (pick any)
.text$mn:00000EA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000EA4
.text$mn:00000EA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EA4
.text$mn:00000EA4 ; Attributes: bp-based frame
.text$mn:00000EA4
.text$mn:00000EA4 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00000EA4                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000EA4 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00000EA4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00000EA4
.text$mn:00000EA4 var_10          = dword ptr -10h
.text$mn:00000EA4 var_C           = dword ptr -0Ch
.text$mn:00000EA4 var_4           = dword ptr -4
.text$mn:00000EA4
.text$mn:00000EA4                 push    ebp
.text$mn:00000EA5                 mov     ebp, esp
.text$mn:00000EA7                 push    0FFFFFFFFh
.text$mn:00000EA9                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00000EAE                 mov     eax, large fs:0
.text$mn:00000EB4                 push    eax
.text$mn:00000EB5                 push    ecx
.text$mn:00000EB6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000EBB                 xor     eax, ebp
.text$mn:00000EBD                 push    eax
.text$mn:00000EBE                 lea     eax, [ebp+var_C]
.text$mn:00000EC1                 mov     large fs:0, eax
.text$mn:00000EC7                 mov     [ebp+var_10], ecx
.text$mn:00000ECA                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000ECD                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00000ED2                 mov     [ebp+var_4], 0
.text$mn:00000ED9                 mov     eax, [ebp+var_10]
.text$mn:00000EDC                 mov     dword ptr [eax+14h], 0
.text$mn:00000EE3                 mov     ecx, [ebp+var_10]
.text$mn:00000EE6                 mov     dword ptr [ecx+18h], 0
.text$mn:00000EED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000EF4                 mov     eax, [ebp+var_10]
.text$mn:00000EF7                 mov     ecx, [ebp+var_C]
.text$mn:00000EFA                 mov     large fs:0, ecx
.text$mn:00000F01                 pop     ecx
.text$mn:00000F02                 mov     esp, ebp
.text$mn:00000F04                 pop     ebp
.text$mn:00000F05                 retn
.text$mn:00000F05 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00000F05
.text$mn:00000F05 ; ---------------------------------------------------------------------------
.text$mn:00000F06                 align 4
.text$mn:00000F06 _text$mn        ends
.text$mn:00000F06
.text$x:00000F08 ; ===========================================================================
.text$x:00000F08
.text$x:00000F08 ; Segment type: Pure code
.text$x:00000F08 ; Segment permissions: Read/Execute
.text$x:00000F08 _text$x         segment para public 'CODE' use32
.text$x:00000F08                 assume cs:_text$x
.text$x:00000F08                 ;org 0F08h
.text$x:00000F08 ; COMDAT (pick associative to section at EA4)
.text$x:00000F08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000F08
.text$x:00000F08 ; =============== S U B R O U T I N E =======================================
.text$x:00000F08
.text$x:00000F08
.text$x:00000F08 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00000F08                                         ; DATA XREF: .xdata$x:00003270o
.text$x:00000F08                 mov     ecx, [ebp-10h]  ; this
.text$x:00000F0B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000F0B __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00000F0B
.text$x:00000F10
.text$x:00000F10 ; =============== S U B R O U T I N E =======================================
.text$x:00000F10
.text$x:00000F10
.text$x:00000F10 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00000F10                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00000F10
.text$x:00000F10 arg_4           = dword ptr  8
.text$x:00000F10
.text$x:00000F10                 mov     edx, [esp+arg_4]
.text$x:00000F14                 lea     eax, [edx+0Ch]
.text$x:00000F17                 mov     ecx, [edx-8]
.text$x:00000F1A                 xor     ecx, eax
.text$x:00000F1C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000F21                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00000F26                 jmp     ___CxxFrameHandler3
.text$x:00000F26 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00000F26
.text$x:00000F26 ; ---------------------------------------------------------------------------
.text$x:00000F2B                 align 4
.text$x:00000F2B _text$x         ends
.text$x:00000F2B
.text$mn:00000F2C ; ===========================================================================
.text$mn:00000F2C
.text$mn:00000F2C ; Segment type: Pure code
.text$mn:00000F2C ; Segment permissions: Read/Execute
.text$mn:00000F2C _text$mn        segment para public 'CODE' use32
.text$mn:00000F2C                 assume cs:_text$mn
.text$mn:00000F2C                 ;org 0F2Ch
.text$mn:00000F2C ; COMDAT (pick any)
.text$mn:00000F2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F2C
.text$mn:00000F2C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F2C
.text$mn:00000F2C ; Attributes: bp-based frame
.text$mn:00000F2C
.text$mn:00000F2C ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00000F2C                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00000F2C ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00000F2C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:00000F2C
.text$mn:00000F2C var_10          = dword ptr -10h
.text$mn:00000F2C var_C           = dword ptr -0Ch
.text$mn:00000F2C var_4           = dword ptr -4
.text$mn:00000F2C
.text$mn:00000F2C                 push    ebp
.text$mn:00000F2D                 mov     ebp, esp
.text$mn:00000F2F                 push    0FFFFFFFFh
.text$mn:00000F31                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00000F36                 mov     eax, large fs:0
.text$mn:00000F3C                 push    eax
.text$mn:00000F3D                 push    ecx
.text$mn:00000F3E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F43                 xor     eax, ebp
.text$mn:00000F45                 push    eax
.text$mn:00000F46                 lea     eax, [ebp+var_C]
.text$mn:00000F49                 mov     large fs:0, eax
.text$mn:00000F4F                 mov     [ebp+var_10], ecx
.text$mn:00000F52                 mov     ecx, [ebp+var_10] ; this
.text$mn:00000F55                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00000F5A                 mov     [ebp+var_4], 0
.text$mn:00000F61                 mov     eax, [ebp+var_10]
.text$mn:00000F64                 mov     dword ptr [eax+14h], 0
.text$mn:00000F6B                 mov     ecx, [ebp+var_10]
.text$mn:00000F6E                 mov     dword ptr [ecx+18h], 0
.text$mn:00000F75                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000F7C                 mov     eax, [ebp+var_10]
.text$mn:00000F7F                 mov     ecx, [ebp+var_C]
.text$mn:00000F82                 mov     large fs:0, ecx
.text$mn:00000F89                 pop     ecx
.text$mn:00000F8A                 mov     esp, ebp
.text$mn:00000F8C                 pop     ebp
.text$mn:00000F8D                 retn
.text$mn:00000F8D ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00000F8D
.text$mn:00000F8D ; ---------------------------------------------------------------------------
.text$mn:00000F8E                 align 10h
.text$mn:00000F8E _text$mn        ends
.text$mn:00000F8E
.text$x:00000F90 ; ===========================================================================
.text$x:00000F90
.text$x:00000F90 ; Segment type: Pure code
.text$x:00000F90 ; Segment permissions: Read/Execute
.text$x:00000F90 _text$x         segment para public 'CODE' use32
.text$x:00000F90                 assume cs:_text$x
.text$x:00000F90                 ;org 0F90h
.text$x:00000F90 ; COMDAT (pick associative to section at F2C)
.text$x:00000F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000F90
.text$x:00000F90 ; =============== S U B R O U T I N E =======================================
.text$x:00000F90
.text$x:00000F90
.text$x:00000F90 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00000F90                                         ; DATA XREF: .xdata$x:00003590o
.text$x:00000F90                 mov     ecx, [ebp-10h]  ; this
.text$x:00000F93                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00000F93 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00000F93
.text$x:00000F98
.text$x:00000F98 ; =============== S U B R O U T I N E =======================================
.text$x:00000F98
.text$x:00000F98
.text$x:00000F98 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00000F98                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00000F98
.text$x:00000F98 arg_4           = dword ptr  8
.text$x:00000F98
.text$x:00000F98                 mov     edx, [esp+arg_4]
.text$x:00000F9C                 lea     eax, [edx+0Ch]
.text$x:00000F9F                 mov     ecx, [edx-8]
.text$x:00000FA2                 xor     ecx, eax
.text$x:00000FA4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000FA9                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00000FAE                 jmp     ___CxxFrameHandler3
.text$x:00000FAE __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00000FAE
.text$x:00000FAE ; ---------------------------------------------------------------------------
.text$x:00000FB3                 align 4
.text$x:00000FB3 _text$x         ends
.text$x:00000FB3
.text$mn:00000FB4 ; ===========================================================================
.text$mn:00000FB4
.text$mn:00000FB4 ; Segment type: Pure code
.text$mn:00000FB4 ; Segment permissions: Read/Execute
.text$mn:00000FB4 _text$mn        segment para public 'CODE' use32
.text$mn:00000FB4                 assume cs:_text$mn
.text$mn:00000FB4                 ;org 0FB4h
.text$mn:00000FB4 ; COMDAT (pick any)
.text$mn:00000FB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FB4
.text$mn:00000FB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FB4
.text$mn:00000FB4 ; Attributes: bp-based frame
.text$mn:00000FB4
.text$mn:00000FB4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00000FB4                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00000FB4 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00000FB4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00000FB4
.text$mn:00000FB4 var_4           = dword ptr -4
.text$mn:00000FB4
.text$mn:00000FB4                 push    ebp
.text$mn:00000FB5                 mov     ebp, esp
.text$mn:00000FB7                 push    ecx
.text$mn:00000FB8                 mov     [ebp+var_4], ecx
.text$mn:00000FBB                 mov     ecx, [ebp+var_4]
.text$mn:00000FBE                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00000FC3                 mov     eax, [ebp+var_4]
.text$mn:00000FC6                 mov     esp, ebp
.text$mn:00000FC8                 pop     ebp
.text$mn:00000FC9                 retn
.text$mn:00000FC9 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00000FC9
.text$mn:00000FC9 ; ---------------------------------------------------------------------------
.text$mn:00000FCA                 align 4
.text$mn:00000FCA _text$mn        ends
.text$mn:00000FCA
.text$mn:00000FCC ; ===========================================================================
.text$mn:00000FCC
.text$mn:00000FCC ; Segment type: Pure code
.text$mn:00000FCC ; Segment permissions: Read/Execute
.text$mn:00000FCC _text$mn        segment para public 'CODE' use32
.text$mn:00000FCC                 assume cs:_text$mn
.text$mn:00000FCC                 ;org 0FCCh
.text$mn:00000FCC ; COMDAT (pick any)
.text$mn:00000FCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FCC
.text$mn:00000FCC ; =============== S U B R O U T I N E =======================================
.text$mn:00000FCC
.text$mn:00000FCC ; Attributes: bp-based frame
.text$mn:00000FCC
.text$mn:00000FCC ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:00000FCC                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:00000FCC ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:00000FCC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:00000FCC
.text$mn:00000FCC var_4           = dword ptr -4
.text$mn:00000FCC
.text$mn:00000FCC                 push    ebp
.text$mn:00000FCD                 mov     ebp, esp
.text$mn:00000FCF                 push    ecx
.text$mn:00000FD0                 mov     [ebp+var_4], ecx
.text$mn:00000FD3                 mov     ecx, [ebp+var_4]
.text$mn:00000FD6                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00000FDB                 mov     eax, [ebp+var_4]
.text$mn:00000FDE                 mov     esp, ebp
.text$mn:00000FE0                 pop     ebp
.text$mn:00000FE1                 retn
.text$mn:00000FE1 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:00000FE1
.text$mn:00000FE1 ; ---------------------------------------------------------------------------
.text$mn:00000FE2                 align 4
.text$mn:00000FE2 _text$mn        ends
.text$mn:00000FE2
.text$mn:00000FE4 ; ===========================================================================
.text$mn:00000FE4
.text$mn:00000FE4 ; Segment type: Pure code
.text$mn:00000FE4 ; Segment permissions: Read/Execute
.text$mn:00000FE4 _text$mn        segment para public 'CODE' use32
.text$mn:00000FE4                 assume cs:_text$mn
.text$mn:00000FE4                 ;org 0FE4h
.text$mn:00000FE4 ; COMDAT (pick any)
.text$mn:00000FE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FE4
.text$mn:00000FE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FE4
.text$mn:00000FE4 ; Attributes: bp-based frame
.text$mn:00000FE4
.text$mn:00000FE4 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00000FE4                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00000FE4 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00000FE4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00000FE4
.text$mn:00000FE4 var_4           = dword ptr -4
.text$mn:00000FE4
.text$mn:00000FE4                 push    ebp
.text$mn:00000FE5                 mov     ebp, esp
.text$mn:00000FE7                 push    ecx
.text$mn:00000FE8                 mov     [ebp+var_4], ecx
.text$mn:00000FEB                 mov     eax, [ebp+var_4]
.text$mn:00000FEE                 mov     esp, ebp
.text$mn:00000FF0                 pop     ebp
.text$mn:00000FF1                 retn
.text$mn:00000FF1 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00000FF1
.text$mn:00000FF1 ; ---------------------------------------------------------------------------
.text$mn:00000FF2                 align 4
.text$mn:00000FF2 _text$mn        ends
.text$mn:00000FF2
.text$mn:00000FF4 ; ===========================================================================
.text$mn:00000FF4
.text$mn:00000FF4 ; Segment type: Pure code
.text$mn:00000FF4 ; Segment permissions: Read/Execute
.text$mn:00000FF4 _text$mn        segment para public 'CODE' use32
.text$mn:00000FF4                 assume cs:_text$mn
.text$mn:00000FF4                 ;org 0FF4h
.text$mn:00000FF4 ; COMDAT (pick any)
.text$mn:00000FF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000FF4
.text$mn:00000FF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00000FF4
.text$mn:00000FF4 ; Attributes: bp-based frame
.text$mn:00000FF4
.text$mn:00000FF4 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00000FF4                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00000FF4 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00000FF4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:00000FF4                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00000FF4
.text$mn:00000FF4 var_4           = dword ptr -4
.text$mn:00000FF4
.text$mn:00000FF4                 push    ebp
.text$mn:00000FF5                 mov     ebp, esp
.text$mn:00000FF7                 push    ecx
.text$mn:00000FF8                 mov     [ebp+var_4], ecx
.text$mn:00000FFB                 mov     eax, [ebp+var_4]
.text$mn:00000FFE                 mov     esp, ebp
.text$mn:00001000                 pop     ebp
.text$mn:00001001                 retn
.text$mn:00001001 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00001001
.text$mn:00001001 ; ---------------------------------------------------------------------------
.text$mn:00001002                 align 4
.text$mn:00001002 _text$mn        ends
.text$mn:00001002
.text$mn:00001004 ; ===========================================================================
.text$mn:00001004
.text$mn:00001004 ; Segment type: Pure code
.text$mn:00001004 ; Segment permissions: Read/Execute
.text$mn:00001004 _text$mn        segment para public 'CODE' use32
.text$mn:00001004                 assume cs:_text$mn
.text$mn:00001004                 ;org 1004h
.text$mn:00001004 ; COMDAT (pick any)
.text$mn:00001004                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001004
.text$mn:00001004 ; =============== S U B R O U T I N E =======================================
.text$mn:00001004
.text$mn:00001004 ; Attributes: bp-based frame
.text$mn:00001004
.text$mn:00001004 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00001004                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:00001004 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:00001004                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+2Bp
.text$mn:00001004
.text$mn:00001004 var_4           = dword ptr -4
.text$mn:00001004
.text$mn:00001004                 push    ebp
.text$mn:00001005                 mov     ebp, esp
.text$mn:00001007                 push    ecx
.text$mn:00001008                 mov     [ebp+var_4], ecx
.text$mn:0000100B                 mov     eax, [ebp+var_4]
.text$mn:0000100E                 mov     esp, ebp
.text$mn:00001010                 pop     ebp
.text$mn:00001011                 retn
.text$mn:00001011 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00001011
.text$mn:00001011 ; ---------------------------------------------------------------------------
.text$mn:00001012                 align 4
.text$mn:00001012 _text$mn        ends
.text$mn:00001012
.text$mn:00001014 ; ===========================================================================
.text$mn:00001014
.text$mn:00001014 ; Segment type: Pure code
.text$mn:00001014 ; Segment permissions: Read/Execute
.text$mn:00001014 _text$mn        segment para public 'CODE' use32
.text$mn:00001014                 assume cs:_text$mn
.text$mn:00001014                 ;org 1014h
.text$mn:00001014 ; COMDAT (pick any)
.text$mn:00001014                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001014
.text$mn:00001014 ; =============== S U B R O U T I N E =======================================
.text$mn:00001014
.text$mn:00001014 ; Attributes: bp-based frame
.text$mn:00001014
.text$mn:00001014 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00001014                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00001014 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00001014                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00001014                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00001014
.text$mn:00001014 var_14          = dword ptr -14h
.text$mn:00001014 var_D           = byte ptr -0Dh
.text$mn:00001014 var_C           = dword ptr -0Ch
.text$mn:00001014 var_4           = dword ptr -4
.text$mn:00001014 Str             = dword ptr  8
.text$mn:00001014
.text$mn:00001014                 push    ebp
.text$mn:00001015                 mov     ebp, esp
.text$mn:00001017                 push    0FFFFFFFFh
.text$mn:00001019                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000101E                 mov     eax, large fs:0
.text$mn:00001024                 push    eax
.text$mn:00001025                 sub     esp, 8
.text$mn:00001028                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000102D                 xor     eax, ebp
.text$mn:0000102F                 push    eax
.text$mn:00001030                 lea     eax, [ebp+var_C]
.text$mn:00001033                 mov     large fs:0, eax
.text$mn:00001039                 mov     [ebp+var_14], ecx
.text$mn:0000103C                 lea     ecx, [ebp+var_D]
.text$mn:0000103F                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00001044                 push    eax
.text$mn:00001045                 mov     ecx, [ebp+var_14]
.text$mn:00001048                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:0000104D                 mov     [ebp+var_4], 0
.text$mn:00001054                 push    0               ; Size
.text$mn:00001056                 push    0               ; char
.text$mn:00001058                 mov     ecx, [ebp+var_14]
.text$mn:0000105B                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001060                 mov     eax, [ebp+Str]
.text$mn:00001063                 push    eax             ; Str
.text$mn:00001064                 mov     ecx, [ebp+var_14]
.text$mn:00001067                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:0000106C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001073                 mov     eax, [ebp+var_14]
.text$mn:00001076                 mov     ecx, [ebp+var_C]
.text$mn:00001079                 mov     large fs:0, ecx
.text$mn:00001080                 pop     ecx
.text$mn:00001081                 mov     esp, ebp
.text$mn:00001083                 pop     ebp
.text$mn:00001084                 retn    4
.text$mn:00001084 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00001084
.text$mn:00001084 ; ---------------------------------------------------------------------------
.text$mn:00001087                 align 4
.text$mn:00001087 _text$mn        ends
.text$mn:00001087
.text$x:00001088 ; ===========================================================================
.text$x:00001088
.text$x:00001088 ; Segment type: Pure code
.text$x:00001088 ; Segment permissions: Read/Execute
.text$x:00001088 _text$x         segment para public 'CODE' use32
.text$x:00001088                 assume cs:_text$x
.text$x:00001088                 ;org 1088h
.text$x:00001088 ; COMDAT (pick associative to section at 1014)
.text$x:00001088                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001088
.text$x:00001088 ; =============== S U B R O U T I N E =======================================
.text$x:00001088
.text$x:00001088
.text$x:00001088 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00001088                                         ; DATA XREF: .xdata$x:00003320o
.text$x:00001088                 mov     ecx, [ebp-14h]
.text$x:0000108B                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000108B __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:0000108B
.text$x:00001090
.text$x:00001090 ; =============== S U B R O U T I N E =======================================
.text$x:00001090
.text$x:00001090
.text$x:00001090 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00001090                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00001090
.text$x:00001090 arg_4           = dword ptr  8
.text$x:00001090
.text$x:00001090                 mov     edx, [esp+arg_4]
.text$x:00001094                 lea     eax, [edx+0Ch]
.text$x:00001097                 mov     ecx, [edx-0Ch]
.text$x:0000109A                 xor     ecx, eax
.text$x:0000109C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000010A1                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:000010A6                 jmp     ___CxxFrameHandler3
.text$x:000010A6 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:000010A6
.text$x:000010A6 ; ---------------------------------------------------------------------------
.text$x:000010AB                 align 4
.text$x:000010AB _text$x         ends
.text$x:000010AB
.text$mn:000010AC ; ===========================================================================
.text$mn:000010AC
.text$mn:000010AC ; Segment type: Pure code
.text$mn:000010AC ; Segment permissions: Read/Execute
.text$mn:000010AC _text$mn        segment para public 'CODE' use32
.text$mn:000010AC                 assume cs:_text$mn
.text$mn:000010AC                 ;org 10ACh
.text$mn:000010AC ; COMDAT (pick any)
.text$mn:000010AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000010AC
.text$mn:000010AC ; =============== S U B R O U T I N E =======================================
.text$mn:000010AC
.text$mn:000010AC ; Attributes: bp-based frame
.text$mn:000010AC
.text$mn:000010AC ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:000010AC                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:000010AC ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:000010AC                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+88p
.text$mn:000010AC
.text$mn:000010AC var_14          = dword ptr -14h
.text$mn:000010AC var_D           = byte ptr -0Dh
.text$mn:000010AC var_C           = dword ptr -0Ch
.text$mn:000010AC var_4           = dword ptr -4
.text$mn:000010AC Str             = dword ptr  8
.text$mn:000010AC
.text$mn:000010AC                 push    ebp
.text$mn:000010AD                 mov     ebp, esp
.text$mn:000010AF                 push    0FFFFFFFFh
.text$mn:000010B1                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:000010B6                 mov     eax, large fs:0
.text$mn:000010BC                 push    eax
.text$mn:000010BD                 sub     esp, 8
.text$mn:000010C0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000010C5                 xor     eax, ebp
.text$mn:000010C7                 push    eax
.text$mn:000010C8                 lea     eax, [ebp+var_C]
.text$mn:000010CB                 mov     large fs:0, eax
.text$mn:000010D1                 mov     [ebp+var_14], ecx
.text$mn:000010D4                 lea     ecx, [ebp+var_D]
.text$mn:000010D7                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000010DC                 push    eax
.text$mn:000010DD                 mov     ecx, [ebp+var_14]
.text$mn:000010E0                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:000010E5                 mov     [ebp+var_4], 0
.text$mn:000010EC                 push    0
.text$mn:000010EE                 push    0
.text$mn:000010F0                 mov     ecx, [ebp+var_14]
.text$mn:000010F3                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000010F8                 mov     eax, [ebp+Str]
.text$mn:000010FB                 push    eax             ; Str
.text$mn:000010FC                 mov     ecx, [ebp+var_14]
.text$mn:000010FF                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00001104                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000110B                 mov     eax, [ebp+var_14]
.text$mn:0000110E                 mov     ecx, [ebp+var_C]
.text$mn:00001111                 mov     large fs:0, ecx
.text$mn:00001118                 pop     ecx
.text$mn:00001119                 mov     esp, ebp
.text$mn:0000111B                 pop     ebp
.text$mn:0000111C                 retn    4
.text$mn:0000111C ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:0000111C
.text$mn:0000111C ; ---------------------------------------------------------------------------
.text$mn:0000111F                 align 10h
.text$mn:0000111F _text$mn        ends
.text$mn:0000111F
.text$x:00001120 ; ===========================================================================
.text$x:00001120
.text$x:00001120 ; Segment type: Pure code
.text$x:00001120 ; Segment permissions: Read/Execute
.text$x:00001120 _text$x         segment para public 'CODE' use32
.text$x:00001120                 assume cs:_text$x
.text$x:00001120                 ;org 1120h
.text$x:00001120 ; COMDAT (pick associative to section at 10AC)
.text$x:00001120                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001120
.text$x:00001120 ; =============== S U B R O U T I N E =======================================
.text$x:00001120
.text$x:00001120
.text$x:00001120 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:00001120                                         ; DATA XREF: .xdata$x:00003640o
.text$x:00001120                 mov     ecx, [ebp-14h]
.text$x:00001123                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00001123 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:00001123
.text$x:00001128
.text$x:00001128 ; =============== S U B R O U T I N E =======================================
.text$x:00001128
.text$x:00001128
.text$x:00001128 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:00001128                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:00001128
.text$x:00001128 arg_4           = dword ptr  8
.text$x:00001128
.text$x:00001128                 mov     edx, [esp+arg_4]
.text$x:0000112C                 lea     eax, [edx+0Ch]
.text$x:0000112F                 mov     ecx, [edx-0Ch]
.text$x:00001132                 xor     ecx, eax
.text$x:00001134                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001139                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:0000113E                 jmp     ___CxxFrameHandler3
.text$x:0000113E __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:0000113E
.text$x:0000113E ; ---------------------------------------------------------------------------
.text$x:00001143                 align 4
.text$x:00001143 _text$x         ends
.text$x:00001143
.text$mn:00001144 ; ===========================================================================
.text$mn:00001144
.text$mn:00001144 ; Segment type: Pure code
.text$mn:00001144 ; Segment permissions: Read/Execute
.text$mn:00001144 _text$mn        segment para public 'CODE' use32
.text$mn:00001144                 assume cs:_text$mn
.text$mn:00001144                 ;org 1144h
.text$mn:00001144 ; COMDAT (pick any)
.text$mn:00001144                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001144
.text$mn:00001144 ; =============== S U B R O U T I N E =======================================
.text$mn:00001144
.text$mn:00001144 ; Attributes: bp-based frame
.text$mn:00001144
.text$mn:00001144 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001144                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00001144 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00001144                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00001144                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p
.text$mn:00001144
.text$mn:00001144 var_4           = dword ptr -4
.text$mn:00001144
.text$mn:00001144                 push    ebp
.text$mn:00001145                 mov     ebp, esp
.text$mn:00001147                 push    ecx
.text$mn:00001148                 mov     [ebp+var_4], ecx
.text$mn:0000114B                 mov     eax, [ebp+var_4]
.text$mn:0000114E                 mov     dword ptr [eax], 0
.text$mn:00001154                 mov     eax, [ebp+var_4]
.text$mn:00001157                 mov     esp, ebp
.text$mn:00001159                 pop     ebp
.text$mn:0000115A                 retn
.text$mn:0000115A ??0_Container_base12@std@@QAE@XZ endp
.text$mn:0000115A
.text$mn:0000115A ; ---------------------------------------------------------------------------
.text$mn:0000115B                 align 4
.text$mn:0000115B _text$mn        ends
.text$mn:0000115B
.text$mn:0000115C ; ===========================================================================
.text$mn:0000115C
.text$mn:0000115C ; Segment type: Pure code
.text$mn:0000115C ; Segment permissions: Read/Execute
.text$mn:0000115C _text$mn        segment para public 'CODE' use32
.text$mn:0000115C                 assume cs:_text$mn
.text$mn:0000115C                 ;org 115Ch
.text$mn:0000115C ; COMDAT (pick any)
.text$mn:0000115C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000115C
.text$mn:0000115C ; =============== S U B R O U T I N E =======================================
.text$mn:0000115C
.text$mn:0000115C ; Attributes: bp-based frame
.text$mn:0000115C
.text$mn:0000115C ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:0000115C                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:0000115C ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:0000115C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:0000115C                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p
.text$mn:0000115C
.text$mn:0000115C var_4           = dword ptr -4
.text$mn:0000115C
.text$mn:0000115C                 push    ebp
.text$mn:0000115D                 mov     ebp, esp
.text$mn:0000115F                 push    ecx
.text$mn:00001160                 mov     [ebp+var_4], ecx
.text$mn:00001163                 mov     eax, [ebp+var_4]
.text$mn:00001166                 mov     dword ptr [eax], 0
.text$mn:0000116C                 mov     ecx, [ebp+var_4]
.text$mn:0000116F                 mov     dword ptr [ecx+4], 0
.text$mn:00001176                 mov     eax, [ebp+var_4]
.text$mn:00001179                 mov     esp, ebp
.text$mn:0000117B                 pop     ebp
.text$mn:0000117C                 retn
.text$mn:0000117C ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:0000117C
.text$mn:0000117C ; ---------------------------------------------------------------------------
.text$mn:0000117D                 align 10h
.text$mn:0000117D _text$mn        ends
.text$mn:0000117D
.text$mn:00001180 ; ===========================================================================
.text$mn:00001180
.text$mn:00001180 ; Segment type: Pure code
.text$mn:00001180 ; Segment permissions: Read/Execute
.text$mn:00001180 _text$mn        segment para public 'CODE' use32
.text$mn:00001180                 assume cs:_text$mn
.text$mn:00001180                 ;org 1180h
.text$mn:00001180 ; COMDAT (pick any)
.text$mn:00001180                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001180
.text$mn:00001180 ; =============== S U B R O U T I N E =======================================
.text$mn:00001180
.text$mn:00001180 ; Attributes: bp-based frame
.text$mn:00001180
.text$mn:00001180 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001180                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00001180 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00001180                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00001180                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00001180
.text$mn:00001180 var_10          = dword ptr -10h
.text$mn:00001180 var_C           = dword ptr -0Ch
.text$mn:00001180 var_4           = dword ptr -4
.text$mn:00001180
.text$mn:00001180                 push    ebp
.text$mn:00001181                 mov     ebp, esp
.text$mn:00001183                 push    0FFFFFFFFh
.text$mn:00001185                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000118A                 mov     eax, large fs:0
.text$mn:00001190                 push    eax
.text$mn:00001191                 push    ecx
.text$mn:00001192                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001197                 xor     eax, ebp
.text$mn:00001199                 push    eax
.text$mn:0000119A                 lea     eax, [ebp+var_C]
.text$mn:0000119D                 mov     large fs:0, eax
.text$mn:000011A3                 mov     [ebp+var_10], ecx
.text$mn:000011A6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000011A9                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000011AE                 mov     [ebp+var_4], 0
.text$mn:000011B5                 mov     eax, [ebp+var_10]
.text$mn:000011B8                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000011BE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000011C5                 mov     eax, [ebp+var_10]
.text$mn:000011C8                 mov     ecx, [ebp+var_C]
.text$mn:000011CB                 mov     large fs:0, ecx
.text$mn:000011D2                 pop     ecx
.text$mn:000011D3                 mov     esp, ebp
.text$mn:000011D5                 pop     ebp
.text$mn:000011D6                 retn
.text$mn:000011D6 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000011D6
.text$mn:000011D6 ; ---------------------------------------------------------------------------
.text$mn:000011D7                 align 4
.text$mn:000011D7 _text$mn        ends
.text$mn:000011D7
.text$x:000011D8 ; ===========================================================================
.text$x:000011D8
.text$x:000011D8 ; Segment type: Pure code
.text$x:000011D8 ; Segment permissions: Read/Execute
.text$x:000011D8 _text$x         segment para public 'CODE' use32
.text$x:000011D8                 assume cs:_text$x
.text$x:000011D8                 ;org 11D8h
.text$x:000011D8 ; COMDAT (pick associative to section at 1180)
.text$x:000011D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000011D8
.text$x:000011D8 ; =============== S U B R O U T I N E =======================================
.text$x:000011D8
.text$x:000011D8
.text$x:000011D8 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000011D8                                         ; DATA XREF: .xdata$x:00003404o
.text$x:000011D8                 mov     ecx, [ebp-10h]  ; this
.text$x:000011DB                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000011DB __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000011DB
.text$x:000011E0
.text$x:000011E0 ; =============== S U B R O U T I N E =======================================
.text$x:000011E0
.text$x:000011E0
.text$x:000011E0 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000011E0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000011E0
.text$x:000011E0 arg_4           = dword ptr  8
.text$x:000011E0
.text$x:000011E0                 mov     edx, [esp+arg_4]
.text$x:000011E4                 lea     eax, [edx+0Ch]
.text$x:000011E7                 mov     ecx, [edx-8]
.text$x:000011EA                 xor     ecx, eax
.text$x:000011EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000011F1                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000011F6                 jmp     ___CxxFrameHandler3
.text$x:000011F6 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000011F6
.text$x:000011F6 ; ---------------------------------------------------------------------------
.text$x:000011FB                 align 4
.text$x:000011FB _text$x         ends
.text$x:000011FB
.text$mn:000011FC ; ===========================================================================
.text$mn:000011FC
.text$mn:000011FC ; Segment type: Pure code
.text$mn:000011FC ; Segment permissions: Read/Execute
.text$mn:000011FC _text$mn        segment para public 'CODE' use32
.text$mn:000011FC                 assume cs:_text$mn
.text$mn:000011FC                 ;org 11FCh
.text$mn:000011FC ; COMDAT (pick any)
.text$mn:000011FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011FC
.text$mn:000011FC ; =============== S U B R O U T I N E =======================================
.text$mn:000011FC
.text$mn:000011FC ; Attributes: bp-based frame
.text$mn:000011FC
.text$mn:000011FC ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000011FC                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000011FC ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:000011FC                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000011FC
.text$mn:000011FC var_10          = dword ptr -10h
.text$mn:000011FC var_C           = dword ptr -0Ch
.text$mn:000011FC var_4           = dword ptr -4
.text$mn:000011FC
.text$mn:000011FC                 push    ebp
.text$mn:000011FD                 mov     ebp, esp
.text$mn:000011FF                 push    0FFFFFFFFh
.text$mn:00001201                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00001206                 mov     eax, large fs:0
.text$mn:0000120C                 push    eax
.text$mn:0000120D                 push    ecx
.text$mn:0000120E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001213                 xor     eax, ebp
.text$mn:00001215                 push    eax
.text$mn:00001216                 lea     eax, [ebp+var_C]
.text$mn:00001219                 mov     large fs:0, eax
.text$mn:0000121F                 mov     [ebp+var_10], ecx
.text$mn:00001222                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001225                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000122A                 mov     [ebp+var_4], 0
.text$mn:00001231                 mov     eax, [ebp+var_10]
.text$mn:00001234                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:0000123A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001241                 mov     eax, [ebp+var_10]
.text$mn:00001244                 mov     ecx, [ebp+var_C]
.text$mn:00001247                 mov     large fs:0, ecx
.text$mn:0000124E                 pop     ecx
.text$mn:0000124F                 mov     esp, ebp
.text$mn:00001251                 pop     ebp
.text$mn:00001252                 retn
.text$mn:00001252 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00001252
.text$mn:00001252 ; ---------------------------------------------------------------------------
.text$mn:00001253                 align 4
.text$mn:00001253 _text$mn        ends
.text$mn:00001253
.text$x:00001254 ; ===========================================================================
.text$x:00001254
.text$x:00001254 ; Segment type: Pure code
.text$x:00001254 ; Segment permissions: Read/Execute
.text$x:00001254 _text$x         segment para public 'CODE' use32
.text$x:00001254                 assume cs:_text$x
.text$x:00001254                 ;org 1254h
.text$x:00001254 ; COMDAT (pick associative to section at 11FC)
.text$x:00001254                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001254
.text$x:00001254 ; =============== S U B R O U T I N E =======================================
.text$x:00001254
.text$x:00001254
.text$x:00001254 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00001254                                         ; DATA XREF: .xdata$x:00003488o
.text$x:00001254                 mov     ecx, [ebp-10h]  ; this
.text$x:00001257                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001257 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00001257
.text$x:0000125C
.text$x:0000125C ; =============== S U B R O U T I N E =======================================
.text$x:0000125C
.text$x:0000125C
.text$x:0000125C __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:0000125C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:0000125C
.text$x:0000125C arg_4           = dword ptr  8
.text$x:0000125C
.text$x:0000125C                 mov     edx, [esp+arg_4]
.text$x:00001260                 lea     eax, [edx+0Ch]
.text$x:00001263                 mov     ecx, [edx-8]
.text$x:00001266                 xor     ecx, eax
.text$x:00001268                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000126D                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00001272                 jmp     ___CxxFrameHandler3
.text$x:00001272 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00001272
.text$x:00001272 ; ---------------------------------------------------------------------------
.text$x:00001277                 align 4
.text$x:00001277 _text$x         ends
.text$x:00001277
.text$mn:00001278 ; ===========================================================================
.text$mn:00001278
.text$mn:00001278 ; Segment type: Pure code
.text$mn:00001278 ; Segment permissions: Read/Execute
.text$mn:00001278 _text$mn        segment para public 'CODE' use32
.text$mn:00001278                 assume cs:_text$mn
.text$mn:00001278                 ;org 1278h
.text$mn:00001278 ; COMDAT (pick any)
.text$mn:00001278                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001278
.text$mn:00001278 ; =============== S U B R O U T I N E =======================================
.text$mn:00001278
.text$mn:00001278 ; Attributes: bp-based frame
.text$mn:00001278
.text$mn:00001278 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001278                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00001278 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00001278                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001278
.text$mn:00001278 var_10          = dword ptr -10h
.text$mn:00001278 var_C           = dword ptr -0Ch
.text$mn:00001278 var_4           = dword ptr -4
.text$mn:00001278
.text$mn:00001278                 push    ebp
.text$mn:00001279                 mov     ebp, esp
.text$mn:0000127B                 push    0FFFFFFFFh
.text$mn:0000127D                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00001282                 mov     eax, large fs:0
.text$mn:00001288                 push    eax
.text$mn:00001289                 push    ecx
.text$mn:0000128A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000128F                 xor     eax, ebp
.text$mn:00001291                 push    eax
.text$mn:00001292                 lea     eax, [ebp+var_C]
.text$mn:00001295                 mov     large fs:0, eax
.text$mn:0000129B                 mov     [ebp+var_10], ecx
.text$mn:0000129E                 mov     ecx, [ebp+var_10] ; this
.text$mn:000012A1                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000012A6                 mov     [ebp+var_4], 0
.text$mn:000012AD                 mov     eax, [ebp+var_10]
.text$mn:000012B0                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:000012B6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000012BD                 mov     eax, [ebp+var_10]
.text$mn:000012C0                 mov     ecx, [ebp+var_C]
.text$mn:000012C3                 mov     large fs:0, ecx
.text$mn:000012CA                 pop     ecx
.text$mn:000012CB                 mov     esp, ebp
.text$mn:000012CD                 pop     ebp
.text$mn:000012CE                 retn
.text$mn:000012CE ??0_System_error_category@std@@QAE@XZ endp
.text$mn:000012CE
.text$mn:000012CE ; ---------------------------------------------------------------------------
.text$mn:000012CF                 align 10h
.text$mn:000012CF _text$mn        ends
.text$mn:000012CF
.text$x:000012D0 ; ===========================================================================
.text$x:000012D0
.text$x:000012D0 ; Segment type: Pure code
.text$x:000012D0 ; Segment permissions: Read/Execute
.text$x:000012D0 _text$x         segment para public 'CODE' use32
.text$x:000012D0                 assume cs:_text$x
.text$x:000012D0                 ;org 12D0h
.text$x:000012D0 ; COMDAT (pick associative to section at 1278)
.text$x:000012D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000012D0
.text$x:000012D0 ; =============== S U B R O U T I N E =======================================
.text$x:000012D0
.text$x:000012D0
.text$x:000012D0 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:000012D0                                         ; DATA XREF: .xdata$x:0000350Co
.text$x:000012D0                 mov     ecx, [ebp-10h]  ; this
.text$x:000012D3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000012D3 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:000012D3
.text$x:000012D8
.text$x:000012D8 ; =============== S U B R O U T I N E =======================================
.text$x:000012D8
.text$x:000012D8
.text$x:000012D8 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000012D8                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000012D8
.text$x:000012D8 arg_4           = dword ptr  8
.text$x:000012D8
.text$x:000012D8                 mov     edx, [esp+arg_4]
.text$x:000012DC                 lea     eax, [edx+0Ch]
.text$x:000012DF                 mov     ecx, [edx-8]
.text$x:000012E2                 xor     ecx, eax
.text$x:000012E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000012E9                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000012EE                 jmp     ___CxxFrameHandler3
.text$x:000012EE __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000012EE
.text$x:000012EE ; ---------------------------------------------------------------------------
.text$x:000012F3                 align 4
.text$x:000012F3 _text$x         ends
.text$x:000012F3
.text$mn:000012F4 ; ===========================================================================
.text$mn:000012F4
.text$mn:000012F4 ; Segment type: Pure code
.text$mn:000012F4 ; Segment permissions: Read/Execute
.text$mn:000012F4 _text$mn        segment para public 'CODE' use32
.text$mn:000012F4                 assume cs:_text$mn
.text$mn:000012F4                 ;org 12F4h
.text$mn:000012F4 ; COMDAT (pick any)
.text$mn:000012F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000012F4
.text$mn:000012F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000012F4
.text$mn:000012F4 ; Attributes: bp-based frame
.text$mn:000012F4
.text$mn:000012F4 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000012F4                 public ??0error_category@std@@QAE@XZ
.text$mn:000012F4 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000012F4
.text$mn:000012F4 var_4           = dword ptr -4
.text$mn:000012F4
.text$mn:000012F4                 push    ebp
.text$mn:000012F5                 mov     ebp, esp
.text$mn:000012F7                 push    ecx
.text$mn:000012F8                 mov     [ebp+var_4], ecx
.text$mn:000012FB                 mov     eax, [ebp+var_4]
.text$mn:000012FE                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001304                 mov     eax, [ebp+var_4]
.text$mn:00001307                 mov     esp, ebp
.text$mn:00001309                 pop     ebp
.text$mn:0000130A                 retn
.text$mn:0000130A ??0error_category@std@@QAE@XZ endp
.text$mn:0000130A
.text$mn:0000130A ; ---------------------------------------------------------------------------
.text$mn:0000130B                 align 4
.text$mn:0000130B _text$mn        ends
.text$mn:0000130B
.text$mn:0000130C ; ===========================================================================
.text$mn:0000130C
.text$mn:0000130C ; Segment type: Pure code
.text$mn:0000130C ; Segment permissions: Read/Execute
.text$mn:0000130C _text$mn        segment para public 'CODE' use32
.text$mn:0000130C                 assume cs:_text$mn
.text$mn:0000130C                 ;org 130Ch
.text$mn:0000130C ; COMDAT (pick any)
.text$mn:0000130C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000130C
.text$mn:0000130C ; =============== S U B R O U T I N E =======================================
.text$mn:0000130C
.text$mn:0000130C ; Attributes: bp-based frame
.text$mn:0000130C
.text$mn:0000130C ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:0000130C                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:0000130C ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:0000130C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:0000130C                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:0000130C
.text$mn:0000130C var_4           = dword ptr -4
.text$mn:0000130C arg_0           = dword ptr  8
.text$mn:0000130C arg_4           = dword ptr  0Ch
.text$mn:0000130C
.text$mn:0000130C                 push    ebp
.text$mn:0000130D                 mov     ebp, esp
.text$mn:0000130F                 push    ecx
.text$mn:00001310                 mov     [ebp+var_4], ecx
.text$mn:00001313                 mov     eax, [ebp+var_4]
.text$mn:00001316                 mov     ecx, [ebp+arg_0]
.text$mn:00001319                 mov     [eax], ecx
.text$mn:0000131B                 mov     edx, [ebp+var_4]
.text$mn:0000131E                 mov     eax, [ebp+arg_4]
.text$mn:00001321                 mov     [edx+4], eax
.text$mn:00001324                 mov     eax, [ebp+var_4]
.text$mn:00001327                 mov     esp, ebp
.text$mn:00001329                 pop     ebp
.text$mn:0000132A                 retn    8
.text$mn:0000132A ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:0000132A
.text$mn:0000132A ; ---------------------------------------------------------------------------
.text$mn:0000132D                 align 10h
.text$mn:0000132D _text$mn        ends
.text$mn:0000132D
.text$mn:00001330 ; ===========================================================================
.text$mn:00001330
.text$mn:00001330 ; Segment type: Pure code
.text$mn:00001330 ; Segment permissions: Read/Execute
.text$mn:00001330 _text$mn        segment para public 'CODE' use32
.text$mn:00001330                 assume cs:_text$mn
.text$mn:00001330                 ;org 1330h
.text$mn:00001330 ; COMDAT (pick any)
.text$mn:00001330                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001330
.text$mn:00001330 ; =============== S U B R O U T I N E =======================================
.text$mn:00001330
.text$mn:00001330 ; Attributes: bp-based frame
.text$mn:00001330
.text$mn:00001330 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00001330                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00001330 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00001330                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00001330
.text$mn:00001330 var_4           = dword ptr -4
.text$mn:00001330 arg_0           = dword ptr  8
.text$mn:00001330
.text$mn:00001330                 push    ebp
.text$mn:00001331                 mov     ebp, esp
.text$mn:00001333                 push    ecx
.text$mn:00001334                 mov     [ebp+var_4], ecx
.text$mn:00001337                 mov     eax, [ebp+var_4]
.text$mn:0000133A                 mov     ecx, [ebp+arg_0]
.text$mn:0000133D                 mov     [eax], ecx
.text$mn:0000133F                 mov     eax, [ebp+var_4]
.text$mn:00001342                 mov     esp, ebp
.text$mn:00001344                 pop     ebp
.text$mn:00001345                 retn    4
.text$mn:00001345 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00001345
.text$mn:00001345 _text$mn        ends
.text$mn:00001345
.text$mn:00001348 ; ===========================================================================
.text$mn:00001348
.text$mn:00001348 ; Segment type: Pure code
.text$mn:00001348 ; Segment permissions: Read/Execute
.text$mn:00001348 _text$mn        segment para public 'CODE' use32
.text$mn:00001348                 assume cs:_text$mn
.text$mn:00001348                 ;org 1348h
.text$mn:00001348 ; COMDAT (pick any)
.text$mn:00001348                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001348
.text$mn:00001348 ; =============== S U B R O U T I N E =======================================
.text$mn:00001348
.text$mn:00001348 ; Attributes: bp-based frame
.text$mn:00001348
.text$mn:00001348 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00001348                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001348 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00001348                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00001348                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00001348
.text$mn:00001348 var_10          = dword ptr -10h
.text$mn:00001348 var_C           = dword ptr -0Ch
.text$mn:00001348 var_4           = dword ptr -4
.text$mn:00001348
.text$mn:00001348                 push    ebp
.text$mn:00001349                 mov     ebp, esp
.text$mn:0000134B                 push    0FFFFFFFFh
.text$mn:0000134D                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001352                 mov     eax, large fs:0
.text$mn:00001358                 push    eax
.text$mn:00001359                 push    ecx
.text$mn:0000135A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000135F                 xor     eax, ebp
.text$mn:00001361                 push    eax
.text$mn:00001362                 lea     eax, [ebp+var_C]
.text$mn:00001365                 mov     large fs:0, eax
.text$mn:0000136B                 mov     [ebp+var_10], ecx
.text$mn:0000136E                 mov     [ebp+var_4], 0
.text$mn:00001375                 mov     ecx, [ebp+var_10]
.text$mn:00001378                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:0000137D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001384                 mov     ecx, [ebp+var_10]
.text$mn:00001387                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:0000138C                 mov     ecx, [ebp+var_C]
.text$mn:0000138F                 mov     large fs:0, ecx
.text$mn:00001396                 pop     ecx
.text$mn:00001397                 mov     esp, ebp
.text$mn:00001399                 pop     ebp
.text$mn:0000139A                 retn
.text$mn:0000139A ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000139A
.text$mn:0000139A ; ---------------------------------------------------------------------------
.text$mn:0000139B                 align 4
.text$mn:0000139B _text$mn        ends
.text$mn:0000139B
.text$x:0000139C ; ===========================================================================
.text$x:0000139C
.text$x:0000139C ; Segment type: Pure code
.text$x:0000139C ; Segment permissions: Read/Execute
.text$x:0000139C _text$x         segment para public 'CODE' use32
.text$x:0000139C                 assume cs:_text$x
.text$x:0000139C                 ;org 139Ch
.text$x:0000139C ; COMDAT (pick associative to section at 1348)
.text$x:0000139C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000139C
.text$x:0000139C ; =============== S U B R O U T I N E =======================================
.text$x:0000139C
.text$x:0000139C
.text$x:0000139C __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000139C                                         ; DATA XREF: .xdata$x:000032F4o
.text$x:0000139C                 mov     ecx, [ebp-10h]
.text$x:0000139F                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000139F __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000139F
.text$x:000013A4
.text$x:000013A4 ; =============== S U B R O U T I N E =======================================
.text$x:000013A4
.text$x:000013A4
.text$x:000013A4 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:000013A4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:000013A4
.text$x:000013A4 arg_4           = dword ptr  8
.text$x:000013A4
.text$x:000013A4                 mov     edx, [esp+arg_4]
.text$x:000013A8                 lea     eax, [edx+0Ch]
.text$x:000013AB                 mov     ecx, [edx-8]
.text$x:000013AE                 xor     ecx, eax
.text$x:000013B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000013B5                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:000013BA                 jmp     ___CxxFrameHandler3
.text$x:000013BA __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:000013BA
.text$x:000013BA ; ---------------------------------------------------------------------------
.text$x:000013BF                 align 10h
.text$x:000013BF _text$x         ends
.text$x:000013BF
.text$mn:000013C0 ; ===========================================================================
.text$mn:000013C0
.text$mn:000013C0 ; Segment type: Pure code
.text$mn:000013C0 ; Segment permissions: Read/Execute
.text$mn:000013C0 _text$mn        segment para public 'CODE' use32
.text$mn:000013C0                 assume cs:_text$mn
.text$mn:000013C0                 ;org 13C0h
.text$mn:000013C0 ; COMDAT (pick any)
.text$mn:000013C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000013C0
.text$mn:000013C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000013C0
.text$mn:000013C0 ; Attributes: bp-based frame
.text$mn:000013C0
.text$mn:000013C0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:000013C0                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:000013C0 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000013C0                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0+3j
.text$mn:000013C0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+43p ...
.text$mn:000013C0
.text$mn:000013C0 var_10          = dword ptr -10h
.text$mn:000013C0 var_C           = dword ptr -0Ch
.text$mn:000013C0 var_4           = dword ptr -4
.text$mn:000013C0
.text$mn:000013C0                 push    ebp
.text$mn:000013C1                 mov     ebp, esp
.text$mn:000013C3                 push    0FFFFFFFFh
.text$mn:000013C5                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:000013CA                 mov     eax, large fs:0
.text$mn:000013D0                 push    eax
.text$mn:000013D1                 push    ecx
.text$mn:000013D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000013D7                 xor     eax, ebp
.text$mn:000013D9                 push    eax
.text$mn:000013DA                 lea     eax, [ebp+var_C]
.text$mn:000013DD                 mov     large fs:0, eax
.text$mn:000013E3                 mov     [ebp+var_10], ecx
.text$mn:000013E6                 mov     [ebp+var_4], 0
.text$mn:000013ED                 mov     ecx, [ebp+var_10]
.text$mn:000013F0                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:000013F5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000013FC                 mov     ecx, [ebp+var_10]
.text$mn:000013FF                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00001404                 mov     ecx, [ebp+var_C]
.text$mn:00001407                 mov     large fs:0, ecx
.text$mn:0000140E                 pop     ecx
.text$mn:0000140F                 mov     esp, ebp
.text$mn:00001411                 pop     ebp
.text$mn:00001412                 retn
.text$mn:00001412 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:00001412
.text$mn:00001412 ; ---------------------------------------------------------------------------
.text$mn:00001413                 align 4
.text$mn:00001413 _text$mn        ends
.text$mn:00001413
.text$x:00001414 ; ===========================================================================
.text$x:00001414
.text$x:00001414 ; Segment type: Pure code
.text$x:00001414 ; Segment permissions: Read/Execute
.text$x:00001414 _text$x         segment para public 'CODE' use32
.text$x:00001414                 assume cs:_text$x
.text$x:00001414                 ;org 1414h
.text$x:00001414 ; COMDAT (pick associative to section at 13C0)
.text$x:00001414                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001414
.text$x:00001414 ; =============== S U B R O U T I N E =======================================
.text$x:00001414
.text$x:00001414
.text$x:00001414 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00001414                                         ; DATA XREF: .xdata$x:00003614o
.text$x:00001414                 mov     ecx, [ebp-10h]
.text$x:00001417                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00001417 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00001417
.text$x:0000141C
.text$x:0000141C ; =============== S U B R O U T I N E =======================================
.text$x:0000141C
.text$x:0000141C
.text$x:0000141C __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000141C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:0000141C
.text$x:0000141C arg_4           = dword ptr  8
.text$x:0000141C
.text$x:0000141C                 mov     edx, [esp+arg_4]
.text$x:00001420                 lea     eax, [edx+0Ch]
.text$x:00001423                 mov     ecx, [edx-8]
.text$x:00001426                 xor     ecx, eax
.text$x:00001428                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000142D                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:00001432                 jmp     ___CxxFrameHandler3
.text$x:00001432 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:00001432
.text$x:00001432 ; ---------------------------------------------------------------------------
.text$x:00001437                 align 4
.text$x:00001437 _text$x         ends
.text$x:00001437
.text$mn:00001438 ; ===========================================================================
.text$mn:00001438
.text$mn:00001438 ; Segment type: Pure code
.text$mn:00001438 ; Segment permissions: Read/Execute
.text$mn:00001438 _text$mn        segment para public 'CODE' use32
.text$mn:00001438                 assume cs:_text$mn
.text$mn:00001438                 ;org 1438h
.text$mn:00001438 ; COMDAT (pick any)
.text$mn:00001438                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001438
.text$mn:00001438 ; =============== S U B R O U T I N E =======================================
.text$mn:00001438
.text$mn:00001438 ; Attributes: bp-based frame
.text$mn:00001438
.text$mn:00001438 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001438                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001438 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001438                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00001438                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00001438
.text$mn:00001438 var_10          = dword ptr -10h
.text$mn:00001438 var_C           = dword ptr -0Ch
.text$mn:00001438 var_4           = dword ptr -4
.text$mn:00001438
.text$mn:00001438                 push    ebp
.text$mn:00001439                 mov     ebp, esp
.text$mn:0000143B                 push    0FFFFFFFFh
.text$mn:0000143D                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001442                 mov     eax, large fs:0
.text$mn:00001448                 push    eax
.text$mn:00001449                 push    ecx
.text$mn:0000144A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000144F                 xor     eax, ebp
.text$mn:00001451                 push    eax
.text$mn:00001452                 lea     eax, [ebp+var_C]
.text$mn:00001455                 mov     large fs:0, eax
.text$mn:0000145B                 mov     [ebp+var_10], ecx
.text$mn:0000145E                 mov     [ebp+var_4], 0
.text$mn:00001465                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000146C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000146F                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00001474                 mov     ecx, [ebp+var_C]
.text$mn:00001477                 mov     large fs:0, ecx
.text$mn:0000147E                 pop     ecx
.text$mn:0000147F                 mov     esp, ebp
.text$mn:00001481                 pop     ebp
.text$mn:00001482                 retn
.text$mn:00001482 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00001482
.text$mn:00001482 ; ---------------------------------------------------------------------------
.text$mn:00001483                 align 4
.text$mn:00001483 _text$mn        ends
.text$mn:00001483
.text$x:00001484 ; ===========================================================================
.text$x:00001484
.text$x:00001484 ; Segment type: Pure code
.text$x:00001484 ; Segment permissions: Read/Execute
.text$x:00001484 _text$x         segment para public 'CODE' use32
.text$x:00001484                 assume cs:_text$x
.text$x:00001484                 ;org 1484h
.text$x:00001484 ; COMDAT (pick associative to section at 1438)
.text$x:00001484                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001484
.text$x:00001484 ; =============== S U B R O U T I N E =======================================
.text$x:00001484
.text$x:00001484
.text$x:00001484 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001484                                         ; DATA XREF: .xdata$x:0000329Co
.text$x:00001484                 mov     ecx, [ebp-10h]  ; this
.text$x:00001487                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001487 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001487
.text$x:0000148C
.text$x:0000148C ; =============== S U B R O U T I N E =======================================
.text$x:0000148C
.text$x:0000148C
.text$x:0000148C __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:0000148C                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:0000148C
.text$x:0000148C arg_4           = dword ptr  8
.text$x:0000148C
.text$x:0000148C                 mov     edx, [esp+arg_4]
.text$x:00001490                 lea     eax, [edx+0Ch]
.text$x:00001493                 mov     ecx, [edx-8]
.text$x:00001496                 xor     ecx, eax
.text$x:00001498                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000149D                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000014A2                 jmp     ___CxxFrameHandler3
.text$x:000014A2 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000014A2
.text$x:000014A2 ; ---------------------------------------------------------------------------
.text$x:000014A7                 align 4
.text$x:000014A7 _text$x         ends
.text$x:000014A7
.text$mn:000014A8 ; ===========================================================================
.text$mn:000014A8
.text$mn:000014A8 ; Segment type: Pure code
.text$mn:000014A8 ; Segment permissions: Read/Execute
.text$mn:000014A8 _text$mn        segment para public 'CODE' use32
.text$mn:000014A8                 assume cs:_text$mn
.text$mn:000014A8                 ;org 14A8h
.text$mn:000014A8 ; COMDAT (pick any)
.text$mn:000014A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014A8
.text$mn:000014A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014A8
.text$mn:000014A8 ; Attributes: bp-based frame
.text$mn:000014A8
.text$mn:000014A8 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:000014A8                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000014A8 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:000014A8                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:000014A8                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:000014A8
.text$mn:000014A8 var_10          = dword ptr -10h
.text$mn:000014A8 var_C           = dword ptr -0Ch
.text$mn:000014A8 var_4           = dword ptr -4
.text$mn:000014A8
.text$mn:000014A8                 push    ebp
.text$mn:000014A9                 mov     ebp, esp
.text$mn:000014AB                 push    0FFFFFFFFh
.text$mn:000014AD                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000014B2                 mov     eax, large fs:0
.text$mn:000014B8                 push    eax
.text$mn:000014B9                 push    ecx
.text$mn:000014BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000014BF                 xor     eax, ebp
.text$mn:000014C1                 push    eax
.text$mn:000014C2                 lea     eax, [ebp+var_C]
.text$mn:000014C5                 mov     large fs:0, eax
.text$mn:000014CB                 mov     [ebp+var_10], ecx
.text$mn:000014CE                 mov     [ebp+var_4], 0
.text$mn:000014D5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000014DC                 mov     ecx, [ebp+var_10] ; this
.text$mn:000014DF                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000014E4                 mov     ecx, [ebp+var_C]
.text$mn:000014E7                 mov     large fs:0, ecx
.text$mn:000014EE                 pop     ecx
.text$mn:000014EF                 mov     esp, ebp
.text$mn:000014F1                 pop     ebp
.text$mn:000014F2                 retn
.text$mn:000014F2 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:000014F2
.text$mn:000014F2 ; ---------------------------------------------------------------------------
.text$mn:000014F3                 align 4
.text$mn:000014F3 _text$mn        ends
.text$mn:000014F3
.text$x:000014F4 ; ===========================================================================
.text$x:000014F4
.text$x:000014F4 ; Segment type: Pure code
.text$x:000014F4 ; Segment permissions: Read/Execute
.text$x:000014F4 _text$x         segment para public 'CODE' use32
.text$x:000014F4                 assume cs:_text$x
.text$x:000014F4                 ;org 14F4h
.text$x:000014F4 ; COMDAT (pick associative to section at 14A8)
.text$x:000014F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000014F4
.text$x:000014F4 ; =============== S U B R O U T I N E =======================================
.text$x:000014F4
.text$x:000014F4
.text$x:000014F4 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:000014F4                                         ; DATA XREF: .xdata$x:000035BCo
.text$x:000014F4                 mov     ecx, [ebp-10h]  ; this
.text$x:000014F7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000014F7 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:000014F7
.text$x:000014FC
.text$x:000014FC ; =============== S U B R O U T I N E =======================================
.text$x:000014FC
.text$x:000014FC
.text$x:000014FC __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:000014FC                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:000014FC
.text$x:000014FC arg_4           = dword ptr  8
.text$x:000014FC
.text$x:000014FC                 mov     edx, [esp+arg_4]
.text$x:00001500                 lea     eax, [edx+0Ch]
.text$x:00001503                 mov     ecx, [edx-8]
.text$x:00001506                 xor     ecx, eax
.text$x:00001508                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000150D                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00001512                 jmp     ___CxxFrameHandler3
.text$x:00001512 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00001512
.text$x:00001512 ; ---------------------------------------------------------------------------
.text$x:00001517                 align 4
.text$x:00001517 _text$x         ends
.text$x:00001517
.text$mn:00001518 ; ===========================================================================
.text$mn:00001518
.text$mn:00001518 ; Segment type: Pure code
.text$mn:00001518 ; Segment permissions: Read/Execute
.text$mn:00001518 _text$mn        segment para public 'CODE' use32
.text$mn:00001518                 assume cs:_text$mn
.text$mn:00001518                 ;org 1518h
.text$mn:00001518 ; COMDAT (pick any)
.text$mn:00001518                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001518
.text$mn:00001518 ; =============== S U B R O U T I N E =======================================
.text$mn:00001518
.text$mn:00001518 ; Attributes: bp-based frame
.text$mn:00001518
.text$mn:00001518 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00001518                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001518 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00001518                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00001518                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00001518
.text$mn:00001518 var_10          = dword ptr -10h
.text$mn:00001518 var_C           = dword ptr -0Ch
.text$mn:00001518 var_4           = dword ptr -4
.text$mn:00001518
.text$mn:00001518                 push    ebp
.text$mn:00001519                 mov     ebp, esp
.text$mn:0000151B                 push    0FFFFFFFFh
.text$mn:0000151D                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001522                 mov     eax, large fs:0
.text$mn:00001528                 push    eax
.text$mn:00001529                 push    ecx
.text$mn:0000152A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000152F                 xor     eax, ebp
.text$mn:00001531                 push    eax
.text$mn:00001532                 lea     eax, [ebp+var_C]
.text$mn:00001535                 mov     large fs:0, eax
.text$mn:0000153B                 mov     [ebp+var_10], ecx
.text$mn:0000153E                 mov     [ebp+var_4], 0
.text$mn:00001545                 push    0               ; Size
.text$mn:00001547                 push    1               ; char
.text$mn:00001549                 mov     ecx, [ebp+var_10]
.text$mn:0000154C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001551                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001558                 mov     ecx, [ebp+var_10]
.text$mn:0000155B                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00001560                 mov     ecx, [ebp+var_C]
.text$mn:00001563                 mov     large fs:0, ecx
.text$mn:0000156A                 pop     ecx
.text$mn:0000156B                 mov     esp, ebp
.text$mn:0000156D                 pop     ebp
.text$mn:0000156E                 retn
.text$mn:0000156E ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:0000156E
.text$mn:0000156E ; ---------------------------------------------------------------------------
.text$mn:0000156F                 align 10h
.text$mn:0000156F _text$mn        ends
.text$mn:0000156F
.text$x:00001570 ; ===========================================================================
.text$x:00001570
.text$x:00001570 ; Segment type: Pure code
.text$x:00001570 ; Segment permissions: Read/Execute
.text$x:00001570 _text$x         segment para public 'CODE' use32
.text$x:00001570                 assume cs:_text$x
.text$x:00001570                 ;org 1570h
.text$x:00001570 ; COMDAT (pick associative to section at 1518)
.text$x:00001570                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001570
.text$x:00001570 ; =============== S U B R O U T I N E =======================================
.text$x:00001570
.text$x:00001570
.text$x:00001570 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00001570                                         ; DATA XREF: .xdata$x:0000334Co
.text$x:00001570                 mov     ecx, [ebp-10h]
.text$x:00001573                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00001573 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00001573
.text$x:00001578
.text$x:00001578 ; =============== S U B R O U T I N E =======================================
.text$x:00001578
.text$x:00001578
.text$x:00001578 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00001578                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00001578
.text$x:00001578 arg_4           = dword ptr  8
.text$x:00001578
.text$x:00001578                 mov     edx, [esp+arg_4]
.text$x:0000157C                 lea     eax, [edx+0Ch]
.text$x:0000157F                 mov     ecx, [edx-8]
.text$x:00001582                 xor     ecx, eax
.text$x:00001584                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001589                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:0000158E                 jmp     ___CxxFrameHandler3
.text$x:0000158E __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:0000158E
.text$x:0000158E ; ---------------------------------------------------------------------------
.text$x:00001593                 align 4
.text$x:00001593 _text$x         ends
.text$x:00001593
.text$mn:00001594 ; ===========================================================================
.text$mn:00001594
.text$mn:00001594 ; Segment type: Pure code
.text$mn:00001594 ; Segment permissions: Read/Execute
.text$mn:00001594 _text$mn        segment para public 'CODE' use32
.text$mn:00001594                 assume cs:_text$mn
.text$mn:00001594                 ;org 1594h
.text$mn:00001594 ; COMDAT (pick any)
.text$mn:00001594                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001594
.text$mn:00001594 ; =============== S U B R O U T I N E =======================================
.text$mn:00001594
.text$mn:00001594 ; Attributes: bp-based frame
.text$mn:00001594
.text$mn:00001594 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00001594                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00001594 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00001594                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+217p
.text$mn:00001594                                         ; __unwindfunclet$?run_dlgProc@AboutDlg@@MAGHIIJ@Z$0+3j
.text$mn:00001594
.text$mn:00001594 var_10          = dword ptr -10h
.text$mn:00001594 var_C           = dword ptr -0Ch
.text$mn:00001594 var_4           = dword ptr -4
.text$mn:00001594
.text$mn:00001594                 push    ebp
.text$mn:00001595                 mov     ebp, esp
.text$mn:00001597                 push    0FFFFFFFFh
.text$mn:00001599                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000159E                 mov     eax, large fs:0
.text$mn:000015A4                 push    eax
.text$mn:000015A5                 push    ecx
.text$mn:000015A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000015AB                 xor     eax, ebp
.text$mn:000015AD                 push    eax
.text$mn:000015AE                 lea     eax, [ebp+var_C]
.text$mn:000015B1                 mov     large fs:0, eax
.text$mn:000015B7                 mov     [ebp+var_10], ecx
.text$mn:000015BA                 mov     [ebp+var_4], 0
.text$mn:000015C1                 push    0
.text$mn:000015C3                 push    1
.text$mn:000015C5                 mov     ecx, [ebp+var_10]
.text$mn:000015C8                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000015CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000015D4                 mov     ecx, [ebp+var_10]
.text$mn:000015D7                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:000015DC                 mov     ecx, [ebp+var_C]
.text$mn:000015DF                 mov     large fs:0, ecx
.text$mn:000015E6                 pop     ecx
.text$mn:000015E7                 mov     esp, ebp
.text$mn:000015E9                 pop     ebp
.text$mn:000015EA                 retn
.text$mn:000015EA ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:000015EA
.text$mn:000015EA ; ---------------------------------------------------------------------------
.text$mn:000015EB                 align 4
.text$mn:000015EB _text$mn        ends
.text$mn:000015EB
.text$x:000015EC ; ===========================================================================
.text$x:000015EC
.text$x:000015EC ; Segment type: Pure code
.text$x:000015EC ; Segment permissions: Read/Execute
.text$x:000015EC _text$x         segment para public 'CODE' use32
.text$x:000015EC                 assume cs:_text$x
.text$x:000015EC                 ;org 15ECh
.text$x:000015EC ; COMDAT (pick associative to section at 1594)
.text$x:000015EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000015EC
.text$x:000015EC ; =============== S U B R O U T I N E =======================================
.text$x:000015EC
.text$x:000015EC
.text$x:000015EC __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:000015EC                                         ; DATA XREF: .xdata$x:0000366Co
.text$x:000015EC                 mov     ecx, [ebp-10h]
.text$x:000015EF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000015EF __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:000015EF
.text$x:000015F4
.text$x:000015F4 ; =============== S U B R O U T I N E =======================================
.text$x:000015F4
.text$x:000015F4
.text$x:000015F4 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:000015F4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:000015F4
.text$x:000015F4 arg_4           = dword ptr  8
.text$x:000015F4
.text$x:000015F4                 mov     edx, [esp+arg_4]
.text$x:000015F8                 lea     eax, [edx+0Ch]
.text$x:000015FB                 mov     ecx, [edx-8]
.text$x:000015FE                 xor     ecx, eax
.text$x:00001600                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001605                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:0000160A                 jmp     ___CxxFrameHandler3
.text$x:0000160A __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:0000160A
.text$x:0000160A ; ---------------------------------------------------------------------------
.text$x:0000160F                 align 10h
.text$x:0000160F _text$x         ends
.text$x:0000160F
.text$mn:00001610 ; ===========================================================================
.text$mn:00001610
.text$mn:00001610 ; Segment type: Pure code
.text$mn:00001610 ; Segment permissions: Read/Execute
.text$mn:00001610 _text$mn        segment para public 'CODE' use32
.text$mn:00001610                 assume cs:_text$mn
.text$mn:00001610                 ;org 1610h
.text$mn:00001610 ; COMDAT (pick any)
.text$mn:00001610                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001610
.text$mn:00001610 ; =============== S U B R O U T I N E =======================================
.text$mn:00001610
.text$mn:00001610 ; Attributes: bp-based frame
.text$mn:00001610
.text$mn:00001610 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001610                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00001610 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00001610                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00001610                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00001610
.text$mn:00001610 var_4           = dword ptr -4
.text$mn:00001610
.text$mn:00001610                 push    ebp
.text$mn:00001611                 mov     ebp, esp
.text$mn:00001613                 push    ecx
.text$mn:00001614                 mov     [ebp+var_4], ecx
.text$mn:00001617                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000161A                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000161F                 mov     esp, ebp
.text$mn:00001621                 pop     ebp
.text$mn:00001622                 retn
.text$mn:00001622 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00001622
.text$mn:00001622 ; ---------------------------------------------------------------------------
.text$mn:00001623                 align 4
.text$mn:00001623 _text$mn        ends
.text$mn:00001623
.text$mn:00001624 ; ===========================================================================
.text$mn:00001624
.text$mn:00001624 ; Segment type: Pure code
.text$mn:00001624 ; Segment permissions: Read/Execute
.text$mn:00001624 _text$mn        segment para public 'CODE' use32
.text$mn:00001624                 assume cs:_text$mn
.text$mn:00001624                 ;org 1624h
.text$mn:00001624 ; COMDAT (pick any)
.text$mn:00001624                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001624
.text$mn:00001624 ; =============== S U B R O U T I N E =======================================
.text$mn:00001624
.text$mn:00001624 ; Attributes: bp-based frame
.text$mn:00001624
.text$mn:00001624 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001624                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001624 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00001624                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00001624                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00001624
.text$mn:00001624 var_10          = dword ptr -10h
.text$mn:00001624 var_C           = dword ptr -0Ch
.text$mn:00001624 var_4           = dword ptr -4
.text$mn:00001624
.text$mn:00001624                 push    ebp
.text$mn:00001625                 mov     ebp, esp
.text$mn:00001627                 push    0FFFFFFFFh
.text$mn:00001629                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:0000162E                 mov     eax, large fs:0
.text$mn:00001634                 push    eax
.text$mn:00001635                 push    ecx
.text$mn:00001636                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000163B                 xor     eax, ebp
.text$mn:0000163D                 push    eax
.text$mn:0000163E                 lea     eax, [ebp+var_C]
.text$mn:00001641                 mov     large fs:0, eax
.text$mn:00001647                 mov     [ebp+var_10], ecx
.text$mn:0000164A                 mov     [ebp+var_4], 0
.text$mn:00001651                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001658                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000165B                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001660                 mov     ecx, [ebp+var_C]
.text$mn:00001663                 mov     large fs:0, ecx
.text$mn:0000166A                 pop     ecx
.text$mn:0000166B                 mov     esp, ebp
.text$mn:0000166D                 pop     ebp
.text$mn:0000166E                 retn
.text$mn:0000166E ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:0000166E
.text$mn:0000166E ; ---------------------------------------------------------------------------
.text$mn:0000166F                 align 10h
.text$mn:0000166F _text$mn        ends
.text$mn:0000166F
.text$x:00001670 ; ===========================================================================
.text$x:00001670
.text$x:00001670 ; Segment type: Pure code
.text$x:00001670 ; Segment permissions: Read/Execute
.text$x:00001670 _text$x         segment para public 'CODE' use32
.text$x:00001670                 assume cs:_text$x
.text$x:00001670                 ;org 1670h
.text$x:00001670 ; COMDAT (pick associative to section at 1624)
.text$x:00001670                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001670
.text$x:00001670 ; =============== S U B R O U T I N E =======================================
.text$x:00001670
.text$x:00001670
.text$x:00001670 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00001670                                         ; DATA XREF: .xdata$x:0000345Co
.text$x:00001670                 mov     ecx, [ebp-10h]  ; this
.text$x:00001673                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00001673 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00001673
.text$x:00001678
.text$x:00001678 ; =============== S U B R O U T I N E =======================================
.text$x:00001678
.text$x:00001678
.text$x:00001678 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00001678                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00001678
.text$x:00001678 arg_4           = dword ptr  8
.text$x:00001678
.text$x:00001678                 mov     edx, [esp+arg_4]
.text$x:0000167C                 lea     eax, [edx+0Ch]
.text$x:0000167F                 mov     ecx, [edx-8]
.text$x:00001682                 xor     ecx, eax
.text$x:00001684                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001689                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:0000168E                 jmp     ___CxxFrameHandler3
.text$x:0000168E __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:0000168E
.text$x:0000168E ; ---------------------------------------------------------------------------
.text$x:00001693                 align 4
.text$x:00001693 _text$x         ends
.text$x:00001693
.text$mn:00001694 ; ===========================================================================
.text$mn:00001694
.text$mn:00001694 ; Segment type: Pure code
.text$mn:00001694 ; Segment permissions: Read/Execute
.text$mn:00001694 _text$mn        segment para public 'CODE' use32
.text$mn:00001694                 assume cs:_text$mn
.text$mn:00001694                 ;org 1694h
.text$mn:00001694 ; COMDAT (pick any)
.text$mn:00001694                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001694
.text$mn:00001694 ; =============== S U B R O U T I N E =======================================
.text$mn:00001694
.text$mn:00001694 ; Attributes: bp-based frame
.text$mn:00001694
.text$mn:00001694 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00001694                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001694 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00001694                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001694                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00001694
.text$mn:00001694 var_10          = dword ptr -10h
.text$mn:00001694 var_C           = dword ptr -0Ch
.text$mn:00001694 var_4           = dword ptr -4
.text$mn:00001694
.text$mn:00001694                 push    ebp
.text$mn:00001695                 mov     ebp, esp
.text$mn:00001697                 push    0FFFFFFFFh
.text$mn:00001699                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:0000169E                 mov     eax, large fs:0
.text$mn:000016A4                 push    eax
.text$mn:000016A5                 push    ecx
.text$mn:000016A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000016AB                 xor     eax, ebp
.text$mn:000016AD                 push    eax
.text$mn:000016AE                 lea     eax, [ebp+var_C]
.text$mn:000016B1                 mov     large fs:0, eax
.text$mn:000016B7                 mov     [ebp+var_10], ecx
.text$mn:000016BA                 mov     [ebp+var_4], 0
.text$mn:000016C1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000016C8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000016CB                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000016D0                 mov     ecx, [ebp+var_C]
.text$mn:000016D3                 mov     large fs:0, ecx
.text$mn:000016DA                 pop     ecx
.text$mn:000016DB                 mov     esp, ebp
.text$mn:000016DD                 pop     ebp
.text$mn:000016DE                 retn
.text$mn:000016DE ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:000016DE
.text$mn:000016DE ; ---------------------------------------------------------------------------
.text$mn:000016DF                 align 10h
.text$mn:000016DF _text$mn        ends
.text$mn:000016DF
.text$x:000016E0 ; ===========================================================================
.text$x:000016E0
.text$x:000016E0 ; Segment type: Pure code
.text$x:000016E0 ; Segment permissions: Read/Execute
.text$x:000016E0 _text$x         segment para public 'CODE' use32
.text$x:000016E0                 assume cs:_text$x
.text$x:000016E0                 ;org 16E0h
.text$x:000016E0 ; COMDAT (pick associative to section at 1694)
.text$x:000016E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000016E0
.text$x:000016E0 ; =============== S U B R O U T I N E =======================================
.text$x:000016E0
.text$x:000016E0
.text$x:000016E0 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:000016E0                                         ; DATA XREF: .xdata$x:000034E0o
.text$x:000016E0                 mov     ecx, [ebp-10h]  ; this
.text$x:000016E3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000016E3 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:000016E3
.text$x:000016E8
.text$x:000016E8 ; =============== S U B R O U T I N E =======================================
.text$x:000016E8
.text$x:000016E8
.text$x:000016E8 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:000016E8                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:000016E8
.text$x:000016E8 arg_4           = dword ptr  8
.text$x:000016E8
.text$x:000016E8                 mov     edx, [esp+arg_4]
.text$x:000016EC                 lea     eax, [edx+0Ch]
.text$x:000016EF                 mov     ecx, [edx-8]
.text$x:000016F2                 xor     ecx, eax
.text$x:000016F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000016F9                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:000016FE                 jmp     ___CxxFrameHandler3
.text$x:000016FE __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:000016FE
.text$x:000016FE ; ---------------------------------------------------------------------------
.text$x:00001703                 align 4
.text$x:00001703 _text$x         ends
.text$x:00001703
.text$mn:00001704 ; ===========================================================================
.text$mn:00001704
.text$mn:00001704 ; Segment type: Pure code
.text$mn:00001704 ; Segment permissions: Read/Execute
.text$mn:00001704 _text$mn        segment para public 'CODE' use32
.text$mn:00001704                 assume cs:_text$mn
.text$mn:00001704                 ;org 1704h
.text$mn:00001704 ; COMDAT (pick any)
.text$mn:00001704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001704
.text$mn:00001704 ; =============== S U B R O U T I N E =======================================
.text$mn:00001704
.text$mn:00001704 ; Attributes: bp-based frame
.text$mn:00001704
.text$mn:00001704 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001704                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00001704 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00001704                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001704                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001704
.text$mn:00001704 var_10          = dword ptr -10h
.text$mn:00001704 var_C           = dword ptr -0Ch
.text$mn:00001704 var_4           = dword ptr -4
.text$mn:00001704
.text$mn:00001704                 push    ebp
.text$mn:00001705                 mov     ebp, esp
.text$mn:00001707                 push    0FFFFFFFFh
.text$mn:00001709                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:0000170E                 mov     eax, large fs:0
.text$mn:00001714                 push    eax
.text$mn:00001715                 push    ecx
.text$mn:00001716                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000171B                 xor     eax, ebp
.text$mn:0000171D                 push    eax
.text$mn:0000171E                 lea     eax, [ebp+var_C]
.text$mn:00001721                 mov     large fs:0, eax
.text$mn:00001727                 mov     [ebp+var_10], ecx
.text$mn:0000172A                 mov     [ebp+var_4], 0
.text$mn:00001731                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001738                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000173B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001740                 mov     ecx, [ebp+var_C]
.text$mn:00001743                 mov     large fs:0, ecx
.text$mn:0000174A                 pop     ecx
.text$mn:0000174B                 mov     esp, ebp
.text$mn:0000174D                 pop     ebp
.text$mn:0000174E                 retn
.text$mn:0000174E ??1_System_error_category@std@@UAE@XZ endp
.text$mn:0000174E
.text$mn:0000174E ; ---------------------------------------------------------------------------
.text$mn:0000174F                 align 10h
.text$mn:0000174F _text$mn        ends
.text$mn:0000174F
.text$x:00001750 ; ===========================================================================
.text$x:00001750
.text$x:00001750 ; Segment type: Pure code
.text$x:00001750 ; Segment permissions: Read/Execute
.text$x:00001750 _text$x         segment para public 'CODE' use32
.text$x:00001750                 assume cs:_text$x
.text$x:00001750                 ;org 1750h
.text$x:00001750 ; COMDAT (pick associative to section at 1704)
.text$x:00001750                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001750
.text$x:00001750 ; =============== S U B R O U T I N E =======================================
.text$x:00001750
.text$x:00001750
.text$x:00001750 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00001750                                         ; DATA XREF: .xdata$x:00003564o
.text$x:00001750                 mov     ecx, [ebp-10h]  ; this
.text$x:00001753                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001753 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00001753
.text$x:00001758
.text$x:00001758 ; =============== S U B R O U T I N E =======================================
.text$x:00001758
.text$x:00001758
.text$x:00001758 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00001758                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00001758
.text$x:00001758 arg_4           = dword ptr  8
.text$x:00001758
.text$x:00001758                 mov     edx, [esp+arg_4]
.text$x:0000175C                 lea     eax, [edx+0Ch]
.text$x:0000175F                 mov     ecx, [edx-8]
.text$x:00001762                 xor     ecx, eax
.text$x:00001764                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001769                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:0000176E                 jmp     ___CxxFrameHandler3
.text$x:0000176E __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:0000176E
.text$x:0000176E ; ---------------------------------------------------------------------------
.text$x:00001773                 align 4
.text$x:00001773 _text$x         ends
.text$x:00001773
.text$mn:00001774 ; ===========================================================================
.text$mn:00001774
.text$mn:00001774 ; Segment type: Pure code
.text$mn:00001774 ; Segment permissions: Read/Execute
.text$mn:00001774 _text$mn        segment para public 'CODE' use32
.text$mn:00001774                 assume cs:_text$mn
.text$mn:00001774                 ;org 1774h
.text$mn:00001774 ; COMDAT (pick any)
.text$mn:00001774                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001774
.text$mn:00001774 ; =============== S U B R O U T I N E =======================================
.text$mn:00001774
.text$mn:00001774 ; Attributes: bp-based frame
.text$mn:00001774
.text$mn:00001774 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00001774                 public ??1error_category@std@@UAE@XZ
.text$mn:00001774 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00001774                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00001774
.text$mn:00001774 var_4           = dword ptr -4
.text$mn:00001774
.text$mn:00001774                 push    ebp
.text$mn:00001775                 mov     ebp, esp
.text$mn:00001777                 push    ecx
.text$mn:00001778                 mov     [ebp+var_4], ecx
.text$mn:0000177B                 mov     eax, [ebp+var_4]
.text$mn:0000177E                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001784                 mov     esp, ebp
.text$mn:00001786                 pop     ebp
.text$mn:00001787                 retn
.text$mn:00001787 ??1error_category@std@@UAE@XZ endp
.text$mn:00001787
.text$mn:00001787 _text$mn        ends
.text$mn:00001787
.text$mn:00001788 ; ===========================================================================
.text$mn:00001788
.text$mn:00001788 ; Segment type: Pure code
.text$mn:00001788 ; Segment permissions: Read/Execute
.text$mn:00001788 _text$mn        segment para public 'CODE' use32
.text$mn:00001788                 assume cs:_text$mn
.text$mn:00001788                 ;org 1788h
.text$mn:00001788 ; COMDAT (pick any)
.text$mn:00001788                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001788
.text$mn:00001788 ; =============== S U B R O U T I N E =======================================
.text$mn:00001788
.text$mn:00001788 ; Attributes: bp-based frame
.text$mn:00001788
.text$mn:00001788 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00001788                 public ??2@YAPAXIPAX@Z
.text$mn:00001788 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00001788                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+2Ep ...
.text$mn:00001788
.text$mn:00001788 arg_4           = dword ptr  0Ch
.text$mn:00001788
.text$mn:00001788                 push    ebp
.text$mn:00001789                 mov     ebp, esp
.text$mn:0000178B                 mov     eax, [ebp+arg_4]
.text$mn:0000178E                 pop     ebp
.text$mn:0000178F                 retn
.text$mn:0000178F ??2@YAPAXIPAX@Z endp
.text$mn:0000178F
.text$mn:0000178F _text$mn        ends
.text$mn:0000178F
.text$mn:00001790 ; ===========================================================================
.text$mn:00001790
.text$mn:00001790 ; Segment type: Pure code
.text$mn:00001790 ; Segment permissions: Read/Execute
.text$mn:00001790 _text$mn        segment para public 'CODE' use32
.text$mn:00001790                 assume cs:_text$mn
.text$mn:00001790                 ;org 1790h
.text$mn:00001790 ; COMDAT (pick any)
.text$mn:00001790                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001790
.text$mn:00001790 ; =============== S U B R O U T I N E =======================================
.text$mn:00001790
.text$mn:00001790 ; Attributes: bp-based frame
.text$mn:00001790
.text$mn:00001790 ; void __cdecl operator delete(void *)
.text$mn:00001790                 public ??3@YAXPAX0@Z
.text$mn:00001790 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00001790                                         ; __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0+8p ...
.text$mn:00001790                 push    ebp
.text$mn:00001791                 mov     ebp, esp
.text$mn:00001793                 pop     ebp
.text$mn:00001794                 retn
.text$mn:00001794 ??3@YAXPAX0@Z   endp
.text$mn:00001794
.text$mn:00001794 ; ---------------------------------------------------------------------------
.text$mn:00001795                 align 4
.text$mn:00001795 _text$mn        ends
.text$mn:00001795
.text$mn:00001798 ; ===========================================================================
.text$mn:00001798
.text$mn:00001798 ; Segment type: Pure code
.text$mn:00001798 ; Segment permissions: Read/Execute
.text$mn:00001798 _text$mn        segment para public 'CODE' use32
.text$mn:00001798                 assume cs:_text$mn
.text$mn:00001798                 ;org 1798h
.text$mn:00001798 ; COMDAT (pick any)
.text$mn:00001798                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001798
.text$mn:00001798 ; =============== S U B R O U T I N E =======================================
.text$mn:00001798
.text$mn:00001798 ; Attributes: bp-based frame
.text$mn:00001798
.text$mn:00001798 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00001798                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00001798 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00001798                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00001798                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00001798
.text$mn:00001798 var_8           = dword ptr -8
.text$mn:00001798 var_4           = dword ptr -4
.text$mn:00001798 arg_0           = dword ptr  8
.text$mn:00001798
.text$mn:00001798                 push    ebp
.text$mn:00001799                 mov     ebp, esp
.text$mn:0000179B                 sub     esp, 8
.text$mn:0000179E                 mov     [ebp+var_8], ecx
.text$mn:000017A1                 mov     eax, [ebp+var_8]
.text$mn:000017A4                 cmp     eax, [ebp+arg_0]
.text$mn:000017A7                 jnz     short loc_17B2
.text$mn:000017A9                 mov     [ebp+var_4], 1
.text$mn:000017B0                 jmp     short loc_17B9
.text$mn:000017B2 ; ---------------------------------------------------------------------------
.text$mn:000017B2
.text$mn:000017B2 loc_17B2:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:000017B2                 mov     [ebp+var_4], 0
.text$mn:000017B9
.text$mn:000017B9 loc_17B9:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:000017B9                 mov     al, byte ptr [ebp+var_4]
.text$mn:000017BC                 mov     esp, ebp
.text$mn:000017BE                 pop     ebp
.text$mn:000017BF                 retn    4
.text$mn:000017BF ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:000017BF
.text$mn:000017BF ; ---------------------------------------------------------------------------
.text$mn:000017C2                 align 4
.text$mn:000017C2 _text$mn        ends
.text$mn:000017C2
.text$mn:000017C4 ; ===========================================================================
.text$mn:000017C4
.text$mn:000017C4 ; Segment type: Pure code
.text$mn:000017C4 ; Segment permissions: Read/Execute
.text$mn:000017C4 _text$mn        segment para public 'CODE' use32
.text$mn:000017C4                 assume cs:_text$mn
.text$mn:000017C4                 ;org 17C4h
.text$mn:000017C4 ; COMDAT (pick any)
.text$mn:000017C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000017C4
.text$mn:000017C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000017C4
.text$mn:000017C4 ; Attributes: bp-based frame
.text$mn:000017C4
.text$mn:000017C4 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:000017C4                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:000017C4 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:000017C4                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:000017C4
.text$mn:000017C4 var_8           = dword ptr -8
.text$mn:000017C4 var_4           = dword ptr -4
.text$mn:000017C4 arg_0           = dword ptr  8
.text$mn:000017C4
.text$mn:000017C4                 push    ebp
.text$mn:000017C5                 mov     ebp, esp
.text$mn:000017C7                 sub     esp, 8
.text$mn:000017CA                 push    esi
.text$mn:000017CB                 mov     [ebp+var_4], ecx
.text$mn:000017CE                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000017D1                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000017D6                 push    eax
.text$mn:000017D7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000017DA                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:000017DF                 mov     ecx, eax
.text$mn:000017E1                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:000017E6                 movzx   eax, al
.text$mn:000017E9                 test    eax, eax
.text$mn:000017EB                 jz      short loc_180C
.text$mn:000017ED                 mov     ecx, [ebp+var_4] ; this
.text$mn:000017F0                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000017F5                 mov     esi, eax
.text$mn:000017F7                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000017FA                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:000017FF                 cmp     esi, eax
.text$mn:00001801                 jnz     short loc_180C
.text$mn:00001803                 mov     [ebp+var_8], 1
.text$mn:0000180A                 jmp     short loc_1813
.text$mn:0000180C ; ---------------------------------------------------------------------------
.text$mn:0000180C
.text$mn:0000180C loc_180C:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:0000180C                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:0000180C                 mov     [ebp+var_8], 0
.text$mn:00001813
.text$mn:00001813 loc_1813:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00001813                 mov     al, byte ptr [ebp+var_8]
.text$mn:00001816                 pop     esi
.text$mn:00001817                 mov     esp, ebp
.text$mn:00001819                 pop     ebp
.text$mn:0000181A                 retn    4
.text$mn:0000181A ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:0000181A
.text$mn:0000181A ; ---------------------------------------------------------------------------
.text$mn:0000181D                 align 10h
.text$mn:0000181D _text$mn        ends
.text$mn:0000181D
.text$mn:00001820 ; ===========================================================================
.text$mn:00001820
.text$mn:00001820 ; Segment type: Pure code
.text$mn:00001820 ; Segment permissions: Read/Execute
.text$mn:00001820 _text$mn        segment para public 'CODE' use32
.text$mn:00001820                 assume cs:_text$mn
.text$mn:00001820                 ;org 1820h
.text$mn:00001820 ; COMDAT (pick any)
.text$mn:00001820                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001820
.text$mn:00001820 ; =============== S U B R O U T I N E =======================================
.text$mn:00001820
.text$mn:00001820 ; Attributes: bp-based frame
.text$mn:00001820
.text$mn:00001820 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t *Str)
.text$mn:00001820                 public ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:00001820 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:00001820                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+B5p
.text$mn:00001820                                         ; AboutDlg::run_dlgProc(uint,uint,long)+C2p ...
.text$mn:00001820
.text$mn:00001820 var_4           = dword ptr -4
.text$mn:00001820 Str             = dword ptr  8
.text$mn:00001820
.text$mn:00001820                 push    ebp
.text$mn:00001821                 mov     ebp, esp
.text$mn:00001823                 push    ecx
.text$mn:00001824                 mov     [ebp+var_4], ecx
.text$mn:00001827                 mov     eax, [ebp+Str]
.text$mn:0000182A                 push    eax             ; Str
.text$mn:0000182B                 mov     ecx, [ebp+var_4]
.text$mn:0000182E                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:00001833                 mov     esp, ebp
.text$mn:00001835                 pop     ebp
.text$mn:00001836                 retn    4
.text$mn:00001836 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:00001836
.text$mn:00001836 ; ---------------------------------------------------------------------------
.text$mn:00001839                 align 4
.text$mn:00001839 _text$mn        ends
.text$mn:00001839
.text$mn:0000183C ; ===========================================================================
.text$mn:0000183C
.text$mn:0000183C ; Segment type: Pure code
.text$mn:0000183C ; Segment permissions: Read/Execute
.text$mn:0000183C _text$mn        segment para public 'CODE' use32
.text$mn:0000183C                 assume cs:_text$mn
.text$mn:0000183C                 ;org 183Ch
.text$mn:0000183C ; COMDAT (pick any)
.text$mn:0000183C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000183C
.text$mn:0000183C ; =============== S U B R O U T I N E =======================================
.text$mn:0000183C
.text$mn:0000183C ; Attributes: bp-based frame
.text$mn:0000183C
.text$mn:0000183C ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000183C                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:0000183C ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000183C
.text$mn:0000183C var_4           = dword ptr -4
.text$mn:0000183C arg_0           = dword ptr  8
.text$mn:0000183C
.text$mn:0000183C                 push    ebp
.text$mn:0000183D                 mov     ebp, esp
.text$mn:0000183F                 push    ecx
.text$mn:00001840                 mov     [ebp+var_4], ecx
.text$mn:00001843                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001846                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:0000184B                 mov     eax, [ebp+arg_0]
.text$mn:0000184E                 and     eax, 1
.text$mn:00001851                 jz      short loc_185F
.text$mn:00001853                 mov     ecx, [ebp+var_4]
.text$mn:00001856                 push    ecx             ; void *
.text$mn:00001857                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000185C                 add     esp, 4
.text$mn:0000185F
.text$mn:0000185F loc_185F:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000185F                 mov     eax, [ebp+var_4]
.text$mn:00001862                 mov     esp, ebp
.text$mn:00001864                 pop     ebp
.text$mn:00001865                 retn    4
.text$mn:00001865 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00001865
.text$mn:00001865 _text$mn        ends
.text$mn:00001865
.text$mn:00001868 ; ===========================================================================
.text$mn:00001868
.text$mn:00001868 ; Segment type: Pure code
.text$mn:00001868 ; Segment permissions: Read/Execute
.text$mn:00001868 _text$mn        segment para public 'CODE' use32
.text$mn:00001868                 assume cs:_text$mn
.text$mn:00001868                 ;org 1868h
.text$mn:00001868 ; COMDAT (pick any)
.text$mn:00001868                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001868
.text$mn:00001868 ; =============== S U B R O U T I N E =======================================
.text$mn:00001868
.text$mn:00001868 ; Attributes: bp-based frame
.text$mn:00001868
.text$mn:00001868 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001868                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00001868 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001868
.text$mn:00001868 var_4           = dword ptr -4
.text$mn:00001868 arg_0           = dword ptr  8
.text$mn:00001868
.text$mn:00001868                 push    ebp
.text$mn:00001869                 mov     ebp, esp
.text$mn:0000186B                 push    ecx
.text$mn:0000186C                 mov     [ebp+var_4], ecx
.text$mn:0000186F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001872                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00001877                 mov     eax, [ebp+arg_0]
.text$mn:0000187A                 and     eax, 1
.text$mn:0000187D                 jz      short loc_188B
.text$mn:0000187F                 mov     ecx, [ebp+var_4]
.text$mn:00001882                 push    ecx             ; void *
.text$mn:00001883                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001888                 add     esp, 4
.text$mn:0000188B
.text$mn:0000188B loc_188B:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000188B                 mov     eax, [ebp+var_4]
.text$mn:0000188E                 mov     esp, ebp
.text$mn:00001890                 pop     ebp
.text$mn:00001891                 retn    4
.text$mn:00001891 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00001891
.text$mn:00001891 _text$mn        ends
.text$mn:00001891
.text$mn:00001894 ; ===========================================================================
.text$mn:00001894
.text$mn:00001894 ; Segment type: Pure code
.text$mn:00001894 ; Segment permissions: Read/Execute
.text$mn:00001894 _text$mn        segment para public 'CODE' use32
.text$mn:00001894                 assume cs:_text$mn
.text$mn:00001894                 ;org 1894h
.text$mn:00001894 ; COMDAT (pick any)
.text$mn:00001894                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001894
.text$mn:00001894 ; =============== S U B R O U T I N E =======================================
.text$mn:00001894
.text$mn:00001894 ; Attributes: bp-based frame
.text$mn:00001894
.text$mn:00001894 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001894                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00001894 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001894
.text$mn:00001894 var_4           = dword ptr -4
.text$mn:00001894 arg_0           = dword ptr  8
.text$mn:00001894
.text$mn:00001894                 push    ebp
.text$mn:00001895                 mov     ebp, esp
.text$mn:00001897                 push    ecx
.text$mn:00001898                 mov     [ebp+var_4], ecx
.text$mn:0000189B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000189E                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:000018A3                 mov     eax, [ebp+arg_0]
.text$mn:000018A6                 and     eax, 1
.text$mn:000018A9                 jz      short loc_18B7
.text$mn:000018AB                 mov     ecx, [ebp+var_4]
.text$mn:000018AE                 push    ecx             ; void *
.text$mn:000018AF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000018B4                 add     esp, 4
.text$mn:000018B7
.text$mn:000018B7 loc_18B7:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000018B7                 mov     eax, [ebp+var_4]
.text$mn:000018BA                 mov     esp, ebp
.text$mn:000018BC                 pop     ebp
.text$mn:000018BD                 retn    4
.text$mn:000018BD ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:000018BD
.text$mn:000018BD _text$mn        ends
.text$mn:000018BD
.text$mn:000018C0 ; ===========================================================================
.text$mn:000018C0
.text$mn:000018C0 ; Segment type: Pure code
.text$mn:000018C0 ; Segment permissions: Read/Execute
.text$mn:000018C0 _text$mn        segment para public 'CODE' use32
.text$mn:000018C0                 assume cs:_text$mn
.text$mn:000018C0                 ;org 18C0h
.text$mn:000018C0 ; COMDAT (pick any)
.text$mn:000018C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018C0
.text$mn:000018C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018C0
.text$mn:000018C0 ; Attributes: bp-based frame
.text$mn:000018C0
.text$mn:000018C0 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000018C0                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:000018C0 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:000018C0
.text$mn:000018C0 var_4           = dword ptr -4
.text$mn:000018C0 arg_0           = dword ptr  8
.text$mn:000018C0
.text$mn:000018C0                 push    ebp
.text$mn:000018C1                 mov     ebp, esp
.text$mn:000018C3                 push    ecx
.text$mn:000018C4                 mov     [ebp+var_4], ecx
.text$mn:000018C7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000018CA                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000018CF                 mov     eax, [ebp+arg_0]
.text$mn:000018D2                 and     eax, 1
.text$mn:000018D5                 jz      short loc_18E3
.text$mn:000018D7                 mov     ecx, [ebp+var_4]
.text$mn:000018DA                 push    ecx             ; void *
.text$mn:000018DB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000018E0                 add     esp, 4
.text$mn:000018E3
.text$mn:000018E3 loc_18E3:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000018E3                 mov     eax, [ebp+var_4]
.text$mn:000018E6                 mov     esp, ebp
.text$mn:000018E8                 pop     ebp
.text$mn:000018E9                 retn    4
.text$mn:000018E9 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:000018E9
.text$mn:000018E9 _text$mn        ends
.text$mn:000018E9
.text$di:000018EC ; ===========================================================================
.text$di:000018EC
.text$di:000018EC ; Segment type: Pure code
.text$di:000018EC ; Segment permissions: Read/Execute
.text$di:000018EC _text$di        segment para public 'CODE' use32
.text$di:000018EC                 assume cs:_text$di
.text$di:000018EC                 ;org 18ECh
.text$di:000018EC ; COMDAT (pick any)
.text$di:000018EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000018EC
.text$di:000018EC ; =============== S U B R O U T I N E =======================================
.text$di:000018EC
.text$di:000018EC ; Attributes: bp-based frame
.text$di:000018EC
.text$di:000018EC ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:000018EC ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:000018EC                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:000018EC                 push    ebp
.text$di:000018ED                 mov     ebp, esp
.text$di:000018EF                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:000018F4                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:000018F9                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000018FE                 call    _atexit
.text$di:00001903                 add     esp, 4
.text$di:00001906                 pop     ebp
.text$di:00001907                 retn
.text$di:00001907 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00001907
.text$di:00001907 _text$di        ends
.text$di:00001907
.text$di:00001908 ; ===========================================================================
.text$di:00001908
.text$di:00001908 ; Segment type: Pure code
.text$di:00001908 ; Segment permissions: Read/Execute
.text$di:00001908 _text$di        segment para public 'CODE' use32
.text$di:00001908                 assume cs:_text$di
.text$di:00001908                 ;org 1908h
.text$di:00001908 ; COMDAT (pick any)
.text$di:00001908                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001908
.text$di:00001908 ; =============== S U B R O U T I N E =======================================
.text$di:00001908
.text$di:00001908 ; Attributes: bp-based frame
.text$di:00001908
.text$di:00001908 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00001908 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00001908                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00001908                 push    ebp
.text$di:00001909                 mov     ebp, esp
.text$di:0000190B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00001910                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00001915                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:0000191A                 call    _atexit
.text$di:0000191F                 add     esp, 4
.text$di:00001922                 pop     ebp
.text$di:00001923                 retn
.text$di:00001923 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00001923
.text$di:00001923 _text$di        ends
.text$di:00001923
.text$di:00001924 ; ===========================================================================
.text$di:00001924
.text$di:00001924 ; Segment type: Pure code
.text$di:00001924 ; Segment permissions: Read/Execute
.text$di:00001924 _text$di        segment para public 'CODE' use32
.text$di:00001924                 assume cs:_text$di
.text$di:00001924                 ;org 1924h
.text$di:00001924 ; COMDAT (pick any)
.text$di:00001924                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001924
.text$di:00001924 ; =============== S U B R O U T I N E =======================================
.text$di:00001924
.text$di:00001924 ; Attributes: bp-based frame
.text$di:00001924
.text$di:00001924 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00001924 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00001924                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00001924                 push    ebp
.text$di:00001925                 mov     ebp, esp
.text$di:00001927                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:0000192C                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00001931                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001936                 call    _atexit
.text$di:0000193B                 add     esp, 4
.text$di:0000193E                 pop     ebp
.text$di:0000193F                 retn
.text$di:0000193F ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:0000193F
.text$di:0000193F _text$di        ends
.text$di:0000193F
.text$di:00001940 ; ===========================================================================
.text$di:00001940
.text$di:00001940 ; Segment type: Pure code
.text$di:00001940 ; Segment permissions: Read/Execute
.text$di:00001940 _text$di        segment para public 'CODE' use32
.text$di:00001940                 assume cs:_text$di
.text$di:00001940                 ;org 1940h
.text$di:00001940 ; COMDAT (pick any)
.text$di:00001940                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001940
.text$di:00001940 ; =============== S U B R O U T I N E =======================================
.text$di:00001940
.text$di:00001940 ; Attributes: bp-based frame
.text$di:00001940
.text$di:00001940 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00001940 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001940                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00001940                 push    ebp
.text$di:00001941                 mov     ebp, esp
.text$di:00001943                 push    0               ; unsigned int
.text$di:00001945                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000194A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000194F                 pop     ebp
.text$di:00001950                 retn
.text$di:00001950 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001950
.text$di:00001950 ; ---------------------------------------------------------------------------
.text$di:00001951                 align 4
.text$di:00001951 _text$di        ends
.text$di:00001951
.text$di:00001954 ; ===========================================================================
.text$di:00001954
.text$di:00001954 ; Segment type: Pure code
.text$di:00001954 ; Segment permissions: Read/Execute
.text$di:00001954 _text$di        segment para public 'CODE' use32
.text$di:00001954                 assume cs:_text$di
.text$di:00001954                 ;org 1954h
.text$di:00001954 ; COMDAT (pick any)
.text$di:00001954                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001954
.text$di:00001954 ; =============== S U B R O U T I N E =======================================
.text$di:00001954
.text$di:00001954 ; Attributes: bp-based frame
.text$di:00001954
.text$di:00001954 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00001954 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001954                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00001954                 push    ebp
.text$di:00001955                 mov     ebp, esp
.text$di:00001957                 push    0               ; unsigned int
.text$di:00001959                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:0000195E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001963                 pop     ebp
.text$di:00001964                 retn
.text$di:00001964 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001964
.text$di:00001964 ; ---------------------------------------------------------------------------
.text$di:00001965                 align 4
.text$di:00001965 _text$di        ends
.text$di:00001965
.text$di:00001968 ; ===========================================================================
.text$di:00001968
.text$di:00001968 ; Segment type: Pure code
.text$di:00001968 ; Segment permissions: Read/Execute
.text$di:00001968 _text$di        segment para public 'CODE' use32
.text$di:00001968                 assume cs:_text$di
.text$di:00001968                 ;org 1968h
.text$di:00001968 ; COMDAT (pick any)
.text$di:00001968                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001968
.text$di:00001968 ; =============== S U B R O U T I N E =======================================
.text$di:00001968
.text$di:00001968 ; Attributes: bp-based frame
.text$di:00001968
.text$di:00001968 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00001968 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001968                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00001968                 push    ebp
.text$di:00001969                 mov     ebp, esp
.text$di:0000196B                 push    0               ; unsigned int
.text$di:0000196D                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00001972                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001977                 pop     ebp
.text$di:00001978                 retn
.text$di:00001978 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001978
.text$di:00001978 ; ---------------------------------------------------------------------------
.text$di:00001979                 align 4
.text$di:00001979 _text$di        ends
.text$di:00001979
.text$di:0000197C ; ===========================================================================
.text$di:0000197C
.text$di:0000197C ; Segment type: Pure code
.text$di:0000197C ; Segment permissions: Read/Execute
.text$di:0000197C _text$di        segment para public 'CODE' use32
.text$di:0000197C                 assume cs:_text$di
.text$di:0000197C                 ;org 197Ch
.text$di:0000197C ; COMDAT (pick any)
.text$di:0000197C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000197C
.text$di:0000197C ; =============== S U B R O U T I N E =======================================
.text$di:0000197C
.text$di:0000197C ; Attributes: bp-based frame
.text$di:0000197C
.text$di:0000197C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:0000197C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:0000197C                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:0000197C                 push    ebp
.text$di:0000197D                 mov     ebp, esp
.text$di:0000197F                 push    0               ; unsigned int
.text$di:00001981                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00001986                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000198B                 pop     ebp
.text$di:0000198C                 retn
.text$di:0000198C ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:0000198C
.text$di:0000198C ; ---------------------------------------------------------------------------
.text$di:0000198D                 align 10h
.text$di:0000198D _text$di        ends
.text$di:0000198D
.text$di:00001990 ; ===========================================================================
.text$di:00001990
.text$di:00001990 ; Segment type: Pure code
.text$di:00001990 ; Segment permissions: Read/Execute
.text$di:00001990 _text$di        segment para public 'CODE' use32
.text$di:00001990                 assume cs:_text$di
.text$di:00001990                 ;org 1990h
.text$di:00001990 ; COMDAT (pick any)
.text$di:00001990                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001990
.text$di:00001990 ; =============== S U B R O U T I N E =======================================
.text$di:00001990
.text$di:00001990 ; Attributes: bp-based frame
.text$di:00001990
.text$di:00001990 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00001990 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00001990
.text$di:00001990 var_1           = byte ptr -1
.text$di:00001990
.text$di:00001990                 push    ebp
.text$di:00001991                 mov     ebp, esp
.text$di:00001993                 push    ecx
.text$di:00001994                 xor     eax, eax
.text$di:00001996                 mov     [ebp+var_1], al
.text$di:00001999                 mov     esp, ebp
.text$di:0000199B                 pop     ebp
.text$di:0000199C                 retn
.text$di:0000199C ??__Eallocator_arg@std@@YAXXZ endp
.text$di:0000199C
.text$di:0000199C ; ---------------------------------------------------------------------------
.text$di:0000199D                 align 10h
.text$di:0000199D _text$di        ends
.text$di:0000199D
.text$di:000019A0 ; ===========================================================================
.text$di:000019A0
.text$di:000019A0 ; Segment type: Pure code
.text$di:000019A0 ; Segment permissions: Read/Execute
.text$di:000019A0 _text$di        segment para public 'CODE' use32
.text$di:000019A0                 assume cs:_text$di
.text$di:000019A0                 ;org 19A0h
.text$di:000019A0 ; COMDAT (pick any)
.text$di:000019A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000019A0
.text$di:000019A0 ; =============== S U B R O U T I N E =======================================
.text$di:000019A0
.text$di:000019A0 ; Attributes: bp-based frame
.text$di:000019A0
.text$di:000019A0 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:000019A0 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:000019A0                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:000019A0
.text$di:000019A0 var_1           = byte ptr -1
.text$di:000019A0
.text$di:000019A0                 push    ebp
.text$di:000019A1                 mov     ebp, esp
.text$di:000019A3                 push    ecx
.text$di:000019A4                 xor     eax, eax
.text$di:000019A6                 mov     [ebp+var_1], al
.text$di:000019A9                 mov     esp, ebp
.text$di:000019AB                 pop     ebp
.text$di:000019AC                 retn
.text$di:000019AC ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:000019AC
.text$di:000019AC ; ---------------------------------------------------------------------------
.text$di:000019AD                 align 10h
.text$di:000019AD _text$di        ends
.text$di:000019AD
.text$yd:000019B0 ; ===========================================================================
.text$yd:000019B0
.text$yd:000019B0 ; Segment type: Pure code
.text$yd:000019B0 ; Segment permissions: Read/Execute
.text$yd:000019B0 _text$yd        segment para public 'CODE' use32
.text$yd:000019B0                 assume cs:_text$yd
.text$yd:000019B0                 ;org 19B0h
.text$yd:000019B0 ; COMDAT (pick any)
.text$yd:000019B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000019B0
.text$yd:000019B0 ; =============== S U B R O U T I N E =======================================
.text$yd:000019B0
.text$yd:000019B0 ; Attributes: bp-based frame
.text$yd:000019B0
.text$yd:000019B0 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:000019B0 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:000019B0                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:000019B0                 push    ebp
.text$yd:000019B1                 mov     ebp, esp
.text$yd:000019B3                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:000019B8                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:000019BD                 pop     ebp
.text$yd:000019BE                 retn
.text$yd:000019BE ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:000019BE
.text$yd:000019BE ; ---------------------------------------------------------------------------
.text$yd:000019BF                 align 10h
.text$yd:000019BF _text$yd        ends
.text$yd:000019BF
.text$yd:000019C0 ; ===========================================================================
.text$yd:000019C0
.text$yd:000019C0 ; Segment type: Pure code
.text$yd:000019C0 ; Segment permissions: Read/Execute
.text$yd:000019C0 _text$yd        segment para public 'CODE' use32
.text$yd:000019C0                 assume cs:_text$yd
.text$yd:000019C0                 ;org 19C0h
.text$yd:000019C0 ; COMDAT (pick any)
.text$yd:000019C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000019C0
.text$yd:000019C0 ; =============== S U B R O U T I N E =======================================
.text$yd:000019C0
.text$yd:000019C0 ; Attributes: bp-based frame
.text$yd:000019C0
.text$yd:000019C0 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:000019C0 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:000019C0                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:000019C0                 push    ebp
.text$yd:000019C1                 mov     ebp, esp
.text$yd:000019C3                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:000019C8                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:000019CD                 pop     ebp
.text$yd:000019CE                 retn
.text$yd:000019CE ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:000019CE
.text$yd:000019CE ; ---------------------------------------------------------------------------
.text$yd:000019CF                 align 10h
.text$yd:000019CF _text$yd        ends
.text$yd:000019CF
.text$yd:000019D0 ; ===========================================================================
.text$yd:000019D0
.text$yd:000019D0 ; Segment type: Pure code
.text$yd:000019D0 ; Segment permissions: Read/Execute
.text$yd:000019D0 _text$yd        segment para public 'CODE' use32
.text$yd:000019D0                 assume cs:_text$yd
.text$yd:000019D0                 ;org 19D0h
.text$yd:000019D0 ; COMDAT (pick any)
.text$yd:000019D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:000019D0
.text$yd:000019D0 ; =============== S U B R O U T I N E =======================================
.text$yd:000019D0
.text$yd:000019D0 ; Attributes: bp-based frame
.text$yd:000019D0
.text$yd:000019D0 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:000019D0 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:000019D0                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:000019D0                 push    ebp
.text$yd:000019D1                 mov     ebp, esp
.text$yd:000019D3                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:000019D8                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:000019DD                 pop     ebp
.text$yd:000019DE                 retn
.text$yd:000019DE ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:000019DE
.text$yd:000019DE ; ---------------------------------------------------------------------------
.text$yd:000019DF                 align 10h
.text$yd:000019DF _text$yd        ends
.text$yd:000019DF
.text$mn:000019E0 ; ===========================================================================
.text$mn:000019E0
.text$mn:000019E0 ; Segment type: Pure code
.text$mn:000019E0 ; Segment permissions: Read/Execute
.text$mn:000019E0 _text$mn        segment para public 'CODE' use32
.text$mn:000019E0                 assume cs:_text$mn
.text$mn:000019E0                 ;org 19E0h
.text$mn:000019E0 ; COMDAT (pick any)
.text$mn:000019E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019E0
.text$mn:000019E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000019E0
.text$mn:000019E0 ; Attributes: bp-based frame
.text$mn:000019E0
.text$mn:000019E0 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000019E0                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000019E0 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000019E0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:000019E0
.text$mn:000019E0 var_10          = byte ptr -10h
.text$mn:000019E0 var_8           = dword ptr -8
.text$mn:000019E0 var_1           = byte ptr -1
.text$mn:000019E0
.text$mn:000019E0                 push    ebp
.text$mn:000019E1                 mov     ebp, esp
.text$mn:000019E3                 sub     esp, 10h
.text$mn:000019E6                 mov     [ebp+var_8], ecx
.text$mn:000019E9                 lea     ecx, [ebp+var_1]
.text$mn:000019EC                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000019F1                 push    1
.text$mn:000019F3                 lea     ecx, [ebp+var_1]
.text$mn:000019F6                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000019FB                 mov     ecx, [ebp+var_8]
.text$mn:000019FE                 mov     [ecx], eax
.text$mn:00001A00                 lea     ecx, [ebp+var_10] ; this
.text$mn:00001A03                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001A08                 push    eax             ; int
.text$mn:00001A09                 mov     edx, [ebp+var_8]
.text$mn:00001A0C                 mov     eax, [edx]
.text$mn:00001A0E                 push    eax             ; void *
.text$mn:00001A0F                 lea     ecx, [ebp+var_1]
.text$mn:00001A12                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001A17                 mov     ecx, [ebp+var_8]
.text$mn:00001A1A                 mov     edx, [ecx]
.text$mn:00001A1C                 mov     eax, [ebp+var_8]
.text$mn:00001A1F                 mov     [edx], eax
.text$mn:00001A21                 mov     esp, ebp
.text$mn:00001A23                 pop     ebp
.text$mn:00001A24                 retn
.text$mn:00001A24 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001A24
.text$mn:00001A24 ; ---------------------------------------------------------------------------
.text$mn:00001A25                 align 4
.text$mn:00001A25 _text$mn        ends
.text$mn:00001A25
.text$mn:00001A28 ; ===========================================================================
.text$mn:00001A28
.text$mn:00001A28 ; Segment type: Pure code
.text$mn:00001A28 ; Segment permissions: Read/Execute
.text$mn:00001A28 _text$mn        segment para public 'CODE' use32
.text$mn:00001A28                 assume cs:_text$mn
.text$mn:00001A28                 ;org 1A28h
.text$mn:00001A28 ; COMDAT (pick any)
.text$mn:00001A28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A28
.text$mn:00001A28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A28
.text$mn:00001A28 ; Attributes: bp-based frame
.text$mn:00001A28
.text$mn:00001A28 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00001A28                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00001A28 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001A28                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:00001A28
.text$mn:00001A28 var_10          = byte ptr -10h
.text$mn:00001A28 var_8           = dword ptr -8
.text$mn:00001A28 var_1           = byte ptr -1
.text$mn:00001A28
.text$mn:00001A28                 push    ebp
.text$mn:00001A29                 mov     ebp, esp
.text$mn:00001A2B                 sub     esp, 10h
.text$mn:00001A2E                 mov     [ebp+var_8], ecx
.text$mn:00001A31                 lea     ecx, [ebp+var_1]
.text$mn:00001A34                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001A39                 push    1
.text$mn:00001A3B                 lea     ecx, [ebp+var_1]
.text$mn:00001A3E                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00001A43                 mov     ecx, [ebp+var_8]
.text$mn:00001A46                 mov     [ecx], eax
.text$mn:00001A48                 lea     ecx, [ebp+var_10] ; this
.text$mn:00001A4B                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001A50                 push    eax             ; int
.text$mn:00001A51                 mov     edx, [ebp+var_8]
.text$mn:00001A54                 mov     eax, [edx]
.text$mn:00001A56                 push    eax             ; void *
.text$mn:00001A57                 lea     ecx, [ebp+var_1]
.text$mn:00001A5A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001A5F                 mov     ecx, [ebp+var_8]
.text$mn:00001A62                 mov     edx, [ecx]
.text$mn:00001A64                 mov     eax, [ebp+var_8]
.text$mn:00001A67                 mov     [edx], eax
.text$mn:00001A69                 mov     esp, ebp
.text$mn:00001A6B                 pop     ebp
.text$mn:00001A6C                 retn
.text$mn:00001A6C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001A6C
.text$mn:00001A6C ; ---------------------------------------------------------------------------
.text$mn:00001A6D                 align 10h
.text$mn:00001A6D _text$mn        ends
.text$mn:00001A6D
.text$mn:00001A70 ; ===========================================================================
.text$mn:00001A70
.text$mn:00001A70 ; Segment type: Pure code
.text$mn:00001A70 ; Segment permissions: Read/Execute
.text$mn:00001A70 _text$mn        segment para public 'CODE' use32
.text$mn:00001A70                 assume cs:_text$mn
.text$mn:00001A70                 ;org 1A70h
.text$mn:00001A70 ; COMDAT (pick any)
.text$mn:00001A70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A70
.text$mn:00001A70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A70
.text$mn:00001A70 ; Attributes: bp-based frame
.text$mn:00001A70
.text$mn:00001A70 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00001A70                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001A70 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00001A70                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00001A70
.text$mn:00001A70 var_20          = dword ptr -20h
.text$mn:00001A70 var_1C          = dword ptr -1Ch
.text$mn:00001A70 var_18          = dword ptr -18h
.text$mn:00001A70 var_11          = byte ptr -11h
.text$mn:00001A70 var_10          = dword ptr -10h
.text$mn:00001A70 var_C           = byte ptr -0Ch
.text$mn:00001A70 var_4           = dword ptr -4
.text$mn:00001A70 arg_0           = dword ptr  8
.text$mn:00001A70
.text$mn:00001A70 ; FUNCTION CHUNK AT .text$mn:00001B92 SIZE 00000009 BYTES
.text$mn:00001A70
.text$mn:00001A70                 push    ebp
.text$mn:00001A71                 mov     ebp, esp
.text$mn:00001A73                 push    0FFFFFFFFh
.text$mn:00001A75                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001A7A                 mov     eax, large fs:0
.text$mn:00001A80                 push    eax
.text$mn:00001A81                 push    ecx
.text$mn:00001A82                 sub     esp, 10h
.text$mn:00001A85                 push    ebx
.text$mn:00001A86                 push    esi
.text$mn:00001A87                 push    edi
.text$mn:00001A88                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A8D                 xor     eax, ebp
.text$mn:00001A8F                 push    eax
.text$mn:00001A90                 lea     eax, [ebp+var_C]
.text$mn:00001A93                 mov     large fs:0, eax
.text$mn:00001A99                 mov     [ebp+var_10], esp
.text$mn:00001A9C                 mov     [ebp+var_18], ecx
.text$mn:00001A9F                 mov     eax, [ebp+arg_0]
.text$mn:00001AA2                 or      eax, 0Fh
.text$mn:00001AA5                 mov     [ebp+var_1C], eax
.text$mn:00001AA8                 mov     ecx, [ebp+var_18]
.text$mn:00001AAB                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001AB0                 cmp     eax, [ebp+var_1C]
.text$mn:00001AB3                 jnb     short loc_1ABD
.text$mn:00001AB5                 mov     ecx, [ebp+arg_0]
.text$mn:00001AB8                 mov     [ebp+var_1C], ecx
.text$mn:00001ABB                 jmp     short loc_1B0F
.text$mn:00001ABD ; ---------------------------------------------------------------------------
.text$mn:00001ABD
.text$mn:00001ABD loc_1ABD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00001ABD                 mov     edx, [ebp+var_18]
.text$mn:00001AC0                 mov     ecx, [edx+18h]
.text$mn:00001AC3                 shr     ecx, 1
.text$mn:00001AC5                 mov     eax, [ebp+var_1C]
.text$mn:00001AC8                 xor     edx, edx
.text$mn:00001ACA                 mov     esi, 3
.text$mn:00001ACF                 div     esi
.text$mn:00001AD1                 cmp     ecx, eax
.text$mn:00001AD3                 ja      short loc_1AD7
.text$mn:00001AD5                 jmp     short loc_1B0F
.text$mn:00001AD7 ; ---------------------------------------------------------------------------
.text$mn:00001AD7
.text$mn:00001AD7 loc_1AD7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00001AD7                 mov     ecx, [ebp+var_18]
.text$mn:00001ADA                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001ADF                 mov     edx, [ebp+var_18]
.text$mn:00001AE2                 mov     ecx, [edx+18h]
.text$mn:00001AE5                 shr     ecx, 1
.text$mn:00001AE7                 sub     eax, ecx
.text$mn:00001AE9                 mov     edx, [ebp+var_18]
.text$mn:00001AEC                 cmp     [edx+18h], eax
.text$mn:00001AEF                 ja      short loc_1B04
.text$mn:00001AF1                 mov     eax, [ebp+var_18]
.text$mn:00001AF4                 mov     ecx, [eax+18h]
.text$mn:00001AF7                 shr     ecx, 1
.text$mn:00001AF9                 mov     edx, [ebp+var_18]
.text$mn:00001AFC                 add     ecx, [edx+18h]
.text$mn:00001AFF                 mov     [ebp+var_1C], ecx
.text$mn:00001B02                 jmp     short loc_1B0F
.text$mn:00001B04 ; ---------------------------------------------------------------------------
.text$mn:00001B04
.text$mn:00001B04 loc_1B04:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00001B04                 mov     ecx, [ebp+var_18]
.text$mn:00001B07                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001B0C                 mov     [ebp+var_1C], eax
.text$mn:00001B0F
.text$mn:00001B0F loc_1B0F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00001B0F                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00001B0F                 mov     [ebp+var_4], 0
.text$mn:00001B16                 mov     eax, [ebp+var_1C]
.text$mn:00001B19                 add     eax, 1
.text$mn:00001B1C                 push    eax
.text$mn:00001B1D                 lea     ecx, [ebp+var_11]
.text$mn:00001B20                 push    ecx
.text$mn:00001B21                 mov     ecx, [ebp+var_18]
.text$mn:00001B24                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001B29                 mov     ecx, eax
.text$mn:00001B2B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001B30                 mov     [ebp+var_20], eax
.text$mn:00001B33                 jmp     short loc_1B92
.text$mn:00001B33 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00001B33
.text$mn:00001B35
.text$mn:00001B35 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B35
.text$mn:00001B35
.text$mn:00001B35 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001B35                                         ; DATA XREF: .xdata$x:00003380o
.text$mn:00001B35
.text$mn:00001B35 ; FUNCTION CHUNK AT .text$mn:00001B7C SIZE 00000009 BYTES
.text$mn:00001B35 ; FUNCTION CHUNK AT .text$mn:00001B8C SIZE 00000006 BYTES
.text$mn:00001B35
.text$mn:00001B35                 mov     [ebp-10h], esp
.text$mn:00001B38                 mov     edx, [ebp+8]
.text$mn:00001B3B                 mov     [ebp-1Ch], edx
.text$mn:00001B3E                 mov     byte ptr [ebp-4], 2
.text$mn:00001B42                 mov     eax, [ebp-1Ch]
.text$mn:00001B45                 add     eax, 1
.text$mn:00001B48                 push    eax
.text$mn:00001B49                 lea     ecx, [ebp-12h]
.text$mn:00001B4C                 push    ecx
.text$mn:00001B4D                 mov     ecx, [ebp-18h]
.text$mn:00001B50                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001B55                 mov     ecx, eax
.text$mn:00001B57                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00001B5C                 mov     [ebp-20h], eax
.text$mn:00001B5F                 jmp     short loc_1B7C
.text$mn:00001B5F __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00001B5F
.text$mn:00001B61
.text$mn:00001B61 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B61
.text$mn:00001B61 ; Attributes: noreturn
.text$mn:00001B61
.text$mn:00001B61 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001B61                                         ; DATA XREF: .xdata$x:00003390o
.text$mn:00001B61                 push    0               ; Size
.text$mn:00001B63                 push    1               ; char
.text$mn:00001B65                 mov     ecx, [ebp-18h]
.text$mn:00001B68                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001B6D                 push    0
.text$mn:00001B6F                 push    0
.text$mn:00001B71                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001B71 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00001B71
.text$mn:00001B76 ; ---------------------------------------------------------------------------
.text$mn:00001B76                 mov     eax, offset $LN17
.text$mn:00001B7B                 retn
.text$mn:00001B7C ; ---------------------------------------------------------------------------
.text$mn:00001B7C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001B7C
.text$mn:00001B7C loc_1B7C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00001B7C                 mov     dword ptr [ebp-4], 1
.text$mn:00001B83                 jmp     short loc_1B8C
.text$mn:00001B83 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001B85
.text$mn:00001B85 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B85
.text$mn:00001B85
.text$mn:00001B85 $LN17           proc near               ; DATA XREF: .text$mn:00001B76o
.text$mn:00001B85                 mov     dword ptr [ebp-4], 1
.text$mn:00001B85 $LN17           endp ; sp-analysis failed
.text$mn:00001B85
.text$mn:00001B8C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001B8C
.text$mn:00001B8C loc_1B8C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00001B8C                 mov     eax, offset $LN19
.text$mn:00001B91                 retn
.text$mn:00001B91 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00001B92 ; ---------------------------------------------------------------------------
.text$mn:00001B92 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001B92
.text$mn:00001B92 loc_1B92:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00001B92                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001B99                 jmp     short loc_1BA2
.text$mn:00001B99 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001B9B
.text$mn:00001B9B ; =============== S U B R O U T I N E =======================================
.text$mn:00001B9B
.text$mn:00001B9B
.text$mn:00001B9B $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_1B8Co
.text$mn:00001B9B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001BA2
.text$mn:00001BA2 loc_1BA2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00001BA2                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00001BA6                 jbe     short loc_1BC1
.text$mn:00001BA8                 mov     edx, [ebp+0Ch]
.text$mn:00001BAB                 push    edx             ; Size
.text$mn:00001BAC                 mov     ecx, [ebp-18h]
.text$mn:00001BAF                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001BB4                 push    eax             ; Src
.text$mn:00001BB5                 mov     eax, [ebp-20h]
.text$mn:00001BB8                 push    eax             ; Dst
.text$mn:00001BB9                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00001BBE                 add     esp, 0Ch
.text$mn:00001BC1
.text$mn:00001BC1 loc_1BC1:                               ; CODE XREF: $LN19+Bj
.text$mn:00001BC1                 push    0               ; Size
.text$mn:00001BC3                 push    1               ; char
.text$mn:00001BC5                 mov     ecx, [ebp-18h]
.text$mn:00001BC8                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001BCD                 lea     ecx, [ebp-20h]
.text$mn:00001BD0                 push    ecx             ; int
.text$mn:00001BD1                 mov     edx, [ebp-18h]
.text$mn:00001BD4                 add     edx, 4
.text$mn:00001BD7                 push    edx             ; void *
.text$mn:00001BD8                 lea     eax, [ebp-13h]
.text$mn:00001BDB                 push    eax
.text$mn:00001BDC                 mov     ecx, [ebp-18h]
.text$mn:00001BDF                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00001BE4                 mov     ecx, eax
.text$mn:00001BE6                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001BEB                 mov     ecx, [ebp-18h]
.text$mn:00001BEE                 mov     edx, [ebp-1Ch]
.text$mn:00001BF1                 mov     [ecx+18h], edx
.text$mn:00001BF4                 mov     eax, [ebp+0Ch]
.text$mn:00001BF7                 push    eax
.text$mn:00001BF8                 mov     ecx, [ebp-18h]
.text$mn:00001BFB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001C00                 mov     ecx, [ebp-0Ch]
.text$mn:00001C03                 mov     large fs:0, ecx
.text$mn:00001C0A                 pop     ecx
.text$mn:00001C0B                 pop     edi
.text$mn:00001C0C                 pop     esi
.text$mn:00001C0D                 pop     ebx
.text$mn:00001C0E                 mov     esp, ebp
.text$mn:00001C10                 pop     ebp
.text$mn:00001C11                 retn    8
.text$mn:00001C11 $LN19           endp ; sp-analysis failed
.text$mn:00001C11
.text$mn:00001C11 _text$mn        ends
.text$mn:00001C11
.text$x:00001C14 ; ===========================================================================
.text$x:00001C14
.text$x:00001C14 ; Segment type: Pure code
.text$x:00001C14 ; Segment permissions: Read/Execute
.text$x:00001C14 _text$x         segment para public 'CODE' use32
.text$x:00001C14                 assume cs:_text$x
.text$x:00001C14                 ;org 1C14h
.text$x:00001C14 ; COMDAT (pick associative to section at 1A70)
.text$x:00001C14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001C14
.text$x:00001C14 ; =============== S U B R O U T I N E =======================================
.text$x:00001C14
.text$x:00001C14
.text$x:00001C14 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00001C14                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00001C14
.text$x:00001C14 arg_4           = dword ptr  8
.text$x:00001C14
.text$x:00001C14                 mov     edx, [esp+arg_4]
.text$x:00001C18                 lea     eax, [edx+0Ch]
.text$x:00001C1B                 mov     ecx, [edx-24h]
.text$x:00001C1E                 xor     ecx, eax
.text$x:00001C20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C25                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00001C2A                 jmp     ___CxxFrameHandler3
.text$x:00001C2A __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00001C2A
.text$x:00001C2A ; ---------------------------------------------------------------------------
.text$x:00001C2F                 align 10h
.text$x:00001C2F _text$x         ends
.text$x:00001C2F
.text$mn:00001C30 ; ===========================================================================
.text$mn:00001C30
.text$mn:00001C30 ; Segment type: Pure code
.text$mn:00001C30 ; Segment permissions: Read/Execute
.text$mn:00001C30 _text$mn        segment para public 'CODE' use32
.text$mn:00001C30                 assume cs:_text$mn
.text$mn:00001C30                 ;org 1C30h
.text$mn:00001C30 ; COMDAT (pick any)
.text$mn:00001C30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C30
.text$mn:00001C30 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C30
.text$mn:00001C30 ; Attributes: bp-based frame
.text$mn:00001C30
.text$mn:00001C30 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:00001C30                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00001C30 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:00001C30                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:00001C30
.text$mn:00001C30 var_20          = dword ptr -20h
.text$mn:00001C30 var_1C          = dword ptr -1Ch
.text$mn:00001C30 var_18          = dword ptr -18h
.text$mn:00001C30 var_11          = byte ptr -11h
.text$mn:00001C30 var_10          = dword ptr -10h
.text$mn:00001C30 var_C           = byte ptr -0Ch
.text$mn:00001C30 var_4           = dword ptr -4
.text$mn:00001C30 arg_0           = dword ptr  8
.text$mn:00001C30
.text$mn:00001C30 ; FUNCTION CHUNK AT .text$mn:00001D52 SIZE 00000009 BYTES
.text$mn:00001C30
.text$mn:00001C30                 push    ebp
.text$mn:00001C31                 mov     ebp, esp
.text$mn:00001C33                 push    0FFFFFFFFh
.text$mn:00001C35                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00001C3A                 mov     eax, large fs:0
.text$mn:00001C40                 push    eax
.text$mn:00001C41                 push    ecx
.text$mn:00001C42                 sub     esp, 10h
.text$mn:00001C45                 push    ebx
.text$mn:00001C46                 push    esi
.text$mn:00001C47                 push    edi
.text$mn:00001C48                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001C4D                 xor     eax, ebp
.text$mn:00001C4F                 push    eax
.text$mn:00001C50                 lea     eax, [ebp+var_C]
.text$mn:00001C53                 mov     large fs:0, eax
.text$mn:00001C59                 mov     [ebp+var_10], esp
.text$mn:00001C5C                 mov     [ebp+var_18], ecx
.text$mn:00001C5F                 mov     eax, [ebp+arg_0]
.text$mn:00001C62                 or      eax, 7
.text$mn:00001C65                 mov     [ebp+var_1C], eax
.text$mn:00001C68                 mov     ecx, [ebp+var_18]
.text$mn:00001C6B                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00001C70                 cmp     eax, [ebp+var_1C]
.text$mn:00001C73                 jnb     short loc_1C7D
.text$mn:00001C75                 mov     ecx, [ebp+arg_0]
.text$mn:00001C78                 mov     [ebp+var_1C], ecx
.text$mn:00001C7B                 jmp     short loc_1CCF
.text$mn:00001C7D ; ---------------------------------------------------------------------------
.text$mn:00001C7D
.text$mn:00001C7D loc_1C7D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:00001C7D                 mov     edx, [ebp+var_18]
.text$mn:00001C80                 mov     ecx, [edx+18h]
.text$mn:00001C83                 shr     ecx, 1
.text$mn:00001C85                 mov     eax, [ebp+var_1C]
.text$mn:00001C88                 xor     edx, edx
.text$mn:00001C8A                 mov     esi, 3
.text$mn:00001C8F                 div     esi
.text$mn:00001C91                 cmp     ecx, eax
.text$mn:00001C93                 ja      short loc_1C97
.text$mn:00001C95                 jmp     short loc_1CCF
.text$mn:00001C97 ; ---------------------------------------------------------------------------
.text$mn:00001C97
.text$mn:00001C97 loc_1C97:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:00001C97                 mov     ecx, [ebp+var_18]
.text$mn:00001C9A                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00001C9F                 mov     edx, [ebp+var_18]
.text$mn:00001CA2                 mov     ecx, [edx+18h]
.text$mn:00001CA5                 shr     ecx, 1
.text$mn:00001CA7                 sub     eax, ecx
.text$mn:00001CA9                 mov     edx, [ebp+var_18]
.text$mn:00001CAC                 cmp     [edx+18h], eax
.text$mn:00001CAF                 ja      short loc_1CC4
.text$mn:00001CB1                 mov     eax, [ebp+var_18]
.text$mn:00001CB4                 mov     ecx, [eax+18h]
.text$mn:00001CB7                 shr     ecx, 1
.text$mn:00001CB9                 mov     edx, [ebp+var_18]
.text$mn:00001CBC                 add     ecx, [edx+18h]
.text$mn:00001CBF                 mov     [ebp+var_1C], ecx
.text$mn:00001CC2                 jmp     short loc_1CCF
.text$mn:00001CC4 ; ---------------------------------------------------------------------------
.text$mn:00001CC4
.text$mn:00001CC4 loc_1CC4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:00001CC4                 mov     ecx, [ebp+var_18]
.text$mn:00001CC7                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00001CCC                 mov     [ebp+var_1C], eax
.text$mn:00001CCF
.text$mn:00001CCF loc_1CCF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:00001CCF                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:00001CCF                 mov     [ebp+var_4], 0
.text$mn:00001CD6                 mov     eax, [ebp+var_1C]
.text$mn:00001CD9                 add     eax, 1
.text$mn:00001CDC                 push    eax
.text$mn:00001CDD                 lea     ecx, [ebp+var_11]
.text$mn:00001CE0                 push    ecx
.text$mn:00001CE1                 mov     ecx, [ebp+var_18]
.text$mn:00001CE4                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001CE9                 mov     ecx, eax
.text$mn:00001CEB                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00001CF0                 mov     [ebp+var_20], eax
.text$mn:00001CF3                 jmp     short loc_1D52
.text$mn:00001CF3 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:00001CF3
.text$mn:00001CF5
.text$mn:00001CF5 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CF5
.text$mn:00001CF5
.text$mn:00001CF5 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:00001CF5                                         ; DATA XREF: .xdata$x:000036A0o
.text$mn:00001CF5
.text$mn:00001CF5 ; FUNCTION CHUNK AT .text$mn:00001D3C SIZE 00000009 BYTES
.text$mn:00001CF5 ; FUNCTION CHUNK AT .text$mn:00001D4C SIZE 00000006 BYTES
.text$mn:00001CF5
.text$mn:00001CF5                 mov     [ebp-10h], esp
.text$mn:00001CF8                 mov     edx, [ebp+8]
.text$mn:00001CFB                 mov     [ebp-1Ch], edx
.text$mn:00001CFE                 mov     byte ptr [ebp-4], 2
.text$mn:00001D02                 mov     eax, [ebp-1Ch]
.text$mn:00001D05                 add     eax, 1
.text$mn:00001D08                 push    eax
.text$mn:00001D09                 lea     ecx, [ebp-12h]
.text$mn:00001D0C                 push    ecx
.text$mn:00001D0D                 mov     ecx, [ebp-18h]
.text$mn:00001D10                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001D15                 mov     ecx, eax
.text$mn:00001D17                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00001D1C                 mov     [ebp-20h], eax
.text$mn:00001D1F                 jmp     short loc_1D3C
.text$mn:00001D1F __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:00001D1F
.text$mn:00001D21
.text$mn:00001D21 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D21
.text$mn:00001D21 ; Attributes: noreturn
.text$mn:00001D21
.text$mn:00001D21 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:00001D21                                         ; DATA XREF: .xdata$x:000036B0o
.text$mn:00001D21                 push    0
.text$mn:00001D23                 push    1
.text$mn:00001D25                 mov     ecx, [ebp-18h]
.text$mn:00001D28                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00001D2D                 push    0
.text$mn:00001D2F                 push    0
.text$mn:00001D31                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00001D31 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:00001D31
.text$mn:00001D36 ; ---------------------------------------------------------------------------
.text$mn:00001D36                 mov     eax, offset $LN17_0
.text$mn:00001D3B                 retn
.text$mn:00001D3C ; ---------------------------------------------------------------------------
.text$mn:00001D3C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00001D3C
.text$mn:00001D3C loc_1D3C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00001D3C                 mov     dword ptr [ebp-4], 1
.text$mn:00001D43                 jmp     short loc_1D4C
.text$mn:00001D43 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00001D45
.text$mn:00001D45 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D45
.text$mn:00001D45
.text$mn:00001D45 $LN17_0         proc near               ; DATA XREF: .text$mn:00001D36o
.text$mn:00001D45                 mov     dword ptr [ebp-4], 1
.text$mn:00001D45 $LN17_0         endp ; sp-analysis failed
.text$mn:00001D45
.text$mn:00001D4C ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00001D4C
.text$mn:00001D4C loc_1D4C:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00001D4C                 mov     eax, offset $LN19_0
.text$mn:00001D51                 retn
.text$mn:00001D51 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00001D52 ; ---------------------------------------------------------------------------
.text$mn:00001D52 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00001D52
.text$mn:00001D52 loc_1D52:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:00001D52                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001D59                 jmp     short loc_1D62
.text$mn:00001D59 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00001D5B
.text$mn:00001D5B ; =============== S U B R O U T I N E =======================================
.text$mn:00001D5B
.text$mn:00001D5B
.text$mn:00001D5B $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_1D4Co
.text$mn:00001D5B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00001D62
.text$mn:00001D62 loc_1D62:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:00001D62                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00001D66                 jbe     short loc_1D81
.text$mn:00001D68                 mov     edx, [ebp+0Ch]
.text$mn:00001D6B                 push    edx             ; int
.text$mn:00001D6C                 mov     ecx, [ebp-18h]
.text$mn:00001D6F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001D74                 push    eax             ; Src
.text$mn:00001D75                 mov     eax, [ebp-20h]
.text$mn:00001D78                 push    eax             ; Dst
.text$mn:00001D79                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00001D7E                 add     esp, 0Ch
.text$mn:00001D81
.text$mn:00001D81 loc_1D81:                               ; CODE XREF: $LN19_0+Bj
.text$mn:00001D81                 push    0
.text$mn:00001D83                 push    1
.text$mn:00001D85                 mov     ecx, [ebp-18h]
.text$mn:00001D88                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00001D8D                 lea     ecx, [ebp-20h]
.text$mn:00001D90                 push    ecx             ; int
.text$mn:00001D91                 mov     edx, [ebp-18h]
.text$mn:00001D94                 add     edx, 4
.text$mn:00001D97                 push    edx             ; void *
.text$mn:00001D98                 lea     eax, [ebp-13h]
.text$mn:00001D9B                 push    eax
.text$mn:00001D9C                 mov     ecx, [ebp-18h]
.text$mn:00001D9F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00001DA4                 mov     ecx, eax
.text$mn:00001DA6                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00001DAB                 mov     ecx, [ebp-18h]
.text$mn:00001DAE                 mov     edx, [ebp-1Ch]
.text$mn:00001DB1                 mov     [ecx+18h], edx
.text$mn:00001DB4                 mov     eax, [ebp+0Ch]
.text$mn:00001DB7                 push    eax
.text$mn:00001DB8                 mov     ecx, [ebp-18h]
.text$mn:00001DBB                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00001DC0                 mov     ecx, [ebp-0Ch]
.text$mn:00001DC3                 mov     large fs:0, ecx
.text$mn:00001DCA                 pop     ecx
.text$mn:00001DCB                 pop     edi
.text$mn:00001DCC                 pop     esi
.text$mn:00001DCD                 pop     ebx
.text$mn:00001DCE                 mov     esp, ebp
.text$mn:00001DD0                 pop     ebp
.text$mn:00001DD1                 retn    8
.text$mn:00001DD1 $LN19_0         endp ; sp-analysis failed
.text$mn:00001DD1
.text$mn:00001DD1 _text$mn        ends
.text$mn:00001DD1
.text$x:00001DD4 ; ===========================================================================
.text$x:00001DD4
.text$x:00001DD4 ; Segment type: Pure code
.text$x:00001DD4 ; Segment permissions: Read/Execute
.text$x:00001DD4 _text$x         segment para public 'CODE' use32
.text$x:00001DD4                 assume cs:_text$x
.text$x:00001DD4                 ;org 1DD4h
.text$x:00001DD4 ; COMDAT (pick associative to section at 1C30)
.text$x:00001DD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001DD4
.text$x:00001DD4 ; =============== S U B R O U T I N E =======================================
.text$x:00001DD4
.text$x:00001DD4
.text$x:00001DD4 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:00001DD4                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:00001DD4
.text$x:00001DD4 arg_4           = dword ptr  8
.text$x:00001DD4
.text$x:00001DD4                 mov     edx, [esp+arg_4]
.text$x:00001DD8                 lea     eax, [edx+0Ch]
.text$x:00001DDB                 mov     ecx, [edx-24h]
.text$x:00001DDE                 xor     ecx, eax
.text$x:00001DE0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001DE5                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:00001DEA                 jmp     ___CxxFrameHandler3
.text$x:00001DEA __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:00001DEA
.text$x:00001DEA ; ---------------------------------------------------------------------------
.text$x:00001DEF                 align 10h
.text$x:00001DEF _text$x         ends
.text$x:00001DEF
.text$mn:00001DF0 ; ===========================================================================
.text$mn:00001DF0
.text$mn:00001DF0 ; Segment type: Pure code
.text$mn:00001DF0 ; Segment permissions: Read/Execute
.text$mn:00001DF0 _text$mn        segment para public 'CODE' use32
.text$mn:00001DF0                 assume cs:_text$mn
.text$mn:00001DF0                 ;org 1DF0h
.text$mn:00001DF0 ; COMDAT (pick any)
.text$mn:00001DF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DF0
.text$mn:00001DF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DF0
.text$mn:00001DF0 ; Attributes: bp-based frame
.text$mn:00001DF0
.text$mn:00001DF0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00001DF0                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00001DF0 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00001DF0                                         ; CODE XREF: $LN19+60p
.text$mn:00001DF0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00001DF0
.text$mn:00001DF0 var_8           = dword ptr -8
.text$mn:00001DF0 var_1           = byte ptr -1
.text$mn:00001DF0 arg_0           = dword ptr  8
.text$mn:00001DF0
.text$mn:00001DF0                 push    ebp
.text$mn:00001DF1                 mov     ebp, esp
.text$mn:00001DF3                 sub     esp, 8
.text$mn:00001DF6                 mov     [ebp+var_8], ecx
.text$mn:00001DF9                 mov     [ebp+var_1], 0
.text$mn:00001DFD                 mov     eax, [ebp+var_8]
.text$mn:00001E00                 mov     ecx, [ebp+arg_0]
.text$mn:00001E03                 mov     [eax+14h], ecx
.text$mn:00001E06                 lea     edx, [ebp+var_1]
.text$mn:00001E09                 push    edx
.text$mn:00001E0A                 mov     ecx, [ebp+var_8]
.text$mn:00001E0D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00001E12                 add     eax, [ebp+arg_0]
.text$mn:00001E15                 push    eax
.text$mn:00001E16                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00001E1B                 add     esp, 8
.text$mn:00001E1E                 mov     esp, ebp
.text$mn:00001E20                 pop     ebp
.text$mn:00001E21                 retn    4
.text$mn:00001E21 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00001E21
.text$mn:00001E21 _text$mn        ends
.text$mn:00001E21
.text$mn:00001E24 ; ===========================================================================
.text$mn:00001E24
.text$mn:00001E24 ; Segment type: Pure code
.text$mn:00001E24 ; Segment permissions: Read/Execute
.text$mn:00001E24 _text$mn        segment para public 'CODE' use32
.text$mn:00001E24                 assume cs:_text$mn
.text$mn:00001E24                 ;org 1E24h
.text$mn:00001E24 ; COMDAT (pick any)
.text$mn:00001E24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E24
.text$mn:00001E24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E24
.text$mn:00001E24 ; Attributes: bp-based frame
.text$mn:00001E24
.text$mn:00001E24 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:00001E24                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00001E24 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00001E24                                         ; CODE XREF: $LN19_0+60p
.text$mn:00001E24                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:00001E24
.text$mn:00001E24 var_8           = dword ptr -8
.text$mn:00001E24 var_2           = word ptr -2
.text$mn:00001E24 arg_0           = dword ptr  8
.text$mn:00001E24
.text$mn:00001E24                 push    ebp
.text$mn:00001E25                 mov     ebp, esp
.text$mn:00001E27                 sub     esp, 8
.text$mn:00001E2A                 mov     [ebp+var_8], ecx
.text$mn:00001E2D                 xor     eax, eax
.text$mn:00001E2F                 mov     [ebp+var_2], ax
.text$mn:00001E33                 mov     ecx, [ebp+var_8]
.text$mn:00001E36                 mov     edx, [ebp+arg_0]
.text$mn:00001E39                 mov     [ecx+14h], edx
.text$mn:00001E3C                 lea     eax, [ebp+var_2]
.text$mn:00001E3F                 push    eax
.text$mn:00001E40                 mov     ecx, [ebp+var_8]
.text$mn:00001E43                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00001E48                 mov     ecx, [ebp+arg_0]
.text$mn:00001E4B                 lea     edx, [eax+ecx*2]
.text$mn:00001E4E                 push    edx
.text$mn:00001E4F                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:00001E54                 add     esp, 8
.text$mn:00001E57                 mov     esp, ebp
.text$mn:00001E59                 pop     ebp
.text$mn:00001E5A                 retn    4
.text$mn:00001E5A ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:00001E5A
.text$mn:00001E5A ; ---------------------------------------------------------------------------
.text$mn:00001E5D                 align 10h
.text$mn:00001E5D _text$mn        ends
.text$mn:00001E5D
.text$mn:00001E60 ; ===========================================================================
.text$mn:00001E60
.text$mn:00001E60 ; Segment type: Pure code
.text$mn:00001E60 ; Segment permissions: Read/Execute
.text$mn:00001E60 _text$mn        segment para public 'CODE' use32
.text$mn:00001E60                 assume cs:_text$mn
.text$mn:00001E60                 ;org 1E60h
.text$mn:00001E60 ; COMDAT (pick any)
.text$mn:00001E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E60
.text$mn:00001E60 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E60
.text$mn:00001E60 ; Attributes: bp-based frame
.text$mn:00001E60
.text$mn:00001E60 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001E60                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001E60 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001E60                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00001E60
.text$mn:00001E60 var_8           = dword ptr -8
.text$mn:00001E60 var_1           = byte ptr -1
.text$mn:00001E60
.text$mn:00001E60                 push    ebp
.text$mn:00001E61                 mov     ebp, esp
.text$mn:00001E63                 sub     esp, 8
.text$mn:00001E66                 mov     [ebp+var_8], ecx
.text$mn:00001E69                 lea     ecx, [ebp+var_1]
.text$mn:00001E6C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001E71                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001E74                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001E79                 mov     eax, [ebp+var_8]
.text$mn:00001E7C                 mov     ecx, [eax]
.text$mn:00001E7E                 push    ecx
.text$mn:00001E7F                 lea     ecx, [ebp+var_1]
.text$mn:00001E82                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00001E87                 push    1               ; int
.text$mn:00001E89                 mov     edx, [ebp+var_8]
.text$mn:00001E8C                 mov     eax, [edx]
.text$mn:00001E8E                 push    eax             ; void *
.text$mn:00001E8F                 lea     ecx, [ebp+var_1]
.text$mn:00001E92                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00001E97                 mov     ecx, [ebp+var_8]
.text$mn:00001E9A                 mov     dword ptr [ecx], 0
.text$mn:00001EA0                 mov     esp, ebp
.text$mn:00001EA2                 pop     ebp
.text$mn:00001EA3                 retn
.text$mn:00001EA3 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001EA3
.text$mn:00001EA3 _text$mn        ends
.text$mn:00001EA3
.text$mn:00001EA4 ; ===========================================================================
.text$mn:00001EA4
.text$mn:00001EA4 ; Segment type: Pure code
.text$mn:00001EA4 ; Segment permissions: Read/Execute
.text$mn:00001EA4 _text$mn        segment para public 'CODE' use32
.text$mn:00001EA4                 assume cs:_text$mn
.text$mn:00001EA4                 ;org 1EA4h
.text$mn:00001EA4 ; COMDAT (pick any)
.text$mn:00001EA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EA4
.text$mn:00001EA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EA4
.text$mn:00001EA4 ; Attributes: bp-based frame
.text$mn:00001EA4
.text$mn:00001EA4 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00001EA4                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00001EA4 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001EA4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00001EA4
.text$mn:00001EA4 var_8           = dword ptr -8
.text$mn:00001EA4 var_1           = byte ptr -1
.text$mn:00001EA4
.text$mn:00001EA4                 push    ebp
.text$mn:00001EA5                 mov     ebp, esp
.text$mn:00001EA7                 sub     esp, 8
.text$mn:00001EAA                 mov     [ebp+var_8], ecx
.text$mn:00001EAD                 lea     ecx, [ebp+var_1]
.text$mn:00001EB0                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001EB5                 mov     ecx, [ebp+var_8] ; this
.text$mn:00001EB8                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001EBD                 mov     eax, [ebp+var_8]
.text$mn:00001EC0                 mov     ecx, [eax]
.text$mn:00001EC2                 push    ecx
.text$mn:00001EC3                 lea     ecx, [ebp+var_1]
.text$mn:00001EC6                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00001ECB                 push    1               ; int
.text$mn:00001ECD                 mov     edx, [ebp+var_8]
.text$mn:00001ED0                 mov     eax, [edx]
.text$mn:00001ED2                 push    eax             ; void *
.text$mn:00001ED3                 lea     ecx, [ebp+var_1]
.text$mn:00001ED6                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00001EDB                 mov     ecx, [ebp+var_8]
.text$mn:00001EDE                 mov     dword ptr [ecx], 0
.text$mn:00001EE4                 mov     esp, ebp
.text$mn:00001EE6                 pop     ebp
.text$mn:00001EE7                 retn
.text$mn:00001EE7 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001EE7
.text$mn:00001EE7 _text$mn        ends
.text$mn:00001EE7
.text$mn:00001EE8 ; ===========================================================================
.text$mn:00001EE8
.text$mn:00001EE8 ; Segment type: Pure code
.text$mn:00001EE8 ; Segment permissions: Read/Execute
.text$mn:00001EE8 _text$mn        segment para public 'CODE' use32
.text$mn:00001EE8                 assume cs:_text$mn
.text$mn:00001EE8                 ;org 1EE8h
.text$mn:00001EE8 ; COMDAT (pick any)
.text$mn:00001EE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EE8
.text$mn:00001EE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EE8
.text$mn:00001EE8 ; Attributes: bp-based frame
.text$mn:00001EE8
.text$mn:00001EE8 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00001EE8                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00001EE8 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00001EE8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00001EE8                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00001EE8
.text$mn:00001EE8 var_4           = dword ptr -4
.text$mn:00001EE8 arg_0           = dword ptr  8
.text$mn:00001EE8
.text$mn:00001EE8                 push    ebp
.text$mn:00001EE9                 mov     ebp, esp
.text$mn:00001EEB                 push    ecx
.text$mn:00001EEC                 mov     [ebp+var_4], ecx
.text$mn:00001EEF                 mov     ecx, [ebp+arg_0]
.text$mn:00001EF2                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00001EF7                 mov     eax, [ebp+arg_0]
.text$mn:00001EFA                 mov     esp, ebp
.text$mn:00001EFC                 pop     ebp
.text$mn:00001EFD                 retn    4
.text$mn:00001EFD ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00001EFD
.text$mn:00001EFD _text$mn        ends
.text$mn:00001EFD
.text$mn:00001F00 ; ===========================================================================
.text$mn:00001F00
.text$mn:00001F00 ; Segment type: Pure code
.text$mn:00001F00 ; Segment permissions: Read/Execute
.text$mn:00001F00 _text$mn        segment para public 'CODE' use32
.text$mn:00001F00                 assume cs:_text$mn
.text$mn:00001F00                 ;org 1F00h
.text$mn:00001F00 ; COMDAT (pick any)
.text$mn:00001F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F00
.text$mn:00001F00 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F00
.text$mn:00001F00 ; Attributes: bp-based frame
.text$mn:00001F00
.text$mn:00001F00 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00001F00                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00001F00 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00001F00                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+B4p
.text$mn:00001F00                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00001F00
.text$mn:00001F00 var_4           = dword ptr -4
.text$mn:00001F00 arg_0           = dword ptr  8
.text$mn:00001F00
.text$mn:00001F00                 push    ebp
.text$mn:00001F01                 mov     ebp, esp
.text$mn:00001F03                 push    ecx
.text$mn:00001F04                 mov     [ebp+var_4], ecx
.text$mn:00001F07                 mov     ecx, [ebp+arg_0]
.text$mn:00001F0A                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:00001F0F                 mov     eax, [ebp+arg_0]
.text$mn:00001F12                 mov     esp, ebp
.text$mn:00001F14                 pop     ebp
.text$mn:00001F15                 retn    4
.text$mn:00001F15 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00001F15
.text$mn:00001F15 _text$mn        ends
.text$mn:00001F15
.text$mn:00001F18 ; ===========================================================================
.text$mn:00001F18
.text$mn:00001F18 ; Segment type: Pure code
.text$mn:00001F18 ; Segment permissions: Read/Execute
.text$mn:00001F18 _text$mn        segment para public 'CODE' use32
.text$mn:00001F18                 assume cs:_text$mn
.text$mn:00001F18                 ;org 1F18h
.text$mn:00001F18 ; COMDAT (pick any)
.text$mn:00001F18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F18
.text$mn:00001F18 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F18
.text$mn:00001F18 ; Attributes: bp-based frame
.text$mn:00001F18
.text$mn:00001F18 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00001F18                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00001F18 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00001F18                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00001F18                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00001F18
.text$mn:00001F18 var_C           = dword ptr -0Ch
.text$mn:00001F18 Size            = dword ptr -8
.text$mn:00001F18 var_4           = dword ptr -4
.text$mn:00001F18 arg_0           = dword ptr  8
.text$mn:00001F18 arg_4           = byte ptr  0Ch
.text$mn:00001F18
.text$mn:00001F18                 push    ebp
.text$mn:00001F19                 mov     ebp, esp
.text$mn:00001F1B                 sub     esp, 0Ch
.text$mn:00001F1E                 mov     [ebp+var_4], ecx
.text$mn:00001F21                 mov     ecx, [ebp+var_4]
.text$mn:00001F24                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00001F29                 cmp     eax, [ebp+arg_0]
.text$mn:00001F2C                 jnb     short loc_1F36
.text$mn:00001F2E                 mov     ecx, [ebp+var_4]
.text$mn:00001F31                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00001F36
.text$mn:00001F36 loc_1F36:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00001F36                 mov     eax, [ebp+var_4]
.text$mn:00001F39                 mov     ecx, [eax+18h]
.text$mn:00001F3C                 cmp     ecx, [ebp+arg_0]
.text$mn:00001F3F                 jnb     short loc_1F56
.text$mn:00001F41                 mov     edx, [ebp+var_4]
.text$mn:00001F44                 mov     eax, [edx+14h]
.text$mn:00001F47                 push    eax
.text$mn:00001F48                 mov     ecx, [ebp+arg_0]
.text$mn:00001F4B                 push    ecx
.text$mn:00001F4C                 mov     ecx, [ebp+var_4]
.text$mn:00001F4F                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00001F54                 jmp     short loc_1FA0
.text$mn:00001F56 ; ---------------------------------------------------------------------------
.text$mn:00001F56
.text$mn:00001F56 loc_1F56:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00001F56                 movzx   edx, [ebp+arg_4]
.text$mn:00001F5A                 test    edx, edx
.text$mn:00001F5C                 jz      short loc_1F90
.text$mn:00001F5E                 cmp     [ebp+arg_0], 10h
.text$mn:00001F62                 jnb     short loc_1F90
.text$mn:00001F64                 mov     eax, [ebp+var_4]
.text$mn:00001F67                 mov     ecx, [ebp+arg_0]
.text$mn:00001F6A                 cmp     ecx, [eax+14h]
.text$mn:00001F6D                 jnb     short loc_1F77
.text$mn:00001F6F                 mov     edx, [ebp+arg_0]
.text$mn:00001F72                 mov     [ebp+Size], edx
.text$mn:00001F75                 jmp     short loc_1F80
.text$mn:00001F77 ; ---------------------------------------------------------------------------
.text$mn:00001F77
.text$mn:00001F77 loc_1F77:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00001F77                 mov     eax, [ebp+var_4]
.text$mn:00001F7A                 mov     ecx, [eax+14h]
.text$mn:00001F7D                 mov     [ebp+Size], ecx
.text$mn:00001F80
.text$mn:00001F80 loc_1F80:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00001F80                 mov     edx, [ebp+Size]
.text$mn:00001F83                 push    edx             ; Size
.text$mn:00001F84                 push    1               ; char
.text$mn:00001F86                 mov     ecx, [ebp+var_4]
.text$mn:00001F89                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001F8E                 jmp     short loc_1FA0
.text$mn:00001F90 ; ---------------------------------------------------------------------------
.text$mn:00001F90
.text$mn:00001F90 loc_1F90:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00001F90                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00001F90                 cmp     [ebp+arg_0], 0
.text$mn:00001F94                 jnz     short loc_1FA0
.text$mn:00001F96                 push    0
.text$mn:00001F98                 mov     ecx, [ebp+var_4]
.text$mn:00001F9B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00001FA0
.text$mn:00001FA0 loc_1FA0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00001FA0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00001FA0                 cmp     [ebp+arg_0], 0
.text$mn:00001FA4                 jbe     short loc_1FAF
.text$mn:00001FA6                 mov     [ebp+var_C], 1
.text$mn:00001FAD                 jmp     short loc_1FB6
.text$mn:00001FAF ; ---------------------------------------------------------------------------
.text$mn:00001FAF
.text$mn:00001FAF loc_1FAF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00001FAF                 mov     [ebp+var_C], 0
.text$mn:00001FB6
.text$mn:00001FB6 loc_1FB6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00001FB6                 mov     al, byte ptr [ebp+var_C]
.text$mn:00001FB9                 mov     esp, ebp
.text$mn:00001FBB                 pop     ebp
.text$mn:00001FBC                 retn    8
.text$mn:00001FBC ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00001FBC
.text$mn:00001FBC ; ---------------------------------------------------------------------------
.text$mn:00001FBF                 align 10h
.text$mn:00001FBF _text$mn        ends
.text$mn:00001FBF
.text$mn:00001FC0 ; ===========================================================================
.text$mn:00001FC0
.text$mn:00001FC0 ; Segment type: Pure code
.text$mn:00001FC0 ; Segment permissions: Read/Execute
.text$mn:00001FC0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FC0                 assume cs:_text$mn
.text$mn:00001FC0                 ;org 1FC0h
.text$mn:00001FC0 ; COMDAT (pick any)
.text$mn:00001FC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FC0
.text$mn:00001FC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FC0
.text$mn:00001FC0 ; Attributes: bp-based frame
.text$mn:00001FC0
.text$mn:00001FC0 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:00001FC0                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:00001FC0 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:00001FC0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Dp
.text$mn:00001FC0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+8Ep ...
.text$mn:00001FC0
.text$mn:00001FC0 var_C           = dword ptr -0Ch
.text$mn:00001FC0 var_8           = dword ptr -8
.text$mn:00001FC0 var_4           = dword ptr -4
.text$mn:00001FC0 arg_0           = dword ptr  8
.text$mn:00001FC0 arg_4           = byte ptr  0Ch
.text$mn:00001FC0
.text$mn:00001FC0                 push    ebp
.text$mn:00001FC1                 mov     ebp, esp
.text$mn:00001FC3                 sub     esp, 0Ch
.text$mn:00001FC6                 mov     [ebp+var_4], ecx
.text$mn:00001FC9                 mov     ecx, [ebp+var_4]
.text$mn:00001FCC                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00001FD1                 cmp     eax, [ebp+arg_0]
.text$mn:00001FD4                 jnb     short loc_1FDE
.text$mn:00001FD6                 mov     ecx, [ebp+var_4]
.text$mn:00001FD9                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00001FDE
.text$mn:00001FDE loc_1FDE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:00001FDE                 mov     eax, [ebp+var_4]
.text$mn:00001FE1                 mov     ecx, [eax+18h]
.text$mn:00001FE4                 cmp     ecx, [ebp+arg_0]
.text$mn:00001FE7                 jnb     short loc_1FFE
.text$mn:00001FE9                 mov     edx, [ebp+var_4]
.text$mn:00001FEC                 mov     eax, [edx+14h]
.text$mn:00001FEF                 push    eax
.text$mn:00001FF0                 mov     ecx, [ebp+arg_0]
.text$mn:00001FF3                 push    ecx
.text$mn:00001FF4                 mov     ecx, [ebp+var_4]
.text$mn:00001FF7                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:00001FFC                 jmp     short loc_2048
.text$mn:00001FFE ; ---------------------------------------------------------------------------
.text$mn:00001FFE
.text$mn:00001FFE loc_1FFE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:00001FFE                 movzx   edx, [ebp+arg_4]
.text$mn:00002002                 test    edx, edx
.text$mn:00002004                 jz      short loc_2038
.text$mn:00002006                 cmp     [ebp+arg_0], 8
.text$mn:0000200A                 jnb     short loc_2038
.text$mn:0000200C                 mov     eax, [ebp+var_4]
.text$mn:0000200F                 mov     ecx, [ebp+arg_0]
.text$mn:00002012                 cmp     ecx, [eax+14h]
.text$mn:00002015                 jnb     short loc_201F
.text$mn:00002017                 mov     edx, [ebp+arg_0]
.text$mn:0000201A                 mov     [ebp+var_8], edx
.text$mn:0000201D                 jmp     short loc_2028
.text$mn:0000201F ; ---------------------------------------------------------------------------
.text$mn:0000201F
.text$mn:0000201F loc_201F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:0000201F                 mov     eax, [ebp+var_4]
.text$mn:00002022                 mov     ecx, [eax+14h]
.text$mn:00002025                 mov     [ebp+var_8], ecx
.text$mn:00002028
.text$mn:00002028 loc_2028:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:00002028                 mov     edx, [ebp+var_8]
.text$mn:0000202B                 push    edx
.text$mn:0000202C                 push    1
.text$mn:0000202E                 mov     ecx, [ebp+var_4]
.text$mn:00002031                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00002036                 jmp     short loc_2048
.text$mn:00002038 ; ---------------------------------------------------------------------------
.text$mn:00002038
.text$mn:00002038 loc_2038:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:00002038                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:00002038                 cmp     [ebp+arg_0], 0
.text$mn:0000203C                 jnz     short loc_2048
.text$mn:0000203E                 push    0
.text$mn:00002040                 mov     ecx, [ebp+var_4]
.text$mn:00002043                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00002048
.text$mn:00002048 loc_2048:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:00002048                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:00002048                 cmp     [ebp+arg_0], 0
.text$mn:0000204C                 jbe     short loc_2057
.text$mn:0000204E                 mov     [ebp+var_C], 1
.text$mn:00002055                 jmp     short loc_205E
.text$mn:00002057 ; ---------------------------------------------------------------------------
.text$mn:00002057
.text$mn:00002057 loc_2057:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:00002057                 mov     [ebp+var_C], 0
.text$mn:0000205E
.text$mn:0000205E loc_205E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:0000205E                 mov     al, byte ptr [ebp+var_C]
.text$mn:00002061                 mov     esp, ebp
.text$mn:00002063                 pop     ebp
.text$mn:00002064                 retn    8
.text$mn:00002064 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:00002064
.text$mn:00002064 ; ---------------------------------------------------------------------------
.text$mn:00002067                 align 4
.text$mn:00002067 _text$mn        ends
.text$mn:00002067
.text$mn:00002068 ; ===========================================================================
.text$mn:00002068
.text$mn:00002068 ; Segment type: Pure code
.text$mn:00002068 ; Segment permissions: Read/Execute
.text$mn:00002068 _text$mn        segment para public 'CODE' use32
.text$mn:00002068                 assume cs:_text$mn
.text$mn:00002068                 ;org 2068h
.text$mn:00002068 ; COMDAT (pick any)
.text$mn:00002068                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002068
.text$mn:00002068 ; =============== S U B R O U T I N E =======================================
.text$mn:00002068
.text$mn:00002068 ; Attributes: bp-based frame
.text$mn:00002068
.text$mn:00002068 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00002068                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00002068 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00002068                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00002068
.text$mn:00002068 var_4           = dword ptr -4
.text$mn:00002068 arg_0           = dword ptr  8
.text$mn:00002068
.text$mn:00002068                 push    ebp
.text$mn:00002069                 mov     ebp, esp
.text$mn:0000206B                 push    ecx
.text$mn:0000206C                 mov     [ebp+var_4], ecx
.text$mn:0000206F                 cmp     [ebp+arg_0], 0
.text$mn:00002073                 jz      short loc_2095
.text$mn:00002075                 mov     ecx, [ebp+var_4]
.text$mn:00002078                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000207D                 cmp     [ebp+arg_0], eax
.text$mn:00002080                 jb      short loc_2095
.text$mn:00002082                 mov     ecx, [ebp+var_4]
.text$mn:00002085                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000208A                 mov     ecx, [ebp+var_4]
.text$mn:0000208D                 add     eax, [ecx+14h]
.text$mn:00002090                 cmp     eax, [ebp+arg_0]
.text$mn:00002093                 ja      short loc_209B
.text$mn:00002095
.text$mn:00002095 loc_2095:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00002095                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00002095                 xor     al, al
.text$mn:00002097                 jmp     short loc_209D
.text$mn:00002099 ; ---------------------------------------------------------------------------
.text$mn:00002099                 jmp     short loc_209D
.text$mn:0000209B ; ---------------------------------------------------------------------------
.text$mn:0000209B
.text$mn:0000209B loc_209B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:0000209B                 mov     al, 1
.text$mn:0000209D
.text$mn:0000209D loc_209D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:0000209D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:0000209D                 mov     esp, ebp
.text$mn:0000209F                 pop     ebp
.text$mn:000020A0                 retn    4
.text$mn:000020A0 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000020A0
.text$mn:000020A0 ; ---------------------------------------------------------------------------
.text$mn:000020A3                 align 4
.text$mn:000020A3 _text$mn        ends
.text$mn:000020A3
.text$mn:000020A4 ; ===========================================================================
.text$mn:000020A4
.text$mn:000020A4 ; Segment type: Pure code
.text$mn:000020A4 ; Segment permissions: Read/Execute
.text$mn:000020A4 _text$mn        segment para public 'CODE' use32
.text$mn:000020A4                 assume cs:_text$mn
.text$mn:000020A4                 ;org 20A4h
.text$mn:000020A4 ; COMDAT (pick any)
.text$mn:000020A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020A4
.text$mn:000020A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000020A4
.text$mn:000020A4 ; Attributes: bp-based frame
.text$mn:000020A4
.text$mn:000020A4 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:000020A4                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:000020A4 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:000020A4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+2Cp
.text$mn:000020A4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:000020A4
.text$mn:000020A4 var_4           = dword ptr -4
.text$mn:000020A4 arg_0           = dword ptr  8
.text$mn:000020A4
.text$mn:000020A4                 push    ebp
.text$mn:000020A5                 mov     ebp, esp
.text$mn:000020A7                 push    ecx
.text$mn:000020A8                 mov     [ebp+var_4], ecx
.text$mn:000020AB                 cmp     [ebp+arg_0], 0
.text$mn:000020AF                 jz      short loc_20D4
.text$mn:000020B1                 mov     ecx, [ebp+var_4]
.text$mn:000020B4                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000020B9                 cmp     [ebp+arg_0], eax
.text$mn:000020BC                 jb      short loc_20D4
.text$mn:000020BE                 mov     ecx, [ebp+var_4]
.text$mn:000020C1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000020C6                 mov     ecx, [ebp+var_4]
.text$mn:000020C9                 mov     edx, [ecx+14h]
.text$mn:000020CC                 lea     eax, [eax+edx*2]
.text$mn:000020CF                 cmp     eax, [ebp+arg_0]
.text$mn:000020D2                 ja      short loc_20DA
.text$mn:000020D4
.text$mn:000020D4 loc_20D4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:000020D4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:000020D4                 xor     al, al
.text$mn:000020D6                 jmp     short loc_20DC
.text$mn:000020D8 ; ---------------------------------------------------------------------------
.text$mn:000020D8                 jmp     short loc_20DC
.text$mn:000020DA ; ---------------------------------------------------------------------------
.text$mn:000020DA
.text$mn:000020DA loc_20DA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:000020DA                 mov     al, 1
.text$mn:000020DC
.text$mn:000020DC loc_20DC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:000020DC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:000020DC                 mov     esp, ebp
.text$mn:000020DE                 pop     ebp
.text$mn:000020DF                 retn    4
.text$mn:000020DF ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:000020DF
.text$mn:000020DF ; ---------------------------------------------------------------------------
.text$mn:000020E2                 align 4
.text$mn:000020E2 _text$mn        ends
.text$mn:000020E2
.text$mn:000020E4 ; ===========================================================================
.text$mn:000020E4
.text$mn:000020E4 ; Segment type: Pure code
.text$mn:000020E4 ; Segment permissions: Read/Execute
.text$mn:000020E4 _text$mn        segment para public 'CODE' use32
.text$mn:000020E4                 assume cs:_text$mn
.text$mn:000020E4                 ;org 20E4h
.text$mn:000020E4 ; COMDAT (pick any)
.text$mn:000020E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020E4
.text$mn:000020E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000020E4
.text$mn:000020E4 ; Attributes: bp-based frame
.text$mn:000020E4
.text$mn:000020E4 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:000020E4                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:000020E4 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:000020E4                                         ; CODE XREF: $LN19+14p
.text$mn:000020E4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:000020E4
.text$mn:000020E4 var_8           = dword ptr -8
.text$mn:000020E4 var_4           = dword ptr -4
.text$mn:000020E4
.text$mn:000020E4                 push    ebp
.text$mn:000020E5                 mov     ebp, esp
.text$mn:000020E7                 sub     esp, 8
.text$mn:000020EA                 mov     [ebp+var_4], ecx
.text$mn:000020ED                 mov     eax, [ebp+var_4]
.text$mn:000020F0                 cmp     dword ptr [eax+18h], 10h
.text$mn:000020F4                 jb      short loc_210A
.text$mn:000020F6                 mov     ecx, [ebp+var_4]
.text$mn:000020F9                 mov     edx, [ecx+4]
.text$mn:000020FC                 push    edx
.text$mn:000020FD                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002102                 add     esp, 4
.text$mn:00002105                 mov     [ebp+var_8], eax
.text$mn:00002108                 jmp     short loc_2113
.text$mn:0000210A ; ---------------------------------------------------------------------------
.text$mn:0000210A
.text$mn:0000210A loc_210A:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000210A                 mov     eax, [ebp+var_4]
.text$mn:0000210D                 add     eax, 4
.text$mn:00002110                 mov     [ebp+var_8], eax
.text$mn:00002113
.text$mn:00002113 loc_2113:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00002113                 mov     eax, [ebp+var_8]
.text$mn:00002116                 mov     esp, ebp
.text$mn:00002118                 pop     ebp
.text$mn:00002119                 retn
.text$mn:00002119 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00002119
.text$mn:00002119 ; ---------------------------------------------------------------------------
.text$mn:0000211A                 align 4
.text$mn:0000211A _text$mn        ends
.text$mn:0000211A
.text$mn:0000211C ; ===========================================================================
.text$mn:0000211C
.text$mn:0000211C ; Segment type: Pure code
.text$mn:0000211C ; Segment permissions: Read/Execute
.text$mn:0000211C _text$mn        segment para public 'CODE' use32
.text$mn:0000211C                 assume cs:_text$mn
.text$mn:0000211C                 ;org 211Ch
.text$mn:0000211C ; COMDAT (pick any)
.text$mn:0000211C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000211C
.text$mn:0000211C ; =============== S U B R O U T I N E =======================================
.text$mn:0000211C
.text$mn:0000211C ; Attributes: bp-based frame
.text$mn:0000211C
.text$mn:0000211C ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:0000211C                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:0000211C ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:0000211C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:0000211C
.text$mn:0000211C var_8           = dword ptr -8
.text$mn:0000211C var_4           = dword ptr -4
.text$mn:0000211C
.text$mn:0000211C                 push    ebp
.text$mn:0000211D                 mov     ebp, esp
.text$mn:0000211F                 sub     esp, 8
.text$mn:00002122                 mov     [ebp+var_4], ecx
.text$mn:00002125                 mov     eax, [ebp+var_4]
.text$mn:00002128                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000212C                 jb      short loc_2142
.text$mn:0000212E                 mov     ecx, [ebp+var_4]
.text$mn:00002131                 mov     edx, [ecx+4]
.text$mn:00002134                 push    edx
.text$mn:00002135                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000213A                 add     esp, 4
.text$mn:0000213D                 mov     [ebp+var_8], eax
.text$mn:00002140                 jmp     short loc_214B
.text$mn:00002142 ; ---------------------------------------------------------------------------
.text$mn:00002142
.text$mn:00002142 loc_2142:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00002142                 mov     eax, [ebp+var_4]
.text$mn:00002145                 add     eax, 4
.text$mn:00002148                 mov     [ebp+var_8], eax
.text$mn:0000214B
.text$mn:0000214B loc_214B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000214B                 mov     eax, [ebp+var_8]
.text$mn:0000214E                 mov     esp, ebp
.text$mn:00002150                 pop     ebp
.text$mn:00002151                 retn
.text$mn:00002151 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:00002151
.text$mn:00002151 ; ---------------------------------------------------------------------------
.text$mn:00002152                 align 4
.text$mn:00002152 _text$mn        ends
.text$mn:00002152
.text$mn:00002154 ; ===========================================================================
.text$mn:00002154
.text$mn:00002154 ; Segment type: Pure code
.text$mn:00002154 ; Segment permissions: Read/Execute
.text$mn:00002154 _text$mn        segment para public 'CODE' use32
.text$mn:00002154                 assume cs:_text$mn
.text$mn:00002154                 ;org 2154h
.text$mn:00002154 ; COMDAT (pick any)
.text$mn:00002154                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002154
.text$mn:00002154 ; =============== S U B R O U T I N E =======================================
.text$mn:00002154
.text$mn:00002154 ; Attributes: bp-based frame
.text$mn:00002154
.text$mn:00002154 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002154                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:00002154 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:00002154                                         ; CODE XREF: $LN19_0+14p
.text$mn:00002154                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:00002154
.text$mn:00002154 var_8           = dword ptr -8
.text$mn:00002154 var_4           = dword ptr -4
.text$mn:00002154
.text$mn:00002154                 push    ebp
.text$mn:00002155                 mov     ebp, esp
.text$mn:00002157                 sub     esp, 8
.text$mn:0000215A                 mov     [ebp+var_4], ecx
.text$mn:0000215D                 mov     eax, [ebp+var_4]
.text$mn:00002160                 cmp     dword ptr [eax+18h], 8
.text$mn:00002164                 jb      short loc_217A
.text$mn:00002166                 mov     ecx, [ebp+var_4]
.text$mn:00002169                 mov     edx, [ecx+4]
.text$mn:0000216C                 push    edx
.text$mn:0000216D                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00002172                 add     esp, 4
.text$mn:00002175                 mov     [ebp+var_8], eax
.text$mn:00002178                 jmp     short loc_2183
.text$mn:0000217A ; ---------------------------------------------------------------------------
.text$mn:0000217A
.text$mn:0000217A loc_217A:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000217A                 mov     eax, [ebp+var_4]
.text$mn:0000217D                 add     eax, 4
.text$mn:00002180                 mov     [ebp+var_8], eax
.text$mn:00002183
.text$mn:00002183 loc_2183:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00002183                 mov     eax, [ebp+var_8]
.text$mn:00002186                 mov     esp, ebp
.text$mn:00002188                 pop     ebp
.text$mn:00002189                 retn
.text$mn:00002189 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:00002189
.text$mn:00002189 ; ---------------------------------------------------------------------------
.text$mn:0000218A                 align 4
.text$mn:0000218A _text$mn        ends
.text$mn:0000218A
.text$mn:0000218C ; ===========================================================================
.text$mn:0000218C
.text$mn:0000218C ; Segment type: Pure code
.text$mn:0000218C ; Segment permissions: Read/Execute
.text$mn:0000218C _text$mn        segment para public 'CODE' use32
.text$mn:0000218C                 assume cs:_text$mn
.text$mn:0000218C                 ;org 218Ch
.text$mn:0000218C ; COMDAT (pick any)
.text$mn:0000218C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000218C
.text$mn:0000218C ; =============== S U B R O U T I N E =======================================
.text$mn:0000218C
.text$mn:0000218C ; Attributes: bp-based frame
.text$mn:0000218C
.text$mn:0000218C ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:0000218C                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:0000218C ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:0000218C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+80p
.text$mn:0000218C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp ...
.text$mn:0000218C
.text$mn:0000218C var_8           = dword ptr -8
.text$mn:0000218C var_4           = dword ptr -4
.text$mn:0000218C
.text$mn:0000218C                 push    ebp
.text$mn:0000218D                 mov     ebp, esp
.text$mn:0000218F                 sub     esp, 8
.text$mn:00002192                 mov     [ebp+var_4], ecx
.text$mn:00002195                 mov     eax, [ebp+var_4]
.text$mn:00002198                 cmp     dword ptr [eax+18h], 8
.text$mn:0000219C                 jb      short loc_21B2
.text$mn:0000219E                 mov     ecx, [ebp+var_4]
.text$mn:000021A1                 mov     edx, [ecx+4]
.text$mn:000021A4                 push    edx
.text$mn:000021A5                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000021AA                 add     esp, 4
.text$mn:000021AD                 mov     [ebp+var_8], eax
.text$mn:000021B0                 jmp     short loc_21BB
.text$mn:000021B2 ; ---------------------------------------------------------------------------
.text$mn:000021B2
.text$mn:000021B2 loc_21B2:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:000021B2                 mov     eax, [ebp+var_4]
.text$mn:000021B5                 add     eax, 4
.text$mn:000021B8                 mov     [ebp+var_8], eax
.text$mn:000021BB
.text$mn:000021BB loc_21BB:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:000021BB                 mov     eax, [ebp+var_8]
.text$mn:000021BE                 mov     esp, ebp
.text$mn:000021C0                 pop     ebp
.text$mn:000021C1                 retn
.text$mn:000021C1 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:000021C1
.text$mn:000021C1 ; ---------------------------------------------------------------------------
.text$mn:000021C2                 align 4
.text$mn:000021C2 _text$mn        ends
.text$mn:000021C2
.text$mn:000021C4 ; ===========================================================================
.text$mn:000021C4
.text$mn:000021C4 ; Segment type: Pure code
.text$mn:000021C4 ; Segment permissions: Read/Execute
.text$mn:000021C4 _text$mn        segment para public 'CODE' use32
.text$mn:000021C4                 assume cs:_text$mn
.text$mn:000021C4                 ;org 21C4h
.text$mn:000021C4 ; COMDAT (pick any)
.text$mn:000021C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021C4
.text$mn:000021C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000021C4
.text$mn:000021C4 ; Attributes: bp-based frame
.text$mn:000021C4
.text$mn:000021C4 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:000021C4                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000021C4 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:000021C4                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:000021C4                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:000021C4
.text$mn:000021C4 var_18          = byte ptr -18h
.text$mn:000021C4 var_14          = dword ptr -14h
.text$mn:000021C4 var_10          = dword ptr -10h
.text$mn:000021C4 var_C           = dword ptr -0Ch
.text$mn:000021C4 var_4           = dword ptr -4
.text$mn:000021C4
.text$mn:000021C4                 push    ebp
.text$mn:000021C5                 mov     ebp, esp
.text$mn:000021C7                 push    0FFFFFFFFh
.text$mn:000021C9                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000021CE                 mov     eax, large fs:0
.text$mn:000021D4                 push    eax
.text$mn:000021D5                 sub     esp, 0Ch
.text$mn:000021D8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000021DD                 xor     eax, ebp
.text$mn:000021DF                 push    eax
.text$mn:000021E0                 lea     eax, [ebp+var_C]
.text$mn:000021E3                 mov     large fs:0, eax
.text$mn:000021E9                 mov     [ebp+var_14], ecx
.text$mn:000021EC                 mov     eax, [ebp+var_14]
.text$mn:000021EF                 cmp     dword ptr [eax], 0
.text$mn:000021F2                 jz      short loc_224F
.text$mn:000021F4                 push    3               ; int
.text$mn:000021F6                 lea     ecx, [ebp+var_18] ; this
.text$mn:000021F9                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000021FE                 mov     [ebp+var_4], 0
.text$mn:00002205                 mov     ecx, [ebp+var_14]
.text$mn:00002208                 mov     edx, [ecx]
.text$mn:0000220A                 add     edx, 4
.text$mn:0000220D                 mov     [ebp+var_10], edx
.text$mn:00002210                 jmp     short loc_221F
.text$mn:00002212 ; ---------------------------------------------------------------------------
.text$mn:00002212
.text$mn:00002212 loc_2212:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00002212                 mov     eax, [ebp+var_10]
.text$mn:00002215                 mov     ecx, [eax]
.text$mn:00002217                 mov     edx, [ebp+var_10]
.text$mn:0000221A                 mov     eax, [ecx+4]
.text$mn:0000221D                 mov     [edx], eax
.text$mn:0000221F
.text$mn:0000221F loc_221F:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:0000221F                 mov     ecx, [ebp+var_10]
.text$mn:00002222                 cmp     dword ptr [ecx], 0
.text$mn:00002225                 jz      short loc_2234
.text$mn:00002227                 mov     edx, [ebp+var_10]
.text$mn:0000222A                 mov     eax, [edx]
.text$mn:0000222C                 mov     dword ptr [eax], 0
.text$mn:00002232                 jmp     short loc_2212
.text$mn:00002234 ; ---------------------------------------------------------------------------
.text$mn:00002234
.text$mn:00002234 loc_2234:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00002234                 mov     ecx, [ebp+var_14]
.text$mn:00002237                 mov     edx, [ecx]
.text$mn:00002239                 mov     dword ptr [edx+4], 0
.text$mn:00002240                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002247                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000224A                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000224F
.text$mn:0000224F loc_224F:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:0000224F                 mov     ecx, [ebp+var_C]
.text$mn:00002252                 mov     large fs:0, ecx
.text$mn:00002259                 pop     ecx
.text$mn:0000225A                 mov     esp, ebp
.text$mn:0000225C                 pop     ebp
.text$mn:0000225D                 retn
.text$mn:0000225D ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:0000225D
.text$mn:0000225D ; ---------------------------------------------------------------------------
.text$mn:0000225E                 align 10h
.text$mn:0000225E _text$mn        ends
.text$mn:0000225E
.text$x:00002260 ; ===========================================================================
.text$x:00002260
.text$x:00002260 ; Segment type: Pure code
.text$x:00002260 ; Segment permissions: Read/Execute
.text$x:00002260 _text$x         segment para public 'CODE' use32
.text$x:00002260                 assume cs:_text$x
.text$x:00002260                 ;org 2260h
.text$x:00002260 ; COMDAT (pick associative to section at 21C4)
.text$x:00002260                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002260
.text$x:00002260 ; =============== S U B R O U T I N E =======================================
.text$x:00002260
.text$x:00002260
.text$x:00002260 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00002260                                         ; DATA XREF: .xdata$x:00003244o
.text$x:00002260                 lea     ecx, [ebp-18h]  ; this
.text$x:00002263                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00002263 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00002263
.text$x:00002268
.text$x:00002268 ; =============== S U B R O U T I N E =======================================
.text$x:00002268
.text$x:00002268
.text$x:00002268 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00002268                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00002268
.text$x:00002268 arg_4           = dword ptr  8
.text$x:00002268
.text$x:00002268                 mov     edx, [esp+arg_4]
.text$x:0000226C                 lea     eax, [edx+0Ch]
.text$x:0000226F                 mov     ecx, [edx-10h]
.text$x:00002272                 xor     ecx, eax
.text$x:00002274                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002279                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:0000227E                 jmp     ___CxxFrameHandler3
.text$x:0000227E __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:0000227E
.text$x:0000227E ; ---------------------------------------------------------------------------
.text$x:00002283                 align 4
.text$x:00002283 _text$x         ends
.text$x:00002283
.text$mn:00002284 ; ===========================================================================
.text$mn:00002284
.text$mn:00002284 ; Segment type: Pure code
.text$mn:00002284 ; Segment permissions: Read/Execute
.text$mn:00002284 _text$mn        segment para public 'CODE' use32
.text$mn:00002284                 assume cs:_text$mn
.text$mn:00002284                 ;org 2284h
.text$mn:00002284 ; COMDAT (pick any)
.text$mn:00002284                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002284
.text$mn:00002284 ; =============== S U B R O U T I N E =======================================
.text$mn:00002284
.text$mn:00002284 ; Attributes: bp-based frame
.text$mn:00002284
.text$mn:00002284 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00002284                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00002284 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00002284                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00002284                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00002284
.text$mn:00002284 var_C           = dword ptr -0Ch
.text$mn:00002284 var_8           = dword ptr -8
.text$mn:00002284 var_2           = byte ptr -2
.text$mn:00002284 var_1           = byte ptr -1
.text$mn:00002284 arg_0           = byte ptr  8
.text$mn:00002284 Size            = dword ptr  0Ch
.text$mn:00002284
.text$mn:00002284                 push    ebp
.text$mn:00002285                 mov     ebp, esp
.text$mn:00002287                 sub     esp, 0Ch
.text$mn:0000228A                 mov     [ebp+var_8], ecx
.text$mn:0000228D                 movzx   eax, [ebp+arg_0]
.text$mn:00002291                 test    eax, eax
.text$mn:00002293                 jnz     short loc_2297
.text$mn:00002295                 jmp     short loc_230A
.text$mn:00002297 ; ---------------------------------------------------------------------------
.text$mn:00002297
.text$mn:00002297 loc_2297:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00002297                 mov     ecx, [ebp+var_8]
.text$mn:0000229A                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000229E                 jb      short loc_230A
.text$mn:000022A0                 mov     edx, [ebp+var_8]
.text$mn:000022A3                 mov     eax, [edx+4]
.text$mn:000022A6                 mov     [ebp+var_C], eax
.text$mn:000022A9                 mov     ecx, [ebp+var_8]
.text$mn:000022AC                 add     ecx, 4
.text$mn:000022AF                 push    ecx
.text$mn:000022B0                 lea     edx, [ebp+var_1]
.text$mn:000022B3                 push    edx
.text$mn:000022B4                 mov     ecx, [ebp+var_8]
.text$mn:000022B7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000022BC                 mov     ecx, eax
.text$mn:000022BE                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000022C3                 cmp     [ebp+Size], 0
.text$mn:000022C7                 jbe     short loc_22E9
.text$mn:000022C9                 mov     eax, [ebp+Size]
.text$mn:000022CC                 push    eax             ; Size
.text$mn:000022CD                 mov     ecx, [ebp+var_C]
.text$mn:000022D0                 push    ecx
.text$mn:000022D1                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000022D6                 add     esp, 4
.text$mn:000022D9                 push    eax             ; Src
.text$mn:000022DA                 mov     edx, [ebp+var_8]
.text$mn:000022DD                 add     edx, 4
.text$mn:000022E0                 push    edx             ; Dst
.text$mn:000022E1                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000022E6                 add     esp, 0Ch
.text$mn:000022E9
.text$mn:000022E9 loc_22E9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:000022E9                 mov     eax, [ebp+var_8]
.text$mn:000022EC                 mov     ecx, [eax+18h]
.text$mn:000022EF                 add     ecx, 1
.text$mn:000022F2                 push    ecx             ; int
.text$mn:000022F3                 mov     edx, [ebp+var_C]
.text$mn:000022F6                 push    edx             ; void *
.text$mn:000022F7                 lea     eax, [ebp+var_2]
.text$mn:000022FA                 push    eax
.text$mn:000022FB                 mov     ecx, [ebp+var_8]
.text$mn:000022FE                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002303                 mov     ecx, eax
.text$mn:00002305                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:0000230A
.text$mn:0000230A loc_230A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:0000230A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:0000230A                 mov     ecx, [ebp+var_8]
.text$mn:0000230D                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00002314                 mov     edx, [ebp+Size]
.text$mn:00002317                 push    edx
.text$mn:00002318                 mov     ecx, [ebp+var_8]
.text$mn:0000231B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002320                 mov     esp, ebp
.text$mn:00002322                 pop     ebp
.text$mn:00002323                 retn    8
.text$mn:00002323 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00002323
.text$mn:00002323 ; ---------------------------------------------------------------------------
.text$mn:00002326                 align 4
.text$mn:00002326 _text$mn        ends
.text$mn:00002326
.text$mn:00002328 ; ===========================================================================
.text$mn:00002328
.text$mn:00002328 ; Segment type: Pure code
.text$mn:00002328 ; Segment permissions: Read/Execute
.text$mn:00002328 _text$mn        segment para public 'CODE' use32
.text$mn:00002328                 assume cs:_text$mn
.text$mn:00002328                 ;org 2328h
.text$mn:00002328 ; COMDAT (pick any)
.text$mn:00002328                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002328
.text$mn:00002328 ; =============== S U B R O U T I N E =======================================
.text$mn:00002328
.text$mn:00002328 ; Attributes: bp-based frame
.text$mn:00002328
.text$mn:00002328 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00002328                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00002328 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00002328                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+47p
.text$mn:00002328                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+34p ...
.text$mn:00002328
.text$mn:00002328 var_C           = dword ptr -0Ch
.text$mn:00002328 var_8           = dword ptr -8
.text$mn:00002328 var_2           = byte ptr -2
.text$mn:00002328 var_1           = byte ptr -1
.text$mn:00002328 arg_0           = byte ptr  8
.text$mn:00002328 arg_4           = dword ptr  0Ch
.text$mn:00002328
.text$mn:00002328                 push    ebp
.text$mn:00002329                 mov     ebp, esp
.text$mn:0000232B                 sub     esp, 0Ch
.text$mn:0000232E                 mov     [ebp+var_8], ecx
.text$mn:00002331                 movzx   eax, [ebp+arg_0]
.text$mn:00002335                 test    eax, eax
.text$mn:00002337                 jnz     short loc_233B
.text$mn:00002339                 jmp     short loc_23AE
.text$mn:0000233B ; ---------------------------------------------------------------------------
.text$mn:0000233B
.text$mn:0000233B loc_233B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:0000233B                 mov     ecx, [ebp+var_8]
.text$mn:0000233E                 cmp     dword ptr [ecx+18h], 8
.text$mn:00002342                 jb      short loc_23AE
.text$mn:00002344                 mov     edx, [ebp+var_8]
.text$mn:00002347                 mov     eax, [edx+4]
.text$mn:0000234A                 mov     [ebp+var_C], eax
.text$mn:0000234D                 mov     ecx, [ebp+var_8]
.text$mn:00002350                 add     ecx, 4
.text$mn:00002353                 push    ecx
.text$mn:00002354                 lea     edx, [ebp+var_1]
.text$mn:00002357                 push    edx
.text$mn:00002358                 mov     ecx, [ebp+var_8]
.text$mn:0000235B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002360                 mov     ecx, eax
.text$mn:00002362                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00002367                 cmp     [ebp+arg_4], 0
.text$mn:0000236B                 jbe     short loc_238D
.text$mn:0000236D                 mov     eax, [ebp+arg_4]
.text$mn:00002370                 push    eax             ; int
.text$mn:00002371                 mov     ecx, [ebp+var_C]
.text$mn:00002374                 push    ecx
.text$mn:00002375                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:0000237A                 add     esp, 4
.text$mn:0000237D                 push    eax             ; Src
.text$mn:0000237E                 mov     edx, [ebp+var_8]
.text$mn:00002381                 add     edx, 4
.text$mn:00002384                 push    edx             ; Dst
.text$mn:00002385                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000238A                 add     esp, 0Ch
.text$mn:0000238D
.text$mn:0000238D loc_238D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:0000238D                 mov     eax, [ebp+var_8]
.text$mn:00002390                 mov     ecx, [eax+18h]
.text$mn:00002393                 add     ecx, 1
.text$mn:00002396                 push    ecx             ; int
.text$mn:00002397                 mov     edx, [ebp+var_C]
.text$mn:0000239A                 push    edx             ; void *
.text$mn:0000239B                 lea     eax, [ebp+var_2]
.text$mn:0000239E                 push    eax
.text$mn:0000239F                 mov     ecx, [ebp+var_8]
.text$mn:000023A2                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000023A7                 mov     ecx, eax
.text$mn:000023A9                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:000023AE
.text$mn:000023AE loc_23AE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:000023AE                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:000023AE                 mov     ecx, [ebp+var_8]
.text$mn:000023B1                 mov     dword ptr [ecx+18h], 7
.text$mn:000023B8                 mov     edx, [ebp+arg_4]
.text$mn:000023BB                 push    edx
.text$mn:000023BC                 mov     ecx, [ebp+var_8]
.text$mn:000023BF                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000023C4                 mov     esp, ebp
.text$mn:000023C6                 pop     ebp
.text$mn:000023C7                 retn    8
.text$mn:000023C7 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:000023C7
.text$mn:000023C7 ; ---------------------------------------------------------------------------
.text$mn:000023CA                 align 4
.text$mn:000023CA _text$mn        ends
.text$mn:000023CA
.text$mn:000023CC ; ===========================================================================
.text$mn:000023CC
.text$mn:000023CC ; Segment type: Pure code
.text$mn:000023CC ; Segment permissions: Read/Execute
.text$mn:000023CC _text$mn        segment para public 'CODE' use32
.text$mn:000023CC                 assume cs:_text$mn
.text$mn:000023CC                 ;org 23CCh
.text$mn:000023CC ; COMDAT (pick any)
.text$mn:000023CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023CC
.text$mn:000023CC ; =============== S U B R O U T I N E =======================================
.text$mn:000023CC
.text$mn:000023CC ; Attributes: bp-based frame
.text$mn:000023CC
.text$mn:000023CC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:000023CC                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000023CC ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000023CC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:000023CC
.text$mn:000023CC var_4           = dword ptr -4
.text$mn:000023CC
.text$mn:000023CC                 push    ebp
.text$mn:000023CD                 mov     ebp, esp
.text$mn:000023CF                 push    ecx
.text$mn:000023D0                 mov     [ebp+var_4], ecx
.text$mn:000023D3                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000023D8                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000023DD                 mov     esp, ebp
.text$mn:000023DF                 pop     ebp
.text$mn:000023E0                 retn
.text$mn:000023E0 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:000023E0
.text$mn:000023E0 ; ---------------------------------------------------------------------------
.text$mn:000023E1                 align 4
.text$mn:000023E1 _text$mn        ends
.text$mn:000023E1
.text$mn:000023E4 ; ===========================================================================
.text$mn:000023E4
.text$mn:000023E4 ; Segment type: Pure code
.text$mn:000023E4 ; Segment permissions: Read/Execute
.text$mn:000023E4 _text$mn        segment para public 'CODE' use32
.text$mn:000023E4                 assume cs:_text$mn
.text$mn:000023E4                 ;org 23E4h
.text$mn:000023E4 ; COMDAT (pick any)
.text$mn:000023E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023E4
.text$mn:000023E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023E4
.text$mn:000023E4 ; Attributes: bp-based frame
.text$mn:000023E4
.text$mn:000023E4 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:000023E4                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:000023E4 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:000023E4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:000023E4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Dp ...
.text$mn:000023E4
.text$mn:000023E4 var_4           = dword ptr -4
.text$mn:000023E4
.text$mn:000023E4                 push    ebp
.text$mn:000023E5                 mov     ebp, esp
.text$mn:000023E7                 push    ecx
.text$mn:000023E8                 mov     [ebp+var_4], ecx
.text$mn:000023EB                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:000023F0                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:000023F5                 mov     esp, ebp
.text$mn:000023F7                 pop     ebp
.text$mn:000023F8                 retn
.text$mn:000023F8 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:000023F8
.text$mn:000023F8 ; ---------------------------------------------------------------------------
.text$mn:000023F9                 align 4
.text$mn:000023F9 _text$mn        ends
.text$mn:000023F9
.text$mn:000023FC ; ===========================================================================
.text$mn:000023FC
.text$mn:000023FC ; Segment type: Pure code
.text$mn:000023FC ; Segment permissions: Read/Execute
.text$mn:000023FC _text$mn        segment para public 'CODE' use32
.text$mn:000023FC                 assume cs:_text$mn
.text$mn:000023FC                 ;org 23FCh
.text$mn:000023FC ; COMDAT (pick any)
.text$mn:000023FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023FC
.text$mn:000023FC ; =============== S U B R O U T I N E =======================================
.text$mn:000023FC
.text$mn:000023FC ; Attributes: bp-based frame
.text$mn:000023FC
.text$mn:000023FC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:000023FC                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:000023FC ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:000023FC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:000023FC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:000023FC
.text$mn:000023FC var_4           = dword ptr -4
.text$mn:000023FC
.text$mn:000023FC                 push    ebp
.text$mn:000023FD                 mov     ebp, esp
.text$mn:000023FF                 push    ecx
.text$mn:00002400                 mov     [ebp+var_4], ecx
.text$mn:00002403                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00002408                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:0000240D                 mov     esp, ebp
.text$mn:0000240F                 pop     ebp
.text$mn:00002410                 retn
.text$mn:00002410 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00002410
.text$mn:00002410 ; ---------------------------------------------------------------------------
.text$mn:00002411                 align 4
.text$mn:00002411 _text$mn        ends
.text$mn:00002411
.text$mn:00002414 ; ===========================================================================
.text$mn:00002414
.text$mn:00002414 ; Segment type: Pure code
.text$mn:00002414 ; Segment permissions: Read/Execute
.text$mn:00002414 _text$mn        segment para public 'CODE' use32
.text$mn:00002414                 assume cs:_text$mn
.text$mn:00002414                 ;org 2414h
.text$mn:00002414 ; COMDAT (pick any)
.text$mn:00002414                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002414
.text$mn:00002414 ; =============== S U B R O U T I N E =======================================
.text$mn:00002414
.text$mn:00002414 ; Attributes: bp-based frame
.text$mn:00002414
.text$mn:00002414 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:00002414                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00002414 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00002414                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:00002414                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p ...
.text$mn:00002414
.text$mn:00002414 var_4           = dword ptr -4
.text$mn:00002414
.text$mn:00002414                 push    ebp
.text$mn:00002415                 mov     ebp, esp
.text$mn:00002417                 push    ecx
.text$mn:00002418                 mov     [ebp+var_4], ecx
.text$mn:0000241B                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00002420                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00002425                 mov     esp, ebp
.text$mn:00002427                 pop     ebp
.text$mn:00002428                 retn
.text$mn:00002428 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00002428
.text$mn:00002428 ; ---------------------------------------------------------------------------
.text$mn:00002429                 align 4
.text$mn:00002429 _text$mn        ends
.text$mn:00002429
.text$mn:0000242C ; ===========================================================================
.text$mn:0000242C
.text$mn:0000242C ; Segment type: Pure code
.text$mn:0000242C ; Segment permissions: Read/Execute
.text$mn:0000242C _text$mn        segment para public 'CODE' use32
.text$mn:0000242C                 assume cs:_text$mn
.text$mn:0000242C                 ;org 242Ch
.text$mn:0000242C ; COMDAT (pick any)
.text$mn:0000242C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000242C
.text$mn:0000242C ; =============== S U B R O U T I N E =======================================
.text$mn:0000242C
.text$mn:0000242C ; Attributes: bp-based frame
.text$mn:0000242C
.text$mn:0000242C ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:0000242C                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:0000242C ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:0000242C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:0000242C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:0000242C
.text$mn:0000242C var_4           = dword ptr -4
.text$mn:0000242C arg_0           = dword ptr  8
.text$mn:0000242C
.text$mn:0000242C                 push    ebp
.text$mn:0000242D                 mov     ebp, esp
.text$mn:0000242F                 push    ecx
.text$mn:00002430                 mov     [ebp+var_4], ecx
.text$mn:00002433                 mov     eax, [ebp+arg_0]
.text$mn:00002436                 push    eax
.text$mn:00002437                 mov     ecx, [ebp+var_4]
.text$mn:0000243A                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000243F                 mov     esp, ebp
.text$mn:00002441                 pop     ebp
.text$mn:00002442                 retn    4
.text$mn:00002442 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00002442
.text$mn:00002442 ; ---------------------------------------------------------------------------
.text$mn:00002445                 align 4
.text$mn:00002445 _text$mn        ends
.text$mn:00002445
.text$mn:00002448 ; ===========================================================================
.text$mn:00002448
.text$mn:00002448 ; Segment type: Pure code
.text$mn:00002448 ; Segment permissions: Read/Execute
.text$mn:00002448 _text$mn        segment para public 'CODE' use32
.text$mn:00002448                 assume cs:_text$mn
.text$mn:00002448                 ;org 2448h
.text$mn:00002448 ; COMDAT (pick any)
.text$mn:00002448                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002448
.text$mn:00002448 ; =============== S U B R O U T I N E =======================================
.text$mn:00002448
.text$mn:00002448 ; Attributes: bp-based frame
.text$mn:00002448
.text$mn:00002448 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:00002448                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:00002448 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:00002448                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:00002448                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:00002448
.text$mn:00002448 var_4           = dword ptr -4
.text$mn:00002448 arg_0           = dword ptr  8
.text$mn:00002448
.text$mn:00002448                 push    ebp
.text$mn:00002449                 mov     ebp, esp
.text$mn:0000244B                 push    ecx
.text$mn:0000244C                 mov     [ebp+var_4], ecx
.text$mn:0000244F                 mov     eax, [ebp+arg_0]
.text$mn:00002452                 push    eax
.text$mn:00002453                 mov     ecx, [ebp+var_4]
.text$mn:00002456                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:0000245B                 mov     esp, ebp
.text$mn:0000245D                 pop     ebp
.text$mn:0000245E                 retn    4
.text$mn:0000245E ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:0000245E
.text$mn:0000245E ; ---------------------------------------------------------------------------
.text$mn:00002461                 align 4
.text$mn:00002461 _text$mn        ends
.text$mn:00002461
.text$mn:00002464 ; ===========================================================================
.text$mn:00002464
.text$mn:00002464 ; Segment type: Pure code
.text$mn:00002464 ; Segment permissions: Read/Execute
.text$mn:00002464 _text$mn        segment para public 'CODE' use32
.text$mn:00002464                 assume cs:_text$mn
.text$mn:00002464                 ;org 2464h
.text$mn:00002464 ; COMDAT (pick any)
.text$mn:00002464                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002464
.text$mn:00002464 ; =============== S U B R O U T I N E =======================================
.text$mn:00002464
.text$mn:00002464 ; Attributes: bp-based frame
.text$mn:00002464
.text$mn:00002464 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00002464                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00002464 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00002464                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00002464
.text$mn:00002464 var_4           = dword ptr -4
.text$mn:00002464 arg_0           = dword ptr  8
.text$mn:00002464
.text$mn:00002464                 push    ebp
.text$mn:00002465                 mov     ebp, esp
.text$mn:00002467                 push    ecx
.text$mn:00002468                 mov     [ebp+var_4], ecx
.text$mn:0000246B                 push    0
.text$mn:0000246D                 mov     eax, [ebp+arg_0]
.text$mn:00002470                 push    eax
.text$mn:00002471                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00002476                 add     esp, 8
.text$mn:00002479                 mov     esp, ebp
.text$mn:0000247B                 pop     ebp
.text$mn:0000247C                 retn    4
.text$mn:0000247C ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:0000247C
.text$mn:0000247C ; ---------------------------------------------------------------------------
.text$mn:0000247F                 align 10h
.text$mn:0000247F _text$mn        ends
.text$mn:0000247F
.text$mn:00002480 ; ===========================================================================
.text$mn:00002480
.text$mn:00002480 ; Segment type: Pure code
.text$mn:00002480 ; Segment permissions: Read/Execute
.text$mn:00002480 _text$mn        segment para public 'CODE' use32
.text$mn:00002480                 assume cs:_text$mn
.text$mn:00002480                 ;org 2480h
.text$mn:00002480 ; COMDAT (pick any)
.text$mn:00002480                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002480
.text$mn:00002480 ; =============== S U B R O U T I N E =======================================
.text$mn:00002480
.text$mn:00002480 ; Attributes: bp-based frame
.text$mn:00002480
.text$mn:00002480 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00002480                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00002480 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00002480                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00002480                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p
.text$mn:00002480
.text$mn:00002480 var_4           = dword ptr -4
.text$mn:00002480 arg_0           = dword ptr  8
.text$mn:00002480
.text$mn:00002480                 push    ebp
.text$mn:00002481                 mov     ebp, esp
.text$mn:00002483                 push    ecx
.text$mn:00002484                 mov     [ebp+var_4], ecx
.text$mn:00002487                 push    0
.text$mn:00002489                 mov     eax, [ebp+arg_0]
.text$mn:0000248C                 push    eax
.text$mn:0000248D                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00002492                 add     esp, 8
.text$mn:00002495                 mov     esp, ebp
.text$mn:00002497                 pop     ebp
.text$mn:00002498                 retn    4
.text$mn:00002498 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00002498
.text$mn:00002498 ; ---------------------------------------------------------------------------
.text$mn:0000249B                 align 4
.text$mn:0000249B _text$mn        ends
.text$mn:0000249B
.text$mn:0000249C ; ===========================================================================
.text$mn:0000249C
.text$mn:0000249C ; Segment type: Pure code
.text$mn:0000249C ; Segment permissions: Read/Execute
.text$mn:0000249C _text$mn        segment para public 'CODE' use32
.text$mn:0000249C                 assume cs:_text$mn
.text$mn:0000249C                 ;org 249Ch
.text$mn:0000249C ; COMDAT (pick any)
.text$mn:0000249C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000249C
.text$mn:0000249C ; =============== S U B R O U T I N E =======================================
.text$mn:0000249C
.text$mn:0000249C ; Attributes: bp-based frame
.text$mn:0000249C
.text$mn:0000249C ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:0000249C                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:0000249C ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:0000249C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:0000249C
.text$mn:0000249C var_4           = dword ptr -4
.text$mn:0000249C arg_0           = dword ptr  8
.text$mn:0000249C
.text$mn:0000249C                 push    ebp
.text$mn:0000249D                 mov     ebp, esp
.text$mn:0000249F                 push    ecx
.text$mn:000024A0                 mov     [ebp+var_4], ecx
.text$mn:000024A3                 push    0
.text$mn:000024A5                 mov     eax, [ebp+arg_0]
.text$mn:000024A8                 push    eax
.text$mn:000024A9                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:000024AE                 add     esp, 8
.text$mn:000024B1                 mov     esp, ebp
.text$mn:000024B3                 pop     ebp
.text$mn:000024B4                 retn    4
.text$mn:000024B4 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:000024B4
.text$mn:000024B4 ; ---------------------------------------------------------------------------
.text$mn:000024B7                 align 4
.text$mn:000024B7 _text$mn        ends
.text$mn:000024B7
.text$mn:000024B8 ; ===========================================================================
.text$mn:000024B8
.text$mn:000024B8 ; Segment type: Pure code
.text$mn:000024B8 ; Segment permissions: Read/Execute
.text$mn:000024B8 _text$mn        segment para public 'CODE' use32
.text$mn:000024B8                 assume cs:_text$mn
.text$mn:000024B8                 ;org 24B8h
.text$mn:000024B8 ; COMDAT (pick any)
.text$mn:000024B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024B8
.text$mn:000024B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000024B8
.text$mn:000024B8 ; Attributes: bp-based frame
.text$mn:000024B8
.text$mn:000024B8 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:000024B8                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:000024B8 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:000024B8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+53p
.text$mn:000024B8
.text$mn:000024B8 var_8           = dword ptr -8
.text$mn:000024B8 var_4           = dword ptr -4
.text$mn:000024B8 arg_0           = dword ptr  8
.text$mn:000024B8 arg_4           = dword ptr  0Ch
.text$mn:000024B8 arg_8           = dword ptr  10h
.text$mn:000024B8
.text$mn:000024B8                 push    ebp
.text$mn:000024B9                 mov     ebp, esp
.text$mn:000024BB                 sub     esp, 8
.text$mn:000024BE                 mov     [ebp+var_4], ecx
.text$mn:000024C1                 mov     ecx, [ebp+arg_0]
.text$mn:000024C4                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:000024C9                 cmp     eax, [ebp+arg_4]
.text$mn:000024CC                 jnb     short loc_24D6
.text$mn:000024CE                 mov     ecx, [ebp+var_4]
.text$mn:000024D1                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:000024D6
.text$mn:000024D6 loc_24D6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:000024D6                 mov     ecx, [ebp+arg_0]
.text$mn:000024D9                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:000024DE                 sub     eax, [ebp+arg_4]
.text$mn:000024E1                 mov     [ebp+var_8], eax
.text$mn:000024E4                 mov     eax, [ebp+var_8]
.text$mn:000024E7                 cmp     eax, [ebp+arg_8]
.text$mn:000024EA                 jnb     short loc_24F2
.text$mn:000024EC                 mov     ecx, [ebp+var_8]
.text$mn:000024EF                 mov     [ebp+arg_8], ecx
.text$mn:000024F2
.text$mn:000024F2 loc_24F2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:000024F2                 mov     edx, [ebp+var_4]
.text$mn:000024F5                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:000024FA                 sub     eax, [edx+14h]
.text$mn:000024FD                 cmp     eax, [ebp+arg_8]
.text$mn:00002500                 ja      short loc_250A
.text$mn:00002502                 mov     ecx, [ebp+var_4]
.text$mn:00002505                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000250A
.text$mn:0000250A loc_250A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+48j
.text$mn:0000250A                 cmp     [ebp+arg_8], 0
.text$mn:0000250E                 jbe     short loc_256A
.text$mn:00002510                 mov     ecx, [ebp+var_4]
.text$mn:00002513                 mov     edx, [ecx+14h]
.text$mn:00002516                 add     edx, [ebp+arg_8]
.text$mn:00002519                 mov     [ebp+var_8], edx
.text$mn:0000251C                 push    0
.text$mn:0000251E                 mov     eax, [ebp+var_8]
.text$mn:00002521                 push    eax
.text$mn:00002522                 mov     ecx, [ebp+var_4]
.text$mn:00002525                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000252A                 movzx   ecx, al
.text$mn:0000252D                 test    ecx, ecx
.text$mn:0000252F                 jz      short loc_256A
.text$mn:00002531                 mov     edx, [ebp+arg_8]
.text$mn:00002534                 push    edx             ; int
.text$mn:00002535                 mov     ecx, [ebp+arg_0]
.text$mn:00002538                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000253D                 mov     ecx, [ebp+arg_4]
.text$mn:00002540                 lea     edx, [eax+ecx*2]
.text$mn:00002543                 push    edx             ; Src
.text$mn:00002544                 mov     ecx, [ebp+var_4]
.text$mn:00002547                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000254C                 mov     ecx, [ebp+var_4]
.text$mn:0000254F                 mov     edx, [ecx+14h]
.text$mn:00002552                 lea     eax, [eax+edx*2]
.text$mn:00002555                 push    eax             ; Dst
.text$mn:00002556                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000255B                 add     esp, 0Ch
.text$mn:0000255E                 mov     ecx, [ebp+var_8]
.text$mn:00002561                 push    ecx
.text$mn:00002562                 mov     ecx, [ebp+var_4]
.text$mn:00002565                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000256A
.text$mn:0000256A loc_256A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+56j
.text$mn:0000256A                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+77j
.text$mn:0000256A                 mov     eax, [ebp+var_4]
.text$mn:0000256D                 mov     esp, ebp
.text$mn:0000256F                 pop     ebp
.text$mn:00002570                 retn    0Ch
.text$mn:00002570 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00002570
.text$mn:00002570 ; ---------------------------------------------------------------------------
.text$mn:00002573                 align 4
.text$mn:00002573 _text$mn        ends
.text$mn:00002573
.text$mn:00002574 ; ===========================================================================
.text$mn:00002574
.text$mn:00002574 ; Segment type: Pure code
.text$mn:00002574 ; Segment permissions: Read/Execute
.text$mn:00002574 _text$mn        segment para public 'CODE' use32
.text$mn:00002574                 assume cs:_text$mn
.text$mn:00002574                 ;org 2574h
.text$mn:00002574 ; COMDAT (pick any)
.text$mn:00002574                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002574
.text$mn:00002574 ; =============== S U B R O U T I N E =======================================
.text$mn:00002574
.text$mn:00002574 ; Attributes: bp-based frame
.text$mn:00002574
.text$mn:00002574 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t *Str)
.text$mn:00002574                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:00002574 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:00002574                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)+Ep
.text$mn:00002574
.text$mn:00002574 var_4           = dword ptr -4
.text$mn:00002574 Str             = dword ptr  8
.text$mn:00002574
.text$mn:00002574                 push    ebp
.text$mn:00002575                 mov     ebp, esp
.text$mn:00002577                 push    ecx
.text$mn:00002578                 mov     [ebp+var_4], ecx
.text$mn:0000257B                 push    43Eh            ; unsigned int
.text$mn:00002580                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002585                 mov     eax, [ebp+Str]
.text$mn:00002588                 push    eax             ; int
.text$mn:00002589                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:0000258E                 add     esp, 0Ch
.text$mn:00002591                 mov     ecx, [ebp+Str]
.text$mn:00002594                 push    ecx             ; Str
.text$mn:00002595                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:0000259A                 add     esp, 4
.text$mn:0000259D                 push    eax             ; int
.text$mn:0000259E                 mov     edx, [ebp+Str]
.text$mn:000025A1                 push    edx             ; Src
.text$mn:000025A2                 mov     ecx, [ebp+var_4]
.text$mn:000025A5                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)
.text$mn:000025AA                 mov     esp, ebp
.text$mn:000025AC                 pop     ebp
.text$mn:000025AD                 retn    4
.text$mn:000025AD ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:000025AD
.text$mn:000025AD _text$mn        ends
.text$mn:000025AD
.text$mn:000025B0 ; ===========================================================================
.text$mn:000025B0
.text$mn:000025B0 ; Segment type: Pure code
.text$mn:000025B0 ; Segment permissions: Read/Execute
.text$mn:000025B0 _text$mn        segment para public 'CODE' use32
.text$mn:000025B0                 assume cs:_text$mn
.text$mn:000025B0                 ;org 25B0h
.text$mn:000025B0 ; COMDAT (pick any)
.text$mn:000025B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025B0
.text$mn:000025B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025B0
.text$mn:000025B0 ; Attributes: bp-based frame
.text$mn:000025B0
.text$mn:000025B0 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(void *Src, int)
.text$mn:000025B0                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:000025B0 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:000025B0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+31p
.text$mn:000025B0
.text$mn:000025B0 var_8           = dword ptr -8
.text$mn:000025B0 var_4           = dword ptr -4
.text$mn:000025B0 Src             = dword ptr  8
.text$mn:000025B0 arg_4           = dword ptr  0Ch
.text$mn:000025B0
.text$mn:000025B0                 push    ebp
.text$mn:000025B1                 mov     ebp, esp
.text$mn:000025B3                 sub     esp, 8
.text$mn:000025B6                 mov     [ebp+var_4], ecx
.text$mn:000025B9                 cmp     [ebp+arg_4], 0
.text$mn:000025BD                 jz      short loc_25D5
.text$mn:000025BF                 push    42Ah            ; unsigned int
.text$mn:000025C4                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000025C9                 mov     eax, [ebp+Src]
.text$mn:000025CC                 push    eax             ; int
.text$mn:000025CD                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000025D2                 add     esp, 0Ch
.text$mn:000025D5
.text$mn:000025D5 loc_25D5:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+Dj
.text$mn:000025D5                 mov     ecx, [ebp+Src]
.text$mn:000025D8                 push    ecx
.text$mn:000025D9                 mov     ecx, [ebp+var_4]
.text$mn:000025DC                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:000025E1                 movzx   edx, al
.text$mn:000025E4                 test    edx, edx
.text$mn:000025E6                 jz      short loc_260A
.text$mn:000025E8                 mov     eax, [ebp+arg_4]
.text$mn:000025EB                 push    eax
.text$mn:000025EC                 mov     ecx, [ebp+var_4]
.text$mn:000025EF                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000025F4                 mov     ecx, [ebp+Src]
.text$mn:000025F7                 sub     ecx, eax
.text$mn:000025F9                 sar     ecx, 1
.text$mn:000025FB                 push    ecx
.text$mn:000025FC                 mov     edx, [ebp+var_4]
.text$mn:000025FF                 push    edx
.text$mn:00002600                 mov     ecx, [ebp+var_4]
.text$mn:00002603                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00002608                 jmp     short loc_267B
.text$mn:0000260A ; ---------------------------------------------------------------------------
.text$mn:0000260A
.text$mn:0000260A loc_260A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+36j
.text$mn:0000260A                 mov     eax, [ebp+var_4]
.text$mn:0000260D                 mov     ecx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00002613                 sub     ecx, [eax+14h]
.text$mn:00002616                 cmp     ecx, [ebp+arg_4]
.text$mn:00002619                 ja      short loc_2623
.text$mn:0000261B                 mov     ecx, [ebp+var_4]
.text$mn:0000261E                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00002623
.text$mn:00002623 loc_2623:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+69j
.text$mn:00002623                 cmp     [ebp+arg_4], 0
.text$mn:00002627                 jbe     short loc_2678
.text$mn:00002629                 mov     edx, [ebp+var_4]
.text$mn:0000262C                 mov     eax, [edx+14h]
.text$mn:0000262F                 add     eax, [ebp+arg_4]
.text$mn:00002632                 mov     [ebp+var_8], eax
.text$mn:00002635                 push    0
.text$mn:00002637                 mov     ecx, [ebp+var_8]
.text$mn:0000263A                 push    ecx
.text$mn:0000263B                 mov     ecx, [ebp+var_4]
.text$mn:0000263E                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00002643                 movzx   edx, al
.text$mn:00002646                 test    edx, edx
.text$mn:00002648                 jz      short loc_2678
.text$mn:0000264A                 mov     eax, [ebp+arg_4]
.text$mn:0000264D                 push    eax             ; int
.text$mn:0000264E                 mov     ecx, [ebp+Src]
.text$mn:00002651                 push    ecx             ; Src
.text$mn:00002652                 mov     ecx, [ebp+var_4]
.text$mn:00002655                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000265A                 mov     edx, [ebp+var_4]
.text$mn:0000265D                 mov     ecx, [edx+14h]
.text$mn:00002660                 lea     edx, [eax+ecx*2]
.text$mn:00002663                 push    edx             ; Dst
.text$mn:00002664                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00002669                 add     esp, 0Ch
.text$mn:0000266C                 mov     eax, [ebp+var_8]
.text$mn:0000266F                 push    eax
.text$mn:00002670                 mov     ecx, [ebp+var_4]
.text$mn:00002673                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00002678
.text$mn:00002678 loc_2678:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+77j
.text$mn:00002678                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+98j
.text$mn:00002678                 mov     eax, [ebp+var_4]
.text$mn:0000267B
.text$mn:0000267B loc_267B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+58j
.text$mn:0000267B                 mov     esp, ebp
.text$mn:0000267D                 pop     ebp
.text$mn:0000267E                 retn    8
.text$mn:0000267E ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:0000267E
.text$mn:0000267E ; ---------------------------------------------------------------------------
.text$mn:00002681                 align 4
.text$mn:00002681 _text$mn        ends
.text$mn:00002681
.text$mn:00002684 ; ===========================================================================
.text$mn:00002684
.text$mn:00002684 ; Segment type: Pure code
.text$mn:00002684 ; Segment permissions: Read/Execute
.text$mn:00002684 _text$mn        segment para public 'CODE' use32
.text$mn:00002684                 assume cs:_text$mn
.text$mn:00002684                 ;org 2684h
.text$mn:00002684 ; COMDAT (pick any)
.text$mn:00002684                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002684
.text$mn:00002684 ; =============== S U B R O U T I N E =======================================
.text$mn:00002684
.text$mn:00002684 ; Attributes: bp-based frame
.text$mn:00002684
.text$mn:00002684 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00002684                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00002684 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00002684                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00002684
.text$mn:00002684 Size            = dword ptr -8
.text$mn:00002684 var_4           = dword ptr -4
.text$mn:00002684 arg_0           = dword ptr  8
.text$mn:00002684 arg_4           = dword ptr  0Ch
.text$mn:00002684 arg_8           = dword ptr  10h
.text$mn:00002684
.text$mn:00002684                 push    ebp
.text$mn:00002685                 mov     ebp, esp
.text$mn:00002687                 sub     esp, 8
.text$mn:0000268A                 mov     [ebp+var_4], ecx
.text$mn:0000268D                 mov     ecx, [ebp+arg_0]
.text$mn:00002690                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00002695                 cmp     eax, [ebp+arg_4]
.text$mn:00002698                 jnb     short loc_26A2
.text$mn:0000269A                 mov     ecx, [ebp+var_4]
.text$mn:0000269D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000026A2
.text$mn:000026A2 loc_26A2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:000026A2                 mov     ecx, [ebp+arg_0]
.text$mn:000026A5                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000026AA                 sub     eax, [ebp+arg_4]
.text$mn:000026AD                 mov     [ebp+Size], eax
.text$mn:000026B0                 mov     eax, [ebp+arg_8]
.text$mn:000026B3                 cmp     eax, [ebp+Size]
.text$mn:000026B6                 jnb     short loc_26BE
.text$mn:000026B8                 mov     ecx, [ebp+arg_8]
.text$mn:000026BB                 mov     [ebp+Size], ecx
.text$mn:000026BE
.text$mn:000026BE loc_26BE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:000026BE                 mov     edx, [ebp+var_4]
.text$mn:000026C1                 cmp     edx, [ebp+arg_0]
.text$mn:000026C4                 jnz     short loc_26E5
.text$mn:000026C6                 mov     eax, [ebp+arg_4]
.text$mn:000026C9                 add     eax, [ebp+Size]
.text$mn:000026CC                 push    eax
.text$mn:000026CD                 mov     ecx, [ebp+var_4]
.text$mn:000026D0                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:000026D5                 mov     ecx, [ebp+arg_4]
.text$mn:000026D8                 push    ecx
.text$mn:000026D9                 push    0
.text$mn:000026DB                 mov     ecx, [ebp+var_4]
.text$mn:000026DE                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000026E3                 jmp     short loc_2727
.text$mn:000026E5 ; ---------------------------------------------------------------------------
.text$mn:000026E5
.text$mn:000026E5 loc_26E5:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000026E5                 push    0
.text$mn:000026E7                 mov     edx, [ebp+Size]
.text$mn:000026EA                 push    edx
.text$mn:000026EB                 mov     ecx, [ebp+var_4]
.text$mn:000026EE                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000026F3                 movzx   eax, al
.text$mn:000026F6                 test    eax, eax
.text$mn:000026F8                 jz      short loc_2727
.text$mn:000026FA                 mov     ecx, [ebp+Size]
.text$mn:000026FD                 push    ecx             ; Size
.text$mn:000026FE                 mov     ecx, [ebp+arg_0]
.text$mn:00002701                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002706                 add     eax, [ebp+arg_4]
.text$mn:00002709                 push    eax             ; Src
.text$mn:0000270A                 mov     ecx, [ebp+var_4]
.text$mn:0000270D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002712                 push    eax             ; Dst
.text$mn:00002713                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002718                 add     esp, 0Ch
.text$mn:0000271B                 mov     edx, [ebp+Size]
.text$mn:0000271E                 push    edx
.text$mn:0000271F                 mov     ecx, [ebp+var_4]
.text$mn:00002722                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002727
.text$mn:00002727 loc_2727:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00002727                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00002727                 mov     eax, [ebp+var_4]
.text$mn:0000272A                 mov     esp, ebp
.text$mn:0000272C                 pop     ebp
.text$mn:0000272D                 retn    0Ch
.text$mn:0000272D ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000272D
.text$mn:0000272D _text$mn        ends
.text$mn:0000272D
.text$mn:00002730 ; ===========================================================================
.text$mn:00002730
.text$mn:00002730 ; Segment type: Pure code
.text$mn:00002730 ; Segment permissions: Read/Execute
.text$mn:00002730 _text$mn        segment para public 'CODE' use32
.text$mn:00002730                 assume cs:_text$mn
.text$mn:00002730                 ;org 2730h
.text$mn:00002730 ; COMDAT (pick any)
.text$mn:00002730                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002730
.text$mn:00002730 ; =============== S U B R O U T I N E =======================================
.text$mn:00002730
.text$mn:00002730 ; Attributes: bp-based frame
.text$mn:00002730
.text$mn:00002730 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00002730                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00002730 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00002730                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00002730
.text$mn:00002730 var_4           = dword ptr -4
.text$mn:00002730 Str             = dword ptr  8
.text$mn:00002730
.text$mn:00002730                 push    ebp
.text$mn:00002731                 mov     ebp, esp
.text$mn:00002733                 push    ecx
.text$mn:00002734                 mov     [ebp+var_4], ecx
.text$mn:00002737                 push    490h            ; unsigned int
.text$mn:0000273C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002741                 mov     eax, [ebp+Str]
.text$mn:00002744                 push    eax             ; int
.text$mn:00002745                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000274A                 add     esp, 0Ch
.text$mn:0000274D                 mov     ecx, [ebp+Str]
.text$mn:00002750                 push    ecx             ; Str
.text$mn:00002751                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00002756                 add     esp, 4
.text$mn:00002759                 push    eax             ; Size
.text$mn:0000275A                 mov     edx, [ebp+Str]
.text$mn:0000275D                 push    edx             ; Src
.text$mn:0000275E                 mov     ecx, [ebp+var_4]
.text$mn:00002761                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00002766                 mov     esp, ebp
.text$mn:00002768                 pop     ebp
.text$mn:00002769                 retn    4
.text$mn:00002769 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00002769
.text$mn:00002769 _text$mn        ends
.text$mn:00002769
.text$mn:0000276C ; ===========================================================================
.text$mn:0000276C
.text$mn:0000276C ; Segment type: Pure code
.text$mn:0000276C ; Segment permissions: Read/Execute
.text$mn:0000276C _text$mn        segment para public 'CODE' use32
.text$mn:0000276C                 assume cs:_text$mn
.text$mn:0000276C                 ;org 276Ch
.text$mn:0000276C ; COMDAT (pick any)
.text$mn:0000276C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000276C
.text$mn:0000276C ; =============== S U B R O U T I N E =======================================
.text$mn:0000276C
.text$mn:0000276C ; Attributes: bp-based frame
.text$mn:0000276C
.text$mn:0000276C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:0000276C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:0000276C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:0000276C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:0000276C
.text$mn:0000276C var_4           = dword ptr -4
.text$mn:0000276C Src             = dword ptr  8
.text$mn:0000276C Size            = dword ptr  0Ch
.text$mn:0000276C
.text$mn:0000276C                 push    ebp
.text$mn:0000276D                 mov     ebp, esp
.text$mn:0000276F                 push    ecx
.text$mn:00002770                 mov     [ebp+var_4], ecx
.text$mn:00002773                 cmp     [ebp+Size], 0
.text$mn:00002777                 jz      short loc_278F
.text$mn:00002779                 push    47Fh            ; unsigned int
.text$mn:0000277E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002783                 mov     eax, [ebp+Src]
.text$mn:00002786                 push    eax             ; int
.text$mn:00002787                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000278C                 add     esp, 0Ch
.text$mn:0000278F
.text$mn:0000278F loc_278F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000278F                 mov     ecx, [ebp+Src]
.text$mn:00002792                 push    ecx
.text$mn:00002793                 mov     ecx, [ebp+var_4]
.text$mn:00002796                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000279B                 movzx   edx, al
.text$mn:0000279E                 test    edx, edx
.text$mn:000027A0                 jz      short loc_27C2
.text$mn:000027A2                 mov     eax, [ebp+Size]
.text$mn:000027A5                 push    eax
.text$mn:000027A6                 mov     ecx, [ebp+var_4]
.text$mn:000027A9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000027AE                 mov     ecx, [ebp+Src]
.text$mn:000027B1                 sub     ecx, eax
.text$mn:000027B3                 push    ecx
.text$mn:000027B4                 mov     edx, [ebp+var_4]
.text$mn:000027B7                 push    edx
.text$mn:000027B8                 mov     ecx, [ebp+var_4]
.text$mn:000027BB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:000027C0                 jmp     short loc_27FF
.text$mn:000027C2 ; ---------------------------------------------------------------------------
.text$mn:000027C2
.text$mn:000027C2 loc_27C2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:000027C2                 push    0
.text$mn:000027C4                 mov     eax, [ebp+Size]
.text$mn:000027C7                 push    eax
.text$mn:000027C8                 mov     ecx, [ebp+var_4]
.text$mn:000027CB                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000027D0                 movzx   ecx, al
.text$mn:000027D3                 test    ecx, ecx
.text$mn:000027D5                 jz      short loc_27FC
.text$mn:000027D7                 mov     edx, [ebp+Size]
.text$mn:000027DA                 push    edx             ; Size
.text$mn:000027DB                 mov     eax, [ebp+Src]
.text$mn:000027DE                 push    eax             ; Src
.text$mn:000027DF                 mov     ecx, [ebp+var_4]
.text$mn:000027E2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000027E7                 push    eax             ; Dst
.text$mn:000027E8                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000027ED                 add     esp, 0Ch
.text$mn:000027F0                 mov     ecx, [ebp+Size]
.text$mn:000027F3                 push    ecx
.text$mn:000027F4                 mov     ecx, [ebp+var_4]
.text$mn:000027F7                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000027FC
.text$mn:000027FC loc_27FC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:000027FC                 mov     eax, [ebp+var_4]
.text$mn:000027FF
.text$mn:000027FF loc_27FF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:000027FF                 mov     esp, ebp
.text$mn:00002801                 pop     ebp
.text$mn:00002802                 retn    8
.text$mn:00002802 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00002802
.text$mn:00002802 ; ---------------------------------------------------------------------------
.text$mn:00002805                 align 4
.text$mn:00002805 _text$mn        ends
.text$mn:00002805
.text$mn:00002808 ; ===========================================================================
.text$mn:00002808
.text$mn:00002808 ; Segment type: Pure code
.text$mn:00002808 ; Segment permissions: Read/Execute
.text$mn:00002808 _text$mn        segment para public 'CODE' use32
.text$mn:00002808                 assume cs:_text$mn
.text$mn:00002808                 ;org 2808h
.text$mn:00002808 ; COMDAT (pick any)
.text$mn:00002808                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002808
.text$mn:00002808 ; =============== S U B R O U T I N E =======================================
.text$mn:00002808
.text$mn:00002808 ; Attributes: bp-based frame
.text$mn:00002808
.text$mn:00002808 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:00002808                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00002808 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00002808                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+51p
.text$mn:00002808
.text$mn:00002808 var_8           = dword ptr -8
.text$mn:00002808 var_4           = dword ptr -4
.text$mn:00002808 arg_0           = dword ptr  8
.text$mn:00002808 arg_4           = dword ptr  0Ch
.text$mn:00002808 arg_8           = dword ptr  10h
.text$mn:00002808
.text$mn:00002808                 push    ebp
.text$mn:00002809                 mov     ebp, esp
.text$mn:0000280B                 sub     esp, 8
.text$mn:0000280E                 mov     [ebp+var_4], ecx
.text$mn:00002811                 mov     ecx, [ebp+arg_0]
.text$mn:00002814                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00002819                 cmp     eax, [ebp+arg_4]
.text$mn:0000281C                 jnb     short loc_2826
.text$mn:0000281E                 mov     ecx, [ebp+var_4]
.text$mn:00002821                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00002826
.text$mn:00002826 loc_2826:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:00002826                 mov     ecx, [ebp+arg_0]
.text$mn:00002829                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000282E                 sub     eax, [ebp+arg_4]
.text$mn:00002831                 mov     [ebp+var_8], eax
.text$mn:00002834                 mov     eax, [ebp+arg_8]
.text$mn:00002837                 cmp     eax, [ebp+var_8]
.text$mn:0000283A                 jnb     short loc_2842
.text$mn:0000283C                 mov     ecx, [ebp+arg_8]
.text$mn:0000283F                 mov     [ebp+var_8], ecx
.text$mn:00002842
.text$mn:00002842 loc_2842:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:00002842                 mov     edx, [ebp+var_4]
.text$mn:00002845                 cmp     edx, [ebp+arg_0]
.text$mn:00002848                 jnz     short loc_2869
.text$mn:0000284A                 mov     eax, [ebp+arg_4]
.text$mn:0000284D                 add     eax, [ebp+var_8]
.text$mn:00002850                 push    eax
.text$mn:00002851                 mov     ecx, [ebp+var_4]
.text$mn:00002854                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00002859                 mov     ecx, [ebp+arg_4]
.text$mn:0000285C                 push    ecx
.text$mn:0000285D                 push    0
.text$mn:0000285F                 mov     ecx, [ebp+var_4]
.text$mn:00002862                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:00002867                 jmp     short loc_28AE
.text$mn:00002869 ; ---------------------------------------------------------------------------
.text$mn:00002869
.text$mn:00002869 loc_2869:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:00002869                 push    0
.text$mn:0000286B                 mov     edx, [ebp+var_8]
.text$mn:0000286E                 push    edx
.text$mn:0000286F                 mov     ecx, [ebp+var_4]
.text$mn:00002872                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00002877                 movzx   eax, al
.text$mn:0000287A                 test    eax, eax
.text$mn:0000287C                 jz      short loc_28AE
.text$mn:0000287E                 mov     ecx, [ebp+var_8]
.text$mn:00002881                 push    ecx             ; int
.text$mn:00002882                 mov     ecx, [ebp+arg_0]
.text$mn:00002885                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000288A                 mov     edx, [ebp+arg_4]
.text$mn:0000288D                 lea     eax, [eax+edx*2]
.text$mn:00002890                 push    eax             ; Src
.text$mn:00002891                 mov     ecx, [ebp+var_4]
.text$mn:00002894                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002899                 push    eax             ; Dst
.text$mn:0000289A                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000289F                 add     esp, 0Ch
.text$mn:000028A2                 mov     ecx, [ebp+var_8]
.text$mn:000028A5                 push    ecx
.text$mn:000028A6                 mov     ecx, [ebp+var_4]
.text$mn:000028A9                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000028AE
.text$mn:000028AE loc_28AE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:000028AE                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:000028AE                 mov     eax, [ebp+var_4]
.text$mn:000028B1                 mov     esp, ebp
.text$mn:000028B3                 pop     ebp
.text$mn:000028B4                 retn    0Ch
.text$mn:000028B4 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000028B4
.text$mn:000028B4 ; ---------------------------------------------------------------------------
.text$mn:000028B7                 align 4
.text$mn:000028B7 _text$mn        ends
.text$mn:000028B7
.text$mn:000028B8 ; ===========================================================================
.text$mn:000028B8
.text$mn:000028B8 ; Segment type: Pure code
.text$mn:000028B8 ; Segment permissions: Read/Execute
.text$mn:000028B8 _text$mn        segment para public 'CODE' use32
.text$mn:000028B8                 assume cs:_text$mn
.text$mn:000028B8                 ;org 28B8h
.text$mn:000028B8 ; COMDAT (pick any)
.text$mn:000028B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028B8
.text$mn:000028B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000028B8
.text$mn:000028B8 ; Attributes: bp-based frame
.text$mn:000028B8
.text$mn:000028B8 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:000028B8                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:000028B8 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:000028B8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:000028B8
.text$mn:000028B8 var_4           = dword ptr -4
.text$mn:000028B8 Str             = dword ptr  8
.text$mn:000028B8
.text$mn:000028B8                 push    ebp
.text$mn:000028B9                 mov     ebp, esp
.text$mn:000028BB                 push    ecx
.text$mn:000028BC                 mov     [ebp+var_4], ecx
.text$mn:000028BF                 push    490h            ; unsigned int
.text$mn:000028C4                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000028C9                 mov     eax, [ebp+Str]
.text$mn:000028CC                 push    eax             ; int
.text$mn:000028CD                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000028D2                 add     esp, 0Ch
.text$mn:000028D5                 mov     ecx, [ebp+Str]
.text$mn:000028D8                 push    ecx             ; Str
.text$mn:000028D9                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:000028DE                 add     esp, 4
.text$mn:000028E1                 push    eax             ; int
.text$mn:000028E2                 mov     edx, [ebp+Str]
.text$mn:000028E5                 push    edx             ; Src
.text$mn:000028E6                 mov     ecx, [ebp+var_4]
.text$mn:000028E9                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:000028EE                 mov     esp, ebp
.text$mn:000028F0                 pop     ebp
.text$mn:000028F1                 retn    4
.text$mn:000028F1 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:000028F1
.text$mn:000028F1 _text$mn        ends
.text$mn:000028F1
.text$mn:000028F4 ; ===========================================================================
.text$mn:000028F4
.text$mn:000028F4 ; Segment type: Pure code
.text$mn:000028F4 ; Segment permissions: Read/Execute
.text$mn:000028F4 _text$mn        segment para public 'CODE' use32
.text$mn:000028F4                 assume cs:_text$mn
.text$mn:000028F4                 ;org 28F4h
.text$mn:000028F4 ; COMDAT (pick any)
.text$mn:000028F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028F4
.text$mn:000028F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000028F4
.text$mn:000028F4 ; Attributes: bp-based frame
.text$mn:000028F4
.text$mn:000028F4 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:000028F4                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:000028F4 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:000028F4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:000028F4
.text$mn:000028F4 var_4           = dword ptr -4
.text$mn:000028F4 Src             = dword ptr  8
.text$mn:000028F4 arg_4           = dword ptr  0Ch
.text$mn:000028F4
.text$mn:000028F4                 push    ebp
.text$mn:000028F5                 mov     ebp, esp
.text$mn:000028F7                 push    ecx
.text$mn:000028F8                 mov     [ebp+var_4], ecx
.text$mn:000028FB                 cmp     [ebp+arg_4], 0
.text$mn:000028FF                 jz      short loc_2917
.text$mn:00002901                 push    47Fh            ; unsigned int
.text$mn:00002906                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000290B                 mov     eax, [ebp+Src]
.text$mn:0000290E                 push    eax             ; int
.text$mn:0000290F                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00002914                 add     esp, 0Ch
.text$mn:00002917
.text$mn:00002917 loc_2917:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:00002917                 mov     ecx, [ebp+Src]
.text$mn:0000291A                 push    ecx
.text$mn:0000291B                 mov     ecx, [ebp+var_4]
.text$mn:0000291E                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00002923                 movzx   edx, al
.text$mn:00002926                 test    edx, edx
.text$mn:00002928                 jz      short loc_294C
.text$mn:0000292A                 mov     eax, [ebp+arg_4]
.text$mn:0000292D                 push    eax
.text$mn:0000292E                 mov     ecx, [ebp+var_4]
.text$mn:00002931                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002936                 mov     ecx, [ebp+Src]
.text$mn:00002939                 sub     ecx, eax
.text$mn:0000293B                 sar     ecx, 1
.text$mn:0000293D                 push    ecx
.text$mn:0000293E                 mov     edx, [ebp+var_4]
.text$mn:00002941                 push    edx
.text$mn:00002942                 mov     ecx, [ebp+var_4]
.text$mn:00002945                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:0000294A                 jmp     short loc_2989
.text$mn:0000294C ; ---------------------------------------------------------------------------
.text$mn:0000294C
.text$mn:0000294C loc_294C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:0000294C                 push    0
.text$mn:0000294E                 mov     eax, [ebp+arg_4]
.text$mn:00002951                 push    eax
.text$mn:00002952                 mov     ecx, [ebp+var_4]
.text$mn:00002955                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000295A                 movzx   ecx, al
.text$mn:0000295D                 test    ecx, ecx
.text$mn:0000295F                 jz      short loc_2986
.text$mn:00002961                 mov     edx, [ebp+arg_4]
.text$mn:00002964                 push    edx             ; int
.text$mn:00002965                 mov     eax, [ebp+Src]
.text$mn:00002968                 push    eax             ; Src
.text$mn:00002969                 mov     ecx, [ebp+var_4]
.text$mn:0000296C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002971                 push    eax             ; Dst
.text$mn:00002972                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00002977                 add     esp, 0Ch
.text$mn:0000297A                 mov     ecx, [ebp+arg_4]
.text$mn:0000297D                 push    ecx
.text$mn:0000297E                 mov     ecx, [ebp+var_4]
.text$mn:00002981                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00002986
.text$mn:00002986 loc_2986:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:00002986                 mov     eax, [ebp+var_4]
.text$mn:00002989
.text$mn:00002989 loc_2989:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:00002989                 mov     esp, ebp
.text$mn:0000298B                 pop     ebp
.text$mn:0000298C                 retn    8
.text$mn:0000298C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:0000298C
.text$mn:0000298C ; ---------------------------------------------------------------------------
.text$mn:0000298F                 align 10h
.text$mn:0000298F _text$mn        ends
.text$mn:0000298F
.text$mn:00002990 ; ===========================================================================
.text$mn:00002990
.text$mn:00002990 ; Segment type: Pure code
.text$mn:00002990 ; Segment permissions: Read/Execute
.text$mn:00002990 _text$mn        segment para public 'CODE' use32
.text$mn:00002990                 assume cs:_text$mn
.text$mn:00002990                 ;org 2990h
.text$mn:00002990 ; COMDAT (pick any)
.text$mn:00002990                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002990
.text$mn:00002990 ; =============== S U B R O U T I N E =======================================
.text$mn:00002990
.text$mn:00002990 ; Attributes: bp-based frame
.text$mn:00002990
.text$mn:00002990 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00002990                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00002990 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00002990                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00002990
.text$mn:00002990 arg_0           = dword ptr  8
.text$mn:00002990 arg_4           = dword ptr  0Ch
.text$mn:00002990
.text$mn:00002990                 push    ebp
.text$mn:00002991                 mov     ebp, esp
.text$mn:00002993                 mov     eax, [ebp+arg_0]
.text$mn:00002996                 mov     ecx, [ebp+arg_4]
.text$mn:00002999                 mov     dl, [ecx]
.text$mn:0000299B                 mov     [eax], dl
.text$mn:0000299D                 pop     ebp
.text$mn:0000299E                 retn
.text$mn:0000299E ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:0000299E
.text$mn:0000299E ; ---------------------------------------------------------------------------
.text$mn:0000299F                 align 10h
.text$mn:0000299F _text$mn        ends
.text$mn:0000299F
.text$mn:000029A0 ; ===========================================================================
.text$mn:000029A0
.text$mn:000029A0 ; Segment type: Pure code
.text$mn:000029A0 ; Segment permissions: Read/Execute
.text$mn:000029A0 _text$mn        segment para public 'CODE' use32
.text$mn:000029A0                 assume cs:_text$mn
.text$mn:000029A0                 ;org 29A0h
.text$mn:000029A0 ; COMDAT (pick any)
.text$mn:000029A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029A0
.text$mn:000029A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000029A0
.text$mn:000029A0 ; Attributes: bp-based frame
.text$mn:000029A0
.text$mn:000029A0 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:000029A0                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:000029A0 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:000029A0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:000029A0
.text$mn:000029A0 arg_0           = dword ptr  8
.text$mn:000029A0 arg_4           = dword ptr  0Ch
.text$mn:000029A0
.text$mn:000029A0                 push    ebp
.text$mn:000029A1                 mov     ebp, esp
.text$mn:000029A3                 mov     eax, [ebp+arg_0]
.text$mn:000029A6                 mov     ecx, [ebp+arg_4]
.text$mn:000029A9                 mov     dx, [ecx]
.text$mn:000029AC                 mov     [eax], dx
.text$mn:000029AF                 pop     ebp
.text$mn:000029B0                 retn
.text$mn:000029B0 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:000029B0
.text$mn:000029B0 ; ---------------------------------------------------------------------------
.text$mn:000029B1                 align 4
.text$mn:000029B1 _text$mn        ends
.text$mn:000029B1
.text$mn:000029B4 ; ===========================================================================
.text$mn:000029B4
.text$mn:000029B4 ; Segment type: Pure code
.text$mn:000029B4 ; Segment permissions: Read/Execute
.text$mn:000029B4 _text$mn        segment para public 'CODE' use32
.text$mn:000029B4                 assume cs:_text$mn
.text$mn:000029B4                 ;org 29B4h
.text$mn:000029B4 ; COMDAT (pick any)
.text$mn:000029B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029B4
.text$mn:000029B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029B4
.text$mn:000029B4 ; Attributes: bp-based frame
.text$mn:000029B4
.text$mn:000029B4 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:000029B4                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:000029B4 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:000029B4                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+E8p
.text$mn:000029B4
.text$mn:000029B4 var_4           = dword ptr -4
.text$mn:000029B4
.text$mn:000029B4                 push    ebp
.text$mn:000029B5                 mov     ebp, esp
.text$mn:000029B7                 push    ecx
.text$mn:000029B8                 mov     [ebp+var_4], ecx
.text$mn:000029BB                 mov     ecx, [ebp+var_4]
.text$mn:000029BE                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000029C3                 mov     esp, ebp
.text$mn:000029C5                 pop     ebp
.text$mn:000029C6                 retn
.text$mn:000029C6 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:000029C6
.text$mn:000029C6 ; ---------------------------------------------------------------------------
.text$mn:000029C7                 align 4
.text$mn:000029C7 _text$mn        ends
.text$mn:000029C7
.text$mn:000029C8 ; ===========================================================================
.text$mn:000029C8
.text$mn:000029C8 ; Segment type: Pure code
.text$mn:000029C8 ; Segment permissions: Read/Execute
.text$mn:000029C8 _text$mn        segment para public 'CODE' use32
.text$mn:000029C8                 assume cs:_text$mn
.text$mn:000029C8                 ;org 29C8h
.text$mn:000029C8 ; COMDAT (pick any)
.text$mn:000029C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029C8
.text$mn:000029C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000029C8
.text$mn:000029C8 ; Attributes: bp-based frame
.text$mn:000029C8
.text$mn:000029C8 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:000029C8                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:000029C8 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000029C8                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:000029C8
.text$mn:000029C8 var_4           = dword ptr -4
.text$mn:000029C8
.text$mn:000029C8                 push    ebp
.text$mn:000029C9                 mov     ebp, esp
.text$mn:000029CB                 push    ecx
.text$mn:000029CC                 mov     [ebp+var_4], ecx
.text$mn:000029CF                 mov     eax, [ebp+var_4]
.text$mn:000029D2                 mov     eax, [eax+4]
.text$mn:000029D5                 mov     esp, ebp
.text$mn:000029D7                 pop     ebp
.text$mn:000029D8                 retn
.text$mn:000029D8 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:000029D8
.text$mn:000029D8 ; ---------------------------------------------------------------------------
.text$mn:000029D9                 align 4
.text$mn:000029D9 _text$mn        ends
.text$mn:000029D9
.text$mn:000029DC ; ===========================================================================
.text$mn:000029DC
.text$mn:000029DC ; Segment type: Pure code
.text$mn:000029DC ; Segment permissions: Read/Execute
.text$mn:000029DC _text$mn        segment para public 'CODE' use32
.text$mn:000029DC                 assume cs:_text$mn
.text$mn:000029DC                 ;org 29DCh
.text$mn:000029DC ; COMDAT (pick any)
.text$mn:000029DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029DC
.text$mn:000029DC ; =============== S U B R O U T I N E =======================================
.text$mn:000029DC
.text$mn:000029DC ; Attributes: bp-based frame
.text$mn:000029DC
.text$mn:000029DC ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:000029DC                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:000029DC ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:000029DC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:000029DC                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:000029DC
.text$mn:000029DC var_4           = dword ptr -4
.text$mn:000029DC
.text$mn:000029DC                 push    ebp
.text$mn:000029DD                 mov     ebp, esp
.text$mn:000029DF                 push    ecx
.text$mn:000029E0                 mov     [ebp+var_4], ecx
.text$mn:000029E3                 mov     eax, [ebp+var_4]
.text$mn:000029E6                 mov     eax, [eax+4]
.text$mn:000029E9                 mov     esp, ebp
.text$mn:000029EB                 pop     ebp
.text$mn:000029EC                 retn
.text$mn:000029EC ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:000029EC
.text$mn:000029EC ; ---------------------------------------------------------------------------
.text$mn:000029ED                 align 10h
.text$mn:000029ED _text$mn        ends
.text$mn:000029ED
.text$mn:000029F0 ; ===========================================================================
.text$mn:000029F0
.text$mn:000029F0 ; Segment type: Pure code
.text$mn:000029F0 ; Segment permissions: Read/Execute
.text$mn:000029F0 _text$mn        segment para public 'CODE' use32
.text$mn:000029F0                 assume cs:_text$mn
.text$mn:000029F0                 ;org 29F0h
.text$mn:000029F0 ; COMDAT (pick any)
.text$mn:000029F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029F0
.text$mn:000029F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000029F0
.text$mn:000029F0 ; Attributes: bp-based frame
.text$mn:000029F0
.text$mn:000029F0 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:000029F0                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000029F0 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:000029F0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:000029F0
.text$mn:000029F0 var_4           = dword ptr -4
.text$mn:000029F0 Dst             = dword ptr  8
.text$mn:000029F0 Src             = dword ptr  0Ch
.text$mn:000029F0 Size            = dword ptr  10h
.text$mn:000029F0
.text$mn:000029F0                 push    ebp
.text$mn:000029F1                 mov     ebp, esp
.text$mn:000029F3                 push    ecx
.text$mn:000029F4                 cmp     [ebp+Size], 0
.text$mn:000029F8                 jnz     short loc_2A02
.text$mn:000029FA                 mov     eax, [ebp+Dst]
.text$mn:000029FD                 mov     [ebp+var_4], eax
.text$mn:00002A00                 jmp     short loc_2A19
.text$mn:00002A02 ; ---------------------------------------------------------------------------
.text$mn:00002A02
.text$mn:00002A02 loc_2A02:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00002A02                 mov     ecx, [ebp+Size]
.text$mn:00002A05                 push    ecx             ; Size
.text$mn:00002A06                 mov     edx, [ebp+Src]
.text$mn:00002A09                 push    edx             ; Src
.text$mn:00002A0A                 mov     eax, [ebp+Dst]
.text$mn:00002A0D                 push    eax             ; Dst
.text$mn:00002A0E                 call    _memcpy
.text$mn:00002A13                 add     esp, 0Ch
.text$mn:00002A16                 mov     [ebp+var_4], eax
.text$mn:00002A19
.text$mn:00002A19 loc_2A19:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00002A19                 mov     eax, [ebp+var_4]
.text$mn:00002A1C                 mov     esp, ebp
.text$mn:00002A1E                 pop     ebp
.text$mn:00002A1F                 retn
.text$mn:00002A1F ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002A1F
.text$mn:00002A1F _text$mn        ends
.text$mn:00002A1F
.text$mn:00002A20 ; ===========================================================================
.text$mn:00002A20
.text$mn:00002A20 ; Segment type: Pure code
.text$mn:00002A20 ; Segment permissions: Read/Execute
.text$mn:00002A20 _text$mn        segment para public 'CODE' use32
.text$mn:00002A20                 assume cs:_text$mn
.text$mn:00002A20                 ;org 2A20h
.text$mn:00002A20 ; COMDAT (pick any)
.text$mn:00002A20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A20
.text$mn:00002A20 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A20
.text$mn:00002A20 ; Attributes: bp-based frame
.text$mn:00002A20
.text$mn:00002A20 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:00002A20                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00002A20 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00002A20                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:00002A20                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00002A20
.text$mn:00002A20 var_4           = dword ptr -4
.text$mn:00002A20 Dst             = dword ptr  8
.text$mn:00002A20 Src             = dword ptr  0Ch
.text$mn:00002A20 arg_8           = dword ptr  10h
.text$mn:00002A20
.text$mn:00002A20                 push    ebp
.text$mn:00002A21                 mov     ebp, esp
.text$mn:00002A23                 push    ecx
.text$mn:00002A24                 cmp     [ebp+arg_8], 0
.text$mn:00002A28                 jnz     short loc_2A32
.text$mn:00002A2A                 mov     eax, [ebp+Dst]
.text$mn:00002A2D                 mov     [ebp+var_4], eax
.text$mn:00002A30                 jmp     short loc_2A49
.text$mn:00002A32 ; ---------------------------------------------------------------------------
.text$mn:00002A32
.text$mn:00002A32 loc_2A32:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00002A32                 mov     ecx, [ebp+arg_8]
.text$mn:00002A35                 push    ecx             ; int
.text$mn:00002A36                 mov     edx, [ebp+Src]
.text$mn:00002A39                 push    edx             ; Src
.text$mn:00002A3A                 mov     eax, [ebp+Dst]
.text$mn:00002A3D                 push    eax             ; Dst
.text$mn:00002A3E                 call    _wmemcpy
.text$mn:00002A43                 add     esp, 0Ch
.text$mn:00002A46                 mov     [ebp+var_4], eax
.text$mn:00002A49
.text$mn:00002A49 loc_2A49:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00002A49                 mov     eax, [ebp+var_4]
.text$mn:00002A4C                 mov     esp, ebp
.text$mn:00002A4E                 pop     ebp
.text$mn:00002A4F                 retn
.text$mn:00002A4F ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00002A4F
.text$mn:00002A4F _text$mn        ends
.text$mn:00002A4F
.text$mn:00002A50 ; ===========================================================================
.text$mn:00002A50
.text$mn:00002A50 ; Segment type: Pure code
.text$mn:00002A50 ; Segment permissions: Read/Execute
.text$mn:00002A50 _text$mn        segment para public 'CODE' use32
.text$mn:00002A50                 assume cs:_text$mn
.text$mn:00002A50                 ;org 2A50h
.text$mn:00002A50 ; COMDAT (pick any)
.text$mn:00002A50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A50
.text$mn:00002A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A50
.text$mn:00002A50 ; Attributes: bp-based frame
.text$mn:00002A50
.text$mn:00002A50 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00002A50                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00002A50 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00002A50                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00002A50
.text$mn:00002A50 var_4           = dword ptr -4
.text$mn:00002A50 arg_0           = dword ptr  8
.text$mn:00002A50 arg_4           = dword ptr  0Ch
.text$mn:00002A50
.text$mn:00002A50                 push    ebp
.text$mn:00002A51                 mov     ebp, esp
.text$mn:00002A53                 push    ecx
.text$mn:00002A54                 mov     [ebp+var_4], ecx
.text$mn:00002A57                 mov     eax, [ebp+arg_4]
.text$mn:00002A5A                 push    eax             ; int
.text$mn:00002A5B                 mov     ecx, [ebp+arg_0]
.text$mn:00002A5E                 push    ecx             ; void *
.text$mn:00002A5F                 mov     ecx, [ebp+var_4]
.text$mn:00002A62                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00002A67                 mov     esp, ebp
.text$mn:00002A69                 pop     ebp
.text$mn:00002A6A                 retn    8
.text$mn:00002A6A ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00002A6A
.text$mn:00002A6A ; ---------------------------------------------------------------------------
.text$mn:00002A6D                 align 10h
.text$mn:00002A6D _text$mn        ends
.text$mn:00002A6D
.text$mn:00002A70 ; ===========================================================================
.text$mn:00002A70
.text$mn:00002A70 ; Segment type: Pure code
.text$mn:00002A70 ; Segment permissions: Read/Execute
.text$mn:00002A70 _text$mn        segment para public 'CODE' use32
.text$mn:00002A70                 assume cs:_text$mn
.text$mn:00002A70                 ;org 2A70h
.text$mn:00002A70 ; COMDAT (pick any)
.text$mn:00002A70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A70
.text$mn:00002A70 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A70
.text$mn:00002A70 ; Attributes: bp-based frame
.text$mn:00002A70
.text$mn:00002A70 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:00002A70                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:00002A70 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:00002A70                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:00002A70
.text$mn:00002A70 var_4           = dword ptr -4
.text$mn:00002A70 arg_0           = dword ptr  8
.text$mn:00002A70 arg_4           = dword ptr  0Ch
.text$mn:00002A70
.text$mn:00002A70                 push    ebp
.text$mn:00002A71                 mov     ebp, esp
.text$mn:00002A73                 push    ecx
.text$mn:00002A74                 mov     [ebp+var_4], ecx
.text$mn:00002A77                 mov     eax, [ebp+arg_4]
.text$mn:00002A7A                 push    eax             ; int
.text$mn:00002A7B                 mov     ecx, [ebp+arg_0]
.text$mn:00002A7E                 push    ecx             ; void *
.text$mn:00002A7F                 mov     ecx, [ebp+var_4]
.text$mn:00002A82                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:00002A87                 mov     esp, ebp
.text$mn:00002A89                 pop     ebp
.text$mn:00002A8A                 retn    8
.text$mn:00002A8A ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:00002A8A
.text$mn:00002A8A ; ---------------------------------------------------------------------------
.text$mn:00002A8D                 align 10h
.text$mn:00002A8D _text$mn        ends
.text$mn:00002A8D
.text$mn:00002A90 ; ===========================================================================
.text$mn:00002A90
.text$mn:00002A90 ; Segment type: Pure code
.text$mn:00002A90 ; Segment permissions: Read/Execute
.text$mn:00002A90 _text$mn        segment para public 'CODE' use32
.text$mn:00002A90                 assume cs:_text$mn
.text$mn:00002A90                 ;org 2A90h
.text$mn:00002A90 ; COMDAT (pick any)
.text$mn:00002A90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A90
.text$mn:00002A90 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A90
.text$mn:00002A90 ; Attributes: bp-based frame
.text$mn:00002A90
.text$mn:00002A90 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00002A90                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00002A90 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00002A90                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00002A90
.text$mn:00002A90 var_4           = dword ptr -4
.text$mn:00002A90 arg_0           = dword ptr  8
.text$mn:00002A90
.text$mn:00002A90                 push    ebp
.text$mn:00002A91                 mov     ebp, esp
.text$mn:00002A93                 push    ecx
.text$mn:00002A94                 mov     [ebp+var_4], ecx
.text$mn:00002A97                 mov     eax, [ebp+arg_0]
.text$mn:00002A9A                 push    eax             ; void *
.text$mn:00002A9B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002AA0                 add     esp, 4
.text$mn:00002AA3                 mov     esp, ebp
.text$mn:00002AA5                 pop     ebp
.text$mn:00002AA6                 retn    8
.text$mn:00002AA6 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00002AA6
.text$mn:00002AA6 ; ---------------------------------------------------------------------------
.text$mn:00002AA9                 align 4
.text$mn:00002AA9 _text$mn        ends
.text$mn:00002AA9
.text$mn:00002AAC ; ===========================================================================
.text$mn:00002AAC
.text$mn:00002AAC ; Segment type: Pure code
.text$mn:00002AAC ; Segment permissions: Read/Execute
.text$mn:00002AAC _text$mn        segment para public 'CODE' use32
.text$mn:00002AAC                 assume cs:_text$mn
.text$mn:00002AAC                 ;org 2AACh
.text$mn:00002AAC ; COMDAT (pick any)
.text$mn:00002AAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AAC
.text$mn:00002AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00002AAC
.text$mn:00002AAC ; Attributes: bp-based frame
.text$mn:00002AAC
.text$mn:00002AAC ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00002AAC                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00002AAC ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00002AAC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00002AAC                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p
.text$mn:00002AAC
.text$mn:00002AAC var_4           = dword ptr -4
.text$mn:00002AAC arg_0           = dword ptr  8
.text$mn:00002AAC
.text$mn:00002AAC                 push    ebp
.text$mn:00002AAD                 mov     ebp, esp
.text$mn:00002AAF                 push    ecx
.text$mn:00002AB0                 mov     [ebp+var_4], ecx
.text$mn:00002AB3                 mov     eax, [ebp+arg_0]
.text$mn:00002AB6                 push    eax             ; void *
.text$mn:00002AB7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002ABC                 add     esp, 4
.text$mn:00002ABF                 mov     esp, ebp
.text$mn:00002AC1                 pop     ebp
.text$mn:00002AC2                 retn    8
.text$mn:00002AC2 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00002AC2
.text$mn:00002AC2 ; ---------------------------------------------------------------------------
.text$mn:00002AC5                 align 4
.text$mn:00002AC5 _text$mn        ends
.text$mn:00002AC5
.text$mn:00002AC8 ; ===========================================================================
.text$mn:00002AC8
.text$mn:00002AC8 ; Segment type: Pure code
.text$mn:00002AC8 ; Segment permissions: Read/Execute
.text$mn:00002AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00002AC8                 assume cs:_text$mn
.text$mn:00002AC8                 ;org 2AC8h
.text$mn:00002AC8 ; COMDAT (pick any)
.text$mn:00002AC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AC8
.text$mn:00002AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AC8
.text$mn:00002AC8 ; Attributes: bp-based frame
.text$mn:00002AC8
.text$mn:00002AC8 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:00002AC8                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:00002AC8 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:00002AC8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:00002AC8
.text$mn:00002AC8 var_4           = dword ptr -4
.text$mn:00002AC8 arg_0           = dword ptr  8
.text$mn:00002AC8
.text$mn:00002AC8                 push    ebp
.text$mn:00002AC9                 mov     ebp, esp
.text$mn:00002ACB                 push    ecx
.text$mn:00002ACC                 mov     [ebp+var_4], ecx
.text$mn:00002ACF                 mov     eax, [ebp+arg_0]
.text$mn:00002AD2                 push    eax             ; void *
.text$mn:00002AD3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002AD8                 add     esp, 4
.text$mn:00002ADB                 mov     esp, ebp
.text$mn:00002ADD                 pop     ebp
.text$mn:00002ADE                 retn    8
.text$mn:00002ADE ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:00002ADE
.text$mn:00002ADE ; ---------------------------------------------------------------------------
.text$mn:00002AE1                 align 4
.text$mn:00002AE1 _text$mn        ends
.text$mn:00002AE1
.text$mn:00002AE4 ; ===========================================================================
.text$mn:00002AE4
.text$mn:00002AE4 ; Segment type: Pure code
.text$mn:00002AE4 ; Segment permissions: Read/Execute
.text$mn:00002AE4 _text$mn        segment para public 'CODE' use32
.text$mn:00002AE4                 assume cs:_text$mn
.text$mn:00002AE4                 ;org 2AE4h
.text$mn:00002AE4 ; COMDAT (pick any)
.text$mn:00002AE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AE4
.text$mn:00002AE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AE4
.text$mn:00002AE4 ; Attributes: bp-based frame
.text$mn:00002AE4
.text$mn:00002AE4 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00002AE4                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002AE4 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002AE4                                         ; DATA XREF: .rdata:00003874o
.text$mn:00002AE4
.text$mn:00002AE4 var_4           = dword ptr -4
.text$mn:00002AE4 arg_0           = dword ptr  8
.text$mn:00002AE4 arg_4           = dword ptr  0Ch
.text$mn:00002AE4
.text$mn:00002AE4                 push    ebp
.text$mn:00002AE5                 mov     ebp, esp
.text$mn:00002AE7                 push    ecx
.text$mn:00002AE8                 mov     [ebp+var_4], ecx
.text$mn:00002AEB                 mov     eax, [ebp+arg_4]
.text$mn:00002AEE                 push    eax             ; int
.text$mn:00002AEF                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002AF4                 add     esp, 4
.text$mn:00002AF7                 test    eax, eax
.text$mn:00002AF9                 jz      short loc_2B14
.text$mn:00002AFB                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00002B00                 push    eax             ; struct std::error_category *
.text$mn:00002B01                 mov     ecx, [ebp+arg_4]
.text$mn:00002B04                 push    ecx             ; int
.text$mn:00002B05                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002B08                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002B0D                 mov     eax, [ebp+arg_0]
.text$mn:00002B10                 jmp     short loc_2B29
.text$mn:00002B12 ; ---------------------------------------------------------------------------
.text$mn:00002B12                 jmp     short loc_2B29
.text$mn:00002B14 ; ---------------------------------------------------------------------------
.text$mn:00002B14
.text$mn:00002B14 loc_2B14:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00002B14                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00002B19                 push    eax             ; struct std::error_category *
.text$mn:00002B1A                 mov     edx, [ebp+arg_4]
.text$mn:00002B1D                 push    edx             ; int
.text$mn:00002B1E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002B21                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002B26                 mov     eax, [ebp+arg_0]
.text$mn:00002B29
.text$mn:00002B29 loc_2B29:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00002B29                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00002B29                 mov     esp, ebp
.text$mn:00002B2B                 pop     ebp
.text$mn:00002B2C                 retn    8
.text$mn:00002B2C ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002B2C
.text$mn:00002B2C ; ---------------------------------------------------------------------------
.text$mn:00002B2F                 align 10h
.text$mn:00002B2F _text$mn        ends
.text$mn:00002B2F
.text$mn:00002B30 ; ===========================================================================
.text$mn:00002B30
.text$mn:00002B30 ; Segment type: Pure code
.text$mn:00002B30 ; Segment permissions: Read/Execute
.text$mn:00002B30 _text$mn        segment para public 'CODE' use32
.text$mn:00002B30                 assume cs:_text$mn
.text$mn:00002B30                 ;org 2B30h
.text$mn:00002B30 ; COMDAT (pick any)
.text$mn:00002B30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B30
.text$mn:00002B30 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B30
.text$mn:00002B30 ; Attributes: bp-based frame
.text$mn:00002B30
.text$mn:00002B30 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00002B30                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002B30 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002B30                                         ; DATA XREF: .rdata:000037E4o
.text$mn:00002B30                                         ; .rdata:00003800o ...
.text$mn:00002B30
.text$mn:00002B30 var_4           = dword ptr -4
.text$mn:00002B30 arg_0           = dword ptr  8
.text$mn:00002B30 arg_4           = dword ptr  0Ch
.text$mn:00002B30
.text$mn:00002B30                 push    ebp
.text$mn:00002B31                 mov     ebp, esp
.text$mn:00002B33                 push    ecx
.text$mn:00002B34                 mov     [ebp+var_4], ecx
.text$mn:00002B37                 mov     eax, [ebp+var_4]
.text$mn:00002B3A                 push    eax             ; struct std::error_category *
.text$mn:00002B3B                 mov     ecx, [ebp+arg_4]
.text$mn:00002B3E                 push    ecx             ; int
.text$mn:00002B3F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002B42                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002B47                 mov     eax, [ebp+arg_0]
.text$mn:00002B4A                 mov     esp, ebp
.text$mn:00002B4C                 pop     ebp
.text$mn:00002B4D                 retn    8
.text$mn:00002B4D ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002B4D
.text$mn:00002B4D _text$mn        ends
.text$mn:00002B4D
.text$mn:00002B50 ; ===========================================================================
.text$mn:00002B50
.text$mn:00002B50 ; Segment type: Pure code
.text$mn:00002B50 ; Segment permissions: Read/Execute
.text$mn:00002B50 _text$mn        segment para public 'CODE' use32
.text$mn:00002B50                 assume cs:_text$mn
.text$mn:00002B50                 ;org 2B50h
.text$mn:00002B50 ; COMDAT (pick any)
.text$mn:00002B50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B50
.text$mn:00002B50 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B50
.text$mn:00002B50 ; Attributes: bp-based frame
.text$mn:00002B50
.text$mn:00002B50 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00002B50                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00002B50 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00002B50                                         ; DATA XREF: .rdata:000037E8o
.text$mn:00002B50                                         ; .rdata:00003804o ...
.text$mn:00002B50
.text$mn:00002B50 var_8           = dword ptr -8
.text$mn:00002B50 var_4           = dword ptr -4
.text$mn:00002B50 arg_0           = dword ptr  8
.text$mn:00002B50 arg_4           = dword ptr  0Ch
.text$mn:00002B50
.text$mn:00002B50                 push    ebp
.text$mn:00002B51                 mov     ebp, esp
.text$mn:00002B53                 sub     esp, 8
.text$mn:00002B56                 mov     [ebp+var_8], ecx
.text$mn:00002B59                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002B5C                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00002B61                 push    eax
.text$mn:00002B62                 mov     ecx, [ebp+var_8]
.text$mn:00002B65                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00002B6A                 movzx   eax, al
.text$mn:00002B6D                 test    eax, eax
.text$mn:00002B6F                 jz      short loc_2B87
.text$mn:00002B71                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002B74                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00002B79                 cmp     eax, [ebp+arg_4]
.text$mn:00002B7C                 jnz     short loc_2B87
.text$mn:00002B7E                 mov     [ebp+var_4], 1
.text$mn:00002B85                 jmp     short loc_2B8E
.text$mn:00002B87 ; ---------------------------------------------------------------------------
.text$mn:00002B87
.text$mn:00002B87 loc_2B87:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00002B87                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00002B87                 mov     [ebp+var_4], 0
.text$mn:00002B8E
.text$mn:00002B8E loc_2B8E:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00002B8E                 mov     al, byte ptr [ebp+var_4]
.text$mn:00002B91                 mov     esp, ebp
.text$mn:00002B93                 pop     ebp
.text$mn:00002B94                 retn    8
.text$mn:00002B94 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00002B94
.text$mn:00002B94 ; ---------------------------------------------------------------------------
.text$mn:00002B97                 align 4
.text$mn:00002B97 _text$mn        ends
.text$mn:00002B97
.text$mn:00002B98 ; ===========================================================================
.text$mn:00002B98
.text$mn:00002B98 ; Segment type: Pure code
.text$mn:00002B98 ; Segment permissions: Read/Execute
.text$mn:00002B98 _text$mn        segment para public 'CODE' use32
.text$mn:00002B98                 assume cs:_text$mn
.text$mn:00002B98                 ;org 2B98h
.text$mn:00002B98 ; COMDAT (pick any)
.text$mn:00002B98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B98
.text$mn:00002B98 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B98
.text$mn:00002B98 ; Attributes: bp-based frame
.text$mn:00002B98
.text$mn:00002B98 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00002B98                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00002B98 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00002B98                                         ; DATA XREF: .rdata:000037ECo
.text$mn:00002B98                                         ; .rdata:00003808o ...
.text$mn:00002B98
.text$mn:00002B98 var_C           = byte ptr -0Ch
.text$mn:00002B98 var_4           = dword ptr -4
.text$mn:00002B98 arg_0           = dword ptr  8
.text$mn:00002B98 arg_4           = dword ptr  0Ch
.text$mn:00002B98
.text$mn:00002B98                 push    ebp
.text$mn:00002B99                 mov     ebp, esp
.text$mn:00002B9B                 sub     esp, 0Ch
.text$mn:00002B9E                 mov     [ebp+var_4], ecx
.text$mn:00002BA1                 mov     eax, [ebp+arg_4]
.text$mn:00002BA4                 push    eax             ; std::error_condition *
.text$mn:00002BA5                 mov     ecx, [ebp+arg_0]
.text$mn:00002BA8                 push    ecx
.text$mn:00002BA9                 lea     edx, [ebp+var_C]
.text$mn:00002BAC                 push    edx
.text$mn:00002BAD                 mov     eax, [ebp+var_4]
.text$mn:00002BB0                 mov     edx, [eax]
.text$mn:00002BB2                 mov     ecx, [ebp+var_4]
.text$mn:00002BB5                 mov     eax, [edx+0Ch]
.text$mn:00002BB8                 call    eax
.text$mn:00002BBA                 mov     ecx, eax
.text$mn:00002BBC                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00002BC1                 mov     esp, ebp
.text$mn:00002BC3                 pop     ebp
.text$mn:00002BC4                 retn    8
.text$mn:00002BC4 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00002BC4
.text$mn:00002BC4 ; ---------------------------------------------------------------------------
.text$mn:00002BC7                 align 4
.text$mn:00002BC7 _text$mn        ends
.text$mn:00002BC7
.text$mn:00002BC8 ; ===========================================================================
.text$mn:00002BC8
.text$mn:00002BC8 ; Segment type: Pure code
.text$mn:00002BC8 ; Segment permissions: Read/Execute
.text$mn:00002BC8 _text$mn        segment para public 'CODE' use32
.text$mn:00002BC8                 assume cs:_text$mn
.text$mn:00002BC8                 ;org 2BC8h
.text$mn:00002BC8 ; COMDAT (pick any)
.text$mn:00002BC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BC8
.text$mn:00002BC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BC8
.text$mn:00002BC8 ; Attributes: bp-based frame
.text$mn:00002BC8
.text$mn:00002BC8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00002BC8                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00002BC8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00002BC8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00002BC8
.text$mn:00002BC8 var_4           = dword ptr -4
.text$mn:00002BC8 arg_0           = dword ptr  8
.text$mn:00002BC8
.text$mn:00002BC8                 push    ebp
.text$mn:00002BC9                 mov     ebp, esp
.text$mn:00002BCB                 push    ecx
.text$mn:00002BCC                 mov     [ebp+var_4], ecx
.text$mn:00002BCF                 mov     eax, [ebp+var_4]
.text$mn:00002BD2                 mov     ecx, [eax+14h]
.text$mn:00002BD5                 cmp     ecx, [ebp+arg_0]
.text$mn:00002BD8                 jnb     short loc_2BE2
.text$mn:00002BDA                 mov     ecx, [ebp+var_4]
.text$mn:00002BDD                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002BE2
.text$mn:00002BE2 loc_2BE2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00002BE2                 mov     edx, [ebp+arg_0]
.text$mn:00002BE5                 push    edx
.text$mn:00002BE6                 mov     ecx, [ebp+var_4]
.text$mn:00002BE9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002BEE                 mov     eax, [ebp+var_4]
.text$mn:00002BF1                 mov     esp, ebp
.text$mn:00002BF3                 pop     ebp
.text$mn:00002BF4                 retn    4
.text$mn:00002BF4 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00002BF4
.text$mn:00002BF4 ; ---------------------------------------------------------------------------
.text$mn:00002BF7                 align 4
.text$mn:00002BF7 _text$mn        ends
.text$mn:00002BF7
.text$mn:00002BF8 ; ===========================================================================
.text$mn:00002BF8
.text$mn:00002BF8 ; Segment type: Pure code
.text$mn:00002BF8 ; Segment permissions: Read/Execute
.text$mn:00002BF8 _text$mn        segment para public 'CODE' use32
.text$mn:00002BF8                 assume cs:_text$mn
.text$mn:00002BF8                 ;org 2BF8h
.text$mn:00002BF8 ; COMDAT (pick any)
.text$mn:00002BF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BF8
.text$mn:00002BF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BF8
.text$mn:00002BF8 ; Attributes: bp-based frame
.text$mn:00002BF8
.text$mn:00002BF8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00002BF8                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00002BF8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00002BF8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00002BF8
.text$mn:00002BF8 var_C           = dword ptr -0Ch
.text$mn:00002BF8 Dst             = dword ptr -8
.text$mn:00002BF8 var_4           = dword ptr -4
.text$mn:00002BF8 arg_0           = dword ptr  8
.text$mn:00002BF8 arg_4           = dword ptr  0Ch
.text$mn:00002BF8
.text$mn:00002BF8                 push    ebp
.text$mn:00002BF9                 mov     ebp, esp
.text$mn:00002BFB                 sub     esp, 0Ch
.text$mn:00002BFE                 mov     [ebp+var_4], ecx
.text$mn:00002C01                 mov     eax, [ebp+var_4]
.text$mn:00002C04                 mov     ecx, [eax+14h]
.text$mn:00002C07                 cmp     ecx, [ebp+arg_0]
.text$mn:00002C0A                 jnb     short loc_2C14
.text$mn:00002C0C                 mov     ecx, [ebp+var_4]
.text$mn:00002C0F                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002C14
.text$mn:00002C14 loc_2C14:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00002C14                 mov     edx, [ebp+var_4]
.text$mn:00002C17                 mov     eax, [edx+14h]
.text$mn:00002C1A                 sub     eax, [ebp+arg_0]
.text$mn:00002C1D                 cmp     eax, [ebp+arg_4]
.text$mn:00002C20                 ja      short loc_2C30
.text$mn:00002C22                 mov     ecx, [ebp+arg_0]
.text$mn:00002C25                 push    ecx
.text$mn:00002C26                 mov     ecx, [ebp+var_4]
.text$mn:00002C29                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002C2E                 jmp     short loc_2C76
.text$mn:00002C30 ; ---------------------------------------------------------------------------
.text$mn:00002C30
.text$mn:00002C30 loc_2C30:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00002C30                 cmp     [ebp+arg_4], 0
.text$mn:00002C34                 jbe     short loc_2C76
.text$mn:00002C36                 mov     ecx, [ebp+var_4]
.text$mn:00002C39                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002C3E                 add     eax, [ebp+arg_0]
.text$mn:00002C41                 mov     [ebp+Dst], eax
.text$mn:00002C44                 mov     edx, [ebp+var_4]
.text$mn:00002C47                 mov     eax, [edx+14h]
.text$mn:00002C4A                 sub     eax, [ebp+arg_4]
.text$mn:00002C4D                 mov     [ebp+var_C], eax
.text$mn:00002C50                 mov     ecx, [ebp+var_C]
.text$mn:00002C53                 sub     ecx, [ebp+arg_0]
.text$mn:00002C56                 push    ecx             ; Size
.text$mn:00002C57                 mov     edx, [ebp+Dst]
.text$mn:00002C5A                 add     edx, [ebp+arg_4]
.text$mn:00002C5D                 push    edx             ; Src
.text$mn:00002C5E                 mov     eax, [ebp+Dst]
.text$mn:00002C61                 push    eax             ; Dst
.text$mn:00002C62                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00002C67                 add     esp, 0Ch
.text$mn:00002C6A                 mov     ecx, [ebp+var_C]
.text$mn:00002C6D                 push    ecx
.text$mn:00002C6E                 mov     ecx, [ebp+var_4]
.text$mn:00002C71                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002C76
.text$mn:00002C76 loc_2C76:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00002C76                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00002C76                 mov     eax, [ebp+var_4]
.text$mn:00002C79                 mov     esp, ebp
.text$mn:00002C7B                 pop     ebp
.text$mn:00002C7C                 retn    8
.text$mn:00002C7C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00002C7C
.text$mn:00002C7C ; ---------------------------------------------------------------------------
.text$mn:00002C7F                 align 10h
.text$mn:00002C7F _text$mn        ends
.text$mn:00002C7F
.text$mn:00002C80 ; ===========================================================================
.text$mn:00002C80
.text$mn:00002C80 ; Segment type: Pure code
.text$mn:00002C80 ; Segment permissions: Read/Execute
.text$mn:00002C80 _text$mn        segment para public 'CODE' use32
.text$mn:00002C80                 assume cs:_text$mn
.text$mn:00002C80                 ;org 2C80h
.text$mn:00002C80 ; COMDAT (pick any)
.text$mn:00002C80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C80
.text$mn:00002C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C80
.text$mn:00002C80 ; Attributes: bp-based frame
.text$mn:00002C80
.text$mn:00002C80 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:00002C80                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:00002C80 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00002C80                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:00002C80
.text$mn:00002C80 var_4           = dword ptr -4
.text$mn:00002C80 arg_0           = dword ptr  8
.text$mn:00002C80
.text$mn:00002C80                 push    ebp
.text$mn:00002C81                 mov     ebp, esp
.text$mn:00002C83                 push    ecx
.text$mn:00002C84                 mov     [ebp+var_4], ecx
.text$mn:00002C87                 mov     eax, [ebp+var_4]
.text$mn:00002C8A                 mov     ecx, [eax+14h]
.text$mn:00002C8D                 cmp     ecx, [ebp+arg_0]
.text$mn:00002C90                 jnb     short loc_2C9A
.text$mn:00002C92                 mov     ecx, [ebp+var_4]
.text$mn:00002C95                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00002C9A
.text$mn:00002C9A loc_2C9A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:00002C9A                 mov     edx, [ebp+arg_0]
.text$mn:00002C9D                 push    edx
.text$mn:00002C9E                 mov     ecx, [ebp+var_4]
.text$mn:00002CA1                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00002CA6                 mov     eax, [ebp+var_4]
.text$mn:00002CA9                 mov     esp, ebp
.text$mn:00002CAB                 pop     ebp
.text$mn:00002CAC                 retn    4
.text$mn:00002CAC ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:00002CAC
.text$mn:00002CAC ; ---------------------------------------------------------------------------
.text$mn:00002CAF                 align 10h
.text$mn:00002CAF _text$mn        ends
.text$mn:00002CAF
.text$mn:00002CB0 ; ===========================================================================
.text$mn:00002CB0
.text$mn:00002CB0 ; Segment type: Pure code
.text$mn:00002CB0 ; Segment permissions: Read/Execute
.text$mn:00002CB0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CB0                 assume cs:_text$mn
.text$mn:00002CB0                 ;org 2CB0h
.text$mn:00002CB0 ; COMDAT (pick any)
.text$mn:00002CB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CB0
.text$mn:00002CB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CB0
.text$mn:00002CB0 ; Attributes: bp-based frame
.text$mn:00002CB0
.text$mn:00002CB0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:00002CB0                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:00002CB0 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00002CB0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:00002CB0
.text$mn:00002CB0 var_C           = dword ptr -0Ch
.text$mn:00002CB0 Dst             = dword ptr -8
.text$mn:00002CB0 var_4           = dword ptr -4
.text$mn:00002CB0 arg_0           = dword ptr  8
.text$mn:00002CB0 arg_4           = dword ptr  0Ch
.text$mn:00002CB0
.text$mn:00002CB0                 push    ebp
.text$mn:00002CB1                 mov     ebp, esp
.text$mn:00002CB3                 sub     esp, 0Ch
.text$mn:00002CB6                 mov     [ebp+var_4], ecx
.text$mn:00002CB9                 mov     eax, [ebp+var_4]
.text$mn:00002CBC                 mov     ecx, [eax+14h]
.text$mn:00002CBF                 cmp     ecx, [ebp+arg_0]
.text$mn:00002CC2                 jnb     short loc_2CCC
.text$mn:00002CC4                 mov     ecx, [ebp+var_4]
.text$mn:00002CC7                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00002CCC
.text$mn:00002CCC loc_2CCC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:00002CCC                 mov     edx, [ebp+var_4]
.text$mn:00002CCF                 mov     eax, [edx+14h]
.text$mn:00002CD2                 sub     eax, [ebp+arg_0]
.text$mn:00002CD5                 cmp     eax, [ebp+arg_4]
.text$mn:00002CD8                 ja      short loc_2CE8
.text$mn:00002CDA                 mov     ecx, [ebp+arg_0]
.text$mn:00002CDD                 push    ecx
.text$mn:00002CDE                 mov     ecx, [ebp+var_4]
.text$mn:00002CE1                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00002CE6                 jmp     short loc_2D34
.text$mn:00002CE8 ; ---------------------------------------------------------------------------
.text$mn:00002CE8
.text$mn:00002CE8 loc_2CE8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:00002CE8                 cmp     [ebp+arg_4], 0
.text$mn:00002CEC                 jbe     short loc_2D34
.text$mn:00002CEE                 mov     ecx, [ebp+var_4]
.text$mn:00002CF1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002CF6                 mov     edx, [ebp+arg_0]
.text$mn:00002CF9                 lea     eax, [eax+edx*2]
.text$mn:00002CFC                 mov     [ebp+Dst], eax
.text$mn:00002CFF                 mov     ecx, [ebp+var_4]
.text$mn:00002D02                 mov     edx, [ecx+14h]
.text$mn:00002D05                 sub     edx, [ebp+arg_4]
.text$mn:00002D08                 mov     [ebp+var_C], edx
.text$mn:00002D0B                 mov     eax, [ebp+var_C]
.text$mn:00002D0E                 sub     eax, [ebp+arg_0]
.text$mn:00002D11                 push    eax             ; int
.text$mn:00002D12                 mov     ecx, [ebp+arg_4]
.text$mn:00002D15                 mov     edx, [ebp+Dst]
.text$mn:00002D18                 lea     eax, [edx+ecx*2]
.text$mn:00002D1B                 push    eax             ; Src
.text$mn:00002D1C                 mov     ecx, [ebp+Dst]
.text$mn:00002D1F                 push    ecx             ; Dst
.text$mn:00002D20                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00002D25                 add     esp, 0Ch
.text$mn:00002D28                 mov     edx, [ebp+var_C]
.text$mn:00002D2B                 push    edx
.text$mn:00002D2C                 mov     ecx, [ebp+var_4]
.text$mn:00002D2F                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00002D34
.text$mn:00002D34 loc_2D34:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:00002D34                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:00002D34                 mov     eax, [ebp+var_4]
.text$mn:00002D37                 mov     esp, ebp
.text$mn:00002D39                 pop     ebp
.text$mn:00002D3A                 retn    8
.text$mn:00002D3A ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:00002D3A
.text$mn:00002D3A ; ---------------------------------------------------------------------------
.text$mn:00002D3D                 align 10h
.text$mn:00002D3D _text$mn        ends
.text$mn:00002D3D
.text$mn:00002D40 ; ===========================================================================
.text$mn:00002D40
.text$mn:00002D40 ; Segment type: Pure code
.text$mn:00002D40 ; Segment permissions: Read/Execute
.text$mn:00002D40 _text$mn        segment para public 'CODE' use32
.text$mn:00002D40                 assume cs:_text$mn
.text$mn:00002D40                 ;org 2D40h
.text$mn:00002D40 ; COMDAT (pick any)
.text$mn:00002D40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D40
.text$mn:00002D40 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D40
.text$mn:00002D40 ; Attributes: bp-based frame
.text$mn:00002D40
.text$mn:00002D40 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00002D40                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00002D40 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002D40                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00002D40                 push    ebp
.text$mn:00002D41                 mov     ebp, esp
.text$mn:00002D43                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00002D48                 pop     ebp
.text$mn:00002D49                 retn
.text$mn:00002D49 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002D49
.text$mn:00002D49 ; ---------------------------------------------------------------------------
.text$mn:00002D4A                 align 4
.text$mn:00002D4A _text$mn        ends
.text$mn:00002D4A
.text$mn:00002D4C ; ===========================================================================
.text$mn:00002D4C
.text$mn:00002D4C ; Segment type: Pure code
.text$mn:00002D4C ; Segment permissions: Read/Execute
.text$mn:00002D4C _text$mn        segment para public 'CODE' use32
.text$mn:00002D4C                 assume cs:_text$mn
.text$mn:00002D4C                 ;org 2D4Ch
.text$mn:00002D4C ; COMDAT (pick any)
.text$mn:00002D4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D4C
.text$mn:00002D4C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D4C
.text$mn:00002D4C ; Attributes: bp-based frame
.text$mn:00002D4C
.text$mn:00002D4C ; public: long (__stdcall *__thiscall NppParameters::getEnableThemeDlgTexture(void)const)(struct HWND__ *, unsigned int, unsigned int, long)
.text$mn:00002D4C                 public ?getEnableThemeDlgTexture@NppParameters@@QBEP6GJPAUHWND__@@IIJ@ZXZ
.text$mn:00002D4C ?getEnableThemeDlgTexture@NppParameters@@QBEP6GJPAUHWND__@@IIJ@ZXZ proc near
.text$mn:00002D4C                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+1DDp
.text$mn:00002D4C
.text$mn:00002D4C var_4           = dword ptr -4
.text$mn:00002D4C
.text$mn:00002D4C                 push    ebp
.text$mn:00002D4D                 mov     ebp, esp
.text$mn:00002D4F                 push    ecx
.text$mn:00002D50                 mov     [ebp+var_4], ecx
.text$mn:00002D53                 mov     eax, [ebp+var_4]
.text$mn:00002D56                 mov     eax, [eax+1C8FCh]
.text$mn:00002D5C                 mov     esp, ebp
.text$mn:00002D5E                 pop     ebp
.text$mn:00002D5F                 retn
.text$mn:00002D5F ?getEnableThemeDlgTexture@NppParameters@@QBEP6GJPAUHWND__@@IIJ@ZXZ endp
.text$mn:00002D5F
.text$mn:00002D5F _text$mn        ends
.text$mn:00002D5F
.text$mn:00002D60 ; ===========================================================================
.text$mn:00002D60
.text$mn:00002D60 ; Segment type: Pure code
.text$mn:00002D60 ; Segment permissions: Read/Execute
.text$mn:00002D60 _text$mn        segment para public 'CODE' use32
.text$mn:00002D60                 assume cs:_text$mn
.text$mn:00002D60                 ;org 2D60h
.text$mn:00002D60 ; COMDAT (pick any)
.text$mn:00002D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D60
.text$mn:00002D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D60
.text$mn:00002D60 ; Attributes: bp-based frame
.text$mn:00002D60
.text$mn:00002D60 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:00002D60                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:00002D60 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:00002D60                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+1D2p
.text$mn:00002D60                 push    ebp
.text$mn:00002D61                 mov     ebp, esp
.text$mn:00002D63                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:00002D68                 pop     ebp
.text$mn:00002D69                 retn
.text$mn:00002D69 ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:00002D69
.text$mn:00002D69 ; ---------------------------------------------------------------------------
.text$mn:00002D6A                 align 4
.text$mn:00002D6A _text$mn        ends
.text$mn:00002D6A
.text$mn:00002D6C ; ===========================================================================
.text$mn:00002D6C
.text$mn:00002D6C ; Segment type: Pure code
.text$mn:00002D6C ; Segment permissions: Read/Execute
.text$mn:00002D6C _text$mn        segment para public 'CODE' use32
.text$mn:00002D6C                 assume cs:_text$mn
.text$mn:00002D6C                 ;org 2D6Ch
.text$mn:00002D6C ; COMDAT (pick any)
.text$mn:00002D6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D6C
.text$mn:00002D6C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D6C
.text$mn:00002D6C ; Attributes: bp-based frame
.text$mn:00002D6C
.text$mn:00002D6C ; struct WcharMbcsConvertor *__cdecl WcharMbcsConvertor::getInstance()
.text$mn:00002D6C                 public ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ
.text$mn:00002D6C ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ proc near
.text$mn:00002D6C                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+94p
.text$mn:00002D6C                 push    ebp
.text$mn:00002D6D                 mov     ebp, esp
.text$mn:00002D6F                 mov     eax, dword ptr ds:?_pSelf@WcharMbcsConvertor@@1PAV1@A ; WcharMbcsConvertor * WcharMbcsConvertor::_pSelf
.text$mn:00002D74                 pop     ebp
.text$mn:00002D75                 retn
.text$mn:00002D75 ?getInstance@WcharMbcsConvertor@@SAPAV1@XZ endp
.text$mn:00002D75
.text$mn:00002D75 ; ---------------------------------------------------------------------------
.text$mn:00002D76                 align 4
.text$mn:00002D76 _text$mn        ends
.text$mn:00002D76
.text$mn:00002D78 ; ===========================================================================
.text$mn:00002D78
.text$mn:00002D78 ; Segment type: Pure code
.text$mn:00002D78 ; Segment permissions: Read/Execute
.text$mn:00002D78 _text$mn        segment para public 'CODE' use32
.text$mn:00002D78                 assume cs:_text$mn
.text$mn:00002D78                 ;org 2D78h
.text$mn:00002D78 ; COMDAT (pick any)
.text$mn:00002D78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D78
.text$mn:00002D78 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D78
.text$mn:00002D78 ; Attributes: bp-based frame
.text$mn:00002D78
.text$mn:00002D78 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00002D78                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00002D78 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00002D78                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00002D78
.text$mn:00002D78 var_4           = dword ptr -4
.text$mn:00002D78 Str             = dword ptr  8
.text$mn:00002D78
.text$mn:00002D78                 push    ebp
.text$mn:00002D79                 mov     ebp, esp
.text$mn:00002D7B                 push    ecx
.text$mn:00002D7C                 mov     eax, [ebp+Str]
.text$mn:00002D7F                 movsx   ecx, byte ptr [eax]
.text$mn:00002D82                 test    ecx, ecx
.text$mn:00002D84                 jnz     short loc_2D8F
.text$mn:00002D86                 mov     [ebp+var_4], 0
.text$mn:00002D8D                 jmp     short loc_2D9E
.text$mn:00002D8F ; ---------------------------------------------------------------------------
.text$mn:00002D8F
.text$mn:00002D8F loc_2D8F:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00002D8F                 mov     edx, [ebp+Str]
.text$mn:00002D92                 push    edx             ; Str
.text$mn:00002D93                 call    _strlen
.text$mn:00002D98                 add     esp, 4
.text$mn:00002D9B                 mov     [ebp+var_4], eax
.text$mn:00002D9E
.text$mn:00002D9E loc_2D9E:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00002D9E                 mov     eax, [ebp+var_4]
.text$mn:00002DA1                 mov     esp, ebp
.text$mn:00002DA3                 pop     ebp
.text$mn:00002DA4                 retn
.text$mn:00002DA4 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00002DA4
.text$mn:00002DA4 ; ---------------------------------------------------------------------------
.text$mn:00002DA5                 align 4
.text$mn:00002DA5 _text$mn        ends
.text$mn:00002DA5
.text$mn:00002DA8 ; ===========================================================================
.text$mn:00002DA8
.text$mn:00002DA8 ; Segment type: Pure code
.text$mn:00002DA8 ; Segment permissions: Read/Execute
.text$mn:00002DA8 _text$mn        segment para public 'CODE' use32
.text$mn:00002DA8                 assume cs:_text$mn
.text$mn:00002DA8                 ;org 2DA8h
.text$mn:00002DA8 ; COMDAT (pick any)
.text$mn:00002DA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DA8
.text$mn:00002DA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DA8
.text$mn:00002DA8 ; Attributes: bp-based frame
.text$mn:00002DA8
.text$mn:00002DA8 ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:00002DA8                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:00002DA8 ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:00002DA8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+21p
.text$mn:00002DA8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p
.text$mn:00002DA8
.text$mn:00002DA8 var_4           = dword ptr -4
.text$mn:00002DA8 Str             = dword ptr  8
.text$mn:00002DA8
.text$mn:00002DA8                 push    ebp
.text$mn:00002DA9                 mov     ebp, esp
.text$mn:00002DAB                 push    ecx
.text$mn:00002DAC                 mov     eax, [ebp+Str]
.text$mn:00002DAF                 movzx   ecx, word ptr [eax]
.text$mn:00002DB2                 test    ecx, ecx
.text$mn:00002DB4                 jnz     short loc_2DBF
.text$mn:00002DB6                 mov     [ebp+var_4], 0
.text$mn:00002DBD                 jmp     short loc_2DCE
.text$mn:00002DBF ; ---------------------------------------------------------------------------
.text$mn:00002DBF
.text$mn:00002DBF loc_2DBF:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:00002DBF                 mov     edx, [ebp+Str]
.text$mn:00002DC2                 push    edx             ; Str
.text$mn:00002DC3                 call    _wcslen
.text$mn:00002DC8                 add     esp, 4
.text$mn:00002DCB                 mov     [ebp+var_4], eax
.text$mn:00002DCE
.text$mn:00002DCE loc_2DCE:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:00002DCE                 mov     eax, [ebp+var_4]
.text$mn:00002DD1                 mov     esp, ebp
.text$mn:00002DD3                 pop     ebp
.text$mn:00002DD4                 retn
.text$mn:00002DD4 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:00002DD4
.text$mn:00002DD4 ; ---------------------------------------------------------------------------
.text$mn:00002DD5                 align 4
.text$mn:00002DD5 _text$mn        ends
.text$mn:00002DD5
.text$mn:00002DD8 ; ===========================================================================
.text$mn:00002DD8
.text$mn:00002DD8 ; Segment type: Pure code
.text$mn:00002DD8 ; Segment permissions: Read/Execute
.text$mn:00002DD8 _text$mn        segment para public 'CODE' use32
.text$mn:00002DD8                 assume cs:_text$mn
.text$mn:00002DD8                 ;org 2DD8h
.text$mn:00002DD8 ; COMDAT (pick any)
.text$mn:00002DD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DD8
.text$mn:00002DD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DD8
.text$mn:00002DD8 ; Attributes: bp-based frame
.text$mn:00002DD8
.text$mn:00002DD8 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00002DD8                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00002DD8 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00002DD8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00002DD8
.text$mn:00002DD8 var_4           = dword ptr -4
.text$mn:00002DD8
.text$mn:00002DD8                 push    ebp
.text$mn:00002DD9                 mov     ebp, esp
.text$mn:00002DDB                 push    ecx
.text$mn:00002DDC                 mov     [ebp+var_4], ecx
.text$mn:00002DDF                 mov     eax, [ebp+var_4]
.text$mn:00002DE2                 push    eax
.text$mn:00002DE3                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00002DE8                 add     esp, 4
.text$mn:00002DEB                 mov     esp, ebp
.text$mn:00002DED                 pop     ebp
.text$mn:00002DEE                 retn
.text$mn:00002DEE ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00002DEE
.text$mn:00002DEE ; ---------------------------------------------------------------------------
.text$mn:00002DEF                 align 10h
.text$mn:00002DEF _text$mn        ends
.text$mn:00002DEF
.text$mn:00002DF0 ; ===========================================================================
.text$mn:00002DF0
.text$mn:00002DF0 ; Segment type: Pure code
.text$mn:00002DF0 ; Segment permissions: Read/Execute
.text$mn:00002DF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DF0                 assume cs:_text$mn
.text$mn:00002DF0                 ;org 2DF0h
.text$mn:00002DF0 ; COMDAT (pick any)
.text$mn:00002DF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DF0
.text$mn:00002DF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DF0
.text$mn:00002DF0 ; Attributes: bp-based frame
.text$mn:00002DF0
.text$mn:00002DF0 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:00002DF0                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:00002DF0 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:00002DF0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:00002DF0
.text$mn:00002DF0 var_4           = dword ptr -4
.text$mn:00002DF0
.text$mn:00002DF0                 push    ebp
.text$mn:00002DF1                 mov     ebp, esp
.text$mn:00002DF3                 push    ecx
.text$mn:00002DF4                 mov     [ebp+var_4], ecx
.text$mn:00002DF7                 mov     eax, [ebp+var_4]
.text$mn:00002DFA                 push    eax
.text$mn:00002DFB                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:00002E00                 add     esp, 4
.text$mn:00002E03                 mov     esp, ebp
.text$mn:00002E05                 pop     ebp
.text$mn:00002E06                 retn
.text$mn:00002E06 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:00002E06
.text$mn:00002E06 ; ---------------------------------------------------------------------------
.text$mn:00002E07                 align 4
.text$mn:00002E07 _text$mn        ends
.text$mn:00002E07
.text$mn:00002E08 ; ===========================================================================
.text$mn:00002E08
.text$mn:00002E08 ; Segment type: Pure code
.text$mn:00002E08 ; Segment permissions: Read/Execute
.text$mn:00002E08 _text$mn        segment para public 'CODE' use32
.text$mn:00002E08                 assume cs:_text$mn
.text$mn:00002E08                 ;org 2E08h
.text$mn:00002E08 ; COMDAT (pick any)
.text$mn:00002E08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E08
.text$mn:00002E08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E08
.text$mn:00002E08 ; Attributes: bp-based frame
.text$mn:00002E08
.text$mn:00002E08 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00002E08                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00002E08 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00002E08                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00002E08
.text$mn:00002E08 var_4           = dword ptr -4
.text$mn:00002E08
.text$mn:00002E08                 push    ebp
.text$mn:00002E09                 mov     ebp, esp
.text$mn:00002E0B                 push    ecx
.text$mn:00002E0C                 mov     [ebp+var_4], ecx
.text$mn:00002E0F                 or      eax, 0FFFFFFFFh
.text$mn:00002E12                 mov     esp, ebp
.text$mn:00002E14                 pop     ebp
.text$mn:00002E15                 retn
.text$mn:00002E15 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00002E15
.text$mn:00002E15 ; ---------------------------------------------------------------------------
.text$mn:00002E16                 align 4
.text$mn:00002E16 _text$mn        ends
.text$mn:00002E16
.text$mn:00002E18 ; ===========================================================================
.text$mn:00002E18
.text$mn:00002E18 ; Segment type: Pure code
.text$mn:00002E18 ; Segment permissions: Read/Execute
.text$mn:00002E18 _text$mn        segment para public 'CODE' use32
.text$mn:00002E18                 assume cs:_text$mn
.text$mn:00002E18                 ;org 2E18h
.text$mn:00002E18 ; COMDAT (pick any)
.text$mn:00002E18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E18
.text$mn:00002E18 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E18
.text$mn:00002E18 ; Attributes: bp-based frame
.text$mn:00002E18
.text$mn:00002E18 ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:00002E18                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:00002E18 ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:00002E18                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:00002E18
.text$mn:00002E18 var_4           = dword ptr -4
.text$mn:00002E18
.text$mn:00002E18                 push    ebp
.text$mn:00002E19                 mov     ebp, esp
.text$mn:00002E1B                 push    ecx
.text$mn:00002E1C                 mov     [ebp+var_4], ecx
.text$mn:00002E1F                 mov     eax, 7FFFFFFFh
.text$mn:00002E24                 mov     esp, ebp
.text$mn:00002E26                 pop     ebp
.text$mn:00002E27                 retn
.text$mn:00002E27 ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:00002E27
.text$mn:00002E27 _text$mn        ends
.text$mn:00002E27
.text$mn:00002E28 ; ===========================================================================
.text$mn:00002E28
.text$mn:00002E28 ; Segment type: Pure code
.text$mn:00002E28 ; Segment permissions: Read/Execute
.text$mn:00002E28 _text$mn        segment para public 'CODE' use32
.text$mn:00002E28                 assume cs:_text$mn
.text$mn:00002E28                 ;org 2E28h
.text$mn:00002E28 ; COMDAT (pick any)
.text$mn:00002E28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E28
.text$mn:00002E28 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E28
.text$mn:00002E28 ; Attributes: bp-based frame
.text$mn:00002E28
.text$mn:00002E28 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00002E28                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00002E28 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00002E28                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00002E28
.text$mn:00002E28 arg_0           = dword ptr  8
.text$mn:00002E28
.text$mn:00002E28                 push    ebp
.text$mn:00002E29                 mov     ebp, esp
.text$mn:00002E2B                 mov     ecx, [ebp+arg_0]
.text$mn:00002E2E                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00002E33                 pop     ebp
.text$mn:00002E34                 retn
.text$mn:00002E34 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00002E34
.text$mn:00002E34 ; ---------------------------------------------------------------------------
.text$mn:00002E35                 align 4
.text$mn:00002E35 _text$mn        ends
.text$mn:00002E35
.text$mn:00002E38 ; ===========================================================================
.text$mn:00002E38
.text$mn:00002E38 ; Segment type: Pure code
.text$mn:00002E38 ; Segment permissions: Read/Execute
.text$mn:00002E38 _text$mn        segment para public 'CODE' use32
.text$mn:00002E38                 assume cs:_text$mn
.text$mn:00002E38                 ;org 2E38h
.text$mn:00002E38 ; COMDAT (pick any)
.text$mn:00002E38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E38
.text$mn:00002E38 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E38
.text$mn:00002E38 ; Attributes: bp-based frame
.text$mn:00002E38
.text$mn:00002E38 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:00002E38                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:00002E38 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:00002E38                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:00002E38
.text$mn:00002E38 arg_0           = dword ptr  8
.text$mn:00002E38
.text$mn:00002E38                 push    ebp
.text$mn:00002E39                 mov     ebp, esp
.text$mn:00002E3B                 mov     ecx, [ebp+arg_0]
.text$mn:00002E3E                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:00002E43                 pop     ebp
.text$mn:00002E44                 retn
.text$mn:00002E44 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:00002E44
.text$mn:00002E44 ; ---------------------------------------------------------------------------
.text$mn:00002E45                 align 4
.text$mn:00002E45 _text$mn        ends
.text$mn:00002E45
.text$mn:00002E48 ; ===========================================================================
.text$mn:00002E48
.text$mn:00002E48 ; Segment type: Pure code
.text$mn:00002E48 ; Segment permissions: Read/Execute
.text$mn:00002E48 _text$mn        segment para public 'CODE' use32
.text$mn:00002E48                 assume cs:_text$mn
.text$mn:00002E48                 ;org 2E48h
.text$mn:00002E48 ; COMDAT (pick any)
.text$mn:00002E48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E48
.text$mn:00002E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E48
.text$mn:00002E48 ; Attributes: bp-based frame
.text$mn:00002E48
.text$mn:00002E48 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00002E48                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002E48 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002E48                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00002E48                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00002E48
.text$mn:00002E48 var_10          = dword ptr -10h
.text$mn:00002E48 var_C           = dword ptr -0Ch
.text$mn:00002E48 var_8           = dword ptr -8
.text$mn:00002E48 var_1           = byte ptr -1
.text$mn:00002E48
.text$mn:00002E48                 push    ebp
.text$mn:00002E49                 mov     ebp, esp
.text$mn:00002E4B                 sub     esp, 10h
.text$mn:00002E4E                 mov     [ebp+var_10], ecx
.text$mn:00002E51                 lea     eax, [ebp+var_1]
.text$mn:00002E54                 push    eax
.text$mn:00002E55                 mov     ecx, [ebp+var_10]
.text$mn:00002E58                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002E5D                 mov     ecx, eax
.text$mn:00002E5F                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00002E64                 mov     [ebp+var_8], eax
.text$mn:00002E67                 cmp     [ebp+var_8], 1
.text$mn:00002E6B                 ja      short loc_2E76
.text$mn:00002E6D                 mov     [ebp+var_C], 1
.text$mn:00002E74                 jmp     short loc_2E7F
.text$mn:00002E76 ; ---------------------------------------------------------------------------
.text$mn:00002E76
.text$mn:00002E76 loc_2E76:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00002E76                 mov     ecx, [ebp+var_8]
.text$mn:00002E79                 sub     ecx, 1
.text$mn:00002E7C                 mov     [ebp+var_C], ecx
.text$mn:00002E7F
.text$mn:00002E7F loc_2E7F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00002E7F                 mov     eax, [ebp+var_C]
.text$mn:00002E82                 mov     esp, ebp
.text$mn:00002E84                 pop     ebp
.text$mn:00002E85                 retn
.text$mn:00002E85 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002E85
.text$mn:00002E85 ; ---------------------------------------------------------------------------
.text$mn:00002E86                 align 4
.text$mn:00002E86 _text$mn        ends
.text$mn:00002E86
.text$mn:00002E88 ; ===========================================================================
.text$mn:00002E88
.text$mn:00002E88 ; Segment type: Pure code
.text$mn:00002E88 ; Segment permissions: Read/Execute
.text$mn:00002E88 _text$mn        segment para public 'CODE' use32
.text$mn:00002E88                 assume cs:_text$mn
.text$mn:00002E88                 ;org 2E88h
.text$mn:00002E88 ; COMDAT (pick any)
.text$mn:00002E88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E88
.text$mn:00002E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E88
.text$mn:00002E88 ; Attributes: bp-based frame
.text$mn:00002E88
.text$mn:00002E88 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:00002E88                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00002E88 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00002E88                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:00002E88                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:00002E88
.text$mn:00002E88 var_10          = dword ptr -10h
.text$mn:00002E88 var_C           = dword ptr -0Ch
.text$mn:00002E88 var_8           = dword ptr -8
.text$mn:00002E88 var_1           = byte ptr -1
.text$mn:00002E88
.text$mn:00002E88                 push    ebp
.text$mn:00002E89                 mov     ebp, esp
.text$mn:00002E8B                 sub     esp, 10h
.text$mn:00002E8E                 mov     [ebp+var_10], ecx
.text$mn:00002E91                 lea     eax, [ebp+var_1]
.text$mn:00002E94                 push    eax
.text$mn:00002E95                 mov     ecx, [ebp+var_10]
.text$mn:00002E98                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002E9D                 mov     ecx, eax
.text$mn:00002E9F                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:00002EA4                 mov     [ebp+var_8], eax
.text$mn:00002EA7                 cmp     [ebp+var_8], 1
.text$mn:00002EAB                 ja      short loc_2EB6
.text$mn:00002EAD                 mov     [ebp+var_C], 1
.text$mn:00002EB4                 jmp     short loc_2EBF
.text$mn:00002EB6 ; ---------------------------------------------------------------------------
.text$mn:00002EB6
.text$mn:00002EB6 loc_2EB6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:00002EB6                 mov     ecx, [ebp+var_8]
.text$mn:00002EB9                 sub     ecx, 1
.text$mn:00002EBC                 mov     [ebp+var_C], ecx
.text$mn:00002EBF
.text$mn:00002EBF loc_2EBF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:00002EBF                 mov     eax, [ebp+var_C]
.text$mn:00002EC2                 mov     esp, ebp
.text$mn:00002EC4                 pop     ebp
.text$mn:00002EC5                 retn
.text$mn:00002EC5 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00002EC5
.text$mn:00002EC5 ; ---------------------------------------------------------------------------
.text$mn:00002EC6                 align 4
.text$mn:00002EC6 _text$mn        ends
.text$mn:00002EC6
.text$mn:00002EC8 ; ===========================================================================
.text$mn:00002EC8
.text$mn:00002EC8 ; Segment type: Pure code
.text$mn:00002EC8 ; Segment permissions: Read/Execute
.text$mn:00002EC8 _text$mn        segment para public 'CODE' use32
.text$mn:00002EC8                 assume cs:_text$mn
.text$mn:00002EC8                 ;org 2EC8h
.text$mn:00002EC8 ; COMDAT (pick any)
.text$mn:00002EC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002EC8
.text$mn:00002EC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EC8
.text$mn:00002EC8 ; Attributes: bp-based frame
.text$mn:00002EC8
.text$mn:00002EC8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00002EC8                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002EC8 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002EC8                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00002EC8                                         ; DATA XREF: .rdata:000037FCo
.text$mn:00002EC8
.text$mn:00002EC8 var_1C          = dword ptr -1Ch
.text$mn:00002EC8 var_18          = dword ptr -18h
.text$mn:00002EC8 Str             = dword ptr -14h
.text$mn:00002EC8 var_10          = dword ptr -10h
.text$mn:00002EC8 var_C           = dword ptr -0Ch
.text$mn:00002EC8 var_4           = dword ptr -4
.text$mn:00002EC8 arg_0           = dword ptr  8
.text$mn:00002EC8 arg_4           = dword ptr  0Ch
.text$mn:00002EC8
.text$mn:00002EC8                 push    ebp
.text$mn:00002EC9                 mov     ebp, esp
.text$mn:00002ECB                 push    0FFFFFFFFh
.text$mn:00002ECD                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002ED2                 mov     eax, large fs:0
.text$mn:00002ED8                 push    eax
.text$mn:00002ED9                 sub     esp, 10h
.text$mn:00002EDC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002EE1                 xor     eax, ebp
.text$mn:00002EE3                 push    eax
.text$mn:00002EE4                 lea     eax, [ebp+var_C]
.text$mn:00002EE7                 mov     large fs:0, eax
.text$mn:00002EED                 mov     [ebp+var_1C], ecx
.text$mn:00002EF0                 mov     [ebp+var_18], 0
.text$mn:00002EF7                 mov     eax, [ebp+arg_4]
.text$mn:00002EFA                 push    eax             ; int
.text$mn:00002EFB                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002F00                 add     esp, 4
.text$mn:00002F03                 mov     [ebp+var_10], eax
.text$mn:00002F06                 cmp     [ebp+var_10], 0
.text$mn:00002F0A                 jz      short loc_2F14
.text$mn:00002F0C                 mov     ecx, [ebp+var_10]
.text$mn:00002F0F                 mov     [ebp+Str], ecx
.text$mn:00002F12                 jmp     short loc_2F1B
.text$mn:00002F14 ; ---------------------------------------------------------------------------
.text$mn:00002F14
.text$mn:00002F14 loc_2F14:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00002F14                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002F1B
.text$mn:00002F1B loc_2F1B:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00002F1B                 mov     edx, [ebp+Str]
.text$mn:00002F1E                 push    edx             ; Str
.text$mn:00002F1F                 mov     ecx, [ebp+arg_0]
.text$mn:00002F22                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002F27                 mov     [ebp+var_4], 0
.text$mn:00002F2E                 mov     eax, [ebp+var_18]
.text$mn:00002F31                 or      eax, 1
.text$mn:00002F34                 mov     [ebp+var_18], eax
.text$mn:00002F37                 mov     eax, [ebp+arg_0]
.text$mn:00002F3A                 mov     ecx, [ebp+var_C]
.text$mn:00002F3D                 mov     large fs:0, ecx
.text$mn:00002F44                 pop     ecx
.text$mn:00002F45                 mov     esp, ebp
.text$mn:00002F47                 pop     ebp
.text$mn:00002F48                 retn    8
.text$mn:00002F48 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002F48
.text$mn:00002F48 ; ---------------------------------------------------------------------------
.text$mn:00002F4B                 align 4
.text$mn:00002F4B _text$mn        ends
.text$mn:00002F4B
.text$x:00002F4C ; ===========================================================================
.text$x:00002F4C
.text$x:00002F4C ; Segment type: Pure code
.text$x:00002F4C ; Segment permissions: Read/Execute
.text$x:00002F4C _text$x         segment para public 'CODE' use32
.text$x:00002F4C                 assume cs:_text$x
.text$x:00002F4C                 ;org 2F4Ch
.text$x:00002F4C ; COMDAT (pick associative to section at 2EC8)
.text$x:00002F4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002F4C
.text$x:00002F4C ; =============== S U B R O U T I N E =======================================
.text$x:00002F4C
.text$x:00002F4C
.text$x:00002F4C __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002F4C                                         ; DATA XREF: .xdata$x:00003430o
.text$x:00002F4C                 mov     eax, [ebp-18h]
.text$x:00002F4F                 and     eax, 1
.text$x:00002F52                 jz      $LN6
.text$x:00002F58                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002F5C                 mov     ecx, [ebp+8]
.text$x:00002F5F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002F64 ; ---------------------------------------------------------------------------
.text$x:00002F64
.text$x:00002F64 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002F64                 retn
.text$x:00002F64 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002F64
.text$x:00002F65
.text$x:00002F65 ; =============== S U B R O U T I N E =======================================
.text$x:00002F65
.text$x:00002F65
.text$x:00002F65 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002F65                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00002F65
.text$x:00002F65 arg_4           = dword ptr  8
.text$x:00002F65
.text$x:00002F65                 mov     edx, [esp+arg_4]
.text$x:00002F69                 lea     eax, [edx+0Ch]
.text$x:00002F6C                 mov     ecx, [edx-14h]
.text$x:00002F6F                 xor     ecx, eax
.text$x:00002F71                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F76                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002F7B                 jmp     ___CxxFrameHandler3
.text$x:00002F7B __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002F7B
.text$x:00002F7B _text$x         ends
.text$x:00002F7B
.text$mn:00002F80 ; ===========================================================================
.text$mn:00002F80
.text$mn:00002F80 ; Segment type: Pure code
.text$mn:00002F80 ; Segment permissions: Read/Execute
.text$mn:00002F80 _text$mn        segment para public 'CODE' use32
.text$mn:00002F80                 assume cs:_text$mn
.text$mn:00002F80                 ;org 2F80h
.text$mn:00002F80 ; COMDAT (pick any)
.text$mn:00002F80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F80
.text$mn:00002F80 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F80
.text$mn:00002F80 ; Attributes: bp-based frame
.text$mn:00002F80
.text$mn:00002F80 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00002F80                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002F80 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002F80                                         ; DATA XREF: .rdata:00003830o
.text$mn:00002F80
.text$mn:00002F80 var_14          = dword ptr -14h
.text$mn:00002F80 var_10          = dword ptr -10h
.text$mn:00002F80 var_C           = dword ptr -0Ch
.text$mn:00002F80 var_4           = dword ptr -4
.text$mn:00002F80 arg_0           = dword ptr  8
.text$mn:00002F80 arg_4           = dword ptr  0Ch
.text$mn:00002F80
.text$mn:00002F80                 push    ebp
.text$mn:00002F81                 mov     ebp, esp
.text$mn:00002F83                 push    0FFFFFFFFh
.text$mn:00002F85                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002F8A                 mov     eax, large fs:0
.text$mn:00002F90                 push    eax
.text$mn:00002F91                 sub     esp, 8
.text$mn:00002F94                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002F99                 xor     eax, ebp
.text$mn:00002F9B                 push    eax
.text$mn:00002F9C                 lea     eax, [ebp+var_C]
.text$mn:00002F9F                 mov     large fs:0, eax
.text$mn:00002FA5                 mov     [ebp+var_14], ecx
.text$mn:00002FA8                 mov     [ebp+var_10], 0
.text$mn:00002FAF                 cmp     [ebp+arg_4], 1
.text$mn:00002FB3                 jnz     short loc_2FD9
.text$mn:00002FB5                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00002FBA                 mov     ecx, [ebp+arg_0]
.text$mn:00002FBD                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002FC2                 mov     [ebp+var_4], 0
.text$mn:00002FC9                 mov     eax, [ebp+var_10]
.text$mn:00002FCC                 or      eax, 1
.text$mn:00002FCF                 mov     [ebp+var_10], eax
.text$mn:00002FD2                 mov     eax, [ebp+arg_0]
.text$mn:00002FD5                 jmp     short loc_2FFC
.text$mn:00002FD7 ; ---------------------------------------------------------------------------
.text$mn:00002FD7                 jmp     short loc_2FFC
.text$mn:00002FD9 ; ---------------------------------------------------------------------------
.text$mn:00002FD9
.text$mn:00002FD9 loc_2FD9:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00002FD9                 mov     ecx, [ebp+arg_4]
.text$mn:00002FDC                 push    ecx
.text$mn:00002FDD                 mov     edx, [ebp+arg_0]
.text$mn:00002FE0                 push    edx
.text$mn:00002FE1                 mov     ecx, [ebp+var_14]
.text$mn:00002FE4                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00002FE9                 mov     [ebp+var_4], 0
.text$mn:00002FF0                 mov     eax, [ebp+var_10]
.text$mn:00002FF3                 or      eax, 1
.text$mn:00002FF6                 mov     [ebp+var_10], eax
.text$mn:00002FF9                 mov     eax, [ebp+arg_0]
.text$mn:00002FFC
.text$mn:00002FFC loc_2FFC:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00002FFC                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00002FFC                 mov     ecx, [ebp+var_C]
.text$mn:00002FFF                 mov     large fs:0, ecx
.text$mn:00003006                 pop     ecx
.text$mn:00003007                 mov     esp, ebp
.text$mn:00003009                 pop     ebp
.text$mn:0000300A                 retn    8
.text$mn:0000300A ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:0000300A
.text$mn:0000300A ; ---------------------------------------------------------------------------
.text$mn:0000300D                 align 10h
.text$mn:0000300D _text$mn        ends
.text$mn:0000300D
.text$x:00003010 ; ===========================================================================
.text$x:00003010
.text$x:00003010 ; Segment type: Pure code
.text$x:00003010 ; Segment permissions: Read/Execute
.text$x:00003010 _text$x         segment para public 'CODE' use32
.text$x:00003010                 assume cs:_text$x
.text$x:00003010                 ;org 3010h
.text$x:00003010 ; COMDAT (pick associative to section at 2F80)
.text$x:00003010                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003010
.text$x:00003010 ; =============== S U B R O U T I N E =======================================
.text$x:00003010
.text$x:00003010
.text$x:00003010 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00003010                                         ; DATA XREF: .xdata$x:000034B4o
.text$x:00003010                 mov     eax, [ebp-10h]
.text$x:00003013                 and     eax, 1
.text$x:00003016                 jz      $LN6_0
.text$x:0000301C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00003020                 mov     ecx, [ebp+8]
.text$x:00003023                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003028 ; ---------------------------------------------------------------------------
.text$x:00003028
.text$x:00003028 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00003028                 retn
.text$x:00003028 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00003028
.text$x:00003029
.text$x:00003029 ; =============== S U B R O U T I N E =======================================
.text$x:00003029
.text$x:00003029
.text$x:00003029 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00003029                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00003029
.text$x:00003029 arg_4           = dword ptr  8
.text$x:00003029
.text$x:00003029                 mov     edx, [esp+arg_4]
.text$x:0000302D                 lea     eax, [edx+0Ch]
.text$x:00003030                 mov     ecx, [edx-0Ch]
.text$x:00003033                 xor     ecx, eax
.text$x:00003035                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000303A                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000303F                 jmp     ___CxxFrameHandler3
.text$x:0000303F __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000303F
.text$x:0000303F _text$x         ends
.text$x:0000303F
.text$mn:00003044 ; ===========================================================================
.text$mn:00003044
.text$mn:00003044 ; Segment type: Pure code
.text$mn:00003044 ; Segment permissions: Read/Execute
.text$mn:00003044 _text$mn        segment para public 'CODE' use32
.text$mn:00003044                 assume cs:_text$mn
.text$mn:00003044                 ;org 3044h
.text$mn:00003044 ; COMDAT (pick any)
.text$mn:00003044                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003044
.text$mn:00003044 ; =============== S U B R O U T I N E =======================================
.text$mn:00003044
.text$mn:00003044 ; Attributes: bp-based frame
.text$mn:00003044
.text$mn:00003044 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00003044                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003044 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00003044                                         ; DATA XREF: .rdata:00003870o
.text$mn:00003044
.text$mn:00003044 var_1C          = dword ptr -1Ch
.text$mn:00003044 var_18          = dword ptr -18h
.text$mn:00003044 Str             = dword ptr -14h
.text$mn:00003044 var_10          = dword ptr -10h
.text$mn:00003044 var_C           = dword ptr -0Ch
.text$mn:00003044 var_4           = dword ptr -4
.text$mn:00003044 arg_0           = dword ptr  8
.text$mn:00003044 arg_4           = dword ptr  0Ch
.text$mn:00003044
.text$mn:00003044                 push    ebp
.text$mn:00003045                 mov     ebp, esp
.text$mn:00003047                 push    0FFFFFFFFh
.text$mn:00003049                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000304E                 mov     eax, large fs:0
.text$mn:00003054                 push    eax
.text$mn:00003055                 sub     esp, 10h
.text$mn:00003058                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000305D                 xor     eax, ebp
.text$mn:0000305F                 push    eax
.text$mn:00003060                 lea     eax, [ebp+var_C]
.text$mn:00003063                 mov     large fs:0, eax
.text$mn:00003069                 mov     [ebp+var_1C], ecx
.text$mn:0000306C                 mov     [ebp+var_18], 0
.text$mn:00003073                 mov     eax, [ebp+arg_4]
.text$mn:00003076                 push    eax             ; int
.text$mn:00003077                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:0000307C                 add     esp, 4
.text$mn:0000307F                 mov     [ebp+var_10], eax
.text$mn:00003082                 cmp     [ebp+var_10], 0
.text$mn:00003086                 jz      short loc_3090
.text$mn:00003088                 mov     ecx, [ebp+var_10]
.text$mn:0000308B                 mov     [ebp+Str], ecx
.text$mn:0000308E                 jmp     short loc_3097
.text$mn:00003090 ; ---------------------------------------------------------------------------
.text$mn:00003090
.text$mn:00003090 loc_3090:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00003090                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00003097
.text$mn:00003097 loc_3097:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00003097                 mov     edx, [ebp+Str]
.text$mn:0000309A                 push    edx             ; Str
.text$mn:0000309B                 mov     ecx, [ebp+arg_0]
.text$mn:0000309E                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000030A3                 mov     [ebp+var_4], 0
.text$mn:000030AA                 mov     eax, [ebp+var_18]
.text$mn:000030AD                 or      eax, 1
.text$mn:000030B0                 mov     [ebp+var_18], eax
.text$mn:000030B3                 mov     eax, [ebp+arg_0]
.text$mn:000030B6                 mov     ecx, [ebp+var_C]
.text$mn:000030B9                 mov     large fs:0, ecx
.text$mn:000030C0                 pop     ecx
.text$mn:000030C1                 mov     esp, ebp
.text$mn:000030C3                 pop     ebp
.text$mn:000030C4                 retn    8
.text$mn:000030C4 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000030C4
.text$mn:000030C4 ; ---------------------------------------------------------------------------
.text$mn:000030C7                 align 4
.text$mn:000030C7 _text$mn        ends
.text$mn:000030C7
.text$x:000030C8 ; ===========================================================================
.text$x:000030C8
.text$x:000030C8 ; Segment type: Pure code
.text$x:000030C8 ; Segment permissions: Read/Execute
.text$x:000030C8 _text$x         segment para public 'CODE' use32
.text$x:000030C8                 assume cs:_text$x
.text$x:000030C8                 ;org 30C8h
.text$x:000030C8 ; COMDAT (pick associative to section at 3044)
.text$x:000030C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000030C8
.text$x:000030C8 ; =============== S U B R O U T I N E =======================================
.text$x:000030C8
.text$x:000030C8
.text$x:000030C8 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000030C8                                         ; DATA XREF: .xdata$x:00003538o
.text$x:000030C8                 mov     eax, [ebp-18h]
.text$x:000030CB                 and     eax, 1
.text$x:000030CE                 jz      $LN6_1
.text$x:000030D4                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:000030D8                 mov     ecx, [ebp+8]
.text$x:000030DB                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000030E0 ; ---------------------------------------------------------------------------
.text$x:000030E0
.text$x:000030E0 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000030E0                 retn
.text$x:000030E0 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000030E0
.text$x:000030E1
.text$x:000030E1 ; =============== S U B R O U T I N E =======================================
.text$x:000030E1
.text$x:000030E1
.text$x:000030E1 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000030E1                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:000030E1
.text$x:000030E1 arg_4           = dword ptr  8
.text$x:000030E1
.text$x:000030E1                 mov     edx, [esp+arg_4]
.text$x:000030E5                 lea     eax, [edx+0Ch]
.text$x:000030E8                 mov     ecx, [edx-14h]
.text$x:000030EB                 xor     ecx, eax
.text$x:000030ED                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000030F2                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000030F7                 jmp     ___CxxFrameHandler3
.text$x:000030F7 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000030F7
.text$x:000030F7 _text$x         ends
.text$x:000030F7
.text$mn:000030FC ; ===========================================================================
.text$mn:000030FC
.text$mn:000030FC ; Segment type: Pure code
.text$mn:000030FC ; Segment permissions: Read/Execute
.text$mn:000030FC _text$mn        segment para public 'CODE' use32
.text$mn:000030FC                 assume cs:_text$mn
.text$mn:000030FC                 ;org 30FCh
.text$mn:000030FC ; COMDAT (pick any)
.text$mn:000030FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030FC
.text$mn:000030FC ; =============== S U B R O U T I N E =======================================
.text$mn:000030FC
.text$mn:000030FC ; Attributes: bp-based frame
.text$mn:000030FC
.text$mn:000030FC ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000030FC                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000030FC ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000030FC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000030FC
.text$mn:000030FC var_4           = dword ptr -4
.text$mn:000030FC Dst             = dword ptr  8
.text$mn:000030FC Src             = dword ptr  0Ch
.text$mn:000030FC Size            = dword ptr  10h
.text$mn:000030FC
.text$mn:000030FC                 push    ebp
.text$mn:000030FD                 mov     ebp, esp
.text$mn:000030FF                 push    ecx
.text$mn:00003100                 cmp     [ebp+Size], 0
.text$mn:00003104                 jnz     short loc_310E
.text$mn:00003106                 mov     eax, [ebp+Dst]
.text$mn:00003109                 mov     [ebp+var_4], eax
.text$mn:0000310C                 jmp     short loc_3125
.text$mn:0000310E ; ---------------------------------------------------------------------------
.text$mn:0000310E
.text$mn:0000310E loc_310E:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:0000310E                 mov     ecx, [ebp+Size]
.text$mn:00003111                 push    ecx             ; Size
.text$mn:00003112                 mov     edx, [ebp+Src]
.text$mn:00003115                 push    edx             ; Src
.text$mn:00003116                 mov     eax, [ebp+Dst]
.text$mn:00003119                 push    eax             ; Dst
.text$mn:0000311A                 call    _memmove
.text$mn:0000311F                 add     esp, 0Ch
.text$mn:00003122                 mov     [ebp+var_4], eax
.text$mn:00003125
.text$mn:00003125 loc_3125:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00003125                 mov     eax, [ebp+var_4]
.text$mn:00003128                 mov     esp, ebp
.text$mn:0000312A                 pop     ebp
.text$mn:0000312B                 retn
.text$mn:0000312B ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000312B
.text$mn:0000312B _text$mn        ends
.text$mn:0000312B
.text$mn:0000312C ; ===========================================================================
.text$mn:0000312C
.text$mn:0000312C ; Segment type: Pure code
.text$mn:0000312C ; Segment permissions: Read/Execute
.text$mn:0000312C _text$mn        segment para public 'CODE' use32
.text$mn:0000312C                 assume cs:_text$mn
.text$mn:0000312C                 ;org 312Ch
.text$mn:0000312C ; COMDAT (pick any)
.text$mn:0000312C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000312C
.text$mn:0000312C ; =============== S U B R O U T I N E =======================================
.text$mn:0000312C
.text$mn:0000312C ; Attributes: bp-based frame
.text$mn:0000312C
.text$mn:0000312C ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:0000312C                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:0000312C ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:0000312C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:0000312C
.text$mn:0000312C var_4           = dword ptr -4
.text$mn:0000312C Dst             = dword ptr  8
.text$mn:0000312C Src             = dword ptr  0Ch
.text$mn:0000312C arg_8           = dword ptr  10h
.text$mn:0000312C
.text$mn:0000312C                 push    ebp
.text$mn:0000312D                 mov     ebp, esp
.text$mn:0000312F                 push    ecx
.text$mn:00003130                 cmp     [ebp+arg_8], 0
.text$mn:00003134                 jnz     short loc_313E
.text$mn:00003136                 mov     eax, [ebp+Dst]
.text$mn:00003139                 mov     [ebp+var_4], eax
.text$mn:0000313C                 jmp     short loc_3155
.text$mn:0000313E ; ---------------------------------------------------------------------------
.text$mn:0000313E
.text$mn:0000313E loc_313E:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:0000313E                 mov     ecx, [ebp+arg_8]
.text$mn:00003141                 push    ecx             ; int
.text$mn:00003142                 mov     edx, [ebp+Src]
.text$mn:00003145                 push    edx             ; Src
.text$mn:00003146                 mov     eax, [ebp+Dst]
.text$mn:00003149                 push    eax             ; Dst
.text$mn:0000314A                 call    _wmemmove
.text$mn:0000314F                 add     esp, 0Ch
.text$mn:00003152                 mov     [ebp+var_4], eax
.text$mn:00003155
.text$mn:00003155 loc_3155:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00003155                 mov     eax, [ebp+var_4]
.text$mn:00003158                 mov     esp, ebp
.text$mn:0000315A                 pop     ebp
.text$mn:0000315B                 retn
.text$mn:0000315B ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000315B
.text$mn:0000315B _text$mn        ends
.text$mn:0000315B
.text$mn:0000315C ; ===========================================================================
.text$mn:0000315C
.text$mn:0000315C ; Segment type: Pure code
.text$mn:0000315C ; Segment permissions: Read/Execute
.text$mn:0000315C _text$mn        segment para public 'CODE' use32
.text$mn:0000315C                 assume cs:_text$mn
.text$mn:0000315C                 ;org 315Ch
.text$mn:0000315C ; COMDAT (pick any)
.text$mn:0000315C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000315C
.text$mn:0000315C ; =============== S U B R O U T I N E =======================================
.text$mn:0000315C
.text$mn:0000315C ; Attributes: bp-based frame
.text$mn:0000315C
.text$mn:0000315C ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:0000315C                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:0000315C ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:0000315C                                         ; DATA XREF: .rdata:000037F8o
.text$mn:0000315C
.text$mn:0000315C var_4           = dword ptr -4
.text$mn:0000315C
.text$mn:0000315C                 push    ebp
.text$mn:0000315D                 mov     ebp, esp
.text$mn:0000315F                 push    ecx
.text$mn:00003160                 mov     [ebp+var_4], ecx
.text$mn:00003163                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00003168                 mov     esp, ebp
.text$mn:0000316A                 pop     ebp
.text$mn:0000316B                 retn
.text$mn:0000316B ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000316B
.text$mn:0000316B _text$mn        ends
.text$mn:0000316B
.text$mn:0000316C ; ===========================================================================
.text$mn:0000316C
.text$mn:0000316C ; Segment type: Pure code
.text$mn:0000316C ; Segment permissions: Read/Execute
.text$mn:0000316C _text$mn        segment para public 'CODE' use32
.text$mn:0000316C                 assume cs:_text$mn
.text$mn:0000316C                 ;org 316Ch
.text$mn:0000316C ; COMDAT (pick any)
.text$mn:0000316C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000316C
.text$mn:0000316C ; =============== S U B R O U T I N E =======================================
.text$mn:0000316C
.text$mn:0000316C ; Attributes: bp-based frame
.text$mn:0000316C
.text$mn:0000316C ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:0000316C                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:0000316C ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:0000316C                                         ; DATA XREF: .rdata:0000382Co
.text$mn:0000316C
.text$mn:0000316C var_4           = dword ptr -4
.text$mn:0000316C
.text$mn:0000316C                 push    ebp
.text$mn:0000316D                 mov     ebp, esp
.text$mn:0000316F                 push    ecx
.text$mn:00003170                 mov     [ebp+var_4], ecx
.text$mn:00003173                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00003178                 mov     esp, ebp
.text$mn:0000317A                 pop     ebp
.text$mn:0000317B                 retn
.text$mn:0000317B ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000317B
.text$mn:0000317B _text$mn        ends
.text$mn:0000317B
.text$mn:0000317C ; ===========================================================================
.text$mn:0000317C
.text$mn:0000317C ; Segment type: Pure code
.text$mn:0000317C ; Segment permissions: Read/Execute
.text$mn:0000317C _text$mn        segment para public 'CODE' use32
.text$mn:0000317C                 assume cs:_text$mn
.text$mn:0000317C                 ;org 317Ch
.text$mn:0000317C ; COMDAT (pick any)
.text$mn:0000317C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000317C
.text$mn:0000317C ; =============== S U B R O U T I N E =======================================
.text$mn:0000317C
.text$mn:0000317C ; Attributes: bp-based frame
.text$mn:0000317C
.text$mn:0000317C ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:0000317C                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:0000317C ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:0000317C                                         ; DATA XREF: .rdata:0000386Co
.text$mn:0000317C
.text$mn:0000317C var_4           = dword ptr -4
.text$mn:0000317C
.text$mn:0000317C                 push    ebp
.text$mn:0000317D                 mov     ebp, esp
.text$mn:0000317F                 push    ecx
.text$mn:00003180                 mov     [ebp+var_4], ecx
.text$mn:00003183                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00003188                 mov     esp, ebp
.text$mn:0000318A                 pop     ebp
.text$mn:0000318B                 retn
.text$mn:0000318B ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000318B
.text$mn:0000318B _text$mn        ends
.text$mn:0000318B
.text$mn:0000318C ; ===========================================================================
.text$mn:0000318C
.text$mn:0000318C ; Segment type: Pure code
.text$mn:0000318C ; Segment permissions: Read/Execute
.text$mn:0000318C _text$mn        segment para public 'CODE' use32
.text$mn:0000318C                 assume cs:_text$mn
.text$mn:0000318C                 ;org 318Ch
.text$mn:0000318C ; COMDAT (pick any)
.text$mn:0000318C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000318C
.text$mn:0000318C ; =============== S U B R O U T I N E =======================================
.text$mn:0000318C
.text$mn:0000318C ; Attributes: bp-based frame
.text$mn:0000318C
.text$mn:0000318C ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:0000318C                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:0000318C ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:0000318C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:0000318C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:0000318C
.text$mn:0000318C var_4           = dword ptr -4
.text$mn:0000318C
.text$mn:0000318C                 push    ebp
.text$mn:0000318D                 mov     ebp, esp
.text$mn:0000318F                 push    ecx
.text$mn:00003190                 mov     [ebp+var_4], ecx
.text$mn:00003193                 mov     eax, [ebp+var_4]
.text$mn:00003196                 mov     eax, [eax+14h]
.text$mn:00003199                 mov     esp, ebp
.text$mn:0000319B                 pop     ebp
.text$mn:0000319C                 retn
.text$mn:0000319C ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:0000319C
.text$mn:0000319C ; ---------------------------------------------------------------------------
.text$mn:0000319D                 align 10h
.text$mn:0000319D _text$mn        ends
.text$mn:0000319D
.text$mn:000031A0 ; ===========================================================================
.text$mn:000031A0
.text$mn:000031A0 ; Segment type: Pure code
.text$mn:000031A0 ; Segment permissions: Read/Execute
.text$mn:000031A0 _text$mn        segment para public 'CODE' use32
.text$mn:000031A0                 assume cs:_text$mn
.text$mn:000031A0                 ;org 31A0h
.text$mn:000031A0 ; COMDAT (pick any)
.text$mn:000031A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031A0
.text$mn:000031A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000031A0
.text$mn:000031A0 ; Attributes: bp-based frame
.text$mn:000031A0
.text$mn:000031A0 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:000031A0                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:000031A0 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:000031A0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:000031A0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p ...
.text$mn:000031A0
.text$mn:000031A0 var_4           = dword ptr -4
.text$mn:000031A0
.text$mn:000031A0                 push    ebp
.text$mn:000031A1                 mov     ebp, esp
.text$mn:000031A3                 push    ecx
.text$mn:000031A4                 mov     [ebp+var_4], ecx
.text$mn:000031A7                 mov     eax, [ebp+var_4]
.text$mn:000031AA                 mov     eax, [eax+14h]
.text$mn:000031AD                 mov     esp, ebp
.text$mn:000031AF                 pop     ebp
.text$mn:000031B0                 retn
.text$mn:000031B0 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:000031B0
.text$mn:000031B0 ; ---------------------------------------------------------------------------
.text$mn:000031B1                 align 4
.text$mn:000031B1 _text$mn        ends
.text$mn:000031B1
.text$mn:000031B4 ; ===========================================================================
.text$mn:000031B4
.text$mn:000031B4 ; Segment type: Pure code
.text$mn:000031B4 ; Segment permissions: Read/Execute
.text$mn:000031B4 _text$mn        segment para public 'CODE' use32
.text$mn:000031B4                 assume cs:_text$mn
.text$mn:000031B4                 ;org 31B4h
.text$mn:000031B4 ; COMDAT (pick any)
.text$mn:000031B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031B4
.text$mn:000031B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000031B4
.text$mn:000031B4 ; Attributes: bp-based frame
.text$mn:000031B4
.text$mn:000031B4 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:000031B4                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:000031B4 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000031B4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_2B14p
.text$mn:000031B4                 push    ebp
.text$mn:000031B5                 mov     ebp, esp
.text$mn:000031B7                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:000031BC                 pop     ebp
.text$mn:000031BD                 retn
.text$mn:000031BD ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000031BD
.text$mn:000031BD ; ---------------------------------------------------------------------------
.text$mn:000031BE                 align 10h
.text$mn:000031BE _text$mn        ends
.text$mn:000031BE
.text$mn:000031C0 ; ===========================================================================
.text$mn:000031C0
.text$mn:000031C0 ; Segment type: Pure code
.text$mn:000031C0 ; Segment permissions: Read/Execute
.text$mn:000031C0 _text$mn        segment para public 'CODE' use32
.text$mn:000031C0                 assume cs:_text$mn
.text$mn:000031C0                 ;org 31C0h
.text$mn:000031C0 ; COMDAT (pick any)
.text$mn:000031C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031C0
.text$mn:000031C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000031C0
.text$mn:000031C0 ; Attributes: bp-based frame
.text$mn:000031C0
.text$mn:000031C0 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:000031C0                 public ?value@error_code@std@@QBEHXZ
.text$mn:000031C0 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:000031C0
.text$mn:000031C0 var_4           = dword ptr -4
.text$mn:000031C0
.text$mn:000031C0                 push    ebp
.text$mn:000031C1                 mov     ebp, esp
.text$mn:000031C3                 push    ecx
.text$mn:000031C4                 mov     [ebp+var_4], ecx
.text$mn:000031C7                 mov     eax, [ebp+var_4]
.text$mn:000031CA                 mov     eax, [eax]
.text$mn:000031CC                 mov     esp, ebp
.text$mn:000031CE                 pop     ebp
.text$mn:000031CF                 retn
.text$mn:000031CF ?value@error_code@std@@QBEHXZ endp
.text$mn:000031CF
.text$mn:000031CF _text$mn        ends
.text$mn:000031CF
.text$mn:000031D0 ; ===========================================================================
.text$mn:000031D0
.text$mn:000031D0 ; Segment type: Pure code
.text$mn:000031D0 ; Segment permissions: Read/Execute
.text$mn:000031D0 _text$mn        segment para public 'CODE' use32
.text$mn:000031D0                 assume cs:_text$mn
.text$mn:000031D0                 ;org 31D0h
.text$mn:000031D0 ; COMDAT (pick any)
.text$mn:000031D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031D0
.text$mn:000031D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000031D0
.text$mn:000031D0 ; Attributes: bp-based frame
.text$mn:000031D0
.text$mn:000031D0 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:000031D0                 public ?value@error_condition@std@@QBEHXZ
.text$mn:000031D0 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:000031D0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:000031D0                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:000031D0
.text$mn:000031D0 var_4           = dword ptr -4
.text$mn:000031D0
.text$mn:000031D0                 push    ebp
.text$mn:000031D1                 mov     ebp, esp
.text$mn:000031D3                 push    ecx
.text$mn:000031D4                 mov     [ebp+var_4], ecx
.text$mn:000031D7                 mov     eax, [ebp+var_4]
.text$mn:000031DA                 mov     eax, [eax]
.text$mn:000031DC                 mov     esp, ebp
.text$mn:000031DE                 pop     ebp
.text$mn:000031DF                 retn
.text$mn:000031DF ?value@error_condition@std@@QBEHXZ endp
.text$mn:000031DF
.text$mn:000031DF _text$mn        ends
.text$mn:000031DF
.text$mn:000031E0 ; ===========================================================================
.text$mn:000031E0
.text$mn:000031E0 ; Segment type: Pure code
.text$mn:000031E0 ; Segment permissions: Read/Execute
.text$mn:000031E0 _text$mn        segment para public 'CODE' use32
.text$mn:000031E0                 assume cs:_text$mn
.text$mn:000031E0                 ;org 31E0h
.text$mn:000031E0 ; COMDAT (pick any)
.text$mn:000031E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031E0
.text$mn:000031E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000031E0
.text$mn:000031E0 ; Attributes: bp-based frame
.text$mn:000031E0
.text$mn:000031E0                 public _hypot
.text$mn:000031E0 _hypot          proc near
.text$mn:000031E0
.text$mn:000031E0 var_10          = qword ptr -10h
.text$mn:000031E0 var_8           = qword ptr -8
.text$mn:000031E0 arg_0           = qword ptr  8
.text$mn:000031E0 arg_8           = qword ptr  10h
.text$mn:000031E0
.text$mn:000031E0                 push    ebp
.text$mn:000031E1                 mov     ebp, esp
.text$mn:000031E3                 sub     esp, 8
.text$mn:000031E6                 movsd   xmm0, [ebp+arg_8]
.text$mn:000031EB                 movsd   [esp+8+var_8], xmm0
.text$mn:000031F0                 sub     esp, 8
.text$mn:000031F3                 movsd   xmm0, [ebp+arg_0]
.text$mn:000031F8                 movsd   [esp+10h+var_10], xmm0
.text$mn:000031FD                 call    __hypot
.text$mn:00003202                 add     esp, 10h
.text$mn:00003205                 pop     ebp
.text$mn:00003206                 retn
.text$mn:00003206 _hypot          endp
.text$mn:00003206
.text$mn:00003206 ; ---------------------------------------------------------------------------
.text$mn:00003207                 align 4
.text$mn:00003207 _text$mn        ends
.text$mn:00003207
.text$mn:00003208 ; ===========================================================================
.text$mn:00003208
.text$mn:00003208 ; Segment type: Pure code
.text$mn:00003208 ; Segment permissions: Read/Execute
.text$mn:00003208 _text$mn        segment para public 'CODE' use32
.text$mn:00003208                 assume cs:_text$mn
.text$mn:00003208                 ;org 3208h
.text$mn:00003208 ; COMDAT (pick any)
.text$mn:00003208                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003208
.text$mn:00003208 ; =============== S U B R O U T I N E =======================================
.text$mn:00003208
.text$mn:00003208 ; Attributes: bp-based frame
.text$mn:00003208
.text$mn:00003208 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:00003208                 public _wmemcpy
.text$mn:00003208 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00003208
.text$mn:00003208 Dst             = dword ptr  8
.text$mn:00003208 Src             = dword ptr  0Ch
.text$mn:00003208 arg_8           = dword ptr  10h
.text$mn:00003208
.text$mn:00003208                 push    ebp
.text$mn:00003209                 mov     ebp, esp
.text$mn:0000320B                 mov     eax, [ebp+arg_8]
.text$mn:0000320E                 shl     eax, 1
.text$mn:00003210                 push    eax             ; Size
.text$mn:00003211                 mov     ecx, [ebp+Src]
.text$mn:00003214                 push    ecx             ; Src
.text$mn:00003215                 mov     edx, [ebp+Dst]
.text$mn:00003218                 push    edx             ; Dst
.text$mn:00003219                 call    _memcpy
.text$mn:0000321E                 add     esp, 0Ch
.text$mn:00003221                 pop     ebp
.text$mn:00003222                 retn
.text$mn:00003222 _wmemcpy        endp
.text$mn:00003222
.text$mn:00003222 ; ---------------------------------------------------------------------------
.text$mn:00003223                 align 4
.text$mn:00003223 _text$mn        ends
.text$mn:00003223
.text$mn:00003224 ; ===========================================================================
.text$mn:00003224
.text$mn:00003224 ; Segment type: Pure code
.text$mn:00003224 ; Segment permissions: Read/Execute
.text$mn:00003224 _text$mn        segment para public 'CODE' use32
.text$mn:00003224                 assume cs:_text$mn
.text$mn:00003224                 ;org 3224h
.text$mn:00003224 ; COMDAT (pick any)
.text$mn:00003224                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003224
.text$mn:00003224 ; =============== S U B R O U T I N E =======================================
.text$mn:00003224
.text$mn:00003224 ; Attributes: bp-based frame
.text$mn:00003224
.text$mn:00003224 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:00003224                 public _wmemmove
.text$mn:00003224 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00003224
.text$mn:00003224 Dst             = dword ptr  8
.text$mn:00003224 Src             = dword ptr  0Ch
.text$mn:00003224 arg_8           = dword ptr  10h
.text$mn:00003224
.text$mn:00003224                 push    ebp
.text$mn:00003225                 mov     ebp, esp
.text$mn:00003227                 mov     eax, [ebp+arg_8]
.text$mn:0000322A                 shl     eax, 1
.text$mn:0000322C                 push    eax             ; Size
.text$mn:0000322D                 mov     ecx, [ebp+Src]
.text$mn:00003230                 push    ecx             ; Src
.text$mn:00003231                 mov     edx, [ebp+Dst]
.text$mn:00003234                 push    edx             ; Dst
.text$mn:00003235                 call    _memmove
.text$mn:0000323A                 add     esp, 0Ch
.text$mn:0000323D                 pop     ebp
.text$mn:0000323E                 retn
.text$mn:0000323E _wmemmove       endp
.text$mn:0000323E
.text$mn:0000323E ; ---------------------------------------------------------------------------
.text$mn:0000323F                 align 10h
.text$mn:0000323F _text$mn        ends
.text$mn:0000323F
.xdata$x:00003240 ; ===========================================================================
.xdata$x:00003240
.xdata$x:00003240 ; Segment type: Pure data
.xdata$x:00003240 ; Segment permissions: Read
.xdata$x:00003240 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003240                 assume cs:_xdata$x
.xdata$x:00003240                 ;org 3240h
.xdata$x:00003240 ; COMDAT (pick associative to section at 21C4)
.xdata$x:00003240 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00003240                                         ; DATA XREF: .xdata$x:00003250o
.xdata$x:00003241                 db 0FFh
.xdata$x:00003242                 db 0FFh
.xdata$x:00003243                 db 0FFh
.xdata$x:00003244                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00003248 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00003248                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00003249                 db    5
.xdata$x:0000324A                 db  93h ; ô
.xdata$x:0000324B                 db  19h
.xdata$x:0000324C                 db    1
.xdata$x:0000324D                 db    0
.xdata$x:0000324E                 db    0
.xdata$x:0000324F                 db    0
.xdata$x:00003250                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00003254                 db    0
.xdata$x:00003255                 db    0
.xdata$x:00003256                 db    0
.xdata$x:00003257                 db    0
.xdata$x:00003258                 db    0
.xdata$x:00003259                 db    0
.xdata$x:0000325A                 db    0
.xdata$x:0000325B                 db    0
.xdata$x:0000325C                 db    0
.xdata$x:0000325D                 db    0
.xdata$x:0000325E                 db    0
.xdata$x:0000325F                 db    0
.xdata$x:00003260                 db    0
.xdata$x:00003261                 db    0
.xdata$x:00003262                 db    0
.xdata$x:00003263                 db    0
.xdata$x:00003264                 db    0
.xdata$x:00003265                 db    0
.xdata$x:00003266                 db    0
.xdata$x:00003267                 db    0
.xdata$x:00003268                 db    0
.xdata$x:00003269                 db    0
.xdata$x:0000326A                 db    0
.xdata$x:0000326B                 db    0
.xdata$x:0000326B _xdata$x        ends
.xdata$x:0000326B
.xdata$x:0000326C ; ===========================================================================
.xdata$x:0000326C
.xdata$x:0000326C ; Segment type: Pure data
.xdata$x:0000326C ; Segment permissions: Read
.xdata$x:0000326C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000326C                 assume cs:_xdata$x
.xdata$x:0000326C                 ;org 326Ch
.xdata$x:0000326C ; COMDAT (pick associative to section at EA4)
.xdata$x:0000326C __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000326C                                         ; DATA XREF: .xdata$x:0000327Co
.xdata$x:0000326D                 db 0FFh
.xdata$x:0000326E                 db 0FFh
.xdata$x:0000326F                 db 0FFh
.xdata$x:00003270                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00003274 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003274                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00003275                 db    5
.xdata$x:00003276                 db  93h ; ô
.xdata$x:00003277                 db  19h
.xdata$x:00003278                 db    1
.xdata$x:00003279                 db    0
.xdata$x:0000327A                 db    0
.xdata$x:0000327B                 db    0
.xdata$x:0000327C                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00003280                 db    0
.xdata$x:00003281                 db    0
.xdata$x:00003282                 db    0
.xdata$x:00003283                 db    0
.xdata$x:00003284                 db    0
.xdata$x:00003285                 db    0
.xdata$x:00003286                 db    0
.xdata$x:00003287                 db    0
.xdata$x:00003288                 db    0
.xdata$x:00003289                 db    0
.xdata$x:0000328A                 db    0
.xdata$x:0000328B                 db    0
.xdata$x:0000328C                 db    0
.xdata$x:0000328D                 db    0
.xdata$x:0000328E                 db    0
.xdata$x:0000328F                 db    0
.xdata$x:00003290                 db    0
.xdata$x:00003291                 db    0
.xdata$x:00003292                 db    0
.xdata$x:00003293                 db    0
.xdata$x:00003294                 db    0
.xdata$x:00003295                 db    0
.xdata$x:00003296                 db    0
.xdata$x:00003297                 db    0
.xdata$x:00003297 _xdata$x        ends
.xdata$x:00003297
.xdata$x:00003298 ; ===========================================================================
.xdata$x:00003298
.xdata$x:00003298 ; Segment type: Pure data
.xdata$x:00003298 ; Segment permissions: Read
.xdata$x:00003298 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003298                 assume cs:_xdata$x
.xdata$x:00003298                 ;org 3298h
.xdata$x:00003298 ; COMDAT (pick associative to section at 1438)
.xdata$x:00003298 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003298                                         ; DATA XREF: .xdata$x:000032A8o
.xdata$x:00003299                 db 0FFh
.xdata$x:0000329A                 db 0FFh
.xdata$x:0000329B                 db 0FFh
.xdata$x:0000329C                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000032A0 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000032A0                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000032A1                 db    5
.xdata$x:000032A2                 db  93h ; ô
.xdata$x:000032A3                 db  19h
.xdata$x:000032A4                 db    1
.xdata$x:000032A5                 db    0
.xdata$x:000032A6                 db    0
.xdata$x:000032A7                 db    0
.xdata$x:000032A8                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000032AC                 db    0
.xdata$x:000032AD                 db    0
.xdata$x:000032AE                 db    0
.xdata$x:000032AF                 db    0
.xdata$x:000032B0                 db    0
.xdata$x:000032B1                 db    0
.xdata$x:000032B2                 db    0
.xdata$x:000032B3                 db    0
.xdata$x:000032B4                 db    0
.xdata$x:000032B5                 db    0
.xdata$x:000032B6                 db    0
.xdata$x:000032B7                 db    0
.xdata$x:000032B8                 db    0
.xdata$x:000032B9                 db    0
.xdata$x:000032BA                 db    0
.xdata$x:000032BB                 db    0
.xdata$x:000032BC                 db    0
.xdata$x:000032BD                 db    0
.xdata$x:000032BE                 db    0
.xdata$x:000032BF                 db    0
.xdata$x:000032C0                 db    0
.xdata$x:000032C1                 db    0
.xdata$x:000032C2                 db    0
.xdata$x:000032C3                 db    0
.xdata$x:000032C3 _xdata$x        ends
.xdata$x:000032C3
.xdata$x:000032C4 ; ===========================================================================
.xdata$x:000032C4
.xdata$x:000032C4 ; Segment type: Pure data
.xdata$x:000032C4 ; Segment permissions: Read
.xdata$x:000032C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000032C4                 assume cs:_xdata$x
.xdata$x:000032C4                 ;org 32C4h
.xdata$x:000032C4 ; COMDAT (pick associative to section at DAC)
.xdata$x:000032C4 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:000032C4                                         ; DATA XREF: .xdata$x:000032D4o
.xdata$x:000032C5                 db 0FFh
.xdata$x:000032C6                 db 0FFh
.xdata$x:000032C7                 db 0FFh
.xdata$x:000032C8                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:000032CC __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:000032CC                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:000032CD                 db    5
.xdata$x:000032CE                 db  93h ; ô
.xdata$x:000032CF                 db  19h
.xdata$x:000032D0                 db    1
.xdata$x:000032D1                 db    0
.xdata$x:000032D2                 db    0
.xdata$x:000032D3                 db    0
.xdata$x:000032D4                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:000032D8                 db    0
.xdata$x:000032D9                 db    0
.xdata$x:000032DA                 db    0
.xdata$x:000032DB                 db    0
.xdata$x:000032DC                 db    0
.xdata$x:000032DD                 db    0
.xdata$x:000032DE                 db    0
.xdata$x:000032DF                 db    0
.xdata$x:000032E0                 db    0
.xdata$x:000032E1                 db    0
.xdata$x:000032E2                 db    0
.xdata$x:000032E3                 db    0
.xdata$x:000032E4                 db    0
.xdata$x:000032E5                 db    0
.xdata$x:000032E6                 db    0
.xdata$x:000032E7                 db    0
.xdata$x:000032E8                 db    0
.xdata$x:000032E9                 db    0
.xdata$x:000032EA                 db    0
.xdata$x:000032EB                 db    0
.xdata$x:000032EC                 db    0
.xdata$x:000032ED                 db    0
.xdata$x:000032EE                 db    0
.xdata$x:000032EF                 db    0
.xdata$x:000032EF _xdata$x        ends
.xdata$x:000032EF
.xdata$x:000032F0 ; ===========================================================================
.xdata$x:000032F0
.xdata$x:000032F0 ; Segment type: Pure data
.xdata$x:000032F0 ; Segment permissions: Read
.xdata$x:000032F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000032F0                 assume cs:_xdata$x
.xdata$x:000032F0                 ;org 32F0h
.xdata$x:000032F0 ; COMDAT (pick associative to section at 1348)
.xdata$x:000032F0 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000032F0                                         ; DATA XREF: .xdata$x:00003300o
.xdata$x:000032F1                 db 0FFh
.xdata$x:000032F2                 db 0FFh
.xdata$x:000032F3                 db 0FFh
.xdata$x:000032F4                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000032F8 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000032F8                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000032F9                 db    5
.xdata$x:000032FA                 db  93h ; ô
.xdata$x:000032FB                 db  19h
.xdata$x:000032FC                 db    1
.xdata$x:000032FD                 db    0
.xdata$x:000032FE                 db    0
.xdata$x:000032FF                 db    0
.xdata$x:00003300                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00003304                 db    0
.xdata$x:00003305                 db    0
.xdata$x:00003306                 db    0
.xdata$x:00003307                 db    0
.xdata$x:00003308                 db    0
.xdata$x:00003309                 db    0
.xdata$x:0000330A                 db    0
.xdata$x:0000330B                 db    0
.xdata$x:0000330C                 db    0
.xdata$x:0000330D                 db    0
.xdata$x:0000330E                 db    0
.xdata$x:0000330F                 db    0
.xdata$x:00003310                 db    0
.xdata$x:00003311                 db    0
.xdata$x:00003312                 db    0
.xdata$x:00003313                 db    0
.xdata$x:00003314                 db    0
.xdata$x:00003315                 db    0
.xdata$x:00003316                 db    0
.xdata$x:00003317                 db    0
.xdata$x:00003318                 db    0
.xdata$x:00003319                 db    0
.xdata$x:0000331A                 db    0
.xdata$x:0000331B                 db    0
.xdata$x:0000331B _xdata$x        ends
.xdata$x:0000331B
.xdata$x:0000331C ; ===========================================================================
.xdata$x:0000331C
.xdata$x:0000331C ; Segment type: Pure data
.xdata$x:0000331C ; Segment permissions: Read
.xdata$x:0000331C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000331C                 assume cs:_xdata$x
.xdata$x:0000331C                 ;org 331Ch
.xdata$x:0000331C ; COMDAT (pick associative to section at 1014)
.xdata$x:0000331C __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:0000331C                                         ; DATA XREF: .xdata$x:0000332Co
.xdata$x:0000331D                 db 0FFh
.xdata$x:0000331E                 db 0FFh
.xdata$x:0000331F                 db 0FFh
.xdata$x:00003320                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00003324 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00003324                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00003325                 db    5
.xdata$x:00003326                 db  93h ; ô
.xdata$x:00003327                 db  19h
.xdata$x:00003328                 db    1
.xdata$x:00003329                 db    0
.xdata$x:0000332A                 db    0
.xdata$x:0000332B                 db    0
.xdata$x:0000332C                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00003330                 db    0
.xdata$x:00003331                 db    0
.xdata$x:00003332                 db    0
.xdata$x:00003333                 db    0
.xdata$x:00003334                 db    0
.xdata$x:00003335                 db    0
.xdata$x:00003336                 db    0
.xdata$x:00003337                 db    0
.xdata$x:00003338                 db    0
.xdata$x:00003339                 db    0
.xdata$x:0000333A                 db    0
.xdata$x:0000333B                 db    0
.xdata$x:0000333C                 db    0
.xdata$x:0000333D                 db    0
.xdata$x:0000333E                 db    0
.xdata$x:0000333F                 db    0
.xdata$x:00003340                 db    0
.xdata$x:00003341                 db    0
.xdata$x:00003342                 db    0
.xdata$x:00003343                 db    0
.xdata$x:00003344                 db    0
.xdata$x:00003345                 db    0
.xdata$x:00003346                 db    0
.xdata$x:00003347                 db    0
.xdata$x:00003347 _xdata$x        ends
.xdata$x:00003347
.xdata$x:00003348 ; ===========================================================================
.xdata$x:00003348
.xdata$x:00003348 ; Segment type: Pure data
.xdata$x:00003348 ; Segment permissions: Read
.xdata$x:00003348 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003348                 assume cs:_xdata$x
.xdata$x:00003348                 ;org 3348h
.xdata$x:00003348 ; COMDAT (pick associative to section at 1518)
.xdata$x:00003348 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00003348                                         ; DATA XREF: .xdata$x:00003358o
.xdata$x:00003349                 db 0FFh
.xdata$x:0000334A                 db 0FFh
.xdata$x:0000334B                 db 0FFh
.xdata$x:0000334C                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00003350 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00003350                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00003351                 db    5
.xdata$x:00003352                 db  93h ; ô
.xdata$x:00003353                 db  19h
.xdata$x:00003354                 db    1
.xdata$x:00003355                 db    0
.xdata$x:00003356                 db    0
.xdata$x:00003357                 db    0
.xdata$x:00003358                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:0000335C                 db    0
.xdata$x:0000335D                 db    0
.xdata$x:0000335E                 db    0
.xdata$x:0000335F                 db    0
.xdata$x:00003360                 db    0
.xdata$x:00003361                 db    0
.xdata$x:00003362                 db    0
.xdata$x:00003363                 db    0
.xdata$x:00003364                 db    0
.xdata$x:00003365                 db    0
.xdata$x:00003366                 db    0
.xdata$x:00003367                 db    0
.xdata$x:00003368                 db    0
.xdata$x:00003369                 db    0
.xdata$x:0000336A                 db    0
.xdata$x:0000336B                 db    0
.xdata$x:0000336C                 db    0
.xdata$x:0000336D                 db    0
.xdata$x:0000336E                 db    0
.xdata$x:0000336F                 db    0
.xdata$x:00003370                 db    0
.xdata$x:00003371                 db    0
.xdata$x:00003372                 db    0
.xdata$x:00003373                 db    0
.xdata$x:00003373 _xdata$x        ends
.xdata$x:00003373
.xdata$x:00003374 ; ===========================================================================
.xdata$x:00003374
.xdata$x:00003374 ; Segment type: Pure data
.xdata$x:00003374 ; Segment permissions: Read
.xdata$x:00003374 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003374                 assume cs:_xdata$x
.xdata$x:00003374                 ;org 3374h
.xdata$x:00003374 ; COMDAT (pick associative to section at 1A70)
.xdata$x:00003374 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00003374                                         ; DATA XREF: .xdata$x:000033FCo
.xdata$x:00003375                 db    0
.xdata$x:00003376                 db    0
.xdata$x:00003377                 db    0
.xdata$x:00003378                 db    0
.xdata$x:00003379                 db    0
.xdata$x:0000337A                 db    0
.xdata$x:0000337B                 db    0
.xdata$x:0000337C                 db    0
.xdata$x:0000337D                 db    0
.xdata$x:0000337E                 db    0
.xdata$x:0000337F                 db    0
.xdata$x:00003380                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00003384 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00003384                                         ; DATA XREF: .xdata$x:000033E8o
.xdata$x:00003385                 db    0
.xdata$x:00003386                 db    0
.xdata$x:00003387                 db    0
.xdata$x:00003388                 db    0
.xdata$x:00003389                 db    0
.xdata$x:0000338A                 db    0
.xdata$x:0000338B                 db    0
.xdata$x:0000338C                 db    0
.xdata$x:0000338D                 db    0
.xdata$x:0000338E                 db    0
.xdata$x:0000338F                 db    0
.xdata$x:00003390                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00003394 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00003394                                         ; DATA XREF: .xdata$x:000033BCo
.xdata$x:00003395                 db 0FFh
.xdata$x:00003396                 db 0FFh
.xdata$x:00003397                 db 0FFh
.xdata$x:00003398                 db    0
.xdata$x:00003399                 db    0
.xdata$x:0000339A                 db    0
.xdata$x:0000339B                 db    0
.xdata$x:0000339C                 db 0FFh
.xdata$x:0000339D                 db 0FFh
.xdata$x:0000339E                 db 0FFh
.xdata$x:0000339F                 db 0FFh
.xdata$x:000033A0                 db    0
.xdata$x:000033A1                 db    0
.xdata$x:000033A2                 db    0
.xdata$x:000033A3                 db    0
.xdata$x:000033A4                 db    1
.xdata$x:000033A5                 db    0
.xdata$x:000033A6                 db    0
.xdata$x:000033A7                 db    0
.xdata$x:000033A8                 db    0
.xdata$x:000033A9                 db    0
.xdata$x:000033AA                 db    0
.xdata$x:000033AB                 db    0
.xdata$x:000033AC                 db    1
.xdata$x:000033AD                 db    0
.xdata$x:000033AE                 db    0
.xdata$x:000033AF                 db    0
.xdata$x:000033B0                 db    0
.xdata$x:000033B1                 db    0
.xdata$x:000033B2                 db    0
.xdata$x:000033B3                 db    0
.xdata$x:000033B4 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:000033B4                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:000033B5                 db    5
.xdata$x:000033B6                 db  93h ; ô
.xdata$x:000033B7                 db  19h
.xdata$x:000033B8                 db    4
.xdata$x:000033B9                 db    0
.xdata$x:000033BA                 db    0
.xdata$x:000033BB                 db    0
.xdata$x:000033BC                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:000033C0                 db    2
.xdata$x:000033C1                 db    0
.xdata$x:000033C2                 db    0
.xdata$x:000033C3                 db    0
.xdata$x:000033C4                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:000033C8                 db    0
.xdata$x:000033C9                 db    0
.xdata$x:000033CA                 db    0
.xdata$x:000033CB                 db    0
.xdata$x:000033CC                 db    0
.xdata$x:000033CD                 db    0
.xdata$x:000033CE                 db    0
.xdata$x:000033CF                 db    0
.xdata$x:000033D0                 db    0
.xdata$x:000033D1                 db    0
.xdata$x:000033D2                 db    0
.xdata$x:000033D3                 db    0
.xdata$x:000033D4                 db    0
.xdata$x:000033D5                 db    0
.xdata$x:000033D6                 db    0
.xdata$x:000033D7                 db    0
.xdata$x:000033D8 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:000033D8                                         ; DATA XREF: .xdata$x:000033C4o
.xdata$x:000033D9                 db    0
.xdata$x:000033DA                 db    0
.xdata$x:000033DB                 db    0
.xdata$x:000033DC                 db    2
.xdata$x:000033DD                 db    0
.xdata$x:000033DE                 db    0
.xdata$x:000033DF                 db    0
.xdata$x:000033E0                 db    3
.xdata$x:000033E1                 db    0
.xdata$x:000033E2                 db    0
.xdata$x:000033E3                 db    0
.xdata$x:000033E4                 db    1
.xdata$x:000033E5                 db    0
.xdata$x:000033E6                 db    0
.xdata$x:000033E7                 db    0
.xdata$x:000033E8                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:000033EC                 db    0
.xdata$x:000033ED                 db    0
.xdata$x:000033EE                 db    0
.xdata$x:000033EF                 db    0
.xdata$x:000033F0                 db    0
.xdata$x:000033F1                 db    0
.xdata$x:000033F2                 db    0
.xdata$x:000033F3                 db    0
.xdata$x:000033F4                 db    3
.xdata$x:000033F5                 db    0
.xdata$x:000033F6                 db    0
.xdata$x:000033F7                 db    0
.xdata$x:000033F8                 db    1
.xdata$x:000033F9                 db    0
.xdata$x:000033FA                 db    0
.xdata$x:000033FB                 db    0
.xdata$x:000033FC                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:000033FC _xdata$x        ends
.xdata$x:000033FC
.xdata$x:00003400 ; ===========================================================================
.xdata$x:00003400
.xdata$x:00003400 ; Segment type: Pure data
.xdata$x:00003400 ; Segment permissions: Read
.xdata$x:00003400 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003400                 assume cs:_xdata$x
.xdata$x:00003400                 ;org 3400h
.xdata$x:00003400 ; COMDAT (pick associative to section at 1180)
.xdata$x:00003400 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00003400                                         ; DATA XREF: .xdata$x:00003410o
.xdata$x:00003401                 db 0FFh
.xdata$x:00003402                 db 0FFh
.xdata$x:00003403                 db 0FFh
.xdata$x:00003404                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00003408 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00003408                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00003409                 db    5
.xdata$x:0000340A                 db  93h ; ô
.xdata$x:0000340B                 db  19h
.xdata$x:0000340C                 db    1
.xdata$x:0000340D                 db    0
.xdata$x:0000340E                 db    0
.xdata$x:0000340F                 db    0
.xdata$x:00003410                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:00003414                 db    0
.xdata$x:00003415                 db    0
.xdata$x:00003416                 db    0
.xdata$x:00003417                 db    0
.xdata$x:00003418                 db    0
.xdata$x:00003419                 db    0
.xdata$x:0000341A                 db    0
.xdata$x:0000341B                 db    0
.xdata$x:0000341C                 db    0
.xdata$x:0000341D                 db    0
.xdata$x:0000341E                 db    0
.xdata$x:0000341F                 db    0
.xdata$x:00003420                 db    0
.xdata$x:00003421                 db    0
.xdata$x:00003422                 db    0
.xdata$x:00003423                 db    0
.xdata$x:00003424                 db    0
.xdata$x:00003425                 db    0
.xdata$x:00003426                 db    0
.xdata$x:00003427                 db    0
.xdata$x:00003428                 db    0
.xdata$x:00003429                 db    0
.xdata$x:0000342A                 db    0
.xdata$x:0000342B                 db    0
.xdata$x:0000342B _xdata$x        ends
.xdata$x:0000342B
.xdata$x:0000342C ; ===========================================================================
.xdata$x:0000342C
.xdata$x:0000342C ; Segment type: Pure data
.xdata$x:0000342C ; Segment permissions: Read
.xdata$x:0000342C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000342C                 assume cs:_xdata$x
.xdata$x:0000342C                 ;org 342Ch
.xdata$x:0000342C ; COMDAT (pick associative to section at 2EC8)
.xdata$x:0000342C __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000342C                                         ; DATA XREF: .xdata$x:0000343Co
.xdata$x:0000342D                 db 0FFh
.xdata$x:0000342E                 db 0FFh
.xdata$x:0000342F                 db 0FFh
.xdata$x:00003430                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00003434 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00003434                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00003435                 db    5
.xdata$x:00003436                 db  93h ; ô
.xdata$x:00003437                 db  19h
.xdata$x:00003438                 db    1
.xdata$x:00003439                 db    0
.xdata$x:0000343A                 db    0
.xdata$x:0000343B                 db    0
.xdata$x:0000343C                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00003440                 db    0
.xdata$x:00003441                 db    0
.xdata$x:00003442                 db    0
.xdata$x:00003443                 db    0
.xdata$x:00003444                 db    0
.xdata$x:00003445                 db    0
.xdata$x:00003446                 db    0
.xdata$x:00003447                 db    0
.xdata$x:00003448                 db    0
.xdata$x:00003449                 db    0
.xdata$x:0000344A                 db    0
.xdata$x:0000344B                 db    0
.xdata$x:0000344C                 db    0
.xdata$x:0000344D                 db    0
.xdata$x:0000344E                 db    0
.xdata$x:0000344F                 db    0
.xdata$x:00003450                 db    0
.xdata$x:00003451                 db    0
.xdata$x:00003452                 db    0
.xdata$x:00003453                 db    0
.xdata$x:00003454                 db    0
.xdata$x:00003455                 db    0
.xdata$x:00003456                 db    0
.xdata$x:00003457                 db    0
.xdata$x:00003457 _xdata$x        ends
.xdata$x:00003457
.xdata$x:00003458 ; ===========================================================================
.xdata$x:00003458
.xdata$x:00003458 ; Segment type: Pure data
.xdata$x:00003458 ; Segment permissions: Read
.xdata$x:00003458 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003458                 assume cs:_xdata$x
.xdata$x:00003458                 ;org 3458h
.xdata$x:00003458 ; COMDAT (pick associative to section at 1624)
.xdata$x:00003458 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00003458                                         ; DATA XREF: .xdata$x:00003468o
.xdata$x:00003459                 db 0FFh
.xdata$x:0000345A                 db 0FFh
.xdata$x:0000345B                 db 0FFh
.xdata$x:0000345C                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00003460 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00003460                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00003461                 db    5
.xdata$x:00003462                 db  93h ; ô
.xdata$x:00003463                 db  19h
.xdata$x:00003464                 db    1
.xdata$x:00003465                 db    0
.xdata$x:00003466                 db    0
.xdata$x:00003467                 db    0
.xdata$x:00003468                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:0000346C                 db    0
.xdata$x:0000346D                 db    0
.xdata$x:0000346E                 db    0
.xdata$x:0000346F                 db    0
.xdata$x:00003470                 db    0
.xdata$x:00003471                 db    0
.xdata$x:00003472                 db    0
.xdata$x:00003473                 db    0
.xdata$x:00003474                 db    0
.xdata$x:00003475                 db    0
.xdata$x:00003476                 db    0
.xdata$x:00003477                 db    0
.xdata$x:00003478                 db    0
.xdata$x:00003479                 db    0
.xdata$x:0000347A                 db    0
.xdata$x:0000347B                 db    0
.xdata$x:0000347C                 db    0
.xdata$x:0000347D                 db    0
.xdata$x:0000347E                 db    0
.xdata$x:0000347F                 db    0
.xdata$x:00003480                 db    0
.xdata$x:00003481                 db    0
.xdata$x:00003482                 db    0
.xdata$x:00003483                 db    0
.xdata$x:00003483 _xdata$x        ends
.xdata$x:00003483
.xdata$x:00003484 ; ===========================================================================
.xdata$x:00003484
.xdata$x:00003484 ; Segment type: Pure data
.xdata$x:00003484 ; Segment permissions: Read
.xdata$x:00003484 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003484                 assume cs:_xdata$x
.xdata$x:00003484                 ;org 3484h
.xdata$x:00003484 ; COMDAT (pick associative to section at 11FC)
.xdata$x:00003484 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00003484                                         ; DATA XREF: .xdata$x:00003494o
.xdata$x:00003485                 db 0FFh
.xdata$x:00003486                 db 0FFh
.xdata$x:00003487                 db 0FFh
.xdata$x:00003488                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:0000348C __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:0000348C                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:0000348D                 db    5
.xdata$x:0000348E                 db  93h ; ô
.xdata$x:0000348F                 db  19h
.xdata$x:00003490                 db    1
.xdata$x:00003491                 db    0
.xdata$x:00003492                 db    0
.xdata$x:00003493                 db    0
.xdata$x:00003494                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00003498                 db    0
.xdata$x:00003499                 db    0
.xdata$x:0000349A                 db    0
.xdata$x:0000349B                 db    0
.xdata$x:0000349C                 db    0
.xdata$x:0000349D                 db    0
.xdata$x:0000349E                 db    0
.xdata$x:0000349F                 db    0
.xdata$x:000034A0                 db    0
.xdata$x:000034A1                 db    0
.xdata$x:000034A2                 db    0
.xdata$x:000034A3                 db    0
.xdata$x:000034A4                 db    0
.xdata$x:000034A5                 db    0
.xdata$x:000034A6                 db    0
.xdata$x:000034A7                 db    0
.xdata$x:000034A8                 db    0
.xdata$x:000034A9                 db    0
.xdata$x:000034AA                 db    0
.xdata$x:000034AB                 db    0
.xdata$x:000034AC                 db    0
.xdata$x:000034AD                 db    0
.xdata$x:000034AE                 db    0
.xdata$x:000034AF                 db    0
.xdata$x:000034AF _xdata$x        ends
.xdata$x:000034AF
.xdata$x:000034B0 ; ===========================================================================
.xdata$x:000034B0
.xdata$x:000034B0 ; Segment type: Pure data
.xdata$x:000034B0 ; Segment permissions: Read
.xdata$x:000034B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000034B0                 assume cs:_xdata$x
.xdata$x:000034B0                 ;org 34B0h
.xdata$x:000034B0 ; COMDAT (pick associative to section at 2F80)
.xdata$x:000034B0 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000034B0                                         ; DATA XREF: .xdata$x:000034C0o
.xdata$x:000034B1                 db 0FFh
.xdata$x:000034B2                 db 0FFh
.xdata$x:000034B3                 db 0FFh
.xdata$x:000034B4                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000034B8 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000034B8                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000034B9                 db    5
.xdata$x:000034BA                 db  93h ; ô
.xdata$x:000034BB                 db  19h
.xdata$x:000034BC                 db    1
.xdata$x:000034BD                 db    0
.xdata$x:000034BE                 db    0
.xdata$x:000034BF                 db    0
.xdata$x:000034C0                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000034C4                 db    0
.xdata$x:000034C5                 db    0
.xdata$x:000034C6                 db    0
.xdata$x:000034C7                 db    0
.xdata$x:000034C8                 db    0
.xdata$x:000034C9                 db    0
.xdata$x:000034CA                 db    0
.xdata$x:000034CB                 db    0
.xdata$x:000034CC                 db    0
.xdata$x:000034CD                 db    0
.xdata$x:000034CE                 db    0
.xdata$x:000034CF                 db    0
.xdata$x:000034D0                 db    0
.xdata$x:000034D1                 db    0
.xdata$x:000034D2                 db    0
.xdata$x:000034D3                 db    0
.xdata$x:000034D4                 db    0
.xdata$x:000034D5                 db    0
.xdata$x:000034D6                 db    0
.xdata$x:000034D7                 db    0
.xdata$x:000034D8                 db    0
.xdata$x:000034D9                 db    0
.xdata$x:000034DA                 db    0
.xdata$x:000034DB                 db    0
.xdata$x:000034DB _xdata$x        ends
.xdata$x:000034DB
.xdata$x:000034DC ; ===========================================================================
.xdata$x:000034DC
.xdata$x:000034DC ; Segment type: Pure data
.xdata$x:000034DC ; Segment permissions: Read
.xdata$x:000034DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000034DC                 assume cs:_xdata$x
.xdata$x:000034DC                 ;org 34DCh
.xdata$x:000034DC ; COMDAT (pick associative to section at 1694)
.xdata$x:000034DC __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000034DC                                         ; DATA XREF: .xdata$x:000034ECo
.xdata$x:000034DD                 db 0FFh
.xdata$x:000034DE                 db 0FFh
.xdata$x:000034DF                 db 0FFh
.xdata$x:000034E0                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:000034E4 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000034E4                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:000034E5                 db    5
.xdata$x:000034E6                 db  93h ; ô
.xdata$x:000034E7                 db  19h
.xdata$x:000034E8                 db    1
.xdata$x:000034E9                 db    0
.xdata$x:000034EA                 db    0
.xdata$x:000034EB                 db    0
.xdata$x:000034EC                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000034F0                 db    0
.xdata$x:000034F1                 db    0
.xdata$x:000034F2                 db    0
.xdata$x:000034F3                 db    0
.xdata$x:000034F4                 db    0
.xdata$x:000034F5                 db    0
.xdata$x:000034F6                 db    0
.xdata$x:000034F7                 db    0
.xdata$x:000034F8                 db    0
.xdata$x:000034F9                 db    0
.xdata$x:000034FA                 db    0
.xdata$x:000034FB                 db    0
.xdata$x:000034FC                 db    0
.xdata$x:000034FD                 db    0
.xdata$x:000034FE                 db    0
.xdata$x:000034FF                 db    0
.xdata$x:00003500                 db    0
.xdata$x:00003501                 db    0
.xdata$x:00003502                 db    0
.xdata$x:00003503                 db    0
.xdata$x:00003504                 db    0
.xdata$x:00003505                 db    0
.xdata$x:00003506                 db    0
.xdata$x:00003507                 db    0
.xdata$x:00003507 _xdata$x        ends
.xdata$x:00003507
.xdata$x:00003508 ; ===========================================================================
.xdata$x:00003508
.xdata$x:00003508 ; Segment type: Pure data
.xdata$x:00003508 ; Segment permissions: Read
.xdata$x:00003508 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003508                 assume cs:_xdata$x
.xdata$x:00003508                 ;org 3508h
.xdata$x:00003508 ; COMDAT (pick associative to section at 1278)
.xdata$x:00003508 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00003508                                         ; DATA XREF: .xdata$x:00003518o
.xdata$x:00003509                 db 0FFh
.xdata$x:0000350A                 db 0FFh
.xdata$x:0000350B                 db 0FFh
.xdata$x:0000350C                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00003510 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00003510                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00003511                 db    5
.xdata$x:00003512                 db  93h ; ô
.xdata$x:00003513                 db  19h
.xdata$x:00003514                 db    1
.xdata$x:00003515                 db    0
.xdata$x:00003516                 db    0
.xdata$x:00003517                 db    0
.xdata$x:00003518                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:0000351C                 db    0
.xdata$x:0000351D                 db    0
.xdata$x:0000351E                 db    0
.xdata$x:0000351F                 db    0
.xdata$x:00003520                 db    0
.xdata$x:00003521                 db    0
.xdata$x:00003522                 db    0
.xdata$x:00003523                 db    0
.xdata$x:00003524                 db    0
.xdata$x:00003525                 db    0
.xdata$x:00003526                 db    0
.xdata$x:00003527                 db    0
.xdata$x:00003528                 db    0
.xdata$x:00003529                 db    0
.xdata$x:0000352A                 db    0
.xdata$x:0000352B                 db    0
.xdata$x:0000352C                 db    0
.xdata$x:0000352D                 db    0
.xdata$x:0000352E                 db    0
.xdata$x:0000352F                 db    0
.xdata$x:00003530                 db    0
.xdata$x:00003531                 db    0
.xdata$x:00003532                 db    0
.xdata$x:00003533                 db    0
.xdata$x:00003533 _xdata$x        ends
.xdata$x:00003533
.xdata$x:00003534 ; ===========================================================================
.xdata$x:00003534
.xdata$x:00003534 ; Segment type: Pure data
.xdata$x:00003534 ; Segment permissions: Read
.xdata$x:00003534 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003534                 assume cs:_xdata$x
.xdata$x:00003534                 ;org 3534h
.xdata$x:00003534 ; COMDAT (pick associative to section at 3044)
.xdata$x:00003534 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00003534                                         ; DATA XREF: .xdata$x:00003544o
.xdata$x:00003535                 db 0FFh
.xdata$x:00003536                 db 0FFh
.xdata$x:00003537                 db 0FFh
.xdata$x:00003538                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000353C __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000353C                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000353D                 db    5
.xdata$x:0000353E                 db  93h ; ô
.xdata$x:0000353F                 db  19h
.xdata$x:00003540                 db    1
.xdata$x:00003541                 db    0
.xdata$x:00003542                 db    0
.xdata$x:00003543                 db    0
.xdata$x:00003544                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00003548                 align 20h
.xdata$x:00003548 _xdata$x        ends
.xdata$x:00003548
.xdata$x:00003560 ; ===========================================================================
.xdata$x:00003560
.xdata$x:00003560 ; Segment type: Pure data
.xdata$x:00003560 ; Segment permissions: Read
.xdata$x:00003560 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003560                 assume cs:_xdata$x
.xdata$x:00003560                 ;org 3560h
.xdata$x:00003560 ; COMDAT (pick associative to section at 1704)
.xdata$x:00003560 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00003560                                         ; DATA XREF: .xdata$x:00003570o
.xdata$x:00003561                 db 0FFh
.xdata$x:00003562                 db 0FFh
.xdata$x:00003563                 db 0FFh
.xdata$x:00003564                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00003568 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00003568                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00003569                 db    5
.xdata$x:0000356A                 db  93h ; ô
.xdata$x:0000356B                 db  19h
.xdata$x:0000356C                 db    1
.xdata$x:0000356D                 db    0
.xdata$x:0000356E                 db    0
.xdata$x:0000356F                 db    0
.xdata$x:00003570                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00003574                 db    0
.xdata$x:00003575                 db    0
.xdata$x:00003576                 db    0
.xdata$x:00003577                 db    0
.xdata$x:00003578                 db    0
.xdata$x:00003579                 db    0
.xdata$x:0000357A                 db    0
.xdata$x:0000357B                 db    0
.xdata$x:0000357C                 db    0
.xdata$x:0000357D                 db    0
.xdata$x:0000357E                 db    0
.xdata$x:0000357F                 db    0
.xdata$x:00003580                 db    0
.xdata$x:00003581                 db    0
.xdata$x:00003582                 db    0
.xdata$x:00003583                 db    0
.xdata$x:00003584                 db    0
.xdata$x:00003585                 db    0
.xdata$x:00003586                 db    0
.xdata$x:00003587                 db    0
.xdata$x:00003588                 db    0
.xdata$x:00003589                 db    0
.xdata$x:0000358A                 db    0
.xdata$x:0000358B                 db    0
.xdata$x:0000358B _xdata$x        ends
.xdata$x:0000358B
.xdata$x:0000358C ; ===========================================================================
.xdata$x:0000358C
.xdata$x:0000358C ; Segment type: Pure data
.xdata$x:0000358C ; Segment permissions: Read
.xdata$x:0000358C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000358C                 assume cs:_xdata$x
.xdata$x:0000358C                 ;org 358Ch
.xdata$x:0000358C ; COMDAT (pick associative to section at F2C)
.xdata$x:0000358C __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000358C                                         ; DATA XREF: .xdata$x:0000359Co
.xdata$x:0000358D                 db 0FFh
.xdata$x:0000358E                 db 0FFh
.xdata$x:0000358F                 db 0FFh
.xdata$x:00003590                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00003594 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003594                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00003595                 db    5
.xdata$x:00003596                 db  93h ; ô
.xdata$x:00003597                 db  19h
.xdata$x:00003598                 db    1
.xdata$x:00003599                 db    0
.xdata$x:0000359A                 db    0
.xdata$x:0000359B                 db    0
.xdata$x:0000359C                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:000035A0                 db    0
.xdata$x:000035A1                 db    0
.xdata$x:000035A2                 db    0
.xdata$x:000035A3                 db    0
.xdata$x:000035A4                 db    0
.xdata$x:000035A5                 db    0
.xdata$x:000035A6                 db    0
.xdata$x:000035A7                 db    0
.xdata$x:000035A8                 db    0
.xdata$x:000035A9                 db    0
.xdata$x:000035AA                 db    0
.xdata$x:000035AB                 db    0
.xdata$x:000035AC                 db    0
.xdata$x:000035AD                 db    0
.xdata$x:000035AE                 db    0
.xdata$x:000035AF                 db    0
.xdata$x:000035B0                 db    0
.xdata$x:000035B1                 db    0
.xdata$x:000035B2                 db    0
.xdata$x:000035B3                 db    0
.xdata$x:000035B4                 db    0
.xdata$x:000035B5                 db    0
.xdata$x:000035B6                 db    0
.xdata$x:000035B7                 db    0
.xdata$x:000035B7 _xdata$x        ends
.xdata$x:000035B7
.xdata$x:000035B8 ; ===========================================================================
.xdata$x:000035B8
.xdata$x:000035B8 ; Segment type: Pure data
.xdata$x:000035B8 ; Segment permissions: Read
.xdata$x:000035B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000035B8                 assume cs:_xdata$x
.xdata$x:000035B8                 ;org 35B8h
.xdata$x:000035B8 ; COMDAT (pick associative to section at 14A8)
.xdata$x:000035B8 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000035B8                                         ; DATA XREF: .xdata$x:000035C8o
.xdata$x:000035B9                 db 0FFh
.xdata$x:000035BA                 db 0FFh
.xdata$x:000035BB                 db 0FFh
.xdata$x:000035BC                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:000035C0 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000035C0                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:000035C1                 db    5
.xdata$x:000035C2                 db  93h ; ô
.xdata$x:000035C3                 db  19h
.xdata$x:000035C4                 db    1
.xdata$x:000035C5                 db    0
.xdata$x:000035C6                 db    0
.xdata$x:000035C7                 db    0
.xdata$x:000035C8                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:000035CC                 db    0
.xdata$x:000035CD                 db    0
.xdata$x:000035CE                 db    0
.xdata$x:000035CF                 db    0
.xdata$x:000035D0                 db    0
.xdata$x:000035D1                 db    0
.xdata$x:000035D2                 db    0
.xdata$x:000035D3                 db    0
.xdata$x:000035D4                 db    0
.xdata$x:000035D5                 db    0
.xdata$x:000035D6                 db    0
.xdata$x:000035D7                 db    0
.xdata$x:000035D8                 db    0
.xdata$x:000035D9                 db    0
.xdata$x:000035DA                 db    0
.xdata$x:000035DB                 db    0
.xdata$x:000035DC                 db    0
.xdata$x:000035DD                 db    0
.xdata$x:000035DE                 db    0
.xdata$x:000035DF                 db    0
.xdata$x:000035E0                 db    0
.xdata$x:000035E1                 db    0
.xdata$x:000035E2                 db    0
.xdata$x:000035E3                 db    0
.xdata$x:000035E3 _xdata$x        ends
.xdata$x:000035E3
.xdata$x:000035E4 ; ===========================================================================
.xdata$x:000035E4
.xdata$x:000035E4 ; Segment type: Pure data
.xdata$x:000035E4 ; Segment permissions: Read
.xdata$x:000035E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000035E4                 assume cs:_xdata$x
.xdata$x:000035E4                 ;org 35E4h
.xdata$x:000035E4 ; COMDAT (pick associative to section at E28)
.xdata$x:000035E4 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:000035E4                                         ; DATA XREF: .xdata$x:000035F4o
.xdata$x:000035E5                 db 0FFh
.xdata$x:000035E6                 db 0FFh
.xdata$x:000035E7                 db 0FFh
.xdata$x:000035E8                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:000035EC __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:000035EC                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:000035ED                 db    5
.xdata$x:000035EE                 db  93h ; ô
.xdata$x:000035EF                 db  19h
.xdata$x:000035F0                 db    1
.xdata$x:000035F1                 db    0
.xdata$x:000035F2                 db    0
.xdata$x:000035F3                 db    0
.xdata$x:000035F4                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:000035F8                 db    0
.xdata$x:000035F9                 db    0
.xdata$x:000035FA                 db    0
.xdata$x:000035FB                 db    0
.xdata$x:000035FC                 db    0
.xdata$x:000035FD                 db    0
.xdata$x:000035FE                 db    0
.xdata$x:000035FF                 db    0
.xdata$x:00003600                 db    0
.xdata$x:00003601                 db    0
.xdata$x:00003602                 db    0
.xdata$x:00003603                 db    0
.xdata$x:00003604                 db    0
.xdata$x:00003605                 db    0
.xdata$x:00003606                 db    0
.xdata$x:00003607                 db    0
.xdata$x:00003608                 db    0
.xdata$x:00003609                 db    0
.xdata$x:0000360A                 db    0
.xdata$x:0000360B                 db    0
.xdata$x:0000360C                 db    0
.xdata$x:0000360D                 db    0
.xdata$x:0000360E                 db    0
.xdata$x:0000360F                 db    0
.xdata$x:0000360F _xdata$x        ends
.xdata$x:0000360F
.xdata$x:00003610 ; ===========================================================================
.xdata$x:00003610
.xdata$x:00003610 ; Segment type: Pure data
.xdata$x:00003610 ; Segment permissions: Read
.xdata$x:00003610 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003610                 assume cs:_xdata$x
.xdata$x:00003610                 ;org 3610h
.xdata$x:00003610 ; COMDAT (pick associative to section at 13C0)
.xdata$x:00003610 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003610                                         ; DATA XREF: .xdata$x:00003620o
.xdata$x:00003611                 db 0FFh
.xdata$x:00003612                 db 0FFh
.xdata$x:00003613                 db 0FFh
.xdata$x:00003614                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00003618 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003618                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00003619                 db    5
.xdata$x:0000361A                 db  93h ; ô
.xdata$x:0000361B                 db  19h
.xdata$x:0000361C                 db    1
.xdata$x:0000361D                 db    0
.xdata$x:0000361E                 db    0
.xdata$x:0000361F                 db    0
.xdata$x:00003620                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:00003624                 db    0
.xdata$x:00003625                 db    0
.xdata$x:00003626                 db    0
.xdata$x:00003627                 db    0
.xdata$x:00003628                 db    0
.xdata$x:00003629                 db    0
.xdata$x:0000362A                 db    0
.xdata$x:0000362B                 db    0
.xdata$x:0000362C                 db    0
.xdata$x:0000362D                 db    0
.xdata$x:0000362E                 db    0
.xdata$x:0000362F                 db    0
.xdata$x:00003630                 db    0
.xdata$x:00003631                 db    0
.xdata$x:00003632                 db    0
.xdata$x:00003633                 db    0
.xdata$x:00003634                 db    0
.xdata$x:00003635                 db    0
.xdata$x:00003636                 db    0
.xdata$x:00003637                 db    0
.xdata$x:00003638                 db    0
.xdata$x:00003639                 db    0
.xdata$x:0000363A                 db    0
.xdata$x:0000363B                 db    0
.xdata$x:0000363B _xdata$x        ends
.xdata$x:0000363B
.xdata$x:0000363C ; ===========================================================================
.xdata$x:0000363C
.xdata$x:0000363C ; Segment type: Pure data
.xdata$x:0000363C ; Segment permissions: Read
.xdata$x:0000363C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000363C                 assume cs:_xdata$x
.xdata$x:0000363C                 ;org 363Ch
.xdata$x:0000363C ; COMDAT (pick associative to section at 10AC)
.xdata$x:0000363C __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:0000363C                                         ; DATA XREF: .xdata$x:0000364Co
.xdata$x:0000363D                 db 0FFh
.xdata$x:0000363E                 db 0FFh
.xdata$x:0000363F                 db 0FFh
.xdata$x:00003640                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:00003644 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:00003644                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:00003645                 db    5
.xdata$x:00003646                 db  93h ; ô
.xdata$x:00003647                 db  19h
.xdata$x:00003648                 db    1
.xdata$x:00003649                 db    0
.xdata$x:0000364A                 db    0
.xdata$x:0000364B                 db    0
.xdata$x:0000364C                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:00003650                 db    0
.xdata$x:00003651                 db    0
.xdata$x:00003652                 db    0
.xdata$x:00003653                 db    0
.xdata$x:00003654                 db    0
.xdata$x:00003655                 db    0
.xdata$x:00003656                 db    0
.xdata$x:00003657                 db    0
.xdata$x:00003658                 db    0
.xdata$x:00003659                 db    0
.xdata$x:0000365A                 db    0
.xdata$x:0000365B                 db    0
.xdata$x:0000365C                 db    0
.xdata$x:0000365D                 db    0
.xdata$x:0000365E                 db    0
.xdata$x:0000365F                 db    0
.xdata$x:00003660                 db    0
.xdata$x:00003661                 db    0
.xdata$x:00003662                 db    0
.xdata$x:00003663                 db    0
.xdata$x:00003664                 db    0
.xdata$x:00003665                 db    0
.xdata$x:00003666                 db    0
.xdata$x:00003667                 db    0
.xdata$x:00003667 _xdata$x        ends
.xdata$x:00003667
.xdata$x:00003668 ; ===========================================================================
.xdata$x:00003668
.xdata$x:00003668 ; Segment type: Pure data
.xdata$x:00003668 ; Segment permissions: Read
.xdata$x:00003668 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003668                 assume cs:_xdata$x
.xdata$x:00003668                 ;org 3668h
.xdata$x:00003668 ; COMDAT (pick associative to section at 1594)
.xdata$x:00003668 __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:00003668                                         ; DATA XREF: .xdata$x:00003678o
.xdata$x:00003669                 db 0FFh
.xdata$x:0000366A                 db 0FFh
.xdata$x:0000366B                 db 0FFh
.xdata$x:0000366C                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:00003670 __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00003670                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:00003671                 db    5
.xdata$x:00003672                 db  93h ; ô
.xdata$x:00003673                 db  19h
.xdata$x:00003674                 db    1
.xdata$x:00003675                 db    0
.xdata$x:00003676                 db    0
.xdata$x:00003677                 db    0
.xdata$x:00003678                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:0000367C                 db    0
.xdata$x:0000367D                 db    0
.xdata$x:0000367E                 db    0
.xdata$x:0000367F                 db    0
.xdata$x:00003680                 db    0
.xdata$x:00003681                 db    0
.xdata$x:00003682                 db    0
.xdata$x:00003683                 db    0
.xdata$x:00003684                 db    0
.xdata$x:00003685                 db    0
.xdata$x:00003686                 db    0
.xdata$x:00003687                 db    0
.xdata$x:00003688                 db    0
.xdata$x:00003689                 db    0
.xdata$x:0000368A                 db    0
.xdata$x:0000368B                 db    0
.xdata$x:0000368C                 db    0
.xdata$x:0000368D                 db    0
.xdata$x:0000368E                 db    0
.xdata$x:0000368F                 db    0
.xdata$x:00003690                 db    0
.xdata$x:00003691                 db    0
.xdata$x:00003692                 db    0
.xdata$x:00003693                 db    0
.xdata$x:00003693 _xdata$x        ends
.xdata$x:00003693
.xdata$x:00003694 ; ===========================================================================
.xdata$x:00003694
.xdata$x:00003694 ; Segment type: Pure data
.xdata$x:00003694 ; Segment permissions: Read
.xdata$x:00003694 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003694                 assume cs:_xdata$x
.xdata$x:00003694                 ;org 3694h
.xdata$x:00003694 ; COMDAT (pick associative to section at 1C30)
.xdata$x:00003694 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00003694                                         ; DATA XREF: .xdata$x:0000371Co
.xdata$x:00003695                 db    0
.xdata$x:00003696                 db    0
.xdata$x:00003697                 db    0
.xdata$x:00003698                 db    0
.xdata$x:00003699                 db    0
.xdata$x:0000369A                 db    0
.xdata$x:0000369B                 db    0
.xdata$x:0000369C                 db    0
.xdata$x:0000369D                 db    0
.xdata$x:0000369E                 db    0
.xdata$x:0000369F                 db    0
.xdata$x:000036A0                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:000036A4 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:000036A4                                         ; DATA XREF: .xdata$x:00003708o
.xdata$x:000036A5                 db    0
.xdata$x:000036A6                 db    0
.xdata$x:000036A7                 db    0
.xdata$x:000036A8                 db    0
.xdata$x:000036A9                 db    0
.xdata$x:000036AA                 db    0
.xdata$x:000036AB                 db    0
.xdata$x:000036AC                 db    0
.xdata$x:000036AD                 db    0
.xdata$x:000036AE                 db    0
.xdata$x:000036AF                 db    0
.xdata$x:000036B0                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:000036B4 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:000036B4                                         ; DATA XREF: .xdata$x:000036DCo
.xdata$x:000036B5                 db 0FFh
.xdata$x:000036B6                 db 0FFh
.xdata$x:000036B7                 db 0FFh
.xdata$x:000036B8                 db    0
.xdata$x:000036B9                 db    0
.xdata$x:000036BA                 db    0
.xdata$x:000036BB                 db    0
.xdata$x:000036BC                 db 0FFh
.xdata$x:000036BD                 db 0FFh
.xdata$x:000036BE                 db 0FFh
.xdata$x:000036BF                 db 0FFh
.xdata$x:000036C0                 db    0
.xdata$x:000036C1                 db    0
.xdata$x:000036C2                 db    0
.xdata$x:000036C3                 db    0
.xdata$x:000036C4                 db    1
.xdata$x:000036C5                 db    0
.xdata$x:000036C6                 db    0
.xdata$x:000036C7                 db    0
.xdata$x:000036C8                 db    0
.xdata$x:000036C9                 db    0
.xdata$x:000036CA                 db    0
.xdata$x:000036CB                 db    0
.xdata$x:000036CC                 db    1
.xdata$x:000036CD                 db    0
.xdata$x:000036CE                 db    0
.xdata$x:000036CF                 db    0
.xdata$x:000036D0                 db    0
.xdata$x:000036D1                 db    0
.xdata$x:000036D2                 db    0
.xdata$x:000036D3                 db    0
.xdata$x:000036D4 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:000036D4                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:000036D5                 db    5
.xdata$x:000036D6                 db  93h ; ô
.xdata$x:000036D7                 db  19h
.xdata$x:000036D8                 db    4
.xdata$x:000036D9                 db    0
.xdata$x:000036DA                 db    0
.xdata$x:000036DB                 db    0
.xdata$x:000036DC                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:000036E0                 db    2
.xdata$x:000036E1                 db    0
.xdata$x:000036E2                 db    0
.xdata$x:000036E3                 db    0
.xdata$x:000036E4                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:000036E8                 db    0
.xdata$x:000036E9                 db    0
.xdata$x:000036EA                 db    0
.xdata$x:000036EB                 db    0
.xdata$x:000036EC                 db    0
.xdata$x:000036ED                 db    0
.xdata$x:000036EE                 db    0
.xdata$x:000036EF                 db    0
.xdata$x:000036F0                 db    0
.xdata$x:000036F1                 db    0
.xdata$x:000036F2                 db    0
.xdata$x:000036F3                 db    0
.xdata$x:000036F4                 db    0
.xdata$x:000036F5                 db    0
.xdata$x:000036F6                 db    0
.xdata$x:000036F7                 db    0
.xdata$x:000036F8 __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:000036F8                                         ; DATA XREF: .xdata$x:000036E4o
.xdata$x:000036F9                 db    0
.xdata$x:000036FA                 db    0
.xdata$x:000036FB                 db    0
.xdata$x:000036FC                 db    2
.xdata$x:000036FD                 db    0
.xdata$x:000036FE                 db    0
.xdata$x:000036FF                 db    0
.xdata$x:00003700                 db    3
.xdata$x:00003701                 db    0
.xdata$x:00003702                 db    0
.xdata$x:00003703                 db    0
.xdata$x:00003704                 db    1
.xdata$x:00003705                 db    0
.xdata$x:00003706                 db    0
.xdata$x:00003707                 db    0
.xdata$x:00003708                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:0000370C                 db    0
.xdata$x:0000370D                 db    0
.xdata$x:0000370E                 db    0
.xdata$x:0000370F                 db    0
.xdata$x:00003710                 db    0
.xdata$x:00003711                 db    0
.xdata$x:00003712                 db    0
.xdata$x:00003713                 db    0
.xdata$x:00003714                 db    3
.xdata$x:00003715                 db    0
.xdata$x:00003716                 db    0
.xdata$x:00003717                 db    0
.xdata$x:00003718                 db    1
.xdata$x:00003719                 db    0
.xdata$x:0000371A                 db    0
.xdata$x:0000371B                 db    0
.xdata$x:0000371C                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:0000371C _xdata$x        ends
.xdata$x:0000371C
.xdata$x:00003720 ; ===========================================================================
.xdata$x:00003720
.xdata$x:00003720 ; Segment type: Pure data
.xdata$x:00003720 ; Segment permissions: Read
.xdata$x:00003720 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003720                 assume cs:_xdata$x
.xdata$x:00003720                 ;org 3720h
.xdata$x:00003720 __unwindtable$?run_dlgProc@AboutDlg@@MAGHIIJ@Z db 0FFh
.xdata$x:00003720                                         ; DATA XREF: .xdata$x:00003730o
.xdata$x:00003721                 db 0FFh
.xdata$x:00003722                 db 0FFh
.xdata$x:00003723                 db 0FFh
.xdata$x:00003724                 dd offset __unwindfunclet$?run_dlgProc@AboutDlg@@MAGHIIJ@Z$0
.xdata$x:00003728 __ehfuncinfo$?run_dlgProc@AboutDlg@@MAGHIIJ@Z db  22h ; "
.xdata$x:00003728                                         ; DATA XREF: __ehhandler$?run_dlgProc@AboutDlg@@MAGHIIJ@Z+1Bo
.xdata$x:00003729                 db    5
.xdata$x:0000372A                 db  93h ; ô
.xdata$x:0000372B                 db  19h
.xdata$x:0000372C                 db    1
.xdata$x:0000372D                 db    0
.xdata$x:0000372E                 db    0
.xdata$x:0000372F                 db    0
.xdata$x:00003730                 dd offset __unwindtable$?run_dlgProc@AboutDlg@@MAGHIIJ@Z
.xdata$x:00003734                 db    0
.xdata$x:00003735                 db    0
.xdata$x:00003736                 db    0
.xdata$x:00003737                 db    0
.xdata$x:00003738                 db    0
.xdata$x:00003739                 db    0
.xdata$x:0000373A                 db    0
.xdata$x:0000373B                 db    0
.xdata$x:0000373C                 db    0
.xdata$x:0000373D                 db    0
.xdata$x:0000373E                 db    0
.xdata$x:0000373F                 db    0
.xdata$x:00003740                 db    0
.xdata$x:00003741                 db    0
.xdata$x:00003742                 db    0
.xdata$x:00003743                 db    0
.xdata$x:00003744                 db    0
.xdata$x:00003745                 db    0
.xdata$x:00003746                 db    0
.xdata$x:00003747                 db    0
.xdata$x:00003748                 db    0
.xdata$x:00003749                 db    0
.xdata$x:0000374A                 db    0
.xdata$x:0000374B                 db    0
.xdata$x:0000374B _xdata$x        ends
.xdata$x:0000374B
.xdata$x:0000374C ; ===========================================================================
.xdata$x:0000374C
.xdata$x:0000374C ; Segment type: Pure data
.xdata$x:0000374C ; Segment permissions: Read
.xdata$x:0000374C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000374C                 assume cs:_xdata$x
.xdata$x:0000374C                 ;org 374Ch
.xdata$x:0000374C ; COMDAT (pick associative to section at C44)
.xdata$x:0000374C __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:0000374C                                         ; DATA XREF: .xdata$x:0000375Co
.xdata$x:0000374D                 db 0FFh
.xdata$x:0000374E                 db 0FFh
.xdata$x:0000374F                 db 0FFh
.xdata$x:00003750                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00003754 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00003754                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00003755                 db    5
.xdata$x:00003756                 db  93h ; ô
.xdata$x:00003757                 db  19h
.xdata$x:00003758                 db    1
.xdata$x:00003759                 db    0
.xdata$x:0000375A                 db    0
.xdata$x:0000375B                 db    0
.xdata$x:0000375C                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00003760                 db    0
.xdata$x:00003761                 db    0
.xdata$x:00003762                 db    0
.xdata$x:00003763                 db    0
.xdata$x:00003764                 db    0
.xdata$x:00003765                 db    0
.xdata$x:00003766                 db    0
.xdata$x:00003767                 db    0
.xdata$x:00003768                 db    0
.xdata$x:00003769                 db    0
.xdata$x:0000376A                 db    0
.xdata$x:0000376B                 db    0
.xdata$x:0000376C                 db    0
.xdata$x:0000376D                 db    0
.xdata$x:0000376E                 db    0
.xdata$x:0000376F                 db    0
.xdata$x:00003770                 db    0
.xdata$x:00003771                 db    0
.xdata$x:00003772                 db    0
.xdata$x:00003773                 db    0
.xdata$x:00003774                 db    0
.xdata$x:00003775                 db    0
.xdata$x:00003776                 db    0
.xdata$x:00003777                 db    0
.xdata$x:00003777 _xdata$x        ends
.xdata$x:00003777
.xdata$x:00003778 ; ===========================================================================
.xdata$x:00003778
.xdata$x:00003778 ; Segment type: Pure data
.xdata$x:00003778 ; Segment permissions: Read
.xdata$x:00003778 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003778                 assume cs:_xdata$x
.xdata$x:00003778                 ;org 3778h
.xdata$x:00003778 ; COMDAT (pick associative to section at A70)
.xdata$x:00003778 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00003778                                         ; DATA XREF: .xdata$x:00003788o
.xdata$x:00003779                 db 0FFh
.xdata$x:0000377A                 db 0FFh
.xdata$x:0000377B                 db 0FFh
.xdata$x:0000377C                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00003780 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00003780                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00003781                 db    5
.xdata$x:00003782                 db  93h ; ô
.xdata$x:00003783                 db  19h
.xdata$x:00003784                 db    1
.xdata$x:00003785                 db    0
.xdata$x:00003786                 db    0
.xdata$x:00003787                 db    0
.xdata$x:00003788                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:0000378C                 db    0
.xdata$x:0000378D                 db    0
.xdata$x:0000378E                 db    0
.xdata$x:0000378F                 db    0
.xdata$x:00003790                 db    0
.xdata$x:00003791                 db    0
.xdata$x:00003792                 db    0
.xdata$x:00003793                 db    0
.xdata$x:00003794                 db    0
.xdata$x:00003795                 db    0
.xdata$x:00003796                 db    0
.xdata$x:00003797                 db    0
.xdata$x:00003798                 db    0
.xdata$x:00003799                 db    0
.xdata$x:0000379A                 db    0
.xdata$x:0000379B                 db    0
.xdata$x:0000379C                 db    0
.xdata$x:0000379D                 db    0
.xdata$x:0000379E                 db    0
.xdata$x:0000379F                 db    0
.xdata$x:000037A0                 db    0
.xdata$x:000037A1                 db    0
.xdata$x:000037A2                 db    0
.xdata$x:000037A3                 db    0
.xdata$x:000037A3 _xdata$x        ends
.xdata$x:000037A3
.xdata$x:000037A4 ; ===========================================================================
.xdata$x:000037A4
.xdata$x:000037A4 ; Segment type: Pure data
.xdata$x:000037A4 ; Segment permissions: Read
.xdata$x:000037A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000037A4                 assume cs:_xdata$x
.xdata$x:000037A4                 ;org 37A4h
.xdata$x:000037A4 ; COMDAT (pick associative to section at B70)
.xdata$x:000037A4 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:000037A4                                         ; DATA XREF: .xdata$x:000037B4o
.xdata$x:000037A5                 db 0FFh
.xdata$x:000037A6                 db 0FFh
.xdata$x:000037A7                 db 0FFh
.xdata$x:000037A8                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:000037AC __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:000037AC                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:000037AD                 db    5
.xdata$x:000037AE                 db  93h ; ô
.xdata$x:000037AF                 db  19h
.xdata$x:000037B0                 db    1
.xdata$x:000037B1                 db    0
.xdata$x:000037B2                 db    0
.xdata$x:000037B3                 db    0
.xdata$x:000037B4                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:000037B8                 db    0
.xdata$x:000037B9                 db    0
.xdata$x:000037BA                 db    0
.xdata$x:000037BB                 db    0
.xdata$x:000037BC                 db    0
.xdata$x:000037BD                 db    0
.xdata$x:000037BE                 db    0
.xdata$x:000037BF                 db    0
.xdata$x:000037C0                 db    0
.xdata$x:000037C1                 db    0
.xdata$x:000037C2                 db    0
.xdata$x:000037C3                 db    0
.xdata$x:000037C4                 db    0
.xdata$x:000037C5                 db    0
.xdata$x:000037C6                 db    0
.xdata$x:000037C7                 db    0
.xdata$x:000037C8                 db    0
.xdata$x:000037C9                 db    0
.xdata$x:000037CA                 db    0
.xdata$x:000037CB                 db    0
.xdata$x:000037CC                 db    0
.xdata$x:000037CD                 db    0
.xdata$x:000037CE                 db    0
.xdata$x:000037CF                 db    0
.xdata$x:000037CF _xdata$x        ends
.xdata$x:000037CF
.bss:000037D0 ; ===========================================================================
.bss:000037D0
.bss:000037D0 ; Segment type: Uninitialized
.bss:000037D0 ; Segment permissions: Read/Write
.bss:000037D0 _bss            segment byte public 'BSS' use32
.bss:000037D0                 assume cs:_bss
.bss:000037D0                 ;org 37D0h
.bss:000037D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000037D0 _allocator_arg  db    ? ;
.bss:000037D1 _piecewise_construct db    ? ;
.bss:000037D2                 align 4
.bss:000037D2 _bss            ends
.bss:000037D2
.rdata:000037D4 ; ===========================================================================
.rdata:000037D4
.rdata:000037D4 ; Segment type: Pure data
.rdata:000037D4 ; Segment permissions: Read
.rdata:000037D4 _rdata          segment dword public 'DATA' use32
.rdata:000037D4                 assume cs:_rdata
.rdata:000037D4                 ;org 37D4h
.rdata:000037D4 ; COMDAT (pick largest)
.rdata:000037D4                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:000037D8                 public ??_7error_category@std@@6B@
.rdata:000037D8 ; const std::error_category::`vftable'
.rdata:000037D8 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:000037D8                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:000037D8                                         ; std::error_category::~error_category(void)+Ao
.rdata:000037D8                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:000037DC                 dd offset __purecall
.rdata:000037E0                 dd offset __purecall
.rdata:000037E4                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:000037E8                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000037EC                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000037EC _rdata          ends
.rdata:000037EC
.rdata:000037F0 ; ===========================================================================
.rdata:000037F0
.rdata:000037F0 ; Segment type: Pure data
.rdata:000037F0 ; Segment permissions: Read
.rdata:000037F0 _rdata          segment dword public 'DATA' use32
.rdata:000037F0                 assume cs:_rdata
.rdata:000037F0                 ;org 37F0h
.rdata:000037F0 ; COMDAT (pick largest)
.rdata:000037F0                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:000037F4                 public ??_7_Generic_error_category@std@@6B@
.rdata:000037F4 ; const std::_Generic_error_category::`vftable'
.rdata:000037F4 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:000037F4                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:000037F4                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:000037F8                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:000037FC                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00003800                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003804                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003808                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003808 _rdata          ends
.rdata:00003808
.rdata:0000380C ; ===========================================================================
.rdata:0000380C
.rdata:0000380C ; Segment type: Pure data
.rdata:0000380C ; Segment permissions: Read
.rdata:0000380C _rdata          segment dword public 'DATA' use32
.rdata:0000380C                 assume cs:_rdata
.rdata:0000380C                 ;org 380Ch
.rdata:0000380C ; COMDAT (pick any)
.rdata:0000380C                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:0000380C ; `string'
.rdata:0000380C ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:0000380C                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:0000380C _rdata          ends
.rdata:0000380C
.rdata:00003814 ; ===========================================================================
.rdata:00003814
.rdata:00003814 ; Segment type: Pure data
.rdata:00003814 ; Segment permissions: Read
.rdata:00003814 _rdata          segment dword public 'DATA' use32
.rdata:00003814                 assume cs:_rdata
.rdata:00003814                 ;org 3814h
.rdata:00003814 ; COMDAT (pick any)
.rdata:00003814                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00003814 ; `string'
.rdata:00003814 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00003814                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_2F14o
.rdata:00003814                                         ; std::_System_error_category::message(int):loc_3090o
.rdata:00003822                 align 4
.rdata:00003822 _rdata          ends
.rdata:00003822
.rdata:00003824 ; ===========================================================================
.rdata:00003824
.rdata:00003824 ; Segment type: Pure data
.rdata:00003824 ; Segment permissions: Read
.rdata:00003824 _rdata          segment dword public 'DATA' use32
.rdata:00003824                 assume cs:_rdata
.rdata:00003824                 ;org 3824h
.rdata:00003824 ; COMDAT (pick largest)
.rdata:00003824                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00003828                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00003828 ; const std::_Iostream_error_category::`vftable'
.rdata:00003828 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00003828                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00003828                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:0000382C                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00003830                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00003834                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003838                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000383C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000383C _rdata          ends
.rdata:0000383C
.rdata:00003840 ; ===========================================================================
.rdata:00003840
.rdata:00003840 ; Segment type: Pure data
.rdata:00003840 ; Segment permissions: Read
.rdata:00003840 _rdata          segment dword public 'DATA' use32
.rdata:00003840                 assume cs:_rdata
.rdata:00003840                 ;org 3840h
.rdata:00003840 ; COMDAT (pick any)
.rdata:00003840                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00003840 ; `string'
.rdata:00003840 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00003840                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00003849                 align 4
.rdata:00003849 _rdata          ends
.rdata:00003849
.rdata:0000384C ; ===========================================================================
.rdata:0000384C
.rdata:0000384C ; Segment type: Pure data
.rdata:0000384C ; Segment permissions: Read
.rdata:0000384C _rdata          segment dword public 'DATA' use32
.rdata:0000384C                 assume cs:_rdata
.rdata:0000384C                 ;org 384Ch
.rdata:0000384C ; COMDAT (pick any)
.rdata:0000384C                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:0000384C ; char `string'[]
.rdata:0000384C ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:0000384C                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00003862                 align 4
.rdata:00003862 _rdata          ends
.rdata:00003862
.rdata:00003864 ; ===========================================================================
.rdata:00003864
.rdata:00003864 ; Segment type: Pure data
.rdata:00003864 ; Segment permissions: Read
.rdata:00003864 _rdata          segment dword public 'DATA' use32
.rdata:00003864                 assume cs:_rdata
.rdata:00003864                 ;org 3864h
.rdata:00003864 ; COMDAT (pick largest)
.rdata:00003864                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00003868                 public ??_7_System_error_category@std@@6B@
.rdata:00003868 ; const std::_System_error_category::`vftable'
.rdata:00003868 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00003868                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00003868                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:0000386C                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00003870                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00003874                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00003878                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000387C                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000387C _rdata          ends
.rdata:0000387C
.rdata:00003880 ; ===========================================================================
.rdata:00003880
.rdata:00003880 ; Segment type: Pure data
.rdata:00003880 ; Segment permissions: Read
.rdata:00003880 _rdata          segment dword public 'DATA' use32
.rdata:00003880                 assume cs:_rdata
.rdata:00003880                 ;org 3880h
.rdata:00003880 ; COMDAT (pick any)
.rdata:00003880                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00003880 ; `string'
.rdata:00003880 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00003880                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00003887                 align 4
.rdata:00003887 _rdata          ends
.rdata:00003887
.bss:00003888 ; ===========================================================================
.bss:00003888
.bss:00003888 ; Segment type: Uninitialized
.bss:00003888 ; Segment permissions: Read/Write
.bss:00003888 _bss            segment dword public 'BSS' use32
.bss:00003888                 assume cs:_bss
.bss:00003888                 ;org 3888h
.bss:00003888 ; COMDAT (pick any)
.bss:00003888                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003888                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00003888 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00003888 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00003888                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00003888                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00003889                 db    ? ;
.bss:0000388A                 db    ? ;
.bss:0000388B                 db    ? ;
.bss:0000388B _bss            ends
.bss:0000388B
.bss:0000388C ; ===========================================================================
.bss:0000388C
.bss:0000388C ; Segment type: Uninitialized
.bss:0000388C ; Segment permissions: Read/Write
.bss:0000388C _bss            segment dword public 'BSS' use32
.bss:0000388C                 assume cs:_bss
.bss:0000388C                 ;org 388Ch
.bss:0000388C ; COMDAT (pick any)
.bss:0000388C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000388C                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:0000388C ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:0000388C ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:0000388C                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000388C                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000388D                 db    ? ;
.bss:0000388E                 db    ? ;
.bss:0000388F                 db    ? ;
.bss:0000388F _bss            ends
.bss:0000388F
.bss:00003890 ; ===========================================================================
.bss:00003890
.bss:00003890 ; Segment type: Uninitialized
.bss:00003890 ; Segment permissions: Read/Write
.bss:00003890 _bss            segment dword public 'BSS' use32
.bss:00003890                 assume cs:_bss
.bss:00003890                 ;org 3890h
.bss:00003890 ; COMDAT (pick any)
.bss:00003890                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003890                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00003890 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00003890 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00003890                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00003890                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00003891                 db    ? ;
.bss:00003892                 db    ? ;
.bss:00003893                 db    ? ;
.bss:00003893 _bss            ends
.bss:00003893
.rdata:00003894 ; ===========================================================================
.rdata:00003894
.rdata:00003894 ; Segment type: Pure data
.rdata:00003894 ; Segment permissions: Read
.rdata:00003894 _rdata          segment dword public 'DATA' use32
.rdata:00003894                 assume cs:_rdata
.rdata:00003894                 ;org 3894h
.rdata:00003894 ; COMDAT (pick any)
.rdata:00003894                 public ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
.rdata:00003894 ; public: static unsigned int const std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::npos
.rdata:00003894 ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB dd 0FFFFFFFFh
.rdata:00003894                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+3Dr
.rdata:00003894                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+5Dr
.rdata:00003894 _rdata          ends
.rdata:00003894
.bss:00003898 ; ===========================================================================
.bss:00003898
.bss:00003898 ; Segment type: Uninitialized
.bss:00003898 ; Segment permissions: Read/Write
.bss:00003898 _bss            segment dword public 'BSS' use32
.bss:00003898                 assume cs:_bss
.bss:00003898                 ;org 3898h
.bss:00003898 ; COMDAT (pick any)
.bss:00003898                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003898                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00003898 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00003898 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00003898                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00003899                 db    ? ;
.bss:0000389A                 db    ? ;
.bss:0000389B                 db    ? ;
.bss:0000389B _bss            ends
.bss:0000389B
.bss:0000389C ; ===========================================================================
.bss:0000389C
.bss:0000389C ; Segment type: Uninitialized
.bss:0000389C ; Segment permissions: Read/Write
.bss:0000389C _bss            segment dword public 'BSS' use32
.bss:0000389C                 assume cs:_bss
.bss:0000389C                 ;org 389Ch
.bss:0000389C ; COMDAT (pick any)
.bss:0000389C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000389C                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000389C ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:0000389C ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000389C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:0000389D                 db    ? ;
.bss:0000389E                 db    ? ;
.bss:0000389F                 db    ? ;
.bss:0000389F _bss            ends
.bss:0000389F
.rdata:000038A0 ; ===========================================================================
.rdata:000038A0
.rdata:000038A0 ; Segment type: Pure data
.rdata:000038A0 ; Segment permissions: Read
.rdata:000038A0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000038A0 _rdata          segment para public 'DATA' use32
.rdata:000038A0                 assume cs:_rdata
.rdata:000038A0                 ;org 38A0h
.rdata:000038A0 ; COMDAT (pick any)
.rdata:000038A0                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000038A0 ; wchar_t `string'
.rdata:000038A0 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000038A0                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+Co
.rdata:000038A0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+14o ...
.rdata:000038A0                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:000038A0                 unicode 0, <clude\xstring>,0
.rdata:0000392E                 align 10h
.rdata:0000392E _rdata          ends
.rdata:0000392E
.bss:00003930 ; ===========================================================================
.bss:00003930
.bss:00003930 ; Segment type: Uninitialized
.bss:00003930 ; Segment permissions: Read/Write
.bss:00003930 _bss            segment dword public 'BSS' use32
.bss:00003930                 assume cs:_bss
.bss:00003930                 ;org 3930h
.bss:00003930 ; COMDAT (pick any)
.bss:00003930                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003930                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00003930 ; std::locale::id std::numpunct<char>::id
.bss:00003930 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00003930                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00003931                 db    ? ;
.bss:00003932                 db    ? ;
.bss:00003933                 db    ? ;
.bss:00003933 _bss            ends
.bss:00003933
.bss:00003934 ; ===========================================================================
.bss:00003934
.bss:00003934 ; Segment type: Uninitialized
.bss:00003934 ; Segment permissions: Read/Write
.bss:00003934 _bss            segment dword public 'BSS' use32
.bss:00003934                 assume cs:_bss
.bss:00003934                 ;org 3934h
.bss:00003934 ; COMDAT (pick any)
.bss:00003934                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003934                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00003934 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00003934 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00003934                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00003935                 db    ? ;
.bss:00003936                 db    ? ;
.bss:00003937                 db    ? ;
.bss:00003937 _bss            ends
.bss:00003937
.rdata:00003938 ; ===========================================================================
.rdata:00003938
.rdata:00003938 ; Segment type: Pure data
.rdata:00003938 ; Segment permissions: Read
.rdata:00003938 _rdata          segment dword public 'DATA' use32
.rdata:00003938                 assume cs:_rdata
.rdata:00003938                 ;org 3938h
.rdata:00003938 ; COMDAT (pick any)
.rdata:00003938                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00003938 ; char `string'[]
.rdata:00003938 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00003938                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00003938                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:00003938 _rdata          ends
.rdata:00003938
.rdata:00003948 ; ===========================================================================
.rdata:00003948
.rdata:00003948 ; Segment type: Pure data
.rdata:00003948 ; Segment permissions: Read
.rdata:00003948 _rdata          segment dword public 'DATA' use32
.rdata:00003948                 assume cs:_rdata
.rdata:00003948                 ;org 3948h
.rdata:00003948 ; COMDAT (pick any)
.rdata:00003948                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00003948 ; char `string'[]
.rdata:00003948 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00003948                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00003948                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:00003948 _rdata          ends
.rdata:00003948
.rdata:00003960 ; ===========================================================================
.rdata:00003960
.rdata:00003960 ; Segment type: Pure data
.rdata:00003960 ; Segment permissions: Read
.rdata:00003960 _rdata          segment dword public 'DATA' use32
.rdata:00003960                 assume cs:_rdata
.rdata:00003960                 ;org 3960h
.rdata:00003960 ; COMDAT (pick any)
.rdata:00003960                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00003960 ; wchar_t `string'
.rdata:00003960 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00003960                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00003960                                         ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+11o
.rdata:00003960                 unicode 0, <invalid null pointer>,0
.rdata:0000398A                 align 4
.rdata:0000398A _rdata          ends
.rdata:0000398A
.rdata$r:0000398C ; ===========================================================================
.rdata$r:0000398C
.rdata$r:0000398C ; Segment type: Pure data
.rdata$r:0000398C ; Segment permissions: Read
.rdata$r:0000398C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000398C                 assume cs:_rdata$r
.rdata$r:0000398C                 ;org 398Ch
.rdata$r:0000398C ; COMDAT (pick any)
.rdata$r:0000398C                 public ??_R4error_category@std@@6B@
.rdata$r:0000398C ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:0000398C ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:000037D4o
.rdata$r:0000398D                 db    0
.rdata$r:0000398E                 db    0
.rdata$r:0000398F                 db    0
.rdata$r:00003990                 db    0
.rdata$r:00003991                 db    0
.rdata$r:00003992                 db    0
.rdata$r:00003993                 db    0
.rdata$r:00003994                 db    0
.rdata$r:00003995                 db    0
.rdata$r:00003996                 db    0
.rdata$r:00003997                 db    0
.rdata$r:00003998                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000399C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000399C _rdata$r        ends
.rdata$r:0000399C
.data$r:000039A0 ; ===========================================================================
.data$r:000039A0
.data$r:000039A0 ; Segment type: Pure data
.data$r:000039A0 ; Segment permissions: Read/Write
.data$r:000039A0 _data$r         segment dword public 'DATA' use32
.data$r:000039A0                 assume cs:_data$r
.data$r:000039A0                 ;org 39A0h
.data$r:000039A0 ; COMDAT (pick any)
.data$r:000039A0                 public ??_R0?AVerror_category@std@@@8
.data$r:000039A0 ; class std::error_category `RTTI Type Descriptor'
.data$r:000039A0 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000039A0                                         ; DATA XREF: .rdata$r:00003998o
.data$r:000039A0                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000039A0                                         ; const type_info::`vftable'
.data$r:000039A4                 align 8
.data$r:000039A8 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:000039C1                 align 4
.data$r:000039C1 _data$r         ends
.data$r:000039C1
.rdata$r:000039C4 ; ===========================================================================
.rdata$r:000039C4
.rdata$r:000039C4 ; Segment type: Pure data
.rdata$r:000039C4 ; Segment permissions: Read
.rdata$r:000039C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000039C4                 assume cs:_rdata$r
.rdata$r:000039C4                 ;org 39C4h
.rdata$r:000039C4 ; COMDAT (pick any)
.rdata$r:000039C4                 public ??_R3error_category@std@@8
.rdata$r:000039C4 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000039C4 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:0000399Co
.rdata$r:000039C4                                         ; .rdata$r:000039F4o
.rdata$r:000039C5                 db    0
.rdata$r:000039C6                 db    0
.rdata$r:000039C7                 db    0
.rdata$r:000039C8                 db    0
.rdata$r:000039C9                 db    0
.rdata$r:000039CA                 db    0
.rdata$r:000039CB                 db    0
.rdata$r:000039CC                 db    1
.rdata$r:000039CD                 db    0
.rdata$r:000039CE                 db    0
.rdata$r:000039CF                 db    0
.rdata$r:000039D0                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000039D0 _rdata$r        ends
.rdata$r:000039D0
.rdata$r:000039D4 ; ===========================================================================
.rdata$r:000039D4
.rdata$r:000039D4 ; Segment type: Pure data
.rdata$r:000039D4 ; Segment permissions: Read
.rdata$r:000039D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000039D4                 assume cs:_rdata$r
.rdata$r:000039D4                 ;org 39D4h
.rdata$r:000039D4 ; COMDAT (pick any)
.rdata$r:000039D4                 public ??_R2error_category@std@@8
.rdata$r:000039D4 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000039D4 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000039D4                                         ; DATA XREF: .rdata$r:000039D0o
.rdata$r:000039D4                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000039D8                 db    0
.rdata$r:000039D9                 align 4
.rdata$r:000039D9 _rdata$r        ends
.rdata$r:000039D9
.rdata$r:000039DC ; ===========================================================================
.rdata$r:000039DC
.rdata$r:000039DC ; Segment type: Pure data
.rdata$r:000039DC ; Segment permissions: Read
.rdata$r:000039DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000039DC                 assume cs:_rdata$r
.rdata$r:000039DC                 ;org 39DCh
.rdata$r:000039DC ; COMDAT (pick any)
.rdata$r:000039DC                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000039DC ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000039DC ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:000039DC                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:000039DC                                         ; .rdata$r:00003A4Co ...
.rdata$r:000039DC                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:000039E0                 db    0
.rdata$r:000039E1                 db    0
.rdata$r:000039E2                 db    0
.rdata$r:000039E3                 db    0
.rdata$r:000039E4                 db    0
.rdata$r:000039E5                 db    0
.rdata$r:000039E6                 db    0
.rdata$r:000039E7                 db    0
.rdata$r:000039E8                 db 0FFh
.rdata$r:000039E9                 db 0FFh
.rdata$r:000039EA                 db 0FFh
.rdata$r:000039EB                 db 0FFh
.rdata$r:000039EC                 db    0
.rdata$r:000039ED                 db    0
.rdata$r:000039EE                 db    0
.rdata$r:000039EF                 db    0
.rdata$r:000039F0                 db  40h ; @
.rdata$r:000039F1                 db    0
.rdata$r:000039F2                 db    0
.rdata$r:000039F3                 db    0
.rdata$r:000039F4                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000039F4 _rdata$r        ends
.rdata$r:000039F4
.rdata$r:000039F8 ; ===========================================================================
.rdata$r:000039F8
.rdata$r:000039F8 ; Segment type: Pure data
.rdata$r:000039F8 ; Segment permissions: Read
.rdata$r:000039F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000039F8                 assume cs:_rdata$r
.rdata$r:000039F8                 ;org 39F8h
.rdata$r:000039F8 ; COMDAT (pick any)
.rdata$r:000039F8                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:000039F8 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:000039F8 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:000039F8                                         ; DATA XREF: .rdata:000037F0o
.rdata$r:000039F9                 db    0
.rdata$r:000039FA                 db    0
.rdata$r:000039FB                 db    0
.rdata$r:000039FC                 db    0
.rdata$r:000039FD                 db    0
.rdata$r:000039FE                 db    0
.rdata$r:000039FF                 db    0
.rdata$r:00003A00                 db    0
.rdata$r:00003A01                 db    0
.rdata$r:00003A02                 db    0
.rdata$r:00003A03                 db    0
.rdata$r:00003A04                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00003A08                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003A08 _rdata$r        ends
.rdata$r:00003A08
.data$r:00003A0C ; ===========================================================================
.data$r:00003A0C
.data$r:00003A0C ; Segment type: Pure data
.data$r:00003A0C ; Segment permissions: Read/Write
.data$r:00003A0C _data$r         segment dword public 'DATA' use32
.data$r:00003A0C                 assume cs:_data$r
.data$r:00003A0C                 ;org 3A0Ch
.data$r:00003A0C ; COMDAT (pick any)
.data$r:00003A0C                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00003A0C ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00003A0C ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003A0C                                         ; DATA XREF: .rdata$r:00003A04o
.data$r:00003A0C                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003A0C                                         ; const type_info::`vftable'
.data$r:00003A10                 db    0
.data$r:00003A11                 db    0
.data$r:00003A12                 db    0
.data$r:00003A13                 db    0
.data$r:00003A14                 db  2Eh ; .
.data$r:00003A15                 db  3Fh ; ?
.data$r:00003A16                 db  41h ; A
.data$r:00003A17                 db  56h ; V
.data$r:00003A18                 db  5Fh ; _
.data$r:00003A19                 db  47h ; G
.data$r:00003A1A                 db  65h ; e
.data$r:00003A1B                 db  6Eh ; n
.data$r:00003A1C                 db  65h ; e
.data$r:00003A1D                 db  72h ; r
.data$r:00003A1E                 db  69h ; i
.data$r:00003A1F                 db  63h ; c
.data$r:00003A20                 db  5Fh ; _
.data$r:00003A21                 db  65h ; e
.data$r:00003A22                 db  72h ; r
.data$r:00003A23                 db  72h ; r
.data$r:00003A24                 db  6Fh ; o
.data$r:00003A25                 db  72h ; r
.data$r:00003A26                 db  5Fh ; _
.data$r:00003A27                 db  63h ; c
.data$r:00003A28                 db  61h ; a
.data$r:00003A29                 db  74h ; t
.data$r:00003A2A                 db  65h ; e
.data$r:00003A2B                 db  67h ; g
.data$r:00003A2C                 db  6Fh ; o
.data$r:00003A2D                 db  72h ; r
.data$r:00003A2E                 db  79h ; y
.data$r:00003A2F                 db  40h ; @
.data$r:00003A30                 db  73h ; s
.data$r:00003A31                 db  74h ; t
.data$r:00003A32                 db  64h ; d
.data$r:00003A33                 db  40h ; @
.data$r:00003A34                 db  40h ; @
.data$r:00003A35                 db    0
.data$r:00003A36                 align 4
.data$r:00003A36 _data$r         ends
.data$r:00003A36
.rdata$r:00003A38 ; ===========================================================================
.rdata$r:00003A38
.rdata$r:00003A38 ; Segment type: Pure data
.rdata$r:00003A38 ; Segment permissions: Read
.rdata$r:00003A38 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003A38                 assume cs:_rdata$r
.rdata$r:00003A38                 ;org 3A38h
.rdata$r:00003A38 ; COMDAT (pick any)
.rdata$r:00003A38                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00003A38 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003A38 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00003A38                                         ; DATA XREF: .rdata$r:00003A08o
.rdata$r:00003A38                                         ; .rdata$r:00003A6Co
.rdata$r:00003A39                 db    0
.rdata$r:00003A3A                 db    0
.rdata$r:00003A3B                 db    0
.rdata$r:00003A3C                 db    0
.rdata$r:00003A3D                 db    0
.rdata$r:00003A3E                 db    0
.rdata$r:00003A3F                 db    0
.rdata$r:00003A40                 db    2
.rdata$r:00003A41                 db    0
.rdata$r:00003A42                 db    0
.rdata$r:00003A43                 db    0
.rdata$r:00003A44                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00003A44 _rdata$r        ends
.rdata$r:00003A44
.rdata$r:00003A48 ; ===========================================================================
.rdata$r:00003A48
.rdata$r:00003A48 ; Segment type: Pure data
.rdata$r:00003A48 ; Segment permissions: Read
.rdata$r:00003A48 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003A48                 assume cs:_rdata$r
.rdata$r:00003A48                 ;org 3A48h
.rdata$r:00003A48 ; COMDAT (pick any)
.rdata$r:00003A48                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00003A48 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00003A48 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00003A48                                         ; DATA XREF: .rdata$r:00003A44o
.rdata$r:00003A48                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003A4C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003A50                 db    0
.rdata$r:00003A51                 align 4
.rdata$r:00003A51 _rdata$r        ends
.rdata$r:00003A51
.rdata$r:00003A54 ; ===========================================================================
.rdata$r:00003A54
.rdata$r:00003A54 ; Segment type: Pure data
.rdata$r:00003A54 ; Segment permissions: Read
.rdata$r:00003A54 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003A54                 assume cs:_rdata$r
.rdata$r:00003A54                 ;org 3A54h
.rdata$r:00003A54 ; COMDAT (pick any)
.rdata$r:00003A54                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00003A54 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003A54 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00003A54                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00003A54                                         ; .rdata$r:00003AC4o ...
.rdata$r:00003A54                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00003A58                 db    1
.rdata$r:00003A59                 db    0
.rdata$r:00003A5A                 db    0
.rdata$r:00003A5B                 db    0
.rdata$r:00003A5C                 db    0
.rdata$r:00003A5D                 db    0
.rdata$r:00003A5E                 db    0
.rdata$r:00003A5F                 db    0
.rdata$r:00003A60                 db 0FFh
.rdata$r:00003A61                 db 0FFh
.rdata$r:00003A62                 db 0FFh
.rdata$r:00003A63                 db 0FFh
.rdata$r:00003A64                 db    0
.rdata$r:00003A65                 db    0
.rdata$r:00003A66                 db    0
.rdata$r:00003A67                 db    0
.rdata$r:00003A68                 db  40h ; @
.rdata$r:00003A69                 db    0
.rdata$r:00003A6A                 db    0
.rdata$r:00003A6B                 db    0
.rdata$r:00003A6C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003A6C _rdata$r        ends
.rdata$r:00003A6C
.rdata$r:00003A70 ; ===========================================================================
.rdata$r:00003A70
.rdata$r:00003A70 ; Segment type: Pure data
.rdata$r:00003A70 ; Segment permissions: Read
.rdata$r:00003A70 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003A70                 assume cs:_rdata$r
.rdata$r:00003A70                 ;org 3A70h
.rdata$r:00003A70 ; COMDAT (pick any)
.rdata$r:00003A70                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00003A70 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00003A70 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00003A70                                         ; DATA XREF: .rdata:00003824o
.rdata$r:00003A71                 db    0
.rdata$r:00003A72                 db    0
.rdata$r:00003A73                 db    0
.rdata$r:00003A74                 db    0
.rdata$r:00003A75                 db    0
.rdata$r:00003A76                 db    0
.rdata$r:00003A77                 db    0
.rdata$r:00003A78                 db    0
.rdata$r:00003A79                 db    0
.rdata$r:00003A7A                 db    0
.rdata$r:00003A7B                 db    0
.rdata$r:00003A7C                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00003A80                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003A80 _rdata$r        ends
.rdata$r:00003A80
.data$r:00003A84 ; ===========================================================================
.data$r:00003A84
.data$r:00003A84 ; Segment type: Pure data
.data$r:00003A84 ; Segment permissions: Read/Write
.data$r:00003A84 _data$r         segment dword public 'DATA' use32
.data$r:00003A84                 assume cs:_data$r
.data$r:00003A84                 ;org 3A84h
.data$r:00003A84 ; COMDAT (pick any)
.data$r:00003A84                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00003A84 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00003A84 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003A84                                         ; DATA XREF: .rdata$r:00003A7Co
.data$r:00003A84                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003A84                                         ; const type_info::`vftable'
.data$r:00003A88                 db    0
.data$r:00003A89                 db    0
.data$r:00003A8A                 db    0
.data$r:00003A8B                 db    0
.data$r:00003A8C                 db  2Eh ; .
.data$r:00003A8D                 db  3Fh ; ?
.data$r:00003A8E                 db  41h ; A
.data$r:00003A8F                 db  56h ; V
.data$r:00003A90                 db  5Fh ; _
.data$r:00003A91                 db  49h ; I
.data$r:00003A92                 db  6Fh ; o
.data$r:00003A93                 db  73h ; s
.data$r:00003A94                 db  74h ; t
.data$r:00003A95                 db  72h ; r
.data$r:00003A96                 db  65h ; e
.data$r:00003A97                 db  61h ; a
.data$r:00003A98                 db  6Dh ; m
.data$r:00003A99                 db  5Fh ; _
.data$r:00003A9A                 db  65h ; e
.data$r:00003A9B                 db  72h ; r
.data$r:00003A9C                 db  72h ; r
.data$r:00003A9D                 db  6Fh ; o
.data$r:00003A9E                 db  72h ; r
.data$r:00003A9F                 db  5Fh ; _
.data$r:00003AA0                 db  63h ; c
.data$r:00003AA1                 db  61h ; a
.data$r:00003AA2                 db  74h ; t
.data$r:00003AA3                 db  65h ; e
.data$r:00003AA4                 db  67h ; g
.data$r:00003AA5                 db  6Fh ; o
.data$r:00003AA6                 db  72h ; r
.data$r:00003AA7                 db  79h ; y
.data$r:00003AA8                 db  40h ; @
.data$r:00003AA9                 db  73h ; s
.data$r:00003AAA                 db  74h ; t
.data$r:00003AAB                 db  64h ; d
.data$r:00003AAC                 db  40h ; @
.data$r:00003AAD                 db  40h ; @
.data$r:00003AAE                 db    0
.data$r:00003AAF                 align 10h
.data$r:00003AAF _data$r         ends
.data$r:00003AAF
.rdata$r:00003AB0 ; ===========================================================================
.rdata$r:00003AB0
.rdata$r:00003AB0 ; Segment type: Pure data
.rdata$r:00003AB0 ; Segment permissions: Read
.rdata$r:00003AB0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003AB0                 assume cs:_rdata$r
.rdata$r:00003AB0                 ;org 3AB0h
.rdata$r:00003AB0 ; COMDAT (pick any)
.rdata$r:00003AB0                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00003AB0 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003AB0 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00003AB0                                         ; DATA XREF: .rdata$r:00003A80o
.rdata$r:00003AB0                                         ; .rdata$r:00003AE8o
.rdata$r:00003AB1                 db    0
.rdata$r:00003AB2                 db    0
.rdata$r:00003AB3                 db    0
.rdata$r:00003AB4                 db    0
.rdata$r:00003AB5                 db    0
.rdata$r:00003AB6                 db    0
.rdata$r:00003AB7                 db    0
.rdata$r:00003AB8                 db    3
.rdata$r:00003AB9                 db    0
.rdata$r:00003ABA                 db    0
.rdata$r:00003ABB                 db    0
.rdata$r:00003ABC                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00003ABC _rdata$r        ends
.rdata$r:00003ABC
.rdata$r:00003AC0 ; ===========================================================================
.rdata$r:00003AC0
.rdata$r:00003AC0 ; Segment type: Pure data
.rdata$r:00003AC0 ; Segment permissions: Read
.rdata$r:00003AC0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003AC0                 assume cs:_rdata$r
.rdata$r:00003AC0                 ;org 3AC0h
.rdata$r:00003AC0 ; COMDAT (pick any)
.rdata$r:00003AC0                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00003AC0 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00003AC0 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00003AC0                                         ; DATA XREF: .rdata$r:00003ABCo
.rdata$r:00003AC0                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003AC4                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003AC8                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003ACC                 db    0
.rdata$r:00003ACD                 align 10h
.rdata$r:00003ACD _rdata$r        ends
.rdata$r:00003ACD
.rdata$r:00003AD0 ; ===========================================================================
.rdata$r:00003AD0
.rdata$r:00003AD0 ; Segment type: Pure data
.rdata$r:00003AD0 ; Segment permissions: Read
.rdata$r:00003AD0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003AD0                 assume cs:_rdata$r
.rdata$r:00003AD0                 ;org 3AD0h
.rdata$r:00003AD0 ; COMDAT (pick any)
.rdata$r:00003AD0                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00003AD0 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003AD0 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00003AD0                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00003AD0                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00003AD4                 db    2
.rdata$r:00003AD5                 db    0
.rdata$r:00003AD6                 db    0
.rdata$r:00003AD7                 db    0
.rdata$r:00003AD8                 db    0
.rdata$r:00003AD9                 db    0
.rdata$r:00003ADA                 db    0
.rdata$r:00003ADB                 db    0
.rdata$r:00003ADC                 db 0FFh
.rdata$r:00003ADD                 db 0FFh
.rdata$r:00003ADE                 db 0FFh
.rdata$r:00003ADF                 db 0FFh
.rdata$r:00003AE0                 db    0
.rdata$r:00003AE1                 db    0
.rdata$r:00003AE2                 db    0
.rdata$r:00003AE3                 db    0
.rdata$r:00003AE4                 db  40h ; @
.rdata$r:00003AE5                 db    0
.rdata$r:00003AE6                 db    0
.rdata$r:00003AE7                 db    0
.rdata$r:00003AE8                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003AE8 _rdata$r        ends
.rdata$r:00003AE8
.rdata$r:00003AEC ; ===========================================================================
.rdata$r:00003AEC
.rdata$r:00003AEC ; Segment type: Pure data
.rdata$r:00003AEC ; Segment permissions: Read
.rdata$r:00003AEC _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003AEC                 assume cs:_rdata$r
.rdata$r:00003AEC                 ;org 3AECh
.rdata$r:00003AEC ; COMDAT (pick any)
.rdata$r:00003AEC                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00003AEC ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00003AEC ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00003864o
.rdata$r:00003AED                 db    0
.rdata$r:00003AEE                 db    0
.rdata$r:00003AEF                 db    0
.rdata$r:00003AF0                 db    0
.rdata$r:00003AF1                 db    0
.rdata$r:00003AF2                 db    0
.rdata$r:00003AF3                 db    0
.rdata$r:00003AF4                 db    0
.rdata$r:00003AF5                 db    0
.rdata$r:00003AF6                 db    0
.rdata$r:00003AF7                 db    0
.rdata$r:00003AF8                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00003AFC                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003AFC _rdata$r        ends
.rdata$r:00003AFC
.data$r:00003B00 ; ===========================================================================
.data$r:00003B00
.data$r:00003B00 ; Segment type: Pure data
.data$r:00003B00 ; Segment permissions: Read/Write
.data$r:00003B00 _data$r         segment dword public 'DATA' use32
.data$r:00003B00                 assume cs:_data$r
.data$r:00003B00                 ;org 3B00h
.data$r:00003B00 ; COMDAT (pick any)
.data$r:00003B00                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00003B00 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00003B00 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003B00                                         ; DATA XREF: .rdata$r:00003AF8o
.data$r:00003B00                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003B00                                         ; const type_info::`vftable'
.data$r:00003B04                 align 8
.data$r:00003B08 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:00003B29                 align 4
.data$r:00003B29 _data$r         ends
.data$r:00003B29
.rdata$r:00003B2C ; ===========================================================================
.rdata$r:00003B2C
.rdata$r:00003B2C ; Segment type: Pure data
.rdata$r:00003B2C ; Segment permissions: Read
.rdata$r:00003B2C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003B2C                 assume cs:_rdata$r
.rdata$r:00003B2C                 ;org 3B2Ch
.rdata$r:00003B2C ; COMDAT (pick any)
.rdata$r:00003B2C                 public ??_R3_System_error_category@std@@8
.rdata$r:00003B2C ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003B2C ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00003AFCo
.rdata$r:00003B2C                                         ; .rdata$r:00003B64o
.rdata$r:00003B2D                 db    0
.rdata$r:00003B2E                 db    0
.rdata$r:00003B2F                 db    0
.rdata$r:00003B30                 db    0
.rdata$r:00003B31                 db    0
.rdata$r:00003B32                 db    0
.rdata$r:00003B33                 db    0
.rdata$r:00003B34                 db    3
.rdata$r:00003B35                 db    0
.rdata$r:00003B36                 db    0
.rdata$r:00003B37                 db    0
.rdata$r:00003B38                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00003B38 _rdata$r        ends
.rdata$r:00003B38
.rdata$r:00003B3C ; ===========================================================================
.rdata$r:00003B3C
.rdata$r:00003B3C ; Segment type: Pure data
.rdata$r:00003B3C ; Segment permissions: Read
.rdata$r:00003B3C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003B3C                 assume cs:_rdata$r
.rdata$r:00003B3C                 ;org 3B3Ch
.rdata$r:00003B3C ; COMDAT (pick any)
.rdata$r:00003B3C                 public ??_R2_System_error_category@std@@8
.rdata$r:00003B3C ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00003B3C ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00003B3C                                         ; DATA XREF: .rdata$r:00003B38o
.rdata$r:00003B3C                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003B40                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003B44                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003B48                 db    0
.rdata$r:00003B49                 align 4
.rdata$r:00003B49 _rdata$r        ends
.rdata$r:00003B49
.rdata$r:00003B4C ; ===========================================================================
.rdata$r:00003B4C
.rdata$r:00003B4C ; Segment type: Pure data
.rdata$r:00003B4C ; Segment permissions: Read
.rdata$r:00003B4C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003B4C                 assume cs:_rdata$r
.rdata$r:00003B4C                 ;org 3B4Ch
.rdata$r:00003B4C ; COMDAT (pick any)
.rdata$r:00003B4C                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00003B4C ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003B4C ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00003B4C                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00003B4C                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00003B50                 db    2
.rdata$r:00003B51                 db    0
.rdata$r:00003B52                 db    0
.rdata$r:00003B53                 db    0
.rdata$r:00003B54                 db    0
.rdata$r:00003B55                 db    0
.rdata$r:00003B56                 db    0
.rdata$r:00003B57                 db    0
.rdata$r:00003B58                 db 0FFh
.rdata$r:00003B59                 db 0FFh
.rdata$r:00003B5A                 db 0FFh
.rdata$r:00003B5B                 db 0FFh
.rdata$r:00003B5C                 db    0
.rdata$r:00003B5D                 db    0
.rdata$r:00003B5E                 db    0
.rdata$r:00003B5F                 db    0
.rdata$r:00003B60                 db  40h ; @
.rdata$r:00003B61                 db    0
.rdata$r:00003B62                 db    0
.rdata$r:00003B63                 db    0
.rdata$r:00003B64                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003B64 _rdata$r        ends
.rdata$r:00003B64
.CRT$XCU:00003B68 ; ===========================================================================
.CRT$XCU:00003B68
.CRT$XCU:00003B68 ; Segment type: Pure data
.CRT$XCU:00003B68 ; Segment permissions: Read
.CRT$XCU:00003B68 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003B68                 assume cs:_CRT$XCU
.CRT$XCU:00003B68                 ;org 3B68h
.CRT$XCU:00003B68 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00003B6C _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00003B6C _CRT$XCU        ends
.CRT$XCU:00003B6C
.CRT$XCU:00003B70 ; ===========================================================================
.CRT$XCU:00003B70
.CRT$XCU:00003B70 ; Segment type: Pure data
.CRT$XCU:00003B70 ; Segment permissions: Read
.CRT$XCU:00003B70 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003B70                 assume cs:_CRT$XCU
.CRT$XCU:00003B70                 ;org 3B70h
.CRT$XCU:00003B70 ; COMDAT (pick associative to section at 3888)
.CRT$XCU:00003B70 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00003B70 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00003B70 _CRT$XCU        ends
.CRT$XCU:00003B70
.CRT$XCU:00003B74 ; ===========================================================================
.CRT$XCU:00003B74
.CRT$XCU:00003B74 ; Segment type: Pure data
.CRT$XCU:00003B74 ; Segment permissions: Read
.CRT$XCU:00003B74 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003B74                 assume cs:_CRT$XCU
.CRT$XCU:00003B74                 ;org 3B74h
.CRT$XCU:00003B74 ; COMDAT (pick associative to section at 388C)
.CRT$XCU:00003B74 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00003B74 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00003B74 _CRT$XCU        ends
.CRT$XCU:00003B74
.CRT$XCU:00003B78 ; ===========================================================================
.CRT$XCU:00003B78
.CRT$XCU:00003B78 ; Segment type: Pure data
.CRT$XCU:00003B78 ; Segment permissions: Read
.CRT$XCU:00003B78 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003B78                 assume cs:_CRT$XCU
.CRT$XCU:00003B78                 ;org 3B78h
.CRT$XCU:00003B78 ; COMDAT (pick associative to section at 3890)
.CRT$XCU:00003B78 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00003B78 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00003B78 _CRT$XCU        ends
.CRT$XCU:00003B78
.CRT$XCU:00003B7C ; ===========================================================================
.CRT$XCU:00003B7C
.CRT$XCU:00003B7C ; Segment type: Pure data
.CRT$XCU:00003B7C ; Segment permissions: Read
.CRT$XCU:00003B7C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003B7C                 assume cs:_CRT$XCU
.CRT$XCU:00003B7C                 ;org 3B7Ch
.CRT$XCU:00003B7C ; COMDAT (pick associative to section at 3898)
.CRT$XCU:00003B7C ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00003B7C ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00003B7C _CRT$XCU        ends
.CRT$XCU:00003B7C
.CRT$XCU:00003B80 ; ===========================================================================
.CRT$XCU:00003B80
.CRT$XCU:00003B80 ; Segment type: Pure data
.CRT$XCU:00003B80 ; Segment permissions: Read
.CRT$XCU:00003B80 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003B80                 assume cs:_CRT$XCU
.CRT$XCU:00003B80                 ;org 3B80h
.CRT$XCU:00003B80 ; COMDAT (pick associative to section at 389C)
.CRT$XCU:00003B80 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00003B80 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00003B80 _CRT$XCU        ends
.CRT$XCU:00003B80
.CRT$XCU:00003B84 ; ===========================================================================
.CRT$XCU:00003B84
.CRT$XCU:00003B84 ; Segment type: Pure data
.CRT$XCU:00003B84 ; Segment permissions: Read
.CRT$XCU:00003B84 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003B84                 assume cs:_CRT$XCU
.CRT$XCU:00003B84                 ;org 3B84h
.CRT$XCU:00003B84 ; COMDAT (pick associative to section at 3930)
.CRT$XCU:00003B84 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00003B84 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00003B84 _CRT$XCU        ends
.CRT$XCU:00003B84
.CRT$XCU:00003B88 ; ===========================================================================
.CRT$XCU:00003B88
.CRT$XCU:00003B88 ; Segment type: Pure data
.CRT$XCU:00003B88 ; Segment permissions: Read
.CRT$XCU:00003B88 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00003B88                 assume cs:_CRT$XCU
.CRT$XCU:00003B88                 ;org 3B88h
.CRT$XCU:00003B88 ; COMDAT (pick associative to section at 3934)
.CRT$XCU:00003B88 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00003B88 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00003B88 _CRT$XCU        ends
.CRT$XCU:00003B88
UNDEF:00003B90 ; ===========================================================================
UNDEF:00003B90
UNDEF:00003B90 ; Segment type: Externs
UNDEF:00003B90 ; UNDEF
UNDEF:00003B90                 extrn __purecall:near   ; DATA XREF: .rdata:000037DCo
UNDEF:00003B90                                         ; .rdata:000037E0o
UNDEF:00003B94 ; void *__cdecl operator new(unsigned int)
UNDEF:00003B94                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00003B94                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p ...
UNDEF:00003B98 ; void __cdecl operator delete(void *)
UNDEF:00003B98                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:00003B98                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:00003B9C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:00003B9C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:00003B9C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00003BA0 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00003BA0                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00003BA0                                         ; _wmemcpy+11p
UNDEF:00003BA4 ; size_t __cdecl strlen(const char *Str)
UNDEF:00003BA4                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00003BA8 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00003BA8                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00003BA8                                         ; _wmemmove+11p
UNDEF:00003BAC ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:00003BAC                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:00003BB0 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00003BB0                 extrn __imp__SendMessageW@16:near
UNDEF:00003BB0                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+F6p
UNDEF:00003BB0                                         ; AboutDlg::run_dlgProc(uint,uint,long)+12Ap
UNDEF:00003BB0                                         ; DATA XREF: ...
UNDEF:00003BB4 ; HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem)
UNDEF:00003BB4                 extrn __imp__GetDlgItem@8:near
UNDEF:00003BB4                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+77p
UNDEF:00003BB4                                         ; AboutDlg::run_dlgProc(uint,uint,long)+114p ...
UNDEF:00003BB8 ; BOOL __stdcall EnableWindow(HWND hWnd, BOOL bEnable)
UNDEF:00003BB8                 extrn __imp__EnableWindow@8:near
UNDEF:00003BB8                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+102p
UNDEF:00003BB8                                         ; DATA XREF: AboutDlg::run_dlgProc(uint,uint,long)+102r
UNDEF:00003BBC ; HANDLE __stdcall LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad)
UNDEF:00003BBC                 extrn __imp__LoadImageW@24:near
UNDEF:00003BBC                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+232p
UNDEF:00003BBC                                         ; DATA XREF: AboutDlg::run_dlgProc(uint,uint,long)+232r
UNDEF:00003BC0 ; BOOL __stdcall DrawIconEx(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags)
UNDEF:00003BC0                 extrn __imp__DrawIconEx@36:near
UNDEF:00003BC0                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+25Ap
UNDEF:00003BC0                                         ; DATA XREF: AboutDlg::run_dlgProc(uint,uint,long)+25Ar
UNDEF:00003BC4 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00003BC4                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00003BC4                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:00003BC8 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00003BC8                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00003BC8                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:00003BC8                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:00003BCC                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00003BD0 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00003BD0                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00003BD0                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00003BD0                                         ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+16p
UNDEF:00003BD4 ; void __cdecl std::_Xbad_alloc()
UNDEF:00003BD4                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00003BD4                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_966p
UNDEF:00003BD4                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_9A8p ...
UNDEF:00003BD8 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00003BD8                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00003BD8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00003BD8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp
UNDEF:00003BDC ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00003BDC                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00003BDC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00003BDC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp
UNDEF:00003BE0 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003BE0                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003BE0                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00003BE4 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00003BE4                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00003BE4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00003BE4                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00003BE8 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00003BE8                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00003BE8                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00003BEC ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003BEC                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003BEC                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00003BF0 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003BF0                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003BF0                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00003BF4 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003BF4                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003BF4                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00003BF8 ; const wchar_t *__thiscall WcharMbcsConvertor::char2wchar(WcharMbcsConvertor *__hidden this, const char *, unsigned int, int, int *, int *)
UNDEF:00003BF8                 extrn ?char2wchar@WcharMbcsConvertor@@QAEPB_WPBDIHPAH1@Z:near
UNDEF:00003BF8                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+ACp
UNDEF:00003BF8                                         ; AboutDlg::run_dlgProc(uint,uint,long)+D7p
UNDEF:00003BFC ; void __thiscall URLCtrl::create(URLCtrl *__hidden this, HWND, wchar_t *, unsigned __int32)
UNDEF:00003BFC                 extrn ?create@URLCtrl@@QAEXPAUHWND__@@PA_WK@Z:near
UNDEF:00003BFC                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+172p
UNDEF:00003BFC                                         ; AboutDlg::run_dlgProc(uint,uint,long)+1B9p
UNDEF:00003C00 ; void __thiscall StaticDialog::goToCenter(StaticDialog *__hidden this)
UNDEF:00003C00                 extrn ?goToCenter@StaticDialog@@QAEXXZ:near
UNDEF:00003C00                                         ; CODE XREF: AboutDlg::doDialog(void)+34p
UNDEF:00003C04 ; __fastcall __security_check_cookie(x)
UNDEF:00003C04                 extrn @__security_check_cookie@4:near
UNDEF:00003C04                                         ; CODE XREF: AboutDlg::run_dlgProc(uint,uint,long)+2AAp
UNDEF:00003C04                                         ; __ehhandler$?run_dlgProc@AboutDlg@@MAGHIIJ@Z+Cp ...
UNDEF:00003C08 ; __stdcall _CxxThrowException(x, x)
UNDEF:00003C08                 extrn __CxxThrowException@8:near
UNDEF:00003C08                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:00003C08                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1+10p
UNDEF:00003C0C                 extrn ___CxxFrameHandler3:near
UNDEF:00003C0C                                         ; CODE XREF: __ehhandler$?run_dlgProc@AboutDlg@@MAGHIIJ@Z+20j
UNDEF:00003C0C                                         ; __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j ...
UNDEF:00003C10 ; const type_info::`vftable'
UNDEF:00003C10                 extrn ??_7type_info@@6B@:near
UNDEF:00003C10                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:00003C10                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00003C14 ; protected: static class WcharMbcsConvertor * WcharMbcsConvertor::_pSelf
UNDEF:00003C14                 extrn ?_pSelf@WcharMbcsConvertor@@1PAV1@A:near
UNDEF:00003C14                                         ; DATA XREF: WcharMbcsConvertor::getInstance(void)+3r
UNDEF:00003C18 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:00003C18                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:00003C18                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:00003C1C                 extrn ___security_cookie:near
UNDEF:00003C1C                                         ; DATA XREF: AboutDlg::run_dlgProc(uint,uint,long)+14r
UNDEF:00003C1C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+14r ...
UNDEF:00003C20                 extrn __fltused:near
UNDEF:00003C20
UNDEF:00003C20
UNDEF:00003C20                 end